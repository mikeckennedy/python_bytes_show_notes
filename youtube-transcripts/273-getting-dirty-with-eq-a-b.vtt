WEBVTT

00:00:00.000 --> 00:00:07.900
Hey, everybody. Thanks for joining us on a slightly different time. But things are good.


00:00:07.900 --> 00:00:08.900
Good to see you, Michael.


00:00:08.900 --> 00:00:12.600
Yeah, great to see you. Hello, YouTube.


00:00:12.600 --> 00:00:16.660
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly


00:00:16.660 --> 00:00:24.180
to your earbuds. This is episode 273, recorded March 1st, 2022. And I'm Brian Okken.


00:00:24.180 --> 00:00:25.180
I'm Michael Kennedy.


00:00:25.180 --> 00:00:28.020
- Well, welcome Michael.


00:00:28.020 --> 00:00:29.740
It's good to have us here.


00:00:29.740 --> 00:00:32.280
- It's great to see you as always.


00:00:32.280 --> 00:00:36.000
It feels like spring is almost here.


00:00:36.000 --> 00:00:37.380
It's March, I can't believe it.


00:00:37.380 --> 00:00:39.140
So pretty awesome.


00:00:39.140 --> 00:00:40.840
Fun to be talking Python with you.


00:00:40.840 --> 00:00:44.620
- Yeah, so should we kick it off with your first item?


00:00:44.620 --> 00:00:45.640
- Let's do it.


00:00:45.640 --> 00:00:51.260
I'm a big fan of science and math and all those things.


00:00:51.260 --> 00:00:52.980
And I came across this article


00:00:52.980 --> 00:00:54.420
because I was reading about science,


00:00:54.420 --> 00:00:56.460
not because I was reading about Python,


00:00:56.460 --> 00:00:59.300
but then I thought, oh, there has to be a Python story here.


00:00:59.300 --> 00:01:01.400
Let's get into it and see if I can track it down.


00:01:01.400 --> 00:01:03.320
And wow, was it not easy to find.


00:01:03.320 --> 00:01:04.160
So here's the deal.


00:01:04.160 --> 00:01:07.540
I saw an article over on sciencealert.com


00:01:07.540 --> 00:01:11.260
called "Physics Breakthrough as AI Successfully Controls


00:01:11.260 --> 00:01:14.940
Plasma in a Nuclear Fusion Experiment."


00:01:14.940 --> 00:01:15.900
- That's so cool.


00:01:15.900 --> 00:01:16.740
- It's amazing, right?


00:01:16.740 --> 00:01:17.940
So let me put a few things together here.


00:01:17.940 --> 00:01:20.100
Nuclear fusion, not fission,


00:01:20.100 --> 00:01:21.980
that's the kind of nuclear we want.


00:01:21.980 --> 00:01:26.060
that is harnessing the sun with no negative effects


00:01:26.060 --> 00:01:30.020
to like turn hydrogen into helium and so on, right?


00:01:30.020 --> 00:01:31.880
If we could harness that,


00:01:31.880 --> 00:01:35.840
that's like free, super easy energy forever.


00:01:35.840 --> 00:01:37.060
It's incredible, right?


00:01:37.060 --> 00:01:39.620
So people have been working on this for a long time.


00:01:39.620 --> 00:01:42.860
The way that I understand,


00:01:42.860 --> 00:01:47.440
which is probably pretty piecemeal that it works


00:01:47.440 --> 00:01:50.100
is you put some kind of thing,


00:01:50.100 --> 00:01:53.820
some kind of a material like hydrogen


00:01:53.820 --> 00:01:54.760
or something in the middle,


00:01:54.760 --> 00:01:57.780
and then you blast it with tons of energy,


00:01:57.780 --> 00:01:59.140
but then it creates this plasma.


00:01:59.140 --> 00:02:01.980
You've got to control with lasers and magnets


00:02:01.980 --> 00:02:06.360
on how you basically keep the pressure high enough


00:02:06.360 --> 00:02:07.940
in addition to just the heat


00:02:07.940 --> 00:02:10.560
to actually make the fusion work, right?


00:02:10.560 --> 00:02:13.700
So there's been some success like,


00:02:13.700 --> 00:02:16.140
"Hey, we got fusion to work for a while.


00:02:16.140 --> 00:02:17.860
It just took more energy than it put out."


00:02:17.860 --> 00:02:20.480
So, you know, it's not a super great power plant,


00:02:20.480 --> 00:02:23.840
but it did do the science thing, right?


00:02:23.840 --> 00:02:24.680
- Yeah.


00:02:24.680 --> 00:02:25.520
- So here's the deal.


00:02:25.520 --> 00:02:28.960
This article says they've used artificial intelligence


00:02:28.960 --> 00:02:31.680
to teach it how to make instantaneous


00:02:31.680 --> 00:02:35.360
or near instantaneous adjustments to the magnetic field


00:02:35.360 --> 00:02:40.360
and the lasers in order to actually get better results


00:02:40.360 --> 00:02:41.780
with fusion, right?


00:02:41.780 --> 00:02:43.720
So take it farther along.


00:02:43.720 --> 00:02:46.320
And it says, "In a joint effort,


00:02:46.320 --> 00:02:52.000
the Swiss Plasma Center and Artificial Intelligence Research Company DeepMind.


00:02:52.000 --> 00:02:58.320
They used deep reinforcement learning to study the nuances of plasma behavior and control inside


00:02:58.320 --> 00:03:05.680
a fusion tokamak. That's the donut shaped thing that where the reaction happens. And they're able


00:03:05.680 --> 00:03:13.440
to make a bunch of small adjustments really quickly in order to get better results. And it's


00:03:13.440 --> 00:03:16.560
It's pretty wild that they did that with AI, isn't it?


00:03:16.560 --> 00:03:18.800
- Yeah, there's definitely Python in there somewhere.


00:03:18.800 --> 00:03:19.720
You just know it.


00:03:19.720 --> 00:03:21.560
- Exactly, so I'm like, all right, where is this?


00:03:21.560 --> 00:03:23.980
So I went through and they talk about the findings


00:03:23.980 --> 00:03:26.800
being in nature, some of the articles


00:03:26.800 --> 00:03:27.640
that they're referencing.


00:03:27.640 --> 00:03:32.280
So there's some like deep, as in not super engaging


00:03:32.280 --> 00:03:34.680
sort of scientific articles, like the traditional


00:03:34.680 --> 00:03:37.000
academic style of writing that you gotta dive into


00:03:37.000 --> 00:03:38.280
and then like follow a bunch of links.


00:03:38.280 --> 00:03:43.160
But eventually in there, you will find that there is some,


00:03:43.160 --> 00:03:48.160
cool science stuff going on and Python is at the heart of it.


00:03:48.160 --> 00:03:52.320
So it's probably not worth going into too much of the details


00:03:52.320 --> 00:03:54.760
of how it's actually happening,


00:03:54.760 --> 00:03:57.520
but it's the Python side of things.


00:03:57.520 --> 00:03:59.280
But I just thought it was super cool that,


00:03:59.280 --> 00:04:01.480
well, here's one of the most exciting things happening


00:04:01.480 --> 00:04:04.800
in energy and for the climate and for all sorts of things.


00:04:04.800 --> 00:04:05.640
- Yeah.


00:04:05.640 --> 00:04:09.240
- And AI and Python are pushing it forward, that's crazy.


00:04:09.240 --> 00:04:11.200
- And that's what we need for a Mr. Fusion


00:04:11.200 --> 00:04:15.440
so that we can make flying cars and time traveling cars too.


00:04:15.440 --> 00:04:16.280
- Exactly.


00:04:16.280 --> 00:04:18.080
I mean, Marty McFly and Doc,


00:04:18.080 --> 00:04:20.320
they go and they throw their banana peel


00:04:20.320 --> 00:04:21.740
on the back of the DeLorean, right?


00:04:21.740 --> 00:04:24.040
You've got to have one of these token mucks to make it roll


00:04:24.040 --> 00:04:25.520
and got to have Python in the car.


00:04:25.520 --> 00:04:26.780
Come on.


00:04:26.780 --> 00:04:27.620
- Obviously.


00:04:27.620 --> 00:04:28.460
So, cool.


00:04:28.460 --> 00:04:29.280
- Obviously.


00:04:29.280 --> 00:04:30.120
(laughing)


00:04:30.120 --> 00:04:32.700
All right, well, take us back to something more concrete.


00:04:32.700 --> 00:04:33.600
- Well, okay.


00:04:33.600 --> 00:04:34.840
So I'm pretty excited about this.


00:04:34.840 --> 00:04:38.880
It's a minor thing, but maybe not too minor.


00:04:38.880 --> 00:04:43.880
PEP 680 has been accepted standards track for Python 311.


00:04:43.880 --> 00:04:47.760
PEP 680 is Tomlib support.


00:04:47.760 --> 00:04:51.320
So support for parsing Toml in the standard library.


00:04:51.320 --> 00:04:52.160
We haven't had it yet.


00:04:52.160 --> 00:04:53.000
- That's awesome.


00:04:53.000 --> 00:04:53.840
- So it-


00:04:53.840 --> 00:04:56.400
- We've got JSON, we've got CSV, why not?


00:04:56.400 --> 00:04:57.480
We got XML.


00:04:57.480 --> 00:04:59.160
- Well, and one of the,


00:04:59.160 --> 00:05:01.600
and now that we,


00:05:01.600 --> 00:05:05.640
PEP uses Toml for pyproject.toml,


00:05:05.640 --> 00:05:08.960
But anyway, so we kind of need,


00:05:08.960 --> 00:05:11.260
I think it'd be cool to have in the standard library.


00:05:11.260 --> 00:05:13.860
I think it's fine to have other outside supports.


00:05:13.860 --> 00:05:18.400
So what they're doing is, and if people don't,


00:05:18.400 --> 00:05:19.600
there's some rationale here,


00:05:19.600 --> 00:05:22.640
but just think it's easier than normal.


00:05:22.640 --> 00:05:27.280
So TML is, I like TML for, because it's just,


00:05:27.280 --> 00:05:29.320
I don't know, it's an easy format to read.


00:05:29.320 --> 00:05:32.240
It's better than any and some other stuff.


00:05:32.240 --> 00:05:33.400
- And for people who don't know,


00:05:33.400 --> 00:05:37.240
it feels any like the .ini file style


00:05:37.240 --> 00:05:38.920
where you've kind of got like section headers


00:05:38.920 --> 00:05:40.880
and then key value bits.


00:05:40.880 --> 00:05:43.960
- Yeah, and it doesn't, and often it doesn't,


00:05:43.960 --> 00:05:46.360
like you can use, you can use black


00:05:46.360 --> 00:05:48.780
and write a pyproject.toml file


00:05:48.780 --> 00:05:51.040
without even really knowing anything about toml.


00:05:51.040 --> 00:05:53.040
So it's pretty straightforward,


00:05:53.040 --> 00:05:55.560
but we didn't have a way built into the standard library


00:05:55.560 --> 00:05:56.400
to just use it.


00:05:56.400 --> 00:05:59.440
So this is this pep.


00:05:59.440 --> 00:06:00.720
One of the things there,


00:06:02.080 --> 00:06:04.840
The interesting bits about it is it's only reading.


00:06:04.840 --> 00:06:08.880
So it's only adding support for reading a TOML.


00:06:08.880 --> 00:06:12.160
So there's a load and a load S.


00:06:12.160 --> 00:06:16.440
So you can load a TOML file or you can load a string


00:06:16.440 --> 00:06:17.520
and that's it.


00:06:17.520 --> 00:06:20.920
And it outputs a dictionary.


00:06:20.920 --> 00:06:24.440
So that makes sense.


00:06:24.440 --> 00:06:27.280
You're just getting a TOML object


00:06:27.280 --> 00:06:30.740
and turning it into a dictionary so you can use it.


00:06:31.920 --> 00:06:35.840
But this is built on top of Tomly.


00:06:35.840 --> 00:06:40.840
So Tomly is being used as the library to,


00:06:40.840 --> 00:06:44.240
basically there's an open source project called Tomly,


00:06:44.240 --> 00:06:47.040
which a lot of projects are using.


00:06:47.040 --> 00:06:49.220
I think this is the one that pytest is using


00:06:49.220 --> 00:06:51.840
and quite a few projects have switched to this.


00:06:51.840 --> 00:06:53.520
It's really fast, it's nice,


00:06:53.520 --> 00:06:56.000
but it supports like writing as well, but--


00:06:56.000 --> 00:06:58.960
- Yeah, write and encode and dump S and all those things.


00:06:58.960 --> 00:07:00.600
- Yeah, right.


00:07:00.600 --> 00:07:03.100
But that's not the part that's gonna get supported.


00:07:03.100 --> 00:07:08.040
And I think that's fine to just have reading built into.


00:07:08.040 --> 00:07:12.920
- And sure, some file formats like text and CSV


00:07:12.920 --> 00:07:16.660
and whatnot, like reading and writing is super common, right?


00:07:16.660 --> 00:07:19.600
But these are way more likely to be used


00:07:19.600 --> 00:07:22.560
as configuration files that drive app startup


00:07:22.560 --> 00:07:24.040
and like hide secrets.


00:07:24.040 --> 00:07:25.200
You know, you put your secrets in there


00:07:25.200 --> 00:07:27.440
and don't put in Git or something like that, whatever.


00:07:27.440 --> 00:07:30.320
Those are the kind of use cases I would see.


00:07:30.320 --> 00:07:32.620
And so in that case, reading seems fine.


00:07:32.620 --> 00:07:33.820
You could always add writing later.


00:07:33.820 --> 00:07:36.320
You just can't take it away if you add it too soon.


00:07:36.320 --> 00:07:38.340
- Right, right.


00:07:38.340 --> 00:07:41.720
But also like, I don't,


00:07:41.720 --> 00:07:44.940
and I'm sure there are reasons to need to write it,


00:07:44.940 --> 00:07:47.440
but I don't.


00:07:47.440 --> 00:07:50.340
You know, it's mostly people write it


00:07:50.340 --> 00:07:51.780
and computers read it sort of thing.


00:07:51.780 --> 00:07:53.020
- Yeah, exactly.


00:07:53.020 --> 00:07:55.460
Some kind of editor writes it and then you read it.


00:07:55.460 --> 00:07:56.300
- Yeah.


00:07:57.180 --> 00:07:58.580
- Fantastic.


00:07:58.580 --> 00:07:59.420
All right, well, cool.


00:07:59.420 --> 00:08:01.640
Very nice to see that one coming along.


00:08:01.640 --> 00:08:06.060
Alvaro out in the audience, hello there,


00:08:06.060 --> 00:08:09.980
says, "TOML just reached version 1.0 not so long ago."


00:08:09.980 --> 00:08:13.500
So maybe that also has some kind of impact


00:08:13.500 --> 00:08:14.940
on the willingness, like, all right,


00:08:14.940 --> 00:08:16.620
the file format is stable.


00:08:16.620 --> 00:08:19.180
Now we can actually start to support it in the library.


00:08:19.180 --> 00:08:20.100
- That's true.


00:08:20.100 --> 00:08:23.980
And we do support Python releases for a long time,


00:08:23.980 --> 00:08:27.380
So it probably needed to be V1 at least.


00:08:27.380 --> 00:08:31.660
- And Sam also says there's a lot of stylistic choices


00:08:31.660 --> 00:08:33.500
for how you write TOML files.


00:08:33.500 --> 00:08:36.540
Like we need a black for TOML.


00:08:36.540 --> 00:08:39.620
Not to configure black,


00:08:39.620 --> 00:08:42.340
but something that then goes against TOML files


00:08:42.340 --> 00:08:44.900
and makes them consistent.


00:08:44.900 --> 00:08:47.980
- Yeah, maybe.


00:08:47.980 --> 00:08:50.780
- Yeah, you could bake that in.


00:08:50.780 --> 00:08:52.420
All right, what have I got next here?


00:08:52.420 --> 00:08:56.040
I've got sticking on the internals here.


00:08:56.040 --> 00:08:59.240
I wanna talk about thread locals in Python.


00:08:59.240 --> 00:09:01.160
So last time we had Calvin on


00:09:01.160 --> 00:09:06.160
and I spoke about this crazy async running thing


00:09:06.160 --> 00:09:10.280
that I had built and boy, is it working well.


00:09:10.280 --> 00:09:12.160
Like I said, it is truly horrifying


00:09:12.160 --> 00:09:13.140
to think about what it's doing,


00:09:13.140 --> 00:09:15.460
but it actually works perfectly.


00:09:15.460 --> 00:09:16.760
So there it is.


00:09:16.760 --> 00:09:20.980
But one of the challenges that it has is it,


00:09:20.980 --> 00:09:24.500
It doesn't like it if you call back into it again.


00:09:24.500 --> 00:09:29.500
And I talked about the nest asyncio project last time,


00:09:29.500 --> 00:09:31.100
which maybe will solve it.


00:09:31.100 --> 00:09:33.120
I tried those and it wasn't working,


00:09:33.120 --> 00:09:35.280
but it could have been like at a different iteration


00:09:35.280 --> 00:09:36.580
before I finally realized like,


00:09:36.580 --> 00:09:39.640
no, I have to go all in on this threading,


00:09:39.640 --> 00:09:42.140
like isolate all that execution into one place


00:09:42.140 --> 00:09:44.100
where we can control it.


00:09:44.100 --> 00:09:45.180
So maybe it would work,


00:09:45.180 --> 00:09:48.980
but I just wanted to talk about thread locals in Python,


00:09:48.980 --> 00:09:51.980
which I thought were pretty easy and pretty interesting.


00:09:51.980 --> 00:09:54.540
So I've got this stuff running over there.


00:09:54.540 --> 00:09:56.740
And one thing that would be nice is each,


00:09:56.740 --> 00:09:58.860
there's different threads calling into the system


00:09:58.860 --> 00:10:01.060
to say schedule some work for me, basically.


00:10:01.060 --> 00:10:02.820
Puts it on a queue, the queue runs it on this


00:10:02.820 --> 00:10:05.760
like controlled loop, and then it sends back the result.


00:10:05.760 --> 00:10:10.580
The problem is if one function calls that to put in work,


00:10:10.580 --> 00:10:12.060
and then as part of doing that work,


00:10:12.060 --> 00:10:14.620
the function itself somewhere deep down,


00:10:14.620 --> 00:10:16.300
like wraps that around,


00:10:16.300 --> 00:10:19.300
it doesn't really like the recursion aspect very much.


00:10:19.300 --> 00:10:21.140
So what I thought is, well, how do I figure out,


00:10:21.140 --> 00:10:23.500
well, this thread has running work,


00:10:23.500 --> 00:10:28.180
and if it calls again, raise an exception and say,


00:10:28.180 --> 00:10:30.180
like, you need to adjust the way you're calling this library,


00:10:30.180 --> 00:10:31.020
it's not working right,


00:10:31.020 --> 00:10:32.980
instead of just like doing some weird thing.


00:10:32.980 --> 00:10:35.740
So what I think I might do,


00:10:35.740 --> 00:10:38.060
and I'm not totally sure it will work perfectly,


00:10:38.060 --> 00:10:42.740
but the idea is certainly useful for all sorts of things,


00:10:42.740 --> 00:10:45.300
is to use a thread local variable.


00:10:45.300 --> 00:10:47.100
Now, when I thought about thread local variables,


00:10:47.100 --> 00:10:49.340
I've used them in other languages


00:10:49.340 --> 00:10:51.300
and I had no idea how to do them in Python.


00:10:51.300 --> 00:10:54.240
It turns out to be incredibly easy.


00:10:54.240 --> 00:10:56.260
You just say, go to threading, the threading module,


00:10:56.260 --> 00:10:57.800
and you say local.


00:10:57.800 --> 00:11:00.100
That becomes like a dynamic class


00:11:00.100 --> 00:11:01.700
that you can just start assigning values to.


00:11:01.700 --> 00:11:03.540
So in the example that I'm linking to,


00:11:03.540 --> 00:11:05.400
it says you get a my data thing,


00:11:05.400 --> 00:11:09.180
which is a thread local data blob, whatever.


00:11:09.180 --> 00:11:12.200
So you could say like, my data.x equals one,


00:11:12.200 --> 00:11:14.860
my data.list equals whatever.


00:11:14.860 --> 00:11:18.300
and then that will store that data,


00:11:18.300 --> 00:11:20.940
but it will store it on a per thread basis.


00:11:20.940 --> 00:11:22.980
So each thread sees a different value.


00:11:22.980 --> 00:11:25.760
So for example, what I could do is say thread,


00:11:25.760 --> 00:11:30.020
at the beginning of the call, like I have running work,


00:11:30.020 --> 00:11:32.740
yes, at the end, roll that back.


00:11:32.740 --> 00:11:35.320
And if I ever call in to schedule some work


00:11:35.320 --> 00:11:38.160
and the thread local says, I'm doing,


00:11:38.160 --> 00:11:39.180
I have active work running,


00:11:39.180 --> 00:11:40.860
well, there's that error case that I talked about.


00:11:40.860 --> 00:11:42.140
And I don't have to do weird things


00:11:42.140 --> 00:11:45.100
like put different IDs of threads into database,


00:11:45.100 --> 00:11:47.580
into like a dictionary and then like check that


00:11:47.580 --> 00:11:48.420
and then lock it.


00:11:48.420 --> 00:11:50.340
Like also I can just say,


00:11:50.340 --> 00:11:54.500
this thread has like a running state for my little scenario.


00:11:54.500 --> 00:11:55.340
What do you think?


00:11:55.340 --> 00:11:56.700
- I think that's great.


00:11:56.700 --> 00:11:57.780
I think it's interesting.


00:11:57.780 --> 00:11:59.120
- Yeah, it is, right?


00:11:59.120 --> 00:11:59.960
- Yeah.


00:11:59.960 --> 00:12:01.740
- And it's right, not too hard.


00:12:01.740 --> 00:12:04.360
Just create one of these little local things,


00:12:04.360 --> 00:12:05.540
interact with it in a thread


00:12:05.540 --> 00:12:08.020
and each thread will have basically its own view


00:12:08.020 --> 00:12:10.260
into that data, which I think is pretty fantastic.


00:12:10.260 --> 00:12:11.340
So.


00:12:11.340 --> 00:12:15.660
- It's like a thread version namespace thing.


00:12:15.660 --> 00:12:17.180
- Yes, exactly, exactly.


00:12:17.180 --> 00:12:20.220
It's a cool little isolation without doing like locks


00:12:20.220 --> 00:12:22.740
and all sorts of weird stuff that can end up in deadlocks


00:12:22.740 --> 00:12:24.980
or slowdowns or other stuff.


00:12:24.980 --> 00:12:28.060
So anyway, if you're got scenarios


00:12:28.060 --> 00:12:28.900
where you're doing threading,


00:12:28.900 --> 00:12:29.980
and you're like, oh, it would be really great


00:12:29.980 --> 00:12:33.440
if I could dedicate some data just to this particular run


00:12:33.440 --> 00:12:35.780
and not like a global thing, check this out.


00:12:35.780 --> 00:12:38.220
It's incredibly straightforward.


00:12:38.220 --> 00:12:39.060
- Nice. - Yeah.


00:12:39.060 --> 00:12:39.900
- Nice.


00:12:39.900 --> 00:12:46.900
Oh, let me pull up one more thing before we move on, Brian.


00:12:46.900 --> 00:12:47.900
Okay.


00:12:47.900 --> 00:12:48.900
DataDog.


00:12:48.900 --> 00:13:01.900
Yes, that's also something else that's extremely easy to use.


00:13:01.900 --> 00:13:02.900
Yeah.


00:13:02.900 --> 00:13:05.820
Thank you DataDog for sponsoring this episode.


00:13:05.820 --> 00:13:11.380
Datadog is a real-time monitoring platform that unifies metrics, traces, and logs into


00:13:11.380 --> 00:13:14.180
one tightly integrated platform.


00:13:14.180 --> 00:13:20.780
Datadog APM empowers developer teams to identify anomalies, resolve issues, and improve application


00:13:20.780 --> 00:13:22.100
performance.


00:13:22.100 --> 00:13:27.220
Begin collecting stack traces, visualize them as flame graphs, and organize them into profile


00:13:27.220 --> 00:13:30.900
types such as CPU, I/O, and more.


00:13:30.900 --> 00:13:35.100
Teams can search for specific profiles, correlate them with distributed traces, and identify


00:13:35.100 --> 00:13:37.580
by slow or underperforming code


00:13:37.580 --> 00:13:39.860
for analysis and optimization.


00:13:39.860 --> 00:13:42.680
Plus with Datadog's APM live search,


00:13:42.680 --> 00:13:45.340
you can perform searches across all,


00:13:45.340 --> 00:13:48.060
across the full stream of integrated traces


00:13:48.060 --> 00:13:51.340
generated by your application over the last 15 minutes.


00:13:51.340 --> 00:13:52.760
That's cool.


00:13:52.760 --> 00:13:57.140
Try Datadog APM free with a 14 day free trial


00:13:57.140 --> 00:13:59.260
and Datadog will send you a free t-shirt.


00:13:59.260 --> 00:14:03.060
Visit pythonbytes.fm/datadog


00:14:03.060 --> 00:14:06.540
or just click the link in your podcast player show notes


00:14:06.540 --> 00:14:07.700
to get started.


00:14:07.700 --> 00:14:09.300
- Yes, thank you, Datadog.


00:14:09.300 --> 00:14:11.300
I love all the visibility into what's going on.


00:14:11.300 --> 00:14:13.780
I was just dealing with some crashes and other issues


00:14:13.780 --> 00:14:16.140
on something I was trying to roll out.


00:14:16.140 --> 00:14:19.460
And some libraries conflicting with some other library,


00:14:19.460 --> 00:14:20.300
they were fighting.


00:14:20.300 --> 00:14:22.760
And yeah, it's great to be able to just log in


00:14:22.760 --> 00:14:24.020
and see what's going on.


00:14:24.020 --> 00:14:24.940
- Yep.


00:14:24.940 --> 00:14:26.740
- Now, before we move off to ThreadLocals,


00:14:26.740 --> 00:14:29.140
quick audience question, Sam out there says,


00:14:29.140 --> 00:14:31.020
"It might be better to use context bars


00:14:31.020 --> 00:14:33.220
if you're also working with an event loop.


00:14:33.220 --> 00:14:36.260
As far as I know, context vars are the evolved version


00:14:36.260 --> 00:14:38.980
of thread locals that are aware of async too.


00:14:38.980 --> 00:14:40.800
That's very interesting.


00:14:40.800 --> 00:14:42.760
I haven't done anything with context vars,


00:14:42.760 --> 00:14:45.820
but the way I think async.io works is,


00:14:45.820 --> 00:14:47.140
even though there's a bunch of stuff running


00:14:47.140 --> 00:14:49.240
from different locations, there's one thread.


00:14:49.240 --> 00:14:50.980
So thread local is useless for that.


00:14:50.980 --> 00:14:54.160
So that's why Sam is suggesting context vars.


00:14:54.160 --> 00:14:56.520
The side that schedules the work


00:14:56.520 --> 00:14:58.800
has nothing to do with async.io in my world.


00:14:58.800 --> 00:15:00.840
So that's why I was thinking thread local.


00:15:00.840 --> 00:15:01.960
>> Yeah.


00:15:01.960 --> 00:15:05.280
>> It's a good highlight to say if you're using async,


00:15:05.280 --> 00:15:07.360
you may need something different.


00:15:07.360 --> 00:15:08.080
>> Absolutely, yeah.


00:15:08.080 --> 00:15:11.480
So thanks, Sam, for that.


00:15:11.480 --> 00:15:13.360
>> Yeah, so I'm not sure if we've really


00:15:13.360 --> 00:15:14.200
talked about it much.


00:15:14.200 --> 00:15:20.120
But I came across that article from Trey Hunter called


00:15:20.120 --> 00:15:22.120
"What is a generator function?"


00:15:22.120 --> 00:15:27.320
And like Python, especially the two to three switch,


00:15:27.320 --> 00:15:30.680
even like a dictionary, the items keyword, you know,


00:15:30.680 --> 00:15:33.720
function to get all the dictionary elements out.


00:15:33.720 --> 00:15:36.840
It doesn't return a list anymore, it returns a generator.


00:15:36.840 --> 00:15:39.880
And maybe it always did, I don't know.


00:15:39.880 --> 00:15:42.240
But there's a whole bunch of stuff that used to return lists


00:15:42.240 --> 00:15:44.120
that now return generators.


00:15:44.120 --> 00:15:46.760
And it kind of, they look, they work great.


00:15:46.760 --> 00:15:50.360
You stick them in a for loop and you're off to the races.


00:15:50.360 --> 00:15:53.400
But a lot of people are a little timid at first


00:15:53.400 --> 00:15:56.640
to try to write their own because it's a yield statement


00:15:56.640 --> 00:16:01.240
instead of a return and how do you do it?


00:16:01.240 --> 00:16:05.580
And so this is a great article by Trey to just say,


00:16:05.580 --> 00:16:08.740
here's what's going on, it's not that complicated.


00:16:08.740 --> 00:16:11.120
Generally, you just have a,


00:16:11.120 --> 00:16:14.000
you often might have a for loop within your code


00:16:14.000 --> 00:16:15.900
and instead of returning all the items,


00:16:15.900 --> 00:16:19.300
you one by one yield to the items.


00:16:19.300 --> 00:16:22.780
So Trey goes through some of the details


00:16:22.780 --> 00:16:24.540
of like how this all works.


00:16:24.540 --> 00:16:26.540
And it's pretty interesting.


00:16:26.540 --> 00:16:28.700
It's interesting for people to read through it


00:16:28.700 --> 00:16:31.540
and understand what's going on behind the scenes.


00:16:31.540 --> 00:16:35.380
So what happens is your function that has a yield in it,


00:16:35.380 --> 00:16:38.580
it will not return the item right away.


00:16:38.580 --> 00:16:42.560
When somebody calls it, it returns a generator object.


00:16:42.560 --> 00:16:46.260
And that generator object has things like next.


00:16:46.260 --> 00:16:48.740
And mostly that's what we care about.


00:16:48.740 --> 00:16:52.780
And next returns the next item that you've returned.


00:16:52.780 --> 00:16:55.540
And then once you run out of items,


00:16:55.540 --> 00:16:58.660
it raises a stop iteration exception


00:16:58.660 --> 00:17:00.100
and that's how it works.


00:17:00.100 --> 00:17:02.820
But generally we just don't care about that stuff.


00:17:02.820 --> 00:17:04.920
We just throw them in a for loop,


00:17:04.920 --> 00:17:08.580
but it is interesting to learn some of the details around it.


00:17:08.580 --> 00:17:10.820
- Yeah, they do seem mysterious and tricky,


00:17:10.820 --> 00:17:12.780
but they're super powerful.


00:17:12.780 --> 00:17:14.740
The more data that you have,


00:17:14.740 --> 00:17:17.380
the way better idea it is to not load it all


00:17:17.380 --> 00:17:19.140
into memory at once.


00:17:19.140 --> 00:17:23.340
- Yeah, and you can do some fun things like chunking.


00:17:23.340 --> 00:17:28.060
You can, like if you're returning like your caller,


00:17:28.060 --> 00:17:30.300
like let's say, and these are fun things to do with this.


00:17:30.300 --> 00:17:34.180
So let's say you're reading from an API or from a file


00:17:34.180 --> 00:17:36.500
or from a device or something.


00:17:36.500 --> 00:17:41.320
And it has, you read like a big chunk of things,


00:17:41.320 --> 00:17:43.940
like 20 of them or 256 or something like that,


00:17:43.940 --> 00:17:47.860
a whole bunch of data at once, but then your caller item,


00:17:47.860 --> 00:17:50.580
your caller really only wants one at a time.


00:17:50.580 --> 00:17:53.060
Within your function, your generator function,


00:17:53.060 --> 00:17:55.180
You can do fancy stuff like read a whole bunch


00:17:55.180 --> 00:17:57.540
and then just meter those out.


00:17:57.540 --> 00:18:00.580
And when then that's empty, you go and read some more


00:18:00.580 --> 00:18:02.420
and have intermittent reads.


00:18:02.420 --> 00:18:03.780
And this will save time for,


00:18:03.780 --> 00:18:07.620
especially when you're not reading everything often.


00:18:07.620 --> 00:18:10.300
Sometimes the caller will break and not utilize everything.


00:18:10.300 --> 00:18:12.540
So that's definitely where,


00:18:12.540 --> 00:18:15.560
and they're a lot more efficient on memory too.


00:18:15.560 --> 00:18:16.640
So if you're, like you said,


00:18:16.640 --> 00:18:18.560
if it's huge amounts of things,


00:18:18.560 --> 00:18:21.380
it might be either for memory reasons or for speed reasons.


00:18:21.380 --> 00:18:22.220
These are great.


00:18:22.220 --> 00:18:23.300
- Yeah, even computational,


00:18:23.300 --> 00:18:27.180
like suppose you want a list of Pydantic objects back


00:18:27.180 --> 00:18:29.260
and you're like reading some massive CSV


00:18:29.260 --> 00:18:33.260
and taking each row and star star value in there somehow.


00:18:33.260 --> 00:18:41.540
That's the actual creation of the Pydantic object


00:18:41.540 --> 00:18:43.220
if there was like a million of them.


00:18:43.220 --> 00:18:45.860
Forget memory, like even just the computation is expensive.


00:18:45.860 --> 00:18:47.980
So if you only want the first 20,


00:18:47.980 --> 00:18:49.180
like you can only pay the price


00:18:49.180 --> 00:18:51.060
of like initializing the first 20.


00:18:51.060 --> 00:18:53.260
So there's all sorts of good reasons, yeah.


00:18:53.260 --> 00:18:55.260
- Okay.


00:18:55.260 --> 00:18:59.780
- I do want to just say one thing about generators


00:18:59.780 --> 00:19:02.280
that I wish there was like a slightly,


00:19:02.280 --> 00:19:05.860
maybe some kind of behavior could be added,


00:19:05.860 --> 00:19:06.900
which would be fantastic.


00:19:06.900 --> 00:19:10.820
So generators can't be reused, right?


00:19:10.820 --> 00:19:12.380
So if I get a result back from a function,


00:19:12.380 --> 00:19:14.300
I try to, and I wanna ask you a question,


00:19:14.300 --> 00:19:17.040
like, were there any items resolved in here?


00:19:17.040 --> 00:19:18.940
And then loop over them if there were.


00:19:19.940 --> 00:19:21.200
you kind of broke it, right?


00:19:21.200 --> 00:19:22.240
You pulled the first one off


00:19:22.240 --> 00:19:24.900
and then the next thing you work with is like


00:19:24.900 --> 00:19:27.860
index one through N rather than zero through N,


00:19:27.860 --> 00:19:30.580
which is a problem.


00:19:30.580 --> 00:19:32.440
So sometimes you need to turn them to a list.


00:19:32.440 --> 00:19:36.820
It'd be cool if there was like a dot to list on a generator


00:19:36.820 --> 00:19:38.460
instead of having to call list on it, right?


00:19:38.460 --> 00:19:40.540
Just like a way as an expression to kind of like,


00:19:40.540 --> 00:19:43.300
I'm calling this and it's sort of a data science flow.


00:19:43.300 --> 00:19:46.020
I want all one expression and turn this generator


00:19:46.020 --> 00:19:47.740
into this other thing that I need to pass along.


00:19:47.740 --> 00:19:49.580
That would be fun.


00:19:49.580 --> 00:19:56.020
>> Yeah. So a question out in the audience that maybe


00:19:56.020 --> 00:20:01.380
the dictionary items and keys return something different,


00:20:01.380 --> 00:20:06.700
but Sam Morley says they return special generators,


00:20:06.700 --> 00:20:08.660
special kinds of generators.


00:20:08.660 --> 00:20:09.300
>> Yeah.


00:20:09.300 --> 00:20:10.140
>> Thanks, Sam.


00:20:10.140 --> 00:20:12.780
>> Cool, indeed. All right.


00:20:12.780 --> 00:20:14.540
Well, what if I got,


00:20:14.540 --> 00:20:17.540
next, I think I just closed it.


00:20:17.540 --> 00:20:22.540
Now, would it really be an episode if we didn't talk about Will McGugan in some way or another?


00:20:22.540 --> 00:20:26.300
So we got him on deck twice, but we're going to start with just something he recommended


00:20:26.300 --> 00:20:27.780
to us.


00:20:27.780 --> 00:20:33.500
That's actually by Sam Colvin, who is the creator of Pydantic.


00:20:33.500 --> 00:20:37.380
And I don't know if you're not sure if you're ready for this, Brian, but this is a little


00:20:37.380 --> 00:20:39.540
bit dirty.


00:20:39.540 --> 00:20:40.940
It's called Dirty Equals.


00:20:40.940 --> 00:20:45.940
And the idea is to abuse the dunder EQ method,


00:20:45.940 --> 00:20:49.580
mostly around unit testing,


00:20:49.580 --> 00:20:53.980
to make test cases and assertions


00:20:53.980 --> 00:20:56.440
and other things you might want to test


00:20:56.440 --> 00:20:59.380
more declarative and less imperative.


00:20:59.380 --> 00:21:03.100
So, that all sounds like fun, but how about an example?


00:21:03.100 --> 00:21:04.980
So it starts out with a trivial example.


00:21:04.980 --> 00:21:07.420
It says, okay, from this library,


00:21:07.420 --> 00:21:10.180
you can import something called is positive.


00:21:10.180 --> 00:21:13.580
So then you could assert one or like some number


00:21:13.580 --> 00:21:17.220
and whatever, one equal equal is positive.


00:21:17.220 --> 00:21:19.300
That's true, that assert passes.


00:21:19.300 --> 00:21:22.500
Negative two equal equal is positive, fails.


00:21:22.500 --> 00:21:24.940
Okay? - Okay.


00:21:24.940 --> 00:21:26.640
- How does that strike you, Brian?


00:21:26.640 --> 00:21:28.700
We're building on that. - That's weird.


00:21:28.700 --> 00:21:29.520
- We're building blocks.


00:21:29.520 --> 00:21:33.420
This is like a Lego piece, not the whole X-Wing fighter.


00:21:33.420 --> 00:21:34.260
Okay?


00:21:34.260 --> 00:21:36.860
But anyway, so that's the building block, right?


00:21:36.860 --> 00:21:39.180
Like take something and instead of saying,


00:21:39.180 --> 00:21:43.220
yes, it's exactly equal, implement the dunder equal method


00:21:43.220 --> 00:21:46.780
say in the is positive class to like take the value,


00:21:46.780 --> 00:21:47.700
make sure it's a number,


00:21:47.700 --> 00:21:49.540
then check whether it's greater than zero, right?


00:21:49.540 --> 00:21:50.860
That kind of thing.


00:21:50.860 --> 00:21:53.980
I don't know if that includes zero, but anyway.


00:21:53.980 --> 00:21:55.820
But then you can get more interesting things


00:21:55.820 --> 00:21:57.740
like so you could go to a database


00:21:57.740 --> 00:22:00.540
and if you do a query against the database,


00:22:00.540 --> 00:22:04.300
you get, I think in the case that's up there,


00:22:04.300 --> 00:22:05.540
I think you get a tuple back.


00:22:05.540 --> 00:22:08.340
It depends on what you set the row factory to be, I suppose.


00:22:08.340 --> 00:22:13.340
So anyway, you get a tuple back of results.


00:22:13.340 --> 00:22:14.860
It looks like maybe this is a dictionary.


00:22:14.860 --> 00:22:19.620
Anyway, so then you can create a dictionary


00:22:19.620 --> 00:22:23.540
that has attributes that are like the result you want.


00:22:23.540 --> 00:22:24.420
They can either be equal


00:22:24.420 --> 00:22:26.920
or they can be things like this is positive.


00:22:26.920 --> 00:22:30.920
So in this case, we're doing a query against the database.


00:22:30.920 --> 00:22:37.500
And then we're, it looks like there's maybe needs


00:22:37.500 --> 00:22:39.540
be like a first one anyway.


00:22:39.540 --> 00:22:41.180
It says, all right, what we're gonna do is we're gonna do


00:22:41.180 --> 00:22:45.140
equal equal that the ID.


00:22:45.140 --> 00:22:48.400
So we'll create a dictionary ID colon is positive int,


00:22:48.400 --> 00:22:51.440
username colon Sam Colvin.


00:22:51.440 --> 00:22:53.060
So that's an actual equality,


00:22:53.060 --> 00:22:55.420
like the username has to be Samuel here.


00:22:55.420 --> 00:22:56.260
- Okay.


00:22:56.260 --> 00:22:57.080
- Yeah.


00:22:57.080 --> 00:22:58.860
And then the avatar is a string


00:22:58.860 --> 00:23:00.500
that matches a regular expression.


00:23:00.500 --> 00:23:03.580
That's like a some number slash PNG.


00:23:03.580 --> 00:23:05.540
The settings has to be a JSON thing


00:23:05.540 --> 00:23:08.700
where inside the settings, it's got some JSON values


00:23:08.700 --> 00:23:10.260
that you might test for.


00:23:10.260 --> 00:23:15.260
And is created now, is now with some level of variation,


00:23:15.260 --> 00:23:17.440
like some level of precision


00:23:17.440 --> 00:23:18.700
that you're willing to work with, right?


00:23:18.700 --> 00:23:21.460
'Cause obviously you run the database query


00:23:21.460 --> 00:23:22.700
and then you get the result,


00:23:22.700 --> 00:23:26.300
but it's like very near, nearly now, right?


00:23:26.300 --> 00:23:29.460
It's like the almost equals and float type of stuff.


00:23:29.460 --> 00:23:30.820
That's pretty cool, right?


00:23:34.220 --> 00:23:35.620
Do I need to answer?


00:23:35.620 --> 00:23:36.900
I mean, I could see--


00:23:36.900 --> 00:23:38.100
- No, share your thoughts.


00:23:38.100 --> 00:23:39.020
Yeah.


00:23:39.020 --> 00:23:44.020
- But I don't know, it's the API is a little odd to me,


00:23:44.020 --> 00:23:45.100
but yeah.


00:23:45.100 --> 00:23:49.780
- Okay, yeah, I think it's definitely an interesting idea.


00:23:49.780 --> 00:23:51.080
It's definitely different.


00:23:51.080 --> 00:23:56.020
Pydantic is often about,


00:23:56.020 --> 00:23:57.980
I know it's not Pydantic, but it's by the creator.


00:23:57.980 --> 00:24:01.620
Pydantic is often about given some data


00:24:01.620 --> 00:24:04.680
that kind of matches, can it be made into that thing?


00:24:04.680 --> 00:24:09.180
And I feel like this kind of testing is in the same vein


00:24:09.180 --> 00:24:12.460
as what you might get working with Pydantic and data.


00:24:12.460 --> 00:24:17.260
- Yeah, well, it's definitely terse and useful.


00:24:17.260 --> 00:24:21.300
And I could totally get used to it.


00:24:21.300 --> 00:24:26.300
If this is a pretty condensed way to compare,


00:24:27.020 --> 00:24:31.660
to see if everything matches this protocol.


00:24:31.660 --> 00:24:32.500
- Yeah, yeah.


00:24:32.500 --> 00:24:35.020
So Sergey in the audience has like sort of


00:24:35.020 --> 00:24:38.660
the alternative perspective could be,


00:24:38.660 --> 00:24:40.580
you could just write multiple assert statements.


00:24:40.580 --> 00:24:41.820
Instead of creating a dictionary


00:24:41.820 --> 00:24:44.500
that represents everything, you could say,


00:24:44.500 --> 00:24:49.460
like get the record back and assert that,


00:24:49.460 --> 00:24:51.340
you'll get the first value out and assert on it.


00:24:51.340 --> 00:24:53.020
Then get the username out and assert,


00:24:53.020 --> 00:24:56.460
and get the avatar and assert on it and so on.


00:24:56.460 --> 00:24:58.820
And it's sort of an intermediate view story


00:24:58.820 --> 00:25:03.180
where you use the testing libraries, the testing classes,


00:25:03.180 --> 00:25:05.820
but sort of more explicit.


00:25:05.820 --> 00:25:06.940
So. - Right.


00:25:06.940 --> 00:25:08.820
And one of the reasons why a lot of people,


00:25:08.820 --> 00:25:10.620
there's a couple of reasons why


00:25:10.620 --> 00:25:13.620
to not use more than one assert,


00:25:13.620 --> 00:25:16.020
because if you were to have multiple asserts,


00:25:16.020 --> 00:25:18.340
the first one to fail stops the check.


00:25:18.340 --> 00:25:20.940
It's possible that this will tell you everything


00:25:20.940 --> 00:25:23.420
that's wrong, not just the first thing that's wrong.


00:25:23.420 --> 00:25:24.420
- Yes, exactly.


00:25:25.220 --> 00:25:28.420
And then some people are just opposed


00:25:28.420 --> 00:25:30.100
to multiple asserts per test.


00:25:30.100 --> 00:25:32.960
It's just for, I don't know.


00:25:32.960 --> 00:25:39.260
A similar thing, so I have a plugin called pytest-check,


00:25:39.260 --> 00:25:44.260
which is just, it uses checks instead of asserts


00:25:44.260 --> 00:25:47.780
so that you can have multiple checks per test.


00:25:47.780 --> 00:25:50.180
It does come up.


00:25:50.180 --> 00:25:52.500
So this is interesting.


00:25:52.500 --> 00:25:54.460
I'll definitely check it out and play with it.


00:25:54.460 --> 00:25:57.420
- Yeah, another benefit of being able to construct


00:25:57.420 --> 00:26:01.800
one of these like prototypical documents or dictionaries


00:26:01.800 --> 00:26:04.700
that then represents the declarative behavior


00:26:04.700 --> 00:26:06.900
or state that you're supposed to be testing for


00:26:06.900 --> 00:26:08.640
is you could create one of these


00:26:08.640 --> 00:26:10.060
and then use it different locations.


00:26:10.060 --> 00:26:11.500
Like, okay, when I insert a record


00:26:11.500 --> 00:26:13.600
and then I get it back out, it should be like this.


00:26:13.600 --> 00:26:18.100
But also if I call the API and it gives me something back,


00:26:18.100 --> 00:26:20.420
it should also still pass the same test.


00:26:20.420 --> 00:26:23.040
Like you could have a different parts of my app,


00:26:23.040 --> 00:26:24.880
they all need to look like this.


00:26:24.880 --> 00:26:25.720
- Yeah.


00:26:25.720 --> 00:26:27.140
- As opposed to having a bunch of tests over and over


00:26:27.140 --> 00:26:28.760
that are effectively the same.


00:26:28.760 --> 00:26:33.200
And Will is here who recommended this,


00:26:33.200 --> 00:26:35.360
suggests one of the benefits of dirty equals


00:26:35.360 --> 00:26:38.780
is that pytest will generate useful diffs from it.


00:26:38.780 --> 00:26:42.320
- Yeah, and definitely.


00:26:42.320 --> 00:26:45.800
Reasons, pytest being a reason to use something,


00:26:45.800 --> 00:26:47.440
I'm on board then, yeah, sure.


00:26:47.440 --> 00:26:49.320
- Yeah, check it out.


00:26:49.320 --> 00:26:51.880
If you do play with it, give us a report how you feel about it.


00:26:51.880 --> 00:26:56.760
Yeah, one more question from Sam, said Sam Morley.


00:26:56.760 --> 00:27:01.280
pytest already has something a bit like this with a prox,


00:27:01.280 --> 00:27:03.400
except for it's for floats, et cetera.


00:27:03.400 --> 00:27:05.800
Except for a prox is not et cetera.


00:27:05.800 --> 00:27:06.920
It's just for floats.


00:27:06.920 --> 00:27:09.120
So you can only use a prox with floats.


00:27:09.120 --> 00:27:13.440
Yeah, so we have approximate now and stuff like that.


00:27:13.440 --> 00:27:18.160
So I'll try it, especially if Will likes it,


00:27:18.160 --> 00:27:19.760
it's got to be good.


00:27:19.760 --> 00:27:22.400
>> Exactly. Awesome.


00:27:22.400 --> 00:27:24.720
All right. What's the final one you got for us here?


00:27:24.720 --> 00:27:27.360
>> Okay. This is more of a question than a,


00:27:27.360 --> 00:27:29.160
I'm not saying this is awesome,


00:27:29.160 --> 00:27:30.840
but I ran across this.


00:27:30.840 --> 00:27:36.340
Actually, I clicked on a listicle.


00:27:36.340 --> 00:27:39.040
Mike, I think there's a self-help group for that.


00:27:39.040 --> 00:27:41.960
>> Yeah. Well, we're definitely


00:27:41.960 --> 00:27:45.520
prone to clicking on the top listicles of various.


00:27:45.520 --> 00:27:49.160
>> My name is Brian and I clicked on a listicle.


00:27:49.160 --> 00:27:51.960
So the listicle was a top 10.


00:27:51.960 --> 00:27:57.480
Where we at? It was 10 tools I wish I knew when I started working with Python.


00:27:57.480 --> 00:28:00.000
And actually, it's a good list.


00:28:00.000 --> 00:28:01.640
I just knew about most of them as well.


00:28:01.640 --> 00:28:03.800
So it's a little link to it anyway.


00:28:03.800 --> 00:28:04.960
>> It's got the sound of music.


00:28:04.960 --> 00:28:05.960
It's got Jackie Chan.


00:28:05.960 --> 00:28:06.880
It's got Office Space.


00:28:06.880 --> 00:28:09.000
Come on. This is a pretty solid listicle.


00:28:09.000 --> 00:28:09.720
Let's get real.


00:28:09.720 --> 00:28:12.160
>> Then I got down to number seven and eight and I'm like,


00:28:12.160 --> 00:28:13.160
what are these things?


00:28:13.160 --> 00:28:13.960
I've never heard of them.


00:28:13.960 --> 00:28:17.000
So, Commitison and Semantic Release.


00:28:17.000 --> 00:28:24.140
So the idea, so I tried to commit with this.


00:28:24.140 --> 00:28:27.220
So Commitizen is a thing that you can say,


00:28:27.220 --> 00:28:29.740
if you install it, you can either brew install it for


00:28:29.740 --> 00:28:32.080
your everything or you can put it in a virtual environment.


00:28:32.080 --> 00:28:36.820
So that's cool. But instead of just committing,


00:28:36.820 --> 00:28:40.120
you use this to commit and it asks you questions.


00:28:40.120 --> 00:28:42.040
>> Right. Instead of typing git space commit,


00:28:42.040 --> 00:28:43.940
you type cz space commit.


00:28:43.940 --> 00:28:47.660
>> Yeah. Then it asks you a whole bunch of stuff.


00:28:47.660 --> 00:28:49.300
Was this a bug fix?


00:28:49.300 --> 00:28:50.700
Was it a feature?


00:28:50.700 --> 00:28:54.040
Then it follows on depending on what you answered.


00:28:54.040 --> 00:28:57.640
If you had a bug fix or a feature,


00:28:57.640 --> 00:28:59.180
is it a breaking feature?


00:28:59.180 --> 00:29:02.680
Basically, it's doing a whole bunch of stuff,


00:29:02.680 --> 00:29:07.980
but it's trying to do these conventional commits.


00:29:07.980 --> 00:29:10.220
We've got a link to this too.


00:29:10.220 --> 00:29:12.740
Then if you've got all this formatting,


00:29:12.740 --> 00:29:15.820
So it ends up formatting your commit message


00:29:15.820 --> 00:29:17.360
to a consistent format


00:29:17.360 --> 00:29:20.560
so that when you're reading the history and stuff,


00:29:20.560 --> 00:29:24.160
you can do a whole bunch of, it's easier, I guess.


00:29:24.160 --> 00:29:28.760
And then this tool also, this listicle also commented


00:29:28.760 --> 00:29:31.780
that you've got a semantic release,


00:29:31.780 --> 00:29:33.840
which is a Python package


00:29:33.840 --> 00:29:36.080
that I haven't got through this much,


00:29:36.080 --> 00:29:40.280
but it can take all this information from these


00:29:40.280 --> 00:29:44.280
and do some better control your semantic release notes


00:29:44.280 --> 00:29:46.040
or release, I don't know if it's release notes


00:29:46.040 --> 00:29:47.400
or just the release version.


00:29:47.400 --> 00:29:49.160
Haven't got that far into it, but.


00:29:49.160 --> 00:29:50.600
- Yeah, the committees and ask,


00:29:50.600 --> 00:29:53.640
is this like a change corresponding to semantic versions


00:29:53.640 --> 00:29:55.880
such that it should be a major change?


00:29:55.880 --> 00:29:57.980
So it'll like, it looks like it'll increment the version


00:29:57.980 --> 00:29:59.460
and stuff like that as well.


00:29:59.460 --> 00:30:01.200
- Yeah. - Yeah.


00:30:01.200 --> 00:30:05.040
- But so the, in the about for committees


00:30:05.040 --> 00:30:08.900
and says command line utility to create commits


00:30:08.900 --> 00:30:12.260
with your rules and apparently you can specify


00:30:12.260 --> 00:30:15.060
some special rules, which is good.


00:30:15.060 --> 00:30:17.520
Display information about your commits,


00:30:17.520 --> 00:30:21.980
bump the version automatically and generate a change log.


00:30:21.980 --> 00:30:22.820
That's cool.


00:30:22.820 --> 00:30:25.200
I want that might be helpful.


00:30:25.200 --> 00:30:28.200
So my questions out to the audience and everybody listening,


00:30:28.200 --> 00:30:30.780
have you used something like this?


00:30:30.780 --> 00:30:32.300
Is it useful?


00:30:32.300 --> 00:30:34.620
Is there something different than this that you recommend?


00:30:34.620 --> 00:30:37.020
And also what size of a project would this make sense


00:30:37.020 --> 00:30:38.780
for a small or medium project?


00:30:38.780 --> 00:30:39.620
- That's cool.


00:30:39.620 --> 00:30:40.440
Yeah, let us know on Twitter


00:30:40.440 --> 00:30:41.840
or at the bottom of the YouTube live stream.


00:30:41.840 --> 00:30:43.840
It's probably the best place.


00:30:43.840 --> 00:30:44.680
- Yep.


00:30:44.680 --> 00:30:46.100
- Yeah, very cool.


00:30:46.100 --> 00:30:49.160
Now, before we go on, I also have a question out to you.


00:30:49.160 --> 00:30:51.240
You can be the proxy for the audience here.


00:30:51.240 --> 00:30:54.040
Notice at the bottom it says requirements 3.6 and above.


00:30:54.040 --> 00:30:56.080
Right?


00:30:56.080 --> 00:30:56.900
- Yeah.


00:30:56.900 --> 00:30:57.740
- Python, that's not,


00:30:57.740 --> 00:30:59.760
I don't feel like that's very controversial


00:30:59.760 --> 00:31:02.120
as 3.6 is not even supported anymore, right?


00:31:02.120 --> 00:31:03.080
- Right.


00:31:03.080 --> 00:31:06.400
- So this is like every possibly supported version


00:31:06.400 --> 00:31:15.040
Python 3 this works for. What would you think if I said the requirement is


00:31:15.040 --> 00:31:21.200
this is Python 3 not Python 3, just it requires Python 3. Knowing that like


00:31:21.200 --> 00:31:27.400
that means or implying that that means supported shipping real versions of


00:31:27.400 --> 00:31:32.040
Python not Python 3.1 right because obviously Python 3.1 is no longer


00:31:32.040 --> 00:31:35.560
supported but neither is 3.5 even like could you say f strings are just in


00:31:35.560 --> 00:31:38.680
Python 3 now without worrying about the version?


00:31:38.680 --> 00:31:42.120
Or do you still need to say--


00:31:42.120 --> 00:31:42.640
3.6.


00:31:42.640 --> 00:31:43.680
3.6, 3.7.


00:31:43.680 --> 00:31:45.480
Should this be updated to be 3.7?


00:31:45.480 --> 00:31:46.160
I mean--


00:31:46.160 --> 00:31:48.000
You kind of have to.


00:31:48.000 --> 00:31:48.840
You think so?


00:31:48.840 --> 00:31:51.360
I don't know.


00:31:51.360 --> 00:31:56.160
When I say something is on Python 3,


00:31:56.160 --> 00:31:57.800
actually I don't even say that anymore.


00:31:57.800 --> 00:32:00.240
So yeah.


00:32:00.240 --> 00:32:01.800
What do you think?


00:32:01.800 --> 00:32:03.600
Well, I used it in the sense like, yeah,


00:32:03.600 --> 00:32:04.720
you need Python 3 for this.


00:32:04.720 --> 00:32:08.200
thinking, well, any version that's supported these days.


00:32:08.200 --> 00:32:09.520
And people are like, well, there's older versions


00:32:09.520 --> 00:32:10.480
that don't support this thing.


00:32:10.480 --> 00:32:13.920
Like, well, obviously I'm not talking about the one


00:32:13.920 --> 00:32:15.880
that was not supported five years ago.


00:32:15.880 --> 00:32:17.420
Like at some point,


00:32:17.420 --> 00:32:23.440
Python 3 is the supported version of Python.


00:32:23.440 --> 00:32:24.280
I don't know.


00:32:24.280 --> 00:32:25.960
- Oh, that's true.


00:32:25.960 --> 00:32:27.920
- Okay, so that's a bit of a diversion there.


00:32:27.920 --> 00:32:29.280
But I went down that route,


00:32:29.280 --> 00:32:30.880
and I was like, I really don't know which way I should go.


00:32:30.880 --> 00:32:34.600
But I feel like there's a case to be made that just like,


00:32:34.600 --> 00:32:38.200
When you talk about Python 3, you're not talking about old unsupported versions.


00:32:38.200 --> 00:32:43.560
You're everything that's like modern 3.7 and above should be like an


00:32:43.560 --> 00:32:45.920
an alias for Python 3.


00:32:45.920 --> 00:32:49.840
I don't know when we were just saying Python 3, what we meant was like 3.1.


00:32:49.840 --> 00:32:52.280
So I know we got to get used to that.


00:32:52.280 --> 00:32:55.120
There's no Python 2 really to worry about.


00:32:55.120 --> 00:32:56.040
All right.


00:32:56.040 --> 00:32:59.400
Well, that will definitely bring us to our extras morning.


00:32:59.400 --> 00:33:00.760
Yeah.


00:33:00.760 --> 00:33:01.400
All right.


00:33:01.400 --> 00:33:04.160
you want me to kick it off since I got my screen up?


00:33:04.520 --> 00:33:05.520
- Yeah, go ahead.


00:33:05.520 --> 00:33:08.160
- All right, so Will, like I said, he gets two appearances


00:33:08.160 --> 00:33:11.040
and also his comments, so thank you for that.


00:33:11.040 --> 00:33:12.640
And this is like in the same vein


00:33:12.640 --> 00:33:13.480
of what I was just talking about.


00:33:13.480 --> 00:33:15.840
Like what is this convention that we want to have, right?


00:33:15.840 --> 00:33:18.360
So the Walrus operator came out in 3.8


00:33:18.360 --> 00:33:23.360
and it was kind of an interesting big deal, right?


00:33:23.360 --> 00:33:26.220
There's a lot of debate around whether or not


00:33:26.220 --> 00:33:27.160
that should be in the language.


00:33:27.160 --> 00:33:29.000
Honestly, I think it's a pretty minor thing


00:33:29.000 --> 00:33:30.440
that it's not a huge deal,


00:33:30.440 --> 00:33:35.440
But the idea is you can both test for a variable as well


00:33:35.440 --> 00:33:39.240
or you can use the test or use the value of the variable


00:33:39.240 --> 00:33:41.900
in the same place that you create it.


00:33:41.900 --> 00:33:44.240
So instead of saying X equals get user


00:33:44.240 --> 00:33:48.700
or like U equals get user, if user is not none or if user,


00:33:48.700 --> 00:33:52.740
you could just say if U colon equals get user,


00:33:52.740 --> 00:33:57.640
do the true thing, otherwise then it's not set right.


00:33:57.640 --> 00:34:01.680
And so Will is suggesting that we pronounce


00:34:01.680 --> 00:34:06.320
the walrus operator as you becomes the value.


00:34:06.320 --> 00:34:09.840
So like X colon equals seven is like X becomes seven.


00:34:09.840 --> 00:34:10.800
What do you think?


00:34:10.800 --> 00:34:12.000
Are you behind this?


00:34:12.000 --> 00:34:13.240
- Okay, so you'd be like,


00:34:13.240 --> 00:34:15.080
when you're reading your code to yourself.


00:34:15.080 --> 00:34:15.900
- How do you say it?


00:34:15.900 --> 00:34:18.200
Like if you say like the lambda expression,


00:34:18.200 --> 00:34:21.000
like how do you like define like the variables


00:34:21.000 --> 00:34:23.940
of the lambda, like there's terms around there


00:34:23.940 --> 00:34:25.480
that make it a little bit hard to say


00:34:25.480 --> 00:34:26.940
without just saying syntax, right?


00:34:26.940 --> 00:34:30.860
So he's proposing like becomes is the saying,


00:34:30.860 --> 00:34:34.420
the verbal, the way we verbalize while we're software.


00:34:34.420 --> 00:34:38.540
I like it, I'm gonna give it a thumbs up.


00:34:38.540 --> 00:34:39.380
- It's interesting,


00:34:39.380 --> 00:34:41.380
but how is that different from assignment though?


00:34:41.380 --> 00:34:43.660
Do we, do you say, what do you say with assignment?


00:34:43.660 --> 00:34:45.660
I don't say like X.


00:34:45.660 --> 00:34:47.540
- Equals, I don't know, yeah.


00:34:47.540 --> 00:34:51.140
- Equals, assign, becomes works.


00:34:51.140 --> 00:34:53.860
- I will put it out there if people can think about it.


00:34:53.860 --> 00:34:55.860
And there's a nice Twitter thread here


00:34:55.860 --> 00:34:57.980
with lots of comments.


00:34:57.980 --> 00:35:00.680
So folks can jump in.


00:35:00.680 --> 00:35:05.180
- Or you can just, walrus, just talk, ex-walrus five.


00:35:05.180 --> 00:35:06.020
- Oh yeah.


00:35:06.020 --> 00:35:07.660
Well, what do walruses do?


00:35:07.660 --> 00:35:09.540
I mean, is there like a cool action that would,


00:35:09.540 --> 00:35:13.100
is like particular to walruses?


00:35:13.100 --> 00:35:14.580
- Well, there probably is, but it's not,


00:35:14.580 --> 00:35:15.420
it doesn't apply to this.


00:35:15.420 --> 00:35:17.080
- It's not very colloquial, is it?


00:35:17.080 --> 00:35:21.060
- Is ex.


00:35:21.060 --> 00:35:23.540
- And John, then John Sheehan out in the audience says,


00:35:23.540 --> 00:35:27.940
In my brain, I use assigned to, and he must know what's coming


00:35:27.940 --> 00:35:30.440
because he's up next.


00:35:30.440 --> 00:35:33.620
Hey, John.


00:35:33.620 --> 00:35:37.220
So the other thing I want to talk about is, did you know, I


00:35:37.220 --> 00:35:43.100
learned through John that string starts with, will take a, an


00:35:43.100 --> 00:35:45.940
iterable, it says tuple, but I suspect it might even be an


00:35:45.940 --> 00:35:49.140
iterable of substrings.


00:35:49.140 --> 00:35:54.140
And if any of them match, it'll test out of each.


00:35:54.140 --> 00:35:56.700
So like A, B, C, D, E, F, you say,


00:35:56.700 --> 00:36:01.700
starts with a tuple, A, B, or C, D, or E, F.


00:36:01.700 --> 00:36:04.460
- Huh.


00:36:04.460 --> 00:36:06.060
- I've never used this.


00:36:06.060 --> 00:36:06.900
- I didn't know that that was a thing.


00:36:06.900 --> 00:36:08.460
- I would always just do that as like,


00:36:08.460 --> 00:36:11.700
X starts with A, B, or X starts with C, D,


00:36:11.700 --> 00:36:13.020
or X starts with E, F.


00:36:13.020 --> 00:36:15.460
No, you apparently can do that all in one go.


00:36:15.460 --> 00:36:17.160
What's the two for?


00:36:17.160 --> 00:36:18.000
- I have no idea.


00:36:18.000 --> 00:36:19.000
I was just thinking that as well.


00:36:19.000 --> 00:36:21.200
There's a two and I don't know what it's for.


00:36:21.200 --> 00:36:23.440
(laughing)


00:36:23.440 --> 00:36:27.000
Yeah, anyway, that's a super quick one,


00:36:27.000 --> 00:36:29.360
but I thought pretty interesting there.


00:36:29.360 --> 00:36:30.920
So that's all I got.


00:36:30.920 --> 00:36:33.120
How about you?


00:36:33.120 --> 00:36:34.500
- I just have one thing.


00:36:34.500 --> 00:36:37.860
We don't need to put it up,


00:36:37.860 --> 00:36:42.000
but my extra is this book.


00:36:42.000 --> 00:36:43.120
- Woo!


00:36:43.120 --> 00:36:46.380
You have your physical 2.0 book in hand?


00:36:46.380 --> 00:36:48.240
- Yes, I've got, oh yeah,


00:36:48.240 --> 00:36:51.460
and for the people not watching,


00:36:51.460 --> 00:36:54.960
I've got a stack of, it's funny,


00:36:54.960 --> 00:36:57.680
my daughter uses my Amazon account too.


00:36:57.680 --> 00:37:01.200
So UPS said, "Hey, there's a package arriving yesterday."


00:37:01.200 --> 00:37:03.680
And I said, and I didn't order anything.


00:37:03.680 --> 00:37:05.900
So I said, I told my daughter,


00:37:05.900 --> 00:37:08.560
"Hey, you probably have a package showing up."


00:37:08.560 --> 00:37:10.520
She's like, "I didn't order anything."


00:37:11.520 --> 00:37:15.720
And then this box arrives with five copies of my book, which is great.


00:37:15.720 --> 00:37:18.920
That's awesome. Yeah. Yeah. Congratulations. Thanks.


00:37:18.920 --> 00:37:22.560
Yeah. We abuse our Amazon account badly.


00:37:22.560 --> 00:37:25.040
Like there's a lot of people that log into Amazon accounting.


00:37:25.040 --> 00:37:28.260
We ended up getting stuff shipped wrong places because somebody shipped it to


00:37:28.260 --> 00:37:30.740
their house last time and then we just hit reorder again.


00:37:30.740 --> 00:37:33.080
And they're like, why do you have our shampoo? I don't know.


00:37:33.080 --> 00:37:35.240
Yeah. Yeah.


00:37:35.240 --> 00:37:40.560
John adds that the two is the starting position.


00:37:40.560 --> 00:37:43.320
>> The starting position.


00:37:43.320 --> 00:37:45.180
>> Yeah. I figured it had something to do with that.


00:37:45.180 --> 00:37:47.640
I wasn't sure how many characters to compare on, but.


00:37:47.640 --> 00:37:50.340
>> Well, I also didn't know that


00:37:50.340 --> 00:37:53.020
you could pass a starting position for starts with.


00:37:53.020 --> 00:37:54.240
That's cool.


00:37:54.240 --> 00:37:56.340
>> Yeah. There's a lot going on here.


00:37:56.340 --> 00:37:58.200
>> Almost starts with.


00:37:58.200 --> 00:37:59.880
>> Yeah. Nearly starts with.


00:37:59.880 --> 00:38:03.880
Yeah. What's the right way?


00:38:03.880 --> 00:38:08.720
So I want to close this out with a joke as always,


00:38:08.720 --> 00:38:13.240
But there's the joke we talked about a while ago,


00:38:13.240 --> 00:38:17.120
where Sebastian Ramirez, creator of FastAPI,


00:38:17.120 --> 00:38:20.640
saw an ad hiring a FastAPI developer,


00:38:20.640 --> 00:38:24.360
and he said, "Oh, it looks like I can't apply for this job.


00:38:24.360 --> 00:38:27.020
"It requires four years of experience with FastAPI,


00:38:27.020 --> 00:38:28.620
"but I can't possibly have that


00:38:28.620 --> 00:38:30.760
"'cause I only created it two years ago," right?


00:38:30.760 --> 00:38:31.840
- Yeah. (laughing)


00:38:31.840 --> 00:38:33.640
- So it's a little bit in that vein.


00:38:34.680 --> 00:38:38.800
So here we have somebody tweeting and says,


00:38:38.800 --> 00:38:40.720
here's a conversation with the recruiter and them.


00:38:40.720 --> 00:38:44.640
It says, "Recruiter, do you have a CS background?"


00:38:44.640 --> 00:38:46.200
Yes, absolutely.


00:38:46.200 --> 00:38:47.320
My CS background.


00:38:47.320 --> 00:38:50.120
And this is the screenshot from the game Counter-Strike,


00:38:50.120 --> 00:38:51.840
which is often referred to as just CS.


00:38:51.840 --> 00:38:53.320
Yeah, of course I got a CS background.


00:38:53.320 --> 00:38:54.160
Are you kidding me?


00:38:54.160 --> 00:38:56.820
(both laughing)


00:38:56.820 --> 00:38:59.120
That's pretty good.


00:38:59.120 --> 00:39:00.280
Yeah.


00:39:00.280 --> 00:39:01.400
- Yeah, that's a good one.


00:39:01.400 --> 00:39:03.160
- Well, just a question though.


00:39:03.160 --> 00:39:07.300
But if you did FastAPI, instead of eight hours a day,


00:39:07.300 --> 00:39:10.820
if you did it 16 hours a day for two years,


00:39:10.820 --> 00:39:13.500
would that constitute four years of experience?


00:39:13.500 --> 00:39:16.020
- That probably is about the same amount of experience.


00:39:16.020 --> 00:39:19.240
Yeah, so what a slacker that Sebastian is.


00:39:19.240 --> 00:39:21.740
- Does he have to eat or something?


00:39:21.740 --> 00:39:22.560
Does he have family?


00:39:22.560 --> 00:39:23.400
What's going on?


00:39:23.400 --> 00:39:24.220
- Come on.


00:39:24.220 --> 00:39:28.100
- Well, always fun with hanging out with you


00:39:28.100 --> 00:39:29.300
and talking Python.


00:39:29.300 --> 00:39:30.140
- You bet.


00:39:30.140 --> 00:39:37.140
everybody on the, listens to it on their podcast player or watches us on YouTube.


00:39:37.140 --> 00:39:39.140
Yeah, absolutely. See you later.


00:39:39.140 --> 00:39:41.140
Bye.

