WEBVTT

00:00:01.580 --> 00:00:08.380
uh hey everybody welcome welcome back to another love another lovely episode of python bites

00:00:09.410 --> 00:00:16.820
let's kick it off hello and welcome yeah sorry brian it's all right hello and welcome to python

00:00:17.040 --> 00:00:22.700
bites where we deliver python news and headlines directly to your earbuds this is episode 441

00:00:23.000 --> 00:00:25.860
recorded July 21st, 2025.

00:00:26.510 --> 00:00:28.580
And I am Brian Okken.

00:00:29.720 --> 00:00:30.140
Who am I?

00:00:30.320 --> 00:00:31.060
I am Michael Kennedy.

00:00:31.540 --> 00:00:32.000
Hello, everyone.

00:00:32.920 --> 00:00:34.580
This episode is sponsored by DigitalOcean.

00:00:34.900 --> 00:00:35.780
Thank you, DigitalOcean.

00:00:36.440 --> 00:00:37.820
Hear about them later in the show.

00:00:38.360 --> 00:00:40.980
If you'd like to give us some topics for the show

00:00:41.160 --> 00:00:42.840
or just ask us questions or connect,

00:00:43.520 --> 00:00:47.380
the links to Mastodon and Blue Sky are in the show notes

00:00:47.800 --> 00:00:50.560
and on our webpage, pythonbytes.fm.

00:00:51.580 --> 00:00:55.740
While you're there, you may as well go ahead and sign up for our newsletter,

00:00:56.500 --> 00:01:00.140
or we'll send you links for the show afterwards.

00:01:01.320 --> 00:01:04.699
And I apologize, because last week it was a little late,

00:01:04.960 --> 00:01:06.780
because I've been sick, but I'm better now.

00:01:08.600 --> 00:01:10.760
And if you'd like to join the show,

00:01:11.000 --> 00:01:14.640
we do post it live, usually Tuesday mornings.

00:01:15.540 --> 00:01:16.860
Monday, no, Monday mornings.

00:01:17.700 --> 00:01:19.160
Sorry, Monday mornings at 10.

00:01:19.420 --> 00:01:20.200
It used to be Tuesday.

00:01:22.520 --> 00:01:25.460
but just go ahead and go over to pythonbytes.fm

00:01:25.560 --> 00:01:27.880
slash live and it'll tell you when the next one is

00:01:28.900 --> 00:01:31.200
and then even if we change it you can see there

00:01:33.060 --> 00:01:35.500
yeah so let's kick it off what do you got for us

00:01:35.840 --> 00:01:39.560
Michael? Let's do some follow up for our first item here

00:01:41.360 --> 00:01:43.500
so remember last week

00:01:43.560 --> 00:01:47.699
I talked about RQ Lite the lightweight user friendly

00:01:47.720 --> 00:01:51.220
distributed relational database built on SQLite.

00:01:52.140 --> 00:01:53.780
And that was pretty cool.

00:01:54.330 --> 00:01:57.160
You could build fault-tolerant relational databases

00:01:58.070 --> 00:02:01.400
in clusters, even potentially geo-distributed

00:02:02.759 --> 00:02:03.800
using SQLite.

00:02:04.860 --> 00:02:08.479
Well, as always, our wonderful listeners are like,

00:02:08.979 --> 00:02:09.600
that's cool.

00:02:09.840 --> 00:02:10.700
Did you know about?

00:02:11.560 --> 00:02:11.640
Right?

00:02:12.140 --> 00:02:12.380
Yeah.

00:02:13.180 --> 00:02:13.960
I love that, though.

00:02:14.270 --> 00:02:14.400
Yeah.

00:02:14.540 --> 00:02:14.980
I do, too.

00:02:15.110 --> 00:02:15.680
Yeah, thank you.

00:02:16.360 --> 00:02:19.420
So two people wrote in and said, did you know about?

00:02:20.020 --> 00:02:22.040
And one was Michael Booth.

00:02:22.340 --> 00:02:25.440
And Michael Booth said, you should check out Terso,

00:02:26.340 --> 00:02:28.140
the next evolution of SQLite.

00:02:28.140 --> 00:02:36.180
So Terso is interesting in that it is kind of like SQLite,

00:02:36.300 --> 00:02:40.180
but rewritten in Rust with the idea

00:02:40.760 --> 00:02:43.620
that it can be a distributed database type of thing.

00:02:43.840 --> 00:02:48.980
also adding some of these AI features, as in vector search

00:02:48.980 --> 00:02:51.340
and other things that you need to be

00:02:51.340 --> 00:02:53.540
able to support working with AI.

00:02:54.580 --> 00:02:55.880
So pretty cool.

00:02:56.780 --> 00:02:58.540
If you look through the website, it's

00:02:59.640 --> 00:03:04.240
like their proper tertio.tech, which it's cool,

00:03:04.420 --> 00:03:10.440
but it kind of leaves it a little bit unsure what exactly it is.

00:03:10.600 --> 00:03:13.860
But what is its relation to SQLite?

00:03:14.540 --> 00:03:18.580
So it's-- go over to the GitHub.

00:03:19.180 --> 00:03:20.060
It's a little bit clearer.

00:03:23.680 --> 00:03:25.420
So it has SQLite compatibility.

00:03:25.860 --> 00:03:29.540
It is not based on SQLite like RQ Lite is.

00:03:30.500 --> 00:03:34.100
But it has language biotines for Python and other--

00:03:35.060 --> 00:03:36.880
maybe some of these other languages people have heard of,

00:03:36.880 --> 00:03:38.720
like Java and JavaScript and so on.

00:03:39.740 --> 00:03:42.360
But it has async I/O support, which is really cool.

00:03:42.680 --> 00:03:44.820
And you might say, well, it's SQLite.

00:03:45.000 --> 00:03:46.400
Can it really have async I/O support?

00:03:47.080 --> 00:03:47.180
Yes.

00:03:48.520 --> 00:03:49.340
At least on Linux.

00:03:49.540 --> 00:03:52.100
It uses I/O U-ring to make that happen.

00:03:52.270 --> 00:03:54.580
But it runs on all the platforms.

00:03:54.850 --> 00:03:56.960
So you can develop on macOS, but then you

00:03:57.080 --> 00:03:59.320
get better perf on Linux, for example.

00:04:00.160 --> 00:04:05.080
Also, they're working on adding a begin concurrent operation,

00:04:05.600 --> 00:04:08.880
like a SQL statement, a query statement.

00:04:09.740 --> 00:04:15.160
in indexing for vector search like it's probably pretty much required and better alter support

00:04:16.359 --> 00:04:25.900
right so basically think of it as a a more modern take not just because it's rewritten in rust which

00:04:26.040 --> 00:04:32.540
seems to be like the thing you do but as part of that taking on a lot of ideas like concurrency

00:04:33.400 --> 00:04:43.780
others. Okay. So big question, is it ready for production use? No. No. But these folks also

00:04:43.960 --> 00:04:51.160
worked on this thing called lib SQL. So it says that the tarot database is the next evolution of

00:04:51.240 --> 00:04:56.720
SQLite in Rust. They had previously worked on something called lib SQL, which is an attempt to

00:04:56.900 --> 00:05:02.980
evolve SQLite in a similar direction, but through a fork rather than a rewrite. And they're like,

00:05:03.100 --> 00:05:05.760
we think this new database thing is a better way to go.

00:05:08.080 --> 00:05:11.900
So if what I talked about with RQ Lite inspires you,

00:05:12.520 --> 00:05:13.460
this also might.

00:05:14.500 --> 00:05:17.280
They also have some kind of what you might expect

00:05:17.680 --> 00:05:20.880
as open core,

00:05:21.460 --> 00:05:24.940
but we'll do the infrastructure side of things for you.

00:05:25.430 --> 00:05:27.100
So they've got this thing called Terso Cloud,

00:05:27.310 --> 00:05:32.740
which is a production or a paid sort of thing, right?

00:05:34.260 --> 00:05:40.240
so serverless access or sync or whatever you want right replication sync vector search all that kind

00:05:40.240 --> 00:05:46.120
of stuff basically managed there's all right so that's thing one the other one comes to this is

00:05:46.160 --> 00:05:50.160
like all it's all Michael Michael's all the way down so we had Michael Booth recommend that one

00:05:50.540 --> 00:05:57.919
got me Michael presenting it we got Mike Fiedler talking about the next one here and Mike Fiedler

00:05:57.920 --> 00:06:01.100
says, have you heard, well, listen to the most recent Python

00:06:01.320 --> 00:06:02.940
bytes and RQ Lite.

00:06:03.070 --> 00:06:03.520
It's cool.

00:06:03.810 --> 00:06:04.340
Hadn't heard of that.

00:06:04.500 --> 00:06:07.740
Something related that might be interesting is Lightstream.io.

00:06:08.620 --> 00:06:12.220
Now, Lightstream.io is more SQLite than before.

00:06:13.040 --> 00:06:16.000
You just keep using SQLite, like the one built into Python,

00:06:17.100 --> 00:06:19.820
but you launch a little daemon that watches it

00:06:20.100 --> 00:06:24.360
and constantly syncs it with S3 or Azure Blob Storage

00:06:24.450 --> 00:06:25.280
or something like that.

00:06:26.300 --> 00:06:26.700
Okay.

00:06:27.780 --> 00:06:29.740
So when you do that, what do you get?

00:06:31.100 --> 00:06:33.480
You get something pretty cool.

00:06:33.480 --> 00:06:38.540
It just constantly streams changes to AWS S3,

00:06:38.900 --> 00:06:41.020
Azure Blob Storage, Google Cloud Storage, et cetera.

00:06:42.820 --> 00:06:45.540
And that means you basically get failover.

00:06:45.760 --> 00:06:46.780
So imagine you're like,

00:06:46.900 --> 00:06:49.800
I would love to just have a SQLite database

00:06:50.880 --> 00:06:53.360
that I can run on a simple little app.

00:06:54.860 --> 00:06:57.140
But what if that server goes down?

00:06:57.440 --> 00:06:58.560
What if that server fails?

00:06:59.780 --> 00:07:03.060
Then all my data is lost from the last time I backed it up

00:07:03.280 --> 00:07:08.700
because my alternative was to run some kind of cluster of Postgres or Mongo or whatever.

00:07:09.900 --> 00:07:14.080
But then you're into lots of DevOps and managing those things

00:07:14.150 --> 00:07:16.000
or you're paying for managed databases,

00:07:16.330 --> 00:07:21.620
which can be relatively expensive to small servers like DigitalOcean has.

00:07:23.220 --> 00:07:27.220
So what you can do is you can just keep on using regular SQLite

00:07:27.340 --> 00:07:31.280
but then use this Lightstream, which has no real performance differences in terms.

00:07:31.780 --> 00:07:36.960
These other two things are trying to change how SQLite works or re-implement a compatible API.

00:07:37.590 --> 00:07:42.380
This one just says, we promise to hook into...

00:07:44.640 --> 00:07:46.200
I put a link in the show notes.

00:07:46.380 --> 00:07:49.680
There's a nice write-up about this that they did.

00:07:49.780 --> 00:07:52.300
It's sort of like, why is this?

00:07:52.620 --> 00:07:57.020
And it's called Lightstream Revamped.

00:07:57.660 --> 00:08:00.200
And it also just talks about, like, why did they build this?

00:08:00.500 --> 00:08:01.060
How does it work?

00:08:01.110 --> 00:08:04.340
So it says it takes over the wall checkpointing process

00:08:04.580 --> 00:08:07.880
to continuously stream updates to the database.

00:08:08.260 --> 00:08:13.140
So basically, as commits are committed to the SQLite file,

00:08:13.400 --> 00:08:15.900
it just keeps pushing that to blob storage.

00:08:16.740 --> 00:08:17.080
Cool, right?

00:08:17.700 --> 00:08:17.960
Yeah.

00:08:19.280 --> 00:08:24.080
So if that RQ Lite thing was interesting but not quite what you're looking for,

00:08:24.520 --> 00:08:26.220
maybe one of these two things is.

00:08:28.480 --> 00:08:28.680
Yeah.

00:08:29.600 --> 00:08:29.760
Interesting.

00:08:31.140 --> 00:08:32.099
Pennies a day, I like that.

00:08:32.520 --> 00:08:32.760
Dirt cheap.

00:08:33.620 --> 00:08:34.159
Yeah, dirt cheap.

00:08:34.240 --> 00:08:35.200
Only costs pennies a day

00:08:36.179 --> 00:08:38.780
because it's just blob storage, right?

00:08:38.960 --> 00:08:40.900
So however you do that.

00:08:41.039 --> 00:08:42.960
And the Lightstream,

00:08:43.979 --> 00:08:45.640
I don't know that they,

00:08:45.860 --> 00:08:46.640
I don't see pricing.

00:08:46.780 --> 00:08:47.260
How about that?

00:08:47.340 --> 00:08:49.120
So this is just pure open source,

00:08:49.420 --> 00:08:50.200
whereas the...

00:08:51.440 --> 00:08:52.180
This is pretty cool.

00:08:52.420 --> 00:08:56.080
Terso was like, you can do the open source thing yourself,

00:08:56.340 --> 00:08:57.960
or we can do our cloud thing, right?

00:08:58.260 --> 00:08:59.900
I don't know which of those makes you happier,

00:09:00.100 --> 00:09:01.760
but they're not the same in that regard.

00:09:02.200 --> 00:09:04.560
Or they are the same with a wrapper, pay wrapper.

00:09:04.920 --> 00:09:05.000
Anyway.

00:09:05.620 --> 00:09:05.740
Yeah.

00:09:07.259 --> 00:09:08.060
Okay, cool.

00:09:09.180 --> 00:09:09.340
Awesome.

00:09:09.600 --> 00:09:09.880
Over to you.

00:09:11.560 --> 00:09:13.900
I want to talk about project status a little bit.

00:09:15.040 --> 00:09:17.240
So I do want to talk about this new PEP.

00:09:17.560 --> 00:09:22.280
So PEP 792, project status markers in the simple index.

00:09:26.140 --> 00:09:27.100
I should have muted for that.

00:09:27.360 --> 00:09:27.460
Sorry.

00:09:29.080 --> 00:09:31.660
So project status, what is this about?

00:09:31.920 --> 00:09:35.080
So this is a new PEP that was, well, it's not really that.

00:09:35.540 --> 00:09:36.440
It is pretty new.

00:09:36.780 --> 00:09:45.540
So it actually updates in February of this year, and it's now accepted.

00:09:45.960 --> 00:09:50.260
so i'm going to talk about this a little bit but i want to talk about project status and what this

00:09:50.420 --> 00:09:56.600
means so if i take a look at a couple of my silly projects i've got py test check which is a project

00:09:56.780 --> 00:10:02.540
i maintain and i actually intend people to be able to use it so it's maintained and so i have added

00:10:02.780 --> 00:10:09.360
a trove classifier to say the status of the project is production stable i think you can use it in

00:10:09.280 --> 00:10:15.260
production but it's you know yeah and but this is optional you don't maintainers don't have to put

00:10:15.260 --> 00:10:21.260
this in for instance i also have a another one called py test crayons that i just did for a uh

00:10:21.600 --> 00:10:28.380
a talk that i gave and um i didn't put the um the status in there so that's an it's an optional

00:10:28.540 --> 00:10:35.240
thing so what we have we have in the current situation there is the trove classifiers that you

00:10:35.260 --> 00:10:44.620
can optionally add to um uh to to your project and you if you like for instance start taking it down

00:10:45.240 --> 00:10:50.820
you can say that it's inactive it's not but i don't think very many people do that often inactive

00:10:50.880 --> 00:10:55.500
just means somebody left but it's still they haven't updated a new one that's like please

00:10:55.620 --> 00:11:01.479
close the door on your way out usually they just walk out the door so and then there's also there's

00:11:01.500 --> 00:11:05.900
actually three kinds of status so there's that the trove classifiers but then there's also

00:11:06.940 --> 00:11:15.800
uh indices uh can mark uh a district can mark distributions and releases as yanked so you can

00:11:16.140 --> 00:11:22.820
um like a version you can yank um so it's not there anymore so then the it's still it's still

00:11:22.980 --> 00:11:29.180
like got an entry there but it's been a yanked uh whether it's true or false so and then you know

00:11:29.020 --> 00:11:31.580
I've started seeing that a lot lately, actually.

00:11:32.400 --> 00:11:32.740
Have you?

00:11:33.300 --> 00:11:35.360
At least UVPIP warnings.

00:11:36.340 --> 00:11:39.440
So I'll say, update the dependencies of this project,

00:11:39.800 --> 00:11:42.960
basically UVPIP compile, and then I'll install the requirements.

00:11:43.900 --> 00:11:46.720
And it'll say, this thing has been yanked because of,

00:11:46.750 --> 00:11:50.320
and it'll have some reason, like broken metadata or whatever.

00:11:50.430 --> 00:11:52.460
I'm like, well, I don't know what I'm supposed to do about this

00:11:52.490 --> 00:11:53.400
because something needed it.

00:11:54.240 --> 00:11:54.480
Yeah.

00:11:55.460 --> 00:11:55.600
OK.

00:11:56.800 --> 00:11:58.240
I've not seen anything fail.

00:11:58.420 --> 00:12:01.560
I haven't seen the apps no longer run because something got that status,

00:12:01.630 --> 00:12:03.200
but I've seen warnings about this now.

00:12:05.060 --> 00:12:11.480
And then there's another type of status that's PyPI itself can have a status

00:12:11.590 --> 00:12:12.600
for an entire project.

00:12:13.740 --> 00:12:19.200
And the entire project can be quarantined if the administrators of PyPI

00:12:19.540 --> 00:12:25.920
think that the project has been like it's got like malware in it or something.

00:12:26.870 --> 00:12:28.040
So they can quarantine it.

00:12:28.800 --> 00:12:36.040
and also a project owner can archive a project and say basically i'm i'm i'm you can disable new

00:12:36.280 --> 00:12:44.240
releases um and it's still around but it's the nobody can update to it and it's just archived

00:12:44.260 --> 00:12:48.980
it's there for historical purposes i guess anyway so there's three statuses and it's a little

00:12:49.220 --> 00:12:56.380
confusing on how to use those um as a as a if you had an alternative in text if you were trying to

00:12:56.740 --> 00:13:03.760
like do dependency resolution or other things. So trying to clean that up a bit. So there's really

00:13:03.840 --> 00:13:11.580
this proposal is to have one project that always has exactly one status. And the status will be,

00:13:12.660 --> 00:13:21.239
it'll be active. And then there's some semantics around that. Active or archived or quarantined

00:13:22.500 --> 00:13:29.160
and deprecated and this makes sense so it's either either it's it's in use it's active or

00:13:29.660 --> 00:13:35.940
it's not um but it's also what does it not mean it's either you know these various levels of why

00:13:35.940 --> 00:13:43.280
you can't you shouldn't use it um and i think this is um this is a way for good way forward

00:13:43.410 --> 00:13:50.199
to have like to kind of consolidate these now this is this has been accepted this uh this active

00:13:50.220 --> 00:13:58.280
archived quarantined deprecated status and it can only be one of those but this has been accepted

00:13:58.460 --> 00:14:05.080
however it's not implemented yet so don't go out and look in PyPI to try to find this yet so this

00:14:05.080 --> 00:14:13.980
is this just was accepted July 8th resolution so you know we will update you further as we hear

00:14:14.280 --> 00:14:16.480
from people in the Python community

00:14:16.590 --> 00:14:18.020
that this is all implemented.

00:14:18.820 --> 00:14:19.540
Yeah, excellent.

00:14:21.440 --> 00:14:23.360
I think I'm behind it.

00:14:23.940 --> 00:14:25.240
The quarantine one is good.

00:14:25.320 --> 00:14:26.720
I'm very glad I've never seen that warning.

00:14:27.880 --> 00:14:29.200
And the archive one feels to me

00:14:29.340 --> 00:14:35.720
like a little bit of a supply chain safety type thing.

00:14:35.920 --> 00:14:37.020
Like, I'm not going to mess with this.

00:14:37.050 --> 00:14:38.320
I will never update this.

00:14:39.580 --> 00:14:41.520
But let's not allow something to happen

00:14:41.550 --> 00:14:42.600
where someone else could either.

00:14:43.580 --> 00:14:44.660
Well, and I'm not sure.

00:14:44.760 --> 00:14:45.960
So I was trying to read this.

00:14:45.960 --> 00:14:48.740
I was trying to understand kind of how it's going to be set.

00:14:48.980 --> 00:14:53.520
So it's probably not going to be something just in the Trove classifier.

00:14:53.720 --> 00:14:58.120
So it probably is going to be something outside of the data itself.

00:14:59.760 --> 00:15:05.020
So because there's times where it's clear there's nobody updating it anymore,

00:15:05.620 --> 00:15:07.160
and you can't get a hold of the maintainer,

00:15:07.660 --> 00:15:10.440
you need to be able to say, this one's dead.

00:15:11.320 --> 00:15:14.980
I think it's too bad that we don't have a better way to say,

00:15:16.840 --> 00:15:20.040
but after the fact, if somebody just stops maintaining something,

00:15:20.500 --> 00:15:22.560
hey, does anybody else want to start maintaining this?

00:15:23.060 --> 00:15:25.800
I know there's security problems around that,

00:15:26.000 --> 00:15:29.860
but it might be good to be able to have some things live on.

00:15:31.380 --> 00:15:34.260
Yeah, and just archiving old stuff.

00:15:35.500 --> 00:15:36.080
It's not good.

00:15:37.140 --> 00:15:41.280
Was it GitHub, I think, that got into a big uproar

00:15:41.999 --> 00:15:43.820
they decided that they're going to

00:15:46.300 --> 00:15:47.820
archive a bunch of

00:15:48.360 --> 00:15:49.800
stuff if it hadn't been updated

00:15:50.080 --> 00:15:51.740
in years, or was it

00:15:51.900 --> 00:15:53.740
NPM? I don't know, one of these types of

00:15:54.180 --> 00:15:55.960
places. If stuff

00:15:56.080 --> 00:15:57.620
doesn't get touched, people are like, hey, it's not

00:15:58.440 --> 00:15:59.480
unmaintained, it's just done.

00:16:00.200 --> 00:16:01.640
There's nothing to add, it's perfect.

00:16:01.980 --> 00:16:02.120
It works.

00:16:04.620 --> 00:16:04.800
Exactly.

00:16:06.400 --> 00:16:07.740
Cool. All right, well, before we

00:16:07.900 --> 00:16:10.020
move on, let's talk

00:16:10.080 --> 00:16:11.440
about our sponsor, huh?

00:16:12.150 --> 00:16:12.320
Yeah.

00:16:13.080 --> 00:16:13.240
Yeah.

00:16:13.990 --> 00:16:18.340
So super excited to have DigitalOcean back to support the show.

00:16:19.220 --> 00:16:22.260
As always, this episode is brought to you by DigitalOcean.

00:16:23.320 --> 00:16:26.660
And DigitalOcean is a comprehensive cloud infrastructure

00:16:27.300 --> 00:16:30.080
that's simple to spin up even for the most complex workloads,

00:16:30.580 --> 00:16:33.280
and it's way better value than most cloud providers.

00:16:33.520 --> 00:16:35.400
I've looked at the big three,

00:16:35.760 --> 00:16:40.640
and they're not even close in how much value you get per dollar

00:16:40.750 --> 00:16:42.180
and how much easier it is to use.

00:16:43.000 --> 00:16:46.840
So at DigitalOcean, companies can save up to 30% off their cloud bill.

00:16:47.700 --> 00:16:51.600
They boast a 99.99% uptime SLA.

00:16:51.710 --> 00:16:56.500
That means they promise to support that level of uptime.

00:16:57.240 --> 00:17:00.700
Our experience, Brian, running Python Bytes and other things on DigitalOcean

00:17:00.770 --> 00:17:03.960
for many years was way higher than four nines.

00:17:04.439 --> 00:17:05.240
Really, really reliable.

00:17:05.300 --> 00:17:06.540
Well, love them.

00:17:07.300 --> 00:17:10.040
They also have industry-leading pricing on bandwidth.

00:17:10.780 --> 00:17:15.860
Also true, like 10 times, 8 times cheaper than AWS and Azure.

00:17:15.939 --> 00:17:16.220
Really good.

00:17:17.600 --> 00:17:21.660
So it's built to be the cloud backbone of businesses, small and large,

00:17:21.959 --> 00:17:24.839
and now they have GPU-powered virtual machines,

00:17:25.740 --> 00:17:28.840
plus storage, database, networking capabilities all-in-one platform

00:17:29.080 --> 00:17:33.420
so AI developers can confidently create apps that their users will love.

00:17:34.340 --> 00:17:37.820
Devs have access to a complete set of infrastructure tools they need,

00:17:38.240 --> 00:17:41.320
both training and inference, so they can build anything they dream up.

00:17:42.580 --> 00:17:45.360
DigitalOcean provides full-service cloud infrastructure that's simple to use,

00:17:45.900 --> 00:17:49.680
reliable no matter the use case, and scalable for any business.

00:17:49.980 --> 00:17:51.240
So did I say good value?

00:17:51.700 --> 00:17:52.940
$4 a month for a server.

00:17:53.780 --> 00:17:54.040
That's yours.

00:17:54.400 --> 00:17:55.820
Your Linux server you SSH into.

00:17:56.060 --> 00:17:56.200
Amazing.

00:17:56.860 --> 00:18:00.140
And GPUs, servers for under $1 per hour.

00:18:00.680 --> 00:18:03.160
So easy to spin up infrastructure.

00:18:03.880 --> 00:18:06.500
to simplify even the most intense business demands.

00:18:06.700 --> 00:18:07.260
That's DigitalOcean.

00:18:08.680 --> 00:18:13.020
If you use the DO4bytes code,

00:18:13.640 --> 00:18:16.900
then you can get up to $200 in free credit

00:18:16.990 --> 00:18:19.120
to get started, DO4bytes.

00:18:19.740 --> 00:18:22.160
Just click the link in your podcast player show notes.

00:18:22.420 --> 00:18:24.200
DigitalOcean is the cloud that's got you covered.

00:18:24.460 --> 00:18:27.160
So like I said, please use our link.

00:18:27.320 --> 00:18:28.620
You'll find the podcast player show notes,

00:18:28.650 --> 00:18:31.760
a clickable chapter URL while I'm speaking right now,

00:18:32.280 --> 00:18:35.700
And at the top of the page at pythonbytes.fm for the episode,

00:18:36.060 --> 00:18:39.040
thank you to DigitalOcean for supporting Python Bytes.

00:18:41.160 --> 00:18:41.600
Indeed, indeed.

00:18:42.040 --> 00:18:44.480
Now, over to you.

00:18:46.840 --> 00:18:52.680
Well, so I want to talk about testing a little bit.

00:18:53.110 --> 00:18:58.100
So Hugo van Kemenad,

00:19:00.580 --> 00:19:07.040
uh love you Hugo sorry uh wrote a post called coverage run coverage on tests and this is

00:19:07.140 --> 00:19:13.200
something that I've taught everybody to do and or taught everybody I can can get my get their

00:19:13.380 --> 00:19:18.400
hold of their ears to do this because it's important but I'm glad that Hugo wrote a post

00:19:18.440 --> 00:19:24.119
about it and this was just going to be an extra however um I was blown away by a few things here

00:19:24.620 --> 00:19:30.440
and I'm like oh we got to make this highlight it a little bit more so that the classic reason why

00:19:30.440 --> 00:19:36.340
you should run coverage on your test is because of the copy paste modify problem with pytest

00:19:36.880 --> 00:19:42.600
because pytest really kind of it the name of the test is just sort of shows up in the reporting

00:19:42.860 --> 00:19:51.099
so it's very easy to um to copy my you take an old test and since you're not calling the test

00:19:51.140 --> 00:19:58.340
function yourself. It's easy to copy, paste, modify, and forget to change the name. And if

00:19:58.340 --> 00:20:05.900
you do that, the second test just hides the name, hides the first one. And that is the classic

00:20:06.100 --> 00:20:11.640
reason why I tell people to run coverage so that you don't do this. And it's hard to figure out

00:20:11.800 --> 00:20:21.080
otherwise. But a couple of cool things that I learned from this post is that Ruff's rule F811

00:20:21.100 --> 00:20:28.320
f811 catches that apparently so there is if you run rough on your test code also

00:20:29.460 --> 00:20:39.660
with at least f811 turned on you'll it it checks for variables which the function name is officially

00:20:39.660 --> 00:20:50.560
a variable that are defined and and redefined or otherwise shadowed and unused so if you used a

00:20:50.220 --> 00:20:57.920
a variable, didn't use it, and redefined it. That's similar to defining a test twice. So I

00:20:58.080 --> 00:21:03.680
didn't know that. So I will make sure that I've got rough running on my test code also. So that's

00:21:03.780 --> 00:21:09.700
cool. Also a tip to say, hey, if you're really just copy-paste modifying a test, maybe think

00:21:09.880 --> 00:21:14.779
about pytest parameterization, which I agree. You might want to just parameterize the test. But this

00:21:14.800 --> 00:21:21.600
is also pretty common it's so common to copy paste modify the second example is what the one that i

00:21:21.780 --> 00:21:25.960
really was like oh my gosh we have to cover this because i would have never i wouldn't have caught

00:21:26.120 --> 00:21:33.900
this so his second example is this weird okay so it's like a he's got an image some image stuff

00:21:34.060 --> 00:21:41.440
that he's testing and it's like i don't know it's i guess i'm just it's a little bit of a complicated

00:21:41.440 --> 00:21:47.220
thing you've got some colors and images and you're trying to test in the in the end you're asserting

00:21:47.440 --> 00:21:53.320
whether or not images are similar of a reloaded image versus an expected image and i don't really

00:21:53.480 --> 00:21:59.240
understand what's going on here but um it doesn't look terrible but one of the things in here is

00:21:59.420 --> 00:22:06.740
that um when he ran coverage it said that uh these two lines at the bottom are not being run at all

00:22:07.080 --> 00:22:14.680
and he's got a a some images a set of images that he's iterating over and apparently there's nothing

00:22:14.680 --> 00:22:25.500
in them so what's going on um and the thing that's going on apparently is uh this his his images are a

00:22:25.840 --> 00:22:32.860
generator is what's going on so he's got some images that are being uh set up as a generator

00:22:33.000 --> 00:22:40.460
so like a uh you know for i a generator comprehension yeah generator comprehension

00:22:41.000 --> 00:22:48.400
and then he passes that to a function that consumes the generator um and then uh and then

00:22:48.400 --> 00:22:54.980
when he tries to use it as the as in the assert section there's nothing there anymore and i would

00:22:54.980 --> 00:23:02.220
have never like obviously this is this is highlighted because i use generated way more than in generator

00:23:02.160 --> 00:23:08.380
comprehensions more than I used to because they're cool and they're efficient. And if you've got huge

00:23:08.540 --> 00:23:14.700
things, they use up less memory. So I'm using them more and more. And I probably am using in my test

00:23:14.840 --> 00:23:21.920
and I better make sure that I'm not like mucking up with things like this. So a pretty cool reason

00:23:22.030 --> 00:23:28.760
to use coverage on your test code to make sure that you don't do this. Oh yeah, the fix, by the

00:23:28.720 --> 00:23:30.400
way of doing this is just

00:23:30.920 --> 00:23:32.260
instead of using a

00:23:32.840 --> 00:23:34.420
generator comprehension, just use a list

00:23:34.780 --> 00:23:36.500
and pass it. Square brackets,

00:23:36.700 --> 00:23:37.120
not parentheses.

00:23:40.280 --> 00:23:42.320
It's subtle, though. I agree. Very subtle.

00:23:42.580 --> 00:23:43.900
Oh, yeah. That's the difference, really.

00:23:44.220 --> 00:23:46.180
Yeah. Parentheses versus brackets.

00:23:47.200 --> 00:23:47.860
And then it works.

00:23:50.040 --> 00:23:50.360
Yeah.

00:23:50.720 --> 00:23:50.860
Okay.

00:23:53.500 --> 00:23:53.740
Anyway.

00:23:54.440 --> 00:23:54.820
Thanks, Hugo.

00:23:55.520 --> 00:23:56.320
Yeah. Thanks, Hugo.

00:23:57.560 --> 00:23:57.980
All right.

00:23:58.840 --> 00:24:07.400
But let's talk about something simpler than all that SQLite distributed async business.

00:24:09.180 --> 00:24:09.940
Here's a problem, Brian.

00:24:10.960 --> 00:24:20.200
You have a program, probably in our case, often a Python program, and you want to give it to somebody and let them run it.

00:24:20.980 --> 00:24:21.860
How do you do that?

00:24:22.640 --> 00:24:27.860
Still, to this day, there's no amazing options to do that.

00:24:27.900 --> 00:24:36.520
I know we have Pi 2.exe and Pi 2.app, but those things are, while awesome,

00:24:37.400 --> 00:24:41.540
they're not consistently reliable and all sorts of things.

00:24:41.720 --> 00:24:45.260
So this is a little bit more dev-focused than that,

00:24:45.380 --> 00:24:49.740
but if you have Docker installed on the machine, right?

00:24:49.850 --> 00:24:56.100
So if Docker is like Docker Desktop or OrbStack or whatever,

00:24:56.660 --> 00:24:59.900
and I guess even in the upcoming macOS,

00:25:00.180 --> 00:25:03.300
we're supposed to have a built-in Docker equivalent

00:25:03.690 --> 00:25:05.760
built straight into macOS, which should be interesting.

00:25:06.980 --> 00:25:08.020
Anyway, if you have any of those,

00:25:08.760 --> 00:25:11.560
there's this project called Docker2.exe.

00:25:13.320 --> 00:25:13.460
Huh.

00:25:14.260 --> 00:25:14.820
To execute.

00:25:14.830 --> 00:25:16.200
Well, I believe it works on all the platforms.

00:25:16.370 --> 00:25:18.340
I don't think it's just Windows.exe,

00:25:18.570 --> 00:25:21.540
even though, you know, yeah, it absolutely works on Windows,

00:25:22.740 --> 00:25:25.160
Linux, and Darwin, a.k.a. macOS.

00:25:26.740 --> 00:25:28.400
So just to executable, right?

00:25:30.240 --> 00:25:34.140
And the idea is that if you have a Docker image with an entry point or

00:25:34.280 --> 00:25:36.120
something like that that will start an app running,

00:25:37.870 --> 00:25:41.360
you can simply build that as a executable,

00:25:42.050 --> 00:25:49.320
either a.exe on Windows, a.app, you have to rename it I think more or less.

00:25:49.560 --> 00:25:51.060
They're just executable binaries, right?

00:25:52.120 --> 00:25:58.060
So you can take that Docker image and build it into an executable, which is pretty awesome.

00:25:59.940 --> 00:26:07.120
So you could, you know, the example they give is kind of, it's a bad, I'm going to call it as a full-on bad example,

00:26:07.360 --> 00:26:10.620
because it says, here is a bare Linux image.

00:26:11.060 --> 00:26:12.600
You can distribute that as a binary.

00:26:12.640 --> 00:26:14.240
It's like, okay, great.

00:26:15.360 --> 00:26:16.720
That's not exactly the use case.

00:26:17.160 --> 00:26:21.380
You know, the use case is I have something I want to give to someone and run it.

00:26:21.980 --> 00:26:51.780
Right. So as a Docker thing, so maybe a better example would be like, here's copying over my source code, building a Docker image, and then turning that base Docker image into an executable that I can distribute. Right. But this thing would do that. It's just the example doesn't show that. So I think that is pretty neat. And if you want yet another way to distribute a more durable tool to somebody, if they have Docker, then you're good to go.

00:26:52.320 --> 00:26:57.860
right it's pretty cool well did they do they have to have a docker yes okay

00:26:59.160 --> 00:27:03.440
because basically somehow this thing just it bundles up the docker image and

00:27:03.440 --> 00:27:07.380
then just executes it using docker in the same way that you would just say

00:27:07.600 --> 00:27:15.740
docker run etc the other thing that's not clear to me is if there's a way to

00:27:16.380 --> 00:27:24.400
pass through mappings for example map port 8000 to 2722 whatever you know what

00:27:24.400 --> 00:27:31.800
I mean or map this volume to this folder probably you can in the exit like when

00:27:31.800 --> 00:27:35.580
you run the executable can you pass that kind of stuff to it also again the

00:27:35.640 --> 00:27:40.840
reason I don't like this example here boy they just like bundle up Linux in the

00:27:40.820 --> 00:27:46.260
Docker file itself, you can say expose this port and do other type of things like that

00:27:46.440 --> 00:27:47.180
in the Docker file.

00:27:47.800 --> 00:27:52.660
So you can bake in, like if you're saying, my thing is a little Flask app that runs using

00:27:52.880 --> 00:27:59.000
maybe SQLite for the database, it exposes this port so that you can then, you know,

00:27:59.000 --> 00:28:03.120
it could print out a thing like click here to like talk to the server and launches a

00:28:03.300 --> 00:28:05.060
URL, the web browser to like a local URL.

00:28:05.860 --> 00:28:09.960
So you can do that with, I'm pretty sure with expose and other stuff in the Docker file.

00:28:10.540 --> 00:28:15.180
But yeah, anyway, you want to ship a Docker image as just an executable binary?

00:28:15.480 --> 00:28:16.060
Check this thing out.

00:28:17.100 --> 00:28:17.440
Cool.

00:28:19.420 --> 00:28:19.760
Very neat.

00:28:20.840 --> 00:28:21.180
All right.

00:28:21.400 --> 00:28:23.180
I know that you have extras, and I don't.

00:28:23.900 --> 00:28:24.280
Okay.

00:28:24.660 --> 00:28:26.960
I've got some testing code news.

00:28:27.120 --> 00:28:28.720
So testing code has sort of been on pause.

00:28:28.880 --> 00:28:29.720
When was the last time?

00:28:29.780 --> 00:28:30.480
May 7th.

00:28:31.140 --> 00:28:31.540
And what?

00:28:32.559 --> 00:28:33.700
It's July now.

00:28:34.160 --> 00:28:37.020
It's been on pause for a while because of life.

00:28:37.200 --> 00:28:39.280
But life has got a little bit of room in it now.

00:28:39.460 --> 00:28:41.340
So I'm going to do a little bit of testing code.

00:28:42.000 --> 00:28:47.440
So there's three episodes in the queue and hopefully more to come.

00:28:47.760 --> 00:28:50.420
So at least, and so this week there will be an episode.

00:28:50.640 --> 00:28:57.680
And I'm pretty excited because this week's episode is covering pytest Django with Adam Johnson.

00:28:57.800 --> 00:28:59.820
And a lot of people have asked me about pytest Django.

00:29:00.600 --> 00:29:08.280
And since I am not a Django-esque expert, and Adam is, Adam was willing to talk with me about it.

00:29:08.500 --> 00:29:10.680
And it's a really great discussion.

00:29:11.120 --> 00:29:12.840
So I'll be excited to get that out.

00:29:13.600 --> 00:29:15.140
I'll be excited to get that out this week.

00:29:15.660 --> 00:29:18.000
And then also, I went ahead.

00:29:18.140 --> 00:29:23.840
So I'm using a hosting provider I'm using for this is Transistor FM.

00:29:24.780 --> 00:29:29.980
And Transistor has the ability to push things to YouTube, but it's a little bit wacky.

00:29:30.180 --> 00:29:32.320
So I went ahead and turned that on.

00:29:33.120 --> 00:29:36.440
And so everything now is for testing code.

00:29:36.580 --> 00:29:37.540
Well, not everything yet.

00:29:38.480 --> 00:29:46.680
207 episodes are now up on youtube um the uh the catch is they sort of show up in random order

00:29:47.440 --> 00:29:54.180
uh they they they push um i think 80 episodes a day or something like that um they they do a lot

00:29:54.240 --> 00:29:59.320
so by by like time we i don't know by the time you probably hear this if you if you don't hear

00:29:59.420 --> 00:30:05.300
it on the first day um they'll probably be all up but anyway um they're there but they're just in

00:30:05.280 --> 00:30:10.840
weird order that's a lot of content to be pushing up there i suspect though after it sort of bulk

00:30:11.000 --> 00:30:16.380
uploads once it does as you start launching it'll it'll go in the right order yeah well it's it's

00:30:16.480 --> 00:30:22.520
because youtube orders i'm pretty sure youtube orders in the upload order of like when you

00:30:22.800 --> 00:30:28.320
uploaded it and there's no way to backdate it to say this was actually two years ago yeah and

00:30:28.340 --> 00:30:33.260
probably uh transistor just batch processes them and the order in which they complete is the order

00:30:33.220 --> 00:30:40.060
much they upload yeah luckily when i did um when i did the when i transitioned to uh

00:30:41.280 --> 00:30:48.080
transistor though they do have a you it just uses your old post dates so uh even though i transitioned

00:30:48.280 --> 00:30:54.580
like i don't know a couple years ago or something like that um i still was able to you know like

00:30:55.620 --> 00:31:01.599
some of the early episodes still show up as like being happening in 2016 even though they got

00:31:01.620 --> 00:31:11.200
transferred later but anyway a lot of content good deal so no extras for you no I'm not very extra

00:31:11.940 --> 00:31:15.140
just been working hard and stuff I'll share I'll have things to share eventually but right now

00:31:15.700 --> 00:31:21.440
no extras I do have a joke I've brought for us what do you think oh yeah let's do it for it

00:31:21.850 --> 00:31:27.979
yeah okay so Brian what if what if programmers were doctors

00:31:30.000 --> 00:31:37.720
you know the old joke hey doctor my leg hurts well stop you know it my leg hurts when I like

00:31:37.920 --> 00:31:42.720
lift it like this we'll stop lifting it like that right yeah there's a there's a fun variation on

00:31:42.780 --> 00:31:48.880
that joke for programmers and it's it's basically the doctor equivalent of it works on my machine

00:31:49.590 --> 00:31:55.580
it says doctor my leg hurts that's weird I also have a leg and it doesn't hurt the issue must be

00:31:55.540 --> 00:31:56.020
on your side.

00:32:00.520 --> 00:32:00.700
Yeah.

00:32:01.740 --> 00:32:02.940
That's definitely true.

00:32:03.480 --> 00:32:03.580
Yeah.

00:32:05.900 --> 00:32:06.420
I like it.

00:32:07.080 --> 00:32:07.940
It's dumb, but funny.

00:32:08.510 --> 00:32:08.840
I know.

00:32:09.260 --> 00:32:09.940
It's short and sweet.

00:32:12.560 --> 00:32:13.420
I like it.

00:32:13.820 --> 00:32:13.980
Cool.

00:32:15.120 --> 00:32:16.600
Well, thanks for the joke, Michael.

00:32:16.810 --> 00:32:19.280
And thanks, as always, for this wonderful episode.

00:32:20.260 --> 00:32:20.640
You bet.

00:32:22.020 --> 00:32:22.360
Bye, Brian.

00:32:22.570 --> 00:32:22.880
Bye, everyone.

00:32:22.980 --> 00:32:23.100
Bye.

