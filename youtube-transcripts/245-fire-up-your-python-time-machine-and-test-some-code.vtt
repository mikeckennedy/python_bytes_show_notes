WEBVTT

00:00:00.000 --> 00:00:05.360
Hello, welcome to the Python Bytes livestream.


00:00:05.360 --> 00:00:08.880
So we've got a lot of fun stuff today.


00:00:08.880 --> 00:00:11.840
Thanks everybody for showing up on the stream.


00:00:11.840 --> 00:00:17.560
I'm blanking. Sorry.


00:00:17.560 --> 00:00:19.740
Okay. Let me start over.


00:00:19.740 --> 00:00:21.880
Hello and welcome to Python Bytes,


00:00:21.880 --> 00:00:25.680
where we deliver Python news and headlines directly to your earbuds.


00:00:25.680 --> 00:00:27.920
This is episode 245,


00:00:27.920 --> 00:00:29.640
so it's not the first time.


00:00:29.640 --> 00:00:34.820
Recorded August 4th 2021. I'm Brian Harkin. I'm Michael Kennedy


00:00:34.820 --> 00:00:37.680
I'm Pompeii


00:00:37.680 --> 00:00:45.240
So won't be thanks so much for coming on the show. Can you introduce yourself a little bit before we share?


00:00:45.240 --> 00:00:49.360
Thank you very much for having me. So my name is Juan P


00:00:49.360 --> 00:00:54.680
I'm from the Spain and the day my PhD in particle physics has been working at CERN


00:00:54.960 --> 00:00:58.340
For four years then two years after my PhD finished


00:00:58.340 --> 00:01:03.860
I decided to step away from academia and start working in industry and right now


00:01:03.860 --> 00:01:10.400
I'm working at financial for which is a company that develops products for Salesforce. So I'm not developing products


00:01:10.400 --> 00:01:16.100
I'm in the analytics team. So my job is to analyze internal data as well as usage


00:01:16.100 --> 00:01:23.480
Product usage from a customer to allow the board to take data-driven decisions and how the company should go forward


00:01:24.260 --> 00:01:25.500
- Nice.


00:01:25.500 --> 00:01:26.820
- Yeah, super interesting.


00:01:26.820 --> 00:01:29.300
Give us your thoughts real quick on one hand,


00:01:29.300 --> 00:01:30.900
working for a place like CERN


00:01:30.900 --> 00:01:32.260
and then the other working on a place


00:01:32.260 --> 00:01:35.840
that like provides like enhancements to Salesforce.


00:01:35.840 --> 00:01:36.900
Like those sounds so different.


00:01:36.900 --> 00:01:39.100
Are they really that different or are they similar


00:01:39.100 --> 00:01:40.780
or what's the story?


00:01:40.780 --> 00:01:42.600
- Part, I mean, of course they're different,


00:01:42.600 --> 00:01:45.820
but there is a big part which is very much the same,


00:01:45.820 --> 00:01:48.200
at least in the team that I'm working on.


00:01:48.200 --> 00:01:50.940
Because at CERN basically what you do


00:01:50.940 --> 00:01:52.740
is you don't know the answer to anything


00:01:52.740 --> 00:01:55.940
and you need to first know what you need to ask yourself.


00:01:55.940 --> 00:01:59.300
And this is very similar to what happens today


00:01:59.300 --> 00:02:02.020
in my current job, because for instance,


00:02:02.020 --> 00:02:06.780
marketing come and say, we have this whatever campaign


00:02:06.780 --> 00:02:09.600
and we want to know if we are targeting right.


00:02:09.600 --> 00:02:12.700
And I need to know what do I need to do


00:02:12.700 --> 00:02:15.740
to answer that question, but neither marketing knows.


00:02:15.740 --> 00:02:18.600
So it's like, let's figure things out.


00:02:18.600 --> 00:02:22.320
But yeah, I mean, it's a pretty drastic change,


00:02:22.320 --> 00:02:26.760
But I don't know, I got a feeling that I needed to switch.


00:02:26.760 --> 00:02:29.800
I like coding a lot and I felt at some point


00:02:29.800 --> 00:02:32.600
that I was enjoying more the coding part


00:02:32.600 --> 00:02:35.620
of being a physicist than the physics part.


00:02:35.620 --> 00:02:36.960
- Yeah. - So I said--


00:02:36.960 --> 00:02:39.440
- You basically described why I'm not in math anymore.


00:02:39.440 --> 00:02:41.680
(laughing)


00:02:41.680 --> 00:02:44.120
- Yeah. - I was working on projects


00:02:44.120 --> 00:02:45.960
and I was having so much fun


00:02:45.960 --> 00:02:47.920
and writing code on these Silicon graphics,


00:02:47.920 --> 00:02:49.480
like huge computers and stuff.


00:02:49.480 --> 00:02:51.240
And then there'd be parts where I'd be like,


00:02:51.240 --> 00:02:53.480
"Ah, this part's not so fun. This part's amazing."


00:02:53.480 --> 00:02:55.480
And I realized the programming parts were amazing.


00:02:55.480 --> 00:02:57.480
And when I had to get down to solving the math bits,


00:02:57.480 --> 00:02:59.980
I'm like, "Ah, darn. I had to put it up until the whole way.


00:02:59.980 --> 00:03:01.980
I got to work on the math again."


00:03:01.980 --> 00:03:04.740
I remember the last year and a half I was working on a project


00:03:04.740 --> 00:03:10.620
that was literally designing a system that worked within GitLab CI


00:03:10.620 --> 00:03:14.620
to automate paper review publishing.


00:03:14.620 --> 00:03:18.120
So you don't need to have a lot of people reading the paper and say,


00:03:18.120 --> 00:03:20.320
"Oh, this rule is not matched,"


00:03:20.320 --> 00:03:22.080
Do you need to fix this image?


00:03:22.080 --> 00:03:28.240
So I built an entire pipeline in python to check all of this that works based on pull requests and groups and so on in


00:03:28.240 --> 00:03:29.680
GitLab ci


00:03:29.680 --> 00:03:31.280
And I thought


00:03:31.280 --> 00:03:35.120
I've been a year and a half not doing almost any physics. So my physics work


00:03:35.120 --> 00:03:39.840
It was related to review paper because it was a chair of an editorial board


00:03:39.840 --> 00:03:44.080
So I had an analysis. It was pretty cool, but I was doing I wasn't doing it


00:03:44.240 --> 00:03:50.400
I received version review the made comment fix this fix that then go back to write a pipe and to make the pipe


00:03:50.400 --> 00:03:53.040
Yeah, exactly


00:03:53.040 --> 00:03:55.040
That sounds really cool


00:03:55.040 --> 00:03:58.560
Well, yeah, go ahead will you kick us off today?


00:03:58.560 --> 00:04:03.920
Will you want to hear about the state of the developer world? How's that sound?


00:04:03.920 --> 00:04:08.020
I like state. Yeah. Yeah, so here's an interesting


00:04:09.600 --> 00:04:12.120
survey results, I guess, put together by JetBrains,


00:04:12.120 --> 00:04:15.200
the state of the developer ecosystem 2021.


00:04:15.200 --> 00:04:16.760
And I thought this would be fun to talk about


00:04:16.760 --> 00:04:21.760
because we do cover like the PSF state of Python survey


00:04:21.760 --> 00:04:23.960
and things like that.


00:04:23.960 --> 00:04:25.760
But I thought it'd be fun to just have a quick look


00:04:25.760 --> 00:04:29.680
at the broader landscape, what people are doing


00:04:29.680 --> 00:04:31.160
and where Python fits into that.


00:04:31.160 --> 00:04:35.180
And JetBrains has done a really good job with the PSF survey.


00:04:35.180 --> 00:04:37.280
So I thought, you know, this will be similar.


00:04:37.280 --> 00:04:38.780
So let's check that out.


00:04:38.780 --> 00:04:41.980
So let me give you some stats and some rundown on this.


00:04:41.980 --> 00:04:45.340
So basically the idea is it presents the results


00:04:45.340 --> 00:04:48.420
of the fifth annual developer ecosystem survey


00:04:48.420 --> 00:04:51.820
conducted by JetBrains, and it went out to 31,000


00:04:51.820 --> 00:04:55.760
or had input from 31,000, 32,000 people.


00:04:55.760 --> 00:04:58.580
All right, so there's a couple of interesting things


00:04:58.580 --> 00:04:59.740
they're doing in the presentation here,


00:04:59.740 --> 00:05:02.100
but let's say in that world,


00:05:02.100 --> 00:05:04.780
JavaScript is still the most popular language,


00:05:04.780 --> 00:05:05.980
not if you ask Stack Overflow,


00:05:05.980 --> 00:05:08.980
but of those 32,000 people or whatever,


00:05:08.980 --> 00:05:11.940
Python's more popular than Java overall.


00:05:11.940 --> 00:05:16.900
However, Java is used more as the main language.


00:05:16.900 --> 00:05:19.380
So there's more people using Python


00:05:19.380 --> 00:05:23.780
for extra things or for other things and so on,


00:05:23.780 --> 00:05:25.220
which I think that jives pretty well


00:05:25.220 --> 00:05:26.500
with my understanding of Python


00:05:26.500 --> 00:05:28.380
is that it's this really amazing way


00:05:28.380 --> 00:05:31.340
to like bring in a little interactivity,


00:05:31.340 --> 00:05:33.300
bring in a little bit of analysis,


00:05:33.300 --> 00:05:34.580
a little Jupyter notebook


00:05:34.580 --> 00:05:38.500
or something, even if it's not your main focus, right?


00:05:38.500 --> 00:05:41.060
You might be an economist, you're not even a programmer,


00:05:41.060 --> 00:05:43.180
but you're still a Python person in a sense,


00:05:43.180 --> 00:05:45.580
whereas you probably wouldn't be a Java person


00:05:45.580 --> 00:05:47.260
as an economist most of the time.


00:05:47.260 --> 00:05:52.220
- Yeah, I use Python for testing.


00:05:52.220 --> 00:05:53.300
- Yeah, for sure.


00:05:53.300 --> 00:05:57.980
So let's see, the top five languages


00:05:57.980 --> 00:06:00.300
that developers are planning to adopt


00:06:00.300 --> 00:06:04.220
are Go, Kotlin, TypeScript, Python, and Rust.


00:06:04.220 --> 00:06:08.380
And the fastest growing languages are Python, TypeScript, Kotlin, SQL, and Go.


00:06:08.380 --> 00:06:14.300
So for example, JavaScript was the most popular language.


00:06:14.300 --> 00:06:16.180
Java was the most popular main language,


00:06:16.180 --> 00:06:18.600
but they're neither the fastest growing languages.


00:06:18.600 --> 00:06:20.820
So that's pretty interesting.


00:06:20.820 --> 00:06:26.860
Of this group, 71% people work on some sort of web backend,


00:06:26.860 --> 00:06:31.940
APIs, Flask apps, or Go apps, or whatever.


00:06:31.940 --> 00:06:34.900
So they have a lot of interesting stuff here


00:06:34.900 --> 00:06:36.140
in terms of analysis.


00:06:36.140 --> 00:06:39.580
So they have these blocks that show how popular a language is,


00:06:39.580 --> 00:06:45.500
it's been used, or how likely people are to adopt it


00:06:45.500 --> 00:06:46.540
and pick it up.


00:06:46.540 --> 00:06:48.900
So there's a bunch of grids if you go to the report,


00:06:48.900 --> 00:06:50.060
and you can check them out.


00:06:50.060 --> 00:06:53.460
And basically, the orange is the current state of the world,


00:06:53.460 --> 00:06:56.900
and there's a darker, almost black,


00:06:56.900 --> 00:06:58.300
that is like the derivative.


00:06:58.300 --> 00:07:02.940
Like how quickly is that world changing for the upswing?


00:07:02.940 --> 00:07:07.720
So for example, JavaScript has more orange squares,


00:07:07.720 --> 00:07:10.160
but it doesn't have as quick of a growth


00:07:10.160 --> 00:07:12.160
or a planned growth, I guess.


00:07:12.160 --> 00:07:14.520
So Python has one of the larger ones,


00:07:14.520 --> 00:07:16.680
so does TypeScript as well.


00:07:16.680 --> 00:07:18.160
And those are interesting to look into.


00:07:18.160 --> 00:07:19.880
You can compare those against different things.


00:07:19.880 --> 00:07:22.760
You can also see the popularity of the language over time.


00:07:22.760 --> 00:07:24.440
Python's been going up and up and up,


00:07:24.440 --> 00:07:27.600
although this year it's kind of plateaued in this report.


00:07:27.600 --> 00:07:30.800
So that's maybe something worth noting.


00:07:30.800 --> 00:07:33.920
There's obvious things going down like Objective-C,


00:07:33.920 --> 00:07:36.640
like you'd be insane to work on Objective-C right now


00:07:36.640 --> 00:07:39.120
when Swift is like replaced it,


00:07:39.120 --> 00:07:40.880
although that's going down as well.


00:07:40.880 --> 00:07:43.160
Let's see, there's a few more things.


00:07:43.160 --> 00:07:45.600
They have these really interesting graphs


00:07:45.600 --> 00:07:48.560
that are both like grids, but also heat map.


00:07:48.560 --> 00:07:50.560
So it'll let you answer questions like,


00:07:50.560 --> 00:07:54.640
okay, if I am currently a Swift developer,


00:07:54.640 --> 00:07:58.460
what is the likelihood that I'm going to adopt Python?


00:07:58.460 --> 00:07:59.700
6%.


00:07:59.700 --> 00:08:01.500
But if I'm a Kotlin developer,


00:08:01.500 --> 00:08:04.560
that's 8% likelihood that I'm going to adopt.


00:08:04.560 --> 00:08:07.480
Oh no, I'm going the wrong way.


00:08:07.480 --> 00:08:09.160
If I'm a Kotlin developer,


00:08:09.160 --> 00:08:13.240
I'm 10% likely to adopt, to move to Python and so on.


00:08:13.240 --> 00:08:15.320
So there's a lot of sort of like flow


00:08:15.320 --> 00:08:16.920
from one language to another.


00:08:16.920 --> 00:08:21.680
I haven't seen any analysis like this in the past, have you?


00:08:21.680 --> 00:08:23.600
- No, that's pretty interesting.


00:08:23.600 --> 00:08:25.520
- Yeah, yeah. - It's looking at correlation or something.


00:08:25.520 --> 00:08:27.800
What's the first row? I'm curious.


00:08:27.800 --> 00:08:29.800
- I'm not planning on changing.


00:08:29.800 --> 00:08:32.060
- So they are the most likely to change.


00:08:32.060 --> 00:08:33.960
(laughing)


00:08:33.960 --> 00:08:35.800
- Yeah, they're just stuck, they're staying.


00:08:35.800 --> 00:08:36.640
- Yeah. (laughing)


00:08:36.640 --> 00:08:37.680
- All right, let's see.


00:08:37.680 --> 00:08:39.940
Also interesting operating systems people use


00:08:39.940 --> 00:08:44.440
for development, 61% Windows, 47% Linux, 44% macOS,


00:08:44.440 --> 00:08:45.920
which that's pretty high for macOS,


00:08:45.920 --> 00:08:49.160
given its general popularity


00:08:49.160 --> 00:08:51.460
amongst the computing world, I think.


00:08:52.360 --> 00:08:55.240
- Yeah, I think Linux is pretty high too.


00:08:55.240 --> 00:08:57.440
Windows doesn't surprise me.


00:08:57.440 --> 00:08:58.280
- Yeah, exactly.


00:08:58.280 --> 00:09:01.280
And then 1% other, who knows what that is.


00:09:01.280 --> 00:09:02.880
Also questions about people using


00:09:02.880 --> 00:09:06.480
the Windows subsystem for Linux and stuff like that.


00:09:06.480 --> 00:09:09.880
There's also, if you're interested,


00:09:09.880 --> 00:09:12.680
a similar heat map for like,


00:09:12.680 --> 00:09:14.740
what type of software do you develop?


00:09:14.740 --> 00:09:17.720
So if you're trying to understand where,


00:09:17.720 --> 00:09:20.480
like if I develop this kind of software,


00:09:20.480 --> 00:09:23.680
what is the distribution for programming languages there, right?


00:09:23.680 --> 00:09:27.180
Like it's interesting to say Python is popular or JavaScript is popular,


00:09:27.180 --> 00:09:29.980
but if I'm an embedded system developer,


00:09:29.980 --> 00:09:31.980
is JavaScript still popular?


00:09:31.980 --> 00:09:35.580
I don't know, probably not, maybe, but maybe not.


00:09:35.580 --> 00:09:37.980
Right? Maybe C is like really popular.


00:09:37.980 --> 00:09:41.180
So there's a really cool thing called what types of software do you develop?


00:09:41.180 --> 00:09:45.380
There's like a grid plus heat map plus intersection of language and type.


00:09:45.380 --> 00:09:47.380
So if I develop security software,


00:09:47.380 --> 00:09:55.680
There's a 9% chance that I would be doing Python versus a 6% chance of Java.


00:09:55.680 --> 00:09:58.880
On the other hand, if I do blockchain, how does that break down and so on?


00:09:58.880 --> 00:10:04.680
Let's see where is Python kind of notable on utility little scripts.


00:10:04.680 --> 00:10:06.580
It's quite popular there.


00:10:06.580 --> 00:10:07.080
Yeah.


00:10:07.080 --> 00:10:13.480
Database backends pretty popular in that area.


00:10:13.480 --> 00:10:16.980
Let's see another one that maybe is stand out.


00:10:16.980 --> 00:10:18.940
would be programming tools.


00:10:18.940 --> 00:10:21.240
Actually, that's pretty interesting and so on.


00:10:21.240 --> 00:10:23.580
Yeah, what do you guys think of this?


00:10:23.580 --> 00:10:25.700
- I think it's weird that there's 39%


00:10:25.700 --> 00:10:28.360
of the C++ developers are developing websites.


00:10:28.360 --> 00:10:30.140
The heck?


00:10:30.140 --> 00:10:31.980
- Yeah, what are they doing back there?


00:10:31.980 --> 00:10:32.820
- What are you doing?


00:10:32.820 --> 00:10:33.760
- Yeah, maybe the backend.


00:10:33.760 --> 00:10:36.100
(laughing)


00:10:36.100 --> 00:10:37.980
She reported in the middle, I don't know.


00:10:37.980 --> 00:10:39.380
But it's weird, yeah.


00:10:39.380 --> 00:10:41.420
- Yeah, yeah, that is quite interesting.


00:10:41.420 --> 00:10:44.780
- And then you get the standard business intelligence,


00:10:44.780 --> 00:10:46.180
it makes sense.


00:10:46.180 --> 00:10:47.740
- Yeah, the business intelligence one,


00:10:47.740 --> 00:10:50.100
that one Python is definitely crushing it there, right?


00:10:50.100 --> 00:10:53.520
It's like 30% versus 10, 15, 20% for the others.


00:10:53.520 --> 00:10:56.100
Yeah, I guess one more,


00:10:56.100 --> 00:10:59.100
there's all these different things you all can dive into.


00:10:59.100 --> 00:11:01.980
I guess one more area that might be worth interesting


00:11:01.980 --> 00:11:04.260
is they broke down like the type of coding


00:11:04.260 --> 00:11:07.700
and software activities you do based on gender.


00:11:07.700 --> 00:11:10.500
So for example, if you're male,


00:11:10.500 --> 00:11:13.140
like how likely are you to do straight programming


00:11:13.140 --> 00:11:16.420
versus testing versus user experience type stuff


00:11:16.420 --> 00:11:18.100
or versus female.


00:11:18.100 --> 00:11:20.580
And let's see, so there were some takeaways.


00:11:20.580 --> 00:11:22.060
It says women are more likely than men


00:11:22.060 --> 00:11:24.940
to be involved in data analysis, machine learning,


00:11:24.940 --> 00:11:27.980
UI design and research,


00:11:27.980 --> 00:11:30.640
but less likely to be directly doing


00:11:30.640 --> 00:11:32.680
infrastructure development or DevOps.


00:11:32.680 --> 00:11:38.320
But I mean, I kind of had that sense as well, but just.


00:11:38.320 --> 00:11:41.340
- I mean, my personal experience


00:11:41.340 --> 00:11:43.260
is completely the opposite.


00:11:43.260 --> 00:11:47.340
So most of the DevOps people I work with are women.


00:11:47.340 --> 00:11:50.960
But I think it kind of makes sense,


00:11:50.960 --> 00:11:54.260
I mean, in the industry for what I'm seeing.


00:11:54.260 --> 00:11:56.540
But for my, it's completely the opposite.


00:11:56.540 --> 00:11:58.780
- Interesting.


00:11:58.780 --> 00:12:00.420
Yeah, so I'll leave this out here


00:12:00.420 --> 00:12:02.460
for people to go dive into and explore more.


00:12:02.460 --> 00:12:05.420
I feel like I've gone probably over enough details there


00:12:05.420 --> 00:12:06.260
to give you all a sense,


00:12:06.260 --> 00:12:09.180
but there's some interesting things to be learned, I think.


00:12:09.180 --> 00:12:10.620
- Yeah, definitely.


00:12:10.620 --> 00:12:11.460
- Pretty cool.


00:12:11.460 --> 00:12:13.860
- Yeah, and Matt out there in the live stream


00:12:13.860 --> 00:12:15.620
points out that that might be more than a hundred percent.


00:12:15.620 --> 00:12:16.980
I'm not sure which part you're talking about.


00:12:16.980 --> 00:12:19.980
I do believe a lot of these had multiple,


00:12:19.980 --> 00:12:21.220
you could check multiple things,


00:12:21.220 --> 00:12:23.020
like which languages am I willing to adopt?


00:12:23.020 --> 00:12:26.880
Well, I might be adopting both SQL and Python


00:12:26.880 --> 00:12:28.780
in the next year, something like that.


00:12:28.780 --> 00:12:32.460
- Yeah, I think a lot of people are perpetually


00:12:32.460 --> 00:12:34.860
going to start learning Rust or Go,


00:12:34.860 --> 00:12:37.320
but never started.


00:12:37.320 --> 00:12:38.500
(laughing)


00:12:38.500 --> 00:12:39.340
- That's true.


00:12:39.340 --> 00:12:40.180
- At least we're learning how.


00:12:40.180 --> 00:12:41.000
- Learning how.


00:12:41.000 --> 00:12:41.840
(laughing)


00:12:41.840 --> 00:12:42.680
- Pretty much.


00:12:42.680 --> 00:12:43.900
(laughing)


00:12:43.900 --> 00:12:46.340
- All right. - All right.


00:12:46.340 --> 00:12:47.300
- Cornell.


00:12:47.300 --> 00:12:50.320
So this was suggested by Yale Mintz.


00:12:50.320 --> 00:12:56.280
And Michael, you know where Cornell comes from apparently?


00:12:56.280 --> 00:12:58.060
- I'm thinking Soundgarden.


00:12:58.060 --> 00:13:00.020
Some good 90s grunge.


00:13:00.020 --> 00:13:01.020
I mean.


00:13:01.020 --> 00:13:03.060
- Okay, maybe.


00:13:03.060 --> 00:13:07.180
So Cornell is a record and replay mock server.


00:13:07.180 --> 00:13:11.720
And we're going to link to the tool,


00:13:11.720 --> 00:13:14.880
but also there's an introduction blog post about it.


00:13:14.880 --> 00:13:21.780
And it supposedly makes it really simple to record and replay features


00:13:21.780 --> 00:13:27.580
to perform end-to-end testing in an isolated test environment.


00:13:27.580 --> 00:13:32.780
So the kind of the gist around it, there's a cool tool called VCRPi,


00:13:32.840 --> 00:13:39.140
which saves cassette files for you send a request,


00:13:39.140 --> 00:13:40.200
and you get replies back,


00:13:40.200 --> 00:13:44.160
and then you can save those request reply sessions and stuff.


00:13:44.160 --> 00:13:50.560
And this is a bundling VCR Pi with Flask to make a little server.


00:13:50.560 --> 00:13:53.560
And it's actually really kind of a cool idea.


00:13:53.560 --> 00:13:57.440
The idea, one of the things around it is that you can do,


00:13:57.440 --> 00:14:00.000
you're not just mocking one service,


00:14:00.060 --> 00:14:02.500
you could just mock in any external service


00:14:02.500 --> 00:14:06.880
that you're dealing with, it'll do replays on that.


00:14:06.880 --> 00:14:09.880
And one of the benefits over rolling your own mocks


00:14:09.880 --> 00:14:13.760
or rolling your own test server or test service


00:14:13.760 --> 00:14:18.760
is that you don't really have to think about


00:14:18.760 --> 00:14:19.880
designing the whole thing.


00:14:19.880 --> 00:14:21.840
It just kind of replays everything.


00:14:21.840 --> 00:14:25.240
Looks pretty fun.


00:14:25.240 --> 00:14:28.040
I haven't played with it yet, but definitely want to.


00:14:28.040 --> 00:14:30.620
- Hey, speaking of play with it, click on documentation.


00:14:30.620 --> 00:14:34.180
I think it is on that page right there at the bottom.


00:14:34.180 --> 00:14:35.240
- Documentation.


00:14:35.240 --> 00:14:40.380
- And then click on the documentation of that page.


00:14:40.380 --> 00:14:41.880
There you go.


00:14:41.880 --> 00:14:44.740
And so you have this kind of like a series


00:14:44.740 --> 00:14:47.280
of animated GIFs of scene in action.


00:14:47.280 --> 00:14:48.740
I think that that's kind of cool, right?


00:14:48.740 --> 00:14:50.260
Like you can, it'll go along and say,


00:14:50.260 --> 00:14:53.140
oh yeah, here you're recording a bunch of API calls


00:14:53.140 --> 00:14:56.020
and then the workflow of like how you create it.


00:14:56.020 --> 00:14:58.820
I just want to give a shout out to the animated GIFs for like,


00:14:58.820 --> 00:15:01.220
"Is this interesting to me? Let me just watch the GIFs


00:15:01.220 --> 00:15:04.620
instead of actually take the time to try to adopt it."


00:15:04.620 --> 00:15:07.320
It's simple, but it seems really effective.


00:15:07.320 --> 00:15:09.120
-Juanpe, what do you think? -It's a good idea.


00:15:09.120 --> 00:15:10.520
No, it's a really good idea.


00:15:10.520 --> 00:15:13.320
I mean, there are many projects that you think


00:15:13.320 --> 00:15:14.820
this might be cool to work with,


00:15:14.820 --> 00:15:17.320
and then you start reading walls of text,


00:15:17.320 --> 00:15:20.120
and halfway through, I don't know if it's interesting,


00:15:20.120 --> 00:15:22.520
but I mean, it's been half an hour.


00:15:22.520 --> 00:15:25.820
So, having a bunch of GIFs is eye-catching, yeah.


00:15:25.820 --> 00:15:28.520
- Yeah, for sure, for sure.


00:15:28.520 --> 00:15:32.660
And then, yeah, also I just want a quick shout out


00:15:32.660 --> 00:15:34.000
to the live stream.


00:15:34.000 --> 00:15:36.340
German points out from his experience,


00:15:36.340 --> 00:15:38.540
the data analysis have more men than women,


00:15:38.540 --> 00:15:40.380
but it could be biased due to the tech sector


00:15:40.380 --> 00:15:41.340
having more men in general.


00:15:41.340 --> 00:15:42.220
I do think that that's true.


00:15:42.220 --> 00:15:43.500
I think what they said is,


00:15:43.500 --> 00:15:45.980
if you're a woman, what are you more likely to be doing?


00:15:45.980 --> 00:15:48.340
If you're a man, what are you more likely to be doing?


00:15:48.340 --> 00:15:51.120
And it's like, of that population,


00:15:51.120 --> 00:15:52.740
what areas do you work in?


00:15:52.740 --> 00:15:56.320
not that user experience has more men or women.


00:15:56.320 --> 00:15:59.120
I don't think it addresses that question.


00:15:59.120 --> 00:16:02.280
I think my thoughts here,


00:16:02.280 --> 00:16:05.360
there's a lot of women who end up in programming


00:16:05.360 --> 00:16:08.620
not down the traditional computer science path.


00:16:08.620 --> 00:16:10.400
You know, they go into biology and then they're like,


00:16:10.400 --> 00:16:12.680
oh, I've actually learned a little Python


00:16:12.680 --> 00:16:15.240
and now I really like it and I work here and it's amazing.


00:16:15.240 --> 00:16:18.440
But, you know, they kind of get pulled in tangentially


00:16:18.440 --> 00:16:19.280
where there's a lot of guys


00:16:19.280 --> 00:16:20.720
that like sign up for computer science


00:16:20.720 --> 00:16:22.520
and they just go through that path.


00:16:22.520 --> 00:16:24.420
And some of the areas that were called out


00:16:24.420 --> 00:16:28.160
are more likely to take the straight computer science path


00:16:28.160 --> 00:16:30.360
people, rather than the, I got interested


00:16:30.360 --> 00:16:34.920
and I came in through psychology or something else, where


00:16:34.920 --> 00:16:36.000
there would be more women.


00:16:36.000 --> 00:16:37.040
So I don't know.


00:16:37.040 --> 00:16:38.720
I would love to have more women in there,


00:16:38.720 --> 00:16:40.640
but I think that this is my--


00:16:40.640 --> 00:16:43.840
broadly speaking, but I think this is my thoughts about why


00:16:43.840 --> 00:16:48.480
maybe those different areas seem to attract people not so


00:16:48.480 --> 00:16:52.240
directly down the computer science path.


00:16:52.240 --> 00:16:53.460
Anyway, yeah.


00:16:53.460 --> 00:16:56.260
All right, Juanpe, you're up.


00:16:56.260 --> 00:16:59.280
Talk to us about the next thing you got here.


00:16:59.280 --> 00:17:00.520
- Sure.


00:17:00.520 --> 00:17:03.040
So I wanna talk about Factory Boy.


00:17:03.040 --> 00:17:05.280
I think it's a very well-known library


00:17:05.280 --> 00:17:11.660
to basically mock objects when you're running tests.


00:17:11.660 --> 00:17:14.720
And both this and the next tool I'm gonna talk about


00:17:14.720 --> 00:17:17.660
came because we were working on a system


00:17:17.660 --> 00:17:21.380
that replicates an entire Salesforce org.


00:17:21.380 --> 00:17:25.620
So we have a infrastructure we've built that takes everything you have,


00:17:25.620 --> 00:17:28.720
every object you have in Salesforce, and copy it to a database.


00:17:28.720 --> 00:17:31.760
This is a way we have to have daily snapshot of the data


00:17:31.760 --> 00:17:34.300
that we can do a time series and analysis


00:17:34.300 --> 00:17:36.460
and all the models that we have on it,


00:17:36.460 --> 00:17:39.160
instead of being a few minutes, let's say,


00:17:39.160 --> 00:17:41.160
when you modify it, it's lost.


00:17:41.160 --> 00:17:45.940
So for this, we obviously need to communicate a lot with the API in Salesforce.


00:17:45.940 --> 00:17:48.940
And when you get API responses,


00:17:48.940 --> 00:17:55.140
You need to not only treat the JSON plainly,


00:17:55.140 --> 00:17:57.740
let's say, just the plain JSON object,


00:17:57.740 --> 00:18:01.180
but you will like also to have some kind of representation.


00:18:01.180 --> 00:18:03.340
And for this, I think it's not news for anyone.


00:18:03.340 --> 00:18:07.100
The Pydantic right now is taking the floor.


00:18:07.100 --> 00:18:10.700
And the biggest issue came


00:18:10.700 --> 00:18:13.140
when we needed to start writing tests for it.


00:18:13.140 --> 00:18:17.420
Because we get the JSON file,


00:18:17.420 --> 00:18:20.260
we stick it in the Pydantic object, it validates everything,


00:18:20.260 --> 00:18:22.100
everything's beautiful and works fine.


00:18:22.100 --> 00:18:25.180
But then we have a bunch of fields on the object


00:18:25.180 --> 00:18:27.060
that cannot be nulled, for instance,


00:18:27.060 --> 00:18:28.600
or they are not optional.


00:18:28.600 --> 00:18:30.100
So they need to come in the API


00:18:30.100 --> 00:18:31.340
and we need to validate for those


00:18:31.340 --> 00:18:33.540
because if the API does not return any of those,


00:18:33.540 --> 00:18:35.300
it should break and tell us,


00:18:35.300 --> 00:18:37.860
look, this is wrong, it's not what you expected.


00:18:37.860 --> 00:18:41.380
So when we wanted to write tests for those


00:18:41.380 --> 00:18:44.740
and we wanted to create objects for those in each test,


00:18:44.740 --> 00:18:47.340
we noticed that out of hundreds of fields,


00:18:47.340 --> 00:18:52.020
we might need to fill, I don't know, probably 80, 90 of them


00:18:52.020 --> 00:18:55.900
because they were mandatory and it started to be very tedious.


00:18:55.900 --> 00:18:58.660
And I remember I opened an issue in the Pydantic.


00:18:58.660 --> 00:19:03.260
I say, "Hey, have you thought about probably allowing


00:19:03.260 --> 00:19:07.740
creating an object with random fields that validate properly?


00:19:07.740 --> 00:19:10.540
Like this feels an integer between 10 and 20."


00:19:10.540 --> 00:19:12.140
So I just don't want to fill it.


00:19:12.140 --> 00:19:13.460
I don't want to fill any of those


00:19:13.460 --> 00:19:15.020
because I don't care for these tests.


00:19:15.020 --> 00:19:18.300
Is there a way that I can say, okay, just fill whatever it validates?


00:19:18.300 --> 00:19:20.700
And they say, no, it's out of the scope of Quarantic,


00:19:20.700 --> 00:19:23.300
which also makes sense, I just wanted to ask in case.


00:19:23.300 --> 00:19:25.700
And they said that probably in Factory Boy,


00:19:25.700 --> 00:19:27.060
they might be interested in this.


00:19:27.060 --> 00:19:30.060
So I went to Factory Boy, and I read the documentation.


00:19:30.060 --> 00:19:32.820
It was pretty cool because it allows you to create


00:19:32.820 --> 00:19:35.940
unifying an inside class.


00:19:35.940 --> 00:19:41.740
So it's a meta class, not a meta class in the terms of Python meta classes,


00:19:41.740 --> 00:19:46.740
but it's a class called Meta within the factory that you want.


00:19:46.740 --> 00:19:49.240
It's weird because every time you say, "Yeah, this is the Meta class."


00:19:49.240 --> 00:19:51.480
"Wait, the Meta class?" "No, it's a class Meta."


00:19:51.480 --> 00:19:56.220
So you inherit from factory, then you define a class called Meta,


00:19:56.220 --> 00:19:58.420
Meta, where you define what is your model.


00:19:58.420 --> 00:20:01.820
So this is the object I want to mock with this factory.


00:20:01.820 --> 00:20:06.460
And then you can define many fields with their default values.


00:20:06.460 --> 00:20:09.460
The cool thing about this is that it implements also Faker.


00:20:09.460 --> 00:20:12.460
So you can say if I have a username, I don't want to fill it.


00:20:12.460 --> 00:20:14.460
Just give me a username and Faker will give you.


00:20:14.460 --> 00:20:17.460
Yeah, Faker is really cool for generating stuff like that.


00:20:17.460 --> 00:20:21.800
Yeah, and the amount of plugins you find for Faker is outstanding.


00:20:21.800 --> 00:20:24.800
So you can fake almost anything you think of.


00:20:24.800 --> 00:20:28.140
So the cool thing about this is that it's not only


00:20:28.140 --> 00:20:30.940
you plug in the class that you have and it will fill it,


00:20:30.940 --> 00:20:33.440
but you also can work with ORMs, like you can use


00:20:33.440 --> 00:20:36.880
SQL, QM, or Django, or ORM,


00:20:36.880 --> 00:20:41.020
and it will generate an object for this ORM


00:20:41.020 --> 00:20:44.620
based on whatever you set these are the default values.


00:20:44.620 --> 00:20:48.680
So I thought it would be great if I could do this also for Pydantic.


00:20:48.680 --> 00:20:52.120
So I could just say, "These are the mandatory fields.


00:20:52.120 --> 00:20:54.320
It puts something fake, you can think about it."


00:20:54.320 --> 00:20:56.820
And then we're ready to go. But reading the documentation,


00:20:56.820 --> 00:21:01.220
it didn't appear anywhere, and I thought, "Hmm, maybe I cannot use it for this case."


00:21:01.220 --> 00:21:03.320
So I went ahead and opened it and said,


00:21:03.320 --> 00:21:05.820
"Are you thinking about putting this also to work with Pydantic?"


00:21:05.820 --> 00:21:09.140
I mean, it's now is booming and everyone is using it.


00:21:09.140 --> 00:21:11.420
And if you are reading JSON from an API,


00:21:11.420 --> 00:21:13.380
it's very likely that you have hundreds of fields


00:21:13.380 --> 00:21:14.220
you don't care about.


00:21:14.220 --> 00:21:16.800
You might want to fill it with whatever.


00:21:16.800 --> 00:21:18.480
And I remember the author said,


00:21:18.480 --> 00:21:20.620
"I didn't know this.


00:21:20.620 --> 00:21:22.300
"I didn't know Pydantics,


00:21:22.300 --> 00:21:23.500
"could you mention it,


00:21:23.500 --> 00:21:25.680
"but internally what Factory Go is doing


00:21:25.680 --> 00:21:27.380
"is creating a dictionary with the parameters


00:21:27.380 --> 00:21:29.920
"you want to fill in and just unpacking it


00:21:29.920 --> 00:21:32.120
"in the construction of the class.


00:21:32.120 --> 00:21:32.960
"Have you tried it?"


00:21:32.960 --> 00:21:34.860
And I was like, "No, I have not."


00:21:34.860 --> 00:21:36.340
When I tried it worked.


00:21:36.340 --> 00:21:39.940
So it was perfectly, I mean, maybe there are some quirks


00:21:39.940 --> 00:21:42.260
of Pydantic that it kind of covers,


00:21:42.260 --> 00:21:46.680
but if you're using Pydantic to store your data


00:21:46.680 --> 00:21:50.060
from API calls and so on, from JSON and validates and so on,


00:21:50.060 --> 00:21:51.620
a factory is pretty cool.


00:21:51.620 --> 00:21:54.220
I mean, the amount of things you can do with this,


00:21:54.220 --> 00:21:56.820
you can create many factory for the same class


00:21:56.820 --> 00:21:58.660
and you can create fixtures like,


00:21:58.660 --> 00:21:59.940
I don't know if you want to mock a new user,


00:21:59.940 --> 00:22:03.300
you can have an admin or a buyer or whatever,


00:22:03.300 --> 00:22:06.040
and then you can just define different factories,


00:22:06.040 --> 00:22:08.340
and it will give you the usage you've defined.


00:22:08.340 --> 00:22:14.420
And it's also pretty cool because the faker is randomized beneath it.


00:22:14.420 --> 00:22:20.500
So if there are parts of your object that your code does not care about,


00:22:20.500 --> 00:22:23.720
it's also a good test to have those parts being random


00:22:23.720 --> 00:22:27.300
because if it really doesn't care, you don't care what those fields are,


00:22:27.300 --> 00:22:31.000
and at some point, your test fails, it happens once,


00:22:31.000 --> 00:22:34.200
it means that you actually can fix something.


00:22:34.200 --> 00:22:35.760
- Yeah, absolutely.


00:22:35.760 --> 00:22:39.520
I did see that if you need repeatable tests,


00:22:39.520 --> 00:22:41.560
but you want Faker to generate random stuff,


00:22:41.560 --> 00:22:44.120
there's a way to seed Faker.


00:22:44.120 --> 00:22:44.960
- Exactly.


00:22:44.960 --> 00:22:46.280
- Generate the random values,


00:22:46.280 --> 00:22:47.680
but do it in a consistent way.


00:22:47.680 --> 00:22:50.000
And one way you might want that is if you have an edge case


00:22:50.000 --> 00:22:51.940
or some value that breaks the test,


00:22:51.940 --> 00:22:54.800
and then you wanna put a break point


00:22:54.800 --> 00:22:57.560
and press debug and go through it again,


00:22:57.560 --> 00:22:59.160
but like, you know, how are you gonna get it


00:22:59.160 --> 00:23:02.080
to hit that case again in a predictable way, right?


00:23:02.080 --> 00:23:04.480
So if you tell it to say,


00:23:04.480 --> 00:23:06.440
always do the same thing, but randomly,


00:23:06.440 --> 00:23:08.280
you know, it'll make it,


00:23:08.280 --> 00:23:10.080
so you can go back and look at it a second time


00:23:10.080 --> 00:23:11.520
and figure out what's up.


00:23:11.520 --> 00:23:12.640
- Yeah, you can fix that.


00:23:12.640 --> 00:23:15.360
Sometimes it's also good to have them fixed,


00:23:15.360 --> 00:23:16.840
even if you don't care.


00:23:16.840 --> 00:23:19.320
I mean, you need to have a date time,


00:23:19.320 --> 00:23:21.200
and for some reason you need to have the date time


00:23:21.200 --> 00:23:23.880
being whatever and whatever, but you can validate for it.


00:23:23.880 --> 00:23:25.640
So you can just, or either set it


00:23:25.640 --> 00:23:27.680
or ensure that it's fixed.


00:23:27.680 --> 00:23:30.720
Yeah, there are many use cases that you can


00:23:30.720 --> 00:23:32.160
exploit that thing.


00:23:32.160 --> 00:23:34.080
And it's actually really cool.


00:23:34.080 --> 00:23:38.200
- Yeah, I usually, I almost always seed Faker


00:23:38.200 --> 00:23:41.000
because I just, I don't, I'm not using it


00:23:41.000 --> 00:23:42.400
because I want the randomness.


00:23:42.400 --> 00:23:44.480
So I'm using it because I don't want to come up


00:23:44.480 --> 00:23:45.320
with the data.


00:23:45.320 --> 00:23:47.920
- Yeah, exactly.


00:23:47.920 --> 00:23:49.840
So make it so that it does the same thing every time.


00:23:49.840 --> 00:23:52.240
Just gives you the random data that you want.


00:23:52.240 --> 00:23:53.680
That's right.


00:23:53.680 --> 00:23:54.520
Agreed.


00:23:54.520 --> 00:23:55.340
Very, very cool.


00:23:56.800 --> 00:23:59.700
- All right, the next one up actually is pretty,


00:23:59.700 --> 00:24:02.480
it's sort of related to that.


00:24:02.480 --> 00:24:03.800
It's called PyInstrument.


00:24:03.800 --> 00:24:06.340
Have either of you heard of PyInstrument?


00:24:06.340 --> 00:24:07.480
- Not until now.


00:24:07.480 --> 00:24:10.000
When I read the notes and it sounds pretty cool.


00:24:10.000 --> 00:24:11.320
- Yeah, right?


00:24:11.320 --> 00:24:12.320
- No, I haven't.


00:24:12.320 --> 00:24:16.080
- Yeah, so it's a call stack profiler for Python,


00:24:16.080 --> 00:24:17.240
which is pretty cool, right?


00:24:17.240 --> 00:24:19.720
It's just gonna tell you where your code is slow,


00:24:19.720 --> 00:24:22.500
but it's, you know, it looks really clean.


00:24:22.500 --> 00:24:24.840
And when you look at the output,


00:24:24.840 --> 00:24:29.440
it can actually give you the results in the terminal.


00:24:29.440 --> 00:24:34.040
So if you want to see, you know, like you run this thing,


00:24:34.040 --> 00:24:39.040
instead of saying Python, my Python.py file,


00:24:39.040 --> 00:24:41.880
you would just say py instrument, that same file,


00:24:41.880 --> 00:24:43.440
and it'll run it, but then at the end,


00:24:43.440 --> 00:24:46.240
it's going to generate a whole bunch of things


00:24:46.240 --> 00:24:48.520
about how long it took and whatnot.


00:24:48.520 --> 00:24:53.320
And then you actually get like colored output


00:24:53.320 --> 00:24:55.900
in the terminal showing which lines of code


00:24:55.900 --> 00:24:58.440
are spending how much time in different places.


00:24:58.440 --> 00:25:00.920
And it seems like it's a real good way


00:25:00.920 --> 00:25:02.200
to just sort of quickly dive in


00:25:02.200 --> 00:25:04.000
on where you're spending your time.


00:25:04.000 --> 00:25:06.880
- Yeah, I'm definitely gonna try this.


00:25:06.880 --> 00:25:07.720
It's cool.


00:25:07.720 --> 00:25:09.680
- Yeah, one thing I like about it is the simplicity


00:25:09.680 --> 00:25:11.320
of like pip install pyinstrument,


00:25:11.320 --> 00:25:12.960
pyinstrument your file.


00:25:12.960 --> 00:25:16.600
That'll give you the answer, right?


00:25:16.600 --> 00:25:18.240
- That for me solved it.


00:25:18.240 --> 00:25:20.920
I mean, every time you want to do some profiling,


00:25:20.920 --> 00:25:23.600
unless they spend some time tweaking things


00:25:23.600 --> 00:25:25.120
so you get what you want.


00:25:25.120 --> 00:25:27.320
The fact that this is just running with PyInstrument,


00:25:27.320 --> 00:25:31.840
whatever script you want, I mean, I'm gonna try for sure.


00:25:31.840 --> 00:25:32.680
- Yeah, yeah, for sure.


00:25:32.680 --> 00:25:35.760
And when you do profiling, you end up in this


00:25:35.760 --> 00:25:39.520
sort of quantum mechanics world of,


00:25:39.520 --> 00:25:42.160
if you observe a thing, you've changed it.


00:25:42.160 --> 00:25:44.520
So there might be code that is like,


00:25:44.520 --> 00:25:48.240
this half is 50/50 and this half is 50/50 of the time,


00:25:48.240 --> 00:25:51.520
but one is calling an external system once


00:25:51.520 --> 00:25:52.780
and the other is a tight loop.


00:25:52.780 --> 00:25:56.380
And if you profile that with instrumentation,


00:25:56.380 --> 00:25:58.280
it's going to wreck it.


00:25:58.280 --> 00:26:00.360
It's going to make the loop look way slower


00:26:00.360 --> 00:26:02.920
'cause now you've added a bunch of overhead to each step


00:26:02.920 --> 00:26:04.600
where there's very little overhead


00:26:04.600 --> 00:26:07.280
to this external service sort of thing.


00:26:07.280 --> 00:26:09.720
And this one uses sampling


00:26:09.720 --> 00:26:12.560
and the sampling doesn't really have that effect.


00:26:12.560 --> 00:26:14.160
It just every so often,


00:26:14.160 --> 00:26:16.240
like every millisecond or something that says,


00:26:16.240 --> 00:26:17.200
what are you doing now?


00:26:17.200 --> 00:26:18.480
What are you doing now?


00:26:18.480 --> 00:26:19.320
Who called you?


00:26:19.320 --> 00:26:20.140
What are you doing now?


00:26:20.140 --> 00:26:20.980
Right?


00:26:20.980 --> 00:26:23.760
And so it's more of a polling sort of thing


00:26:23.760 --> 00:26:28.340
rather than slowing down a line by line code.


00:26:28.340 --> 00:26:30.360
So that's probably worth doing as well.


00:26:30.360 --> 00:26:32.960
- Yeah, that's pretty cool.


00:26:32.960 --> 00:26:33.800
- Yeah.


00:26:33.800 --> 00:26:36.280
- Yeah, it's like you can specifically jump in


00:26:36.280 --> 00:26:38.160
and just do a section of your code


00:26:38.160 --> 00:26:40.000
that you care about also.


00:26:40.000 --> 00:26:40.840
- Exactly.


00:26:40.840 --> 00:26:42.160
If you wanna say,


00:26:42.160 --> 00:26:45.560
so one of the things that I hate about profiling is


00:26:45.560 --> 00:26:49.700
it'll say 87% of your time was in the startup code


00:26:49.700 --> 00:26:50.540
and the imports.


00:26:50.540 --> 00:26:53.860
You're like, yeah, okay, that's not relevant to me.


00:26:53.860 --> 00:26:55.000
What I wanna know is the part


00:26:55.000 --> 00:26:57.300
that I'm actually trying to test here.


00:26:57.300 --> 00:26:59.680
How long did I spend there?


00:26:59.680 --> 00:27:02.280
And please don't pollute that with other junk


00:27:02.280 --> 00:27:04.520
about like starting up Python


00:27:04.520 --> 00:27:07.400
or loading modules or whatever, right?


00:27:07.400 --> 00:27:10.680
And so you can, there's an API


00:27:10.680 --> 00:27:14.400
and you can say from Python import profiler,


00:27:14.400 --> 00:27:19.400
And then you can do a context block in there and run it.


00:27:19.400 --> 00:27:22.340
And just that code will tell you like how long it takes.


00:27:22.340 --> 00:27:26.160
Does anything else jump out there at you, Brian?


00:27:26.160 --> 00:27:28.940
And like with this example I got on the screen here,


00:27:28.940 --> 00:27:30.800
that will be hard.


00:27:30.800 --> 00:27:33.360
- It's an async example for one.


00:27:33.360 --> 00:27:35.600
- Yeah, as an async and a wait.


00:27:35.600 --> 00:27:39.220
And so they recently released PI instrument four,


00:27:39.220 --> 00:27:42.520
which will actually give you the information


00:27:42.520 --> 00:27:47.520
about the async code as well.


00:27:47.520 --> 00:27:49.880
So it'll, let's see what it says.


00:27:49.880 --> 00:27:51.120
So it has async support,


00:27:51.120 --> 00:27:54.280
PyInstrument now detects when an async task hits an await


00:27:54.280 --> 00:27:57.920
and tracks the time spent outside of the async context


00:27:57.920 --> 00:27:59.080
under the await.


00:27:59.080 --> 00:28:01.160
Whereas before it would basically just profile


00:28:01.160 --> 00:28:05.320
the asyncio event loop or something silly like that.


00:28:05.320 --> 00:28:08.520
So if you're trying to profile async and await


00:28:08.520 --> 00:28:11.180
and asyncio, this might be your best option


00:28:11.180 --> 00:28:13.080
'cause it specifically supports that.


00:28:13.080 --> 00:28:16.140
- That's good.


00:28:16.140 --> 00:28:21.140
So what happened before if you use a different profile?


00:28:21.140 --> 00:28:24.540
- It would say, yeah, it says you only see the time spent


00:28:24.540 --> 00:28:28.100
in the run loop and it'll basically tell you like,


00:28:28.100 --> 00:28:30.700
here you see like run once, the select


00:28:30.700 --> 00:28:33.020
and then the Q control built in.


00:28:33.020 --> 00:28:36.460
It's just like, there's this asyncio event loop


00:28:36.460 --> 00:28:38.380
just cranking around waiting for the signal


00:28:38.380 --> 00:28:39.500
for the IO to be done.


00:28:39.500 --> 00:28:41.340
and it just says, well, you're waiting on this,


00:28:41.340 --> 00:28:42.860
you're in the loop, you know what I mean?


00:28:42.860 --> 00:28:43.980
- Yeah, yeah, yeah.


00:28:43.980 --> 00:28:46.660
- Yeah, so, yeah.


00:28:46.660 --> 00:28:47.900
So now you get a little bit better.


00:28:47.900 --> 00:28:50.300
Like it says, okay, you're waiting on this line


00:28:50.300 --> 00:28:54.100
of your code for a second or whatever it is.


00:28:54.100 --> 00:28:57.620
Yeah, there's also, I'll shout out a few more things here.


00:28:57.620 --> 00:28:58.620
Is it in the stock?


00:28:58.620 --> 00:28:59.460
Yeah, so,


00:28:59.460 --> 00:29:03.980
they also, there's also a bunch of simple authentication


00:29:03.980 --> 00:29:07.140
they did previously about network calls and stuff.


00:29:07.140 --> 00:29:12.140
and there's an interactive Vue.js app


00:29:12.140 --> 00:29:14.260
that you can get with Flame Graphs.


00:29:14.260 --> 00:29:15.980
So instead of looking at it in the terminal,


00:29:15.980 --> 00:29:17.620
you can look at it in your web browser


00:29:17.620 --> 00:29:19.980
and explore into those.


00:29:19.980 --> 00:29:22.180
So yeah, there's a lot of neat little things here.


00:29:22.180 --> 00:29:23.500
I pulled out the show notes,


00:29:23.500 --> 00:29:27.060
but it seems like a really nice way to do some profiling


00:29:27.060 --> 00:29:30.060
and you just high instrument your code and you have a look.


00:29:30.060 --> 00:29:32.580
- Cool.


00:29:32.580 --> 00:29:35.040
- Yeah, I personally kind of like the default output.


00:29:35.040 --> 00:29:37.040
I know that a lot of people like Flame Graphs.


00:29:37.040 --> 00:29:40.120
like they don't really do much for me.


00:29:40.120 --> 00:29:42.760
They look like, I don't see the data,


00:29:42.760 --> 00:29:45.760
but it's cool that it has both.


00:29:45.760 --> 00:29:47.160
- Yeah.


00:29:47.160 --> 00:29:49.440
A couple of things from the live chat.


00:29:49.440 --> 00:29:51.560
Maddy says, "Pi instrument is a statistical


00:29:51.560 --> 00:29:53.440
"or sampling profiler,


00:29:53.440 --> 00:29:56.360
"which is better paradigm for profiling."


00:29:56.360 --> 00:29:57.480
I think it depends.


00:29:57.480 --> 00:30:01.400
I mean, the instrumentation ones do give you


00:30:01.400 --> 00:30:02.960
more precise information,


00:30:02.960 --> 00:30:07.960
but it's also skewed with the overhead of that information.


00:30:07.960 --> 00:30:11.960
So it depends, but this is the least influential one


00:30:11.960 --> 00:30:13.100
for sure.


00:30:13.100 --> 00:30:17.360
And then Avaro says,


00:30:17.360 --> 00:30:20.120
"How would you use PyInstrument with an entry point?"


00:30:20.120 --> 00:30:22.420
That's a good question.


00:30:22.420 --> 00:30:25.920
Not knowing the answer off the top of my head,


00:30:25.920 --> 00:30:28.340
maybe make another Python file that just imports


00:30:28.340 --> 00:30:29.960
your library and calls the entry point


00:30:29.960 --> 00:30:31.120
and then profile that.


00:30:31.120 --> 00:30:36.960
But there's a real quick cheat, you know, just make it call it and then


00:30:36.960 --> 00:30:43.360
pi instrument that file. But there may be some way to say like dash m and give it


00:30:43.360 --> 00:30:49.920
a module and a thing to do. So yeah, that's it, Brian. That's it for pi instrument.


00:30:49.920 --> 00:30:58.080
>> Cool. Well, I just wanted to remind everybody that Python 3.10 release candidate one came out


00:30:58.080 --> 00:31:03.840
yesterday. So Pablo announced it just on the third, I think. I think it was yesterday.


00:31:03.840 --> 00:31:14.080
Isn't it the fourth today? Yeah, anyway. So 3.10 is out. If you've got, well, 3.10,


00:31:14.080 --> 00:31:20.480
RC1 is out. The timelines that we're looking at then, we're getting excited, it's coming up. So


00:31:20.480 --> 00:31:23.820
So September 6th is the plan for RC2,


00:31:23.820 --> 00:31:28.120
and then October 4th is the plan for the official release.


00:31:28.120 --> 00:31:31.220
So we're just really right around the corner. It's nice.


00:31:31.220 --> 00:31:35.020
And this is definitely a time, I know we've brought this up before,


00:31:35.020 --> 00:31:38.720
but if you maintain any third-party Python packages,


00:31:38.720 --> 00:31:42.820
you probably should have already been testing it against 3.10.


00:31:42.820 --> 00:31:46.020
But if you haven't, definitely do it now


00:31:46.020 --> 00:31:49.620
to make sure that people that use your stuff don't.


00:31:49.680 --> 00:31:51.920
that doesn't break when they need to.


00:31:51.920 --> 00:31:56.120
And then in the show notes, we put just a list of,


00:31:56.120 --> 00:31:59.320
just a reminder of some of the new changes in 3.10.


00:31:59.320 --> 00:32:02.420
We've definitely talked about some of these before,


00:32:02.420 --> 00:32:05.120
structural pattern matching,


00:32:05.120 --> 00:32:07.420
which is the switch statement kind of thing.


00:32:07.420 --> 00:32:11.680
And then, yeah, lots of these other things we've covered.


00:32:11.680 --> 00:32:15.620
I'm kind of actually, I like the union types,


00:32:15.620 --> 00:32:19.180
because there's a lot of stuff that I write


00:32:19.240 --> 00:32:21.560
that the default is none,


00:32:21.560 --> 00:32:23.800
but the normal type is something else.


00:32:23.800 --> 00:32:28.160
So you can really easily say the type is none or int,


00:32:28.160 --> 00:32:29.400
or something like that.


00:32:29.400 --> 00:32:33.000
And that's a lot cleaner than before.


00:32:33.000 --> 00:32:35.920
I've already started using 310


00:32:35.920 --> 00:32:38.680
to test everything that I support.


00:32:38.680 --> 00:32:41.920
So hope everybody else has as well.


00:32:41.920 --> 00:32:42.740
- Yeah, cool.


00:32:42.740 --> 00:32:45.880
I like the optional length checking in zip, right?


00:32:45.880 --> 00:32:47.480
Zip taking two collections


00:32:47.480 --> 00:32:49.020
and you wanna pair up the items,


00:32:49.020 --> 00:32:52.420
Like if those things don't match, that should be a problem.


00:32:52.420 --> 00:32:55.220
Also like the or for the types information.


00:32:55.220 --> 00:32:58.180
And I think dict and some of those types


00:32:58.180 --> 00:33:02.940
are now don't require a from typing imports.


00:33:02.940 --> 00:33:03.860
- Oh, right, yeah.


00:33:03.860 --> 00:33:06.180
- I don't see it called out here,


00:33:06.180 --> 00:33:09.240
but one of the problem was,


00:33:09.240 --> 00:33:12.980
maybe that's explicit type aliases, I'm not entirely sure.


00:33:12.980 --> 00:33:15.540
But if you wanna say this type is a dictionary


00:33:15.540 --> 00:33:20.060
of strings and integers, you would have to say


00:33:20.060 --> 00:33:23.700
from typing import capital D dict


00:33:23.700 --> 00:33:27.980
and then dict square bracket, string comma int,


00:33:27.980 --> 00:33:32.140
whereas now you can just use the lowercase d-i-c-t


00:33:32.140 --> 00:33:33.740
and you don't have to have that import


00:33:33.740 --> 00:33:34.940
and you can do that sort of thing too.


00:33:34.940 --> 00:33:36.660
So I'm looking forward to that.


00:33:36.660 --> 00:33:38.460
- Yeah, a lot of the, a lot of,


00:33:38.460 --> 00:33:42.220
with this, a lot of the common type hints,


00:33:42.220 --> 00:33:44.220
you won't have to do the import anymore.


00:33:44.220 --> 00:33:46.400
And that's great.


00:33:46.400 --> 00:33:48.820
So I think that's really all I was using the import for


00:33:48.820 --> 00:33:52.380
was things like dict and set, things like that.


00:33:52.380 --> 00:33:54.020
- Yeah, exactly.


00:33:54.020 --> 00:33:58.500
- Didn't that, I mean, I seem to remember that 3.10


00:33:58.500 --> 00:34:01.980
was the one that was including these built-in types


00:34:01.980 --> 00:34:04.100
without having to import from typing.


00:34:04.100 --> 00:34:07.860
Didn't that update might break


00:34:07.860 --> 00:34:11.300
some of the libraries that use typing?


00:34:11.300 --> 00:34:13.660
- Like Pydantic and FastAPI.


00:34:13.660 --> 00:34:17.180
- The thing that that was, was to use it in,


00:34:17.180 --> 00:34:20.220
basically use it as a string


00:34:20.220 --> 00:34:23.060
and not actually evaluate the type.


00:34:23.060 --> 00:34:25.700
I think that like, so if you had your own type,


00:34:25.700 --> 00:34:28.560
your own pedantic type that was a customer,


00:34:28.560 --> 00:34:29.860
I think you could put customer,


00:34:29.860 --> 00:34:31.800
but it wouldn't be actually evaluated


00:34:31.800 --> 00:34:35.140
until a type checker hit it or something like that.


00:34:35.140 --> 00:34:36.060
- Forward typing.


00:34:36.060 --> 00:34:37.460
- Yeah, yeah, exactly.


00:34:37.460 --> 00:34:41.000
So this ability to specify the type


00:34:41.000 --> 00:34:45.400
on like lowercase ddict is related, but it's not the same.


00:34:45.400 --> 00:34:46.240
- Okay.


00:34:46.240 --> 00:34:49.320
- And I'm pretty sure that that fear around Pydantic


00:34:49.320 --> 00:34:51.760
is not in 3.10.


00:34:51.760 --> 00:34:55.200
- Yeah, either got postponed or rolled back or modified.


00:34:55.200 --> 00:34:56.040
Yeah.


00:34:56.040 --> 00:35:00.820
- I just want to talk about the one that says,


00:35:00.820 --> 00:35:04.680
what was the number?


00:35:04.680 --> 00:35:08.280
Six, two six, do you have it?


00:35:10.200 --> 00:35:11.740
- Yeah, the precise line numbers


00:35:11.740 --> 00:35:14.060
for debugging and other tools.


00:35:14.060 --> 00:35:16.200
- I think it's very underrated.


00:35:16.200 --> 00:35:18.060
(laughs)


00:35:18.060 --> 00:35:19.380
It's gonna be one of those things


00:35:19.380 --> 00:35:20.580
that when people get used to it,


00:35:20.580 --> 00:35:22.860
it's like, I don't know how you live without this.


00:35:22.860 --> 00:35:24.340
- Oh yeah.


00:35:24.340 --> 00:35:27.860
Yeah, there's not a good example shown right off the bat,


00:35:27.860 --> 00:35:29.860
but it's pretty cool.


00:35:29.860 --> 00:35:32.860
- Yeah, yeah, absolutely.


00:35:32.860 --> 00:35:33.820
Very cool, and then we also have better


00:35:33.820 --> 00:35:36.180
stack trace error messages, right?


00:35:36.180 --> 00:35:37.460
- Yeah. - Yeah, those are coming.


00:35:37.460 --> 00:35:39.580
A lot of good things to look forward to.


00:35:39.580 --> 00:35:40.420
- Yeah.


00:35:40.420 --> 00:35:42.540
- All right, Juanpe, you got the last item.


00:35:42.540 --> 00:35:43.380
- Great.


00:35:43.380 --> 00:35:44.340
- I think it's time for it.


00:35:44.340 --> 00:35:46.300
You wanna take us out, right?


00:35:46.300 --> 00:35:47.140
- Sure.


00:35:47.140 --> 00:35:50.760
Yeah, so let's talk about Time Machine.


00:35:50.760 --> 00:35:55.060
I said we were building this tool


00:35:55.060 --> 00:35:57.500
that copies an entire Salesforce org.


00:35:57.500 --> 00:35:59.580
One of the things that we need to orchestrate everything


00:35:59.580 --> 00:36:02.260
is to timestamp almost every action we do.


00:36:02.260 --> 00:36:06.440
This means that in many places all over the code,


00:36:06.440 --> 00:36:10.720
we have a DaytimeUTCNow method call.


00:36:10.720 --> 00:36:14.420
And when we are testing it, we need to be able to mock it.


00:36:14.420 --> 00:36:18.620
And if you've tried to patch DaytimeUTCNow


00:36:18.620 --> 00:36:22.140
with the usual patch method, it works, you can do it,


00:36:22.140 --> 00:36:24.180
but you need to do it with a patch


00:36:24.180 --> 00:36:25.580
and then you pass the string,


00:36:25.580 --> 00:36:29.780
but the module where this UTCNow call is,


00:36:29.780 --> 00:36:31.380
and then you're good to go.


00:36:31.380 --> 00:36:33.540
But when you have this in many files in the same test,


00:36:33.540 --> 00:36:35.260
you need to patch every one of those


00:36:35.260 --> 00:36:37.020
because otherwise it wouldn't work.


00:36:37.020 --> 00:36:40.580
So I tried to use patch object and patch daytime and say,


00:36:40.580 --> 00:36:43.740
okay, I want to patch the, you know, method of this object.


00:36:43.740 --> 00:36:46.340
And it will of course complain and say,


00:36:46.340 --> 00:36:51.340
you cannot patch a built-in type like daytime, daytime.


00:36:51.340 --> 00:36:54.300
So I was looking for how we could patch this


00:36:54.300 --> 00:36:59.300
and I found Freescan, which is a very well-known library


00:36:59.300 --> 00:37:01.580
thing to patch this kind of things.


00:37:01.580 --> 00:37:05.000
But suddenly I noticed that once I started using Frisk,


00:37:05.000 --> 00:37:09.540
and all of my tests took much longer to complete.


00:37:09.540 --> 00:37:14.240
It's not like deal breaker.


00:37:14.240 --> 00:37:17.460
So it went for probably five minutes to seven,


00:37:17.460 --> 00:37:18.620
or seven and a half.


00:37:18.620 --> 00:37:22.020
But it was very surprised because our pipeline


00:37:22.020 --> 00:37:24.140
or deployment pipeline really take a long time.


00:37:24.140 --> 00:37:27.100
So every time I can reduce a minute, it's good for me.


00:37:27.100 --> 00:37:28.820
And when I saw it going up two minutes,


00:37:28.820 --> 00:37:31.200
I was surprised, why is this happening?


00:37:31.200 --> 00:37:33.100
And then I learned that what Freescan is doing


00:37:33.100 --> 00:37:36.180
is actually scanning all your dependencies


00:37:36.180 --> 00:37:38.620
and making the patch for every call you make


00:37:38.620 --> 00:37:40.240
to the methods of data.


00:37:40.240 --> 00:37:44.960
And then in trying to see if there was something else,


00:37:44.960 --> 00:37:47.060
I found out Time Machine.


00:37:47.060 --> 00:37:51.900
Time Machine is a very cool,


00:37:51.900 --> 00:37:54.820
not so well-known, I think, library


00:37:54.820 --> 00:37:57.360
that allows you to do basically the same


00:37:57.360 --> 00:37:59.040
that Freescan allows you to do.


00:37:59.040 --> 00:38:04.880
so you can just patch almost any method call in daytime or time


00:38:04.880 --> 00:38:07.520
with a simple decorator in your test.


00:38:07.520 --> 00:38:10.120
It also supports pytest fixtures that you can use.


00:38:10.120 --> 00:38:16.360
The good thing about this is that it does not scan for imports of date and datetime,


00:38:16.360 --> 00:38:21.660
and what it does is actually change the underlying C-level calls


00:38:21.660 --> 00:38:24.400
that you make to get the time.


00:38:24.400 --> 00:38:27.980
So every time you say, "I want to patch any call


00:38:27.980 --> 00:38:31.680
to be on January 1st of 2019," for instance,


00:38:31.680 --> 00:38:33.680
it will just call it normally,


00:38:33.680 --> 00:38:37.120
but the underlined C calls that will be made


00:38:37.120 --> 00:38:39.120
will return this time instead of the other ones.


00:38:39.120 --> 00:38:41.120
You don't need to scan everything to patch it.


00:38:41.120 --> 00:38:44.260
Another thing that I thought was pretty cool


00:38:44.260 --> 00:38:48.060
is you can let the time tick after you patched it.


00:38:48.060 --> 00:38:52.600
So you say, "This is for February 1st of 2018,"


00:38:52.600 --> 00:38:57.040
And once you enter the mock, either with a decorator


00:38:57.040 --> 00:38:58.480
or with a context manager,


00:38:58.480 --> 00:39:01.880
you can also use like standard patch call,


00:39:01.880 --> 00:39:03.280
then time start passing,


00:39:03.280 --> 00:39:08.280
starting on that time that you mocked it for.


00:39:08.280 --> 00:39:11.900
So you can do perf counters and all this thing normally,


00:39:11.900 --> 00:39:14.240
but if you need to stay in a given day for a test,


00:39:14.240 --> 00:39:15.920
you can do it.


00:39:15.920 --> 00:39:17.020
So I thought it was pretty cool.


00:39:17.020 --> 00:39:19.960
It solved my two extra minutes running


00:39:19.960 --> 00:39:22.040
because we have many places and many files


00:39:22.040 --> 00:39:24.320
and the project would be UCHC now.


00:39:24.320 --> 00:39:25.960
And it was pretty well.


00:39:25.960 --> 00:39:31.940
- So this must have had incremental,


00:39:31.940 --> 00:39:33.160
I mean, it has a little bit of time


00:39:33.160 --> 00:39:34.140
that has to do its work,


00:39:34.140 --> 00:39:37.460
but it's fast enough that you're not noticing it then?


00:39:37.460 --> 00:39:38.760
- No, I'm not noticing anything.


00:39:38.760 --> 00:39:40.960
I mean, it runs more or less the same.


00:39:40.960 --> 00:39:42.840
- Okay, well, that's pretty good.


00:39:42.840 --> 00:39:44.360
- I imagine there should be some delay,


00:39:44.360 --> 00:39:47.960
but it's not as noticeable as what happened with Freescan.


00:39:47.960 --> 00:39:50.400
- Yeah. - It took some time.


00:39:50.400 --> 00:39:52.120
- Yeah, I'm really glad you brought this up.


00:39:52.120 --> 00:39:52.960
This is cool.


00:39:52.960 --> 00:39:55.320
- It's probably pretty good.


00:39:55.320 --> 00:39:57.200
- Yeah, exactly.


00:39:57.200 --> 00:39:59.580
I say, Brian, you probably,


00:39:59.580 --> 00:40:01.440
this is kind of in your world, right?


00:40:01.440 --> 00:40:03.440
Like dealing with time as a dependency.


00:40:03.440 --> 00:40:05.640
- Definitely.


00:40:05.640 --> 00:40:09.040
And there's, sometimes it's really,


00:40:09.040 --> 00:40:11.600
you want it fixed because you really want fixed answers.


00:40:11.600 --> 00:40:15.000
'Cause like your timestamps and stuff are in your data.


00:40:15.000 --> 00:40:16.240
You're gonna have to, I mean,


00:40:16.240 --> 00:40:19.880
it's good to compare against known oracles,


00:40:19.880 --> 00:40:22.440
But there's also times where you...


00:40:22.440 --> 00:40:27.080
And this is where Freescan isn't so bad,


00:40:27.080 --> 00:40:29.760
but maybe this would be really useful too,


00:40:29.760 --> 00:40:32.200
is if you want to test certain things.


00:40:32.200 --> 00:40:34.120
There's weird quirky dates you want to make sure


00:40:34.120 --> 00:40:38.040
that your software deals with certain times fine.


00:40:38.040 --> 00:40:39.640
Does it work fine when it's running


00:40:39.640 --> 00:40:44.040
over like overnight on December 31st to January 1st,


00:40:44.040 --> 00:40:47.440
things like that, when the year changes and things like that.


00:40:47.440 --> 00:40:48.280
- Exactly.


00:40:48.280 --> 00:40:49.120
- Yeah.


00:40:49.120 --> 00:40:49.960
- Yeah.


00:40:49.960 --> 00:40:50.780
- Yeah.


00:40:50.780 --> 00:40:54.200
- Yeah, you always wanna test your boundary conditions,


00:40:54.200 --> 00:40:57.640
right, and crossing over time or weird cases


00:40:57.640 --> 00:40:59.720
like March 29th and stuff like that.


00:40:59.720 --> 00:41:01.120
You're like, let me just try that


00:41:01.120 --> 00:41:03.200
and see if this is gonna survive.


00:41:03.200 --> 00:41:04.040
- Yeah.


00:41:04.040 --> 00:41:06.840
- Yeah, but then, I mean, to be fair,


00:41:06.840 --> 00:41:07.880
I think most of the time,


00:41:07.880 --> 00:41:09.960
things like this are used are,


00:41:09.960 --> 00:41:14.960
like was brought up is that the time shows up in the data.


00:41:14.960 --> 00:41:16.880
So in order to compare the, you know,


00:41:16.880 --> 00:41:20.200
or the log or something in order to compare those apples


00:41:20.200 --> 00:41:23.520
to apples, it's nice to have the same dates there.


00:41:23.520 --> 00:41:26.500
I can't tell you how many times I've had to compare


00:41:26.500 --> 00:41:29.560
two log files and strip out the times


00:41:29.560 --> 00:41:31.680
because those are the, like those are the,


00:41:31.680 --> 00:41:34.640
every line's different because the timestamp's different.


00:41:34.640 --> 00:41:36.920
So, yeah.


00:41:36.920 --> 00:41:37.820
- Yeah, very cool.


00:41:37.820 --> 00:41:40.100
Nice find.


00:41:40.100 --> 00:41:45.440
- So that's all for Time Machine, yeah.


00:41:45.440 --> 00:41:46.340
- Yeah, super.


00:41:46.340 --> 00:41:51.340
- Well, that's our six items, everybody.


00:41:51.340 --> 00:41:54.820
Have you got anything extra, Michael?


00:41:54.820 --> 00:41:58.600
- Well, I have the old thing that is new again.


00:41:58.600 --> 00:41:59.520
Let's see.


00:41:59.520 --> 00:42:00.680
I have some bandits.


00:42:00.680 --> 00:42:06.620
So the drama around supply chain vulnerabilities


00:42:06.620 --> 00:42:12.460
and open source repositories goes on.


00:42:12.460 --> 00:42:15.900
So this one, I think actually the other article


00:42:15.900 --> 00:42:19.960
to talk about a co-script to us from Joe Ridley.


00:42:19.960 --> 00:42:21.120
Thank you, Joe, for sending that in.


00:42:21.120 --> 00:42:26.120
But basically there's some more malicious things


00:42:26.120 --> 00:42:31.480
in PyPI again, and people just remind everyone


00:42:31.480 --> 00:42:34.880
to be careful and maybe white list stuff.


00:42:34.880 --> 00:42:39.880
Yeah, this one, I don't know what this one was.


00:42:39.880 --> 00:42:44.000
If it was typo squatting this time around


00:42:44.000 --> 00:42:47.180
or it was just something else that got put up there.


00:42:47.180 --> 00:42:49.620
Yeah, there's one headline is,


00:42:49.620 --> 00:42:50.700
"Credit card stealing malware


00:42:50.700 --> 00:42:52.980
found in official Python repository."


00:42:52.980 --> 00:42:55.100
And the other one is,


00:42:55.100 --> 00:42:58.780
same one about our technical article says,


00:42:58.780 --> 00:43:00.900
"Software downloaded 30,000 times from PyPI


00:43:00.900 --> 00:43:03.880
ransacks developer's machines.


00:43:03.880 --> 00:43:08.300
Expect to see more of these Frankenstein type things."


00:43:08.300 --> 00:43:10.600
'Cause it's basically a systemic threat,


00:43:10.600 --> 00:43:13.220
like how does it get dealt with?


00:43:13.220 --> 00:43:14.700
I'm not sure if they list out.


00:43:14.700 --> 00:43:19.700
Yeah, so they did interesting stuff as well.


00:43:19.700 --> 00:43:23.360
Like they did simple obfuscation of the code


00:43:23.360 --> 00:43:24.400
that was being run.


00:43:24.400 --> 00:43:26.260
So you couldn't look at it and say,


00:43:26.260 --> 00:43:28.820
look for a credit card or look for a Bitcoin wallet


00:43:28.820 --> 00:43:31.460
and then go do your evil deeds in Python source code.


00:43:31.460 --> 00:43:35.620
So they would do things like base 64


00:43:35.620 --> 00:43:39.580
and code the Python code and then just in memory,


00:43:39.580 --> 00:43:40.980
decode it, then run it.


00:43:41.900 --> 00:43:43.860
So they were trying to get around things like that.


00:43:43.860 --> 00:43:48.700
So anyway, people can check that out and it's not ideal


00:43:48.700 --> 00:43:51.600
but just a reminder to beware.


00:43:51.600 --> 00:43:56.620
- Yuck.


00:43:56.620 --> 00:43:58.180
- Yuck, yuck, yuck.


00:43:58.180 --> 00:43:59.340
This is why we can't have nice things.


00:43:59.340 --> 00:44:00.180
Come on people.


00:44:00.180 --> 00:44:02.300
- This is why we can't have nice things.


00:44:02.300 --> 00:44:05.700
Well, I got a couple of things I wanted to bring up


00:44:05.700 --> 00:44:07.700
just things I've been up to.


00:44:07.700 --> 00:44:11.780
Just released episode 162 of testing code


00:44:11.780 --> 00:44:16.020
and I kind of run through all the different flavors


00:44:16.020 --> 00:44:18.800
of test-driven development that I know of.


00:44:18.800 --> 00:44:20.460
So there are quite a few versions.


00:44:20.460 --> 00:44:22.340
So check it out if you're interested


00:44:22.340 --> 00:44:24.060
in test-driven development.


00:44:24.060 --> 00:44:27.860
And then I'm just working on wrapping up the talks


00:44:27.860 --> 00:44:29.500
and continuous integration chapter


00:44:29.500 --> 00:44:32.780
for the second edition of the pytest book.


00:44:32.780 --> 00:44:35.780
So it'll be coming out hopefully within a week.


00:44:35.780 --> 00:44:37.780
- Very cool.


00:44:37.780 --> 00:44:39.260
Good to see you making progress there.


00:44:41.380 --> 00:44:43.340
Do you have anything extra, Wampi?


00:44:43.340 --> 00:44:46.340
- Nope, not from my side.


00:44:46.340 --> 00:44:48.540
I'm very happy to be here.


00:44:48.540 --> 00:44:50.180
- Let's go to a joke.


00:44:50.180 --> 00:44:51.220
- Yeah, it's good to have you here.


00:44:51.220 --> 00:44:54.100
All right, let's go to a joke.


00:44:54.100 --> 00:44:55.740
So this one's visual.


00:44:55.740 --> 00:44:59.500
If you're listening, you're gonna have to go to the,


00:44:59.500 --> 00:45:02.360
scroll down to your podcast show notes at the bottom.


00:45:02.360 --> 00:45:04.420
Just click on the joke link.


00:45:04.420 --> 00:45:06.980
One of the things you guys, I like about Python


00:45:06.980 --> 00:45:10.500
is there's a lot of stability in the code that we write.


00:45:10.500 --> 00:45:14.160
You know, if I wrote something on Flask five years ago,


00:45:14.160 --> 00:45:15.500
chances are it'll still run, right?


00:45:15.500 --> 00:45:16.780
If I write my Python code now,


00:45:16.780 --> 00:45:18.860
it's probably still gonna run.


00:45:18.860 --> 00:45:19.740
Yeah, there's new things,


00:45:19.740 --> 00:45:21.900
there's new shiny visualization frameworks and stuff,


00:45:21.900 --> 00:45:23.980
but generally it's pretty stable.


00:45:23.980 --> 00:45:25.880
You know what is the opposite of that?


00:45:25.880 --> 00:45:28.020
JavaScript.


00:45:28.020 --> 00:45:31.860
So here's a little animation,


00:45:31.860 --> 00:45:35.340
and it says JavaScript developer bouncing


00:45:35.340 --> 00:45:36.540
from framework to framework,


00:45:36.540 --> 00:45:38.660
and it's this incredible,


00:45:38.660 --> 00:45:42.800
like almost people are awesome type of thing


00:45:42.800 --> 00:45:47.440
where somebody set up, you know, 50 workout balls


00:45:47.440 --> 00:45:48.720
on a running track,


00:45:48.720 --> 00:45:51.600
the whole straight of a quarter mile running track


00:45:51.600 --> 00:45:55.440
and somebody jumps on it and just like glides


00:45:55.440 --> 00:45:56.480
from one to the next.


00:45:56.480 --> 00:45:57.480
What do y'all think?


00:45:57.480 --> 00:46:01.440
- The fact that he's able to do this is surprising.


00:46:01.440 --> 00:46:03.400
- It's really impressive that he pulls it off.


00:46:03.400 --> 00:46:08.080
And it's on one of these like sandy gritty running tracks.


00:46:08.080 --> 00:46:09.920
It's gonna hurt like crazy if he misses it.


00:46:09.920 --> 00:46:11.880
So maybe there's motivation, you know?


00:46:11.880 --> 00:46:16.880
- Actually, I remember the GenBrain report


00:46:16.880 --> 00:46:18.720
you said before I was thinking,


00:46:18.720 --> 00:46:20.760
I didn't say anything, but I didn't want to mean,


00:46:20.760 --> 00:46:23.680
but you were saying, how likely are you to change languages?


00:46:23.680 --> 00:46:25.040
And it was like, well, JavaScript,


00:46:25.040 --> 00:46:26.320
they're going to change a lot.


00:46:26.320 --> 00:46:29.680
Then I thought, oh, they're languages, not frameworks.


00:46:29.680 --> 00:46:30.520
- Exactly.


00:46:30.520 --> 00:46:32.560
How likely are you to change your framework?


00:46:32.560 --> 00:46:35.240
Well, that's like, nearly a hundred percent.


00:46:37.200 --> 00:46:39.120
- Yeah, that's true.


00:46:39.120 --> 00:46:40.760
I mean, people stick around like,


00:46:40.760 --> 00:46:45.040
you got Django developers have been doing it for years.


00:46:45.040 --> 00:46:46.800
- 10 years and they're more excited today


00:46:46.800 --> 00:46:47.740
than ever about it, right?


00:46:47.740 --> 00:46:50.040
They're not like, we're ditching this.


00:46:50.040 --> 00:46:50.880
- Yeah.


00:46:50.880 --> 00:46:54.800
- All right, well, that's, does that count?


00:46:54.800 --> 00:46:56.120
Does that count as a joke?


00:46:56.120 --> 00:46:56.960
- Yeah.


00:46:56.960 --> 00:46:57.800
- Oh, I laughed.


00:46:57.800 --> 00:47:00.360
- All right, perfect.


00:47:00.360 --> 00:47:02.080
Well, that's what I brought for you all.


00:47:02.080 --> 00:47:04.920
- Well, thanks to everyone for showing up


00:47:04.920 --> 00:47:07.480
and had a fun day today.


00:47:07.480 --> 00:47:09.060
Hope everybody else did.


00:47:09.060 --> 00:47:10.680
- Thanks a lot for having me here.


00:47:10.680 --> 00:47:12.920
- Thanks Brian, and thanks for being with us Pompeii.


00:47:12.920 --> 00:47:14.260
- Bye. - Bye bye.


00:47:14.260 --> 00:47:24.260
[BLANK_AUDIO]

