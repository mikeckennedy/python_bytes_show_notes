WEBVTT

00:00:00.000 --> 00:00:09.880
Hey, we're live. Hey. Welcome, YouTube and everybody watching the live stream. So welcome,


00:00:09.880 --> 00:00:10.880
Michael.


00:00:10.880 --> 00:00:11.880
Hey, Brian.


00:00:11.880 --> 00:00:19.000
Hey. Before we get started, actually, let's just get started. Thanks to everybody for


00:00:19.000 --> 00:00:25.600
showing up and we'll jump in. Hello and welcome to Python Bytes where we deliver Python news


00:00:25.600 --> 00:00:32.600
and headlines directly to your earbuds. This is episode 325 recorded February 28th, the


00:00:32.600 --> 00:00:37.460
last day of February in 2023. I am Brian Okken.


00:00:37.460 --> 00:00:39.360
And I'm Michael Kennedy.


00:00:39.360 --> 00:00:44.040
And before we jump in, I want to thank everybody on the, that shows up for the live stream.


00:00:44.040 --> 00:00:47.740
If you haven't shown up for the live stream before, it's a lot of fun. People can stop


00:00:47.740 --> 00:00:53.520
and ask questions and chat and everything. And it's a good way to say hi. and we


00:00:53.520 --> 00:00:55.800
We enjoy having you here or watch it afterwards


00:00:55.800 --> 00:00:57.500
if this is a bad time for you.


00:00:57.500 --> 00:01:01.820
Also wanna thank Microsoft for Startup Founders Hub


00:01:01.820 --> 00:01:03.360
for sponsoring this episode.


00:01:03.360 --> 00:01:05.480
They've been an excellent sponsor of the show


00:01:05.480 --> 00:01:08.240
and they've also agreed to have us like


00:01:08.240 --> 00:01:10.500
be able to play with the sponsor spots


00:01:10.500 --> 00:01:11.700
and do some AI readings.


00:01:11.700 --> 00:01:13.720
So this one's gonna be a fun one, this one.


00:01:13.720 --> 00:01:15.200
So I'm excited about it.


00:01:15.200 --> 00:01:17.400
- I am too, it's gonna be fun.


00:01:17.400 --> 00:01:20.880
- So why don't you kick us off with our first topic today?


00:01:20.880 --> 00:01:23.520
All right, let's jump right in.


00:01:23.520 --> 00:01:26.500
You like solid code.


00:01:26.500 --> 00:01:28.560
So how about some codesolid.com?


00:01:28.560 --> 00:01:30.680
Has nothing to do with solid code,


00:01:30.680 --> 00:01:32.840
but it's still interesting and it does have to do with code.


00:01:32.840 --> 00:01:37.200
This one is something called Parquet and Arrow.


00:01:37.200 --> 00:01:38.760
Have you heard of Apache Arrow


00:01:38.760 --> 00:01:41.040
or the Parquet file format, Brian?


00:01:41.040 --> 00:01:43.840
- I don't, I've heard of Arrow,


00:01:43.840 --> 00:01:46.560
but I don't think I've heard of Parquet.


00:01:46.560 --> 00:01:49.720
- So when people do a lot of data science,


00:01:49.720 --> 00:01:52.360
you'll see them do things like open up Jupyter Notebooks


00:01:52.360 --> 00:01:54.120
and import pandas.


00:01:54.120 --> 00:01:58.000
And then from pandas, they'll say load CSV.


00:01:58.000 --> 00:02:00.840
Well, if you could think of a whole bunch


00:02:00.840 --> 00:02:03.480
of different file formats and how fast and efficient


00:02:03.480 --> 00:02:06.040
they might be stored on disk in red,


00:02:06.040 --> 00:02:09.000
how do you think CSVs might turn out?


00:02:09.000 --> 00:02:14.040
Pretty slow, pretty large, and so on.


00:02:14.040 --> 00:02:17.440
And Arrow through PyArrow has some really interesting


00:02:17.440 --> 00:02:21.320
in-memory structures that are a little more efficient


00:02:21.320 --> 00:02:25.800
than pandas, as well as it has access to this parquet format.


00:02:25.800 --> 00:02:27.360
So does pandas through an add-on,


00:02:27.360 --> 00:02:31.480
but you'll see that it's still faster using PyArrow.


00:02:31.480 --> 00:02:35.400
So basically, that's what this article


00:02:35.400 --> 00:02:36.400
that I found is about.


00:02:36.400 --> 00:02:39.120
It highlights how these things compare,


00:02:39.120 --> 00:02:42.800
and it basically asks the questions like,


00:02:42.800 --> 00:02:47.280
can we use pandas data frames and arrow tables together?


00:02:47.280 --> 00:02:48.780
Like if I have a pandas data frame,


00:02:48.780 --> 00:02:51.200
but I wanna then switch it into PyArrow


00:02:51.200 --> 00:02:55.020
for better performance at some point for some analysis,


00:02:55.020 --> 00:02:55.860
can I do that?


00:02:55.860 --> 00:02:56.880
Or if I start with PyArrow,


00:02:56.880 --> 00:02:58.960
could I then turn it into a data frame


00:02:58.960 --> 00:03:01.040
and hand it off to Seaborn


00:03:01.040 --> 00:03:04.720
or some other thing that expects a pandas data frame?


00:03:04.720 --> 00:03:05.560
Answer is yes.


00:03:05.560 --> 00:03:07.600
Short version there.


00:03:07.600 --> 00:03:09.540
Are they better?


00:03:09.540 --> 00:03:10.480
In which ways are they better?


00:03:10.480 --> 00:03:11.440
Which way are they worse?


00:03:11.440 --> 00:03:15.600
And then the bulk of the analysis here is like,


00:03:15.600 --> 00:03:18.200
Okay, we could save our data, read and write our data


00:03:18.200 --> 00:03:20.680
from a bunch of different file formats,


00:03:20.680 --> 00:03:23.360
Parquet, but also things like Feather,


00:03:23.360 --> 00:03:25.960
Oryx, CSV and others, even Excel.


00:03:25.960 --> 00:03:29.040
What should we maybe consider using?


00:03:29.040 --> 00:03:34.240
Okay, so installing it is just pip install,


00:03:34.240 --> 00:03:37.240
PyArrow, super easy, same type of story.


00:03:37.240 --> 00:03:41.880
If you want to use it with Pandas,


00:03:41.880 --> 00:03:44.400
so I've got some Pandas data, DataFrame,


00:03:44.400 --> 00:03:48.660
and then I want to then convert it over, that's super easy.


00:03:48.660 --> 00:03:51.380
So you can use,


00:03:51.380 --> 00:03:55.880
go to PyArrow and you say PyArrow.table,


00:03:55.880 --> 00:03:58.400
say from pandas and give it a pandas data frame


00:03:58.400 --> 00:04:02.960
and then boom, you've got it in PyArrow format.


00:04:02.960 --> 00:04:03.840
- Okay.


00:04:03.840 --> 00:04:07.920
- One of the things that's interesting is with pandas


00:04:07.920 --> 00:04:12.920
is a real nice like wrangling exploration style of data.


00:04:12.920 --> 00:04:14.160
Okay.


00:04:14.160 --> 00:04:17.380
So I can go and I can just show the data frame


00:04:17.380 --> 00:04:20.120
and it'll tell me like there are 14 columns


00:04:20.120 --> 00:04:22.920
and this example, 6,433 rows


00:04:22.920 --> 00:04:26.480
and it'll list off the headers and then the column data.


00:04:26.480 --> 00:04:29.000
If I do the same thing in PyArrow, I just get,


00:04:29.000 --> 00:04:32.600
it's kind of human readable.


00:04:32.600 --> 00:04:36.600
You just get like a dump of junk basically.


00:04:36.600 --> 00:04:38.140
It's not real great.


00:04:38.140 --> 00:04:40.640
So that aspect, certainly using pandas


00:04:40.640 --> 00:04:42.680
is nice for this kind of exploration.


00:04:42.680 --> 00:04:45.480
Another thing about PyArrow is the data is immutable.


00:04:45.480 --> 00:04:48.760
So you can't say, oh, every time that this thing appears,


00:04:48.760 --> 00:04:51.760
actually replace it with this canonical version.


00:04:51.760 --> 00:04:55.380
You know, if you get like a Y, lowercase yes,


00:04:55.380 --> 00:04:58.240
and capital yes, you wanna make them all just lowercase yes,


00:04:58.240 --> 00:05:01.760
or just the Y, like you gotta make a copy


00:05:01.760 --> 00:05:03.240
instead of change it in place.


00:05:03.240 --> 00:05:06.960
So that's one of the reasons you might stick with pandas,


00:05:06.960 --> 00:05:08.360
which is pretty interesting.


00:05:09.720 --> 00:05:12.680
But you can do a lot of really interesting parsing


00:05:12.680 --> 00:05:16.760
and performance stuff that you would do with,


00:05:16.760 --> 00:05:19.660
like you would do with pandas.


00:05:19.660 --> 00:05:23.120
But if your goal is performance


00:05:23.120 --> 00:05:24.880
and performance measured in different ways,


00:05:24.880 --> 00:05:29.040
how much memory does it take up in computer RAM?


00:05:29.040 --> 00:05:32.760
How much disk space type of memory does it take up?


00:05:32.760 --> 00:05:35.000
How fast is it to read and write from those?


00:05:35.000 --> 00:05:38.280
It's pretty much always better to go with PyArrow.


00:05:39.600 --> 00:05:42.220
So for example, if I take those same sets of data,


00:05:42.220 --> 00:05:44.320
those two sets of data from--


00:05:44.320 --> 00:05:46.520
I think this is the New York City taxi data,


00:05:46.520 --> 00:05:49.620
some subset of that, really common data set.


00:05:49.620 --> 00:05:54.680
It's-- quick, digit grouping.


00:05:54.680 --> 00:05:57.840
It's a little over 3 megs of memory for the data frame,


00:05:57.840 --> 00:06:00.120
and it's just under 100--


00:06:00.120 --> 00:06:02.480
sorry, 3 megs.


00:06:02.480 --> 00:06:03.760
Yeah, I don't know if I said 300.


00:06:03.760 --> 00:06:06.280
3 megs of data for pandas, whereas it's


00:06:06.280 --> 00:06:09.320
just under 1 meg for PyArrow.


00:06:09.320 --> 00:06:13.880
So that's three times smaller, which is pretty interesting


00:06:13.880 --> 00:06:16.200
there.


00:06:16.200 --> 00:06:19.280
The other one is if you do mathy things on it,


00:06:19.280 --> 00:06:21.440
like if you've got tables of numbers,


00:06:21.440 --> 00:06:26.400
you're really likely to talk about things


00:06:26.400 --> 00:06:31.200
like the max or the mean or the average and so on.


00:06:31.200 --> 00:06:37.560
Now, if you do that to pandas and you do it to pyro,


00:06:37.560 --> 00:06:40.560
You'll see it's about eight times faster to do math


00:06:40.560 --> 00:06:43.400
with PyArrow than it is to do it with Pandas.


00:06:43.400 --> 00:06:44.960
That's pretty cool, right?


00:06:44.960 --> 00:06:49.160
- Yeah, the syntax is a little grosser, but yeah.


00:06:49.160 --> 00:06:50.600
- The syntax is a little grosser.


00:06:50.600 --> 00:06:53.200
I will show you a way to get to this in a moment


00:06:53.200 --> 00:06:55.560
that is less gross, I believe.


00:06:55.560 --> 00:06:56.660
- Okay. - Okay.


00:06:56.660 --> 00:07:04.240
And then Alvaro out there does say,


00:07:04.240 --> 00:07:06.120
If you want fast data frames,


00:07:06.120 --> 00:07:08.520
Polars plus Parquet is the way to go.


00:07:08.520 --> 00:07:14.680
He's reading, skating to where the puck is gonna be, indeed.


00:07:14.680 --> 00:07:17.720
And Kim says, "Presumably the immutability


00:07:17.720 --> 00:07:19.760
"plays a large part in the performance."


00:07:19.760 --> 00:07:21.640
I suppose so.


00:07:21.640 --> 00:07:23.160
- Yeah.


00:07:23.160 --> 00:07:26.760
- And then also some feedback of real-time analytics here.


00:07:26.760 --> 00:07:28.800
Alvaro says, "I got a broken script from a colleague.


00:07:28.800 --> 00:07:30.700
"I rewrote it in Pandas,


00:07:30.700 --> 00:07:33.520
"and it took about two hours of process


00:07:33.520 --> 00:07:36.600
In Polars, it took three minutes.


00:07:36.600 --> 00:07:41.680
So that's a non-trivial sort of bonus there.


00:07:41.680 --> 00:07:44.520
All right, let me go over the file formats.


00:07:44.520 --> 00:07:45.960
And I'll just really quickly--


00:07:45.960 --> 00:07:47.380
I think we've talked about Polars.


00:07:47.380 --> 00:07:49.280
I'll just reintroduce it really quick.


00:07:49.280 --> 00:07:52.200
So if we go and look at the different file formats,


00:07:52.200 --> 00:07:56.240
we could use Parquet.


00:07:56.240 --> 00:07:59.320
So we could say 2 Parquet with PyArrow.


00:07:59.320 --> 00:08:00.200
And you get it out.


00:08:00.200 --> 00:08:03.760
And these numbers are all kind of like insane.


00:08:03.760 --> 00:08:07.560
Four milliseconds versus reading it with two milliseconds.


00:08:07.560 --> 00:08:09.160
If you use the fast parquet,


00:08:09.160 --> 00:08:12.080
which is the thing that allows data frames to do it,


00:08:12.080 --> 00:08:14.360
it's 14 milliseconds,


00:08:14.360 --> 00:08:17.600
which is a little over three times slower,


00:08:17.600 --> 00:08:19.840
but it's still really, really fast, right?


00:08:19.840 --> 00:08:22.180
There's feather, which is the fastest


00:08:22.180 --> 00:08:25.920
of all the file formats with a two millisecond save time,


00:08:25.920 --> 00:08:26.920
which is blazing.


00:08:26.920 --> 00:08:28.020
There's Orc.


00:08:28.020 --> 00:08:29.360
I have no idea what Orc is.


00:08:29.360 --> 00:08:31.280
It's a little bit faster.


00:08:31.280 --> 00:08:36.160
Or if you want to show that you're taking lots of time


00:08:36.160 --> 00:08:37.520
and doing lots of processing,


00:08:37.520 --> 00:08:39.440
doing lots of data science-y things,


00:08:39.440 --> 00:08:40.640
you could always do Excel,


00:08:40.640 --> 00:08:42.480
which takes about a second almost.


00:08:42.480 --> 00:08:44.840
I mean, on a larger dataset,


00:08:44.840 --> 00:08:46.600
it might take a lot longer, right?


00:08:46.600 --> 00:08:48.120
You're like, oh, I'm busy, I can't work.


00:08:48.120 --> 00:08:50.680
I'm getting a coffee 'cause I'm saving.


00:08:50.680 --> 00:08:52.280
- Well, I mean, there's some people


00:08:52.280 --> 00:08:54.360
that really have to export it to Excel


00:08:54.360 --> 00:08:56.900
so that other people can make mistakes later.


00:08:56.900 --> 00:09:01.240
- Yes, exactly, 'cause life is better when it's all go-tos.


00:09:01.240 --> 00:09:02.080
Yeah.


00:09:02.080 --> 00:09:04.480
But no, you're right.


00:09:04.480 --> 00:09:07.420
If the goal is to deliver an Excel file, then obviously.


00:09:07.420 --> 00:09:08.640
But this is more like considering


00:09:08.640 --> 00:09:11.260
what's a good intermediate just storage format.


00:09:11.260 --> 00:09:14.320
And then CSV is actually not that slow.


00:09:14.320 --> 00:09:17.400
It's still slower, but it's only 30 milliseconds.


00:09:17.400 --> 00:09:19.200
But the other part that's worth thinking about,


00:09:19.200 --> 00:09:22.480
remember, this is only 6,400 rows.


00:09:22.480 --> 00:09:25.240
The parquet format is 191K.


00:09:26.400 --> 00:09:30.080
The Pandas one is almost 100K more, which is interesting.


00:09:30.080 --> 00:09:32.540
The Feather is almost half a meg.


00:09:32.540 --> 00:09:34.300
Orac is three quarters of a meg.


00:09:34.300 --> 00:09:35.480
Excel is half a meg.


00:09:35.480 --> 00:09:36.760
CSV is a meg, right?


00:09:36.760 --> 00:09:41.040
So a meg, that's almost five times file size increase.


00:09:41.040 --> 00:09:42.360
So if you're storing tons of data


00:09:42.360 --> 00:09:46.220
and it's five gigs versus 50 gigs,


00:09:46.220 --> 00:09:48.900
you know, you maybe wanna think about


00:09:48.900 --> 00:09:50.020
storing it in a different format.


00:09:50.020 --> 00:09:53.000
Plus you read and write it faster, right?


00:09:54.600 --> 00:09:56.800
So these are all pretty interesting.


00:09:56.800 --> 00:10:01.800
And Polars, Polar.rs is the lightning fast data frame


00:10:01.800 --> 00:10:05.120
built in Rust and Python.


00:10:05.120 --> 00:10:07.200
This is built on top of PyArrow.


00:10:07.200 --> 00:10:08.040
I had a whole,


00:10:08.040 --> 00:10:12.800
built on top of Apache Arrow.


00:10:12.800 --> 00:10:14.960
I had a whole talk Python episode on it.


00:10:14.960 --> 00:10:17.040
I'm pretty sure I'd talked about Polars before


00:10:17.040 --> 00:10:18.200
on here as well,


00:10:18.200 --> 00:10:21.520
but it's got like a really cool sort of fluent


00:10:21.520 --> 00:10:23.560
programming style and under the covers,


00:10:23.560 --> 00:10:25.040
it's using PyArrow as well.


00:10:25.040 --> 00:10:26.760
So pretty neat.


00:10:26.760 --> 00:10:28.720
Yeah, so if you're really looking to say like,


00:10:28.720 --> 00:10:30.960
I just wanna go all in on this,


00:10:30.960 --> 00:10:34.400
as Avaro pointed out, I think it was Avaro,


00:10:34.400 --> 00:10:37.720
that Polars is, yeah, that Polars is pretty cool.


00:10:37.720 --> 00:10:39.140
- Okay, neat.


00:10:39.140 --> 00:10:43.360
- And Henry out there, real time feedback is,


00:10:43.360 --> 00:10:45.940
Pandas is fully supporting PyArrow for all data types


00:10:45.940 --> 00:10:49.560
in the upcoming 1.5 and 2.0 releases.


00:10:49.560 --> 00:10:51.960
There was just a blog post on it


00:10:51.960 --> 00:10:53.600
on the Data Pythonista blog.


00:10:53.600 --> 00:10:56.320
It's not clear if they're switching to it.


00:10:56.320 --> 00:11:00.600
I believe it's NumPy at the moment as the core,


00:11:00.600 --> 00:11:05.200
but it's, could be supporting it, which is awesome.


00:11:05.200 --> 00:11:08.040
Yeah, thanks Henry for that live update there.


00:11:08.040 --> 00:11:10.400
- Yeah, well then I'll also,


00:11:10.400 --> 00:11:12.320
I said, but it did say basically starting


00:11:12.320 --> 00:11:14.720
to get native PyOS speed with pandas


00:11:14.720 --> 00:11:17.720
by just selecting the backend in the new pandas version.


00:11:17.720 --> 00:11:18.600
So.


00:11:18.600 --> 00:11:19.560
- Indeed.


00:11:19.560 --> 00:11:21.680
Awesome, yeah, yeah, very, very cool.


00:11:21.680 --> 00:11:24.520
So lots of options here, but I think a takeaway


00:11:24.520 --> 00:11:27.760
that it's kind of worth paying attention to here


00:11:27.760 --> 00:11:30.720
is choosing maybe Parquet as a file format,


00:11:30.720 --> 00:11:33.720
regardless of whether you're using Pandas


00:11:33.720 --> 00:11:35.440
or PyArrow or whatever, right?


00:11:35.440 --> 00:11:37.560
'Cause I think the default is read and write CSV.


00:11:37.560 --> 00:11:41.160
And if your CSV files are ginormous,


00:11:41.160 --> 00:11:43.960
that might be something you wanna not do.


00:11:43.960 --> 00:11:45.400
Yeah. - Okay.


00:11:45.400 --> 00:11:47.040
- All right, over to you.


00:11:47.040 --> 00:11:50.120
- Well, you said have ever heard of Parquet,


00:11:50.120 --> 00:11:52.520
And before we get to the next topic,


00:11:52.520 --> 00:11:56.760
I was thinking like, is it butter or is it parquet?


00:11:56.760 --> 00:11:59.360
It's a thing from when we were kids, but.


00:11:59.360 --> 00:12:01.280
- That's right, margarine.


00:12:01.280 --> 00:12:03.000
Yum.


00:12:03.000 --> 00:12:03.880
- Mm, parquet.


00:12:03.880 --> 00:12:06.520
Had a little tub that talked, it was neat.


00:12:06.520 --> 00:12:08.880
- Oh, that's right, it did, it had a little mouth, yeah.


00:12:08.880 --> 00:12:10.360
- Yeah.


00:12:10.360 --> 00:12:12.200
I wanna talk about FastAPI a bit.


00:12:12.200 --> 00:12:15.080
So this topic, FastAPI filter,


00:12:15.080 --> 00:12:17.080
comes from us from Arthur Rio.


00:12:17.080 --> 00:12:19.220
And Arthur, actually, it's his library.


00:12:19.220 --> 00:12:22.580
I'm going to pop over to the documentation quickly.


00:12:22.580 --> 00:12:27.020
But what it is, it's a query string filters for API endpoints


00:12:27.020 --> 00:12:31.540
to and so you can show them in Swagger and use them in stuff for cool things.


00:12:31.540 --> 00:12:36.540
So I'll pop over to the documentation.


00:12:36.540 --> 00:12:43.540
So it says query string filters that supports backends, SQLAlchemy and more.


00:12:43.540 --> 00:12:45.540
And it's a really cool thing.


00:12:45.540 --> 00:12:49.540
string filters that supports backends SQLAlchemy and Mongo


00:12:49.540 --> 00:12:53.580
engine. So that's nice. But let's say, well, we'll get to


00:12:53.580 --> 00:12:56.060
the what the filters look like later. But in the swagger


00:12:56.060 --> 00:12:58.740
interface, this is pretty neat. So let's say you're grabbing the


00:12:58.740 --> 00:13:03.340
users. And you want to filter them by like the name, you can


00:13:03.340 --> 00:13:08.860
do to query in the name or the age less than or age greater


00:13:08.860 --> 00:13:13.940
than or equal. These pretty nice. There's a so it says the


00:13:14.260 --> 00:13:18.360
the philosophy of FastAPI filters to be very declarative.


00:13:18.360 --> 00:13:20.840
You define fields that you want to be able to filter on


00:13:20.840 --> 00:13:22.880
as well as the type of operator


00:13:22.880 --> 00:13:26.400
and then tie your filters to a specific model.


00:13:26.400 --> 00:13:27.720
It's pretty easy to set up.


00:13:27.720 --> 00:13:31.040
The syntax is pretty, well, we'll let you look at it,


00:13:31.040 --> 00:13:34.680
but it's not that bad to set up the filters.


00:13:34.680 --> 00:13:37.120
- Yeah, a lot of Pydantic models,


00:13:37.120 --> 00:13:39.200
as you might expect it being FastAPI.


00:13:39.200 --> 00:13:40.720
- Yeah.


00:13:40.720 --> 00:13:42.000
So you plug in these filters,


00:13:42.000 --> 00:13:44.680
But then you get things like the built-in ones


00:13:44.680 --> 00:13:47.100
are like not equal, greater than,


00:13:47.100 --> 00:13:51.120
greater than or equal in, those sorts of things.


00:13:51.120 --> 00:13:54.480
But you can do some pretty complex query strings then,


00:13:54.480 --> 00:13:57.600
like, oh, there's some good examples down here.


00:13:57.600 --> 00:14:01.240
So like the users, but order by descending name


00:14:01.240 --> 00:14:05.160
or order by ascending ID,


00:14:05.160 --> 00:14:06.840
there's like plus and minus for ascending


00:14:06.840 --> 00:14:08.120
and you can have order by,


00:14:08.120 --> 00:14:13.120
and you can filter by like the name, custom orders,


00:14:13.120 --> 00:14:18.040
and actually putting some filters right in your API string


00:14:18.040 --> 00:14:19.320
is kind of an interesting idea.


00:14:19.320 --> 00:14:20.960
I don't know if it's a good idea or a bad idea,


00:14:20.960 --> 00:14:22.000
but it's interesting.


00:14:22.000 --> 00:14:27.840
- Yeah, this is a real interesting philosophy


00:14:27.840 --> 00:14:32.840
of how do I access the data in my database as an API?


00:14:34.000 --> 00:14:39.000
And I would say there's sort of two really common ways


00:14:39.000 --> 00:14:43.480
and then there's a lot of abuse of what APIs look like


00:14:43.480 --> 00:14:44.480
and what you should do, you know,


00:14:44.480 --> 00:14:47.560
just remote procedure calls and all sorts of randomness.


00:14:47.560 --> 00:14:51.760
But the philosophy is I've got data in a database


00:14:51.760 --> 00:14:53.840
and I wanna expose it over an API.


00:14:53.840 --> 00:14:57.480
Do I go and write a bunch of different functions


00:14:57.480 --> 00:15:01.440
in FastAPI in this example, where I decide,


00:15:01.440 --> 00:15:05.600
here's a way where you can find the recent users


00:15:05.600 --> 00:15:09.760
and you can then possibly take some kind of parameter


00:15:09.760 --> 00:15:13.080
about a sort or maybe how recent of the users


00:15:13.080 --> 00:15:15.360
do you wanna be, but you're writing the code


00:15:15.360 --> 00:15:17.560
that decides here's the database query


00:15:17.560 --> 00:15:20.980
and it's generally focused on recent users, right?


00:15:20.980 --> 00:15:23.080
That's one way to do APIs.


00:15:23.080 --> 00:15:25.620
The other is I kinda wanna take my database


00:15:25.620 --> 00:15:30.620
and just make it queryable over the internet, right?


00:15:30.800 --> 00:15:33.240
And this is, with the right restrictions,


00:15:33.240 --> 00:15:35.360
it's not necessarily a security vulnerability,


00:15:35.360 --> 00:15:37.520
but it's just pushing all of the thinking


00:15:37.520 --> 00:15:40.160
about what the API is to the client side, right?


00:15:40.160 --> 00:15:42.080
So if I'm doing Vue.js, it's like,


00:15:42.080 --> 00:15:44.520
well, we'll wrap this onto our database,


00:15:44.520 --> 00:15:46.780
and you ask it any question you can imagine,


00:15:46.780 --> 00:15:49.980
as if you had a direct query line to the database, right?


00:15:49.980 --> 00:15:53.440
So that's why you would do maybe the age greater than,


00:15:53.440 --> 00:15:55.940
or you could do some of those filters where you say,


00:15:55.940 --> 00:15:58.080
give me all the users where the created date


00:15:58.080 --> 00:16:01.200
is less than such and such or greater than such.


00:16:01.200 --> 00:16:03.140
That would basically be like the new users, right?


00:16:03.140 --> 00:16:06.680
But it's up to the client to kind of know the data schema


00:16:06.680 --> 00:16:08.080
and talk to it.


00:16:08.080 --> 00:16:10.040
And this is that latter style.


00:16:10.040 --> 00:16:12.160
If you like that, awesome.


00:16:12.160 --> 00:16:15.360
You can expose a relational database over SQLAlchemy


00:16:15.360 --> 00:16:18.880
or MongoDB through Mongo engine, and it looks pretty cool.


00:16:18.880 --> 00:16:21.540
- My thoughts on where I mean,


00:16:21.540 --> 00:16:22.920
I'm not using this in production,


00:16:22.920 --> 00:16:25.280
but my thoughts on where I might use this,


00:16:25.280 --> 00:16:29.500
even disregarding like one of the Brandon's concerns,


00:16:29.500 --> 00:16:31.340
Brandon Brainer says,


00:16:31.340 --> 00:16:34.220
exposing my API field names makes me nervous.


00:16:34.220 --> 00:16:37.860
But there's a part of your, oops,


00:16:37.860 --> 00:16:39.880
part of your development


00:16:39.880 --> 00:16:43.580
where you're not quite sure what queries you want.


00:16:43.580 --> 00:16:45.540
So custom writing them,


00:16:45.540 --> 00:16:46.900
maybe you're not ready to do that


00:16:46.900 --> 00:16:49.380
or it'll be a lot of back and forth.


00:16:49.380 --> 00:16:52.860
So a great, I think a great place to be for this would be


00:16:52.860 --> 00:16:55.660
when you're working with, you've got your front end


00:16:55.660 --> 00:16:57.940
and your backend code, your API code,


00:16:57.940 --> 00:17:00.140
and you're trying to figure out


00:17:00.140 --> 00:17:02.140
what sort of searches you want,


00:17:02.140 --> 00:17:03.900
and you can use something like this


00:17:03.900 --> 00:17:08.560
to have it right be in the actual API query.


00:17:08.560 --> 00:17:12.380
And then once you figure out all the stuff you need,


00:17:12.380 --> 00:17:13.740
then you could go back if you want to


00:17:13.740 --> 00:17:15.980
and hard code different API endpoints


00:17:15.980 --> 00:17:19.500
with similar stuff, maybe, I don't know.


00:17:19.500 --> 00:17:21.980
- Yeah, yeah, and not everything's built the same, right?


00:17:21.980 --> 00:17:25.260
Kim out there points out that many of the APIs


00:17:25.260 --> 00:17:28.660
that he uses or builds are for in-house use only.


00:17:28.660 --> 00:17:29.580
- Yeah. - Right?


00:17:29.580 --> 00:17:31.060
And so it's just like,


00:17:31.060 --> 00:17:34.100
instead of coming up very, very focused API endpoints,


00:17:34.100 --> 00:17:35.680
it's like, well, kind of just leave it open


00:17:35.680 --> 00:17:38.380
and people can use this service to access the data


00:17:38.380 --> 00:17:41.380
in a somewhat safe way, like a restricted way.


00:17:41.380 --> 00:17:44.040
So it's, what are you building?


00:17:44.040 --> 00:17:45.920
Like, are you putting it just on the open internet


00:17:45.920 --> 00:17:49.940
or are you putting it, you know, inside?


00:17:49.940 --> 00:17:50.900
- That's very true.


00:17:50.900 --> 00:17:55.220
Yeah, like I've got a bunch of projects I'm working on that are internal and like,


00:17:55.220 --> 00:17:59.420
I, I, who cares if somebody knows what my data names are and stuff.


00:17:59.420 --> 00:17:59.540
So,


00:17:59.540 --> 00:17:59.740
right.


00:17:59.740 --> 00:18:00.740
Well, and what is in it?


00:18:00.740 --> 00:18:05.660
Are you storing social security numbers and addresses or are you still storing


00:18:05.660 --> 00:18:08.700
a voltage levels for RF devices?


00:18:08.700 --> 00:18:08.980
Right.


00:18:08.980 --> 00:18:09.580
Exactly.


00:18:09.580 --> 00:18:11.180
No, the voltage levels have leaked.


00:18:11.180 --> 00:18:11.860
Oh no.


00:18:11.860 --> 00:18:12.580
Right.


00:18:12.580 --> 00:18:14.380
I mean, it might be awesome.


00:18:14.380 --> 00:18:20.340
yeah, I mean the end, like the secretive, we don't want it to get


00:18:20.340 --> 00:18:23.460
out in the public, but it's not something


00:18:23.460 --> 00:18:26.300
that internal users are gonna do anything with.


00:18:26.300 --> 00:18:28.540
So, yeah. - Yeah, yeah, exactly.


00:18:28.540 --> 00:18:29.620
- Cool. - Cool, well, yeah,


00:18:29.620 --> 00:18:32.220
that's really a nice one.


00:18:32.220 --> 00:18:35.220
So, Brian, sponsor this week?


00:18:35.220 --> 00:18:38.860
- Yeah, Microsoft for Startups Founders Hub.


00:18:38.860 --> 00:18:42.460
But if you remember last week, we did an ad


00:18:42.460 --> 00:18:47.460
where we asked an AI to come up with the ad text for us.


00:18:48.780 --> 00:18:51.300
in like an official sort of official sounding way.


00:18:51.300 --> 00:18:52.220
- Yeah, yep.


00:18:52.220 --> 00:18:55.960
So this week you pushed it through the filter


00:18:55.960 --> 00:18:59.860
and said to try to come up with the wording


00:18:59.860 --> 00:19:01.500
in a hipster voice, right?


00:19:01.500 --> 00:19:05.500
So here we go with a hipster style.


00:19:05.500 --> 00:19:07.260
I'll try.


00:19:07.260 --> 00:19:10.380
Yo Python Bytes fam, this segment is brought to you


00:19:10.380 --> 00:19:13.060
by the sickest program out there for startup founders,


00:19:13.060 --> 00:19:15.440
Microsoft for Startup Founders Hub.


00:19:15.440 --> 00:19:17.740
If you're a boss at running a startup,


00:19:17.740 --> 00:19:19.060
you're gonna wanna listen up


00:19:19.060 --> 00:19:22.100
because this is the deal of a lifetime.


00:19:22.100 --> 00:19:24.820
Microsoft for Startup Founders Hub is your ticket


00:19:24.820 --> 00:19:28.460
to scaling efficiently and preserving your runway


00:19:28.460 --> 00:19:31.780
all while keeping your cool factor intact.


00:19:31.780 --> 00:19:33.700
With over six figures worth of benefits,


00:19:33.700 --> 00:19:36.300
the program is serious next level.


00:19:36.300 --> 00:19:39.220
You'll get 150K in Azure credits,


00:19:39.220 --> 00:19:41.980
the richest cloud credit offering on the market,


00:19:41.980 --> 00:19:45.860
access to the OpenAI APIs


00:19:45.860 --> 00:19:48.280
and the new Azure OpenAI service,


00:19:48.280 --> 00:19:51.760
where you can infuse some serious generative AI


00:19:51.760 --> 00:19:53.260
into your apps.


00:19:53.260 --> 00:19:57.020
And a one-on-one technical advisor from the Microsoft squad


00:19:57.020 --> 00:19:59.060
who will help you with your technical stack


00:19:59.060 --> 00:20:00.620
and architectural plans.


00:20:00.620 --> 00:20:02.980
This program is open to all,


00:20:02.980 --> 00:20:05.080
whether you're just getting started or really,


00:20:05.080 --> 00:20:06.540
or already killing it.


00:20:06.540 --> 00:20:09.520
And the best part, there's no funding requirement.


00:20:09.520 --> 00:20:11.360
All it takes is five minutes to apply


00:20:11.360 --> 00:20:13.720
and you'll be reaping the benefits in no time.


00:20:13.720 --> 00:20:16.560
check it out and sign up for Microsoft for Startup


00:20:16.560 --> 00:20:21.560
Founders Hub at pythonbytes.fm/foundershub2022.


00:20:21.560 --> 00:20:23.080
Peace out and keep listening.


00:20:23.080 --> 00:20:27.120
- It's insane the power of these AIs these days.


00:20:27.120 --> 00:20:29.720
And you know, if you wanna get access to OpenAI


00:20:29.720 --> 00:20:32.080
and Azure and GitHub and all those things,


00:20:32.080 --> 00:20:33.280
well, sign up.


00:20:33.280 --> 00:20:34.840
A lot of people seem to be liking that program,


00:20:34.840 --> 00:20:36.540
so it's cool they're supporting us.


00:20:36.540 --> 00:20:39.880
- Yeah, also cool that they're letting us play with the ad.


00:20:39.880 --> 00:20:41.480
- Yes, with their own tools indeed.


00:20:41.480 --> 00:20:44.780
Okay, what I got next, Brian,


00:20:44.780 --> 00:20:48.540
is stuff to take your code to the next level, bro.


00:20:48.540 --> 00:20:52.000
12, but this sounds pretty interesting,


00:20:52.000 --> 00:20:55.720
12 Python decorators to take your code to the next level.


00:20:55.720 --> 00:20:57.120
- Nice. - Decorators are awesome.


00:20:57.120 --> 00:21:01.280
And they're kind of like a little bit of magic Python dust


00:21:01.280 --> 00:21:05.000
you can sprinkle onto a method and make things happen, right?


00:21:05.000 --> 00:21:08.500
Now, about half of these are homegrown.


00:21:08.500 --> 00:21:10.000
Half of those I'd recommend.


00:21:10.000 --> 00:21:11.800
And then a bunch of them are also,


00:21:11.800 --> 00:21:13.360
the other half is maybe the built-in ones


00:21:13.360 --> 00:21:14.800
that come from various places.


00:21:14.800 --> 00:21:16.520
So I'll just go through the list of 12


00:21:16.520 --> 00:21:18.320
and you tell me what you think.


00:21:18.320 --> 00:21:21.160
The first one that they started off with in this article


00:21:21.160 --> 00:21:22.000
doesn't thrill me.


00:21:22.000 --> 00:21:23.480
It says, "Hey, I can wrap this function


00:21:23.480 --> 00:21:24.440
"with this thing called logger


00:21:24.440 --> 00:21:26.040
"and it'll tell me when it starts and stops."


00:21:26.040 --> 00:21:29.240
Like, yeah, no thanks, that doesn't seem interesting.


00:21:29.240 --> 00:21:33.640
But the next one, especially if you're already focused


00:21:33.640 --> 00:21:35.200
on decorators and psyched about that,


00:21:35.200 --> 00:21:39.200
is the FuncTools wraps, right?


00:21:39.200 --> 00:21:41.420
- Because if you're gonna--


00:21:41.420 --> 00:21:43.020
- Definitely, you gotta use it.


00:21:43.020 --> 00:21:45.220
- Yeah, it's basically required.


00:21:45.220 --> 00:21:46.580
If you create a decorator,


00:21:46.580 --> 00:21:49.140
and they show you how to do that on the screen here,


00:21:49.140 --> 00:21:52.660
and you try to interact with the function that is decorated,


00:21:52.660 --> 00:21:54.460
well, you're gonna get funky results.


00:21:54.460 --> 00:21:55.580
Like, what is the function's name?


00:21:55.580 --> 00:21:57.940
Well, it's the name of the decorator, not the actual thing.


00:21:57.940 --> 00:21:58.820
What if it's arguments?


00:21:58.820 --> 00:22:00.980
It's star, star, star, KWRs.


00:22:00.980 --> 00:22:02.620
What is documentation?


00:22:02.620 --> 00:22:05.380
Whatever the name, the documentation of the decorators,


00:22:05.380 --> 00:22:06.200
and all that.


00:22:06.200 --> 00:22:08.660
So with wraps, you can wrap it around,


00:22:08.660 --> 00:22:11.540
and it'll actually kind of pass through that information,


00:22:11.540 --> 00:22:13.180
which is pretty cool.


00:22:13.180 --> 00:22:15.660
So if you're gonna do decorators wrapped,


00:22:15.660 --> 00:22:17.580
that's kind of a meta decorator here.


00:22:17.580 --> 00:22:20.460
Another one I think is really cool,


00:22:20.460 --> 00:22:24.300
and not for all use cases, not really great on the web


00:22:24.300 --> 00:22:26.740
because of the scale out across process story


00:22:26.740 --> 00:22:28.180
that often happens in deployment.


00:22:28.180 --> 00:22:30.120
But if you're doing data sciencey things


00:22:30.120 --> 00:22:32.620
or a bunch of repetitive processing,


00:22:32.620 --> 00:22:34.860
the LRU cache is like magic


00:22:34.860 --> 00:22:37.700
unless you are really memory constrained or something.


00:22:37.700 --> 00:22:39.940
- Yeah, love LRU cache.


00:22:39.940 --> 00:22:41.860
- Yeah, you just put it on a function


00:22:41.860 --> 00:22:45.540
and you say @LRU cache and you can even give it a max size.


00:22:45.540 --> 00:22:50.300
And it just says, as long as given a fixed input,


00:22:50.300 --> 00:22:53.060
you'll get the same output every time.


00:22:53.060 --> 00:22:55.580
Then you can put the LRU cache on it.


00:22:55.580 --> 00:22:57.220
The second time you call it the same arguments,


00:22:57.220 --> 00:22:58.060
it just goes, you know what?


00:22:58.060 --> 00:23:00.140
I know the answer, here you go.


00:23:00.140 --> 00:23:03.420
And it's an incredibly easy way to speed up stuff


00:23:03.420 --> 00:23:05.660
that takes like numbers and like well-known things


00:23:05.660 --> 00:23:08.300
that are not objects, but it can be tested.


00:23:08.300 --> 00:23:09.960
Like, yeah, these are the same values.


00:23:09.960 --> 00:23:11.720
- And if you don't care about the max size,


00:23:11.720 --> 00:23:13.440
you can just use the decorator cache.


00:23:13.440 --> 00:23:15.920
Now you don't need to have the LRU part.


00:23:15.920 --> 00:23:17.040
- No, nice.


00:23:17.040 --> 00:23:17.900
Great addition.


00:23:17.900 --> 00:23:21.520
Next up we have @repeat.


00:23:21.520 --> 00:23:24.800
Suppose for some reason I want to call a function


00:23:24.800 --> 00:23:26.360
multiple times.


00:23:26.360 --> 00:23:29.040
Like if I want to try to say,


00:23:29.040 --> 00:23:31.540
what if I call this a bunch of times just for say,


00:23:32.680 --> 00:23:35.480
load testing or I want to just, you know,


00:23:35.480 --> 00:23:36.520
kind of enduring development.


00:23:36.520 --> 00:23:39.400
I can't see this being used in any realistic way,


00:23:39.400 --> 00:23:41.240
but you can just say, this is one that they built.


00:23:41.240 --> 00:23:44.400
You just wrap it and say, repeat this n number of times.


00:23:44.400 --> 00:23:45.440
That might be useful.


00:23:45.440 --> 00:23:48.200
- Yeah.


00:23:48.200 --> 00:23:49.160
- Time it.


00:23:49.160 --> 00:23:52.840
So time it is one that you could create


00:23:52.840 --> 00:23:53.840
that I think is pretty nice.


00:23:53.840 --> 00:23:55.200
Like this is one of the homegrown ones


00:23:55.200 --> 00:23:58.540
that I do think is good is a lot of times


00:23:58.540 --> 00:24:00.160
you want to know how long a function takes.


00:24:00.160 --> 00:24:02.240
And one thing you could do is you could grab the time


00:24:02.240 --> 00:24:04.760
at the start, here they're using perf counters,


00:24:04.760 --> 00:24:06.000
which is pretty excellent.


00:24:06.000 --> 00:24:09.100
And then at the end, grab the time, print it out.


00:24:09.100 --> 00:24:10.840
But then you're messing with your code, right?


00:24:10.840 --> 00:24:12.480
It'd be a lot easier to just go,


00:24:12.480 --> 00:24:14.660
you know what, I just want to wrap a decorator


00:24:14.660 --> 00:24:17.380
over some function and have it print out stuff.


00:24:17.380 --> 00:24:19.600
Just usually during development or debugging


00:24:19.600 --> 00:24:20.800
or something, not in production.


00:24:20.800 --> 00:24:23.880
But if you're like, well, how long did this take?


00:24:23.880 --> 00:24:27.320
So just yesterday I was fiddling with a function.


00:24:27.320 --> 00:24:29.840
I'm like, if I change it this way, will it get any faster?


00:24:29.840 --> 00:24:30.980
It's a little more complicated,


00:24:30.980 --> 00:24:33.540
but maybe there's a big benefit, right?


00:24:33.540 --> 00:24:35.660
And I put this on something like this on there


00:24:35.660 --> 00:24:37.260
and like, yeah, it didn't make any difference.


00:24:37.260 --> 00:24:39.700
So we'll keep them a simple bit of code in place.


00:24:39.700 --> 00:24:43.140
- Yeah, and if it's like super fast,


00:24:43.140 --> 00:24:45.820
you can also do things like loop it,


00:24:45.820 --> 00:24:49.140
like add a loop thing there so that it runs like 100 times


00:24:49.140 --> 00:24:51.340
and then do the division or something.


00:24:51.340 --> 00:24:52.340
- That's a really good point.


00:24:52.340 --> 00:24:56.100
And these are composable, right?


00:24:56.100 --> 00:24:57.220
Decorators are composable.


00:24:57.220 --> 00:25:00.940
So you could say @timeit @repeat1000.


00:25:00.940 --> 00:25:01.780
- Oh, yeah.


00:25:01.780 --> 00:25:02.600
- Right?


00:25:02.600 --> 00:25:05.980
I mean, all of a sudden repeat is starting to sound useful.


00:25:05.980 --> 00:25:08.580
They have a retry one for retrying a bunch of times.


00:25:08.580 --> 00:25:10.540
No.


00:25:10.540 --> 00:25:12.300
Tenacity.


00:25:12.300 --> 00:25:14.900
Don't do that.


00:25:14.900 --> 00:25:17.060
There's some that are really, really fantastic


00:25:17.060 --> 00:25:18.100
with many options.


00:25:18.100 --> 00:25:19.960
Don't bother rewriting some of those


00:25:19.960 --> 00:25:21.380
'cause you've got things like tenacity


00:25:21.380 --> 00:25:23.500
that has exponential back off,


00:25:23.500 --> 00:25:25.220
limiting the number of retries,


00:25:25.220 --> 00:25:28.600
customizing different behaviors and plans


00:25:28.600 --> 00:25:30.120
based on exceptions.


00:25:30.120 --> 00:25:31.880
So grab something like Tenacity.


00:25:31.880 --> 00:25:35.680
But the idea of understanding the retries is kind of cool.


00:25:35.680 --> 00:25:37.520
- Thanks for reminding us about Tenacity.


00:25:37.520 --> 00:25:38.360
I forgot about that.


00:25:38.360 --> 00:25:40.720
- Yeah, that's a good one, right?


00:25:40.720 --> 00:25:42.200
Count Call.


00:25:42.200 --> 00:25:45.240
If you're doing debugging or performance stuff,


00:25:45.240 --> 00:25:46.240
you're just like,


00:25:46.240 --> 00:25:48.760
why does it seem like this is getting called like five times?


00:25:48.760 --> 00:25:49.760
It should be called once.


00:25:49.760 --> 00:25:50.960
This is weird.


00:25:50.960 --> 00:25:52.240
And so you could actually,


00:25:52.240 --> 00:25:54.880
they introduced this Count Call decorator


00:25:54.880 --> 00:25:56.720
that just every time a function is called,


00:25:56.720 --> 00:25:58.200
it's now been called this many times,


00:25:58.200 --> 00:26:00.840
which sounds silly, but are you trying to track down


00:26:00.840 --> 00:26:02.720
like an N plus one database problem


00:26:02.720 --> 00:26:04.520
or other weird things like that?


00:26:04.520 --> 00:26:06.520
If you don't really know why something bizarre


00:26:06.520 --> 00:26:09.520
is happening a ton of times, this could be kind of helpful.


00:26:09.520 --> 00:26:10.360
- Yeah.


00:26:10.360 --> 00:26:15.560
- Rate limited, this one sounds cool as well.


00:26:15.560 --> 00:26:17.680
Like I only want you to call this function


00:26:17.680 --> 00:26:21.240
so often per second.


00:26:21.240 --> 00:26:25.400
and you can decide what to do.


00:26:25.400 --> 00:26:27.400
In this case, it says we're gonna time.sleep.


00:26:27.400 --> 00:26:28.940
I'm not so sure that makes a lot of sense,


00:26:28.940 --> 00:26:30.120
but it was asynchronous.


00:26:30.120 --> 00:26:32.400
You could await asyncIO.sleep


00:26:32.400 --> 00:26:34.280
and it would cause no overhead on the system.


00:26:34.280 --> 00:26:35.440
It wouldn't clog anything up.


00:26:35.440 --> 00:26:37.960
It would just make the caller wait.


00:26:37.960 --> 00:26:40.600
So there's some interesting variations there as well.


00:26:40.600 --> 00:26:43.800
Keep scrolling.


00:26:43.800 --> 00:26:46.600
And then some more built-in ones, data classes.


00:26:46.600 --> 00:26:50.260
If you wanna have a data class, just @dataclass the class.


00:26:51.120 --> 00:26:53.080
Brian, do you use data classes much?


00:26:53.080 --> 00:26:54.780
- Yes, quite a bit.


00:26:54.780 --> 00:26:55.840
- Nice.


00:26:55.840 --> 00:26:57.760
I like my classes to be VC funded,


00:26:57.760 --> 00:26:59.940
so I use Pydantic more often.


00:26:59.940 --> 00:27:03.200
(laughing)


00:27:03.200 --> 00:27:04.040
Let's see last week.


00:27:04.040 --> 00:27:06.960
No, congratulations to the Samuel team there.


00:27:06.960 --> 00:27:10.000
But I honestly, I typically use Pydantic a little bit more


00:27:10.000 --> 00:27:13.120
because I'm often gonna use it with FastAPI or Beanie


00:27:13.120 --> 00:27:14.360
or something over the wire,


00:27:14.360 --> 00:27:17.640
but I really like the idea of data classes too.


00:27:20.120 --> 00:27:23.080
All right, a couple more, register.


00:27:23.080 --> 00:27:24.160
Let me know if you know about this one.


00:27:24.160 --> 00:27:25.160
I heard about it a little while,


00:27:25.160 --> 00:27:27.640
but I haven't ever had a chance to use it.


00:27:27.640 --> 00:27:32.600
But the AT at exit module in Python,


00:27:32.600 --> 00:27:35.680
it has a way to say when my program is shutting down,


00:27:35.680 --> 00:27:38.900
even if the user like control C is out of it,


00:27:38.900 --> 00:27:42.480
I need to make sure that I delete say some file I created


00:27:42.480 --> 00:27:45.000
or call an API and tell it real quick,


00:27:45.000 --> 00:27:46.840
like, you know what, we're gone.


00:27:46.840 --> 00:27:48.360
Or I don't know, something like that, right?


00:27:48.360 --> 00:27:50.200
You just need, there's something you gotta do


00:27:50.200 --> 00:27:53.440
on your way out, even if it's a force exit.


00:27:53.440 --> 00:27:56.480
- Yeah, I have as, sorry to interrupt.


00:27:56.480 --> 00:27:57.320
I have used this.


00:27:57.320 --> 00:27:58.300
- Okay. - Yeah.


00:27:58.300 --> 00:27:59.140
- Yeah, when did you use it?


00:27:59.140 --> 00:28:00.360
What do you use it for?


00:28:00.360 --> 00:28:01.200
- Similar sort of thing.


00:28:01.200 --> 00:28:03.200
I've got like some thing in the background


00:28:03.200 --> 00:28:05.000
that I wanna make sure that we,


00:28:05.000 --> 00:28:06.240
there's a little bit of cleanup


00:28:06.240 --> 00:28:09.560
that's done before it goes away.


00:28:09.560 --> 00:28:11.720
But I just wanted to correct this.


00:28:11.720 --> 00:28:15.360
This says from import, from at exit import register


00:28:15.360 --> 00:28:17.200
and then decorate with register.


00:28:17.200 --> 00:28:20.040
I think it looks better if you just import out of the exit


00:28:20.040 --> 00:28:23.800
and do the decorator as at exit dot register


00:28:23.800 --> 00:28:25.080
because it's better documentation.


00:28:25.080 --> 00:28:26.100
- I totally agree.


00:28:26.100 --> 00:28:26.940
I totally agree.


00:28:26.940 --> 00:28:31.940
There's a couple of things in this article


00:28:31.940 --> 00:28:33.740
where the code is a little bit,


00:28:33.740 --> 00:28:36.640
no, it was the other article that I did


00:28:36.640 --> 00:28:38.160
that was a little bit, that I talked about,


00:28:38.160 --> 00:28:39.660
it was a little bit weird, but I agree.


00:28:39.660 --> 00:28:41.680
Keeping the namespace tells you like,


00:28:41.680 --> 00:28:43.600
well, what the heck are you registering for, right?


00:28:43.600 --> 00:28:46.320
I think namespaces are a good idea.


00:28:46.320 --> 00:28:47.160
I definitely use them.


00:28:47.160 --> 00:28:49.320
Anyway, so you can just put this decorator on a function.


00:28:49.320 --> 00:28:52.160
And when you exit, they show an example of some loop going,


00:28:52.160 --> 00:28:54.000
just while true, and they Control-C out of it.


00:28:54.000 --> 00:28:55.960
It says, hey, we're cleaning up here.


00:28:55.960 --> 00:28:57.040
Now bye.


00:28:57.040 --> 00:28:59.080
Which is a pretty nice way to handle it,


00:28:59.080 --> 00:29:02.080
instead of trying to catch all the use cases with exceptions


00:29:02.080 --> 00:29:05.320
and try finalizes and so on.


00:29:05.320 --> 00:29:08.000
All right, property.


00:29:08.000 --> 00:29:12.360
Give your fields behaviors and validation.


00:29:12.360 --> 00:29:13.640
Getter, setters, and so on.


00:29:13.640 --> 00:29:14.600
Love it.


00:29:14.600 --> 00:29:16.220
And single dispatch.


00:29:16.220 --> 00:29:19.380
I believe we've spoken about before where you can give,


00:29:19.380 --> 00:29:23.880
basically you do argument overloads for functions.


00:29:23.880 --> 00:29:26.220
So you can say, here's a function


00:29:26.220 --> 00:29:27.860
and here's the one that takes an integer


00:29:27.860 --> 00:29:29.020
and here's the one that takes a list.


00:29:29.020 --> 00:29:30.340
And these are separate functions


00:29:30.340 --> 00:29:31.700
and separate implementations.


00:29:31.700 --> 00:29:35.580
And you do that with that single dispatch decorator.


00:29:35.580 --> 00:29:38.660
- You know, I actually always forget about this, but-


00:29:38.660 --> 00:29:39.740
- I do too.


00:29:39.740 --> 00:29:42.980
- I kind of glad I forget about it because I think-


00:29:42.980 --> 00:29:44.580
- I would use it too much.


00:29:44.580 --> 00:29:46.140
- Maybe.


00:29:46.140 --> 00:29:49.740
I used to love function overloading


00:29:49.740 --> 00:29:53.220
when I was doing C, C++, C# type stuff.


00:29:53.220 --> 00:29:54.260
I would really count on it.


00:29:54.260 --> 00:29:57.240
And I thought I would miss it in Python, and I haven't.


00:29:57.240 --> 00:30:00.700
- Well, I noticed that some people


00:30:00.700 --> 00:30:02.900
that convert to Python from C


00:30:02.900 --> 00:30:05.580
will just assume that it has function overloading,


00:30:05.580 --> 00:30:07.580
and it just doesn't work.


00:30:07.580 --> 00:30:09.620
- That's known as function erasure.


00:30:09.620 --> 00:30:10.460
- Function erasure.


00:30:10.460 --> 00:30:11.780
- The last one wins, right?


00:30:11.780 --> 00:30:13.740
We talked about that last time.


00:30:13.740 --> 00:30:16.180
Oh no, we talked about that when we talked on Talk Python,


00:30:16.180 --> 00:30:17.740
which maybe we'll mention at the end,


00:30:17.740 --> 00:30:20.100
but yeah, last time we talked, yeah.


00:30:20.100 --> 00:30:20.940
- Yeah.


00:30:20.940 --> 00:30:25.420
- Anyway, those are the 12 that they put in the article.


00:30:25.420 --> 00:30:27.020
Most of them are really great.


00:30:27.020 --> 00:30:29.320
Some of them point you at things like tenacity,


00:30:29.320 --> 00:30:31.040
which is also really good.


00:30:31.040 --> 00:30:32.420
So that's what I got.


00:30:32.420 --> 00:30:33.700
- Nice.


00:30:33.700 --> 00:30:37.480
Well, I would like to talk about testing too a bit.


00:30:37.480 --> 00:30:39.180
Let's talk about PyHamCrest.


00:30:39.180 --> 00:30:44.180
So this topic is contributed by TXLs on the socials.


00:30:44.180 --> 00:30:49.260
So thanks TXLs.


00:30:49.260 --> 00:30:53.140
So PyHamCrest and the thought was like,


00:30:53.140 --> 00:30:54.740
Brian talks about testing a lot.


00:30:54.740 --> 00:30:56.620
So why haven't you covered this?


00:30:56.620 --> 00:30:58.700
So what PyHamCrest is,


00:30:58.700 --> 00:31:03.700
is a matcher object declarative rule matcher thing


00:31:03.700 --> 00:31:07.580
that helps you with the certs and stuff like that.


00:31:07.580 --> 00:31:08.500
Have you used this?


00:31:08.500 --> 00:31:10.080
- I have not.


00:31:10.080 --> 00:31:15.080
My first thought it was like some kind of menu item


00:31:15.080 --> 00:31:17.600
on a holiday dinner, but no.


00:31:17.600 --> 00:31:20.520
I literally only heard about this


00:31:20.520 --> 00:31:21.520
'cause you put it in the show notes.


00:31:21.520 --> 00:31:22.780
So it's news to me.


00:31:22.780 --> 00:31:23.620
- Okay.


00:31:23.620 --> 00:31:28.340
So the idea is instead of like all the assert,


00:31:28.340 --> 00:31:29.980
so you've got a whole bunch of certain things


00:31:29.980 --> 00:31:32.920
like assert that, assert that and equal to


00:31:32.920 --> 00:31:35.240
and a bunch of ham crisp things that you can import.


00:31:35.240 --> 00:31:38.320
So you can do things like instead of saying


00:31:38.320 --> 00:31:41.840
assert the biscuit equals my biscuit.


00:31:41.840 --> 00:31:45.420
You can say, assert that the biscuit equal to my biscuit.


00:31:45.420 --> 00:31:49.600
So at first, so I've always thought asserts are,


00:31:49.600 --> 00:31:53.400
like I get this for unit test, but for pytest,


00:31:53.400 --> 00:31:54.960
what do we need it?


00:31:54.960 --> 00:31:57.880
Because you could just use assert in pytest.


00:31:57.880 --> 00:32:02.480
However, I'm kind of easing up on that argument


00:32:02.480 --> 00:32:05.400
because I can see a lot of places where just really,


00:32:05.400 --> 00:32:08.080
if you can make your assertions more readable


00:32:08.080 --> 00:32:10.480
in some contexts, then why not?


00:32:10.480 --> 00:32:13.560
- Sure, and I don't know about this one,


00:32:13.560 --> 00:32:18.000
but if it's got things like go through a list


00:32:18.000 --> 00:32:20.520
and assert everything as equal in the list, right?


00:32:20.520 --> 00:32:21.360
- Yeah.


00:32:21.360 --> 00:32:24.600
- Or higher order things where it would be kind of complex


00:32:24.600 --> 00:32:27.840
to implement the test that is the thing you want to assert.


00:32:27.840 --> 00:32:30.800
Like these three fields are equal of these three things,


00:32:30.800 --> 00:32:32.840
right, then it becomes a little less obvious.


00:32:32.840 --> 00:32:37.480
And if this has a really nice story, it looks like it does.


00:32:37.480 --> 00:32:39.660
- Yep, there's a whole bunch of matchers within it.


00:32:39.660 --> 00:32:42.980
Like for objects, it's like equal to and has length,


00:32:42.980 --> 00:32:47.380
it has property, has properties is interesting.


00:32:47.380 --> 00:32:49.700
So you could like assert on duck typing.


00:32:49.700 --> 00:32:53.020
Hopefully it has these values or something.


00:32:53.020 --> 00:32:56.340
Numbers close to greater than, less than,


00:32:56.340 --> 00:32:58.740
of course, these asserts are fine with this,


00:32:58.740 --> 00:33:02.260
but the logical stuff, the logical and sequences


00:33:02.260 --> 00:33:04.640
is what I think where I probably might use it.


00:33:04.640 --> 00:33:07.680
Things like all of or any of or anything,


00:33:07.680 --> 00:33:09.720
or that's neat.


00:33:09.720 --> 00:33:11.500
Like all of these things are true.


00:33:11.500 --> 00:33:15.000
And you can combine this with or,


00:33:15.000 --> 00:33:18.020
like all of these or all of those or something.


00:33:18.020 --> 00:33:22.780
Sequences, it contains in any order.


00:33:22.780 --> 00:33:24.360
That's kind of interesting.


00:33:24.360 --> 00:33:26.240
- Nice.


00:33:26.240 --> 00:33:28.920
- Has items, is in.


00:33:28.920 --> 00:33:32.080
Again, these are things that are testable in Python,


00:33:32.080 --> 00:33:35.860
raw, like just raw test, not too bad,


00:33:35.860 --> 00:33:38.920
but if it's more readable, sure, why not?


00:33:38.920 --> 00:33:43.080
So there's some like that are shown,


00:33:43.080 --> 00:33:46.440
like, especially with raising error, like exceptions.


00:33:46.440 --> 00:33:47.280
Oh, where'd I get it?


00:33:47.280 --> 00:33:50.860
Oh, the tutorial has a bunch of cool stuff in it.


00:33:50.860 --> 00:33:54.780
The things like assert that calling translate


00:33:54.780 --> 00:33:58.140
with args curse word raises a language error.


00:33:58.140 --> 00:33:59.480
Well, that's kind of neat.


00:33:59.480 --> 00:34:01.820
- Very naughty.


00:34:01.820 --> 00:34:05.240
assert that broken function raises exception.


00:34:05.240 --> 00:34:06.080
Okay.


00:34:06.080 --> 00:34:09.940
I mean, in pytest, you've got the raises thing


00:34:09.940 --> 00:34:14.020
with pytest raises, but it is, some people have a hard,


00:34:14.020 --> 00:34:17.220
like it's not obvious and this may be,


00:34:17.220 --> 00:34:18.580
maybe this looks better.


00:34:18.580 --> 00:34:21.820
This is kind of neat.


00:34:21.820 --> 00:34:26.060
You can use assertion exceptions with async methods.


00:34:26.060 --> 00:34:28.300
So it has a resolved item.


00:34:28.300 --> 00:34:31.600
So you can say assert that await resolved future


00:34:31.600 --> 00:34:36.740
results in future raising value error or something.


00:34:36.740 --> 00:34:38.380
- Yeah, nice. That's cool.


00:34:38.380 --> 00:34:40.940
- So, yeah.


00:34:40.940 --> 00:34:43.900
So a lot of predefined matchers and I guess


00:34:43.900 --> 00:34:48.900
it has some syntactic sugar things like is underscore.


00:34:48.900 --> 00:34:52.420
So just if it sounds better to have an is in there,


00:34:52.420 --> 00:34:53.460
you can add it.


00:34:53.460 --> 00:34:56.820
So assert that the biscuit is equal to,


00:34:56.820 --> 00:34:59.980
doesn't do anything, but it sounds better.


00:34:59.980 --> 00:35:02.980
So why not, I guess.


00:35:02.980 --> 00:35:04.420
>> If you wanted to read that English,


00:35:04.420 --> 00:35:07.900
like insert a no op verb.


00:35:07.900 --> 00:35:08.740
>> Yeah.


00:35:08.740 --> 00:35:14.420
But I guess I do want to highlight this because why not?


00:35:14.420 --> 00:35:17.140
I mean, since I'm writing a lot of test code,


00:35:17.140 --> 00:35:19.460
I'm used to all the different ways you can check


00:35:19.460 --> 00:35:22.840
different equivalents of values or comparisons.


00:35:22.840 --> 00:35:25.460
So I don't know how much I would use this,


00:35:25.460 --> 00:35:28.400
but I've seen a lot of people struggle


00:35:28.400 --> 00:35:30.440
with how to write an assertion.


00:35:30.440 --> 00:35:33.160
And so having some help with the library, why not?


00:35:33.160 --> 00:35:34.600
So this is pretty neat.


00:35:34.600 --> 00:35:36.120
- Yeah, this totally resonates with me.


00:35:36.120 --> 00:35:36.960
I like it.


00:35:36.960 --> 00:35:42.840
- Well, that's our six items, six, four items.


00:35:42.840 --> 00:35:45.080
(laughing)


00:35:45.080 --> 00:35:49.440
Do you have any extras for us this week?


00:35:49.440 --> 00:35:51.240
- I do have a few extras.


00:35:51.240 --> 00:35:52.760
Let me throw them in here.


00:35:52.760 --> 00:35:54.400
First of all, it's a few weeks old.


00:35:54.400 --> 00:35:56.880
I didn't remember to put it up here,


00:35:56.880 --> 00:36:01.880
but Python 3.11.2 is out as well as 3.10.10


00:36:01.880 --> 00:36:07.320
and the alpha five of 3.12.


00:36:07.320 --> 00:36:09.820
We're getting kind of close to beta, it feels like,


00:36:09.820 --> 00:36:11.360
for 3.12, which will be exciting


00:36:11.360 --> 00:36:12.720
'cause then we'll get real visibility


00:36:12.720 --> 00:36:15.200
into what's probably gonna be happening


00:36:15.200 --> 00:36:16.500
for the next version of Python.


00:36:16.500 --> 00:36:17.440
That's cool.


00:36:17.440 --> 00:36:19.120
- Yeah.


00:36:19.120 --> 00:36:23.920
I'm testing for 3.12 already with our CI builds.


00:36:23.920 --> 00:36:24.760
Nice.


00:36:24.760 --> 00:36:28.280
For example, with 3.11.2,


00:36:28.280 --> 00:36:33.280
there were 192 commits since 3.11.1, 194 rather.


00:36:33.280 --> 00:36:37.040
So that's pretty, it's pretty non-trivial right there.


00:36:37.040 --> 00:36:39.440
And they link over to somewhere that looks,


00:36:39.440 --> 00:36:41.640
I don't know, just, what am I supposed to learn from that?


00:36:41.640 --> 00:36:44.120
Here's the changes from 3.11 to 3.12.


00:36:44.120 --> 00:36:46.320
So I always go to downloads, full list of downloads.


00:36:46.320 --> 00:36:47.400
Dun-na-na-na-na-na-na.


00:36:47.400 --> 00:36:51.120
Scroll down to the particular version here


00:36:51.120 --> 00:36:52.240
and go to release notes.


00:36:52.240 --> 00:36:53.080
And there you go.


00:36:53.080 --> 00:36:54.200
probably what they should be linking to.


00:36:54.200 --> 00:36:55.440
And here's all the things.


00:36:55.440 --> 00:36:57.360
There's some that are in here that are


00:36:57.360 --> 00:37:00.880
things that you might actually care about.


00:37:00.880 --> 00:37:04.040
Like for example, fixed race condition


00:37:04.040 --> 00:37:06.640
while iterating over thread states in thread.local.


00:37:06.640 --> 00:37:09.160
You might not want that in your code.


00:37:09.160 --> 00:37:10.480
And various other things.


00:37:10.480 --> 00:37:13.000
Yeah, bunch of, there's a,


00:37:13.000 --> 00:37:14.200
look at all these changes here.


00:37:14.200 --> 00:37:15.280
This is a lot.


00:37:15.280 --> 00:37:16.560
- Yeah, nice.


00:37:16.560 --> 00:37:18.240
- So, yeah. - Go team.


00:37:18.240 --> 00:37:19.080
- Yeah, go team.


00:37:19.080 --> 00:37:23.000
You might think, oh, it's just a dot plus one,


00:37:23.000 --> 00:37:27.240
plus 0.0.1 sort of thing to it.


00:37:27.240 --> 00:37:30.960
But now it's got some interesting changes,


00:37:30.960 --> 00:37:33.460
as well as I haven't looked at what's happening in the others,


00:37:33.460 --> 00:37:35.440
but maybe some of those are important enough


00:37:35.440 --> 00:37:37.680
to pull backwards those fixes.


00:37:37.680 --> 00:37:41.360
Also, more recent, as in eight days ago,


00:37:41.360 --> 00:37:46.800
we've got Django 4.2 beta, beta 1.


00:37:46.800 --> 00:37:52.840
And typically, the philosophy is once it hits beta,


00:37:52.840 --> 00:37:55.040
The API should be stable, the features should be stable.


00:37:55.040 --> 00:37:57.040
It's just about fixing bugs.


00:37:57.040 --> 00:37:58.160
Doesn't always work out that way,


00:37:58.160 --> 00:37:59.200
but that's generally the idea.


00:37:59.200 --> 00:38:04.200
So basically, here's your concrete look at Django 4.2.


00:38:04.200 --> 00:38:05.880
- Yeah. - If that's right.


00:38:05.880 --> 00:38:08.400
- And 4.2 looks exciting.


00:38:08.400 --> 00:38:09.280
- Yeah, absolutely.


00:38:09.280 --> 00:38:12.420
So you can, you know, they've got some release nodes


00:38:12.420 --> 00:38:14.600
and various things about what's going on.


00:38:14.600 --> 00:38:15.500
You can go check that out.


00:38:15.500 --> 00:38:20.000
So they got Psycho PG3, so Postgres support.


00:38:21.480 --> 00:38:26.360
It now supports post-PsychoPG version 3.1.8 or higher.


00:38:26.360 --> 00:38:29.320
So you can update your code to use that as a backend.


00:38:29.320 --> 00:38:32.680
- I'm still using two, so I better know those at three.


00:38:32.680 --> 00:38:34.640
- Now, careful, Brian.


00:38:34.640 --> 00:38:36.600
PsychoPG 2 is likely to be deprecated


00:38:36.600 --> 00:38:38.720
and removed at some point in the future.


00:38:38.720 --> 00:38:39.560
- Okay.


00:38:39.560 --> 00:38:42.420
- Yeah, comments on columns and tables.


00:38:42.420 --> 00:38:45.960
So that's kind of neat in the database model.


00:38:45.960 --> 00:38:48.840
So the ORM gets some of their mitigation.


00:38:48.840 --> 00:38:50.280
- No comment on that.


00:38:50.280 --> 00:38:52.520
Yeah, no comment, very good.


00:38:52.520 --> 00:38:54.900
Some stuff about the so-called breach attack.


00:38:54.900 --> 00:38:57.000
I have no idea what it seems to have to do with gzip,


00:38:57.000 --> 00:38:58.320
so check that out.


00:38:58.320 --> 00:39:01.080
Another one that's interesting is in-memory file storage


00:39:01.080 --> 00:39:04.040
and custom file stores.


00:39:04.040 --> 00:39:06.680
This is for making testing potentially faster.


00:39:06.680 --> 00:39:09.880
So if you're gonna write some files as part of a behavior,


00:39:09.880 --> 00:39:11.200
you can say, just write them to in-memory.


00:39:11.200 --> 00:39:13.880
Don't have to clean them up, and they write really fast.


00:39:13.880 --> 00:39:16.360
- Yeah, it phenomenally speeds up testing.


00:39:16.360 --> 00:39:19.480
It's good. - Yeah, but, all right.


00:39:19.480 --> 00:39:20.540
So there's that.


00:39:20.540 --> 00:39:23.740
And then also, I want to give a shout out--


00:39:23.740 --> 00:39:24.660
I'll put it like this.


00:39:24.660 --> 00:39:27.100
I want to give a shout out to an app real quick


00:39:27.100 --> 00:39:30.060
that people might find useful by way of a journey.


00:39:30.060 --> 00:39:35.460
So rewriting the Talk Python apps in Flutter, which all the APIs


00:39:35.460 --> 00:39:39.500
are Python, but we're having apps on macOS, Windows,


00:39:39.500 --> 00:39:42.060
Linux, iOS, and Android.


00:39:42.060 --> 00:39:43.560
That's really hard to do with Python,


00:39:43.560 --> 00:39:44.940
so Flutter is what we're using.


00:39:44.940 --> 00:39:46.460
And it's going along really well.


00:39:46.460 --> 00:39:48.500
Here's a little screenshot for you, Brian,


00:39:48.500 --> 00:39:50.220
to show you what we've got so far.


00:39:50.220 --> 00:39:51.140
Isn't that cool?


00:39:51.140 --> 00:39:51.980
- Yeah.


00:39:51.980 --> 00:39:54.820
- Yes, and another, like here's the little app and stuff.


00:39:54.820 --> 00:39:56.500
So I think I'm really happy with how it's coming together.


00:39:56.500 --> 00:39:58.660
I think it's gonna be a better mobile app experience


00:39:58.660 --> 00:40:02.220
for, and an existing desktop experience


00:40:02.220 --> 00:40:05.220
for like offline mode with the Talk Python courses.


00:40:05.220 --> 00:40:06.040
- Oh, cool.


00:40:06.040 --> 00:40:07.740
- Yeah, so that'll be really neat.


00:40:07.740 --> 00:40:09.980
The thing I wanna tell you about


00:40:09.980 --> 00:40:12.280
is something I just applied to it.


00:40:12.280 --> 00:40:14.820
This thing called ImageOptim.


00:40:14.820 --> 00:40:16.420
And what you can do is you can just take


00:40:16.420 --> 00:40:17.860
the top level of your project.


00:40:17.860 --> 00:40:20.780
So I did this for, say, the Talk Python Training website.


00:40:20.780 --> 00:40:22.060
I did this for the mobile app.


00:40:22.060 --> 00:40:24.860
Just take the very top level project folder


00:40:24.860 --> 00:40:26.220
and just throw it on this app.


00:40:26.220 --> 00:40:28.900
And it'll go find all the images, all the vector


00:40:28.900 --> 00:40:32.180
graphics, and everything, and minimize the heck out of them.


00:40:32.180 --> 00:40:35.020
So for example, when I did that on the mobile app,


00:40:35.020 --> 00:40:37.180
it went from 10 megs of image assets


00:40:37.180 --> 00:40:39.800
to 8 megs of image assets, lossless.


00:40:39.800 --> 00:40:43.340
Like, no one will know the difference other than me


00:40:43.340 --> 00:40:44.460
that I've done it.


00:40:44.460 --> 00:40:47.220
And it dropped 20% of the file size, which


00:40:47.220 --> 00:40:50.100
It's not the end of the world, but given how much work it is,


00:40:50.100 --> 00:40:51.460
it's not too bad.


00:40:51.460 --> 00:40:54.000
- Well, the lossless part is the important bit.


00:40:54.000 --> 00:40:55.660
So that's pretty exciting.


00:40:55.660 --> 00:40:56.500
- Yeah, exactly.


00:40:56.500 --> 00:40:59.600
So it'll do things like if it's a PNG and it sees


00:40:59.600 --> 00:41:01.760
you're using a smaller color palette


00:41:01.760 --> 00:41:02.860
than what it's actually holding.


00:41:02.860 --> 00:41:04.920
It's like, oh, we can rewrite that in a way


00:41:04.920 --> 00:41:06.260
that doesn't make it actually look different,


00:41:06.260 --> 00:41:08.020
but takes up less storage.


00:41:08.020 --> 00:41:12.100
Basically, it's a wrapper over things like Moze JPEG,


00:41:12.100 --> 00:41:17.100
PNG Crush, Google Zopfali, I don't know.


00:41:17.100 --> 00:41:18.460
how to save these things.


00:41:18.460 --> 00:41:22.340
But there are a bunch of lossless image manipulation tools


00:41:22.340 --> 00:41:24.100
and it just applies those to all of them


00:41:24.100 --> 00:41:24.980
in a super easy way.


00:41:24.980 --> 00:41:26.900
And this thing's open source itself.


00:41:26.900 --> 00:41:27.740
- Cool.


00:41:27.740 --> 00:41:30.420
- So yeah, anyway, if people have websites out there,


00:41:30.420 --> 00:41:33.060
they could consider just like,


00:41:33.060 --> 00:41:35.460
take your website, throw it on here,


00:41:35.460 --> 00:41:37.920
and it'll tell you, make sure it's all checked in and get,


00:41:37.920 --> 00:41:39.300
do this, see what it says.


00:41:39.300 --> 00:41:40.560
It gives you a little report at the bottom,


00:41:40.560 --> 00:41:45.460
like you saved either 10K or you saved five megs,


00:41:45.460 --> 00:41:48.620
depending, you can decide whether to keep the changes.


00:41:48.620 --> 00:41:49.520
- Yeah, cool.


00:41:49.520 --> 00:41:53.380
- Yep, all right, that's all my extras.


00:41:53.380 --> 00:41:54.220
How about you?


00:41:54.220 --> 00:41:55.580
- I just have a couple.


00:41:55.580 --> 00:41:58.540
Yesterday I talked with you on Python Byte,


00:41:58.540 --> 00:42:02.660
no, on Talk Python, about pytest tips and tricks.


00:42:02.660 --> 00:42:06.380
And I just wanted to point out that the post is available


00:42:06.380 --> 00:42:08.840
for people to read if they want to go look through it.


00:42:08.840 --> 00:42:11.980
And if you have comments, please, or questions,


00:42:11.980 --> 00:42:14.260
let me know, of course.


00:42:14.260 --> 00:42:17.020
Also in March, I think I've brought this up before,


00:42:17.020 --> 00:42:20.060
but I'll be speaking at PyCascades.


00:42:20.060 --> 00:42:21.960
There's a picture of me without hair.


00:42:21.960 --> 00:42:27.860
And I did stick up a blog post on pythontest.com,


00:42:27.860 --> 00:42:33.860
just a placeholder so that I can link the slides


00:42:33.860 --> 00:42:35.500
and code afterwards.


00:42:35.500 --> 00:42:36.940
So that's up.


00:42:36.940 --> 00:42:37.900
- Awesome.


00:42:37.900 --> 00:42:39.660
- And that's it.


00:42:39.660 --> 00:42:41.700
- Yeah, that's gonna be a really cool talk.


00:42:41.700 --> 00:42:43.020
I think a lot of people are interested


00:42:43.020 --> 00:42:45.860
how you share fixtures and build them for your team


00:42:45.860 --> 00:42:48.900
or cross project as well.


00:42:48.900 --> 00:42:50.940
As it was really great to have you on Talk Python.


00:42:50.940 --> 00:42:53.300
We talked a bunch of cool pytest things.


00:42:53.300 --> 00:42:54.660
That'll be out in a few weeks for people


00:42:54.660 --> 00:42:56.540
if they don't wanna watch the YouTube version.


00:42:56.540 --> 00:42:59.700
- And then we'll let people know when that's available.


00:42:59.700 --> 00:43:00.780
But yeah, absolutely.


00:43:00.780 --> 00:43:02.180
But hopefully they're all subscribed


00:43:02.180 --> 00:43:03.940
to Talk Python already anyway.


00:43:03.940 --> 00:43:04.940
- I'm sure they are.


00:43:04.940 --> 00:43:05.940
- Yeah. - They are.


00:43:05.940 --> 00:43:07.820
How about a joke?


00:43:07.820 --> 00:43:08.660
Are we ready?


00:43:08.660 --> 00:43:10.020
- Yes, let's do a joke.


00:43:10.020 --> 00:43:11.260
- Let's do it.


00:43:11.260 --> 00:43:13.580
So this one, this is a quick and easy one.


00:43:13.580 --> 00:43:16.260
And for people listening, no pictures even.


00:43:16.260 --> 00:43:20.520
This one comes from Nick's craft on Twitter.


00:43:20.520 --> 00:43:25.520
And it says, "Developers, let us describe you as a group."


00:43:25.520 --> 00:43:26.800
Right?


00:43:26.800 --> 00:43:30.860
Things, groups of things sometimes have weird names.


00:43:30.860 --> 00:43:31.840
Right?


00:43:31.840 --> 00:43:35.340
Like a group of wolves is called a pack.


00:43:35.340 --> 00:43:37.500
A group of crows is called a murder.


00:43:38.400 --> 00:43:41.480
We think we should call a group of developers, Brian.


00:43:41.480 --> 00:43:43.960
- That's hilarious.


00:43:43.960 --> 00:43:46.360
A group of developers is called a merge conflict.


00:43:46.360 --> 00:43:48.440
(both laughing)


00:43:48.440 --> 00:43:49.280
- Isn't that good?


00:43:49.280 --> 00:43:50.400
- Yeah.


00:43:50.400 --> 00:43:51.240
- It is.


00:43:51.240 --> 00:43:52.700
The comments are pretty good.


00:43:52.700 --> 00:43:58.080
If you scroll down here, some of them are silly.


00:43:58.080 --> 00:43:59.500
Some are just like, yep.


00:43:59.500 --> 00:44:04.900
Yeah, anyway, they're pretty good.


00:44:06.120 --> 00:44:08.960
But yeah, a group of developers is called a merge conflict.


00:44:08.960 --> 00:44:10.400
And so true it is.


00:44:10.400 --> 00:44:14.080
You can even have a merge conflict with yourself.


00:44:14.080 --> 00:44:15.000
Be a group of one.


00:44:15.000 --> 00:44:21.440
- How about a group of tech CEOs with social media accounts


00:44:21.440 --> 00:44:23.920
would be a lawsuit.


00:44:23.920 --> 00:44:25.920
- That's right.


00:44:25.920 --> 00:44:28.560
An SEC investigation.


00:44:28.560 --> 00:44:29.400
That's right.


00:44:29.400 --> 00:44:30.220
- Yeah, yeah.


00:44:30.220 --> 00:44:32.360
- Cool.


00:44:32.360 --> 00:44:33.320
Wow.


00:44:33.320 --> 00:44:34.160
Fun as always.


00:44:34.160 --> 00:44:34.980
Thank you.


00:44:34.980 --> 00:44:39.620
Thanks everybody for showing up as always and we'll see you next time.

