WEBVTT

00:00:00.000 --> 00:00:08.320
Hey YouTube. Hey Brian. Hey. Hey, great to be here with you as always. Good to be here.


00:00:08.320 --> 00:00:13.360
Thanks everyone who is out there in the live stream watching. As always, put your comments


00:00:13.360 --> 00:00:17.680
and thoughts into the live stream. We'll try to make them part of the show if they fit.


00:00:17.680 --> 00:00:22.520
That's much appreciated. If you're watching the playback, well thanks, but obviously no


00:00:22.520 --> 00:00:30.360
time travel so no live chat. Well not yet Brian, no one's come back from the future


00:00:30.360 --> 00:00:38.040
to tell us. No actually we invented time travel. But I'm assuming, I'm assuming. Anyway, thanks


00:00:38.040 --> 00:00:41.080
for being here either way and yeah let's just kick it off.


00:00:41.080 --> 00:00:44.360
All right sounds good.


00:00:44.360 --> 00:00:48.280
Hello and welcome to Python Bytes where we deliver Python news and headlines directly


00:00:48.280 --> 00:00:55.280
to your earbuds. This is episode 330 recorded April 4th, 2023. I'm Michael Kennedy.


00:00:55.280 --> 00:00:56.760
>> Brian O'Connor And I'm Brian O'Connor.


00:00:56.760 --> 00:01:02.000
>> Brian O'Connor And you can connect with us over on Fosstodon.


00:01:02.000 --> 00:01:08.480
If you're on Mastodon, find us there. I'm@mkennedy@fauceton.org. Brian's Brian O'Connor


00:01:08.480 --> 00:01:15.560
over there. And the show is at pythonbytes@fauceton.org. And if you're interested in the video version,


00:01:15.560 --> 00:01:18.440
check out pythonbytes.fm/live, click that,


00:01:18.440 --> 00:01:20.560
go over to the YouTube channel, subscribe, get notified,


00:01:20.560 --> 00:01:24.640
you'll get a little pop-up when we start streaming live.


00:01:24.640 --> 00:01:26.440
It's always fun to be part of it.


00:01:26.440 --> 00:01:29.600
We encourage people to check the show out that way as well.


00:01:29.600 --> 00:01:32.760
So Brian, let's start off with something


00:01:32.760 --> 00:01:36.300
that has been almost exactly one year in the works.


00:01:36.300 --> 00:01:39.140
- I was just gonna ask you about that.


00:01:39.140 --> 00:01:42.840
So was this about a year ago


00:01:42.840 --> 00:01:45.480
we talked about this Pydantic rewrite?


00:01:45.480 --> 00:01:55.340
I think I saw something on Twitter of all places from Samuel Colvin saying it was April


00:01:55.340 --> 00:02:00.560
4th, 2022 that I started working on Pydantic version 2.


00:02:00.560 --> 00:02:02.520
So that sounds like to the day.


00:02:02.520 --> 00:02:03.520
Okay.


00:02:03.520 --> 00:02:07.800
Well, it's not completely here yet, but it's here enough to try.


00:02:07.800 --> 00:02:09.440
So I'm pretty excited about it.


00:02:09.440 --> 00:02:14.040
So by Pydantic V2 version two pre-release.


00:02:14.040 --> 00:02:16.100
So people can, it's available now.


00:02:16.100 --> 00:02:17.640
So people can install it.


00:02:17.640 --> 00:02:22.640
You have to do the, like the pip install --pre


00:02:22.640 --> 00:02:26.120
Pydantic and then you can say by Pydantic greater


00:02:26.120 --> 00:02:30.000
than or equal to 2.0 A1, I guess,


00:02:30.000 --> 00:02:32.400
if you want to get the alpha one or better.


00:02:32.400 --> 00:02:35.480
So the big news is alpha one's available


00:02:35.480 --> 00:02:37.960
and it's pretty exciting.


00:02:37.960 --> 00:02:39.900
there's a whole bunch of great stuff changes.


00:02:39.900 --> 00:02:41.580
We've talked, I think we talked about it.


00:02:41.580 --> 00:02:43.380
You talked about it on your show, I think also.


00:02:43.380 --> 00:02:44.800
- Yeah.


00:02:44.800 --> 00:02:48.540
- But the headlines here is,


00:02:48.540 --> 00:02:50.820
well, one, it's not complete yet.


00:02:50.820 --> 00:02:51.760
This is the alpha.


00:02:51.760 --> 00:02:53.040
We're not even debate is yet.


00:02:53.040 --> 00:02:56.520
So if you see, if you try it out and you see something,


00:02:56.520 --> 00:03:00.320
they've got a GitHub created GitHub issue


00:03:00.320 --> 00:03:04.880
and they want to have people use the bug V2 label


00:03:04.880 --> 00:03:07.940
to create issues around the version two.


00:03:07.940 --> 00:03:09.980
'cause I wanna hop on those right away.


00:03:09.980 --> 00:03:13.280
Anyway, so the big change was,


00:03:13.280 --> 00:03:17.440
one of the big changes was to move all a lot of Pydantic


00:03:17.440 --> 00:03:20.240
and the rules and everything


00:03:20.240 --> 00:03:24.180
into a different module called Pydantic Core.


00:03:24.180 --> 00:03:26.400
That one's mostly written in Rust.


00:03:26.400 --> 00:03:31.760
And so it's like five to 50 times faster overall


00:03:31.760 --> 00:03:34.860
for performance.


00:03:34.860 --> 00:03:36.100
So that's pretty exciting.


00:03:36.100 --> 00:03:37.780
'Cause these are, I mean, this is,


00:03:37.780 --> 00:03:39.140
When you're using Pydantic,


00:03:39.140 --> 00:03:41.020
it's hitting for every interaction, right?


00:03:41.020 --> 00:03:43.380
So as fast as possible is great.


00:03:43.380 --> 00:03:46.140
And I do like the idea of the,


00:03:46.140 --> 00:03:48.260
like the separating the rust part out


00:03:48.260 --> 00:03:49.460
into a different module,


00:03:49.460 --> 00:03:52.880
different package Pydantic core,


00:03:52.880 --> 00:03:56.500
so that they can have kind of maintain it


00:03:56.500 --> 00:03:58.680
and have safety and maintenance around that


00:03:58.680 --> 00:04:00.060
a little separate.


00:04:00.060 --> 00:04:01.740
I think that makes sense.


00:04:01.740 --> 00:04:04.860
- Yeah, and people used to have to create


00:04:04.860 --> 00:04:06.180
their derived classes


00:04:06.180 --> 00:04:07.800
and put a lot of their customization


00:04:07.800 --> 00:04:11.540
and their what's called root level validators


00:04:11.540 --> 00:04:12.700
and things like that where it's like,


00:04:12.700 --> 00:04:13.940
I wanna validate the whole class,


00:04:13.940 --> 00:04:16.740
not just a certain field or if this is set,


00:04:16.740 --> 00:04:18.540
then that has to be set that way.


00:04:18.540 --> 00:04:21.940
A lot of those things had to be done in an OOP way.


00:04:21.940 --> 00:04:23.620
And I think with the PyDandic core,


00:04:23.620 --> 00:04:26.580
you have more direct access to a layer below.


00:04:26.580 --> 00:04:29.300
So it's not just faster, which is fantastic,


00:04:29.300 --> 00:04:33.300
but it also opens up more ways to interact with PyDandic,


00:04:33.300 --> 00:04:34.380
which is cool.


00:04:34.380 --> 00:04:39.240
- Yeah, so they've got a lot of stuff working already.


00:04:39.240 --> 00:04:41.200
They want people to be able to experiment


00:04:41.200 --> 00:04:44.880
and try out their base model changes,


00:04:44.880 --> 00:04:47.880
a lot of the same features for validation,


00:04:47.880 --> 00:04:52.040
but there's new method names and it is a change.


00:04:52.040 --> 00:04:54.720
Data classes, serialization, strict mode,


00:04:54.720 --> 00:04:58.120
different schemas, lots of changes for V2.


00:04:58.120 --> 00:05:00.420
So I'd like people to try it out.


00:05:02.880 --> 00:05:05.900
There is a lot of stuff still under construction,


00:05:05.900 --> 00:05:07.860
mostly documentation.


00:05:07.860 --> 00:05:10.300
And some of the, like some of the base settings


00:05:10.300 --> 00:05:12.680
have changed from, there were base settings


00:05:12.680 --> 00:05:14.800
and now they're gonna be in by Pydantic settings.


00:05:14.800 --> 00:05:16.700
That's not quite ready.


00:05:16.700 --> 00:05:19.940
So there's still some work to do,


00:05:19.940 --> 00:05:21.180
even in the migration guide.


00:05:21.180 --> 00:05:23.840
So there's, they've gotten the start of the migration guide,


00:05:23.840 --> 00:05:24.680
but it's not there.


00:05:24.680 --> 00:05:27.220
As you see on like the, some of the links,


00:05:27.220 --> 00:05:31.060
there's changes to data classes, changes to base model.


00:05:31.060 --> 00:05:33.100
Some of the stuff's already there,


00:05:33.100 --> 00:05:35.580
but it's still under construction.


00:05:35.580 --> 00:05:36.940
So pretty exciting.


00:05:36.940 --> 00:05:37.780
- Yeah.


00:05:37.780 --> 00:05:40.740
I'm definitely excited.


00:05:40.740 --> 00:05:45.740
And the five to 50 times faster, that's no joke.


00:05:45.740 --> 00:05:47.980
There's the idea, okay, well, what are you doing?


00:05:47.980 --> 00:05:50.580
I'm like parsing like a settings file


00:05:50.580 --> 00:05:53.500
or I got a single JSON document, whatever.


00:05:53.500 --> 00:05:56.740
All the FastAPI is deeply, not all,


00:05:56.740 --> 00:06:00.060
but much of FastAPI is deeply based on exchanging


00:06:00.060 --> 00:06:03.140
rich data with Pydantic.


00:06:03.140 --> 00:06:07.140
So your API layer could get much faster.


00:06:07.140 --> 00:06:10.500
And you can also use this, people maybe don't realize it,


00:06:10.500 --> 00:06:14.500
you can use this with other frameworks as well.


00:06:14.500 --> 00:06:17.060
You could use it with Flask, you could use it with Pyramid.


00:06:17.060 --> 00:06:19.900
FastAPI is cool because you can put just,


00:06:19.900 --> 00:06:22.740
there's a argument of type Pydantic model


00:06:22.740 --> 00:06:24.740
and it automatically fills it all in.


00:06:24.740 --> 00:06:27.300
But all you got to do is just take,


00:06:27.300 --> 00:06:29.900
here's the post dictionary and feed it to a Pydantic model.


00:06:29.900 --> 00:06:32.160
like just inside the function as the first line


00:06:32.160 --> 00:06:33.780
and you're in the same place.


00:06:33.780 --> 00:06:36.180
You can use this across all these areas.


00:06:36.180 --> 00:06:40.840
Then for example, Python bytes.fm is powered by Beanie,


00:06:40.840 --> 00:06:45.320
which is Pydantic plus MongoDB plus Async, which is awesome.


00:06:45.320 --> 00:06:48.500
But every single database record comes back,


00:06:48.500 --> 00:06:50.240
goes through Pydantic.


00:06:50.240 --> 00:06:53.560
And if you're using something like Beanie or SQL model


00:06:53.560 --> 00:06:56.000
and FastAPI, your data layer goes through Pydantic


00:06:56.000 --> 00:07:00.680
and your web layer, 'cause there's like multi-layered


00:07:00.680 --> 00:07:03.720
Pydantic operations on every interaction.


00:07:03.720 --> 00:07:06.840
And so making that part five to 50 times faster


00:07:06.840 --> 00:07:09.760
is just huge, right?


00:07:09.760 --> 00:07:12.400
That's a really big surface area to make a lot faster.


00:07:12.400 --> 00:07:15.680
I got speed ups as well to talk about later in the show.


00:07:15.680 --> 00:07:16.520
- Yeah, so I guess--


00:07:16.520 --> 00:07:18.400
- Not that much area, that's awesome.


00:07:18.400 --> 00:07:19.960
- One of the things you bring up,


00:07:19.960 --> 00:07:22.760
which is interesting is that a lot of people,


00:07:22.760 --> 00:07:24.560
I mean, there's tons of people that use Pydantic


00:07:24.560 --> 00:07:28.060
just by itself with their own code.


00:07:28.060 --> 00:07:32.420
But the people that mostly touch it through FastAPI or Beanie


00:07:32.420 --> 00:07:34.180
or something, they may have to wait


00:07:34.180 --> 00:07:38.860
until those projects bring on the changes then,


00:07:38.860 --> 00:07:42.620
unless those projects have branches for V2, which who


00:07:42.620 --> 00:07:43.500
knows.


00:07:43.500 --> 00:07:45.620
Yeah, I hope so.


00:07:45.620 --> 00:07:47.180
And maybe there's a way--


00:07:47.180 --> 00:07:52.180
I think the breaking changes in, say, base model, for example,


00:07:52.180 --> 00:07:55.660
are, I think they're kind of deprecated already.


00:07:55.660 --> 00:07:56.500
- Okay.


00:07:56.500 --> 00:08:00.060
- In 1.10.7, just they're still there, right?


00:08:00.060 --> 00:08:03.600
But I think they become breaking changes here.


00:08:03.600 --> 00:08:09.400
If you're also, if you're doing model validation,


00:08:09.400 --> 00:08:12.120
a lot of the function names gets changed.


00:08:12.120 --> 00:08:16.900
Yeah, like things like from RM go away.


00:08:16.900 --> 00:08:20.000
There's a bunch of little, I don't think they're big changes


00:08:20.000 --> 00:08:21.540
that are gonna be a huge problem for people,


00:08:21.540 --> 00:08:23.900
but they are incompatibilities as you point out.


00:08:23.900 --> 00:08:26.460
With Roman Wright and Sebastian Ramirez


00:08:26.460 --> 00:08:28.900
are seem to be really on top of their projects,


00:08:28.900 --> 00:08:30.660
respectively Beanie and FastAPI.


00:08:30.660 --> 00:08:35.180
So I feel like by the time this becomes fully released,


00:08:35.180 --> 00:08:36.120
they'll be there.


00:08:36.120 --> 00:08:38.180
- Yeah, and what's one of the reasons why I covered


00:08:38.180 --> 00:08:40.860
is to try to like promote everybody.


00:08:40.860 --> 00:08:41.700
- Nudge, nudge, hey, exactly.


00:08:41.700 --> 00:08:42.540
- Nudge, nudge.


00:08:42.540 --> 00:08:43.540
(laughing)


00:08:43.540 --> 00:08:44.380
- Exactly.


00:08:44.380 --> 00:08:45.200
- Please.


00:08:45.200 --> 00:08:46.040
(laughing)


00:08:46.040 --> 00:08:46.860
So, yes.


00:08:46.860 --> 00:08:48.180
- Indeed.


00:08:48.180 --> 00:08:50.060
Yeah, it would be awesome that when this comes out


00:08:50.060 --> 00:08:52.660
for just, boom, V2 is out.


00:08:52.660 --> 00:08:54.860
You just update all the packages that depend upon it.


00:08:54.860 --> 00:08:56.540
And you can adopt it right away.


00:08:56.540 --> 00:08:57.260
That would be great.


00:08:57.260 --> 00:09:01.340
>>To be fair, let's say I'm working on a side project that's


00:09:01.340 --> 00:09:03.820
using FastAPI or Beanie or something,


00:09:03.820 --> 00:09:05.940
and I don't have it in production yet.


00:09:05.940 --> 00:09:09.500
I'd be like, yeah, let's use V2 right away.


00:09:09.500 --> 00:09:11.180
But if I've got a production system,


00:09:11.180 --> 00:09:12.860
I don't want to switch right away.


00:09:12.860 --> 00:09:17.100
So I get that there's projects at different levels.


00:09:17.100 --> 00:09:19.860
And group projects like FastAPI and Beanie


00:09:19.860 --> 00:09:21.860
You have to keep that in mind.


00:09:21.860 --> 00:09:24.860
>> Very cool.


00:09:24.860 --> 00:09:27.180
Well, this is exciting to me.


00:09:27.180 --> 00:09:29.220
I've known this has been coming for a long time,


00:09:29.220 --> 00:09:30.820
so excellent work.


00:09:30.820 --> 00:09:32.660
>> What you got for us?


00:09:32.660 --> 00:09:36.540
>> Well, that's quick real-time follow-up.


00:09:36.540 --> 00:09:38.900
I interviewed Samuel Colvin.


00:09:38.900 --> 00:09:41.160
He loves to do stuff on the 4th of months,


00:09:41.160 --> 00:09:42.940
apparently on August 4th,


00:09:42.940 --> 00:09:47.060
that's last year called Titanic V2, the plan.


00:09:47.060 --> 00:09:50.120
So people can check that out if they're interested.


00:09:50.120 --> 00:09:53.200
Let's talk about something really small, okay?


00:09:53.200 --> 00:09:54.160
- Okay.


00:09:54.160 --> 00:09:56.420
- From a friend of the show, Miguel Grinberg.


00:09:56.420 --> 00:10:00.580
And he created this thing called micro dot.


00:10:00.580 --> 00:10:03.640
Micro dot, it's very small.


00:10:03.640 --> 00:10:07.320
It's bigger even than like the semi dot


00:10:07.320 --> 00:10:09.260
or the regular dot, very small.


00:10:09.260 --> 00:10:11.520
(laughing)


00:10:11.520 --> 00:10:13.640
- It's just quick.


00:10:13.640 --> 00:10:15.340
- Yeah, so back to web frameworks.


00:10:16.380 --> 00:10:18.660
This is the impossibly small web framework


00:10:18.660 --> 00:10:21.340
for Python and MicroPython.


00:10:21.340 --> 00:10:24.900
So I believe its reason for existence


00:10:24.900 --> 00:10:29.580
really is to basically bring something like Flask


00:10:29.580 --> 00:10:32.080
to MicroPython and CircuitPython, which is cool.


00:10:32.080 --> 00:10:36.840
However, it also runs under standard CPython,


00:10:36.840 --> 00:10:39.800
which opens up some interesting possibilities as well.


00:10:39.800 --> 00:10:41.980
- Cool.


00:10:41.980 --> 00:10:45.840
- So if we go down here,


00:10:45.840 --> 00:10:49.840
So if you're familiar with the Flask API,


00:10:49.840 --> 00:10:53.840
you should be real familiar with micro dot.


00:10:53.840 --> 00:10:56.840
So app equals, instead of Flask, you say micro dot.


00:10:56.840 --> 00:10:58.840
Got a function.


00:10:58.840 --> 00:11:01.840
It says I want to do an app dot route on it.


00:11:01.840 --> 00:11:04.840
Or I don't know if he supports a direct verb,


00:11:04.840 --> 00:11:07.840
HTTP verbs there, like app dot get,


00:11:07.840 --> 00:11:10.840
app dot post like Flask adopted recently,


00:11:10.840 --> 00:11:12.840
but app dot route for sure.


00:11:12.840 --> 00:11:18.720
And then one of the differences is you have to pass a request object into the functions there,


00:11:18.720 --> 00:11:24.440
whereas Flask has this thread local ambient variation of this thing.


00:11:24.440 --> 00:11:32.440
So you'll get like a 500 error if you try to, you know, just run this directly without adding that request.


00:11:32.440 --> 00:11:33.440
So it's easy to overlook.


00:11:33.440 --> 00:11:39.640
But other than that, other than the fact that there's a request parameter to the views,


00:11:39.640 --> 00:11:41.640
basically the same thing.


00:11:41.640 --> 00:11:43.000
- Hmm.


00:11:43.000 --> 00:11:45.280
- Okay, so yeah, that's pretty interesting.


00:11:45.280 --> 00:11:49.920
Now, there's a bunch of compromises that are made here


00:11:49.920 --> 00:11:52.800
because MicroPython doesn't support Jinja,


00:11:52.800 --> 00:11:56.080
it doesn't support Flask, all of these different things.


00:11:56.080 --> 00:11:59.600
All right, so there is a template language,


00:11:59.600 --> 00:12:02.320
but it's not Jinja, right?


00:12:02.320 --> 00:12:04.020
So there's a bit of a migration


00:12:04.020 --> 00:12:07.200
if you were going to take this on, right?


00:12:07.200 --> 00:12:09.200
So you can run it under CPython,


00:12:09.200 --> 00:12:12.720
but you can also run it under MicroPython.


00:12:12.720 --> 00:12:15.000
There's the HTTP methods.


00:12:15.000 --> 00:12:17.360
I think you see the old style.


00:12:17.360 --> 00:12:19.960
No, no, there is an app.get.


00:12:19.960 --> 00:12:20.800
You can do the old style


00:12:20.800 --> 00:12:23.000
where you pass the method names like get and post,


00:12:23.000 --> 00:12:24.520
or you can just do an app.get.


00:12:24.520 --> 00:12:29.400
But yeah, again, if you're familiar with Flask,


00:12:29.400 --> 00:12:30.520
the way you do routes,


00:12:30.520 --> 00:12:32.320
the way you pass data into the functions,


00:12:32.320 --> 00:12:35.720
all those things are absolutely the same,


00:12:35.720 --> 00:12:36.760
which is pretty cool.


00:12:38.360 --> 00:12:41.160
One thing you can do is you can return JSON responses


00:12:41.160 --> 00:12:44.900
and you can even just return a dictionary


00:12:44.900 --> 00:12:47.620
which I don't think you can do in Flask.


00:12:47.620 --> 00:12:50.120
Maybe you can, but I think you have to JSONify it.


00:12:50.120 --> 00:12:51.680
I think you gotta say Flask.JSONify.


00:12:51.680 --> 00:12:53.840
So this is kind of an upgrade, I would say.


00:12:53.840 --> 00:12:58.820
So if you have a little tiny thing, like let's see.


00:12:58.820 --> 00:13:03.960
Hold on, let's get it.


00:13:03.960 --> 00:13:06.040
Little tiny thing like this, Brian.


00:13:06.040 --> 00:13:06.960
Okay.


00:13:06.960 --> 00:13:08.660
All right, here, how big is that?


00:13:08.660 --> 00:13:11.180
You know, like, not, about the size of my hand,


00:13:11.180 --> 00:13:14.140
like the half the way across the palm of my hand.


00:13:14.140 --> 00:13:15.580
Got one of these little tiny


00:13:15.580 --> 00:13:17.700
micro Python, circuit Python things.


00:13:17.700 --> 00:13:19.880
You can now put APIs on here,


00:13:19.880 --> 00:13:23.140
and you can put even really interesting things


00:13:23.140 --> 00:13:26.540
like it has support for concurrency.


00:13:26.540 --> 00:13:30.380
So Flask doesn't support directly having async and await,


00:13:30.380 --> 00:13:32.180
I don't believe, not fully anyway.


00:13:32.180 --> 00:13:33.620
You gotta switch over to court to do that.


00:13:33.620 --> 00:13:35.180
I think they partially support it,


00:13:35.180 --> 00:13:37.580
but not full async and await.


00:13:37.580 --> 00:13:42.060
But you can use the MicroPython asyncio extension here


00:13:42.060 --> 00:13:45.700
and get APIs running with full async and await,


00:13:45.700 --> 00:13:50.220
concurrency support, doing JSON or other things.


00:13:50.220 --> 00:13:52.500
Maybe I didn't think, not sure.


00:13:52.500 --> 00:13:53.660
- Pretty cool, 'cause a lot of the,


00:13:53.660 --> 00:13:55.660
I mean, that's just a easy, like,


00:13:55.660 --> 00:13:58.580
throw in a REST API or some sort of API on something


00:13:58.580 --> 00:14:00.360
to throw back JSON to,


00:14:00.360 --> 00:14:04.340
that would be really cool.


00:14:04.340 --> 00:14:06.700
And you don't need, I mean, for applications like that,


00:14:06.700 --> 00:14:08.800
you don't need a lot of templating around.


00:14:08.800 --> 00:14:13.380
- Yeah, and so let's see, go to the core extensions here.


00:14:13.380 --> 00:14:14.780
You can see there's actually a bunch


00:14:14.780 --> 00:14:15.820
of cool core extensions.


00:14:15.820 --> 00:14:17.500
So got the async and await support.


00:14:17.500 --> 00:14:19.220
So all you gotta do is just,


00:14:19.220 --> 00:14:22.220
where am I gonna scroll?


00:14:22.220 --> 00:14:25.980
Just write async def endpoint, right?


00:14:25.980 --> 00:14:27.460
Boom, off it goes.


00:14:27.460 --> 00:14:30.580
- Yeah, 'cause you really wanna async that hello world.


00:14:30.580 --> 00:14:31.940
- Yeah, for hello world, not so much.


00:14:31.940 --> 00:14:33.260
But if you're talking to, you know,


00:14:33.260 --> 00:14:34.980
files like similar database or something.


00:14:34.980 --> 00:14:36.460
- Yeah, that's true.


00:14:36.460 --> 00:14:38.620
- You can use, what is that, micro template?


00:14:38.620 --> 00:14:41.260
It says uTemplate, but I bet it's a micro.


00:14:41.260 --> 00:14:44.700
- I think it's pronounced template.


00:14:44.700 --> 00:14:47.260
- Template, yeah, uTemplate.


00:14:47.260 --> 00:14:52.600
It's a lightweight and memory efficient template for Python,


00:14:52.600 --> 00:14:58.540
which it looks very, very Jinja-like as well.


00:14:58.540 --> 00:15:00.260
So that's a pretty straightforward thing,


00:15:00.260 --> 00:15:02.140
but it's not identical, right?


00:15:02.140 --> 00:15:02.980
What else we got?


00:15:02.980 --> 00:15:05.740
- Ooh, this is Jinja, isn't it?


00:15:05.740 --> 00:15:06.980
- Oh, can you?


00:15:06.980 --> 00:15:09.640
(Jesse humming)


00:15:09.640 --> 00:15:12.820
But no, hold on, it's CPython only.


00:15:12.820 --> 00:15:14.620
- Oh, okay, okay, got it.


00:15:14.620 --> 00:15:17.100
- So, 'cause it's not supported in MicroPython.


00:15:17.100 --> 00:15:19.860
- Got it, but if you're doing it on CPython,


00:15:19.860 --> 00:15:22.060
you can add those templates.


00:15:22.060 --> 00:15:24.540
- Yes, this is actually why it's pretty interesting to me.


00:15:24.540 --> 00:15:29.540
So you can do TLS, HTTPS support, right,


00:15:29.540 --> 00:15:31.520
which is pretty cool.


00:15:31.520 --> 00:15:34.220
You have WebSockets, you have asynchronous WebSockets,


00:15:34.220 --> 00:15:39.100
you have cores, cross-origin, resource sharing settings,


00:15:39.100 --> 00:15:41.020
and you can even deploy it.


00:15:41.020 --> 00:15:43.120
So it comes with its own little web server,


00:15:43.120 --> 00:15:47.840
which you can run on your MicroPython DLE, right?


00:15:47.840 --> 00:15:50.580
But if you were gonna put this into a big data center


00:15:50.580 --> 00:15:53.000
on a huge rack of servers,


00:15:53.000 --> 00:15:55.140
that might not be the best choice.


00:15:55.140 --> 00:15:58.180
So you can run it on MicroWSGI, which is awesome.


00:15:58.180 --> 00:16:00.220
You can run it on G-Unicorn.


00:16:00.220 --> 00:16:05.220
You can even run it on GUnicorn with UVicorn workers


00:16:05.220 --> 00:16:10.580
to get like the awesome libUV high performance


00:16:10.580 --> 00:16:12.200
async support, right?


00:16:12.200 --> 00:16:16.840
So you can deploy it onto kind of the top tier Python stuff,


00:16:16.840 --> 00:16:20.420
put, you know, Nginx in front of it and all that.


00:16:20.420 --> 00:16:21.340
It's pretty cool, right?


00:16:21.340 --> 00:16:22.620
- Yeah.


00:16:22.620 --> 00:16:27.620
- Now, what are the ways you run web apps on servers,


00:16:27.620 --> 00:16:28.860
especially in Python,


00:16:28.860 --> 00:16:33.500
because of the threading support is not as friction-free,


00:16:33.500 --> 00:16:35.380
I guess, like the GIL and all that,


00:16:35.380 --> 00:16:39.380
is you'll farm it out into multiple workers, right?


00:16:39.380 --> 00:16:42.340
So I can't remember what we have for Python bytes,


00:16:42.340 --> 00:16:46.820
not too many, like two or four different worker processes.


00:16:46.820 --> 00:16:49.300
And each of the worker processes


00:16:49.300 --> 00:16:52.620
kind of gets round-robin brought in to handle a request.


00:16:52.620 --> 00:16:54.460
So like if one of them is busy,


00:16:54.460 --> 00:16:57.580
it'll automatically send the request over to another one.


00:16:58.820 --> 00:17:01.940
Now, usually there's maybe a couple of limits,


00:17:01.940 --> 00:17:04.140
but one of the limits you really wanna consider is,


00:17:04.140 --> 00:17:06.220
I don't wanna run the machine out of memory.


00:17:06.220 --> 00:17:09.900
So I think the ones we use like 150 megs per worker process.


00:17:09.900 --> 00:17:12.180
So at some point you can only create so many


00:17:12.180 --> 00:17:15.660
and then the servers like, okay, I've had it.


00:17:15.660 --> 00:17:18.060
But with this little thing that runs on MicroPython,


00:17:18.060 --> 00:17:19.500
you could scale the heck out of it.


00:17:19.500 --> 00:17:23.220
You could have a ton of worker processes under MicroWSGI.


00:17:23.220 --> 00:17:24.360
- Oh yeah.


00:17:24.360 --> 00:17:27.820
- Or under UVicorn, right?


00:17:27.820 --> 00:17:31.340
And I actually did a little super simple test.


00:17:31.340 --> 00:17:34.720
Like I wrote the Flask equivalent of hello world,


00:17:34.720 --> 00:17:36.100
literally exactly the same code


00:17:36.100 --> 00:17:37.620
with the changes I talked about.


00:17:37.620 --> 00:17:39.540
And then the micro Python version,


00:17:39.540 --> 00:17:42.820
the sorry, the micro dot version.


00:17:42.820 --> 00:17:47.140
And that one, both running on CPython,


00:17:47.140 --> 00:17:49.780
nine megs for this framework,


00:17:49.780 --> 00:17:52.020
25 megs for the Flask framework.


00:17:52.020 --> 00:17:55.820
So maybe you can have twice as much processing


00:17:57.620 --> 00:18:01.860
horizontal scale with this thing, but deployed to real servers.


00:18:01.860 --> 00:18:05.620
So there might actually be some interesting advantages to having


00:18:05.620 --> 00:18:07.220
this like really tight framework.


00:18:07.220 --> 00:18:10.100
Like I want to run it in a bunch of Docker containers that are like


00:18:10.100 --> 00:18:11.660
using the smallest amount of memory.


00:18:11.660 --> 00:18:15.500
I want to farm it out and say, no, I'll have 30 worker processes on the server.


00:18:15.500 --> 00:18:16.340
Not five.


00:18:16.340 --> 00:18:17.260
I don't know.


00:18:17.260 --> 00:18:18.180
Yeah.


00:18:18.180 --> 00:18:21.060
Yeah.


00:18:21.060 --> 00:18:25.220
Oh, Pample is pretty psyched about the memory saving out there as well.


00:18:25.220 --> 00:18:27.620
So I think it's good.


00:18:27.620 --> 00:18:28.820
Yeah.


00:18:28.820 --> 00:18:31.120
And I mean, for lots of jobs where you don't need


00:18:31.120 --> 00:18:33.620
if you don't need the power, don't use the power.


00:18:33.620 --> 00:18:35.920
So, yeah, yeah, pretty neat.


00:18:35.920 --> 00:18:38.620
So well done, well, and yeah.


00:18:38.620 --> 00:18:40.520
Over to you.


00:18:40.520 --> 00:18:41.820
What's your next one?


00:18:41.820 --> 00:18:43.820
I want to talk about GitHub actions a bit.


00:18:43.820 --> 00:18:47.220
So a lot of my workflows have moved over to GitHub actions.


00:18:47.220 --> 00:18:51.680
And so there's actually three projects that I wanted to talk about


00:18:51.680 --> 00:18:53.560
that I thought were neat and worth.


00:18:53.560 --> 00:18:56.840
and they're all kind of in the GitHub action genre.


00:18:56.840 --> 00:18:57.720
>> Whatchka.


00:18:57.720 --> 00:19:01.040
>> Whatchka. What you got first?


00:19:01.040 --> 00:19:07.040
WatchGHA, it comes from Ned Batchelder.


00:19:07.040 --> 00:19:10.760
This is just a simple tool


00:19:10.760 --> 00:19:15.880
to watch your GitHub action progress from a command line.


00:19:15.880 --> 00:19:20.480
I think it's a command line thing, looks like command line.


00:19:20.480 --> 00:19:23.260
And so it looks, so you can,


00:19:23.260 --> 00:19:25.020
it has like a little progress bar thing,


00:19:25.020 --> 00:19:28.500
progress dots that go green and then they start out gray


00:19:28.500 --> 00:19:31.260
and then they go white and green and stuff


00:19:31.260 --> 00:19:33.300
to see the different things.


00:19:33.300 --> 00:19:37.700
You got like, we were running 3.7 on Ubuntu, 5.8.


00:19:37.700 --> 00:19:41.380
So if you've got a big matrix that's doing a lot of stuff,


00:19:41.380 --> 00:19:43.520
it's kind of hard to keep up with what all is going on.


00:19:43.520 --> 00:19:46.220
So this is kind of neat to watch,


00:19:46.220 --> 00:19:48.100
just a little tool from Ned.


00:19:48.100 --> 00:19:48.940
Thanks, Ned.


00:19:48.940 --> 00:19:53.540
One of the other things I was thinking about,


00:19:53.540 --> 00:19:57.420
so I just, my talk at PyCascades was talking about


00:19:57.420 --> 00:20:01.500
that you can share, you can just,


00:20:01.500 --> 00:20:05.100
you can share packages without actually ever building it


00:20:05.100 --> 00:20:07.540
because pip install will build your wheel for you


00:20:07.540 --> 00:20:09.380
if it's not built already.


00:20:09.380 --> 00:20:12.540
But you probably should test that.


00:20:12.540 --> 00:20:15.100
And one of the ways you can test some of that building


00:20:15.100 --> 00:20:20.100
is with Hinix build and inspect Python package.


00:20:20.100 --> 00:20:22.160
- Oh, cool.


00:20:22.160 --> 00:20:27.160
- So this is a GitHub action that will,


00:20:27.160 --> 00:20:28.240
it does a lot of stuff,


00:20:28.240 --> 00:20:31.800
but it does a build to make sure the build works.


00:20:31.800 --> 00:20:36.800
It also has a linter to lint the wheel contents.


00:20:36.800 --> 00:20:40.200
It also uploads the wheel and the source distribution


00:20:40.200 --> 00:20:41.880
as GitHub action artifacts.


00:20:41.880 --> 00:20:45.160
So it actually does generate the wheel for you


00:20:45.160 --> 00:20:48.020
as an artifact, which is kind of neat.


00:20:48.020 --> 00:20:52.120
The, it also, one of the things that's,


00:20:52.120 --> 00:20:53.680
one of the things that's always a mystery to me


00:20:53.680 --> 00:20:57.080
is like the, making sure I have everything that I want


00:20:57.080 --> 00:21:00.040
in the SDist, the source distribution,


00:21:00.040 --> 00:21:03.760
and this will lint that and also,


00:21:03.760 --> 00:21:06.840
well, I guess it doesn't lint the contents of the SDist,


00:21:06.840 --> 00:21:07.840
but it does print them out.


00:21:07.840 --> 00:21:11.160
So print does a tree of the SDist and the wheel


00:21:11.160 --> 00:21:14.120
in the output so that you don't have to download it


00:21:14.120 --> 00:21:16.120
to check it, you can just look at it.


00:21:16.120 --> 00:21:17.800
- That's cool.


00:21:17.800 --> 00:21:19.800
Make sure all the files and resources


00:21:19.800 --> 00:21:21.880
you might need to send out come along.


00:21:21.880 --> 00:21:24.920
- Yeah, and this, yeah,


00:21:24.920 --> 00:21:28.480
I had recently made a change to a package


00:21:28.480 --> 00:21:31.360
and it took out the tests and I had somebody say,


00:21:31.360 --> 00:21:33.680
oh, look, we want the tests back in.


00:21:33.680 --> 00:21:35.080
So it's kind of nice.


00:21:37.080 --> 00:21:41.760
So let's, I guess that's it with that.


00:21:41.760 --> 00:21:44.920
It's kind of a neat GitHub action thing


00:21:44.920 --> 00:21:48.120
that you just put it in.


00:21:48.120 --> 00:21:49.080
It's one of those actions.


00:21:49.080 --> 00:21:51.320
So you just like specify it and it just works.


00:21:51.320 --> 00:21:52.160
It's nice.


00:21:52.160 --> 00:21:56.160
The third thing I wanted to bring up was


00:21:56.160 --> 00:22:00.460
pytest GitHub actions annotate failures.


00:22:00.460 --> 00:22:05.240
So this is a, just a nice extra thing


00:22:05.240 --> 00:22:07.380
that I hadn't heard about before.


00:22:07.380 --> 00:22:12.120
pytest, it's under the pytest dev umbrella,


00:22:12.120 --> 00:22:15.640
but it's a pip install sort of thing.


00:22:15.640 --> 00:22:17.440
And what it does is it makes sure


00:22:17.440 --> 00:22:21.040
that all the proper stuff gets output


00:22:21.040 --> 00:22:24.120
so that you can have nice annotated,


00:22:24.120 --> 00:22:28.320
if there's failures, it's annotated nicely


00:22:28.320 --> 00:22:29.800
in GitHub Actions.


00:22:29.800 --> 00:22:30.620
That's it.


00:22:30.620 --> 00:22:34.440
Just some fun GitHub Action stuff.


00:22:34.440 --> 00:22:38.000
- Yeah, once you really start getting into CI/CD,


00:22:38.000 --> 00:22:39.520
it's fun and you're just like,


00:22:39.520 --> 00:22:41.440
oh, and now that it's automated, we could do this,


00:22:41.440 --> 00:22:43.120
so we could do that.


00:22:43.120 --> 00:22:45.880
- Yeah, and then, but when you automate all the things


00:22:45.880 --> 00:22:47.660
and then when things go wrong, you're like,


00:22:47.660 --> 00:22:50.040
oh God, then we have to pull it down and check it again.


00:22:50.040 --> 00:22:52.880
But having, so having some of these debug stuff


00:22:52.880 --> 00:22:56.000
and things up in the cloud is good.


00:22:56.000 --> 00:22:57.000
- Yeah, very handy.


00:22:57.000 --> 00:23:02.560
Excellent, all right, well, I have a PEP for us to discuss.


00:23:02.560 --> 00:23:03.560
- Okay.


00:23:03.560 --> 00:23:07.360
709, inlined comprehensions.


00:23:07.360 --> 00:23:12.360
Now, this is a debate that I seem to have only on YouTube.


00:23:12.360 --> 00:23:19.000
If I'll do, like I've done some videos


00:23:19.000 --> 00:23:23.000
about list comprehensions or other sort of design patterns,


00:23:23.000 --> 00:23:26.000
you might involve comprehensions and people are like,


00:23:26.000 --> 00:23:28.880
oh, Michael, you said that a for loop


00:23:28.880 --> 00:23:30.880
is different than a list comprehension,


00:23:30.880 --> 00:23:33.320
but look, it says for thing in collection.


00:23:33.320 --> 00:23:34.400
And so they're the same.


00:23:34.400 --> 00:23:37.200
And so I just don't, you just don't know what you're talking about.


00:23:37.200 --> 00:23:39.040
Like, you know what, let's disassemble it.


00:23:39.040 --> 00:23:40.480
Let's see what it does.


00:23:40.480 --> 00:23:41.880
Is it the same disassembly?


00:23:41.880 --> 00:23:44.280
No, it's completely different disassembly.


00:23:44.280 --> 00:23:47.280
That means the implementation of this comprehension, they're different.


00:23:47.280 --> 00:23:49.200
I don't care if the word for appears in both of them.


00:23:49.200 --> 00:23:50.280
They're not the same thing.


00:23:50.280 --> 00:23:57.120
This PEP brings them kind of tries to take the both the best of both worlds though.


00:23:57.120 --> 00:24:00.720
And it says, there are some things we do to make


00:24:00.720 --> 00:24:04.360
comprehensions work, but look like they're just right there


00:24:04.360 --> 00:24:07.480
in the same function or in line, even if you don't have


00:24:07.480 --> 00:24:10.760
a function, but in fact, there's kind of this,


00:24:10.760 --> 00:24:13.320
this thing behind the scenes is happening where we create


00:24:13.320 --> 00:24:16.960
a nested function that you never see, but the interpreter


00:24:16.960 --> 00:24:20.720
creates and then calls it and that's the interpreter.


00:24:20.720 --> 00:24:21.560
Okay.


00:24:21.560 --> 00:24:23.820
That's the comprehension rather.


00:24:23.820 --> 00:24:28.820
So this PEP by Karl Meyer is basically saying


00:24:28.820 --> 00:24:34.080
we could get really good performance increases


00:24:34.080 --> 00:24:36.980
if we just change that implementation a little.


00:24:36.980 --> 00:24:40.280
And the reason it's created as a nested function


00:24:40.280 --> 00:24:42.560
and not just some inline code is,


00:24:42.560 --> 00:24:47.420
what if you have a variable X in your regular function,


00:24:47.420 --> 00:24:50.740
and then you have X as a loop variable


00:24:50.740 --> 00:24:53.500
or as the item variable in your comprehension


00:24:53.500 --> 00:24:54.340
or things like that, right?


00:24:54.340 --> 00:24:56.700
You want them to still be isolated.


00:24:56.700 --> 00:25:00.300
So that's basically the idea here.


00:25:00.300 --> 00:25:02.100
It says, "Comprehensions are currently compiled


00:25:02.100 --> 00:25:04.620
"as nested functions, which provides isolation


00:25:04.620 --> 00:25:06.940
"of the comprehension's iteration variable,


00:25:06.940 --> 00:25:09.400
"but is inefficient at runtime."


00:25:09.400 --> 00:25:13.780
So pep709 proposes to inline list dictionary


00:25:13.780 --> 00:25:15.720
and set comprehensions into the code


00:25:15.720 --> 00:25:20.020
where they are defined and provide the expected isolation


00:25:20.020 --> 00:25:22.680
by looking at all the variables,


00:25:22.680 --> 00:25:27.680
creating a copy of them, running this in place.


00:25:27.680 --> 00:25:30.680
And then if there was a variable for that loop variable,


00:25:30.680 --> 00:25:32.680
just put the old value back.


00:25:32.680 --> 00:25:34.600
I kind of push and pop them there.


00:25:34.600 --> 00:25:39.240
And the benefits here are up to two times as fast


00:25:39.240 --> 00:25:43.200
as comprehensions are today.


00:25:43.200 --> 00:25:48.120
So then they said, this is translating to an 11% speed up


00:25:48.120 --> 00:25:50.960
in one sample benchmark derived from real world code


00:25:50.960 --> 00:25:52.680
that makes heavy use of comprehensions


00:25:52.680 --> 00:25:55.240
in the context of doing actual work.


00:25:55.240 --> 00:25:56.340
That's pretty cool, right?


00:25:56.340 --> 00:25:57.720
- Yeah.


00:25:57.720 --> 00:26:00.280
- I believe comprehensions were in general,


00:26:00.280 --> 00:26:02.420
slightly faster than for loops


00:26:02.420 --> 00:26:05.680
that would just do something and put it in a list.


00:26:05.680 --> 00:26:09.440
So making it two times faster still is even better.


00:26:09.440 --> 00:26:12.200
So this gets adopted, it's in draft form right now.


00:26:12.200 --> 00:26:15.040
I can go back to my YouTube comments


00:26:15.040 --> 00:26:17.360
and have even further nuanced discussions


00:26:17.360 --> 00:26:20.320
about like, here's yet again,


00:26:20.320 --> 00:26:22.920
how they are not the same thing, but they look similar.


00:26:22.920 --> 00:26:25.680
So let's, yeah.


00:26:25.680 --> 00:26:28.280
- I never would have thought that


00:26:28.280 --> 00:26:31.680
I should reuse a variable in a comprehension though.


00:26:31.680 --> 00:26:34.720
I don't do that, but I guess.


00:26:34.720 --> 00:26:36.700
- No, I think it's like,


00:26:36.700 --> 00:26:41.040
if let's say you've got two less comprehensions,


00:26:41.040 --> 00:26:45.240
you know, X squared for X in first set,


00:26:47.000 --> 00:26:50.780
than 2x plus 1 for x in other sets.


00:26:50.780 --> 00:26:52.580
Those are two separate list comprehensions.


00:26:52.580 --> 00:26:56.160
You don't want one of those variables, too.


00:26:56.160 --> 00:26:57.040
You want to keep them--


00:26:57.040 --> 00:27:01.240
they want to be like, OK, this x is only for this comprehension.


00:27:01.240 --> 00:27:02.280
That's what it's like.


00:27:02.280 --> 00:27:04.200
So if you have an embedded comprehension,


00:27:04.200 --> 00:27:06.000
you might use x in both places.


00:27:06.000 --> 00:27:08.600
Right, or if you have an x and y equals something,


00:27:08.600 --> 00:27:10.120
and then you generate a comprehension,


00:27:10.120 --> 00:27:11.120
you say x in there.


00:27:11.120 --> 00:27:13.320
There's a couple of--


00:27:13.320 --> 00:27:14.720
Yeah.


00:27:14.720 --> 00:27:17.560
I mean, I guess I was just thinking my own style.


00:27:17.560 --> 00:27:19.360
The second one I would never do.


00:27:19.360 --> 00:27:21.480
If I was already using X, I probably


00:27:21.480 --> 00:27:23.280
wouldn't use X in the comprehension.


00:27:23.280 --> 00:27:29.560
But I'll often use I or X in a comprehension in embedded ones


00:27:29.560 --> 00:27:30.840
and don't even think about it.


00:27:30.840 --> 00:27:33.000
So yeah, interesting.


00:27:33.000 --> 00:27:33.500
Cool.


00:27:33.500 --> 00:27:34.280
Yeah.


00:27:34.280 --> 00:27:36.800
David Poole says, I'm sure there's good reasons for it,


00:27:36.800 --> 00:27:39.320
but I wonder why comprehensions don't use name mingling


00:27:39.320 --> 00:27:42.800
strategies for their var names.


00:27:42.800 --> 00:27:45.400
Everyone's got to be named underscore, underscore X.


00:27:45.400 --> 00:27:47.660
(laughing)


00:27:47.660 --> 00:27:50.840
- That reminds me of a joke.


00:27:50.840 --> 00:27:53.440
- Well, so what it's doing now is it basically says,


00:27:53.440 --> 00:27:59.480
we're going to create a function


00:27:59.480 --> 00:28:02.240
and so that variables are basically a local variable,


00:28:02.240 --> 00:28:05.880
that function, which has no influence on it.


00:28:05.880 --> 00:28:08.320
Were you gonna actually tell us the joke?


00:28:08.320 --> 00:28:09.800
(laughing)


00:28:09.800 --> 00:28:11.240
- No, I was gonna wait.


00:28:11.240 --> 00:28:12.080
- Okay, all right.


00:28:12.080 --> 00:28:14.080
Or should we do it now?


00:28:14.080 --> 00:28:20.080
I think it was Ned Batchelder actually that mentioned that Dunder,


00:28:20.080 --> 00:28:25.080
we often talk about Dunder and Nit instead of double underscore and it,


00:28:25.080 --> 00:28:29.080
but it's really underscore, underscore, and it underscore, underscore.


00:28:29.080 --> 00:28:32.080
So it's really quunder.


00:28:32.080 --> 00:28:33.080
Quunder.


00:28:33.080 --> 00:28:37.080
And so I responded to him and said, "I don't think so.


00:28:37.080 --> 00:28:41.080
I think it's Dunder and Nit Dunder is what it should be."


00:28:41.080 --> 00:28:44.440
But that would be redundant.


00:28:44.440 --> 00:28:47.980
- It's pretty bad.


00:28:47.980 --> 00:28:50.100
That's pretty much on par with the joke we got at the end.


00:28:50.100 --> 00:28:52.220
So, all right.


00:28:52.220 --> 00:28:54.900
So if one, basically the way to understand this,


00:28:54.900 --> 00:28:57.260
you can't look at the code and tell, right?


00:28:57.260 --> 00:28:59.700
Which is why people incorrectly


00:28:59.700 --> 00:29:01.820
try to correct me on YouTube.


00:29:01.820 --> 00:29:04.100
So you look at the code and it looks like,


00:29:04.100 --> 00:29:05.060
oh, it's just a four lists.


00:29:05.060 --> 00:29:07.300
And we took out the line breaks and put brackets.


00:29:07.300 --> 00:29:08.460
So it's the same thing.


00:29:09.820 --> 00:29:11.780
So if you look at it now, you can see,


00:29:11.780 --> 00:29:15.340
if you create a function that creates a list comprehension,


00:29:15.340 --> 00:29:20.740
you'll see it creates what's called a code object


00:29:20.740 --> 00:29:24.660
of type list comprehension, then it calls make function,


00:29:24.660 --> 00:29:26.580
then it loads the list,


00:29:26.580 --> 00:29:28.980
and then it does a bunch of stuff on it.


00:29:28.980 --> 00:29:30.820
And then it actually, you can see there's like


00:29:30.820 --> 00:29:32.540
this sub function that gets disassembled,


00:29:32.540 --> 00:29:33.940
and it says, we're gonna build a list,


00:29:33.940 --> 00:29:36.460
load fast, iterate it, list append,


00:29:36.460 --> 00:29:37.420
and what's really interesting,


00:29:37.420 --> 00:29:40.140
This is the part that differs from for loops.


00:29:40.140 --> 00:29:43.780
There's a byte code called list_append.


00:29:43.780 --> 00:29:46.460
If you do this with a for loop where you have a list


00:29:46.460 --> 00:29:48.780
and you call append, it loads the function append


00:29:48.780 --> 00:29:50.900
and then calls append on the operands.


00:29:50.900 --> 00:29:54.740
But it's not in the runtime in a for loop.


00:29:54.740 --> 00:29:57.380
In a comprehension, there's a special byte code that runs.


00:29:57.380 --> 00:30:01.260
And that's the primary difference.


00:30:01.260 --> 00:30:03.900
But the drawback-- so the benefit


00:30:03.900 --> 00:30:07.800
is list append is a byte code operation, not a function call.


00:30:07.800 --> 00:30:10.300
But the drawback is there's this object created,


00:30:10.300 --> 00:30:12.620
there's a stack frame created, there's a function call


00:30:12.620 --> 00:30:14.380
over to this comprehension call.


00:30:14.380 --> 00:30:17.260
There's an issue with all that stuff, right?


00:30:17.260 --> 00:30:19.420
So the new one just says, what we're gonna do


00:30:19.420 --> 00:30:22.260
is we're gonna create a new opcode


00:30:22.260 --> 00:30:26.060
called load fast and clear, which is like,


00:30:26.060 --> 00:30:27.220
I'm gonna load the variable x


00:30:27.220 --> 00:30:29.060
and if there was one of those before,


00:30:29.060 --> 00:30:33.700
we're going to hang on to that just in case.


00:30:33.700 --> 00:30:35.700
so we can put it back to avoid that.


00:30:35.700 --> 00:30:39.380
And then it calls buildList, and you can notice there's no...


00:30:39.380 --> 00:30:44.780
There's no function call, so no stack frame,


00:30:44.780 --> 00:30:47.780
no extra function call, there's no list comprehension object,


00:30:47.780 --> 00:30:52.860
all those things. And so this is the new bytecode operation


00:30:52.860 --> 00:30:55.740
that manages that variable isolation,


00:30:55.740 --> 00:30:58.460
and then you just do it directly, which saves you a bunch.


00:30:58.460 --> 00:31:00.460
We talked about the 2x speed there.


00:31:01.620 --> 00:31:03.860
So that's the pep.


00:31:03.860 --> 00:31:05.540
People check it out, see what you think.


00:31:05.540 --> 00:31:06.860
>> That's really interesting, Michael,


00:31:06.860 --> 00:31:09.460
but you had me at it's faster.


00:31:09.460 --> 00:31:12.900
>> I know exactly. I just want people to know


00:31:12.900 --> 00:31:15.780
what's happening and why it might be faster and so on.


00:31:15.780 --> 00:31:18.420
So pretty neat.


00:31:18.420 --> 00:31:25.020
You can see it does have the only possible,


00:31:25.020 --> 00:31:26.820
I guess, concern.


00:31:26.820 --> 00:31:28.460
The reason they say, why is this even a pep?


00:31:28.460 --> 00:31:30.300
Why is this not just, hey, I made it faster.


00:31:30.300 --> 00:31:32.540
Like, why do we need to discuss this?


00:31:32.540 --> 00:31:33.380
- Yeah.


00:31:33.380 --> 00:31:34.380
- 'Cause like you said, Brian, like it's faster.


00:31:34.380 --> 00:31:35.880
We're done, let's go.


00:31:35.880 --> 00:31:39.300
Is there are user observable changes


00:31:39.300 --> 00:31:42.900
if the user doesn't like themselves, basically?


00:31:42.900 --> 00:31:48.420
For example, why would a user return locals


00:31:48.420 --> 00:31:51.060
as the item you want put into a list


00:31:51.060 --> 00:31:52.580
during a list comprehension?


00:31:52.580 --> 00:31:54.000
Well, if you did do that,


00:31:54.000 --> 00:31:57.380
you would see that it's not the same as before.


00:31:58.580 --> 00:32:02.460
I have no idea why you would ever try to do that,


00:32:02.460 --> 00:32:05.260
but that technically would be a breaking change.


00:32:05.260 --> 00:32:08.060
The other one, slightly more valid perhaps,


00:32:08.060 --> 00:32:10.540
is that if there's an exception inside


00:32:10.540 --> 00:32:12.900
the list comprehension,


00:32:12.900 --> 00:32:15.460
because it used to be in a separate function call,


00:32:15.460 --> 00:32:21.740
it would show up in the actual trace back call stack.


00:32:21.740 --> 00:32:25.500
But now you are not in another function,


00:32:25.500 --> 00:32:30.500
it's on a line in the OG function.


00:32:30.500 --> 00:32:34.260
So you don't have that.


00:32:34.260 --> 00:32:37.180
Basically it's missing from there.


00:32:37.180 --> 00:32:39.460
So you would have a slightly different traceback exception.


00:32:39.460 --> 00:32:43.700
The exception would be the same, but the traceback call stack listing would be different.


00:32:43.700 --> 00:32:49.780
That potentially affects somebody, but not a lot.


00:32:49.780 --> 00:32:54.940
I don't know.


00:32:51.260 --> 00:32:52.780
It's a two X, it's a trade off.


00:32:52.780 --> 00:32:55.220
I would totally think it's worth taking.


00:32:55.220 --> 00:32:57.120
- Yeah, but I see why that's a,


00:32:57.120 --> 00:33:01.860
it's a observable interface or an observable behavior change.


00:33:01.860 --> 00:33:02.700
So yeah.


00:33:02.700 --> 00:33:04.140
- Yeah, yeah.


00:33:04.140 --> 00:33:06.340
- Although I learned from Brett Cannon


00:33:06.340 --> 00:33:08.580
just a couple of weeks ago that


00:33:08.580 --> 00:33:10.700
locals often has weird stuff in it.


00:33:10.700 --> 00:33:12.180
If you look at locals a lot,


00:33:12.180 --> 00:33:15.460
sometimes there's stuff in there that you don't recognize.


00:33:15.460 --> 00:33:16.660
- Interesting.


00:33:16.660 --> 00:33:19.500
Yeah, the locals one seems like, you know what?


00:33:20.740 --> 00:33:21.580
- Don't do that.


00:33:21.580 --> 00:33:25.140
But the trace back one, I can see, okay,


00:33:25.140 --> 00:33:26.340
we're always looking for this.


00:33:26.340 --> 00:33:27.740
And like, if I get an error,


00:33:27.740 --> 00:33:29.240
I try to like look at the trace back


00:33:29.240 --> 00:33:30.860
to figure out what to tell people.


00:33:30.860 --> 00:33:34.700
Or I don't, theoretically, could have,


00:33:34.700 --> 00:33:36.260
it still seems unlikely.


00:33:36.260 --> 00:33:40.980
I feel like you shouldn't depend upon what's listed there,


00:33:40.980 --> 00:33:42.820
but I'm sure somebody does somewhere.


00:33:42.820 --> 00:33:46.860
- Well, like ID makers and things like that.


00:33:46.860 --> 00:33:49.980
- Yeah, yeah, cool.


00:33:49.980 --> 00:33:52.980
That's it for all of our items.


00:33:52.980 --> 00:33:55.400
You got any extras?


00:33:55.400 --> 00:33:57.820
I don't. Do you?


00:33:57.820 --> 00:33:59.820
I thought I didn't have any extras.


00:33:59.820 --> 00:34:03.220
I think by the time... I'm going to try to predict the future a little bit


00:34:03.220 --> 00:34:05.220
because I have some control over it.


00:34:05.220 --> 00:34:07.220
I do have an extra.


00:34:07.220 --> 00:34:10.580
I'm going to be releasing either today or tomorrow.


00:34:10.580 --> 00:34:12.580
By the time this podcast comes out,


00:34:12.580 --> 00:34:15.540
this is going to be released.


00:34:15.540 --> 00:34:18.540
But if you're watching it live, it's not yet released.


00:34:18.540 --> 00:34:21.940
So I'm going to be releasing a new course, Python Web Apps


00:34:21.940 --> 00:34:23.180
that Fly with CDNs.


00:34:23.180 --> 00:34:25.020
This is just over a three-hour course


00:34:25.020 --> 00:34:28.780
that's all about taking CDNs and applying them


00:34:28.780 --> 00:34:33.500
to Flask web apps, and also hosting video content


00:34:33.500 --> 00:34:36.780
and large files, and how do you geo-replicate that.


00:34:36.780 --> 00:34:38.740
We use a lot of these techniques in Python Bytes


00:34:38.740 --> 00:34:41.580
to make the website faster, as well as


00:34:41.580 --> 00:34:47.060
to deliver terabytes of MP3s to people.


00:34:47.060 --> 00:34:49.260
So check that out.


00:34:49.260 --> 00:34:51.100
I will put a link in the show notes.


00:34:51.100 --> 00:34:53.140
Again, if you're listening live, this is not out yet,


00:34:53.140 --> 00:34:56.420
but it will be out by the time the MP3


00:34:56.420 --> 00:34:57.660
hits your podcast player.


00:34:57.660 --> 00:34:59.420
So if you have the audio only version,


00:34:59.420 --> 00:35:01.460
go check it out, link's in the show notes.


00:35:01.460 --> 00:35:02.300
- Nice.


00:35:02.300 --> 00:35:05.180
- Yeah, I think that's a really, really cool course.


00:35:05.180 --> 00:35:07.980
I think there's so much people can get out of it


00:35:07.980 --> 00:35:10.580
in terms of like, it's really easy, you know,


00:35:10.580 --> 00:35:13.540
30 minutes and you're like, oh, our app is so much faster


00:35:13.540 --> 00:35:15.860
and we can use smaller servers.


00:35:15.860 --> 00:35:16.940
That's really great.


00:35:16.940 --> 00:35:20.040
Well, three hours plus 30 minutes.


00:35:20.040 --> 00:35:22.320
- Yes, well, once you know the thing,


00:35:22.320 --> 00:35:24.040
it's probably 30 minutes to apply to your app.


00:35:24.040 --> 00:35:24.880
That's what I mean.


00:35:24.880 --> 00:35:26.520
Yeah.


00:35:26.520 --> 00:35:28.840
David Poole says, "The traceback one could be worked around


00:35:28.840 --> 00:35:33.080
"if the debug compiled used the old function style method,


00:35:33.080 --> 00:35:35.160
"like aggressive optimizations in GCC


00:35:35.160 --> 00:35:36.840
"with inline functions."


00:35:36.840 --> 00:35:39.360
Okay, possibly, interesting.


00:35:39.360 --> 00:35:43.800
You'd have to have people buy into that, but right.


00:35:43.800 --> 00:35:46.680
I mean, I'm sure Brian, you're very well aware


00:35:46.680 --> 00:35:50.720
of the debug versus release builds and optimization levels


00:35:50.720 --> 00:35:53.120
and all that stuff in C, right?


00:35:53.120 --> 00:35:56.040
- No, I mean, yes, but I don't use them.


00:35:56.040 --> 00:35:58.160
- No, you don't need that.


00:35:58.160 --> 00:36:03.160
- Well, I personally don't like to test


00:36:03.160 --> 00:36:05.440
in something my user isn't gonna see.


00:36:05.440 --> 00:36:09.020
So I always test in optimized released.


00:36:09.020 --> 00:36:10.400
- Got it, yeah, yeah.


00:36:10.400 --> 00:36:12.240
But it can make a big difference.


00:36:12.240 --> 00:36:13.720
But in the Python world,


00:36:13.720 --> 00:36:17.320
we don't really discuss that so much, right?


00:36:17.320 --> 00:36:19.880
- Yeah, and except for the comment,


00:36:19.880 --> 00:36:22.240
the one thing to be aware of that I would,


00:36:22.240 --> 00:36:23.400
while we're on it,


00:36:23.400 --> 00:36:25.720
we probably haven't mentioned this lately,


00:36:25.720 --> 00:36:28.300
is asserts are awesome in your test code,


00:36:28.300 --> 00:36:30.800
but they're not that great in your,


00:36:30.800 --> 00:36:33.680
actually, they're pretty great in your function code also,


00:36:33.680 --> 00:36:35.680
but just don't depend on it,


00:36:35.680 --> 00:36:38.520
because assert lines can be completely removed


00:36:38.520 --> 00:36:41.600
if you have the optimization on, so.


00:36:41.600 --> 00:36:42.440
- Absolutely.


00:36:42.440 --> 00:36:45.800
All right, you ready for a joke?


00:36:45.800 --> 00:36:46.800
Yes.


00:36:46.800 --> 00:36:48.520
Are you a fan of movies?


00:36:48.520 --> 00:36:49.960
Like watching movies and stuff?


00:36:49.960 --> 00:36:51.840
Yeah, I just went to a great movie.


00:36:51.840 --> 00:36:52.840
Yeah, so.


00:36:52.840 --> 00:36:53.840
Nice.


00:36:53.840 --> 00:36:57.920
Well, as a software person, especially if you do a lot with Linux or macOS, you might


00:36:57.920 --> 00:36:59.960
not be able to watch the movies too much.


00:36:59.960 --> 00:37:02.840
This one says, "I can't watch movies on my computer.


00:37:02.840 --> 00:37:07.480
All it does is bash scripts."


00:37:07.480 --> 00:37:09.040
Bash on the scripts of the movie.


00:37:09.040 --> 00:37:10.040
Oh, okay.


00:37:10.040 --> 00:37:11.040
Not plot.


00:37:11.040 --> 00:37:13.560
Or run shell scripts.


00:37:13.560 --> 00:37:14.560
I'm not sure which.


00:37:14.560 --> 00:37:16.160
- Okay, that's funny.


00:37:16.160 --> 00:37:17.000
I think.


00:37:17.000 --> 00:37:17.840
- Sort of, yeah.


00:37:17.840 --> 00:37:18.660
(laughing)


00:37:18.660 --> 00:37:19.500
Somewhat.


00:37:19.500 --> 00:37:21.520
Anyway, that's what I got for you.


00:37:21.520 --> 00:37:24.240
I have an incredible one that I wanna put up,


00:37:24.240 --> 00:37:27.520
but it's like only video that has music


00:37:27.520 --> 00:37:30.280
and no spoken word.


00:37:30.280 --> 00:37:31.840
So I don't think it fits for this format.


00:37:31.840 --> 00:37:33.360
But you know what, I'll throw it in.


00:37:33.360 --> 00:37:34.200
I'll throw it in.


00:37:34.200 --> 00:37:35.240
People also check out the movie.


00:37:35.240 --> 00:37:36.860
It's about releasing stuff to production.


00:37:36.860 --> 00:37:38.600
So it's pretty epic.


00:37:40.120 --> 00:37:44.600
put it on the list, but we won't play something that's like 30 seconds long that has nothing


00:37:44.600 --> 00:37:45.600
but music.


00:37:45.600 --> 00:37:46.600
Cool.


00:37:46.600 --> 00:37:47.600
Nice.


00:37:47.600 --> 00:37:48.600
All right.


00:37:48.600 --> 00:37:54.040
Is that all we got?


00:37:54.040 --> 00:37:55.040
That's all we got.


00:37:55.040 --> 00:37:56.040
It's a wrap.


00:37:56.040 --> 00:37:57.040
So it's a wrap.


00:37:57.040 --> 00:37:58.040
Yeah.


00:37:58.040 --> 00:37:59.040
Thanks as always.


00:37:59.040 --> 00:38:00.040
Thank you.


00:38:00.040 --> 00:38:01.040
See you later.


00:38:01.040 --> 00:38:02.040
Bye.


00:38:02.040 --> 00:38:03.040
Thanks everyone for listening and being here on YouTube.


00:38:03.040 --> 00:38:03.520
Those of you who are in the show.


00:38:03.520 --> 00:38:13.520
[BLANK_AUDIO]

