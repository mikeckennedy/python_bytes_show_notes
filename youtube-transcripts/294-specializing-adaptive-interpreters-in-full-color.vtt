WEBVTT

00:00:00.000 --> 00:00:01.760
>> Hey, Brian.


00:00:01.760 --> 00:00:02.760
>> Hey.


00:00:02.760 --> 00:00:06.560
>> Hey. Nice to have you here. Hello, YouTube.


00:00:06.560 --> 00:00:08.740
>> That's great to be back.


00:00:08.740 --> 00:00:12.180
>> I am pulling off a very, very cool trick.


00:00:12.180 --> 00:00:14.480
I just want to point out before we get started.


00:00:14.480 --> 00:00:15.880
>> Okay.


00:00:15.880 --> 00:00:19.240
>> So on the Talk Python channel,


00:00:19.240 --> 00:00:22.100
I'm doing a podcast with Anthony Shaw and Shane from


00:00:22.100 --> 00:00:26.360
Microsoft about Azure and Python and some CLI stuff they built,


00:00:26.360 --> 00:00:29.200
and FastAPI, and at the exact same time,


00:00:29.200 --> 00:00:35.520
I'm doing this one here. They're both streaming live. I don't know how that's happening. The other


00:00:35.520 --> 00:00:40.080
one was recorded two months ago and we couldn't release it because some of the things weren't


00:00:40.080 --> 00:00:44.960
finished yet. So I just I hit go on that. The real one, if you're bouncing around, the real one is


00:00:44.960 --> 00:00:51.200
here. Okay. Anyway, with that, you're ready to start a podcast? Yeah, definitely.


00:00:51.200 --> 00:00:57.360
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly


00:00:57.360 --> 00:01:03.920
to your earbuds. This is episode 294 recorded July 12th, 2022. I'm Michael Kennedy.


00:01:03.920 --> 00:01:09.280
And I am Brian Okken. It's just us this weekend or this today.


00:01:09.280 --> 00:01:16.400
It's just us. Yeah. I don't know. Dean out of the audience asked, is this a daily podcast show now?


00:01:16.400 --> 00:01:22.000
I'm a little bit torn about it. I feel like we almost could do a daily show,


00:01:22.000 --> 00:01:26.880
but then I think what it might take to do a daily show, knowing how much work a weekly show is,


00:01:26.880 --> 00:01:29.280
No, it's not a daily podcast.


00:01:29.280 --> 00:01:30.120
- No.


00:01:30.120 --> 00:01:32.500
- Would be fun, but--


00:01:32.500 --> 00:01:34.200
- Might be fun to do sometime,


00:01:34.200 --> 00:01:36.400
just do like a full week or something just to--


00:01:36.400 --> 00:01:37.240
- Right, exactly.


00:01:37.240 --> 00:01:39.920
Just a super, there's so much news


00:01:39.920 --> 00:01:41.960
we're seeing every day for the week.


00:01:41.960 --> 00:01:42.800
Cool, well--


00:01:42.800 --> 00:01:43.880
- But just like the same topics,


00:01:43.880 --> 00:01:44.720
like six days in a row.


00:01:44.720 --> 00:01:46.460
- Just do them over.


00:01:46.460 --> 00:01:47.300
- Yeah.


00:01:47.300 --> 00:01:48.920
(laughing)


00:01:48.920 --> 00:01:50.600
- Exactly, exactly.


00:01:50.600 --> 00:01:52.700
All right, am I up first this week?


00:01:52.700 --> 00:01:54.280
- You are, yes.


00:01:54.280 --> 00:01:55.120
- Right on.


00:01:55.120 --> 00:01:59.840
Well, let me tell you about something special, specialist.


00:01:59.840 --> 00:02:03.500
So just last week, I believe it was,


00:02:03.500 --> 00:02:05.400
I interviewed Alex Waygood,


00:02:05.400 --> 00:02:08.520
who did the write-up for the Python Language Summit.


00:02:08.520 --> 00:02:12.480
And as part of the topics we were discovering,


00:02:12.480 --> 00:02:14.520
the Python Language Summit and Python This Year


00:02:14.520 --> 00:02:16.980
is focusing a lot on performance


00:02:16.980 --> 00:02:19.240
and what's called the Shannon Plan.


00:02:19.240 --> 00:02:21.160
So this is Mark Shannon's plan


00:02:21.160 --> 00:02:24.640
to make Python five times faster over five releases.


00:02:24.640 --> 00:02:27.400
It's got a ton of support at Microsoft.


00:02:27.400 --> 00:02:30.040
Keita Van Rossum's there working on it,


00:02:30.040 --> 00:02:33.020
but they've hired like five or six other people


00:02:33.020 --> 00:02:35.620
who are full-time working on making Python faster now.


00:02:35.620 --> 00:02:37.360
So awesome, awesome.


00:02:37.360 --> 00:02:38.360
Thank you for that.


00:02:38.360 --> 00:02:44.880
However, one of the things that made Python 3.11 fast


00:02:44.880 --> 00:02:47.120
is some of the early work they did.


00:02:47.120 --> 00:02:52.120
And it comes down to PEP 659,


00:02:52.360 --> 00:02:54.700
a specializing adaptive interpreter.


00:02:54.700 --> 00:02:57.800
So let me tell you about this feature,


00:02:57.800 --> 00:03:01.040
this performance improvement first,


00:03:01.040 --> 00:03:03.080
and then we'll see what specialist is about,


00:03:03.080 --> 00:03:04.240
'cause it's about understanding


00:03:04.240 --> 00:03:06.640
and visualizing this behavior.


00:03:06.640 --> 00:03:07.680
Okay?


00:03:07.680 --> 00:03:12.680
So one of the things that is a problem with Python,


00:03:12.680 --> 00:03:16.680
because it's dynamic and its types can change


00:03:16.680 --> 00:03:18.360
and what can be passed could vary.


00:03:18.360 --> 00:03:19.940
I mean, you could have type hints,


00:03:19.940 --> 00:03:22.020
but you can violate the type hints all day long


00:03:22.020 --> 00:03:22.860
and it's fine.


00:03:22.860 --> 00:03:27.820
So what the interpreter has to do is say,


00:03:27.820 --> 00:03:31.260
well, we're gonna do all of our operations super general.


00:03:31.260 --> 00:03:33.660
So if I have a function and it's called add


00:03:33.660 --> 00:03:36.340
and it takes X and Y and it returns X plus Y,


00:03:36.340 --> 00:03:39.580
seems easy, but is that string addition?


00:03:39.580 --> 00:03:42.060
Is that numerical addition?


00:03:42.060 --> 00:03:45.340
Is that some custom operator overloading


00:03:45.340 --> 00:03:49.740
with a dunder add or whatever it is in some type?


00:03:49.740 --> 00:03:51.460
If it fails in one way, you kind of got to reverse it.


00:03:51.460 --> 00:03:53.460
Like there's all this unknown, right?


00:03:53.460 --> 00:03:54.300
- Yeah.


00:03:54.300 --> 00:03:57.300
- What if you knew, what if you knew those were integers


00:03:57.300 --> 00:04:00.380
and not classes or not strings?


00:04:00.380 --> 00:04:02.340
You could run different code.


00:04:02.340 --> 00:04:04.300
You wouldn't have to first figure out what they are.


00:04:04.300 --> 00:04:05.500
Are they compatible?


00:04:05.500 --> 00:04:10.500
Do you do the add in the low level CPython internals


00:04:10.500 --> 00:04:12.820
or do you go to like some Python class and do it?


00:04:12.820 --> 00:04:14.900
Right, you could be much more focused.


00:04:14.900 --> 00:04:15.740
- Yeah.


00:04:15.740 --> 00:04:17.620
- Additionally, if it was adding for a list,


00:04:17.620 --> 00:04:19.700
you could say, well, if I know their list,


00:04:19.700 --> 00:04:22.960
what we just do is go list.extend,


00:04:22.960 --> 00:04:24.740
and we give it the other list, right?


00:04:24.740 --> 00:04:27.380
We don't hunt around and figure out all this other stuff.


00:04:27.380 --> 00:04:31.780
So that's the general idea of the specializing interpreter


00:04:31.780 --> 00:04:33.220
is it goes through and it says,


00:04:33.220 --> 00:04:37.560
look, we don't know for sure what could be passed here,


00:04:37.560 --> 00:04:40.380
but if it looks like over and over,


00:04:40.380 --> 00:04:44.300
we're running the same code and it's always the same types,


00:04:44.300 --> 00:04:48.100
is there a way we could specialize those types?


00:04:49.220 --> 00:04:56.720
Is there a way that we could put specific code for adding numbers or specific code for combining lists?


00:04:56.720 --> 00:05:01.720
And this is called adaptive and speculative specialization.


00:05:01.720 --> 00:05:02.720
Okay.


00:05:02.720 --> 00:05:03.720
Okay.


00:05:03.720 --> 00:05:09.220
And my favorite part of it when it's performed, it's called the quickening.


00:05:09.220 --> 00:05:15.220
Quickening is the process of replacing slow instructions with faster variants.


00:05:15.220 --> 00:05:20.500
So kind of like I said, it has some advantages over immutable bytecode.


00:05:20.500 --> 00:05:24.700
It can be changed at runtime, like you see, we're always adding integers.


00:05:24.700 --> 00:05:29.700
It can use super instructions that span lines or take multiple operands.


00:05:29.700 --> 00:05:35.020
And it does not need to handle tracing as it can fall back to the original bytecode for that.


00:05:35.020 --> 00:05:35.820
Okay?


00:05:35.820 --> 00:05:38.500
So there's a whole bunch of stuff going on here.


00:05:38.500 --> 00:05:43.860
Like the example they give is, you might want to specialize load adder.


00:05:43.860 --> 00:05:48.180
So load adder is a way to say, give me the value that this thing contains.


00:05:48.180 --> 00:05:50.180
But what is the thing?


00:05:50.180 --> 00:05:54.260
One of the things you might do is you might realize it's an instance class.


00:05:54.260 --> 00:05:58.660
And then you would call load adder instance value.


00:05:58.660 --> 00:06:01.940
You might realize it's a module.


00:06:01.940 --> 00:06:07.380
And you might call load adder module or slot or so on, right?


00:06:07.380 --> 00:06:12.100
But if you knew, you don't have to go through first the abstract step and then


00:06:12.100 --> 00:06:17.380
figure out which of these it is, you just do the thing that it is. Okay, so that's the idea of this


00:06:17.380 --> 00:06:24.260
pep. This is one of the things that's making Python 3.11 faster. Awesome. So to the main topic.


00:06:24.260 --> 00:06:30.500
Okay, and then I'll just just as a note, I'm saying okay, as if I understand what you just said, but


00:06:30.500 --> 00:06:37.380
most of it. It's all right. I think we'll let's let's look at pictures. Okay. All right. So this


00:06:37.380 --> 00:06:45.860
This thing by Brent Boucher is called Specialist and it's about visualizing this specializing


00:06:45.860 --> 00:06:46.860
adaptive interpreter.


00:06:46.860 --> 00:06:48.860
>> Oh, okay, good.


00:06:48.860 --> 00:06:49.860
>> Okay.


00:06:49.860 --> 00:06:54.340
So it says Specialist uses fine-grained location information to create visual representations


00:06:54.340 --> 00:07:01.300
of exactly where and how CPython 3.11's new specializing adaptive interpreter optimizes


00:07:01.300 --> 00:07:02.780
your code.


00:07:02.780 --> 00:07:06.660
And it's not just interesting, it has actionable information.


00:07:06.660 --> 00:07:07.960
- Okay.


00:07:07.960 --> 00:07:09.420
- So for example, see here,


00:07:09.420 --> 00:07:13.400
and you gotta pull up the website if you're just listening.


00:07:13.400 --> 00:07:17.580
If you see in that website, you'll see some color.


00:07:17.580 --> 00:07:22.960
You'll see green, less green, yellow, orange,


00:07:22.960 --> 00:07:24.840
all the way to red.


00:07:24.840 --> 00:07:25.760
So there's two aspects,


00:07:25.760 --> 00:07:28.660
there's sort of a darkness as well as a color.


00:07:28.660 --> 00:07:32.960
So the most, like where Python could take advantage


00:07:32.960 --> 00:07:35.000
of this feature, you see green,


00:07:35.000 --> 00:07:40.000
where it can't, you see red and imagine the spectrum.


00:07:40.000 --> 00:07:44.120
It goes like green, yellow, orange, red.


00:07:44.120 --> 00:07:47.240
So it's not on or off, it's how much could it specialize.


00:07:47.240 --> 00:07:48.060
Okay? - Okay.


00:07:48.060 --> 00:07:49.420
- So what you see here, for example,


00:07:49.420 --> 00:07:52.720
is it's able to take some numbers,


00:07:52.720 --> 00:07:56.920
an integer and a string,


00:07:56.920 --> 00:08:01.620
and then use the fact that it knows what those are


00:08:01.620 --> 00:08:04.080
to make certain things like appending an output


00:08:04.080 --> 00:08:08.080
and doing some character operations on it.


00:08:08.080 --> 00:08:10.400
It was able to replace that


00:08:10.400 --> 00:08:12.560
with a different runtime behavior


00:08:12.560 --> 00:08:13.920
because of this quickening.


00:08:13.920 --> 00:08:17.440
All right, so let's skip down here.


00:08:17.440 --> 00:08:18.600
I gave you a bit of the background.


00:08:18.600 --> 00:08:19.860
So it says, let's look at this example.


00:08:19.860 --> 00:08:24.860
We have F to C, which converts Fahrenheit to Celsius.


00:08:24.860 --> 00:08:28.200
And what it does is, okay, we're gonna take an F


00:08:28.200 --> 00:08:30.960
and it has type hints that say float, float.


00:08:30.960 --> 00:08:32.720
But those don't matter.


00:08:32.720 --> 00:08:36.580
So it says we're gonna take an F and subtract 32 from it.


00:08:36.580 --> 00:08:38.380
And then we're gonna do simple math.


00:08:38.380 --> 00:08:41.260
We're gonna take that result,


00:08:41.260 --> 00:08:45.340
that range of that size of temperature there,


00:08:45.340 --> 00:08:47.460
based on zero, and then multiply it by five


00:08:47.460 --> 00:08:48.300
and divide it by nine.


00:08:48.300 --> 00:08:51.420
We all learned this in chemistry class or somewhere,


00:08:51.420 --> 00:08:56.100
or we talked about converting different measurement.


00:08:56.100 --> 00:08:57.260
- Yeah, of course.


00:08:57.260 --> 00:08:59.720
- Right, so these are straightforward,


00:08:59.720 --> 00:09:02.140
but there's actually problems in here


00:09:02.140 --> 00:09:05.220
that make it slower and prohibit Python


00:09:05.220 --> 00:09:08.340
from quickening it as much as it can be quickened.


00:09:08.340 --> 00:09:12.780
So if we take this code, it just runs F to C and C to F


00:09:12.780 --> 00:09:14.500
and it gives us some test values and says,


00:09:14.500 --> 00:09:16.660
just do it and tell us what happened.


00:09:16.660 --> 00:09:18.060
We can run specialists on it.


00:09:18.060 --> 00:09:20.120
And it says, okay, this X here,


00:09:20.120 --> 00:09:23.300
it says the green areas indicate regions of code


00:09:23.300 --> 00:09:25.020
that were successfully specialized


00:09:25.020 --> 00:09:28.620
where red areas are unsuccessful.


00:09:28.620 --> 00:09:30.900
Like it tried and it failed.


00:09:30.900 --> 00:09:36.860
So it says one of the problems is, start out the x equals f minus 32.


00:09:36.860 --> 00:09:42.580
It says, well, we can quicken operations on numerical types that are the same,


00:09:42.580 --> 00:09:47.140
but for now there's not a float int and float variant of this.


00:09:47.140 --> 00:09:48.260
It's got to be float float.


00:09:48.260 --> 00:09:55.820
So it says, right, you could have gotten a faster operation there, but because


00:09:55.820 --> 00:09:57.460
the types didn't match, you won't.


00:09:59.340 --> 00:10:02.140
But then what it did get out is an X, and that was great,


00:10:02.140 --> 00:10:03.980
an X which is a float, and it's gonna do some stuff,


00:10:03.980 --> 00:10:05.500
and it could sort of make it better, but it said,


00:10:05.500 --> 00:10:09.060
"Look, here's some multiplication again


00:10:09.060 --> 00:10:10.620
by an integer and a float."


00:10:10.620 --> 00:10:12.420
So that's not quickened.


00:10:12.420 --> 00:10:16.040
And this division, division is apparently never quickened.


00:10:16.040 --> 00:10:17.300
So what can we do?


00:10:17.300 --> 00:10:20.240
Well, with that information, you can say,


00:10:20.240 --> 00:10:22.420
"Well, what's the problem with subtracting 32?


00:10:22.420 --> 00:10:23.260
Well, it wasn't a float.


00:10:23.260 --> 00:10:25.260
Well, what if I said 32.0?"


00:10:25.260 --> 00:10:28.660
Oh, yes, all right, that gets replaced by faster code.


00:10:28.660 --> 00:10:29.500
- Oh, nice. - Right?


00:10:29.500 --> 00:10:30.700
- Yeah. - So that's pretty nice.


00:10:30.700 --> 00:10:31.820
And if you want to return,


00:10:31.820 --> 00:10:35.220
it was adding like X plus 32 for the other direction,


00:10:35.220 --> 00:10:37.500
and now it's 32.0, that's faster.


00:10:37.500 --> 00:10:39.080
Okay, well, what else?


00:10:39.080 --> 00:10:42.140
What if we, now you can see when we did that part


00:10:42.140 --> 00:10:46.220
of the conversion X times five divided by nine,


00:10:46.220 --> 00:10:49.940
if we put a 5.0, that gets faster still,


00:10:49.940 --> 00:10:51.880
but the divide is never quickened.


00:10:51.880 --> 00:10:55.120
Okay, well, what if we put the divide in parentheses?


00:10:55.120 --> 00:10:58.300
It doesn't really matter if it's X times five divided by nine


00:10:58.300 --> 00:11:01.080
are X times five divided by nine, right?


00:11:01.080 --> 00:11:02.980
These are mathematically equivalent,


00:11:02.980 --> 00:11:04.880
but they're not equivalent to Python


00:11:04.880 --> 00:11:08.260
'cause that operation results in,


00:11:08.260 --> 00:11:12.300
it leverages constant folding, right?


00:11:12.300 --> 00:11:14.860
Five divided by nine is pre-computed in Python


00:11:14.860 --> 00:11:15.700
to be a float.


00:11:15.700 --> 00:11:17.400
- Okay.


00:11:17.400 --> 00:11:18.220
- At parse time, right?


00:11:18.220 --> 00:11:19.460
That's just how it works with constants.


00:11:19.460 --> 00:11:21.560
If it says it can do math with constants ahead of time,


00:11:21.560 --> 00:11:22.580
it does it.


00:11:22.580 --> 00:11:23.660
So that becomes a float,


00:11:23.660 --> 00:11:26.280
and then float times float is now quickened, right?


00:11:26.280 --> 00:11:27.740
Isn't this cool, the way you can apply this


00:11:27.740 --> 00:11:29.740
and actually make your code faster,


00:11:29.740 --> 00:11:31.060
not just go, "Oh, it's interesting.


00:11:31.060 --> 00:11:32.660
It must be quick in it there."


00:11:32.660 --> 00:11:35.420
>> Yeah. It is really pretty cool.


00:11:35.420 --> 00:11:37.500
I'd really like to see this incorporated into


00:11:37.500 --> 00:11:39.780
an editor or something to say,


00:11:39.780 --> 00:11:42.060
"Your code will be faster if you just add


00:11:42.060 --> 00:11:44.900
a point zero here or something like that."


00:11:44.900 --> 00:11:47.900
>> It's going to become a float anyway. It doesn't matter.


00:11:47.900 --> 00:11:51.060
Why would you write 32.0 when you just meant 32?


00:11:51.060 --> 00:11:53.700
Seems more precise to say 32.


00:11:53.700 --> 00:11:56.180
>> Because I'm used to doing that,


00:11:56.180 --> 00:11:57.740
to thinking if it's okay.


00:11:57.740 --> 00:12:00.740
Well, me personally, if I know it's gonna be a float math,


00:12:00.740 --> 00:12:05.080
I usually do 0.0, but maybe that's not a normal thing.


00:12:05.080 --> 00:12:07.460
- You're such a C programmer.


00:12:07.460 --> 00:12:09.700
(laughing)


00:12:09.700 --> 00:12:13.740
All right, well, I think this is really cool.


00:12:13.740 --> 00:12:15.100
This is specialist. - It is pretty cool, yeah.


00:12:15.100 --> 00:12:19.100
- And I don't know if I have any code that does math


00:12:19.100 --> 00:12:21.540
at that fine of grain or level that I really care,


00:12:21.540 --> 00:12:24.840
but maybe, if you're in charge of a library


00:12:24.840 --> 00:12:27.360
where you've got a tight loop or you do a lot of math


00:12:27.360 --> 00:12:28.960
science stuff where it matters,


00:12:28.960 --> 00:12:30.520
this can be really useful.


00:12:30.520 --> 00:12:32.040
And what's cool is it's not like,


00:12:32.040 --> 00:12:37.040
and switch to Rust or switch to C or switch to Cython


00:12:37.040 --> 00:12:38.320
and it'll take effect.


00:12:38.320 --> 00:12:40.880
Like no, this is like straight Python code.


00:12:40.880 --> 00:12:42.880
This is just how do I take most advantage


00:12:42.880 --> 00:12:46.480
of what is already happening for performance boosts


00:12:46.480 --> 00:12:48.520
in 3.11 that we haven't had before.


00:12:48.520 --> 00:12:49.800
- I think, and I think it's gonna be


00:12:49.800 --> 00:12:51.080
just one more workflow step.


00:12:51.080 --> 00:12:54.040
So you've got, you profile your code,


00:12:54.040 --> 00:12:57.000
your code, your whole thing is a little bit slower


00:12:57.000 --> 00:12:58.200
than you'd like it to be.


00:12:58.200 --> 00:12:59.560
You throw a profiler on it,


00:12:59.560 --> 00:13:02.680
you see the bottleneck areas that you could improve


00:13:02.680 --> 00:13:06.340
and you think, should I like rewrite some of this in Rust


00:13:06.340 --> 00:13:08.440
or C or, you know, what should I do?


00:13:08.440 --> 00:13:10.800
Well, first off, let's try doing this,


00:13:10.800 --> 00:13:15.800
like throw this at it and have the optimizer


00:13:15.800 --> 00:13:20.920
from 3.11 help you out and yeah.


00:13:20.920 --> 00:13:23.720
So I think this, I can definitely see


00:13:23.720 --> 00:13:26.060
that this is gonna be part of people's workflow.


00:13:26.060 --> 00:13:26.900
But yeah, profile first.


00:13:26.900 --> 00:13:27.720
- I agree that you wanna profile first.


00:13:27.720 --> 00:13:30.000
- Don't do it everywhere. - Yes, exactly.


00:13:30.000 --> 00:13:31.860
'Cause while it's fun to do this,


00:13:31.860 --> 00:13:34.480
only focus where it's gonna matter.


00:13:34.480 --> 00:13:37.660
Don't optimize a bunch of stuff that doesn't.


00:13:37.660 --> 00:13:41.080
So Brian out in the audience says, different Brian,


00:13:41.080 --> 00:13:43.880
is there a plan to do lossless type conversion


00:13:43.880 --> 00:13:47.040
or maybe Flake 8 can make this kind of suggestion?


00:13:47.040 --> 00:13:48.080
- Yeah, exactly.


00:13:48.080 --> 00:13:50.800
- Yeah, I'm not really sure if,


00:13:52.520 --> 00:13:53.640
you don't want to write the code


00:13:53.640 --> 00:13:56.360
where you get different outputs, probably, right?


00:13:56.360 --> 00:13:57.880
But everything that was happening here,


00:13:57.880 --> 00:14:02.880
you ended up with the same outcome anyway.


00:14:02.880 --> 00:14:04.960
It's just like, well, do I do the division first


00:14:04.960 --> 00:14:05.960
or the multiplication?


00:14:05.960 --> 00:14:09.160
Or do I start with an int that results


00:14:09.160 --> 00:14:11.480
after some addition, subtraction with a float,


00:14:11.480 --> 00:14:13.880
or as I just make them all floats, right?


00:14:13.880 --> 00:14:18.440
I feel like it's, in most cases,


00:14:18.440 --> 00:14:21.640
it shouldn't be changing the outcome, so.


00:14:21.640 --> 00:14:23.720
- Okay, yeah.


00:14:23.720 --> 00:14:24.640
- Yeah, cool.


00:14:24.640 --> 00:14:27.080
Anyway, that's what I got for the first one.


00:14:27.080 --> 00:14:28.200
How about you?


00:14:28.200 --> 00:14:32.660
- Well, kind of sticking with a 3.11 theme so far.


00:14:32.660 --> 00:14:37.160
Well, we can use Toml now, but in 3.11,


00:14:37.160 --> 00:14:42.160
we are gonna have a Toml that'd be part of Python 3.11


00:14:42.160 --> 00:14:46.880
with PEP 680, and we covered that in episode 273.


00:14:46.880 --> 00:14:49.920
But one of the things we didn't mention


00:14:49.920 --> 00:14:54.920
was that the Tomlib is,


00:14:54.920 --> 00:14:56.360
and I think we did mention it,


00:14:56.360 --> 00:14:59.760
is based on Tomli, but Tomli you can use right now.


00:14:59.760 --> 00:15:03.500
So a lot of projects are switching to use Tomli


00:15:03.500 --> 00:15:08.500
as their Toml parser to read like pyproject.toml


00:15:08.500 --> 00:15:13.160
or read their own config file.


00:15:13.160 --> 00:15:17.080
And so I just wanted to highlight it.


00:15:17.080 --> 00:15:20.200
Tom Lee is the, a little Toml parser.


00:15:20.200 --> 00:15:23.440
It's a cute little thing on the project.


00:15:23.440 --> 00:15:24.280
- That's cute.


00:15:24.280 --> 00:15:29.280
- But I was reminded of it because the real Python people


00:15:29.280 --> 00:15:34.480
put out actually, looks like gear, Arne,


00:15:34.480 --> 00:15:37.200
sorry, I'm not gonna try to pronounce that name.


00:15:37.200 --> 00:15:40.000
Real Python wrote an article called


00:15:40.000 --> 00:15:43.240
Python and Toml New Best Friends.


00:15:43.240 --> 00:15:47.220
And I really love, it's a very comprehensive article,


00:15:47.220 --> 00:15:50.560
but I really love at least the first three parts of it,


00:15:50.560 --> 00:15:53.020
using Toml as a config format,


00:15:53.020 --> 00:15:55.180
getting to know key value pairs,


00:15:55.180 --> 00:15:57.600
and load Toml with Python,


00:15:57.600 --> 00:15:59.760
because this is kind of what you're gonna do with it.


00:15:59.760 --> 00:16:01.880
You're gonna write config files for something.


00:16:01.880 --> 00:16:03.560
And I just kind of,


00:16:03.560 --> 00:16:06.400
this is a great introduction of Toml for Python,


00:16:06.400 --> 00:16:08.520
and that's kind of what we care about, right?


00:16:08.520 --> 00:16:11.400
So it goes through,


00:16:11.400 --> 00:16:14.400
like just getting used to what Toml looks like,


00:16:14.400 --> 00:16:15.760
what a configure file looks like,


00:16:15.760 --> 00:16:17.840
talking about how all the keys,


00:16:17.840 --> 00:16:20.360
even if you, it's like key value stuff.


00:16:20.360 --> 00:16:23.760
And even if you put a number there or something,


00:16:23.760 --> 00:16:25.000
it's gonna be a string.


00:16:25.000 --> 00:16:26.620
All the keys get converted to strings,


00:16:26.620 --> 00:16:28.480
even if they don't look like them.


00:16:28.480 --> 00:16:31.600
And they are, they're UTF-8.


00:16:31.600 --> 00:16:35.240
So you can use Unicode in there as well,


00:16:35.240 --> 00:16:37.000
which is kind of neat.


00:16:37.000 --> 00:16:38.760
- Put your emojis in there.


00:16:38.760 --> 00:16:43.640
>> Yeah, well, are emojis UTF-8?


00:16:43.640 --> 00:16:45.680
>> I think mostly.


00:16:45.680 --> 00:16:46.640
Many of them are.


00:16:46.640 --> 00:16:47.400
>> Interesting.


00:16:47.400 --> 00:16:51.240
That would be fun to put emojis in here.


00:16:51.240 --> 00:16:51.800
I don't know.


00:16:51.800 --> 00:16:52.600
>> What mode are we running?


00:16:52.600 --> 00:16:54.800
Are we running in cow mode or lizard mode?


00:16:54.800 --> 00:16:55.520
I'll do lizard.


00:16:55.520 --> 00:16:57.600
Yeah, OK, well, if you're running in lizard mode--


00:16:57.600 --> 00:16:59.560
>> Lizard is true.


00:16:59.560 --> 00:17:01.600
OK, I got to try that to see.


00:17:01.600 --> 00:17:02.880
I should have done that before.


00:17:02.880 --> 00:17:06.240
>> Oh my gosh, I think it's both horrible and amazing


00:17:06.240 --> 00:17:08.880
to imagine writing like config files to like put it


00:17:08.880 --> 00:17:10.840
and put it in lizard mode, do it.


00:17:10.840 --> 00:17:12.320
- Yeah.


00:17:12.320 --> 00:17:13.320
One of the things that I didn't,


00:17:13.320 --> 00:17:14.360
before reading this article,


00:17:14.360 --> 00:17:16.800
one of the things I didn't know you could do in Toml


00:17:16.800 --> 00:17:18.320
because I just started cursory,


00:17:18.320 --> 00:17:21.040
I use it with pyproject.toml and that's about it.


00:17:21.040 --> 00:17:22.400
But you can do,


00:17:22.400 --> 00:17:28.040
so talks about normal how to read stuff.


00:17:28.040 --> 00:17:29.500
But one of the things is,


00:17:29.500 --> 00:17:31.480
oh, what was I gonna talk about?


00:17:31.480 --> 00:17:33.080
Arrays.


00:17:33.080 --> 00:17:35.800
And you can do arrays of things, which are neat.


00:17:35.800 --> 00:17:40.640
and tables and arrays of tables, which is like,


00:17:40.640 --> 00:17:42.280
so you have arrays of tables


00:17:42.280 --> 00:17:44.200
or these bracket bracket things.


00:17:44.200 --> 00:17:46.960
And then you can do dot stuff.


00:17:46.960 --> 00:17:51.960
So if you have like, was it user and user dot player,


00:17:51.960 --> 00:17:55.440
these will show up as like, you know,


00:17:55.440 --> 00:17:58.840
sub dictionary key things.


00:17:58.840 --> 00:18:00.720
And so one of the things that I,


00:18:00.720 --> 00:18:02.440
and I played with it this morning


00:18:02.440 --> 00:18:06.000
And it really, I should have had something to show,


00:18:06.000 --> 00:18:08.960
but the thing I like to do is to just read it,


00:18:08.960 --> 00:18:11.920
just like this article talks about reading it,


00:18:11.920 --> 00:18:15.280
just read the Toml file into Python and print it.


00:18:15.280 --> 00:18:19.360
And then you can, and it'll print out as a dictionary,


00:18:19.360 --> 00:18:22.120
and then you can create whatever format you want


00:18:22.120 --> 00:18:23.880
for your Toml file, and then you can just see


00:18:23.880 --> 00:18:24.800
what it's gonna look like,


00:18:24.800 --> 00:18:26.600
and then you know how to access it.


00:18:26.600 --> 00:18:27.560
(laughs)


00:18:27.560 --> 00:18:29.240
That's one of the best ways to do that.


00:18:29.240 --> 00:18:30.560
- That's awesome.


00:18:30.560 --> 00:18:31.400
- Yeah.


00:18:31.400 --> 00:18:34.000
That's pretty that's pretty in depth.


00:18:34.000 --> 00:18:36.520
And a blast from last week passed.


00:18:36.520 --> 00:18:39.120
Actually, hey, actually says UTF 8 can


00:18:39.120 --> 00:18:41.240
encode any Unicode character emoji.


00:18:41.240 --> 00:18:43.240
Your heart emoji heart out.


00:18:43.240 --> 00:18:46.160
Oh yeah, you could do like you know,


00:18:46.160 --> 00:18:47.920
is it in heart mode?


00:18:47.920 --> 00:18:50.680
Heart equals true or equals false or


00:18:50.680 --> 00:18:51.960
over optimize optimizer.


00:18:51.960 --> 00:18:55.000
You could do a flame emoji equals true.


00:18:55.000 --> 00:18:56.840
Exactly, so I love it.


00:18:56.840 --> 00:18:59.520
I think look, we have not leveraged


00:18:59.520 --> 00:19:01.720
- We have not leveraged the configuration


00:19:01.720 --> 00:19:03.160
as emoji sufficiently.


00:19:03.160 --> 00:19:06.320
- No, yeah, I think pytest should rewrite


00:19:06.320 --> 00:19:08.560
all of its configs as emoji items.


00:19:08.560 --> 00:19:10.200
- Just do a PR, I'm sure they'll take it.


00:19:10.200 --> 00:19:12.880
- Yeah. (laughing)


00:19:12.880 --> 00:19:14.360
Yeah, it'd be good. - All right.


00:19:14.360 --> 00:19:15.360
Yeah, all right, let me tell you


00:19:15.360 --> 00:19:18.280
about our sponsor for this week before we move on.


00:19:18.280 --> 00:19:21.400
So this week is brought to you by Microsoft Founders Hub.


00:19:21.400 --> 00:19:24.040
In fact, they are supporting a whole bunch


00:19:24.040 --> 00:19:26.120
of upcoming episodes, so thank you a whole bunch


00:19:26.120 --> 00:19:28.360
to Microsoft for startups here.


00:19:28.360 --> 00:19:30.240
Starting a business is hard by some estimates,


00:19:30.240 --> 00:19:32.940
over 90% of startups go out of business


00:19:32.940 --> 00:19:34.060
within their first year.


00:19:34.060 --> 00:19:35.800
With that in mind, Microsoft for Startups


00:19:35.800 --> 00:19:39.060
set out to understand what startups need to be successful


00:19:39.060 --> 00:19:40.720
and to create a digital platform


00:19:40.720 --> 00:19:42.460
to help overcome those challenges.


00:19:42.460 --> 00:19:44.760
Microsoft for Startups Founders Hub.


00:19:44.760 --> 00:19:48.440
Their hub provides all founders at any stage


00:19:48.440 --> 00:19:52.340
with a bunch of free resources to help solve challenges.


00:19:52.340 --> 00:19:54.640
And you get technology benefits,


00:19:54.640 --> 00:19:55.760
but also really importantly,


00:19:55.760 --> 00:19:58.520
access to expert guidance and skilled resources,


00:19:58.520 --> 00:20:01.100
mentorship and networking connections and a bunch more.


00:20:01.100 --> 00:20:06.100
So unlike a bunch of other similar projects in the industry,


00:20:06.100 --> 00:20:09.000
Microsoft for Startup Founders Hub does not require startups


00:20:09.000 --> 00:20:11.900
to be investor backed or third party validated


00:20:11.900 --> 00:20:13.420
to participate.


00:20:13.420 --> 00:20:16.880
It's free to apply and if you apply, get in,


00:20:16.880 --> 00:20:18.880
then it's, you're in.


00:20:18.880 --> 00:20:19.720
It's open to all.


00:20:19.720 --> 00:20:21.440
So what do you get if you join or apply


00:20:21.440 --> 00:20:22.560
and then get accepted?


00:20:22.560 --> 00:20:24.800
So you can speed up your development


00:20:24.800 --> 00:20:27.200
with access to GitHub, Microsoft Cloud,


00:20:27.200 --> 00:20:29.400
with the ability to unlock credits over time,


00:20:29.400 --> 00:20:32.720
as in, I think it's over $100,000 worth of credits


00:20:32.720 --> 00:20:34.000
over time, over the first year,


00:20:34.000 --> 00:20:37.200
if you meet a bunch of milestones, which is fantastic.


00:20:37.200 --> 00:20:38.520
It'll help your startup innovate.


00:20:38.520 --> 00:20:41.600
FounderHub is partnering with companies like OpenAI,


00:20:41.600 --> 00:20:43.640
the global leader in AI research and development


00:20:43.640 --> 00:20:45.640
to provide benefits and discounts too.


00:20:45.640 --> 00:20:47.960
- Neat.


00:20:47.960 --> 00:20:50.080
- Yeah, through Microsoft Startup Founders Hub,


00:20:50.080 --> 00:20:52.680
becoming a founder is no longer about who you know.


00:20:52.680 --> 00:20:54.440
You'll have access to the mentorship network,


00:20:54.440 --> 00:20:56.880
giving you access to a pool of hundreds of mentors


00:20:56.880 --> 00:20:59.880
across a range of disciplines, areas like idea,


00:20:59.880 --> 00:21:02.040
validation, fundraising, management, coaching,


00:21:02.040 --> 00:21:04.800
sales, marketing, as well as specific technical


00:21:04.800 --> 00:21:05.680
stress points.


00:21:05.680 --> 00:21:07.840
To me, that's actually the biggest value


00:21:07.840 --> 00:21:10.800
is the networking and mentor side.


00:21:10.800 --> 00:21:12.800
So you'll be able to book a one-on-one meeting


00:21:12.800 --> 00:21:16.400
with these mentors, many of whom are founders themselves.


00:21:16.400 --> 00:21:17.880
Make your idea a reality today


00:21:17.880 --> 00:21:20.080
with the critical support you'll get from Microsoft


00:21:20.080 --> 00:21:21.360
for Startups Founders Hub.


00:21:21.360 --> 00:21:24.680
Join the program at pythonbytes.fm/foundershub.


00:21:24.680 --> 00:21:27.060
Link will be in your player show notes.


00:21:27.060 --> 00:21:27.900
- Nice.


00:21:27.900 --> 00:21:28.800
Yeah, cool.


00:21:28.800 --> 00:21:29.820
- Indeed.


00:21:29.820 --> 00:21:31.840
All right, I guess I'm up next with this order we got.


00:21:31.840 --> 00:21:35.400
And oh my goodness, Samuel Colvin, take a bow.


00:21:35.400 --> 00:21:40.520
He put out a plan for what's happening


00:21:40.520 --> 00:21:43.200
with Pydantic version two.


00:21:43.200 --> 00:21:46.680
But the reason I say take a bow is this is one detailed plan


00:21:46.680 --> 00:21:48.640
that is really, really thought through,


00:21:48.640 --> 00:21:52.760
thought out, backed up with a bunch of GitHub discussions


00:21:52.760 --> 00:21:53.760
and so on.


00:21:53.760 --> 00:21:54.600
- Wow.


00:21:54.600 --> 00:21:56.100
- The idea is,


00:21:56.100 --> 00:21:59.440
Pydantic started out as an interesting idea


00:21:59.440 --> 00:22:02.920
and surprise, surprise, a bunch of people glommed onto it,


00:22:02.920 --> 00:22:07.280
probably more than it was originally envisioned to be so.


00:22:07.280 --> 00:22:12.000
So for example, SQL model from Sebastian Ramirez is like,


00:22:12.000 --> 00:22:15.180
Pydantic models are now our ORM to the database


00:22:15.180 --> 00:22:17.400
with all the interesting stuff that ORMs have.


00:22:17.400 --> 00:22:19.540
And Roman Wright said, "Guess what?


00:22:19.540 --> 00:22:22.980
"We could do that for MongoDB as well."


00:22:22.980 --> 00:22:25.440
Same with the Pydastic thing we recently spoke about.


00:22:25.440 --> 00:22:28.820
And then Sebastian Ramirez is like, also,


00:22:28.820 --> 00:22:31.460
like, "Hey, FastAPI, this can be both our data exchange


00:22:31.460 --> 00:22:33.740
"as well as our documentation."


00:22:33.740 --> 00:22:36.340
Sure, so I was like, "Oh my goodness, what's going on here?"


00:22:36.340 --> 00:22:39.620
So, he says there's a bunch of stuff on the insides


00:22:39.620 --> 00:22:42.220
that could be better, let's say,


00:22:42.220 --> 00:22:45.660
or maybe time to rethink this.


00:22:45.660 --> 00:22:47.420
So in this plan, it talks about what they'll add,


00:22:47.420 --> 00:22:49.700
what they'll remove, what will change,


00:22:49.700 --> 00:22:52.880
some of the ideas for how long it will take and so on.


00:22:52.880 --> 00:22:55.200
- Interesting.


00:22:55.200 --> 00:22:57.460
- Yeah, here's a pretty significant thing.


00:22:57.460 --> 00:22:59.540
I'm currently taking a kind of sabbatical


00:22:59.540 --> 00:23:02.120
after leaving my last job to work on this,


00:23:02.120 --> 00:23:03.900
which goes until October.


00:23:03.900 --> 00:23:07.300
So that's a big commitment to,


00:23:07.300 --> 00:23:09.540
I'm gonna help make Pydantic better.


00:23:09.540 --> 00:23:12.420
- Oh, wow. - So it sounds familiar.


00:23:12.420 --> 00:23:15.300
It sounds a bit like Rich and Textual


00:23:15.300 --> 00:23:16.540
and those types of things as well.


00:23:16.540 --> 00:23:19.500
But this is a big, big commitment from Samuel


00:23:19.500 --> 00:23:22.020
and he's really doing a ton of work.


00:23:22.020 --> 00:23:24.060
Says, "People seem to care about my project.


00:23:24.060 --> 00:23:28.100
"It's downloaded 26 million times a month."


00:23:28.100 --> 00:23:29.580
- Wow. - Which is insane.


00:23:29.580 --> 00:23:30.580
Yeah, it's awesome.


00:23:30.580 --> 00:23:33.500
- That's kind of incredible.


00:23:33.500 --> 00:23:35.260
- It is.


00:23:35.260 --> 00:23:37.320
And so it says, "Here's the basic roadmap.


00:23:37.320 --> 00:23:38.480
"Implement a few features


00:23:38.480 --> 00:23:41.460
"in what's now called the Pydantic Core."


00:23:41.460 --> 00:23:44.260
We just had Ashley, who as we saw is out in the audience.


00:23:44.260 --> 00:23:47.620
Hey, Ashley, who gave a bit of a shout out to this feature.


00:23:47.620 --> 00:23:50.500
And also I do want to also credit a couple other people


00:23:50.500 --> 00:23:53.220
because Douglas Nichols and John Thagen


00:23:53.220 --> 00:23:55.460
also let me know that this was big news coming.


00:23:55.460 --> 00:23:57.100
So thank you all for that.


00:23:57.100 --> 00:24:02.680
The PyData core is being rewritten in Rust,


00:24:02.680 --> 00:24:05.300
which doesn't mean you have to know or do anything.


00:24:05.300 --> 00:24:07.360
It just means you have to pip install something.


00:24:07.360 --> 00:24:10.500
You get a binary compiled thing that runs a lot faster.


00:24:10.500 --> 00:24:12.200
Okay, so more on that in a second.


00:24:13.580 --> 00:24:15.560
First, they're working to get 1.10 out


00:24:15.560 --> 00:24:18.640
and basically merge every open PR that makes sense


00:24:18.640 --> 00:24:21.880
and close every PR that doesn't make sense


00:24:21.880 --> 00:24:24.120
and then profusely apologize to why your PR


00:24:24.120 --> 00:24:25.880
that you spent a long time making


00:24:25.880 --> 00:24:28.000
was closed without merging.


00:24:28.000 --> 00:24:30.120
Some other bookkeeping things.


00:24:30.120 --> 00:24:34.200
I start tearing the Pydentic code apart


00:24:34.200 --> 00:24:37.000
and see how many existing tests can still be made to pass


00:24:37.000 --> 00:24:39.400
and then release eventually Pydentic.


00:24:39.400 --> 00:24:41.580
The goal is to have this done by October,


00:24:41.580 --> 00:24:43.480
probably by the end of year for sure.


00:24:43.480 --> 00:24:45.940
Couple of things worth paying attention to,


00:24:45.940 --> 00:24:48.140
there are a bunch of breaking changes in here.


00:24:48.140 --> 00:24:49.740
A lot of things are being cleaned up,


00:24:49.740 --> 00:24:54.740
reorganized, renamed, some removed,


00:24:54.740 --> 00:24:58.020
like from ORM, people might be using that with SQLAlchemy,


00:24:58.020 --> 00:25:00.260
that's being removed, for example, and so on.


00:25:00.260 --> 00:25:04.980
So there's, if you depend heavily on PyDandic,


00:25:04.980 --> 00:25:07.900
especially if you build a project like Beanie


00:25:07.900 --> 00:25:09.500
that depends heavily on PyDandic,


00:25:09.500 --> 00:25:10.860
you're gonna need to look at this


00:25:10.860 --> 00:25:13.500
because some of the stuff won't work anymore.


00:25:13.500 --> 00:25:15.380
But let's highlight a couple of things here.


00:25:15.380 --> 00:25:19.620
Performance, this one is really important


00:25:19.620 --> 00:25:24.420
because this is the data exchange level for FastAPI.


00:25:24.420 --> 00:25:27.620
This is the database transformation level.


00:25:27.620 --> 00:25:28.820
When I do a query from the database,


00:25:28.820 --> 00:25:31.020
what comes back comes back in some raw form


00:25:31.020 --> 00:25:33.860
and then is turned into a Pydantic model.


00:25:33.860 --> 00:25:37.660
And those are computationally expensive things


00:25:37.660 --> 00:25:39.020
that happen often.


00:25:39.020 --> 00:25:44.020
And in general, PyDandig version two is about 17 times


00:25:44.020 --> 00:25:48.220
1,700% faster than V1 when validating models


00:25:48.220 --> 00:25:50.180
in a standard scenario.


00:25:50.180 --> 00:25:53.280
It says between four to 50 times faster than PyDandig one.


00:25:53.280 --> 00:25:56.180
- Hmm, wow. - That's cool, right?


00:25:56.180 --> 00:25:57.160
- Yeah.


00:25:57.160 --> 00:25:59.500
- That alone should make your ears perk up and go,


00:25:59.500 --> 00:26:02.720
excuse me, my ORM just got 17 times faster?


00:26:02.720 --> 00:26:04.400
Wait a minute, I'm liking this.


00:26:04.400 --> 00:26:07.680
I know that this is not the only thing


00:26:07.680 --> 00:26:08.760
that happens at ORLM level,


00:26:08.760 --> 00:26:12.300
But the ones that I called out that depend heavily on it,


00:26:12.300 --> 00:26:16.120
that's in the transformation path, so this is important.


00:26:16.120 --> 00:26:17.480
- Yeah.


00:26:17.480 --> 00:26:20.080
This is actually, I'm super impressed.


00:26:20.080 --> 00:26:24.740
I normally don't even see this sort of advanced planning


00:26:24.740 --> 00:26:26.760
in commercial projects.


00:26:26.760 --> 00:26:28.080
- Yes, oh yeah.


00:26:28.080 --> 00:26:30.240
You could do a whole business startup


00:26:30.240 --> 00:26:31.360
that doesn't have the amount of thought


00:26:31.360 --> 00:26:33.240
that went into what's happening


00:26:33.240 --> 00:26:34.600
in the next version of Pydantic.


00:26:34.600 --> 00:26:36.400
It's ridiculous. - This is incredible, yeah.


00:26:36.400 --> 00:26:37.440
- It's incredible.


00:26:37.440 --> 00:26:39.340
I was serious when I said take a bow.


00:26:39.340 --> 00:26:43.840
It really lays out, opens a discussion


00:26:43.840 --> 00:26:44.960
about certain things and so on.


00:26:44.960 --> 00:26:47.240
So like another one is strict mode.


00:26:47.240 --> 00:26:50.520
I think I even saw a comment in the chat about it.


00:26:50.520 --> 00:26:54.400
So one of the things I actually like about Pydantic,


00:26:54.400 --> 00:26:56.000
but under certain circumstances,


00:26:56.000 --> 00:26:57.240
I can see why you would not want it,


00:26:57.240 --> 00:27:00.860
is if you have something you say is an integer field,


00:27:00.860 --> 00:27:03.340
and then you pass one, two, three, the number, great.


00:27:03.340 --> 00:27:06.360
But if you also pass quote one, two, three,


00:27:06.360 --> 00:27:08.680
Pydantic will magically parse that for you.


00:27:08.680 --> 00:27:10.360
Like this happens all the time on the internet.


00:27:10.360 --> 00:27:11.760
Like a query string has a number,


00:27:11.760 --> 00:27:13.940
but query strings are always strings.


00:27:13.940 --> 00:27:16.600
There's no way to have anything but strings.


00:27:16.600 --> 00:27:17.960
So you got to convert them, right?


00:27:17.960 --> 00:27:20.520
So this automatically does that.


00:27:20.520 --> 00:27:22.160
But if you don't want that to happen,


00:27:22.160 --> 00:27:24.440
you say you gave me a string, it's invalid.


00:27:24.440 --> 00:27:25.800
You can turn on strict mode,


00:27:25.800 --> 00:27:28.320
which is off by default, I believe.


00:27:28.320 --> 00:27:30.360
There's also a bunch of plain, go ahead.


00:27:30.360 --> 00:27:33.440
- So strict mode does the conversion or strict mode-


00:27:33.440 --> 00:27:35.000
- Strict mode won't do the conversion.


00:27:35.000 --> 00:27:37.760
It says, you said it's an int, you gave me a string.


00:27:37.760 --> 00:27:40.760
Nope, rather than could it be an integer?


00:27:40.760 --> 00:27:41.960
Let's try that first.


00:27:41.960 --> 00:27:43.160
You know what I mean?


00:27:43.160 --> 00:27:44.000
- Yeah.


00:27:44.000 --> 00:27:47.640
- You know, maybe one of the things you do is


00:27:47.640 --> 00:27:49.280
in the ORM level, one of those things,


00:27:49.280 --> 00:27:50.360
you might put it in strict mode


00:27:50.360 --> 00:27:52.640
so it doesn't do as much work trying to convert stuff.


00:27:52.640 --> 00:27:53.840
I don't know if it actually would matter,


00:27:53.840 --> 00:27:56.800
but formalizes a bunch of conversions.


00:27:56.800 --> 00:28:00.760
It has built-in JSON support and different things.


00:28:01.640 --> 00:28:05.120
Another big thing is this Pydantic core


00:28:05.120 --> 00:28:10.120
will be able to be used outside of Pydantic classes now.


00:28:10.120 --> 00:28:14.280
So you can do a significant performance


00:28:14.280 --> 00:28:17.400
to improve stuff like adding validation to the data classes


00:28:17.400 --> 00:28:19.760
or validating arguments and query strings


00:28:19.760 --> 00:28:23.640
or a type DIC or a function argument or whatever.


00:28:23.640 --> 00:28:24.680
- Yeah.


00:28:24.680 --> 00:28:26.280
- Yeah, let's see.


00:28:26.280 --> 00:28:30.520
Next up, and let's see this one,


00:28:30.520 --> 00:28:32.840
Strict mode, we talked about strict mode.


00:28:32.840 --> 00:28:35.600
Another one is required versus nullable.


00:28:35.600 --> 00:28:37.520
It was a little bit of ambiguity of,


00:28:37.520 --> 00:28:41.020
you know, if you said something's a string,


00:28:41.020 --> 00:28:44.320
that means it's required and it can't be none.


00:28:44.320 --> 00:28:47.420
If you say it's a string pipe none,


00:28:47.420 --> 00:28:49.920
or it's an optional string or something like that,


00:28:49.920 --> 00:28:56.400
then basically the behaviors were a little bit different.


00:28:56.880 --> 00:29:00.620
So originally, I think this is when typing was pretty new,


00:29:00.620 --> 00:29:03.420
said, "Pydenic previously had a confused idea


00:29:03.420 --> 00:29:05.460
"of required versus nullable.


00:29:05.460 --> 00:29:08.200
"This is mostly resulted from Sam's misgivings


00:29:08.200 --> 00:29:10.360
"about marking a field as optional,


00:29:10.360 --> 00:29:12.860
"but requiring a value to be provided to it,


00:29:12.860 --> 00:29:15.140
"but allowing it to be set to none,"


00:29:15.140 --> 00:29:16.740
or something along those lines.


00:29:16.740 --> 00:29:22.460
Anyway, there's minor changes around that.


00:29:22.460 --> 00:29:25.660
Let's see, final one that I wanna cover is namespace stuff.


00:29:25.660 --> 00:29:29.220
This is like a whole bunch of things


00:29:29.220 --> 00:29:30.540
are now getting renamed.


00:29:30.540 --> 00:29:32.980
So for example, if you override,


00:29:32.980 --> 00:29:36.020
if you implemented or overrode validateJSON,


00:29:36.020 --> 00:29:38.180
it's now model_validateJSON.


00:29:38.180 --> 00:29:41.180
If you had isInstance, it's now model isInstance.


00:29:41.180 --> 00:29:44.500
So there's a bunch of these changes all over the place


00:29:44.500 --> 00:29:46.700
that look like they're gonna cause break-in changes.


00:29:46.700 --> 00:29:48.360
They're easy to fix, just change the name,


00:29:48.360 --> 00:29:50.380
but you know, it's not nothing.


00:29:50.380 --> 00:29:52.060
Also, parseFile.


00:29:52.060 --> 00:29:52.900
(laughs)


00:29:52.900 --> 00:29:56.060
I also love his candor here.


00:29:56.060 --> 00:29:57.620
Parse file.


00:29:57.620 --> 00:29:58.460
This was a mistake.


00:29:58.460 --> 00:30:01.420
It should have never been in Pydantic or removing it.


00:30:01.420 --> 00:30:05.940
Parse raw, partially replaced by this other thing.


00:30:05.940 --> 00:30:07.820
Anything else it did was a mistake.


00:30:07.820 --> 00:30:10.620
From ORM, this has been moved somewhere else.


00:30:10.620 --> 00:30:11.640
Schema and so on.


00:30:11.640 --> 00:30:13.160
So you just, like, there's a lot of stuff


00:30:13.160 --> 00:30:14.000
that people were using here.


00:30:14.000 --> 00:30:17.980
So just have a look, try it out.


00:30:17.980 --> 00:30:19.660
Don't just go, oh, then version two's out.


00:30:19.660 --> 00:30:20.500
Is this gonna work?


00:30:20.500 --> 00:30:22.820
Like, this is gonna have some significant changes.


00:30:22.820 --> 00:30:26.220
>> Another reason why it's really awesome that he goes


00:30:26.220 --> 00:30:28.500
through so much detail is because


00:30:28.500 --> 00:30:31.340
there's going to be stuff that breaks.


00:30:31.340 --> 00:30:34.660
It's a breaking interface change.


00:30:34.660 --> 00:30:37.700
It's cool that it's this detailed.


00:30:37.700 --> 00:30:40.140
A couple of things to notice.


00:30:40.140 --> 00:30:44.260
Let's see, somebody else in the chat mentioned,


00:30:44.260 --> 00:30:48.180
Richard mentioned, and he has emojis in the headers.


00:30:48.180 --> 00:30:49.980
Yeah, there's emojis in the headers.


00:30:49.980 --> 00:30:54.980
I gotta say like the navigation in the table of contents,


00:30:54.980 --> 00:30:58.940
very cool, it goes to like light gray


00:30:58.940 --> 00:31:01.200
for areas you've already seen and then--


00:31:01.200 --> 00:31:02.540
- Oh, that's interesting.


00:31:02.540 --> 00:31:04.260
- It's a cool thing, so.


00:31:04.260 --> 00:31:06.180
- Yeah, it's quite cool.


00:31:06.180 --> 00:31:08.700
I've been going on and on, but two real quick things.


00:31:08.700 --> 00:31:12.820
One, there'll be no pure Python implementation of the core.


00:31:12.820 --> 00:31:15.440
It's always Rust, but they list out the platforms


00:31:15.440 --> 00:31:18.060
where it'll be compiled to, including WebAssembly.


00:31:18.060 --> 00:31:19.580
- Oh, nice.


00:31:19.580 --> 00:31:21.720
they previously had some Cython


00:31:21.720 --> 00:31:25.000
in what was supposed to be pure Python's Pydantic.


00:31:25.000 --> 00:31:28.980
And so now, a kind of bonus is the Pydantic model,


00:31:28.980 --> 00:31:32.940
the Pydantic package becomes a pure Python package,


00:31:32.940 --> 00:31:34.420
whereas previously it wasn't.


00:31:34.420 --> 00:31:36.460
So they've taken like all of that behavior


00:31:36.460 --> 00:31:37.660
and put it under this core thing


00:31:37.660 --> 00:31:39.260
that ships as a Rust binary.


00:31:39.260 --> 00:31:42.140
And now instead of doing some Cython middle ground,


00:31:42.140 --> 00:31:43.700
it's pure Python again.


00:31:43.700 --> 00:31:47.300
So that's interesting refactoring, I think.


00:31:47.300 --> 00:31:48.940
- Yeah, yeah.


00:31:48.940 --> 00:31:52.460
And finally, documentation, when you get a validation error,


00:31:52.460 --> 00:31:55.540
it gives you a link to the documentation


00:31:55.540 --> 00:31:57.420
in the JSON error message.


00:31:57.420 --> 00:31:59.020
- That's pretty cool.


00:31:59.020 --> 00:31:59.860
- Yeah.


00:31:59.860 --> 00:32:00.980
- That's nice.


00:32:00.980 --> 00:32:01.800
- All right, yeah.


00:32:01.800 --> 00:32:04.080
Anyway, that's quite a plan, isn't it, Brian?


00:32:04.080 --> 00:32:05.560
- Yeah, quite a plan.


00:32:05.560 --> 00:32:08.660
- All right, well, I'm excited for it.


00:32:08.660 --> 00:32:14.740
- Okay, well, next topic is a little more lighthearted.


00:32:14.740 --> 00:32:16.220
It's about fish.


00:32:17.900 --> 00:32:20.420
Pyke to be specific.


00:32:20.420 --> 00:32:22.160
No, it's about PDFs.


00:32:22.160 --> 00:32:25.860
So there's, it's just a cool project I saw,


00:32:25.860 --> 00:32:28.180
I noticed Pyke PDF.


00:32:28.180 --> 00:32:31.700
It's a Python library for reading and writing PDF files.


00:32:31.700 --> 00:32:32.520
What's the big deal?


00:32:32.520 --> 00:32:35.100
We've had these before, but this is,


00:32:35.100 --> 00:32:40.100
it's based on QPDF, which is a C++ based library.


00:32:40.100 --> 00:32:45.580
And it's presently keep continued being maintained.


00:32:46.420 --> 00:32:48.740
So it's kind of pretty fast.


00:32:48.740 --> 00:32:50.400
Well, actually I'm assuming it's fast


00:32:50.400 --> 00:32:52.100
if it's C++ in the background.


00:32:52.100 --> 00:32:58.260
But it's also pretty just nice and elegant to do things.


00:32:58.260 --> 00:33:03.520
And the documentation has this nice fish, which is good.


00:33:03.520 --> 00:33:07.080
I always like cool diagrams, cool logos.


00:33:07.080 --> 00:33:11.100
But some of the neat things that you can do with it.


00:33:11.100 --> 00:33:13.880
So it's recommending that you not use it


00:33:13.880 --> 00:33:15.900
if you're just writing PDF files,


00:33:15.900 --> 00:33:19.420
that there's other things that you can use,


00:33:19.420 --> 00:33:22.020
what was it, like Report Lab to write PDFs.


00:33:22.020 --> 00:33:24.940
But if you're having to read or modify PDFs,


00:33:24.940 --> 00:33:26.740
then this is where it shines.


00:33:26.740 --> 00:33:30.980
You can do things like copy pages from one PDF to another,


00:33:30.980 --> 00:33:35.260
split and merge PDFs, extract content out of PDFs.


00:33:35.260 --> 00:33:38.740
Like if you're using it for data stuff,


00:33:38.740 --> 00:33:40.420
you get a report in PDF


00:33:40.420 --> 00:33:43.100
and you're trying to pull the information out,


00:33:43.100 --> 00:33:44.820
you can use it for that.


00:33:44.820 --> 00:33:47.500
or images, you can pull all the images out of a PDF file,


00:33:47.500 --> 00:33:49.260
or this is kind of cool,


00:33:49.260 --> 00:33:51.900
you can replace images in a PDF file


00:33:51.900 --> 00:33:54.340
and generate a new one without changing anything else


00:33:54.340 --> 00:33:55.220
about the file.


00:33:55.220 --> 00:33:57.000
It's kind of neat.


00:33:57.000 --> 00:33:59.100
So just kind of a neat,


00:33:59.100 --> 00:34:03.580
if people are working with reading or modifying PDF files,


00:34:03.580 --> 00:34:05.460
maybe check this one out.


00:34:05.460 --> 00:34:06.700
- Yeah, this looks great.


00:34:06.700 --> 00:34:09.740
The fact that it's in C++,


00:34:09.740 --> 00:34:12.140
I'm guessing it's probably standalone.


00:34:12.140 --> 00:34:15.180
I remember I've done some PDF things before


00:34:15.180 --> 00:34:19.020
and it felt like I had to install some OS level thing


00:34:19.020 --> 00:34:21.780
that it shelled out to, so this is cool.


00:34:21.780 --> 00:34:24.620
- Yeah, and the, some,


00:34:24.620 --> 00:34:27.060
nice on the readme, it has a comparison


00:34:27.060 --> 00:34:29.660
of some of the different PDF doc,


00:34:29.660 --> 00:34:32.420
or PDF libraries that you could use.


00:34:32.420 --> 00:34:34.420
And some of the reasons why you might want this one,


00:34:34.420 --> 00:34:36.740
like it supports more versions.


00:34:36.740 --> 00:34:40.020
I didn't realize that, like one of these libraries


00:34:40.020 --> 00:34:42.540
I've heard of before PDF RW,


00:34:42.540 --> 00:34:46.100
doesn't support the newer versions, so bummer.


00:34:46.100 --> 00:34:50.740
And then also password protected files,


00:34:50.740 --> 00:34:53.780
it supports that except for, but not public key ones,


00:34:53.780 --> 00:34:55.540
but just normal passwords.


00:34:55.540 --> 00:34:56.780
- Straight passwords, yeah.


00:34:56.780 --> 00:34:57.800
- Yeah. - That's great.


00:34:57.800 --> 00:34:58.640
- So it's kind of--


00:34:58.640 --> 00:35:02.900
- Also like the measure of actively maintained,


00:35:02.900 --> 00:35:05.820
the commit activity per year over the years.


00:35:05.820 --> 00:35:09.020
- Oh, right, that's kind of interesting.


00:35:09.020 --> 00:35:11.860
Yeah, it's an interesting metric. It seems good. I haven't


00:35:11.860 --> 00:35:16.260
really thought about it lately. But yeah, yeah. Nice. All right.


00:35:16.260 --> 00:35:17.020
Yeah, this is a great one.


00:35:17.020 --> 00:35:18.820
Well, so that's


00:35:18.820 --> 00:35:22.300
it for our main items.


00:35:22.300 --> 00:35:25.100
Yeah, what else you got? Any extras?


00:35:25.100 --> 00:35:30.500
Well, last week, last week, we talked about the, the critical


00:35:30.500 --> 00:35:36.980
packages, or at, at some recent. Yeah, last week, we talked


00:35:36.980 --> 00:35:40.640
about them. Either yesterday or last week, depending on how you


00:35:40.640 --> 00:35:41.260
consume this.


00:35:41.260 --> 00:35:47.540
Yeah, so we I was surprised to find out that pytest check with


00:35:47.540 --> 00:35:50.740
the plugin I wrote was part was one of those I'm like, really?


00:35:50.740 --> 00:35:55.580
Because it's like the top 1%. So I, if anybody's curious, I


00:35:55.580 --> 00:35:58.500
wanted to just highlight that a little bit. So pytest check is a


00:35:58.500 --> 00:36:03.500
plugin that allows multiple failures per test. And in one of


00:36:03.500 --> 00:36:06.660
the best ways I it's a secondary way that one of the


00:36:06.660 --> 00:36:09.900
contributors added is you can use it as a context manager. You


00:36:09.900 --> 00:36:12.980
can say like with check and then do an assert, then you know


00:36:12.980 --> 00:36:14.580
multiple of those within a


00:36:14.580 --> 00:36:16.980
I like the one liner you asked. That's pretty. Yeah.


00:36:16.980 --> 00:36:20.980
And this is totally like black will totally reformat this if you


00:36:20.980 --> 00:36:24.300
ran it through black, but it's nice. You'd have to block it


00:36:24.300 --> 00:36:29.180
out. Anyway. I was like, how could it be? What? Well, I'm


00:36:29.180 --> 00:36:33.420
curious what it what on the list it was. So there's, there's a


00:36:33.440 --> 00:36:37.720
a place called what Hugo,


00:36:37.720 --> 00:36:42.720
Hugo VK has a top IPI packages list and it's updated.


00:36:42.720 --> 00:36:45.260
I think it's just updated once a month or something,


00:36:45.260 --> 00:36:47.400
but you can do the top five.


00:36:47.400 --> 00:36:49.800
You can do the top 5,000.


00:36:49.800 --> 00:36:52.840
Yeah, it's the top 5,000 or 1,000 or 100.


00:36:52.840 --> 00:36:55.320
And so I'm curious,


00:36:55.320 --> 00:36:58.200
was curious about what on the, where on the list I was.


00:36:58.200 --> 00:37:01.280
I'm number 1,677.


00:37:01.280 --> 00:37:03.680
So kind of far down the list, but hey,


00:37:03.680 --> 00:37:07.720
- Hey, it's still in the top third of the top 1%.


00:37:07.720 --> 00:37:09.160
That's pretty awesome.


00:37:09.160 --> 00:37:11.480
- The pytest is number 72.


00:37:11.480 --> 00:37:12.360
That was pretty neat.


00:37:12.360 --> 00:37:14.400
And Pydantic, which we covered was,


00:37:14.400 --> 00:37:18.160
I just checked 117,


00:37:18.160 --> 00:37:20.960
but there are 57 pytest plugins


00:37:20.960 --> 00:37:23.080
that show up in the top 3,500.


00:37:23.080 --> 00:37:25.560
So that's pretty neat.


00:37:25.560 --> 00:37:26.900
- That is pretty neat.


00:37:26.900 --> 00:37:29.200
- That's all I got for extras.


00:37:29.200 --> 00:37:31.080
- All right, well, I have zero extras.


00:37:31.080 --> 00:37:32.680
So mine are finished as well.


00:37:32.680 --> 00:37:34.140
How about a joke?


00:37:34.140 --> 00:37:35.440
- Yeah, great.


00:37:35.440 --> 00:37:38.200
- All right, I told you we're coming back to it.


00:37:38.200 --> 00:37:40.000
So this one comes from Netta,


00:37:40.000 --> 00:37:44.820
Netta Code Girl at netta.mk.


00:37:44.820 --> 00:37:48.240
And let me just pull this one up here, right?


00:37:48.240 --> 00:37:49.220
So this one is,


00:37:49.220 --> 00:37:54.960
there's this colleague here.


00:37:54.960 --> 00:37:56.760
Can I make this, there we go, make it a little bigger.


00:37:56.760 --> 00:37:59.440
There's the two women who are developers,


00:37:59.440 --> 00:38:02.880
Netta and her unnamed friend who always has


00:38:02.880 --> 00:38:06.720
gotten in trouble with the elevator last time, basically.


00:38:06.720 --> 00:38:12.680
And there's this sort of weird manager looking guy


00:38:12.680 --> 00:38:15.080
that comes in and says, "I tested your chatbot,


00:38:15.080 --> 00:38:17.920
but some of its replies are really messed up."


00:38:17.920 --> 00:38:19.960
"Well, that's what testing's all about.


00:38:19.960 --> 00:38:23.000
I'll go through the logs later," says one of the girls.


00:38:23.000 --> 00:38:25.600
"No, no, no, no, no, no, no, no, no need."


00:38:25.600 --> 00:38:26.800
(both laughing)


00:38:26.800 --> 00:38:27.920
Check out the faces.


00:38:28.840 --> 00:38:34.040
Excuse me. I'm not even sure I want to open the logs now. Yeah. Yeah, don't look at the


00:38:34.040 --> 00:38:37.160
That's what testing's for


00:38:37.160 --> 00:38:39.960
I'll go through the logs later


00:38:39.960 --> 00:38:49.000
Well, yeah, she's got some good ones in her list there so love it yeah, I like the art too, nice art


00:38:49.000 --> 00:38:56.840
Also nice was our podcast thanks for being here. Thank you. Yeah, you bet


00:38:58.360 --> 00:38:59.200
See you next week.


00:38:59.200 --> 00:39:00.500
See you next time.


00:39:00.500 --> 00:39:02.140
Thanks everyone who showed up live.


00:39:02.140 --> 00:39:02.560
Bye.

