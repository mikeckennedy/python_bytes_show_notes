WEBVTT

00:00:00.000 --> 00:00:04.000
- Hello, everybody.


00:00:04.000 --> 00:00:05.000
- Hey there.


00:00:05.000 --> 00:00:06.960
- Welcome to the stream.


00:00:06.960 --> 00:00:13.360
And let's just kick off the show.


00:00:13.360 --> 00:00:17.360
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly


00:00:17.360 --> 00:00:18.360
to your earbuds.


00:00:18.360 --> 00:00:23.720
This is episode 259, recorded November 17th, 2021.


00:00:23.720 --> 00:00:24.720
And I'm Brian Okken.


00:00:24.720 --> 00:00:25.720
- I'm Michael Kennedy.


00:00:25.720 --> 00:00:27.400
- And I'm Renee Thi.


00:00:27.400 --> 00:00:29.960
- Well, thanks, Renee, for joining us today.


00:00:29.960 --> 00:00:32.500
Can you tell us a little bit about who you are?


00:00:32.500 --> 00:00:33.660
- Sure.


00:00:33.660 --> 00:00:36.860
I'm the director of data science at Helio Campus.


00:00:36.860 --> 00:00:39.460
And a lot of people know me as Data Science Renee


00:00:39.460 --> 00:00:42.220
or becoming Data Sci on Twitter.


00:00:42.220 --> 00:00:45.220
So that's where a lot of people follow me.


00:00:45.220 --> 00:00:46.940
And then I started with,


00:00:46.940 --> 00:00:49.420
I had a podcast that's not actively recording,


00:00:49.420 --> 00:00:51.780
but it's called Becoming a Data Scientist Podcast.


00:00:51.780 --> 00:00:56.140
So some people listening probably know me from that as well.


00:00:56.140 --> 00:00:56.980
- Cool.


00:00:56.980 --> 00:00:57.800
- Yeah, awesome.


00:00:57.800 --> 00:00:58.640
You were doing a bunch of cool stuff there.


00:00:58.640 --> 00:00:59.920
- Well, Brian makes me show up every week,


00:00:59.920 --> 00:01:00.760
so I don't know what to tell you.


00:01:00.760 --> 00:01:02.640
- Well, yeah, it definitely helps having a partner


00:01:02.640 --> 00:01:05.760
so that you can coerce each other in.


00:01:05.760 --> 00:01:06.600
- That's right.


00:01:06.600 --> 00:01:07.920
- And I think that's a really good thing.


00:01:07.920 --> 00:01:09.240
- Yeah, I think that's a really good thing.


00:01:09.240 --> 00:01:10.080
- Yeah, I think that's a really good thing.


00:01:10.080 --> 00:01:10.920
- Yeah, I think that's a really good thing.


00:01:10.920 --> 00:01:11.760
- Yeah, I think that's a really good thing.


00:01:11.760 --> 00:01:12.580
- Yeah, I think that's a really good thing.


00:01:12.580 --> 00:01:13.420
- Yeah, I think that's a really good thing.


00:01:13.420 --> 00:01:14.260
- Yeah, I think that's a really good thing.


00:01:14.260 --> 00:01:15.080
- Yeah, I think that's a really good thing.


00:01:15.080 --> 00:01:15.920
- Yeah, I think that's a really good thing.


00:01:15.920 --> 00:01:16.760
- Yeah, I think that's a really good thing.


00:01:16.760 --> 00:01:19.760
have hundreds of episodes very consistently recorded.


00:01:19.760 --> 00:01:22.260
- Well, Brian makes me show up every week,


00:01:22.260 --> 00:01:23.100
so I don't know what to tell you.


00:01:23.100 --> 00:01:24.920
- Well, yeah, it definitely helps having a partner


00:01:24.920 --> 00:01:28.220
so that you can coerce each other in.


00:01:28.220 --> 00:01:29.060
- That's right.


00:01:29.060 --> 00:01:32.280
- Well, Michael, speaking of partners.


00:01:32.280 --> 00:01:35.660
- Shall I kick it off?


00:01:35.660 --> 00:01:36.480
- Yeah.


00:01:36.480 --> 00:01:39.620
- Let's talk about some changes, some Pi PI changes.


00:01:39.620 --> 00:01:41.900
These have come to us from Brian Skin.


00:01:41.900 --> 00:01:44.020
Thank you, Brian, for shooting this over.


00:01:44.920 --> 00:01:49.240
And it's a project by Bernay Gabor here.


00:01:49.240 --> 00:01:51.000
And if we pull this up, it says,


00:01:51.000 --> 00:01:54.320
"Have you ever wondered when did your Python packages,


00:01:54.320 --> 00:01:56.520
"the packages in your environment that you have active


00:01:56.520 --> 00:02:00.100
"or any given environment, how old are they?


00:02:00.100 --> 00:02:01.860
"When were they last updated?


00:02:01.860 --> 00:02:04.400
"Is there a version of them that's out of date?"


00:02:04.400 --> 00:02:08.840
So I've been solving this by just forcing them to update


00:02:08.840 --> 00:02:12.320
using pip compile and the pip-tools stuff


00:02:12.320 --> 00:02:17.000
to just regenerate and reinstall the requirements files.


00:02:17.000 --> 00:02:20.880
But this is a way to just ask the question,


00:02:20.880 --> 00:02:21.880
hey, what's the status?


00:02:21.880 --> 00:02:24.400
And it wouldn't be an episode


00:02:24.400 --> 00:02:27.100
if we didn't somehow feature Will McGugan.


00:02:27.100 --> 00:02:31.100
So this is based on Rich, of course.


00:02:31.100 --> 00:02:32.820
So let's go check this thing out.


00:02:32.820 --> 00:02:35.480
So over here, if we go to the homepage,


00:02:35.480 --> 00:02:38.780
we get as all projects should, a nice animation here.


00:02:38.780 --> 00:02:39.620
And if you look at it,


00:02:39.620 --> 00:02:46.100
you see type pypi-changes and you specify the path to a Python in a virtual environment.


00:02:46.100 --> 00:02:51.420
So in this example, it's like pypi-changes vnv/bin/python.


00:02:51.420 --> 00:02:55.700
It does some thinking on the internet, caches some information about the packages,


00:02:55.700 --> 00:02:58.660
and it says, all right, you've got all these things installed.


00:02:58.660 --> 00:03:00.300
They're this version.


00:03:00.300 --> 00:03:05.500
Some of them it'll just say, this was updated 10 months ago or a year and three days ago.


00:03:05.500 --> 00:03:07.980
Others it'll say it was updated a year ago,


00:03:07.980 --> 00:03:11.880
but only six months on the latest version.


00:03:11.880 --> 00:03:13.220
It says remote such and such.


00:03:13.220 --> 00:03:15.540
That's the one you could install if you were to update it.


00:03:15.540 --> 00:03:17.540
So it's a real nice way to see, well,


00:03:17.540 --> 00:03:20.940
which ones are here that could be updated.


00:03:20.940 --> 00:03:24.000
Or even also sometimes it's interesting to know like,


00:03:24.000 --> 00:03:27.060
oh, this library, it doesn't have an update,


00:03:27.060 --> 00:03:28.220
but it's 10 years old.


00:03:28.220 --> 00:03:30.340
Maybe I should consider switching to a library


00:03:30.340 --> 00:03:34.660
that's a little more maintained and making progress, right?


00:03:34.660 --> 00:03:35.660
What do you all think?


00:03:35.660 --> 00:03:36.500
- That's handy.


00:03:36.500 --> 00:03:39.020
- Yeah, cool, right?


00:03:39.020 --> 00:03:40.020
- It is pretty neat.


00:03:40.020 --> 00:03:43.400
- So yeah, I've been playing around with this today,


00:03:43.400 --> 00:03:44.540
installed it, checked it out,


00:03:44.540 --> 00:03:47.180
even pointed out that, you know, since yesterday,


00:03:47.180 --> 00:03:48.980
some things changed in one of my projects


00:03:48.980 --> 00:03:50.060
that I wanna keep up to date.


00:03:50.060 --> 00:03:51.820
So I updated it.


00:03:51.820 --> 00:03:52.780
Yeah, so I like it.


00:03:52.780 --> 00:03:55.300
It's got a nice command line interface.


00:03:55.300 --> 00:03:58.540
You basically specify the Python


00:03:58.540 --> 00:04:00.980
that is in the environment that you wanna check.


00:04:00.980 --> 00:04:02.420
That could either be the main Python


00:04:02.420 --> 00:04:06.100
or a virtual environment Python.


00:04:06.100 --> 00:04:07.940
Like I said, you can control the caching


00:04:07.940 --> 00:04:09.020
'cause the first time it runs,


00:04:09.020 --> 00:04:10.500
it has to go get lots of information


00:04:10.500 --> 00:04:12.300
about each package that's installed


00:04:12.300 --> 00:04:14.140
and it's faster the second time.


00:04:14.140 --> 00:04:15.940
It also has some cool parallelism.


00:04:15.940 --> 00:04:19.420
So you can say number of jobs, like --jobs.


00:04:19.420 --> 00:04:23.300
And by default, it runs 10 downloads in parallel


00:04:23.300 --> 00:04:24.600
as it's pulling this information in,


00:04:24.600 --> 00:04:26.880
but I guess you could go crazy there.


00:04:26.880 --> 00:04:28.740
So anyway, I thought this was pretty cool.


00:04:28.740 --> 00:04:30.540
It's a nice little thing to have.


00:04:30.540 --> 00:04:34.100
So I pipx install this, it's perfect for pipx


00:04:34.100 --> 00:04:38.820
because it doesn't need to be in the project it's testing.


00:04:38.820 --> 00:04:41.060
It just needs to be on your machine as a command


00:04:41.060 --> 00:04:43.060
and then you point it at the environment,


00:04:43.060 --> 00:04:43.900
different environments


00:04:43.900 --> 00:04:46.100
and it gives you reports on those environments.


00:04:46.100 --> 00:04:48.540
- Yeah, I love pipx too.


00:04:48.540 --> 00:04:51.040
One of the things I wanna note,


00:04:51.040 --> 00:04:53.900
just as I know a lot of package maintainers,


00:04:53.900 --> 00:04:57.300
having, I mean, it's worth checking things out


00:04:57.300 --> 00:04:59.860
if it's a really old packet,


00:04:59.860 --> 00:05:01.780
if it hasn't been updated for a long time.


00:05:01.780 --> 00:05:03.380
But some things are pure Python things


00:05:03.380 --> 00:05:05.060
that just do a little tiny thing


00:05:05.060 --> 00:05:06.900
and don't need updated very often.


00:05:06.900 --> 00:05:10.020
- Yeah, it's not necessarily a bad thing


00:05:10.020 --> 00:05:10.860
that it's not updated,


00:05:10.860 --> 00:05:14.380
but it's an indicator of something.


00:05:14.380 --> 00:05:16.840
Yes, exactly.


00:05:16.840 --> 00:05:19.260
Let's see out in the live audience,


00:05:19.260 --> 00:05:20.660
Anthony Lister, hey, says,


00:05:20.660 --> 00:05:22.700
"Can the changes be exported to a text file?"


00:05:22.700 --> 00:05:24.060
I haven't seen anything about that


00:05:24.060 --> 00:05:26.700
other than just piping it into a text file


00:05:26.700 --> 00:05:29.780
and who knows what happens with all the color in there,


00:05:29.780 --> 00:05:31.240
but perhaps.


00:05:31.240 --> 00:05:35.300
Yeah, Renee, what do you do to manage your dependencies


00:05:35.300 --> 00:05:37.080
and all those kinds of things?


00:05:37.080 --> 00:05:40.340
- Well, at work we started using Docker for that.


00:05:40.340 --> 00:05:43.460
So we have a centralized Docker container


00:05:43.460 --> 00:05:44.900
that everyone on my team uses


00:05:44.900 --> 00:05:47.300
and we make sure we have the same setup in there.


00:05:47.300 --> 00:05:50.280
So I'm not the one that directly manages it,


00:05:50.280 --> 00:05:53.180
but that's the solution that we've gone towards


00:05:53.180 --> 00:05:55.140
to make sure we're all on the same page.


00:05:55.140 --> 00:05:55.980
- Oh, interesting.


00:05:55.980 --> 00:05:56.980
So you've got the Docker environment


00:05:56.980 --> 00:05:58.780
that has some version of Python set up


00:05:58.780 --> 00:06:00.920
with all the libraries you need pre-installed


00:06:00.920 --> 00:06:02.700
and then you just use that to run


00:06:02.700 --> 00:06:04.700
and that way you know it's the same.


00:06:04.700 --> 00:06:07.620
- Yep, and then it's also nice because when we kind of move


00:06:07.620 --> 00:06:09.740
our some of our projects into production,


00:06:09.740 --> 00:06:11.580
we can include that Docker container with it.


00:06:11.580 --> 00:06:14.020
So it will have whatever version it had at the time.


00:06:14.020 --> 00:06:15.700
So for some reason it's not compatible


00:06:15.700 --> 00:06:17.980
with some later version we upgraded to,


00:06:17.980 --> 00:06:20.540
it still lives out there with the version of the tools


00:06:20.540 --> 00:06:23.180
that it had until we have a chance to update everything.


00:06:23.180 --> 00:06:24.540
- Sure, that's really cool.


00:06:24.540 --> 00:06:28.500
One of the challenges that people have sometimes


00:06:28.500 --> 00:06:30.720
as they say, even though you've got some kind of version


00:06:30.720 --> 00:06:35.220
management, you know, pyproject.toml or requirements.txt


00:06:35.220 --> 00:06:37.740
or whatever, that doesn't necessarily mean


00:06:37.740 --> 00:06:39.940
that people actually install them, the latest.


00:06:39.940 --> 00:06:41.560
So you could still be out of sync, right?


00:06:41.560 --> 00:06:44.660
So having the image that's constantly the same,


00:06:44.660 --> 00:06:47.380
constantly in sync, that's kind of way to force it.


00:06:47.380 --> 00:06:48.820
Do also want to give a quick shout out


00:06:48.820 --> 00:06:51.620
to this project, pip-deptry.


00:06:51.620 --> 00:06:53.700
Remember, Brian, we spoke about that before,


00:06:53.700 --> 00:06:54.900
which is pretty cool.


00:06:54.900 --> 00:06:57.500
And what it'll show you is, this will show you


00:06:57.500 --> 00:07:00.700
the things you've directly installed


00:07:00.700 --> 00:07:03.300
versus the things that happened to be installed.


00:07:03.300 --> 00:07:05.900
So if we go back to this like animation here,


00:07:05.900 --> 00:07:10.300
you can see that it's got Flask, which is 2.0.2,


00:07:10.300 --> 00:07:13.980
but then it's got Markup Safe, it's got It's Dangerous,


00:07:13.980 --> 00:07:15.900
like nobody installed It's Dangerous.


00:07:15.900 --> 00:07:18.820
That's a thing that was installed because of Flask.


00:07:18.820 --> 00:07:21.360
And so for example, when I look at my environments,


00:07:21.360 --> 00:07:23.100
there were some things that were out of date,


00:07:23.100 --> 00:07:25.140
but they were out of date because they were pinned


00:07:25.140 --> 00:07:28.980
requirements of other things that I actually wanted to install.


00:07:28.980 --> 00:07:33.020
So for example, example, doc opt, and some other things are


00:07:33.020 --> 00:07:36.780
pinned to lower versions. And I can't really update those, but


00:07:36.780 --> 00:07:39.460
they'll show up as outdated. So you might pair this with some


00:07:39.460 --> 00:07:43.100
pip depth tree to see like, what ones are you in control of? And


00:07:43.100 --> 00:07:44.380
what ones are just kind of out there?


00:07:44.380 --> 00:07:50.540
All right, so that's, that's that one. Well, you got it for


00:07:50.540 --> 00:07:50.780
us.


00:07:50.780 --> 00:07:54.860
Well, this is an interesting, there's a discussion about a


00:07:54.860 --> 00:07:58.020
a possible change to future Python.


00:07:58.020 --> 00:08:01.040
Again, this is just stuff that people are discussing.


00:08:01.040 --> 00:08:03.300
It's nothing that's even decided on,


00:08:03.300 --> 00:08:08.300
but it's an idea of late bound arguments for Python,


00:08:08.300 --> 00:08:13.180
for late bound arguments for deep, I don't know,


00:08:13.180 --> 00:08:17.860
late bound argument defaults, that's it for functions.


00:08:17.860 --> 00:08:19.340
So here's the idea.


00:08:19.340 --> 00:08:24.340
So you've got, so we know that if you sign up


00:08:24.340 --> 00:08:28.280
if you assign the default value for a function argument,


00:08:28.280 --> 00:08:32.040
that is bound at definition time.


00:08:32.040 --> 00:08:34.380
So when Python first goes and reads it,


00:08:34.380 --> 00:08:38.140
that seems fine.


00:08:38.140 --> 00:08:41.360
It's a weird thing about the namespace there though.


00:08:41.360 --> 00:08:46.360
So what happens is if you have a variable foo, for instance,


00:08:46.360 --> 00:08:52.700
or a value foo, the value expression can be,


00:08:52.700 --> 00:08:55.940
you can look that up in the defining area.


00:08:55.940 --> 00:08:58.380
So the namespace where the function is defined.


00:08:58.380 --> 00:09:02.100
It's a little specific, but it causes some weirdness.


00:09:02.100 --> 00:09:04.460
It's not the namespace of the function.


00:09:04.460 --> 00:09:07.900
It's the namespace of the surrounding the function.


00:09:07.900 --> 00:09:10.820
The problem with that really is that like, for instance


00:09:10.820 --> 00:09:13.740
if we wanted to do something like a bisect function


00:09:13.740 --> 00:09:18.740
that took, you know, has a, you give it an array


00:09:18.740 --> 00:09:22.160
and maybe an X value for the middle or something.


00:09:22.160 --> 00:09:23.700
We also have a high and low.


00:09:23.700 --> 00:09:26.880
We know the low is index would be zero as a default,


00:09:26.880 --> 00:09:28.760
but what the high should be is,


00:09:28.760 --> 00:09:30.720
should be the length of the array.


00:09:30.720 --> 00:09:33.200
And it's, you can't do that


00:09:33.200 --> 00:09:37.000
because you can't reference the array as a default value.


00:09:37.000 --> 00:09:38.440
So that's what this,


00:09:38.440 --> 00:09:41.320
kind of what this discussion is about


00:09:41.320 --> 00:09:45.520
is trying to figure out a way to possibly have an optional


00:09:45.520 --> 00:09:47.960
late binding of those values.


00:09:47.960 --> 00:09:50.520
And in this specific case,


00:09:50.520 --> 00:09:53.120
to be very helpful to be able to late bind that value,


00:09:53.120 --> 00:09:55.680
like at the time that the function's called,


00:09:55.680 --> 00:09:57.900
not at the time that it's defined.


00:09:57.900 --> 00:09:58.740
And this was--


00:09:58.740 --> 00:10:00.560
- Right, you wanna take the first parameter


00:10:00.560 --> 00:10:02.960
and use it to set the default value


00:10:02.960 --> 00:10:04.800
of the subsequent parameter.


00:10:04.800 --> 00:10:07.000
- Yeah, like to say like the length of the array


00:10:07.000 --> 00:10:10.080
is the default for length or something.


00:10:10.080 --> 00:10:13.840
And that was, who was it?


00:10:13.840 --> 00:10:17.840
Chris Angelico that suggested this.


00:10:17.840 --> 00:10:21.340
And the discussion actually has some people,


00:10:21.340 --> 00:10:24.400
even Guido said, I'm not really opposed to it.


00:10:24.400 --> 00:10:25.960
Let's explore it a little bit.


00:10:25.960 --> 00:10:30.680
So there is some, Chris is trying to do a proof of concept.


00:10:30.680 --> 00:10:34.600
There is some question about what the syntax should be.


00:10:34.600 --> 00:10:38.960
So Chris suggested a equal colon.


00:10:38.960 --> 00:10:42.400
So like the reverse of the walrus operator


00:10:42.400 --> 00:10:44.840
because apparently that's available.


00:10:44.840 --> 00:10:48.920
Another suggestion was equal greater than


00:10:48.920 --> 00:10:50.080
to kind of look like an arrow,


00:10:50.080 --> 00:10:53.760
but we already have like dash arrow to mean something else.


00:10:53.760 --> 00:10:57.540
So up in the air on the syntax, but anyway,


00:10:57.540 --> 00:11:02.520
one of the things I wanted to comment about is the,


00:11:02.520 --> 00:11:06.160
in the article we're linking to,


00:11:06.160 --> 00:11:09.900
it says at first blush Angelico's idea


00:11:09.900 --> 00:11:13.460
to fix this wart in Python seems fairly straightforward,


00:11:13.460 --> 00:11:16.980
but the discussion has shown that there are multiple facets to consider.


00:11:16.980 --> 00:11:17.780
Yeah.


00:11:17.780 --> 00:11:23.780
And it's always tricky to add complexity or to the language. So the, you know,


00:11:23.780 --> 00:11:28.660
the people in the steering council will take it. Think about it.


00:11:28.660 --> 00:11:30.580
Right. Under consideration. Yes.


00:11:30.580 --> 00:11:33.060
Renee, what do you think about this?


00:11:33.060 --> 00:11:40.180
I'm going to be honest, it's going over my head. I don't consider myself like a real software


00:11:40.180 --> 00:11:45.380
So I usually use Python for standard data science type of scripts.


00:11:45.380 --> 00:11:49.140
I'm trying to sit here thinking of a use case for this that I would use and not coming up


00:11:49.140 --> 00:11:50.140
with one.


00:11:50.140 --> 00:11:52.500
Yeah, I'm with you on that one as well.


00:11:52.500 --> 00:11:58.220
This doesn't mean it's a bad idea necessarily.


00:11:58.220 --> 00:12:04.540
One use case would be to be able to set an empty list as a default value.


00:12:04.540 --> 00:12:07.900
We can't do that now because the list is bound.


00:12:07.900 --> 00:12:11.220
All calls to the function will get


00:12:11.220 --> 00:12:14.020
whatever the last function set it to.


00:12:14.020 --> 00:12:15.780
And that's a weirdness in Python,


00:12:15.780 --> 00:12:17.740
but we could probably fix that with this.


00:12:17.740 --> 00:12:18.580
- Yeah, yeah.


00:12:18.580 --> 00:12:19.780
That's what I was thinking as well,


00:12:19.780 --> 00:12:23.700
is if you pass immutable value as the default,


00:12:23.700 --> 00:12:25.580
then you're asking for trouble, right?


00:12:25.580 --> 00:12:27.460
Because if it gets changed anywhere,


00:12:27.460 --> 00:12:31.180
then every subsequent call gets those changes applied to it.


00:12:31.180 --> 00:12:32.220
So that seems useful.


00:12:32.220 --> 00:12:36.220
this sort of flowing one parameter into the next,


00:12:36.220 --> 00:12:40.260
I'm not sure it's worth the complexity.


00:12:40.260 --> 00:12:43.020
So Renee, what I wanted to ask you was,


00:12:43.020 --> 00:12:47.000
as somebody who doesn't dive deep into the low levels


00:12:47.000 --> 00:12:49.500
of the language and compiler, parsing,


00:12:49.500 --> 00:12:51.140
all that kind of stuff, which is totally fine,


00:12:51.140 --> 00:12:53.620
that's like 99% of the people,


00:12:53.620 --> 00:12:55.900
how do you feel about these kinds of new features


00:12:55.900 --> 00:12:56.900
coming along?


00:12:56.900 --> 00:12:58.260
Are you like, oh, geez, now I gotta learn


00:12:58.260 --> 00:13:01.020
the walrus operator, I gotta learn pattern matching,


00:13:01.020 --> 00:13:03.020
I was fine and now I've got to deal with this code.


00:13:03.020 --> 00:13:03.860
What is this?


00:13:03.860 --> 00:13:06.020
Or do you see it as like, oh, awesome, here's new stuff?


00:13:06.020 --> 00:13:07.340
- Yeah, I mean, I guess it depends


00:13:07.340 --> 00:13:09.940
how much it really impacts my day-to-day work.


00:13:09.940 --> 00:13:11.780
If it's something that it's not impacting


00:13:11.780 --> 00:13:13.260
something I use frequently,


00:13:13.260 --> 00:13:16.500
or it's kind of abstracted away from me or optional,


00:13:16.500 --> 00:13:18.800
then go ahead.


00:13:18.800 --> 00:13:21.780
But if it's something that some features they roll out


00:13:21.780 --> 00:13:24.260
clearly have a wide ranging impact


00:13:24.260 --> 00:13:25.720
and you have to go update everything.


00:13:25.720 --> 00:13:28.900
So I'm not great at keeping up with that,


00:13:28.900 --> 00:13:30.100
which is one reason that,


00:13:30.100 --> 00:13:36.020
Of course, you have to be so careful when you update to a new version, but I guess that's


00:13:36.020 --> 00:13:37.860
why people listen to podcasts like this.


00:13:37.860 --> 00:13:39.700
So you know it's potentially coming.


00:13:39.700 --> 00:13:44.140
So you're aware when it does come out, you're on top of it.


00:13:44.140 --> 00:13:46.980
But I don't have strong opinions.


00:13:46.980 --> 00:13:49.860
And what we worry about a lot in data science is the packages, right?


00:13:49.860 --> 00:13:53.980
So not the base Python, but the packages are constantly changing and the dependencies and


00:13:53.980 --> 00:13:54.980
the versions.


00:13:54.980 --> 00:13:57.740
that does end up affecting us


00:13:57.740 --> 00:14:00.060
when it follows through to that level.


00:14:00.060 --> 00:14:05.220
- Yeah, my concern is around teaching Python


00:14:05.220 --> 00:14:08.880
because every new syntax thing you put in


00:14:08.880 --> 00:14:11.860
makes it something that you potentially


00:14:11.860 --> 00:14:13.220
have to teach somebody.


00:14:13.220 --> 00:14:16.520
And maybe you don't have to teach newbies this,


00:14:16.520 --> 00:14:19.140
but they'll see it in code.


00:14:19.140 --> 00:14:21.820
So they should be able to understand what it is.


00:14:21.820 --> 00:14:23.940
So, but on the other hand,


00:14:23.940 --> 00:14:28.460
like things like you can do really crazy comprehensions,


00:14:28.460 --> 00:14:31.180
list comprehensions and stuff, but you don't have to.


00:14:31.180 --> 00:14:33.140
And most of the ones I see are fairly simple ones.


00:14:33.140 --> 00:14:36.060
So I don't think we should nix a phone.


00:14:36.060 --> 00:14:37.620
Nick shouldn't nix something just


00:14:37.620 --> 00:14:41.380
because it can be complicated, but anyway.


00:14:41.380 --> 00:14:42.700
- Yeah, indeed.


00:14:42.700 --> 00:14:43.540
Yeah, good one.


00:14:43.540 --> 00:14:46.180
All right, Renee, you got the next one.


00:14:46.180 --> 00:14:49.420
- All right, so speaking of data science packages,


00:14:49.420 --> 00:14:51.740
a lot of us use pandas.


00:14:51.740 --> 00:14:53.740
So I wrote a book, which I'll come back to later


00:14:53.740 --> 00:14:55.780
called SQL for Data Scientists.


00:14:55.780 --> 00:14:58.820
And since I wrote that and some people


00:14:58.820 --> 00:15:00.780
that have been learning data science in school


00:15:00.780 --> 00:15:04.460
or on the job haven't always used SQL


00:15:04.460 --> 00:15:06.280
or if they use it as kind of a separate process


00:15:06.280 --> 00:15:07.120
from their Python.


00:15:07.120 --> 00:15:08.220
So they started asking me,


00:15:08.220 --> 00:15:10.940
how do you use SQL alongside Python?


00:15:10.940 --> 00:15:13.100
So this is kind of beginner level,


00:15:13.100 --> 00:15:15.660
but also something that's just very useful.


00:15:15.660 --> 00:15:19.940
In the pandas package, there's a read SQL function.


00:15:19.940 --> 00:15:22.540
And so you can read a SQL query.


00:15:22.540 --> 00:15:23.500
It runs the query.


00:15:23.500 --> 00:15:25.800
It's kind of a wrapper around some other functions.


00:15:25.800 --> 00:15:28.600
It will run the query and return the dataset


00:15:28.600 --> 00:15:30.660
into your data frame.


00:15:30.660 --> 00:15:33.240
And so basically you're just running a query


00:15:33.240 --> 00:15:36.000
and the results become the data frame right in your notebook.


00:15:36.000 --> 00:15:39.340
So let's see some of my notes on here.


00:15:39.340 --> 00:15:42.860
So you can save your SQL as a text file.


00:15:42.860 --> 00:15:45.600
So you don't have to have the string in your actual notebook


00:15:45.600 --> 00:15:47.280
which is sometimes useful.


00:15:47.280 --> 00:15:51.000
And then when you import it in from that pandas data frame,


00:15:51.000 --> 00:15:53.440
that's where a lot of people do their data cleaning


00:15:53.440 --> 00:15:55.280
feature engineering and everything like that.


00:15:55.280 --> 00:15:57.520
So you could just pull in the raw data from SQL


00:15:57.520 --> 00:16:00.280
and do a lot of the data engineering there.


00:16:00.280 --> 00:16:02.720
Sometimes I do feature engineering in SQL


00:16:02.720 --> 00:16:03.540
and then pull it in.


00:16:03.540 --> 00:16:05.860
So that's kind of up to each user,


00:16:05.860 --> 00:16:08.880
but you really just set up the connection in your database


00:16:08.880 --> 00:16:10.600
using a package like SQLAlchemy.


00:16:10.600 --> 00:16:13.280
So you have a connection to the database


00:16:13.280 --> 00:16:16.160
and you pass your SQL string either directly


00:16:16.160 --> 00:16:19.520
or from the file and the database connection


00:16:19.520 --> 00:16:21.480
and it returns a pandas data frame.


00:16:23.040 --> 00:16:25.400
So I'm happy to talk a little bit more about,


00:16:25.400 --> 00:16:27.320
you know, how I use this at work.


00:16:27.320 --> 00:16:28.760
- Yeah, I think this is really good.


00:16:28.760 --> 00:16:31.760
You know, one of the things to do with pandas


00:16:31.760 --> 00:16:36.080
is there's just so many of these little functions


00:16:36.080 --> 00:16:38.400
that solve whole problems.


00:16:38.400 --> 00:16:40.280
You know, it's like, oh, you could go


00:16:40.280 --> 00:16:44.720
and use requests to download some HTML


00:16:44.720 --> 00:16:47.320
and then you could use beautiful soup to do some selectors


00:16:47.320 --> 00:16:50.000
and you could get some stuff and parse out some HTML


00:16:50.000 --> 00:16:52.060
and then you could get some table information out


00:16:52.060 --> 00:16:54.300
and then convert that into a data frame.


00:16:54.300 --> 00:16:57.660
Or you could just say read HTML table,


00:16:57.660 --> 00:17:00.060
bracket zero or whatever, and boom, you have it.


00:17:00.060 --> 00:17:03.160
Knowing about these, I think, is really interesting.


00:17:03.160 --> 00:17:04.780
So it's cool that you highlighted this one.


00:17:04.780 --> 00:17:08.700
I actually just, on a side, I'm just literally an hour,


00:17:08.700 --> 00:17:10.660
so probably before this show ships,


00:17:10.660 --> 00:17:15.060
we'll ship this episode I did with Bex Choichiev


00:17:15.060 --> 00:17:17.900
about 25 Panda functions you didn't even know existed.


00:17:17.900 --> 00:17:20.900
And what's interesting is this one wasn't even on the list.


00:17:20.900 --> 00:17:23.980
- So good, so I'll highlight another one,


00:17:23.980 --> 00:17:25.900
now you know the exits.


00:17:25.900 --> 00:17:27.420
- Yeah. - That's pretty cool.


00:17:27.420 --> 00:17:28.860
- Yeah, that's super cool.


00:17:28.860 --> 00:17:31.020
Let's see a couple of comments from the audience.


00:17:31.020 --> 00:17:32.500
Sam Morley, hey Sam, says,


00:17:32.500 --> 00:17:35.540
"Pandas is so amazing, I always find something too late


00:17:35.540 --> 00:17:38.640
"that it has all of these IO functions."


00:17:38.640 --> 00:17:43.120
And then we have Paul, Anzal, hey Paul, says,


00:17:43.120 --> 00:17:45.360
"Do you have any recommendations on tutorials


00:17:45.360 --> 00:17:48.560
"for how to create good SQLAlchemy selectables?


00:17:48.560 --> 00:17:51.200
this always feels like the scariest bit.


00:17:51.200 --> 00:17:52.800
- I don't have any of that on hand.


00:17:52.800 --> 00:17:54.960
I'll try to find something later


00:17:54.960 --> 00:17:57.200
or I'll ask my Twitter following and see what they recommend.


00:17:57.200 --> 00:17:59.760
I don't have a good list of tutorials for that one.


00:17:59.760 --> 00:18:03.280
I can talk about, yeah, by selectable,


00:18:03.280 --> 00:18:05.360
he said he means connectable.


00:18:05.360 --> 00:18:08.480
So yeah, I don't have a tutorial for that.


00:18:08.480 --> 00:18:09.560
There's a lot of documentation


00:18:09.560 --> 00:18:11.240
and I know that SQLAlchemy


00:18:11.240 --> 00:18:13.400
can be a little mysterious sometimes.


00:18:13.400 --> 00:18:14.900
Maybe that's why it's alchemy.


00:18:16.160 --> 00:18:19.960
But yeah, I will try to share that later on Twitter.


00:18:19.960 --> 00:18:21.720
- Yeah, fantastic.


00:18:21.720 --> 00:18:23.080
All right, and Paul says,


00:18:23.080 --> 00:18:25.120
"A read clipboard is pretty great."


00:18:25.120 --> 00:18:26.360
Interesting. - Yeah.


00:18:26.360 --> 00:18:27.200
- Yeah, very cool.


00:18:27.200 --> 00:18:29.040
But a bunch of different things there.


00:18:29.040 --> 00:18:30.800
- Yeah, so if you want me to walk through an example


00:18:30.800 --> 00:18:32.320
of how I use this at work, I'm happy to do that.


00:18:32.320 --> 00:18:34.960
- Yeah, give us a quick sample and then...


00:18:34.960 --> 00:18:37.080
- Yeah, so at Helio Campus,


00:18:37.080 --> 00:18:38.400
one thing we do is we connect


00:18:38.400 --> 00:18:41.280
to a lot of different databases at universities.


00:18:41.280 --> 00:18:43.680
So the universities will have separate databases


00:18:43.680 --> 00:18:47.160
for admissions, enrollment, financial aid,


00:18:47.160 --> 00:18:48.640
those are all separate systems.


00:18:48.640 --> 00:18:51.360
And so we pull all that data into a data warehouse


00:18:51.360 --> 00:18:53.880
and in SQL, we can combine that data,


00:18:53.880 --> 00:18:56.960
build some extracts that we're all using the same way.


00:18:56.960 --> 00:18:59.520
And so we can either use this to just read


00:18:59.520 --> 00:19:01.560
one of those tables directly,


00:19:01.560 --> 00:19:03.680
or we can combine, what I typically do


00:19:03.680 --> 00:19:07.080
is do a little bit of a cleanup and feature engineering


00:19:07.080 --> 00:19:09.180
and narrow down my dataset to the population


00:19:09.180 --> 00:19:11.960
that I want to run through my model in SQL


00:19:11.960 --> 00:19:13.640
and then just pull those final results.


00:19:13.640 --> 00:19:15.200
And now I've got my data set


00:19:15.200 --> 00:19:17.040
with at least preliminary features.


00:19:17.040 --> 00:19:18.620
I might do some standardization


00:19:18.620 --> 00:19:20.080
and things like that in pandas,


00:19:20.080 --> 00:19:23.400
but I've got a pretty clean and subset


00:19:23.400 --> 00:19:27.280
of the data that I need right into my Jupyter notebook.


00:19:27.280 --> 00:19:28.440
- Oh, that's fantastic.


00:19:28.440 --> 00:19:30.200
- Pretty great.


00:19:30.200 --> 00:19:32.760
- Yeah, I think definitely understanding SQL


00:19:32.760 --> 00:19:35.400
is an important skill for data scientists.


00:19:35.400 --> 00:19:38.760
And it's slightly different than for say,


00:19:38.760 --> 00:19:41.200
like a web API developer, right?


00:19:41.200 --> 00:19:43.280
- Absolutely, that's why I wrote the book.


00:19:43.280 --> 00:19:44.640
- That's awesome, yeah, for sure.


00:19:44.640 --> 00:19:48.820
So on the API side, you kind of get something set up,


00:19:48.820 --> 00:19:51.600
you're very likely using an ORM like SQLAlchemy


00:19:51.600 --> 00:19:53.240
and you just connect it and go.


00:19:53.240 --> 00:19:54.080
And once you get it set,


00:19:54.080 --> 00:19:55.600
like you can kind of forget about it


00:19:55.600 --> 00:19:56.960
and just program against it.


00:19:56.960 --> 00:19:58.840
As a data scientist, you're exploring,


00:19:58.840 --> 00:19:59.960
you don't totally know, right?


00:19:59.960 --> 00:20:03.200
You're kind of out there testing and digging into stuff


00:20:03.200 --> 00:20:04.740
and sorting and filtering.


00:20:04.740 --> 00:20:06.600
And yeah, I think you need,


00:20:06.600 --> 00:20:09.800
I would say you probably need a better fluency with SQL


00:20:09.800 --> 00:20:11.640
as a data scientist a lot of times


00:20:11.640 --> 00:20:12.680
than as a web developer.


00:20:12.680 --> 00:20:14.400
'Cause I can just use an ORM or ODM


00:20:14.400 --> 00:20:17.520
and just kind of know what it's doing.


00:20:17.520 --> 00:20:19.880
- Yeah, and it enables you to build your own data sets


00:20:19.880 --> 00:20:21.680
instead of relying on a data engineering


00:20:21.680 --> 00:20:23.840
trying to explain what you need and why


00:20:23.840 --> 00:20:24.800
and which fields you need.


00:20:24.800 --> 00:20:26.060
Now you could just do it yourself


00:20:26.060 --> 00:20:28.640
or add a field if you need it.


00:20:28.640 --> 00:20:31.240
You can do more sophisticated things like window functions.


00:20:31.240 --> 00:20:34.800
So yeah, I think knowing SQL is really a value add


00:20:34.800 --> 00:20:37.000
if you're looking to become a data scientist


00:20:37.000 --> 00:20:39.400
and putting yourself out there on the market.


00:20:39.400 --> 00:20:41.920
if you can do the whole pipeline end to end,


00:20:41.920 --> 00:20:43.360
it definitely makes you stand out.


00:20:43.360 --> 00:20:44.400
- I would think so.


00:20:44.400 --> 00:20:46.280
All right, one thing to wrap up on this.


00:20:46.280 --> 00:20:48.680
Sam asks, "Can you configure SQLAlchemy


00:20:48.680 --> 00:20:51.020
to dump the raw queries that it runs?"


00:20:51.020 --> 00:20:52.000
Yes.


00:20:52.000 --> 00:20:53.400
- Yeah, in this case,


00:20:53.400 --> 00:20:56.020
you have the raw query in your function call.


00:20:56.020 --> 00:20:59.520
So I'm not actually using SQLAlchemy for that


00:20:59.520 --> 00:21:00.360
'cause I'm providing the query.


00:21:00.360 --> 00:21:01.240
- Yeah, you just got a select statement, right?


00:21:01.240 --> 00:21:03.640
The problem with SQLAlchemy and data science


00:21:03.640 --> 00:21:06.420
is you have to, the structure of your models


00:21:06.420 --> 00:21:08.640
has to exactly match the structure of the data.


00:21:08.640 --> 00:21:11.160
And often, I imagine you're just kind of dealing


00:21:11.160 --> 00:21:12.800
with loose data and it doesn't make sense


00:21:12.800 --> 00:21:15.720
to take the time to like model it in classes.


00:21:15.720 --> 00:21:18.040
But for SQLAlchemy, you can just set echo equal true


00:21:18.040 --> 00:21:18.960
when you create the engine,


00:21:18.960 --> 00:21:20.560
and then everything that would get sent


00:21:20.560 --> 00:21:22.840
to the crossover to the database gets echoed


00:21:22.840 --> 00:21:26.780
as like DDL or SQL or whatever that it does.


00:21:26.780 --> 00:21:27.880
So yes.


00:21:27.880 --> 00:21:29.120
- Good, good info. - Cool, sure.


00:21:29.120 --> 00:21:29.960
- Yeah.


00:21:29.960 --> 00:21:32.520
All right.


00:21:32.520 --> 00:21:35.200
Brian, want to tell us about our sponsor?


00:21:35.200 --> 00:21:36.040
- Yeah, let's.


00:21:37.720 --> 00:21:40.640
I am pleased and happy to that Shortcut


00:21:40.640 --> 00:21:42.080
is sponsoring the episode.


00:21:42.080 --> 00:21:44.920
So thank you Shortcut, formerly Clubhouse


00:21:44.920 --> 00:21:46.600
for sponsoring the episode.


00:21:46.600 --> 00:21:48.560
There are a lot of project management tools out there


00:21:48.560 --> 00:21:51.160
but most suffer from common problems


00:21:51.160 --> 00:21:54.320
like it's too simple for an engineering team to use


00:21:54.320 --> 00:21:57.340
on several projects or it's too complex


00:21:57.340 --> 00:22:01.100
and it's hard to get started and there's tons of options.


00:22:01.100 --> 00:22:03.140
And some of them are great for managers


00:22:03.140 --> 00:22:05.320
but bad for engineers and some are great for engineers


00:22:05.320 --> 00:22:06.460
and bad for managers.


00:22:06.460 --> 00:22:08.060
Shortcut is different.


00:22:08.060 --> 00:22:10.480
It's built for software teams


00:22:10.480 --> 00:22:13.660
and based on making workflows super easy.


00:22:13.660 --> 00:22:15.940
For example, keyboard friendly user interface,


00:22:15.940 --> 00:22:19.300
the UI is intuitive for mouse lovers, of course,


00:22:19.300 --> 00:22:21.980
but the activities that you use every day


00:22:21.980 --> 00:22:25.500
can be set to keyboard shortcuts if they aren't already.


00:22:25.500 --> 00:22:29.460
Just learn them and you'll start working faster.


00:22:29.460 --> 00:22:30.720
It's awesome.


00:22:30.720 --> 00:22:32.100
Tight VCS integration,


00:22:32.100 --> 00:22:34.820
so you can update tasks, progress, and commits


00:22:34.820 --> 00:22:36.220
with a commit or a PR.


00:22:36.220 --> 00:22:37.380
That's sweet.


00:22:37.380 --> 00:22:40.060
And iteration planning is a breeze.


00:22:40.060 --> 00:22:42.300
I like that there's a burndown


00:22:42.300 --> 00:22:43.820
and cycle time charts built in.


00:22:43.820 --> 00:22:45.380
They just are set up already for you


00:22:45.380 --> 00:22:47.060
when you start using this.


00:22:47.060 --> 00:22:49.540
So it's a pretty clean system.


00:22:49.540 --> 00:22:52.840
Give it a try at shortcut.com/pythonbytes.


00:22:52.840 --> 00:22:54.660
- Yeah, absolutely.


00:22:54.660 --> 00:22:56.740
Thanks shortcut for sponsoring this episode.


00:22:56.740 --> 00:23:00.520
Now, what have we got next here?


00:23:00.520 --> 00:23:03.100
Pigeon, I wanna talk about Pigeon.


00:23:03.980 --> 00:23:08.980
So, we already talked about Wilma Gugin and Rich,


00:23:08.980 --> 00:23:11.260
so it's time to talk about Anthony Shaw


00:23:11.260 --> 00:23:13.700
so that we can complete our shout outs


00:23:13.700 --> 00:23:16.820
we always seem to give over on the podcast.


00:23:16.820 --> 00:23:18.680
So, I wanna talk about Pidgin


00:23:18.680 --> 00:23:20.420
because I just interviewed Anthony Shaw,


00:23:20.420 --> 00:23:25.420
but more importantly, he just released Pidgin as 1.0.


00:23:25.420 --> 00:23:29.820
So Pidgin is a drop-in JIT compiler for Python 3.10.


00:23:29.820 --> 00:23:31.580
Let me say that again,


00:23:31.580 --> 00:23:35.220
a legit compiler for Python.


00:23:35.220 --> 00:23:39.140
And there've been other speed up type of attempts


00:23:39.140 --> 00:23:41.660
where people will like fork CPython


00:23:41.660 --> 00:23:45.180
and they'll do something inside of it to make it different.


00:23:45.180 --> 00:23:46.420
Think Cinder.


00:23:46.420 --> 00:23:48.660
There've been attempts to create a totally different


00:23:48.660 --> 00:23:52.500
but compatible one like PyPy, P-Y-P-Y.


00:23:52.500 --> 00:23:58.780
And that's, they've worked pretty well


00:23:58.780 --> 00:24:00.780
but they always have some sort of incompatibility


00:24:00.780 --> 00:24:03.880
It would be nice if just the Python you ran


00:24:03.880 --> 00:24:07.840
could be compiled to go faster if you want it to be.


00:24:07.840 --> 00:24:09.080
So that's what this is.


00:24:09.080 --> 00:24:11.320
It uses a PEP whose number I forgot


00:24:11.320 --> 00:24:13.000
that allows you to plug in something


00:24:13.000 --> 00:24:17.700
that inspects the method frames before they get executed.


00:24:17.700 --> 00:24:22.080
And then instead of just interpreting that code,


00:24:22.080 --> 00:24:24.680
the bytecode as Python bytecode,


00:24:24.680 --> 00:24:28.200
it'll actually compile it to machine instructions,


00:24:28.200 --> 00:24:31.400
first to .NET intermediate instructions,


00:24:31.400 --> 00:24:33.280
intermediate language, and then those get compiled


00:24:33.280 --> 00:24:36.580
to machine instructions that then run directly.


00:24:36.580 --> 00:24:42.420
Works on Linux, macOS, Windows, x64, and ARM64.


00:24:42.420 --> 00:24:44.700
So this is a pretty cool development.


00:24:44.700 --> 00:24:47.980
- It is pretty cool.


00:24:47.980 --> 00:24:51.780
- Yeah, so if we go over here and check it out,


00:24:51.780 --> 00:24:54.200
in order to use it, it has some requirements.


00:24:54.200 --> 00:24:56.140
You just pip install pigeon, that's it.


00:24:57.900 --> 00:24:58.900
That's crazy, right?


00:24:58.900 --> 00:25:01.420
And then it has to be on 3.10, it can't be older than that.


00:25:01.420 --> 00:25:05.220
And you have to have .NET 6 installed.


00:25:05.220 --> 00:25:07.020
Okay, so that just got released.


00:25:07.020 --> 00:25:10.140
It's a good chance you don't have .NET 6 installed.


00:25:10.140 --> 00:25:11.660
But then once you set it up right,


00:25:11.660 --> 00:25:13.940
you can just say import pigeon, pigeon.enable


00:25:13.940 --> 00:25:15.300
at the startup of your app,


00:25:15.300 --> 00:25:17.520
and then it will look at all the methods


00:25:17.520 --> 00:25:18.580
and JIT compile them.


00:25:18.580 --> 00:25:22.900
So if you come down here,


00:25:22.900 --> 00:25:25.380
like he has an example of a half function


00:25:25.380 --> 00:25:27.220
that Anthony put up here.


00:25:27.220 --> 00:25:31.460
And when it first loads, it's not JIT compiled,


00:25:31.460 --> 00:25:33.940
but after that, you can go and say,


00:25:33.940 --> 00:25:36.060
if you run it, you can say disassemble this thing


00:25:36.060 --> 00:25:41.060
and it'll show you basically assembly instructions


00:25:41.060 --> 00:25:44.180
of what would have otherwise been Python code.


00:25:44.180 --> 00:25:46.460
- Wow.


00:25:46.460 --> 00:25:47.600
- It's wild, right?


00:25:47.600 --> 00:25:51.220
So it's a little bit like Numba,


00:25:51.220 --> 00:25:55.260
it's a little bit like, a tiny bit like Cython


00:25:55.260 --> 00:25:57.300
in the sense that it takes Python code,


00:25:57.300 --> 00:25:58.740
translates it into something else


00:25:58.740 --> 00:26:00.580
that then can be interoperated with,


00:26:00.580 --> 00:26:01.920
and then makes it go fast.


00:26:01.920 --> 00:26:04.860
So this is all well and good.


00:26:04.860 --> 00:26:07.260
If you're gonna use it on the web,


00:26:07.260 --> 00:26:08.740
by default it would be just fine,


00:26:08.740 --> 00:26:11.340
except if you're hosting it,


00:26:11.340 --> 00:26:15.580
normally you host it in this like supervisor process


00:26:15.580 --> 00:26:17.340
and then a bunch of forked off processes.


00:26:17.340 --> 00:26:20.660
So there's a WSGI app configuration thing


00:26:20.660 --> 00:26:22.740
you can do as well, somewhere in the docs.


00:26:22.740 --> 00:26:23.580
I'm not seeing it right now,


00:26:23.580 --> 00:26:28.580
but you basically allow it to push the pigeon changes


00:26:28.580 --> 00:26:32.300
on down into the worker processes, which is pretty cool.


00:26:32.300 --> 00:26:34.780
And it has a bunch of comparisons against PyPy,


00:26:34.780 --> 00:26:37.500
Piston, Numba, IronPython, et cetera,


00:26:37.500 --> 00:26:41.720
Nuti, Nutca, and so on.


00:26:41.720 --> 00:26:45.180
Now it's not that much faster.


00:26:45.180 --> 00:26:47.020
It is faster when you're doing more like


00:26:47.020 --> 00:26:49.280
data science-y things, I believe,


00:26:49.280 --> 00:26:52.140
than if you're doing just like a query against a database


00:26:52.140 --> 00:26:54.420
where you're mostly just waiting anyway.


00:26:54.420 --> 00:26:56.140
But still, I think this is promising


00:26:56.140 --> 00:26:57.540
and it's really pretty early days.


00:26:57.540 --> 00:26:59.860
So the thing to look at


00:26:59.860 --> 00:27:06.260
is if there's optimizations coming along here somewhere


00:27:06.260 --> 00:27:07.280
in the docs,


00:27:07.280 --> 00:27:10.580
Anthony lists out the various optimizations


00:27:10.580 --> 00:27:11.620
he's put in so far,


00:27:11.620 --> 00:27:13.980
and really it just needs more optimizations


00:27:13.980 --> 00:27:16.500
to make it faster still,


00:27:16.500 --> 00:27:18.260
which is pretty neat.


00:27:18.260 --> 00:27:21.620
- I think that's pretty cool.


00:27:21.620 --> 00:27:25.600
The, one of the things that my first reaction was,


00:27:25.600 --> 00:27:28.440
oh, it's .NET only, so I have to use it on Windows.


00:27:28.440 --> 00:27:31.700
But that's not been that way for a long time.


00:27:31.700 --> 00:27:33.840
So .NET runs on just about everything.


00:27:33.840 --> 00:27:34.680
- Yeah, exactly.


00:27:34.680 --> 00:27:36.120
It supports all the different frameworks.


00:27:36.120 --> 00:27:39.240
There's even this thing called live.trypigeon.com


00:27:39.240 --> 00:27:41.560
where you can write Python code like


00:27:41.560 --> 00:27:50.200
here on the left, and then you can say compile it


00:27:51.520 --> 00:27:54.520
And it will actually show you the assembly


00:27:54.520 --> 00:27:55.520
that it would compile to.


00:27:55.520 --> 00:27:59.440
And then here's the .NET intermediate language.


00:27:59.440 --> 00:28:01.040
I guess maybe they should possibly


00:28:01.040 --> 00:28:02.520
be switching orders here.


00:28:02.520 --> 00:28:04.880
First it goes to IL, and then it goes to machine instructions


00:28:04.880 --> 00:28:05.560
through the JIT.


00:28:05.560 --> 00:28:08.840
But it shows you all the stuff that it's


00:28:08.840 --> 00:28:09.880
doing to make this work.


00:28:09.880 --> 00:28:11.380
And you can even see at the bottom,


00:28:11.380 --> 00:28:15.120
there's a visual understanding of what it's doing.


00:28:15.120 --> 00:28:17.120
One of the things that's really cool that it does


00:28:17.120 --> 00:28:20.640
is imagine you've got a math problem up here.


00:28:20.640 --> 00:28:25.640
you're saying like, X equals Y times Y


00:28:25.640 --> 00:28:29.160
plus Z times Z, or something like that.


00:28:29.160 --> 00:28:31.000
Like each one of those steps


00:28:31.000 --> 00:28:33.600
generates an intermediate number.


00:28:33.600 --> 00:28:36.840
So for example, Z times Z would generate a,


00:28:36.840 --> 00:28:40.000
by default, a Python number.


00:28:40.000 --> 00:28:41.640
And then so would Y times Y,


00:28:41.640 --> 00:28:43.980
and then the addition, and finally you assign it.


00:28:43.980 --> 00:28:45.480
What it'll do is it'll say,


00:28:45.480 --> 00:28:47.640
well, okay, if those are two floats,


00:28:47.640 --> 00:28:49.560
let's just store that as a C float.


00:28:50.600 --> 00:28:52.060
in the intermediate computation,


00:28:52.060 --> 00:28:53.420
and then that's as a C flow.


00:28:53.420 --> 00:28:55.960
And so it can sort of stay lower level


00:28:55.960 --> 00:28:58.460
as it's doing a lot of computational type of things.


00:28:58.460 --> 00:29:00.160
So there's a bunch of interesting optimizations.


00:29:00.160 --> 00:29:01.040
People can check this out.


00:29:01.040 --> 00:29:02.440
I haven't had a chance to try it yet.


00:29:02.440 --> 00:29:05.060
I was hoping to, but haven't got there yet.


00:29:05.060 --> 00:29:06.480
- Yeah, really interesting conversation


00:29:06.480 --> 00:29:07.800
you had with him too.


00:29:07.800 --> 00:29:08.640
- Thanks.


00:29:08.640 --> 00:29:11.020
- And it's interesting timing


00:29:11.020 --> 00:29:12.420
to just get him to jump on this.


00:29:12.420 --> 00:29:16.400
Like right after he wrote the book on Python internals,


00:29:16.400 --> 00:29:19.200
CPython internals, to jump into this.


00:29:19.200 --> 00:29:22.740
- Right, well, I guess he's working on it before, but still.


00:29:22.740 --> 00:29:25.260
- Yeah, you definitely got to know CPython internals


00:29:25.260 --> 00:29:26.160
to do this.


00:29:26.160 --> 00:29:30.840
Renee, do you guys do anything to optimize your code


00:29:30.840 --> 00:29:34.060
with like Numba or Cython or anything like that?


00:29:34.060 --> 00:29:35.860
Or are you just running straight Python


00:29:35.860 --> 00:29:37.640
and letting the libraries deal with it?


00:29:37.640 --> 00:29:39.220
- Yeah, not currently.


00:29:39.220 --> 00:29:41.420
We have a pretty good server


00:29:41.420 --> 00:29:43.780
and are working with relatively small data sets,


00:29:43.780 --> 00:29:46.540
you know, not millions of rows, for example.


00:29:46.540 --> 00:29:50.040
So for right now, we haven't gone in this direction at all.


00:29:50.040 --> 00:29:52.180
I can imagine this would also be really useful


00:29:52.180 --> 00:29:54.000
if you were a computer science student


00:29:54.000 --> 00:29:56.560
and trying to understand what's going on under the hood


00:29:56.560 --> 00:29:57.420
when you run these things.


00:29:57.420 --> 00:29:59.240
So it's interesting that it's,


00:29:59.240 --> 00:30:01.160
for the people that aren't seeing the visual,


00:30:01.160 --> 00:30:02.560
you've kind of have three columns here


00:30:02.560 --> 00:30:06.080
with the code side by side to kind of get a peek


00:30:06.080 --> 00:30:07.560
under the hood at what's going on there.


00:30:07.560 --> 00:30:09.760
But no, this isn't something I've used personally.


00:30:09.760 --> 00:30:10.600
- Yeah, yeah.


00:30:10.600 --> 00:30:13.080
I haven't used it either, but like I said, I would like to.


00:30:13.080 --> 00:30:16.440
I think it's got the ability to just plug in


00:30:16.440 --> 00:30:17.640
and make things faster.


00:30:17.640 --> 00:30:20.400
And really, it is faster to some degree.


00:30:20.400 --> 00:30:22.840
Sometimes I think it's slower, sometimes faster.


00:30:22.840 --> 00:30:26.680
But the more optimizations the JIT compiler gets,


00:30:26.680 --> 00:30:28.320
the better it could be, right?


00:30:28.320 --> 00:30:32.200
So like, if it could inline function calls


00:30:32.200 --> 00:30:35.080
rather than calling them, or it could,


00:30:35.080 --> 00:30:39.560
there's things like if it sees you allocating a list


00:30:39.560 --> 00:30:40.820
and putting stuff into it,


00:30:40.820 --> 00:30:43.160
it can skip some intermediate steps


00:30:43.160 --> 00:30:44.440
and just straight allocate that.


00:30:44.440 --> 00:30:47.240
or if you're doing accessing elements by index


00:30:47.240 --> 00:30:49.520
out of the list, it can just do pointer operations


00:30:49.520 --> 00:30:51.920
instead of going through the Python APIs.


00:30:51.920 --> 00:30:56.040
There's a lot of hard work that Anthony's put into this


00:30:56.040 --> 00:30:57.580
and I think it's pretty cool.


00:30:57.580 --> 00:31:01.160
Yeah, I haven't tried it, would like to.


00:31:01.160 --> 00:31:03.360
Yeah.


00:31:03.360 --> 00:31:04.760
- Cool.


00:31:04.760 --> 00:31:07.080
- Indeed, all right, Brian, what do you got for us?


00:31:07.080 --> 00:31:09.200
- Well, actually, before I jump to the next topic,


00:31:09.200 --> 00:31:10.120
I wanted to mention,


00:31:10.120 --> 00:31:12.520
I wanted to shoo into this last conversation.


00:31:13.680 --> 00:31:18.380
Brett Cannon just wrote a interesting article


00:31:18.380 --> 00:31:20.040
called "Selecting a Programming Language


00:31:20.040 --> 00:31:22.760
"Can Be a Form of Premature Optimization."


00:31:22.760 --> 00:31:25.440
And this is relevant to the conversation


00:31:25.440 --> 00:31:28.520
because the real steps, he says,


00:31:28.520 --> 00:31:30.800
if you think Python might be too slow,


00:31:30.800 --> 00:31:36.220
another implementation like Pidgin is like step three.


00:31:36.220 --> 00:31:38.480
So first prototype in Python,


00:31:38.480 --> 00:31:40.640
then optimize your data structures and algorithms


00:31:40.640 --> 00:31:43.360
and also like, you know, profile it.


00:31:43.360 --> 00:31:44.440
- Yeah.


00:31:44.440 --> 00:31:46.480
- And then try another implementation


00:31:46.480 --> 00:31:49.240
before you've banned a Python altogether.


00:31:49.240 --> 00:31:51.600
And then, you can do some late bindings


00:31:51.600 --> 00:31:54.560
like language bindings to connect to C


00:31:54.560 --> 00:31:56.600
if you need to or Rust.


00:31:56.600 --> 00:31:59.200
But I think it ties in as like,


00:31:59.200 --> 00:32:04.120
when would I choose Pigeon or PyPI over CPython?


00:32:04.120 --> 00:32:07.000
Well, it's step three, just to let people know.


00:32:07.000 --> 00:32:09.600
- Step three, got it.


00:32:09.600 --> 00:32:11.000
- Step three.


00:32:11.000 --> 00:32:12.680
I wanted to do something more lighthearted


00:32:12.680 --> 00:32:15.420
like use print for debugging.


00:32:15.420 --> 00:32:17.440
So I love this article.


00:32:17.440 --> 00:32:18.940
I am guilty of this.


00:32:18.940 --> 00:32:23.160
Of course I use debuggers and logging systems as well


00:32:23.160 --> 00:32:26.800
but I also throw print statements in there sometimes


00:32:26.800 --> 00:32:29.340
and I'm not ashamed to say it.


00:32:29.340 --> 00:32:32.720
So Adam Johnson wrote tips for debugging the print


00:32:32.720 --> 00:32:34.720
and there were a couple that with print,


00:32:34.720 --> 00:32:36.200
there were a couple that stood out to me.


00:32:36.200 --> 00:32:39.520
I really wanted to mention, 'cause I use them a lot.


00:32:39.520 --> 00:32:43.940
even with logging though, is use debug variables


00:32:43.940 --> 00:32:46.240
with f-strings and the equal sign.


00:32:46.240 --> 00:32:49.180
So this is brilliant.


00:32:49.180 --> 00:32:50.480
It's been in since 3.8.


00:32:50.480 --> 00:32:55.080
Instead of typing like a print widget equals


00:32:55.080 --> 00:32:57.600
and then in a string and then the widget number


00:32:57.600 --> 00:33:00.840
or something, you can just use the f-strings


00:33:00.840 --> 00:33:03.500
and do the equal sign and it interpolates for you.


00:33:03.500 --> 00:33:06.300
Or it doesn't interpolate, it just prints it for you.


00:33:06.300 --> 00:33:07.540
So it's nice.


00:33:07.540 --> 00:33:08.380
I like that.


00:33:09.420 --> 00:33:13.100
The next one is, I love this, use emojis.


00:33:13.100 --> 00:33:14.240
I never thought to do this.


00:33:14.240 --> 00:33:15.540
This is brilliant.


00:33:15.540 --> 00:33:18.020
Throw emojis in your print statements


00:33:18.020 --> 00:33:22.020
so that they pop out when you're debugging.


00:33:22.020 --> 00:33:22.860
- Yeah, this is cool.


00:33:22.860 --> 00:33:26.300
I started using emojis in comments.


00:33:26.300 --> 00:33:27.420
- Oh, okay.


00:33:27.420 --> 00:33:28.300
Comments, nice.


00:33:28.300 --> 00:33:31.380
- Yeah, so I'll put like the different emojis mean,


00:33:31.380 --> 00:33:32.800
for me, I was doing some API stuff.


00:33:32.800 --> 00:33:35.580
So like, this is the read-only method here of an API.


00:33:35.580 --> 00:33:37.220
So I'll put a certain emoji up there.


00:33:37.220 --> 00:33:38.740
And this is one that changes data.


00:33:38.740 --> 00:33:40.580
So here's, so I'll put there,


00:33:40.580 --> 00:33:42.780
here's one that returns a list versus a single thing.


00:33:42.780 --> 00:33:46.020
So I'll put a whole bunch of those emojis and stuff.


00:33:46.020 --> 00:33:48.180
- Yeah, well, I mean, I used to do like a whole bunch


00:33:48.180 --> 00:33:50.220
of plus signs 'cause they're easy to see.


00:33:50.220 --> 00:33:51.060
- Yeah.


00:33:51.060 --> 00:33:52.420
- But an emoji would be way easier to see.


00:33:52.420 --> 00:33:53.540
- It's way more fun, man.


00:33:53.540 --> 00:33:54.380
- Yeah.


00:33:54.380 --> 00:33:55.220
- Yeah.


00:33:55.220 --> 00:33:56.040
- Yeah, I do this as well.


00:33:56.040 --> 00:33:57.380
I print all the time for debugging,


00:33:57.380 --> 00:33:58.940
especially in Jupyter notebooks,


00:33:58.940 --> 00:34:01.180
because you don't always have the most sophisticated


00:34:01.180 --> 00:34:02.300
debugging tools in there,


00:34:02.300 --> 00:34:05.300
but being able to print and see what's going on


00:34:05.300 --> 00:34:07.180
as you go through each step of the notebook


00:34:07.180 --> 00:34:09.520
And emojis are a great idea for that


00:34:09.520 --> 00:34:11.500
because it's so visual as you're scrolling through.


00:34:11.500 --> 00:34:13.500
You want to like, they're showing there the X


00:34:13.500 --> 00:34:14.600
and the check mark emoji.


00:34:14.600 --> 00:34:16.500
I like that for my little to-do list


00:34:16.500 --> 00:34:17.820
and the comments that I leave.


00:34:17.820 --> 00:34:19.020
- Yeah, yeah, I have thoughts.


00:34:19.020 --> 00:34:19.980
I've done that as well.


00:34:19.980 --> 00:34:20.820
It's cool.


00:34:20.820 --> 00:34:23.940
Chris May out in the audience just put a, you know,


00:34:23.940 --> 00:34:28.180
a heart sign, smiley face emoji as a response to this.


00:34:28.180 --> 00:34:29.000
Love it.


00:34:29.000 --> 00:34:31.020
- Last thing, he's got like seven tips.


00:34:31.020 --> 00:34:33.420
The last tip I wanted to talk about was using rich


00:34:33.420 --> 00:34:38.420
and or specifically rich print, rich dot print or a P print.


00:34:38.420 --> 00:34:42.860
So for P print, you have to do from P print,


00:34:42.860 --> 00:34:44.940
install P print or something,


00:34:44.940 --> 00:34:47.980
or unless you wanted to say it twice with P print dot P


00:34:47.980 --> 00:34:52.180
print, but it's for it's P print stands for pretty printing.


00:34:52.180 --> 00:34:55.900
And the gist of this really is the structures by default


00:34:55.900 --> 00:34:57.740
print horribly.


00:34:57.740 --> 00:35:01.540
If you just print like a dict or, or a set or something,


00:35:01.540 --> 00:35:02.620
it looks gross,


00:35:02.620 --> 00:35:05.700
but Rich and PrettyPrint make it look nice.


00:35:05.700 --> 00:35:09.200
So if you're printing with those and debugging, use that.


00:35:09.200 --> 00:35:10.040
So.


00:35:10.040 --> 00:35:12.260
- Yeah, yeah, that's great.


00:35:12.260 --> 00:35:15.940
There's also exception handling stuff in there for it.


00:35:15.940 --> 00:35:19.540
And there's a lot of that kind of debugging stuff in Rich.


00:35:19.540 --> 00:35:22.180
- Yeah, printing exceptions is great with that.


00:35:22.180 --> 00:35:24.900
I also wanted to say one of the reasons why I,


00:35:24.900 --> 00:35:28.780
one of the places where I use printing a lot for debugging


00:35:28.780 --> 00:35:31.900
is I print to print stuff in my,


00:35:31.900 --> 00:35:35.340
what I expect is going on when I'm writing a test function.


00:35:35.340 --> 00:35:39.220
So I'll often print out the flow, what's going on.


00:35:39.220 --> 00:35:41.900
The reason I do that is when, if pytest,


00:35:41.900 --> 00:35:43.980
for pytest, if a test fails,


00:35:43.980 --> 00:35:45.580
pytest dumps the standard out.


00:35:45.580 --> 00:35:47.340
So it'll dump all of your print statements


00:35:47.340 --> 00:35:49.140
from the failed procedure.


00:35:49.140 --> 00:35:52.820
So that's either the test under code or the test itself.


00:35:52.820 --> 00:35:54.940
If there's print statements, it gets dumped out.


00:35:54.940 --> 00:35:56.380
So that's helpful.


00:35:56.380 --> 00:35:57.940
- Yeah, nice.


00:35:57.940 --> 00:35:58.940
- That's great, I love it.


00:35:58.940 --> 00:36:01.860
I use print statements a lot, my output is very verbose.


00:36:01.860 --> 00:36:06.100
- You can see right in order what's happening.


00:36:06.100 --> 00:36:07.500
Sometimes a debugger helps,


00:36:07.500 --> 00:36:10.440
but sometimes it's time to just print.


00:36:10.440 --> 00:36:11.280
- Yeah.


00:36:11.280 --> 00:36:14.580
- All right. - Speaking of visual stuff,


00:36:14.580 --> 00:36:15.940
what's your last one here, Renee?


00:36:15.940 --> 00:36:18.640
- Yeah, so in our line of work with data science,


00:36:18.640 --> 00:36:22.300
especially when you're providing the models as tools


00:36:22.300 --> 00:36:25.020
for end users that aren't the data scientists themselves,


00:36:25.020 --> 00:36:28.180
you really want the explainability is really important.


00:36:28.180 --> 00:36:31.100
So being able to explain why a certain prediction


00:36:31.100 --> 00:36:34.500
got the value it did, what the different inputs are,


00:36:34.500 --> 00:36:36.260
we're always working to make that, you know,


00:36:36.260 --> 00:36:38.340
more transparent for our end users.


00:36:38.340 --> 00:36:41.860
In our case, for example, we might be predicting


00:36:41.860 --> 00:36:45.700
which students might be at risk of not retaining


00:36:45.700 --> 00:36:48.340
at the university, so not being enrolled a year later.


00:36:48.340 --> 00:36:49.860
So what are the different factors,


00:36:49.860 --> 00:36:52.140
both overall for the whole population


00:36:52.140 --> 00:36:55.220
that are correlated with not being enrolled for a year.


00:36:55.220 --> 00:36:57.380
And for each individual student,


00:36:57.380 --> 00:36:59.240
what might be particular factors that,


00:36:59.240 --> 00:37:01.520
at least from the model's perspective,


00:37:01.520 --> 00:37:03.240
puts them at higher risk.


00:37:03.240 --> 00:37:05.560
So this package is called SHAP,


00:37:05.560 --> 00:37:10.760
and that stands for Shapley Additive Explanations.


00:37:10.760 --> 00:37:12.880
It was brought to my attention by my team member,


00:37:12.880 --> 00:37:15.040
Brian Richards at Helio Campus.


00:37:15.040 --> 00:37:16.840
And now we use it very frequently


00:37:16.840 --> 00:37:19.760
because it has really good visualizations.


00:37:19.760 --> 00:37:23.160
So these Shapley values, apparently they're from game theory.


00:37:23.160 --> 00:37:25.960
I won't pretend to understand the details of how they're generated.


00:37:25.960 --> 00:37:29.660
But you can think of it as like a model on top of your model.


00:37:29.660 --> 00:37:33.060
So it's additive and all the different features,


00:37:33.060 --> 00:37:37.160
if you see the visualization here, it's showing kind of a little waterfall chart.


00:37:37.160 --> 00:37:39.960
So some of the values that...


00:37:39.960 --> 00:37:42.960
Think of a particular row that you're running through your algorithm.


00:37:42.960 --> 00:37:46.760
Some of the values in that row are going to make the...


00:37:46.760 --> 00:37:51.160
if you're doing a classification model, some values might make you more likely to be in one class,


00:37:51.160 --> 00:37:55.480
some might make you more likely to be in the other class. So you have these visuals of kind of the


00:37:55.480 --> 00:38:01.320
push and pull of each value. In this visual, we're seeing, you know, age is pushing a number to the


00:38:01.320 --> 00:38:07.240
right, sex is pushing it to the left, I guess BP and BMI, that looks like a blood pressure. So it's


00:38:07.240 --> 00:38:11.960
got this like waterfall type of chart. And what it's actually doing is it's comparing, it starts


00:38:11.960 --> 00:38:17.800
with the expected value for the whole population and then it's showing you for this particular


00:38:17.800 --> 00:38:26.120
record each of the input values is kind of nudging that eventual prediction one in one


00:38:26.120 --> 00:38:31.720
direction or the other. So it's just nice visually to have those waterfall plots and to see


00:38:31.720 --> 00:38:40.360
which features are negatively or positively correlated with the you know the end result.


00:38:40.360 --> 00:38:42.920
And you could also do some cool scatter plots with this.


00:38:42.920 --> 00:38:46.560
So you can do the input value versus the SHAP value


00:38:46.560 --> 00:38:50.200
and have a point for every item in your population.


00:38:50.200 --> 00:38:52.440
So in our example, that would be students.


00:38:52.440 --> 00:38:55.000
So we can have a scatter plot of all the students and something


00:38:55.000 --> 00:38:58.160
like the number of cumulative credits


00:38:58.160 --> 00:38:59.860
that they have as of that term.


00:38:59.860 --> 00:39:03.520
And so you'll see the gradient of from low credits


00:39:03.520 --> 00:39:04.320
to high credits.


00:39:04.320 --> 00:39:06.240
It's not usually linear.


00:39:06.240 --> 00:39:07.720
What are those kind of break points?


00:39:07.720 --> 00:39:12.000
And at what point are the values positively impactful


00:39:12.000 --> 00:39:16.640
to likelihood to retain or in the opposite direction?


00:39:16.640 --> 00:39:21.280
Of course, I'm glad that they put in this documentation,


00:39:21.280 --> 00:39:23.160
they have a whole section on basically


00:39:23.160 --> 00:39:24.800
correlation is not causation.


00:39:24.800 --> 00:39:27.680
And we're constantly having to talk to our end users


00:39:27.680 --> 00:39:28.520
about that.


00:39:28.520 --> 00:39:33.520
But if we say a student that lives in a certain town


00:39:33.520 --> 00:39:36.620
is potentially more likely to retain,


00:39:36.620 --> 00:39:38.500
maybe because of distance from campus,


00:39:38.500 --> 00:39:41.220
or maybe you have traditionally recruit


00:39:41.220 --> 00:39:43.060
a lot of students from that town.


00:39:43.060 --> 00:39:44.560
It doesn't mean that if you force someone


00:39:44.560 --> 00:39:45.540
to move to that town,


00:39:45.540 --> 00:39:48.380
they're more likely to stay at your institution, right?


00:39:48.380 --> 00:39:51.620
So yeah, correlation is not causation.


00:39:51.620 --> 00:39:54.820
And I'm gonna switch over here to the visual


00:39:54.820 --> 00:39:56.620
to something called a beeswarm plot


00:39:56.620 --> 00:39:59.220
that you can output this right in your Jupyter notebook,


00:39:59.220 --> 00:40:02.740
which is really handy when you develop a new model.


00:40:02.740 --> 00:40:04.980
And I'll try to describe this for people


00:40:04.980 --> 00:40:06.540
who are listening to the audio.


00:40:06.540 --> 00:40:11.060
It has along the X axis, a list of features.


00:40:11.060 --> 00:40:13.460
So you've got in this example on their website,


00:40:13.460 --> 00:40:16.620
age, relationship, capital gain, marital status.


00:40:16.620 --> 00:40:20.100
And then you see a bunch of dots going across horizontally.


00:40:20.100 --> 00:40:22.900
And there's areas where there's little clusters of dots.


00:40:22.900 --> 00:40:27.140
So what this is showing is the X axis is the shop value.


00:40:27.140 --> 00:40:30.700
So what this shop package outputs.


00:40:30.700 --> 00:40:33.940
So you can see visually across,


00:40:33.940 --> 00:40:37.260
what is the spread of the impact of this value?


00:40:37.260 --> 00:40:40.020
So if each dot is a person in this case,


00:40:40.020 --> 00:40:42.680
you see people all the way to the right,


00:40:42.680 --> 00:40:45.640
whatever their age was positively impacted


00:40:45.640 --> 00:40:48.660
their eventual score, people all the way to the left,


00:40:48.660 --> 00:40:51.020
their age negatively impacted the score.


00:40:51.020 --> 00:40:54.720
And then each dot is a color that ranges from blue to red.


00:40:54.720 --> 00:40:57.700
So the blue ones are people with low age


00:40:57.700 --> 00:41:00.180
and the red ones are people with a high age.


00:41:00.180 --> 00:41:03.500
So you can see here, basically the higher the age,


00:41:03.500 --> 00:41:07.380
the more positive their eventual prediction.


00:41:07.380 --> 00:41:09.300
So just an interesting way to get both


00:41:09.300 --> 00:41:12.900
like a feature importance and see the distribution


00:41:12.900 --> 00:41:15.380
of the values within each feature.


00:41:15.380 --> 00:41:16.700
So it's just really helpful


00:41:16.700 --> 00:41:18.240
when you're doing predictive models,


00:41:18.240 --> 00:41:20.520
both for evaluating your own model


00:41:20.520 --> 00:41:24.140
and then eventually explaining it to end users.


00:41:24.140 --> 00:41:26.460
- So would a wider spread mean that


00:41:26.460 --> 00:41:30.260
the feature is more useful


00:41:30.260 --> 00:41:32.420
or does it have any?


00:41:32.420 --> 00:41:35.500
- Yeah, especially if you can see a split


00:41:35.500 --> 00:41:36.340
in the numbers there.


00:41:36.340 --> 00:41:38.780
So you see in this example relationship,


00:41:38.780 --> 00:41:40.740
you've got all the red ones to the right


00:41:40.740 --> 00:41:42.280
and all the blue ones to the left.


00:41:42.280 --> 00:41:45.100
That means that there's a clear relationship


00:41:45.100 --> 00:41:48.500
from this relationship field with the target variable.


00:41:48.500 --> 00:41:52.180
So there's a clear split where the low values


00:41:52.180 --> 00:41:55.440
are on one side and the high values are on the other side.


00:41:55.440 --> 00:41:57.940
And then yeah, the spread means that


00:41:57.940 --> 00:42:00.480
If there's not a good example here,


00:42:00.480 --> 00:42:02.820
but sometimes you'll see like two clumps,


00:42:02.820 --> 00:42:05.660
two beeswarms spread apart with nothing in the middle.


00:42:05.660 --> 00:42:08.180
So that's when you have a really clear spread


00:42:08.180 --> 00:42:11.300
of the high impact group versus the low impact group.


00:42:11.300 --> 00:42:13.140
And if it's more narrow,


00:42:13.140 --> 00:42:15.940
that's less of a important variable.


00:42:15.940 --> 00:42:20.460
So you see if you look at the one that's sorted by max,


00:42:20.460 --> 00:42:25.780
here we go, absolute value of the shop value,


00:42:25.780 --> 00:42:30.680
the ones near the bottom for the population have less impact.


00:42:30.680 --> 00:42:33.600
Now, there might be one person in there where


00:42:33.600 --> 00:42:35.040
that particular value was like


00:42:35.040 --> 00:42:37.680
the deciding factor of which class they ended up in.


00:42:37.680 --> 00:42:39.520
But for the population as a whole,


00:42:39.520 --> 00:42:41.700
there's less differentiation across


00:42:41.700 --> 00:42:45.520
these values than across the ones near the top of the list.


00:42:45.520 --> 00:42:48.360
>> Yeah. This is cool because that visualization of


00:42:48.360 --> 00:42:50.880
models is very tricky, right?


00:42:50.880 --> 00:42:53.840
It's something like knowing why you got an answer.


00:42:53.840 --> 00:42:55.840
This looks very helpful.


00:42:55.840 --> 00:42:57.840
Yeah, it's really useful.


00:42:57.840 --> 00:42:59.840
The visuals are so pretty by default,


00:42:59.840 --> 00:43:01.840
but then you can also pull those values into other tools.


00:43:01.840 --> 00:43:03.840
So, for example,


00:43:03.840 --> 00:43:05.840
for each


00:43:05.840 --> 00:43:07.840
feature in each row,


00:43:07.840 --> 00:43:09.840
you get a shop value. So you can write those back


00:43:09.840 --> 00:43:11.840
to the database and then pull those values


00:43:11.840 --> 00:43:13.840
into another tool. We use it in Tableau


00:43:13.840 --> 00:43:15.840
to highlight for each student


00:43:15.840 --> 00:43:17.840
what are those really important


00:43:17.840 --> 00:43:19.840
features, either making them


00:43:19.840 --> 00:43:21.840
if you're not making them,


00:43:21.840 --> 00:43:26.480
not causation, but correlated with their more likely


00:43:26.480 --> 00:43:28.820
to retain or less likely to retain.


00:43:28.820 --> 00:43:31.640
So we might say, well, for this student, their GPA,


00:43:31.640 --> 00:43:32.760
that's the main factor.


00:43:32.760 --> 00:43:34.200
Their GPA is really low.


00:43:34.200 --> 00:43:36.620
Students with low GPAs tend not to retain.


00:43:36.620 --> 00:43:40.200
And so when the end user's looking at all of their values


00:43:40.200 --> 00:43:43.600
in a table or some other kind of view,


00:43:43.600 --> 00:43:45.600
you can use the SHAP value to highlight.


00:43:45.600 --> 00:43:47.280
GPA is the one you need to hone in on


00:43:47.280 --> 00:43:48.960
the student is struggling academically.


00:43:48.960 --> 00:43:50.040
- Right, try to help them,


00:43:50.040 --> 00:43:52.700
get some help with grades, for example.


00:43:52.700 --> 00:43:54.360
Cool. Yeah, this is a great find.


00:43:54.360 --> 00:43:58.700
Indeed, indeed.


00:43:58.700 --> 00:44:00.600
Brian, that brings us to the extras.


00:44:00.600 --> 00:44:03.540
Got any extras for us?


00:44:03.540 --> 00:44:07.580
- I do. I've got one that was just a quick one.


00:44:07.580 --> 00:44:08.960
Let's see, pull it up.


00:44:08.960 --> 00:44:14.340
Matthew Fiegaert mentioned on Twitter


00:44:14.340 --> 00:44:17.080
that pip index is a cool thing.


00:44:17.900 --> 00:44:21.300
And I kinda didn't know about it, so this is neat.


00:44:21.300 --> 00:44:25.820
So pip index is something you can take a pip index,


00:44:25.820 --> 00:44:28.860
well, specifically pip index versions.


00:44:28.860 --> 00:44:30.700
So pip index does a whole bunch of stuff,


00:44:30.700 --> 00:44:33.700
but pip index versions will tell you,


00:44:33.700 --> 00:44:35.860
if you also give it a package,


00:44:35.860 --> 00:44:39.180
it'll tell you all the different versions


00:44:39.180 --> 00:44:43.240
that are available on PyPI and which one you have


00:44:43.240 --> 00:44:45.660
and which, you know, if you're out of date and stuff.


00:44:45.660 --> 00:44:48.340
But so for instance, if you're thinking


00:44:48.340 --> 00:44:49.940
about upgrading something


00:44:49.940 --> 00:44:52.580
and you don't know what to upgrade to,


00:44:52.580 --> 00:44:55.100
you can look to see what all is there, I guess.


00:44:55.100 --> 00:44:56.060
- Or you wanna roll it back.


00:44:56.060 --> 00:44:57.700
You're like, oh, this version is not working.


00:44:57.700 --> 00:44:59.820
I wanna go back to a lower one.


00:44:59.820 --> 00:45:03.580
But if you're on 2.0, I said, it's not 1.0.


00:45:03.580 --> 00:45:04.420
What is it, right?


00:45:04.420 --> 00:45:05.240
What do you go back to?


00:45:05.240 --> 00:45:07.020
And so this will like list all the available versions.


00:45:07.020 --> 00:45:10.260
Basically, this is a CLI version


00:45:10.260 --> 00:45:15.140
of the releases option in pypi.org.


00:45:15.140 --> 00:45:17.980
- Right, and that's not like obvious how to get to


00:45:17.980 --> 00:45:21.480
on PyPI, but I know you can get to it.


00:45:21.480 --> 00:45:22.560
You can see all the releases,


00:45:22.560 --> 00:45:24.880
but by default it doesn't show those.


00:45:24.880 --> 00:45:25.920
So this is pretty quick.


00:45:25.920 --> 00:45:26.960
- Yeah, pretty neat.


00:45:26.960 --> 00:45:29.400
Good one, good one.


00:45:29.400 --> 00:45:30.240
Renee, how about you?


00:45:30.240 --> 00:45:31.400
Some extras?


00:45:31.400 --> 00:45:33.700
- Sure, I wanted to make sure to mention my book.


00:45:33.700 --> 00:45:37.320
So just published and just out in Europe this week,


00:45:37.320 --> 00:45:38.240
actually as a paperback,


00:45:38.240 --> 00:45:40.320
but it's been out since September in the US,


00:45:40.320 --> 00:45:42.080
SQL for Data Scientists,


00:45:42.080 --> 00:45:45.400
a beginner's guide for building datasets for analysis.


00:45:45.400 --> 00:45:47.740
So I mentioned earlier, I wrote this book


00:45:47.740 --> 00:45:50.600
because I think a lot of students coming out


00:45:50.600 --> 00:45:53.440
of data science programs or people who are coming


00:45:53.440 --> 00:45:58.400
from maybe a statistics background that are in data science


00:45:58.400 --> 00:46:00.760
might not have experience pulling the data.


00:46:00.760 --> 00:46:03.760
So in class, a lot of times you're given a clean spreadsheet


00:46:03.760 --> 00:46:05.920
to start with when you're building your predictive model.


00:46:05.920 --> 00:46:08.560
Then you get to the job and you sit down the first day


00:46:08.560 --> 00:46:10.360
and they say, "Great, build us a model."


00:46:10.360 --> 00:46:12.040
And you say, well, where's the data?


00:46:12.040 --> 00:46:14.440
It's in a raw form in the database.


00:46:14.440 --> 00:46:16.100
So you have to build your own data set.


00:46:16.100 --> 00:46:17.360
So that's what the purpose of the book


00:46:17.360 --> 00:46:20.080
is to kind of get you from that point of when you have access


00:46:20.080 --> 00:46:23.480
to raw data to exploring and building your data set


00:46:23.480 --> 00:46:25.640
so that you can run it through your predictive model.


00:46:25.640 --> 00:46:28.520
So on the screen there, you see my website.


00:46:28.520 --> 00:46:30.400
And for people on the audio, it's


00:46:30.400 --> 00:46:33.440
SQLfordatascientist.com.


00:46:33.440 --> 00:46:37.400
And you can go to different chapters on the website.


00:46:37.400 --> 00:46:39.000
And I have some example SQL.


00:46:39.000 --> 00:46:40.280
And you can also run it.


00:46:40.280 --> 00:46:44.160
So there's a SQLite database in the browser here.


00:46:44.160 --> 00:46:46.460
And so you can actually copy and paste


00:46:46.460 --> 00:46:48.480
some of the SQL on the page,


00:46:48.480 --> 00:46:51.160
click execute and it shows up in a table down here.


00:46:51.160 --> 00:46:52.740
You can edit it and rerun it.


00:46:52.740 --> 00:46:54.280
So you get a little bit of practice


00:46:54.280 --> 00:46:57.420
with using the database in the book.


00:46:57.420 --> 00:46:58.260
- Neat.


00:46:58.260 --> 00:46:59.080
- Yeah.


00:46:59.080 --> 00:47:01.240
Cool book and wow, SQLite in the browser.


00:47:01.240 --> 00:47:02.360
Very neat.


00:47:02.360 --> 00:47:03.200
- Thank you.


00:47:03.200 --> 00:47:04.040
- Yeah.


00:47:04.040 --> 00:47:04.860
Awesome.


00:47:04.860 --> 00:47:06.760
It's a book that definitely should exist.


00:47:06.760 --> 00:47:08.680
All right, really quickly,


00:47:08.680 --> 00:47:12.420
I'm gonna do a webcast with Paul Everett.


00:47:12.420 --> 00:47:13.960
Haven't seen Paul in the audience today.


00:47:13.960 --> 00:47:14.800
Paul, where are you?


00:47:14.800 --> 00:47:17.320
No, I'm not sure he might be working.


00:47:17.320 --> 00:47:18.580
But on November 23rd,


00:47:18.580 --> 00:47:21.720
I'm gonna be doing a webcast around PyCharm.


00:47:21.720 --> 00:47:25.600
I've updated my PyCharm course with all sorts of good stuff.


00:47:25.600 --> 00:47:27.220
Haven't quite totally announced it yet


00:47:27.220 --> 00:47:29.280
'cause there's a few things I'm waiting,


00:47:29.280 --> 00:47:32.560
slightly more stable versions to come out of JetBrains


00:47:32.560 --> 00:47:35.960
to finish some of their data science tools actually.


00:47:35.960 --> 00:47:37.600
And then I'll talk more about it,


00:47:37.600 --> 00:47:40.320
but we're doing a webcast in about a week or so.


00:47:40.320 --> 00:47:43.400
So that should be a lot of fun and yeah, come,


00:47:43.400 --> 00:47:44.220
come check it out.


00:47:44.220 --> 00:47:46.580
Watch Paul and me make the code go.


00:47:46.580 --> 00:47:49.560
- Two days before Thanksgiving.


00:47:49.560 --> 00:47:51.060
- Yes, indeed.


00:47:51.060 --> 00:47:54.340
All right, that brings us to our joke.


00:47:54.340 --> 00:48:00.360
And in the joke is a response to something


00:48:00.360 --> 00:48:02.000
that you posted on Twitter.


00:48:02.000 --> 00:48:04.600
Really appreciating my foresight of using lots of stuff,


00:48:04.600 --> 00:48:08.640
comment as the message in git commit.


00:48:08.640 --> 00:48:09.760
- Well, that actually confused me


00:48:09.760 --> 00:48:11.400
'cause I did a git rebase main


00:48:11.400 --> 00:48:12.920
and it said applying lots of stuff.


00:48:12.920 --> 00:48:16.560
And I thought it was like a feature of git rebase


00:48:16.560 --> 00:48:19.400
and it just happened to be my commit message.


00:48:19.400 --> 00:48:21.200
- Yeah, it's like, oh, git's gotten real casual.


00:48:21.200 --> 00:48:22.240
It's a lot of stuff.


00:48:22.240 --> 00:48:27.000
So Francois Voron said,


00:48:27.000 --> 00:48:31.080
"Time for a classic XKCD link here."


00:48:31.080 --> 00:48:32.600
- Yeah, oh yeah.


00:48:32.600 --> 00:48:35.860
And so this is like the commit history


00:48:35.860 --> 00:48:39.040
throughout the project as you get farther into it.


00:48:39.040 --> 00:48:42.600
So it starts out with very formal, proper comments


00:48:42.600 --> 00:48:45.000
like created main loop and timing control.


00:48:45.000 --> 00:48:48.280
The next commit is enabled config file parsing


00:48:48.280 --> 00:48:52.360
and then starts to fit miscellaneous bug fixes


00:48:52.360 --> 00:48:54.360
and then code additions and edits


00:48:54.360 --> 00:48:57.200
and then a branch, more code,


00:48:57.200 --> 00:49:00.660
here have code just eight letter A's.


00:49:01.760 --> 00:49:03.280
- It comes back with-- - Infernal screaming.


00:49:03.280 --> 00:49:08.280
- Exactly, just ADK, FJ, SLK, just a bunch of home row.


00:49:08.280 --> 00:49:10.480
And then my hands are typing words,


00:49:10.480 --> 00:49:13.020
and then just hands, and the title is,


00:49:13.020 --> 00:49:15.360
as a project drags on,


00:49:15.360 --> 00:49:18.260
my git commit messages get less and less informative.


00:49:18.260 --> 00:49:20.520
We've all been there, right?


00:49:20.520 --> 00:49:21.360
- Yeah. - Yes.


00:49:21.360 --> 00:49:25.800
- It happens to me with branch names too,


00:49:25.800 --> 00:49:29.100
'cause if I'm working on one feature and push part of it,


00:49:29.100 --> 00:49:31.000
and then I go, and I'm still working on it,


00:49:31.000 --> 00:49:33.240
I like to use a new branch name.


00:49:33.240 --> 00:49:33.760
>> Yeah.


00:49:33.760 --> 00:49:38.360
>> I just, it's hard to come up with good branch names.


00:49:38.360 --> 00:49:42.080
>> I'm branching. Exactly.


00:49:42.080 --> 00:49:44.960
I try to be more formal on the branches at least,


00:49:44.960 --> 00:49:46.840
so I know I can delete them later.


00:49:46.840 --> 00:49:49.600
When I'm working on projects that are mostly just me,


00:49:49.600 --> 00:49:52.760
I'll create a GitHub issue and then create


00:49:52.760 --> 00:49:54.600
the branch name to be like a short version


00:49:54.600 --> 00:49:56.800
of the issue title and the issue number.


00:49:56.800 --> 00:49:58.440
Then when I commit back in,


00:49:58.440 --> 00:50:00.560
I can just look at the branch name and put a hash,


00:50:00.560 --> 00:50:05.560
that number and it'll tag it in the commit on the issue in GitHub.


00:50:05.560 --> 00:50:10.560
If I'm working with someone, like a team, I might put like my name slash branch name


00:50:10.560 --> 00:50:15.560
and then actually in some of the tools like SourceTree, you have like little expand widgets


00:50:15.560 --> 00:50:20.560
around that on the branches. So you can say these are Michael's branches and these are Rene's branches and so on.


00:50:20.560 --> 00:50:25.560
Yeah, we got into the habit of doing that too. It helps a lot to see right up front whose branch is this.


00:50:25.560 --> 00:50:27.760
- Yeah, it can get out of control, right?


00:50:27.760 --> 00:50:28.600
- Mm-hmm.


00:50:28.600 --> 00:50:31.640
- All right, a quick couple of follow-ups, Brian.


00:50:31.640 --> 00:50:33.920
Anthony says, "The book looks great, Renee.


00:50:33.920 --> 00:50:35.000
I'll check it out."


00:50:35.000 --> 00:50:36.120
- Great, thank you.


00:50:36.120 --> 00:50:37.600
- Chris May likes it as well.


00:50:37.600 --> 00:50:38.760
It's a great book idea.


00:50:38.760 --> 00:50:40.880
- Glad you like it.


00:50:40.880 --> 00:50:43.040
- Especially when I keep working long


00:50:43.040 --> 00:50:43.880
after I should have gone home.


00:50:43.880 --> 00:50:45.360
No, this is the joke.


00:50:45.360 --> 00:50:47.160
This is me, especially after I keep working long


00:50:47.160 --> 00:50:48.640
after I should have gone home.


00:50:48.640 --> 00:50:51.120
Gone home, yeah, absolutely.


00:50:51.120 --> 00:50:54.440
And Sam, oops, forgot to stage this as a comment.


00:50:54.440 --> 00:50:57.300
as a common message in my repositories.


00:50:57.300 --> 00:50:59.200
(laughing)


00:50:59.200 --> 00:51:00.040
- I see.


00:51:00.040 --> 00:51:03.160
So cool.


00:51:03.160 --> 00:51:04.080
It was a fun episode.


00:51:04.080 --> 00:51:05.520
Thanks Renee for coming on.


00:51:05.520 --> 00:51:06.440
- Yeah, thanks for having me.


00:51:06.440 --> 00:51:07.280
It's fun.


00:51:07.280 --> 00:51:09.720
Don't get to dive into Python too often.


00:51:09.720 --> 00:51:11.800
I'm using the same type of things over and over.


00:51:11.800 --> 00:51:14.600
So it's nice to see what's new and what's on the horizon.


00:51:14.600 --> 00:51:17.080
- Awesome. - Yep.


00:51:17.080 --> 00:51:18.360
Thanks Renee, thanks Brian.


00:51:18.360 --> 00:51:19.600
See y'all.


00:51:19.600 --> 00:51:20.440
- Bye.

