WEBVTT

00:00:00.000 --> 00:00:04.340
- Everybody on the live stream, welcome.


00:00:04.340 --> 00:00:07.160
Hello and welcome to Python Bytes,


00:00:07.160 --> 00:00:09.380
where we deliver Python news and headlines


00:00:09.380 --> 00:00:10.640
directly to your earbuds.


00:00:10.640 --> 00:00:13.180
This is episode 271.


00:00:13.180 --> 00:00:14.020
Really?


00:00:14.020 --> 00:00:14.840
Wow.


00:00:14.840 --> 00:00:17.560
Recorded February 16th, 2022.


00:00:17.560 --> 00:00:18.980
I'm Brian Okken.


00:00:18.980 --> 00:00:20.520
- Hi, I'm Michael Kennedy.


00:00:20.520 --> 00:00:22.300
- And I'm Steve Dower.


00:00:22.300 --> 00:00:23.500
- Welcome Steve.


00:00:23.500 --> 00:00:25.380
So who's Steve Dower?


00:00:25.380 --> 00:00:26.220
- Who's Steve Dower?


00:00:26.220 --> 00:00:27.460
Yeah.


00:00:27.460 --> 00:00:29.300
number of things.


00:00:29.300 --> 00:00:33.100
Probably most interesting to this audience is I'm a core developer on CPython,


00:00:33.100 --> 00:00:34.780
one of our Windows experts.


00:00:34.780 --> 00:00:38.820
So I spend a lot of my time focusing on making Python run better on Windows.


00:00:38.820 --> 00:00:41.540
I also work on Microsoft, work at Microsoft,


00:00:41.540 --> 00:00:44.620
where I also spend a lot of my time making Python run better on Windows.


00:00:44.620 --> 00:00:47.820
So I'm kind of kind of a bit of a one trick pony, I guess.


00:00:47.820 --> 00:00:51.540
But I feel like it's good work and it helps a lot of people.


00:00:51.540 --> 00:00:54.980
So it's a problem with Python and Windows. It's your fault.


00:00:56.100 --> 00:01:00.180
I if there's solutions for Python on Windows, then it's my fault.


00:01:00.180 --> 00:01:02.500
I'll let other people own the problems.


00:01:02.500 --> 00:01:10.060
OK, so if I go to the Windows store, I can now install Python from there.


00:01:10.060 --> 00:01:12.860
And you were you were part of that, right?


00:01:12.860 --> 00:01:14.860
Oh, I should I should have had that up on screen, shouldn't I?


00:01:14.860 --> 00:01:18.060
Yeah, that was that was actually


00:01:18.060 --> 00:01:22.540
the request came from people within Microsoft were like, hey, why can't


00:01:22.540 --> 00:01:25.420
why can't we get Python up on the store


00:01:25.420 --> 00:01:29.020
to it. And my response to all of these is like, well, if the community is willing to do it,


00:01:29.020 --> 00:01:33.660
which is half me and is half the people who would have to take over if I stop doing it, then


00:01:33.660 --> 00:01:40.620
yeah, we'll go ahead and do it. And so I got actual work time for that. That was a contribution


00:01:40.620 --> 00:01:46.380
from Microsoft for that one. But yeah, the community was on board and it's going really


00:01:46.380 --> 00:01:52.060
well. That's also the one that we tied into the default Python.exe that's on every Windows machine


00:01:52.060 --> 00:01:55.380
So if you go to a brand new machine and just type in Python,


00:01:55.380 --> 00:01:59.580
you'll get straight to the PSF's Python.


00:01:59.580 --> 00:02:00.980
Microsoft is not doing it anymore.


00:02:00.980 --> 00:02:02.940
We just contributed the change.


00:02:02.940 --> 00:02:07.140
And now I switch hat and do it with the other hat on.


00:02:07.140 --> 00:02:08.660
So it's real Python.


00:02:08.660 --> 00:02:10.940
It's exactly the same as what you get from python.org.


00:02:10.940 --> 00:02:15.820
It's just delivered easily, fast install, automatic updates,


00:02:15.820 --> 00:02:19.100
and a couple of edge issues that we're


00:02:19.100 --> 00:02:20.820
working on bringing down.


00:02:20.820 --> 00:02:23.100
So yeah, fantastic.


00:02:23.100 --> 00:02:24.220
Automatic update.


00:02:24.220 --> 00:02:27.940
I know this wasn't one of the topics, but now I think I might have to rethink


00:02:27.940 --> 00:02:30.940
how I'm installing Python on my desktop at work.


00:02:30.940 --> 00:02:33.740
So that's a cool idea.


00:02:33.740 --> 00:02:38.940
I have only had store installs on my own machines since three point eight.


00:02:38.940 --> 00:02:41.460
I think I haven't apart from testing.


00:02:41.460 --> 00:02:43.660
I haven't actually used the regular installer.


00:02:43.660 --> 00:02:45.620
But I mean, you're you.


00:02:45.620 --> 00:02:47.660
Of course, that makes sense.


00:02:47.660 --> 00:02:50.060
I mean, you know, it's always testing, right?


00:02:50.060 --> 00:02:52.100
- Every time I'm using Python, I'm testing.


00:02:52.100 --> 00:02:54.140
- Yeah, yeah, yeah.


00:02:54.140 --> 00:02:55.140
Chris May out there says,


00:02:55.140 --> 00:02:56.740
"Thank you so much for making my work life


00:02:56.740 --> 00:02:58.460
"in Windows easier."


00:02:58.460 --> 00:03:00.100
Anytime. - Yeah.


00:03:00.100 --> 00:03:02.500
Well, Michael, why don't you kick us off with a story?


00:03:02.500 --> 00:03:05.620
- I have got a good one.


00:03:05.620 --> 00:03:08.300
So I'm a big fan of FastAPI


00:03:08.300 --> 00:03:10.580
and FastAPI being built on Starlet.


00:03:10.580 --> 00:03:14.100
So by the transit of property, I'm also a fan of Starlet.


00:03:14.100 --> 00:03:16.540
And there's this thing I want to cover


00:03:16.540 --> 00:03:19.140
called FastAPI events.


00:03:19.140 --> 00:03:24.140
So when a request comes in to a particular API endpoint,


00:03:24.140 --> 00:03:25.920
or if you convert it over to a web app,


00:03:25.920 --> 00:03:29.040
to a webpage sort of request or something,


00:03:29.040 --> 00:03:31.240
you might want to dispatch that out to say,


00:03:31.240 --> 00:03:34.220
like, WebSocket listeners, or something along those lines.


00:03:34.220 --> 00:03:36.840
So there's this cool project called FastAPI Events.


00:03:36.840 --> 00:03:39.400
It's pretty small and new,


00:03:39.400 --> 00:03:40.840
so I'm gonna try to give it some visibility.


00:03:40.840 --> 00:03:43.040
It's only got 36 stars, it's pretty new.


00:03:43.040 --> 00:03:45.360
But the idea is that you can go through


00:03:45.360 --> 00:03:48.520
and basically create this middleware handler


00:03:48.520 --> 00:03:51.320
that will let you say when a request comes in,


00:03:51.320 --> 00:03:53.400
here's the way when an event is raised,


00:03:53.400 --> 00:03:55.080
here's the thing that's going to handle it.


00:03:55.080 --> 00:03:58.120
And then in some API endpoint, you can say dispatch,


00:03:58.120 --> 00:04:01.160
give the event a name and some dictionary data


00:04:01.160 --> 00:04:02.000
to be passed along.


00:04:02.000 --> 00:04:04.360
I suppose it doesn't have to be a dictionary,


00:04:04.360 --> 00:04:05.960
it could be whatever.


00:04:05.960 --> 00:04:07.440
And then in other parts of your code,


00:04:07.440 --> 00:04:10.920
you say, I want to just hear about this event that happens,


00:04:10.920 --> 00:04:13.600
no matter what API endpoint received it,


00:04:13.600 --> 00:04:17.080
no matter where in like how deep down in the code


00:04:17.080 --> 00:04:20.160
it was received and so on.


00:04:20.160 --> 00:04:22.200
So then way down here,


00:04:22.200 --> 00:04:25.160
you just put a role handler decorator on there.


00:04:25.160 --> 00:04:27.500
You say, I wanna capture all the events that start with,


00:04:27.500 --> 00:04:29.520
you know, some substring like cat star


00:04:29.520 --> 00:04:31.880
for like category, whatever,


00:04:31.880 --> 00:04:34.200
or this one is actually literally about cats.


00:04:34.200 --> 00:04:38.240
And then you can just go through and write these functions


00:04:38.240 --> 00:04:39.520
that will then handle that.


00:04:39.520 --> 00:04:41.080
And you know, you can,


00:04:41.080 --> 00:04:43.280
you can also pass them off to queues like,


00:04:43.280 --> 00:04:45.040
and you can use the SQS,


00:04:45.040 --> 00:04:48.120
the simple queuing service from AWS, I believe that is,


00:04:48.120 --> 00:04:51.340
as the endpoint instead of it just being your app, right?


00:04:51.340 --> 00:04:54.640
So if you've got like lots of scale out and stuff like that.


00:04:54.640 --> 00:04:55.920
- Wow.


00:04:55.920 --> 00:04:56.760
- Yeah.


00:04:56.760 --> 00:04:58.600
- So just like a neat way to do logging


00:04:58.600 --> 00:04:59.900
or even distributed logging, I guess,


00:04:59.900 --> 00:05:01.680
if you've got forwarding handlers.


00:05:01.680 --> 00:05:03.800
- Yeah, it seems like it, right?


00:05:03.800 --> 00:05:08.800
Like, or if you want to sort of build up,


00:05:08.800 --> 00:05:11.040
like here's the request transaction


00:05:11.040 --> 00:05:12.080
and here we're at this stage,


00:05:12.080 --> 00:05:14.040
or like you could maybe do like a visibility


00:05:14.040 --> 00:05:15.940
to long-running workflows with this kind of thing


00:05:15.940 --> 00:05:18.180
or something along those lines, I would think.


00:05:18.180 --> 00:05:23.640
So yeah, there's also an echo handler for debugging.


00:05:23.640 --> 00:05:24.480
I kind of like that.


00:05:24.480 --> 00:05:26.000
Like if I just need to see what is happening,


00:05:26.000 --> 00:05:27.920
it'll just print whatever's happening.


00:05:27.920 --> 00:05:29.640
Just start printing out all the behaviors


00:05:29.640 --> 00:05:30.480
that you're logging.


00:05:30.480 --> 00:05:32.080
So yeah.


00:05:32.080 --> 00:05:33.480
- And then when you want to stop doing that,


00:05:33.480 --> 00:05:34.800
you just take away the handler


00:05:34.800 --> 00:05:38.080
and you don't have to search the entire code base for print


00:05:38.080 --> 00:05:40.760
and find everywhere that you've added it in for debugging.


00:05:40.760 --> 00:05:41.860
- Exactly.


00:05:42.920 --> 00:05:46.800
Alvaro out there says, "This looks similar to Django events."


00:05:46.800 --> 00:05:50.280
Yeah, I suspect it is similar.


00:05:50.280 --> 00:05:53.920
Anyway, pretty short and simple,


00:05:53.920 --> 00:05:56.000
but if you're looking for a way to sort of


00:05:56.000 --> 00:06:00.000
put notifications in a structured way


00:06:00.000 --> 00:06:03.480
into a FastAPI app, well, here you go.


00:06:03.480 --> 00:06:04.840
- Oh, I'm thinking of a whole bunch


00:06:04.840 --> 00:06:06.760
of more abusive ways to use this.


00:06:06.760 --> 00:06:09.000
(laughing)


00:06:09.000 --> 00:06:12.120
- Yeah, you can write some really impressive


00:06:12.120 --> 00:06:13.620
spaghetti code with this.


00:06:13.620 --> 00:06:15.120
- Yeah, I'm sure that you can.


00:06:15.120 --> 00:06:18.240
- Get the cloud involved in everything.


00:06:18.240 --> 00:06:22.860
- Yeah, so let's switch gears a little bit


00:06:22.860 --> 00:06:23.780
and talk about testing.


00:06:23.780 --> 00:06:25.680
Imagine that I've got a testing topic.


00:06:25.680 --> 00:06:28.600
So this is, I'm pretty excited.


00:06:28.600 --> 00:06:33.600
This is, I've been asked a lot about testing pipelines,


00:06:33.600 --> 00:06:35.920
testing data science stuff.


00:06:35.920 --> 00:06:39.500
And I'm not, that's not something I do day to day.


00:06:39.500 --> 00:06:42.580
So I'm really glad to find people talking about it.


00:06:42.580 --> 00:06:46.140
So this, we've got an article from Peter Baumgartner,


00:06:46.140 --> 00:06:50.660
ways to use testing, ways I use testing as a data scientist.


00:06:50.660 --> 00:06:54.460
And I actually, I just really love this article.


00:06:54.460 --> 00:06:55.300
It's great.


00:06:55.300 --> 00:06:59.940
To start with, he starts off with what he uses testing for


00:06:59.940 --> 00:07:01.500
as a data scientist.


00:07:01.500 --> 00:07:04.740
He uses testing to make sure things work,


00:07:04.740 --> 00:07:06.500
to document his understanding


00:07:07.460 --> 00:07:09.460
and to prevent future errors.


00:07:09.460 --> 00:07:11.820
Well, that seems straightforward.


00:07:11.820 --> 00:07:14.300
But the reason why he wrote this up


00:07:14.300 --> 00:07:17.400
is apparently because there's a lot of software,


00:07:17.400 --> 00:07:20.020
there's a lot of testing stuff out on the web,


00:07:20.020 --> 00:07:22.860
but it's geared towards test engineers


00:07:22.860 --> 00:07:24.480
or software developers.


00:07:24.480 --> 00:07:26.680
And he's like, I'm not a software developer.


00:07:26.680 --> 00:07:29.300
I'm doing something else.


00:07:29.300 --> 00:07:30.500
I'm doing analysis.


00:07:30.500 --> 00:07:33.560
I'm not a software person, even though, yeah, you are.


00:07:34.660 --> 00:07:39.220
But to write this up in a context


00:07:39.220 --> 00:07:41.620
where data people might understand it better.


00:07:41.620 --> 00:07:44.420
For instance, he doesn't even start off


00:07:44.420 --> 00:07:46.940
with having written tests.


00:07:46.940 --> 00:07:50.700
His analysis is like if you're doing notebooks


00:07:50.700 --> 00:07:54.200
or other code, just use assert a lot.


00:07:54.200 --> 00:07:56.620
So he's using assert all over the place,


00:07:56.620 --> 00:08:00.980
including he says, where do you have,


00:08:00.980 --> 00:08:04.160
use it for as many intermediate calculations


00:08:04.160 --> 00:08:07.020
and processes as you can, as it makes sense.


00:08:07.020 --> 00:08:11.920
Because in doing things like checking obvious stuff,


00:08:11.920 --> 00:08:16.400
like he's got an example of a table count


00:08:16.400 --> 00:08:17.880
where he's counting up all the yeses.


00:08:17.880 --> 00:08:19.680
Well, you can do a little bit of math


00:08:19.680 --> 00:08:21.040
just to make sure the math works.


00:08:21.040 --> 00:08:22.960
So like all the yeses and nos and missing


00:08:22.960 --> 00:08:25.680
should all add up to the same count.


00:08:25.680 --> 00:08:27.360
Go ahead and throw an assert in there


00:08:27.360 --> 00:08:29.440
because sometimes it doesn't.


00:08:29.440 --> 00:08:32.800
And in this example, he said that he actually caught an error


00:08:32.800 --> 00:08:37.360
because he was looking at two different data frames.


00:08:37.360 --> 00:08:40.320
So they really weren't, they didn't add up to the same.


00:08:40.320 --> 00:08:42.080
So you can catch things like that.


00:08:42.080 --> 00:08:46.000
So just double checking yourself on things


00:08:46.000 --> 00:08:50.800
as you go wrong, away, go as you're developing.


00:08:50.800 --> 00:08:52.880
One of the cool quotes he has in here is like,


00:08:52.880 --> 00:08:56.400
as he has a habit of when he's using notebooks


00:08:56.400 --> 00:08:59.680
to whenever he's visually inspecting the output,


00:08:59.680 --> 00:09:02.760
if you're visually looking at the data that comes out,


00:09:02.760 --> 00:09:07.480
maybe write an assert statement to do that analysis


00:09:07.480 --> 00:09:09.360
so that it's always checked.


00:09:09.360 --> 00:09:13.200
And this is a cool use of putting asserts in notebooks.


00:09:13.200 --> 00:09:14.520
I like this idea.


00:09:14.520 --> 00:09:19.160
The article goes on, it's pretty extensive,


00:09:19.160 --> 00:09:23.840
talking about checking the data, using hypothesis to,


00:09:23.840 --> 00:09:27.540
well, not the data at this part,


00:09:27.540 --> 00:09:30.100
but your assumptions around the data.


00:09:30.100 --> 00:09:32.900
So using a hypothesis to check your assumptions


00:09:32.900 --> 00:09:35.780
and hypothesis will show you things


00:09:35.780 --> 00:09:38.500
that maybe you didn't consider like NANDs,


00:09:38.500 --> 00:09:40.900
are you handling those correctly?


00:09:40.900 --> 00:09:43.180
Empty series or empty data structures


00:09:43.180 --> 00:09:47.700
that are going into your code, are you handling those?


00:09:47.700 --> 00:09:51.320
I mean, hypothesis does take some handholding,


00:09:51.320 --> 00:09:53.580
but it does make you think about really


00:09:53.580 --> 00:09:56.300
what is the shape of the data going in?


00:09:56.300 --> 00:09:59.760
And do you need to limit it?


00:09:59.760 --> 00:10:01.280
What hypothesis is looking at,


00:10:01.280 --> 00:10:03.960
or do you need to change your code to handle more things?


00:10:03.960 --> 00:10:05.120
- Hypothesis is great.


00:10:05.120 --> 00:10:09.800
I've used that for a couple of parsing projects


00:10:09.800 --> 00:10:10.800
or combining projects.


00:10:10.800 --> 00:10:13.720
I spent way too long adding all the strategies


00:10:13.720 --> 00:10:17.640
to be able to test a URL parser that I was calling into,


00:10:17.640 --> 00:10:22.080
but it's fantastic for finding kind of things


00:10:22.080 --> 00:10:24.520
that you would not have thought of.


00:10:24.520 --> 00:10:27.180
- Yeah, I mean, it's finding things, but it's also,


00:10:27.180 --> 00:10:29.720
and it does make, yeah, that aspect of it


00:10:29.720 --> 00:10:31.080
seems like the point of it,


00:10:31.080 --> 00:10:34.080
but the real value I get out of hypothesis


00:10:34.080 --> 00:10:37.740
is thinking, making sure I really understand the data


00:10:37.740 --> 00:10:41.920
that's gonna come in and thinking through those.


00:10:41.920 --> 00:10:44.100
Goes on to talk about actually testing your data


00:10:44.100 --> 00:10:47.320
using things like Pandera, which I wasn't familiar with,


00:10:47.320 --> 00:10:49.680
and another package called Great Expectations


00:10:49.680 --> 00:10:53.640
to look at like putting schemas around the data coming in


00:10:53.640 --> 00:10:57.160
and making sure that the data always matches the schema,


00:10:57.160 --> 00:11:01.360
going on to talk about ArrangeActAssert and using pytest.


00:11:01.360 --> 00:11:02.720
pytest comes in with,


00:11:02.720 --> 00:11:04.800
he's only really writing formal tests


00:11:04.800 --> 00:11:07.380
when he's writing libraries for other people,


00:11:07.380 --> 00:11:09.360
but all these other packages


00:11:09.360 --> 00:11:11.840
to be able to test with data science,


00:11:11.840 --> 00:11:13.120
I think this is a great addition


00:11:13.120 --> 00:11:15.340
to the data science community.


00:11:15.340 --> 00:11:19.320
- So yeah, Alvaro talks about how this is,


00:11:19.320 --> 00:11:21.680
you know, often referred to as defensive programming.


00:11:21.680 --> 00:11:24.040
And then, you know, I feel for him a little bit,


00:11:24.040 --> 00:11:26.760
it says that work we use with our Fortran code.


00:11:26.760 --> 00:11:30.560
So there's that, but I do think this is a really


00:11:30.560 --> 00:11:34.000
interesting way of thinking about defensive code.


00:11:34.000 --> 00:11:36.460
You know, I just, I think of writing defensive code


00:11:36.460 --> 00:11:38.400
as like, oh, I'm gonna have a bunch of if statements


00:11:38.400 --> 00:11:40.320
to verify this thing's not none or verify


00:11:40.320 --> 00:11:42.360
that this is the right type and that it has like


00:11:42.360 --> 00:11:45.600
a reasonable value and raise exceptions.


00:11:45.600 --> 00:11:49.200
I haven't really thought so much of it for like notebooks.


00:11:49.200 --> 00:11:50.720
So that's pretty interesting.


00:11:50.720 --> 00:11:52.360
And one of the neat things about like,


00:11:52.360 --> 00:11:55.120
if you're actually putting asserts in your code,


00:11:55.120 --> 00:11:58.040
you can actually, you can write tests against your code


00:11:58.040 --> 00:12:01.080
that don't even have any asserts in them.


00:12:01.080 --> 00:12:04.160
And because the search will happen within your code


00:12:04.160 --> 00:12:05.920
and the test will still fail and catch it.


00:12:05.920 --> 00:12:06.760
So it's cool.


00:12:06.760 --> 00:12:08.640
- Yeah, yeah, very cool.


00:12:08.640 --> 00:12:11.760
Good stuff.


00:12:11.760 --> 00:12:14.620
- Yeah.


00:12:14.620 --> 00:12:17.560
- Steve, I am super excited to hear about what you're,


00:12:17.560 --> 00:12:19.920
you got coming up because this is brand new.


00:12:19.920 --> 00:12:22.000
Being a core developer, I feel it is appropriate


00:12:22.000 --> 00:12:24.600
that you break this news here.


00:12:24.600 --> 00:12:26.720
I mean, I'm not going to lie when it came to,


00:12:26.720 --> 00:12:27.920
you know, what am I going to talk about?


00:12:27.920 --> 00:12:30.160
Okay, what's the most recently accepted pep


00:12:30.160 --> 00:12:32.720
that was somewhat controversial?


00:12:32.720 --> 00:12:37.040
And I think just as you kind of look down to the section


00:12:37.040 --> 00:12:38.200
on rejected ideas,


00:12:38.200 --> 00:12:41.800
which is considerably longer than the accepted ideas,


00:12:41.800 --> 00:12:43.920
you can probably get a bit of a sense


00:12:43.920 --> 00:12:48.360
for just what went on with exception groups.


00:12:48.360 --> 00:12:50.240
And I know, Michael, you just had a conversation.


00:12:50.240 --> 00:12:51.440
You've learned all about them.


00:12:51.440 --> 00:12:54.920
So you can take over when I run out here.


00:12:54.920 --> 00:12:56.240
I'll share my thoughts with it.


00:12:56.240 --> 00:12:57.000
But yeah, go ahead.


00:12:57.000 --> 00:12:58.080
I'd love to hear about it.


00:12:58.080 --> 00:13:02.040
This is sort of inspired by Trio, right?


00:13:02.040 --> 00:13:04.320
It's the end goal kind of is.


00:13:04.320 --> 00:13:05.560
So this is an interesting pep.


00:13:05.560 --> 00:13:07.760
And we've got a few of these on the go at the moment.


00:13:07.760 --> 00:13:10.280
It's kind of like a stepping stone towards a better


00:13:10.280 --> 00:13:12.440
programming model or a stepping stone


00:13:12.440 --> 00:13:13.960
towards better libraries.


00:13:13.960 --> 00:13:18.640
So it's something that I think in my opinion,


00:13:18.640 --> 00:13:24.320
very few application developers, the last developer


00:13:24.320 --> 00:13:27.440
in the chain, are often not going to use them,


00:13:27.440 --> 00:13:29.480
and they're not going to need them.


00:13:29.480 --> 00:13:32.760
But as you go further in towards the lower levels of libraries,


00:13:32.760 --> 00:13:35.560
especially people writing async schedulers,


00:13:35.560 --> 00:13:37.520
are going to find incredible value out of them.


00:13:37.520 --> 00:13:40.760
Essentially, what the idea is that when you're


00:13:40.760 --> 00:13:44.960
running multiple tasks in parallel, if some of them fail,


00:13:44.960 --> 00:13:47.240
we don't currently have a neat way


00:13:47.240 --> 00:13:51.400
to capture the exceptions from all of the ones that failed.


00:13:51.400 --> 00:13:54.320
There's some approaches that would be like, wait for all of them to complete


00:13:54.320 --> 00:13:58.240
and wrap it in a list, and then you get some exception that contains a list


00:13:58.240 --> 00:14:01.880
of exceptions, but that's lost a whole lot of context.


00:14:01.880 --> 00:14:04.600
You can get just whichever exception happens first,


00:14:04.600 --> 00:14:06.560
but then you lose all the other exceptions.


00:14:06.560 --> 00:14:08.720
And there's just been no real way to handle it.


00:14:08.720 --> 00:14:11.280
So an exception group essentially


00:14:11.280 --> 00:14:14.520
does bundle up all the exceptions internally


00:14:14.520 --> 00:14:15.200
in some way.


00:14:15.200 --> 00:14:18.160
But the really interesting thing is the except star syntax,


00:14:18.160 --> 00:14:20.520
which I'm going to have to scroll a long way down to find


00:14:20.520 --> 00:14:23.720
where that comes up.


00:14:23.720 --> 00:14:26.760
But this is really clever, because if you're


00:14:26.760 --> 00:14:29.320
in that situation where, say, you're


00:14:29.320 --> 00:14:32.360
running 10 parallel processes--


00:14:32.360 --> 00:14:34.440
so here's kind of the first example of it--


00:14:34.440 --> 00:14:38.640
then exceptions are no longer control flow at this level.


00:14:38.640 --> 00:14:42.920
Because if you've run 10 things and you're waiting for 10 things to complete,


00:14:42.920 --> 00:14:45.320
you're not actually doing control flow with the exceptions anymore.


00:14:45.320 --> 00:14:48.640
What you're doing is handling the exception,


00:14:48.640 --> 00:14:52.120
but then the control flow is going to go back to where it was anyway,


00:14:52.120 --> 00:14:56.240
because you're going to be doing something different.


00:14:56.240 --> 00:14:57.960
So for example, if a file doesn't open,


00:14:57.960 --> 00:15:03.000
then you would want to do something different, right?


00:15:03.000 --> 00:15:05.760
you're going to stop going on and trying to read from the file.


00:15:05.760 --> 00:15:09.640
But if you've tried to open 10 files and three of them failed,


00:15:09.640 --> 00:15:12.800
you at the outside level.


00:15:12.800 --> 00:15:15.600
So at the end, at the inner level for each file that may have failed,


00:15:15.600 --> 00:15:17.800
you'll do something different at the outer level.


00:15:17.800 --> 00:15:20.320
All you're really going to do is say, hey, this task failed


00:15:20.320 --> 00:15:24.080
because a file couldn't be opened and maybe you do something else.


00:15:24.080 --> 00:15:25.280
But it's at the outside level.


00:15:25.280 --> 00:15:28.760
So except star takes that exception group and it's going to give you a chance


00:15:28.760 --> 00:15:31.400
to handle each exception


00:15:31.400 --> 00:15:37.560
Essentially on its own. It will group them together. So in this example, if you know five tasks report spam error


00:15:37.560 --> 00:15:42.920
Then you'll get into this except spam error block with all five of them at once


00:15:42.920 --> 00:15:50.440
Which is just how it's not a list of spam exception spam error exceptions something like or a tuple something like that


00:15:50.440 --> 00:15:56.680
So kind of I think it's I think it's a tuple. I think with the star syntax, I believe something honorable basically. Yeah


00:15:57.360 --> 00:16:00.960
Yeah, something you can iterate over to see the exceptions,


00:16:00.960 --> 00:16:05.520
but it's really just this happened at some point,


00:16:05.520 --> 00:16:06.960
and you process it.


00:16:06.960 --> 00:16:09.080
And if the group actually contains


00:16:09.080 --> 00:16:11.800
multiple types of exceptions, then each handler that matches


00:16:11.800 --> 00:16:14.120
is going to be called for all the exceptions that


00:16:14.120 --> 00:16:15.560
match that.


00:16:15.560 --> 00:16:19.080
So you could have this try block raise an exception group that


00:16:19.080 --> 00:16:20.920
has some spam errors, it has some foo errors,


00:16:20.920 --> 00:16:25.120
it has some bar errors, and all three except star blocks


00:16:25.120 --> 00:16:31.260
going to get called with the exceptions that match those, which is a bit, it's definitely


00:16:31.260 --> 00:16:32.720
going to confuse a lot of people.


00:16:32.720 --> 00:16:37.200
It confuses me, which is why I was keen to actually spend a bit more time digging into


00:16:37.200 --> 00:16:42.720
it and trying to figure out what's really valuable about this.


00:16:42.720 --> 00:16:47.720
And I do think the most valuable one is really where the error is canceled error, because


00:16:47.720 --> 00:16:53.480
if for whatever reason, five of your tasks have been canceled, then you need to capture


00:16:53.480 --> 00:16:55.360
that and do something with that outside of it.


00:16:55.360 --> 00:17:00.040
But it doesn't necessarily mean you want to throw away the five successful results.


00:17:00.040 --> 00:17:05.080
And so you do kind of want to to keep a bit of everything going on.


00:17:05.080 --> 00:17:10.400
It's and like I say, it's a building block on its own.


00:17:10.400 --> 00:17:13.760
This isn't enough to do anything new and useful.


00:17:13.760 --> 00:17:16.400
The next thing that comes along is task groups.


00:17:16.400 --> 00:17:21.320
And that's being worked on by a you know, I expect a lot of the same people


00:17:21.320 --> 00:17:23.200
who worked on exception groups.


00:17:23.200 --> 00:17:26.720
Because with task groups, now you can actually start--


00:17:26.720 --> 00:17:27.920
there we go.


00:17:27.920 --> 00:17:29.360
Guidos just merged task groups.


00:17:29.360 --> 00:17:32.000
Excellent.


00:17:32.000 --> 00:17:36.240
Then now you can actually run the task group.


00:17:36.240 --> 00:17:39.160
And if the group raises any errors,


00:17:39.160 --> 00:17:41.720
then you'll catch them through an exception group.


00:17:41.720 --> 00:17:46.800
And so that enables a whole lot of new uses and new ways


00:17:46.800 --> 00:17:50.280
to use async I/O or just async generally,


00:17:50.280 --> 00:17:51.560
Numedit library, as you say,


00:17:51.560 --> 00:17:54.640
Trio's already had something like this for a while.


00:17:54.640 --> 00:17:56.680
- From their nursery thing.


00:17:56.680 --> 00:18:00.120
- Yeah, and so that is now being standardized


00:18:00.120 --> 00:18:03.400
so libraries can kind of share their implementations


00:18:03.400 --> 00:18:04.660
and work together on it.


00:18:04.660 --> 00:18:08.840
- So one of the reasons you need this


00:18:08.840 --> 00:18:13.200
is if I start two web requests and three database queries,


00:18:13.200 --> 00:18:14.700
and then I go to wait on them,


00:18:17.400 --> 00:18:25.240
if several of them fail, the error state captured in totality is a tree of errors that represent,


00:18:25.240 --> 00:18:30.680
well, this task started this other task, which then had this error, this other one, right? So


00:18:30.680 --> 00:18:36.120
you need some way to deal with a group of errors that could happen kind of all at once, right? In


00:18:36.120 --> 00:18:43.080
one of these task groups that gets kicked off. Yeah. So the new task group thing is super cool.


00:18:43.080 --> 00:18:46.960
So you say async with task group as TG.


00:18:46.960 --> 00:18:48.420
And there's two things that are neat about it.


00:18:48.420 --> 00:18:51.220
One is right now, if you fire off a bunch of tasks


00:18:51.220 --> 00:18:54.720
in async and await style, they're basically unrelated.


00:18:54.720 --> 00:18:57.220
Like if one fails, that means nothing for the other.


00:18:57.220 --> 00:18:58.060
Right, they're just like,


00:18:58.060 --> 00:19:00.180
well, here's a bunch of stuff that happened.


00:19:00.180 --> 00:19:03.100
And this creates a relationship between them, right?


00:19:03.100 --> 00:19:04.100
So that if one fails,


00:19:04.100 --> 00:19:05.640
I think it might not schedule new ones,


00:19:05.640 --> 00:19:07.600
something to that of like, it's brand new.


00:19:07.600 --> 00:19:08.480
I'm just seeing the tweets.


00:19:08.480 --> 00:19:11.020
So I think that that's the story.


00:19:11.020 --> 00:19:14.220
I believe that was the story of Trio.


00:19:14.220 --> 00:19:16.380
The other thing that's interesting here that


00:19:16.380 --> 00:19:21.380
in this example, which I'll link to from Yuri


00:19:21.380 --> 00:19:24.260
that he posted, he tweeted about the news,


00:19:24.260 --> 00:19:27.380
was notice that the first one says,


00:19:27.380 --> 00:19:29.980
task group create task for some task


00:19:29.980 --> 00:19:33.340
and then await something that creates another task.


00:19:33.340 --> 00:19:34.820
There's nowhere where you say,


00:19:34.820 --> 00:19:38.140
store all those values into like some list of tasks


00:19:38.140 --> 00:19:39.660
and then go to the task and iterate them


00:19:39.660 --> 00:19:42.860
and wait for them or gather them or whatever the heck it was you had to do before.


00:19:42.860 --> 00:19:46.220
This now makes tasks fire and forget.


00:19:46.220 --> 00:19:49.980
I can say run this, run this, and within that I could do more of those types of things.


00:19:49.980 --> 00:19:55.180
And then you just block at the with context manager level


00:19:55.180 --> 00:19:58.860
to wait for all the tasks to finish, which I think is a real big improvement


00:19:58.860 --> 00:20:01.100
because right now you've got to like constantly juggle,


00:20:01.100 --> 00:20:03.580
well, I've got to return a task from this so I can go wait on it later


00:20:03.580 --> 00:20:06.780
and all those sort of oddities, and this cleans up a lot of that.


00:20:06.780 --> 00:20:09.340
- Right, and of course, being Python,


00:20:09.340 --> 00:20:11.260
I don't know exactly how the syntax works,


00:20:11.260 --> 00:20:14.460
but being Python, that TG object, the task group,


00:20:14.460 --> 00:20:16.500
doesn't actually disappear at the end of the with block.


00:20:16.500 --> 00:20:19.180
So if that's got results stored into it,


00:20:19.180 --> 00:20:20.940
then you still have access to those


00:20:20.940 --> 00:20:23.100
and all of the information about the task group,


00:20:23.100 --> 00:20:25.740
even after you've waited for it to complete running.


00:20:25.740 --> 00:20:26.780
- Oh yeah, that's cool.


00:20:26.780 --> 00:20:28.580
Yeah, so I think this is a nice addition


00:20:28.580 --> 00:20:31.300
to asyncio in Python.


00:20:31.300 --> 00:20:33.460
That's cool, and apparently 3.11 is coming.


00:20:33.460 --> 00:20:36.180
- Yeah, coming in 3.11.


00:20:36.180 --> 00:20:37.420
Yeah.


00:20:37.420 --> 00:20:39.540
I do see a question from Sam Morley in the chat there.


00:20:39.540 --> 00:20:41.580
Is there a way to short circuit so that you don't


00:20:41.580 --> 00:20:43.060
recatch certain exceptions?


00:20:43.060 --> 00:20:46.020
My understanding-- and Michael, if you've got a better one,


00:20:46.020 --> 00:20:47.460
correct me--


00:20:47.460 --> 00:20:50.700
is that the except blocks work in the same way


00:20:50.700 --> 00:20:51.900
as regular ones.


00:20:51.900 --> 00:20:55.180
And the first one that matches a particular exception


00:20:55.180 --> 00:20:55.940
will handle it.


00:20:55.940 --> 00:20:59.220
And the later ones don't, even if they would also match.


00:20:59.220 --> 00:21:04.900
So if the spam error is a subclass of foo error,


00:21:04.900 --> 00:21:09.940
But there's another subclass of foo error, then spam errors will get handled by the spam error handler.


00:21:09.940 --> 00:21:16.380
The foo error handler will handle all the other ones apart from the spam error subclass.


00:21:16.380 --> 00:21:24.780
Nice. Yeah, I don't know much about the accept star other than it was basically a requirement for the task group stuff to be implemented properly.


00:21:24.780 --> 00:21:27.060
So once one came in, the other could come in.


00:21:27.820 --> 00:21:31.940
It's the only feasible way to actually do something


00:21:31.940 --> 00:21:33.700
as a result of an exception group.


00:21:33.700 --> 00:21:38.460
Otherwise, you do end up with a very generic exception,


00:21:38.460 --> 00:21:41.940
and then you write a for loop over all the exceptions


00:21:41.940 --> 00:21:44.060
that it handled and try and figure it out yourself.


00:21:44.060 --> 00:21:45.780
So you'd end up rewriting the code,


00:21:45.780 --> 00:21:48.100
and it was just not going to be feasible.


00:21:48.100 --> 00:21:50.420
It needed to be syntax, and so it is.


00:21:50.420 --> 00:21:53.140
Yeah, right on.


00:21:53.140 --> 00:21:54.700
Very exciting and very timely.


00:21:54.700 --> 00:21:55.660
Thanks, Steve.


00:21:55.660 --> 00:21:57.540
I'm kind of glad that I put off learning


00:21:57.540 --> 00:21:59.960
how to do async code until 3.11.


00:21:59.960 --> 00:22:01.280
(laughing)


00:22:01.280 --> 00:22:02.200
It's easier.


00:22:02.200 --> 00:22:05.140
- It's a good band and a good time for async I/O.


00:22:05.140 --> 00:22:06.200
- Yeah. - Yeah.


00:22:06.200 --> 00:22:09.180
- Cool, cool.


00:22:09.180 --> 00:22:11.560
- All right, I guess I'm up with the next one, huh, Brian?


00:22:11.560 --> 00:22:13.760
- Yeah, let's see what you got.


00:22:13.760 --> 00:22:16.200
- I have got some other interesting things.


00:22:16.200 --> 00:22:20.320
I'm here about showing off the underappreciated projects,


00:22:20.320 --> 00:22:23.240
or the new projects, just a couple of stars here.


00:22:23.240 --> 00:22:24.760
And we've talked about overloading before,


00:22:24.760 --> 00:22:26.840
but I thought this was a clean way to do it,


00:22:26.840 --> 00:22:27.680
that people can think about.


00:22:27.680 --> 00:22:29.000
And Steve, I would definitely love


00:22:29.000 --> 00:22:29.840
to hear your thoughts on this.


00:22:29.840 --> 00:22:34.840
So Felix the cat created this library called PyOverload.


00:22:34.840 --> 00:22:41.000
And the idea is basically once you have type information,


00:22:41.000 --> 00:22:43.680
then you can have method or function overloading.


00:22:43.680 --> 00:22:46.600
The idea being like, okay, I have a function called foo


00:22:46.600 --> 00:22:49.480
or whatever, and you can say if it takes an integer,


00:22:49.480 --> 00:22:51.040
I want this implementation run.


00:22:51.040 --> 00:22:51.880
If it takes a string,


00:22:51.880 --> 00:22:54.840
I want some other implementation to run, right?


00:22:54.840 --> 00:22:59.000
That's sort of the traditional C++, C# definition of it.


00:22:59.000 --> 00:23:02.120
But in Python, we don't have that really


00:23:02.120 --> 00:23:04.160
because the language started without type.


00:23:04.160 --> 00:23:06.560
So how are you gonna figure out the type to overload it?


00:23:06.560 --> 00:23:08.360
That just doesn't make any sense.


00:23:08.360 --> 00:23:10.840
So with this one, you could sort of use,


00:23:10.840 --> 00:23:12.240
traditionally you could use is instance.


00:23:12.240 --> 00:23:14.020
We're gonna do one thing or another.


00:23:14.020 --> 00:23:16.080
Is it a single thing or is it a list of those things?


00:23:16.080 --> 00:23:17.560
What are we gonna do?


00:23:17.560 --> 00:23:21.120
But with this one, you can put just @overload


00:23:21.120 --> 00:23:23.280
and then whatever the signature is,


00:23:23.280 --> 00:23:26.040
If you can say it has no functions or has no parameters


00:23:26.040 --> 00:23:29.480
or it has like two integers or it has three integers


00:23:29.480 --> 00:23:33.440
or it has like a list of them or whatever.


00:23:33.440 --> 00:23:36.160
And there's even a way to sort of say somewhere down here,


00:23:36.160 --> 00:23:37.160
there's a way to say like,


00:23:37.160 --> 00:23:40.320
if none of them match call this particular one.


00:23:40.320 --> 00:23:43.560
So basically it's just straight function overloading


00:23:43.560 --> 00:23:45.560
in Python if that's the thing you want.


00:23:45.560 --> 00:23:48.320
Steve, does this make you cringe or do you like it?


00:23:48.320 --> 00:23:52.960
- Well, you know, I'm not gonna lie.


00:23:52.960 --> 00:23:57.920
I'm not the most into static typing in my Python code,


00:23:57.920 --> 00:23:59.880
as a lot of other people.


00:23:59.880 --> 00:24:02.800
And there's a lot of complicated reasons.


00:24:02.800 --> 00:24:04.840
But I think for a situation like this,


00:24:04.840 --> 00:24:06.880
I mean, I know if I was writing a function that


00:24:06.880 --> 00:24:09.280
took a string or an int, the very first line


00:24:09.280 --> 00:24:11.960
would be convert it to whichever type I actually want.


00:24:11.960 --> 00:24:13.520
And then the rest of the function


00:24:13.520 --> 00:24:14.840
is going to look identical.


00:24:14.840 --> 00:24:15.760
Yeah.


00:24:15.760 --> 00:24:16.260
And that's--


00:24:16.260 --> 00:24:16.760
Sure.


00:24:16.760 --> 00:24:20.000
In that case where there might be an unparsed type of thing,


00:24:20.000 --> 00:24:22.320
for sure, I think you wouldn't really do an overload.


00:24:22.320 --> 00:24:23.960
That would be insane.


00:24:23.960 --> 00:24:26.840
And my kind of gut feel-- and I'm always


00:24:26.840 --> 00:24:31.520
open to examples proving me wrong, in which case


00:24:31.520 --> 00:24:34.640
I would write the isInstance code that's in those examples.


00:24:34.640 --> 00:24:36.240
My kind of gut feeling is that if you're


00:24:36.240 --> 00:24:38.520
doing two drastically different things in the function,


00:24:38.520 --> 00:24:41.400
based on the type, you need two functions.


00:24:41.400 --> 00:24:44.280
And once you've got two separate functions,


00:24:44.280 --> 00:24:47.280
if the people calling don't know what they're passing you,


00:24:47.280 --> 00:24:49.600
then they've got a problem.


00:24:49.600 --> 00:24:51.900
And it's not so much my responsibility


00:24:51.900 --> 00:24:58.540
fix it with overloading. That said, overloading is really cool. And I am the exact opposite


00:24:58.540 --> 00:25:03.380
person when it comes to C and C++. I will do all the craziest possible stuff with overloading


00:25:03.380 --> 00:25:08.140
in those languages because I think it fits the language and it's a lot of fun. And there's


00:25:08.140 --> 00:25:12.860
definitely occasions and value for having it in Python. We do have the single dispatch


00:25:12.860 --> 00:25:19.460
decorator, has been part of Python for a while, which will do this on the very first parameter.


00:25:19.460 --> 00:25:24.020
this very trivially extending it to the whole function signature


00:25:24.020 --> 00:25:26.420
is really cool.


00:25:26.420 --> 00:25:32.000
So if I needed to do this, I would probably


00:25:32.000 --> 00:25:33.580
want to use a library like this.


00:25:33.580 --> 00:25:40.140
I would probably reconsider my API design choices


00:25:40.140 --> 00:25:42.100
up to that point.


00:25:42.100 --> 00:25:44.180
But I can understand the attraction


00:25:44.180 --> 00:25:49.080
of getting to reuse the name and not


00:25:49.080 --> 00:25:53.440
make the person calling it think too hard about what's actually


00:25:53.440 --> 00:25:54.680
going to run.


00:25:54.680 --> 00:25:57.680
>>Yeah, the place where this sort of seems interesting to me


00:25:57.680 --> 00:26:00.680
is there's a lot of tricks and juggling people


00:26:00.680 --> 00:26:03.720
do with like star args, star star kw args, where like, OK,


00:26:03.720 --> 00:26:07.120
depending on how you pass it, stuff will do a bunch of things.


00:26:07.120 --> 00:26:11.520
I'm always looking for a way to not do that.


00:26:11.520 --> 00:26:14.320
How can I remove that?


00:26:14.320 --> 00:26:15.440
It's completely opaque.


00:26:15.440 --> 00:26:18.080
I have to do a Google search and read the docs to figure out


00:26:18.080 --> 00:26:20.200
what is at all possible here.


00:26:20.200 --> 00:26:22.600
One of these days, I'm probably going


00:26:22.600 --> 00:26:24.040
to take all of the kind of patents


00:26:24.040 --> 00:26:25.480
for that kind of thing that I've collected


00:26:25.480 --> 00:26:26.600
and turn it into a book.


00:26:26.600 --> 00:26:28.840
But writing a book just feels like way too much work.


00:26:28.840 --> 00:26:30.440
So not any time soon.


00:26:30.440 --> 00:26:32.120
Sorry.


00:26:32.120 --> 00:26:34.120
My colleagues at work can ping me at any time,


00:26:34.120 --> 00:26:36.560
and I'll give them a patent for what they're trying to do.


00:26:36.560 --> 00:26:41.080
But I do have quite a set of--


00:26:41.080 --> 00:26:45.160
Oh, you're trying to make stuff weirdly work in this way.


00:26:45.160 --> 00:26:47.600
Here's a nice way that you can enable that


00:26:47.600 --> 00:26:51.000
without having to resort to type checks and everything.


00:26:51.000 --> 00:26:52.440
- Yeah.


00:26:52.440 --> 00:26:53.720
- I've been using, I mean,


00:26:53.720 --> 00:26:55.200
I've been using Python for a long time


00:26:55.200 --> 00:26:58.320
and I do remember one of the first things that I noticed


00:26:58.320 --> 00:26:59.720
is I couldn't do overloading.


00:26:59.720 --> 00:27:02.640
And at the time, so this was many years ago,


00:27:02.640 --> 00:27:05.880
I was using a lot of overloading in my C and C++ code.


00:27:05.880 --> 00:27:09.960
And I was like, oh, I can't do overloading.


00:27:09.960 --> 00:27:12.560
But one of the things I've noticed is actually the,


00:27:12.560 --> 00:27:14.240
instead of keeping,


00:27:14.240 --> 00:27:16.940
wishing that I had overloading in Python,


00:27:16.940 --> 00:27:18.680
I've noticed that I don't really use it


00:27:18.680 --> 00:27:20.720
in C and C++ anymore.


00:27:20.720 --> 00:27:21.680
I've--


00:27:21.680 --> 00:27:22.880
- It's gone the other way, how interesting.


00:27:22.880 --> 00:27:26.880
- Yeah, I really, I'd rather be more explicit about the,


00:27:26.880 --> 00:27:29.920
and just have a function that, two functions that,


00:27:29.920 --> 00:27:32.160
that are, maybe they're similarly named,


00:27:32.160 --> 00:27:35.440
but they have an appendix that's different.


00:27:35.440 --> 00:27:37.680
So that if you have different data, you pass it.


00:27:37.680 --> 00:27:38.680
And I'm with you, Michael.


00:27:38.680 --> 00:27:41.760
I'd rather have people go, well, which one do I need?


00:27:41.760 --> 00:27:45.680
I'll look it up than just passing the wrong data type


00:27:45.680 --> 00:27:49.920
and having me, because sometimes if they haven't converted


00:27:49.920 --> 00:27:54.160
the data, like string versus number is a scary one for me


00:27:54.160 --> 00:27:57.680
because I'm often getting my numbers from an API


00:27:57.680 --> 00:28:01.080
or something and they come in as a string


00:28:01.080 --> 00:28:03.280
if you forgot to convert it and you passed it


00:28:03.280 --> 00:28:05.260
to the wrong thing and you're really doing something


00:28:05.260 --> 00:28:06.960
completely different.


00:28:06.960 --> 00:28:08.880
That's not a good thing.


00:28:08.880 --> 00:28:10.940
- I got bit by that one just yesterday,


00:28:10.940 --> 00:28:15.160
updating one of my CI builds to use Python 3.1,


00:28:15.160 --> 00:28:16.160
I mean 3.10.


00:28:16.160 --> 00:28:21.000
But you know, is it a string or is it a one?


00:28:21.000 --> 00:28:22.480
(laughing)


00:28:22.480 --> 00:28:23.840
- Interesting, yes.


00:28:23.840 --> 00:28:29.520
- But yeah, certainly that conversion would be worrying.


00:28:29.520 --> 00:28:32.200
The other one is, is it a string or is it a list of strings?


00:28:32.200 --> 00:28:35.120
And that's the one that bites us in Python all the time.


00:28:35.120 --> 00:28:38.920
And I don't even know how you resolve an overloaded function


00:28:38.920 --> 00:28:42.980
based on, is it a string or can I iterate it?


00:28:42.980 --> 00:28:44.400
- Well, like in that case, actually,


00:28:44.400 --> 00:28:47.280
I would rather just have that part be part of the function


00:28:47.280 --> 00:28:50.840
at the top of it, if it can handle both to check the type


00:28:50.840 --> 00:28:54.000
and iterate or not, but you know.


00:28:54.000 --> 00:28:55.920
- Yeah, cool.


00:28:55.920 --> 00:28:58.680
All right, let me close this out with two quick thoughts.


00:28:58.680 --> 00:29:01.960
First, I think this is interesting


00:29:01.960 --> 00:29:04.680
because it's one of the things that's possible


00:29:04.680 --> 00:29:05.820
with modern Python.


00:29:05.820 --> 00:29:07.140
Like once we've added typing,


00:29:07.140 --> 00:29:08.980
now you could consider this as a thing,


00:29:08.980 --> 00:29:12.980
whereas previously it really was highly impractical,


00:29:12.980 --> 00:29:15.920
I think, as a way to do it.


00:29:15.920 --> 00:29:17.260
So I think that's kind of cool.


00:29:17.260 --> 00:29:19.980
And then two, I think it might be an entryway


00:29:19.980 --> 00:29:21.500
for people who are not aware of Brian,


00:29:21.500 --> 00:29:23.340
and I'll put myself in there as well,


00:29:23.340 --> 00:29:25.420
yet of going like, actually,


00:29:25.420 --> 00:29:27.500
these things I thought I need, I don't need those, right?


00:29:27.500 --> 00:29:28.860
There's a lot of stuff I thought I needed,


00:29:28.860 --> 00:29:30.700
and I haven't used it for three years,


00:29:30.700 --> 00:29:32.140
so maybe I actually don't need it.


00:29:32.140 --> 00:29:35.180
But that's not how you maybe first approach solving


00:29:35.180 --> 00:29:36.740
your first problem in Python


00:29:36.740 --> 00:29:40.500
that you're coming from C++ or whatever, C#, whatever.


00:29:40.500 --> 00:29:42.740
This might be a gateway.


00:29:42.740 --> 00:29:45.020
So anyway, those are my two thoughts.


00:29:45.020 --> 00:29:48.260
- One more thought from Dean after Python 3.11,


00:29:48.260 --> 00:29:49.580
do we get Python 95?


00:29:49.580 --> 00:29:51.660
(laughing)


00:29:51.660 --> 00:29:54.580
- There was a Windows 3.12.


00:29:54.580 --> 00:29:57.240
So I think Python gets to do a 3.12 as well.


00:29:57.240 --> 00:29:59.220
- 3.12.


00:30:00.300 --> 00:30:02.580
I think it was only available in China.


00:30:02.580 --> 00:30:04.580
- Interesting.


00:30:04.580 --> 00:30:06.540
- And I believe, I like to follow on with that, Dean.


00:30:06.540 --> 00:30:07.780
Very funny.


00:30:07.780 --> 00:30:12.100
I believe that Windows 10 was named,


00:30:12.100 --> 00:30:14.220
you let me know if you know different, Steve.


00:30:14.220 --> 00:30:15.640
Windows 10 was named Windows 10


00:30:15.640 --> 00:30:18.120
because there used to be the check Windows 9


00:30:18.120 --> 00:30:20.800
as the starting string for 95 and 98.


00:30:20.800 --> 00:30:23.180
So you can't be nine 'cause then you're gonna be 95.


00:30:23.180 --> 00:30:24.500
So we got to kick on past it.


00:30:24.500 --> 00:30:25.340
It's kind of like that.


00:30:25.340 --> 00:30:30.340
There was some embarrassingly big language runtimes


00:30:30.340 --> 00:30:33.880
out there still doing that check


00:30:33.880 --> 00:30:36.280
that really struggled with Windows 9


00:30:36.280 --> 00:30:40.720
and showed up in enough places that, yeah,


00:30:40.720 --> 00:30:44.860
I think it just made sense for everyone to just skip it.


00:30:44.860 --> 00:30:48.120
- Not skipping 13, we're skipping nine.


00:30:48.120 --> 00:30:48.960
It's too unlucky.


00:30:48.960 --> 00:30:50.200
All right, awesome.


00:30:50.200 --> 00:30:52.000
Brian, what you got for us?


00:30:52.000 --> 00:30:53.200
- Oh, what do I have next?


00:30:53.200 --> 00:30:58.200
I have the next generation Seaborn interface.


00:30:58.200 --> 00:31:03.380
So Seaborn is a really awesome plotting library


00:31:03.380 --> 00:31:04.700
built on Matplotlib.


00:31:04.700 --> 00:31:08.440
And I, you know, actually I don't use it that much,


00:31:08.440 --> 00:31:10.440
but I've always been intrigued by it


00:31:10.440 --> 00:31:13.740
and kind of watching what plotting libraries do and stuff.


00:31:13.740 --> 00:31:15.620
And one of the things I was curious about,


00:31:15.620 --> 00:31:18.620
which I'm really grateful for this article,


00:31:18.620 --> 00:31:20.380
is some of the history behind it.


00:31:20.380 --> 00:31:22.340
So the article starts off


00:31:22.340 --> 00:31:24.540
next generation Seaboard interface


00:31:24.540 --> 00:31:27.260
talks about the background and goals,


00:31:27.260 --> 00:31:30.580
but some of the great things in here,


00:31:30.580 --> 00:31:32.520
let me grab some notes.


00:31:32.520 --> 00:31:36.380
This work grew out of a long running effort


00:31:36.380 --> 00:31:38.380
to refactor Seaborn internals.


00:31:38.380 --> 00:31:41.720
So that functions, you know, anyway,


00:31:41.720 --> 00:31:44.800
where I wanted to get at was he was developing


00:31:44.800 --> 00:31:46.060
a refactor of the internals.


00:31:46.060 --> 00:31:47.260
And he's like, wait, wait a second,


00:31:47.260 --> 00:31:48.220
if I want to refactor it,


00:31:48.220 --> 00:31:50.580
Maybe I should expose more stuff.


00:31:50.580 --> 00:31:54.100
And some of the background was,


00:31:54.100 --> 00:31:56.860
Seaborn was originally conceived of as a toolbox


00:31:56.860 --> 00:32:01.260
to do of domain-specific statistical graphics


00:32:01.260 --> 00:32:03.260
to be used alongside Matplotlib.


00:32:03.260 --> 00:32:05.420
So the intent was people would use both Seaborn


00:32:05.420 --> 00:32:07.360
and Matplotlib together.


00:32:07.360 --> 00:32:10.540
However, things that people are doing


00:32:10.540 --> 00:32:11.520
are doing things differently.


00:32:11.520 --> 00:32:13.860
A lot of people just grab Seaborn by itself.


00:32:13.860 --> 00:32:15.820
Some people even just learn Seaborn


00:32:15.820 --> 00:32:17.740
before they even learn Matplotlib,


00:32:17.740 --> 00:32:19.440
which is an interesting thing.


00:32:19.440 --> 00:32:22.240
And that's how I thought you were supposed to be doing this.


00:32:22.240 --> 00:32:25.760
But the concept was, and then over time,


00:32:25.760 --> 00:32:26.880
there's a whole bunch of features


00:32:26.880 --> 00:32:28.080
that have been added to Seaborn


00:32:28.080 --> 00:32:30.500
to where it's like really slick looking,


00:32:30.500 --> 00:32:33.280
but to do the same thing by hand in Matplotlib


00:32:33.280 --> 00:32:34.540
is a lot of work.


00:32:34.540 --> 00:32:37.120
So there's some things that like,


00:32:37.120 --> 00:32:39.460
if you, Seaborn's almost there,


00:32:39.460 --> 00:32:40.720
but you need to tweak it a little bit


00:32:40.720 --> 00:32:42.240
and you have to do things manually,


00:32:42.240 --> 00:32:44.340
well, then you have to just do everything by yourself


00:32:44.340 --> 00:32:45.720
and it's a lot of work.


00:32:45.720 --> 00:32:49.900
So the idea around this, a rewrite of the API


00:32:49.900 --> 00:32:52.920
is let's rework some of the internals


00:32:52.920 --> 00:32:55.260
so that a lot of the little sub components


00:32:55.260 --> 00:32:58.940
that go inside of a plot are exposed.


00:32:58.940 --> 00:33:01.100
That way people can get access to it


00:33:01.100 --> 00:33:05.680
to do a more fine-tuned configuration within the,


00:33:05.680 --> 00:33:08.020
so they don't really have to just do everything by hand.


00:33:08.020 --> 00:33:10.660
It's either all or nothing, Seaborn or Matplotlib.


00:33:10.660 --> 00:33:12.960
You can kind of do both more easily,


00:33:12.960 --> 00:33:14.500
which is a kind of a cool idea.


00:33:15.500 --> 00:33:17.360
There's a whole bunch of great details in here


00:33:17.360 --> 00:33:19.920
that talk about some of the API changes.


00:33:19.920 --> 00:33:23.600
Basically, it's exposing the internal,


00:33:23.600 --> 00:33:25.280
if you create a plot, there's nothing there


00:33:25.280 --> 00:33:26.120
and it won't show up.


00:33:26.120 --> 00:33:28.160
You have to create layers on the plot.


00:33:28.160 --> 00:33:29.440
And then within the layers,


00:33:29.440 --> 00:33:33.360
you've got marks and different components that go into it.


00:33:33.360 --> 00:33:36.280
I kind of like this idea of building things up.


00:33:36.280 --> 00:33:39.080
But what I really like is the public aspect of this.


00:33:39.080 --> 00:33:42.840
You've got a library that's out in the open.


00:33:42.840 --> 00:33:44.880
It's being used by a lot of people already.


00:33:44.880 --> 00:33:47.640
and somebody saying, maybe we should tweak the API


00:33:47.640 --> 00:33:48.920
and do something different.


00:33:48.920 --> 00:33:51.480
And just going ahead and doing that in the open saying,


00:33:51.480 --> 00:33:52.840
hey, we're gonna do this.


00:33:52.840 --> 00:33:54.200
There's a note at the top,


00:33:54.200 --> 00:33:56.920
or I'm thinking about doing this note at the top saying,


00:33:56.920 --> 00:33:58.120
it's a work in progress.


00:33:58.120 --> 00:34:01.320
Don't depend on these examples 'cause things might change,


00:34:01.320 --> 00:34:04.280
but this is the direction we're trying to go,


00:34:04.280 --> 00:34:05.880
trying to get feedback from people.


00:34:05.880 --> 00:34:08.680
And I think this is a lot of things


00:34:08.680 --> 00:34:09.960
that a lot of people struggle with


00:34:09.960 --> 00:34:11.720
when they're maintaining packages


00:34:11.720 --> 00:34:14.480
that have been around for a long time is,


00:34:14.480 --> 00:34:15.880
I wanted two things a little different,


00:34:15.880 --> 00:34:18.200
but am I gonna break everybody?


00:34:18.200 --> 00:34:19.520
And talking through it.


00:34:19.520 --> 00:34:21.680
So anyway, this is a great read,


00:34:21.680 --> 00:34:24.880
especially if you're a data plotting kind of person.


00:34:24.880 --> 00:34:27.000
- Yeah, very nice.


00:34:27.000 --> 00:34:29.260
I always wanna do more with visualization


00:34:29.260 --> 00:34:32.060
and I'm sure that I have some good data I could pull up.


00:34:32.060 --> 00:34:35.160
I end up basically just writing APIs


00:34:35.160 --> 00:34:36.680
on websites these days,


00:34:36.680 --> 00:34:38.600
but I really should be pulling this up


00:34:38.600 --> 00:34:39.720
and doing some of these graphs


00:34:39.720 --> 00:34:42.400
and I'm really happy these are around.


00:34:42.400 --> 00:34:43.840
Steve, how about you?


00:34:43.840 --> 00:34:44.840
Seaborn's great.


00:34:44.840 --> 00:34:48.760
It's always-- back when I first discovered it,


00:34:48.760 --> 00:34:50.640
one of its major selling points was simply


00:34:50.640 --> 00:34:53.560
importing Seaborn would magically


00:34:53.560 --> 00:34:56.920
make your default Matplotlib charts look nicer.


00:34:56.920 --> 00:34:57.800
Which--


00:34:57.800 --> 00:34:58.320
I love it.


00:34:58.320 --> 00:35:00.400
It's like the bootstrap of Matplotlib.


00:35:00.400 --> 00:35:01.600
It really was.


00:35:01.600 --> 00:35:04.480
It's like they just apply their style by default,


00:35:04.480 --> 00:35:06.800
and every Matplotlib chart suddenly


00:35:06.800 --> 00:35:10.320
looked nicer, which Matplotlib's done their own styling work


00:35:10.320 --> 00:35:13.000
now, so it's less variable for that.


00:35:13.000 --> 00:35:14.920
I do like this API.


00:35:14.920 --> 00:35:15.580
It looks good.


00:35:15.580 --> 00:35:17.680
And as Dean's pointing out in chat,


00:35:17.680 --> 00:35:20.680
it's like Matplotlib has an object-oriented plotting API


00:35:20.680 --> 00:35:23.360
similar to this, possibly identical,


00:35:23.360 --> 00:35:24.480
just like everyone else.


00:35:24.480 --> 00:35:28.200
I've never learned the object-oriented API.


00:35:28.200 --> 00:35:28.880
But it is there.


00:35:28.880 --> 00:35:33.200
And that's the modern one.


00:35:33.200 --> 00:35:34.800
I know a lot of people say Matplotlib


00:35:34.800 --> 00:35:38.240
is impenetrable and kind of hard to build things up.


00:35:38.240 --> 00:35:40.120
But it does have a really nice API there.


00:35:40.120 --> 00:35:44.080
It's just not the PiPlot one that kind of imitates


00:35:44.080 --> 00:35:45.680
MATLAB's old API.


00:35:45.680 --> 00:35:50.680
And so having it there is really nice.


00:35:50.680 --> 00:35:54.380
And Seaborne, having their own is also great.


00:35:54.380 --> 00:35:59.000
- Another nice thing to read about in this is


00:35:59.000 --> 00:36:04.600
he does a hat tip to ggplot or ggplot2


00:36:04.600 --> 00:36:08.440
or whatever it's called, saying that,


00:36:08.440 --> 00:36:12.440
Yes, it's gonna look a lot of this is similar to ggplot,


00:36:12.440 --> 00:36:15.120
but it isn't that I'm trying to copy it


00:36:15.120 --> 00:36:18.220
or maybe that's definitely influence,


00:36:18.220 --> 00:36:23.220
but it is that Seaborn is important


00:36:23.220 --> 00:36:26.560
because we think about things differently in Python


00:36:26.560 --> 00:36:28.000
than we do in R.


00:36:28.000 --> 00:36:32.780
And just having, it would be,


00:36:32.780 --> 00:36:34.820
but also a hat tip to another library


00:36:34.820 --> 00:36:37.000
that is a wrapper around ggplot.


00:36:37.000 --> 00:36:39.720
If you just want that, you can do that in Python too.


00:36:39.720 --> 00:36:40.560
That's available.


00:36:40.560 --> 00:36:43.520
So it is interesting to,


00:36:43.520 --> 00:36:46.040
these are, we think of these as competing libraries,


00:36:46.040 --> 00:36:47.860
but they're really not competing with each other.


00:36:47.860 --> 00:36:49.780
They're working together to push the,


00:36:49.780 --> 00:36:51.780
push plotting forward.


00:36:51.780 --> 00:36:52.620
- Yeah.


00:36:52.620 --> 00:36:53.460
- Yeah.


00:36:53.460 --> 00:36:57.860
- Dean out there points out you can do plot.style.useSeaborn


00:36:57.860 --> 00:37:00.040
or ggplot, which is another.


00:37:00.040 --> 00:37:01.240
- Use ggplot.


00:37:01.240 --> 00:37:03.040
- Let me throw out, oh yeah, go ahead, Steve.


00:37:03.040 --> 00:37:04.920
- ggplot's certainly the one to copy from.


00:37:04.920 --> 00:37:09.960
I mean, there's a reason that one is as universally popular


00:37:09.960 --> 00:37:13.040
as any plotting library can possibly be.


00:37:13.040 --> 00:37:19.080
It's probably competing with Excel for popularity


00:37:19.080 --> 00:37:20.760
of plotting data, realistically.


00:37:20.760 --> 00:37:23.720
It's a really nice API, and it looks good,


00:37:23.720 --> 00:37:25.520
and everyone's familiar with it.


00:37:25.520 --> 00:37:29.800
And so there's nothing wrong with copying from ggplot.


00:37:29.800 --> 00:37:30.480
>>Nice.


00:37:30.480 --> 00:37:34.080
I got one more shout out to throw into this conversation.


00:37:34.080 --> 00:37:38.880
the XKCD plotting style for Matplotlib.


00:37:38.880 --> 00:37:42.280
So you've got, I mean, this is fantastic.


00:37:42.280 --> 00:37:47.280
It looks like the, it really does look like XKCD would,


00:37:47.280 --> 00:37:51.300
you know, the comic would do for these.


00:37:51.300 --> 00:37:54.040
So this is fantastic, I love it.


00:37:54.040 --> 00:37:55.680
- What I love is I actually see this.


00:37:55.680 --> 00:37:57.480
I see this in papers and stuff like that.


00:37:57.480 --> 00:38:00.080
People just go ahead and use the XKCD style


00:38:00.080 --> 00:38:01.780
and for serious stuff.


00:38:01.780 --> 00:38:03.480
And it just is, it's awesome.


00:38:03.480 --> 00:38:04.640
I love it.


00:38:04.640 --> 00:38:06.120
- I think there's actually some value


00:38:06.120 --> 00:38:08.400
to having like cartoony looking graphics,


00:38:08.400 --> 00:38:10.440
like UI sketches and graphs to say like,


00:38:10.440 --> 00:38:11.800
look, this is speculative.


00:38:11.800 --> 00:38:14.200
This is just like, don't read too much into it.


00:38:14.200 --> 00:38:17.160
I'm trying to give you an idea rather than an exact thing.


00:38:17.160 --> 00:38:20.360
And I think sort of a UI, like cartoony looking sketches


00:38:20.360 --> 00:38:23.400
and this also plays into that.


00:38:23.400 --> 00:38:24.240
- Yeah.


00:38:24.240 --> 00:38:28.960
- All right, Steve, you got the last one?


00:38:28.960 --> 00:38:29.960
- I got the last one, yeah.


00:38:29.960 --> 00:38:32.960
So this is another kind of recent delivery


00:38:32.960 --> 00:38:35.880
from the CPython core team, we can now


00:38:35.880 --> 00:38:38.480
compile CPython to WebAssembly.


00:38:38.480 --> 00:38:39.360
Wow.


00:38:39.360 --> 00:38:43.040
So and to a lot of people, that probably means very little.


00:38:43.040 --> 00:38:45.520
But I guess the brief, brief summary


00:38:45.520 --> 00:38:50.920
is WebAssembly is kind of what the JavaScript in your browser


00:38:50.920 --> 00:38:53.000
compiles to before it runs.


00:38:53.000 --> 00:38:55.960
So it's skipped that initial step of being JavaScript,


00:38:55.960 --> 00:38:59.040
and it's now ready to run in the browser.


00:38:59.040 --> 00:39:01.440
So it's a lower level.


00:39:01.440 --> 00:39:04.680
There are tool chains out there that can compile all sorts of languages


00:39:04.680 --> 00:39:06.560
directly to WebAssembly.


00:39:06.560 --> 00:39:11.520
And so in this case, we've taken, I believe we use one of the,


00:39:11.520 --> 00:39:15.120
I don't know the exact tool chain that's used and it may not matter,


00:39:15.120 --> 00:39:18.280
but it basically takes the C code and compiles that to WebAssembly,


00:39:18.280 --> 00:39:22.840
gives you a package that can be brought into an electron app


00:39:22.840 --> 00:39:26.720
or a Node.js app or a web browser, a modern web browser, and be run


00:39:26.720 --> 00:39:28.800
in the browser.


00:39:28.800 --> 00:39:31.360
There is so this page is a little bit dated.


00:39:31.360 --> 00:39:35.600
There's been a bit more work since then, but I found this is the best overview of where things


00:39:35.600 --> 00:39:39.600
are kind of at long list of C extensions that don't work. Probably unsurprising, like the


00:39:39.600 --> 00:39:47.200
browser doesn't have a lot of this stuff in it. Don't have all the different APIs, the Win32 API


00:39:47.200 --> 00:39:51.520
underneath or whatever it was delegating to. Yeah. No Tkinter? What?


00:39:53.360 --> 00:39:56.440
Yeah, no Tkinter, no subprocess.


00:39:56.440 --> 00:39:57.920
C types, apparently, you can do.


00:39:57.920 --> 00:40:00.680
I've heard there is a libffi port


00:40:00.680 --> 00:40:05.120
to the Emscripten kind of platform.


00:40:05.120 --> 00:40:11.640
So how this kind of works is when you take WebAssembly


00:40:11.640 --> 00:40:14.240
into a browser, it has access to nothing.


00:40:14.240 --> 00:40:17.360
It starts off in a really enclosed kind of box of things


00:40:17.360 --> 00:40:18.840
that it can do.


00:40:18.840 --> 00:40:20.880
And that doesn't actually work for Python at all,


00:40:20.880 --> 00:40:23.180
because the very only thing that it tries to do


00:40:23.180 --> 00:40:25.280
is search the file system for what


00:40:25.280 --> 00:40:27.460
files it should be loading.


00:40:27.460 --> 00:40:31.060
So we actually build it as part of another platform.


00:40:31.060 --> 00:40:35.620
Emscripten is one platform that kind of polyfills


00:40:35.620 --> 00:40:38.220
a whole lot of native-looking APIs


00:40:38.220 --> 00:40:40.700
so that code that's compiled on top of Emscripten


00:40:40.700 --> 00:40:42.220
is able to use it.


00:40:42.220 --> 00:40:46.700
And this little demo, which I'll just hit Start,


00:40:46.700 --> 00:40:49.060
REPL, this is running on that.


00:40:49.060 --> 00:40:51.060
So this is a build of Python 3.11,


00:40:51.060 --> 00:40:56.880
alpha four built with clang running on em scripting. And I


00:40:56.880 --> 00:41:01.740
can I believe I can do this and do like OS lister. And it thinks


00:41:01.740 --> 00:41:04.240
as a file system that now that's not my file system that's in


00:41:04.240 --> 00:41:08.160
memory. It can be changed to browser storage. But this is


00:41:08.160 --> 00:41:10.380
entirely in the browser, like there's nothing downloaded,


00:41:10.380 --> 00:41:12.480
there's nothing running on my machine here. There's nothing


00:41:12.480 --> 00:41:15.420
running in the cloud. It's literally in the browser, I can


00:41:15.420 --> 00:41:18.580
probably freeze my browser with this, like I can do an infinite


00:41:18.580 --> 00:41:21.080
And do it, do it.


00:41:21.080 --> 00:41:22.080
Let's see if this cuts me off.


00:41:22.080 --> 00:41:27.020
I'll just hit clear.


00:41:27.020 --> 00:41:28.140
What happens if you hit clear?


00:41:28.140 --> 00:41:30.180
Whoa.


00:41:30.180 --> 00:41:30.900
It started again.


00:41:30.900 --> 00:41:32.920
No, we're going to start again.


00:41:32.920 --> 00:41:33.740
No, it's done.


00:41:33.740 --> 00:41:36.320
I just, I refresh and yeah.


00:41:36.320 --> 00:41:38.120
so yeah.


00:41:38.120 --> 00:41:42.960
And, and the, there's a second one that the actual build as it was committed


00:41:42.960 --> 00:41:48.440
supports, which is Wazi WSI, that's a slightly different approach to adding all


00:41:48.440 --> 00:41:51.600
the functionality around a WebAssembly module.


00:41:51.600 --> 00:41:55.440
It's so it's a little bit more flexible, a little bit more controlled.


00:41:55.440 --> 00:42:00.640
Emscripten is really like give me POSIX system inside my browser, all in memory.


00:42:00.640 --> 00:42:07.280
And so and so we have two options, and these are available in the in the main branch.


00:42:07.280 --> 00:42:13.200
I don't at the moment, we're not shipping prebuilt modules for WebAssembly.


00:42:13.200 --> 00:42:15.320
That might be a possibility.


00:42:15.320 --> 00:42:17.400
So if that's something that you'd like to see, then,


00:42:17.400 --> 00:42:20.560
I guess, go to discuss.python.org and post about it.


00:42:20.560 --> 00:42:21.680
It's probably a post there.


00:42:21.680 --> 00:42:24.240
I should have looked for a post there.


00:42:24.240 --> 00:42:28.360
But we're not currently doing pre-built releases.


00:42:28.360 --> 00:42:29.520
But I think we could.


00:42:29.520 --> 00:42:32.680
I think this is one of these options where the WebAssembly


00:42:32.680 --> 00:42:34.880
build is totally portable.


00:42:34.880 --> 00:42:37.680
And so if we build it, we can distribute it.


00:42:37.680 --> 00:42:40.800
And then websites that want to do something like this


00:42:40.800 --> 00:42:43.840
could just download it from our servers and run it.


00:42:43.840 --> 00:42:46.240
So I think there's a lot of potential here.


00:42:46.240 --> 00:42:51.360
And it's at the potential stage.


00:42:51.360 --> 00:42:55.800
This is another stepping stone to bigger and better things.


00:42:55.800 --> 00:42:58.560
Our kind of responsibility as the core team is to enable it.


00:42:58.560 --> 00:43:01.160
And now we really want people to come in and pick this up


00:43:01.160 --> 00:43:03.080
and do awesome things with it.


00:43:03.080 --> 00:43:04.960
Firstly, so we can figure out what gaps still


00:43:04.960 --> 00:43:06.520
need to be filled.


00:43:06.520 --> 00:43:10.360
But also just to expand the growth and the reach of Python,


00:43:10.360 --> 00:43:13.160
to bring it into places that currently doesn't exist


00:43:13.160 --> 00:43:17.680
or can't work and give it new life in new places,


00:43:17.680 --> 00:43:18.920
open it up to new people.


00:43:18.920 --> 00:43:21.960
- This is fantastic.


00:43:21.960 --> 00:43:22.920
Congratulations.


00:43:22.920 --> 00:43:25.360
I love it. - And so the work for this,


00:43:25.360 --> 00:43:27.940
primarily done by Katie Bell,


00:43:27.940 --> 00:43:29.780
Christian Himes and Ethan Smith.


00:43:29.780 --> 00:43:33.600
So I think Christian got to do all the merge commits,


00:43:33.600 --> 00:43:35.640
but it's definitely been a number of people


00:43:35.640 --> 00:43:37.260
working on this for a while.


00:43:37.260 --> 00:43:41.020
Those are the primary three.


00:43:42.360 --> 00:43:44.640
- I'm really excited for the possibility for this.


00:43:44.640 --> 00:43:47.440
I think one of the things that could be amazing,


00:43:47.440 --> 00:43:50.720
obviously running it in the front end


00:43:50.720 --> 00:43:52.560
is a thing that could be done.


00:43:52.560 --> 00:43:55.280
I saw the documentation said it was about 10 megs


00:43:55.280 --> 00:43:56.200
to download it.


00:43:56.200 --> 00:43:58.520
I'm sure you can put that on like a CDN.


00:43:58.520 --> 00:44:00.840
So you kind of hit it once somewhere


00:44:00.840 --> 00:44:03.160
for a particular version of Python.


00:44:03.160 --> 00:44:04.000
That's pretty good.


00:44:04.000 --> 00:44:07.080
You know, we all have pretty fast things these days.


00:44:07.080 --> 00:44:08.960
- Yeah, still got room to do them.


00:44:08.960 --> 00:44:10.600
- Yeah.


00:44:10.600 --> 00:44:12.220
What gets me really excited, though,


00:44:12.220 --> 00:44:16.960
is putting that into an ElectronJS app.


00:44:16.960 --> 00:44:18.080
Yeah, absolutely.


00:44:18.080 --> 00:44:20.640
Because ElectronJS is a really interesting way


00:44:20.640 --> 00:44:24.320
to bring web technologies cross-platform, as much as I--


00:44:24.320 --> 00:44:26.280
like, oh, I said an Electron app.


00:44:26.280 --> 00:44:29.200
Still, it's really opened up the possibility


00:44:29.200 --> 00:44:30.040
for a lot of things.


00:44:30.040 --> 00:44:32.040
But it really has meant, OK, you're doing TypeScript,


00:44:32.040 --> 00:44:33.720
you're doing JavaScript, and you just


00:44:33.720 --> 00:44:35.120
have to go full on in that world.


00:44:35.120 --> 00:44:38.400
So here, you could still do your front end and whatever.


00:44:38.400 --> 00:44:43.540
But having the core logic of that desktop app being in Python


00:44:43.540 --> 00:44:47.360
running in this, that's exciting if that can be put together.


00:44:47.360 --> 00:44:49.320
I should also add two things.


00:44:49.320 --> 00:44:52.160
Pyodide is a project that people have probably


00:44:52.160 --> 00:44:54.060
heard of before, which has been working


00:44:54.060 --> 00:44:56.600
on this for considerably longer than the core team has.


00:44:56.600 --> 00:44:59.080
And so I think a lot of the patches that needed to happen


00:44:59.080 --> 00:45:00.920
have come from them.


00:45:00.920 --> 00:45:04.600
And they now get to spend more time focusing on the data


00:45:04.600 --> 00:45:06.280
science stack, which-- because they've


00:45:06.280 --> 00:45:12.360
ports of NumPy and pandas and other libraries to actually do data science in the browser.


00:45:12.360 --> 00:45:18.440
And the other interesting thing that I saw was someone from CondaForge suggesting that they could


00:45:18.440 --> 00:45:25.320
elevate Wasm builds to their kind of automated level. And so all of CondaForge may suddenly


00:45:25.320 --> 00:45:29.880
become available to use in the browser on top of a build of Python like this.


00:45:29.880 --> 00:45:33.120
- Wow. - That would unlock so much.


00:45:33.120 --> 00:45:34.320
That would be incredible.


00:45:34.320 --> 00:45:37.680
- Interesting. - Yeah.


00:45:37.680 --> 00:45:41.320
- I imagine initially it would unlock a lot of bug reports.


00:45:41.320 --> 00:45:43.600
But we need to work through those first.


00:45:43.600 --> 00:45:44.880
- Yeah, I was thinking of, you know,


00:45:44.880 --> 00:45:47.800
take the top 1,000 most popular packages,


00:45:47.800 --> 00:45:49.800
you know, could you get 90% of those compiled


00:45:49.800 --> 00:45:51.600
to like other WebAssembly things


00:45:51.600 --> 00:45:55.560
that then could be included and then imported here somehow?


00:45:55.560 --> 00:45:56.400
- Exactly.


00:45:56.400 --> 00:45:58.540
And the top 1,000 with native code,


00:45:58.540 --> 00:46:00.020
'cause it's only the native code, right?


00:46:00.020 --> 00:46:02.940
The Python code still compiles in the browser


00:46:02.940 --> 00:46:05.780
just like it would in the CPython interpreter.


00:46:05.780 --> 00:46:09.140
It's only the native code that has to be ported and built.


00:46:09.140 --> 00:46:12.020
And so once that's done, then you know,


00:46:12.020 --> 00:46:12.860
grow up and running.


00:46:12.860 --> 00:46:15.980
So the top 1000 is probably more than you need.


00:46:15.980 --> 00:46:18.000
- Yeah, absolutely.


00:46:18.000 --> 00:46:18.940
All right, awesome.


00:46:18.940 --> 00:46:20.940
I'm looking forward to seeing where this goes.


00:46:20.940 --> 00:46:22.900
So many neat options.


00:46:22.900 --> 00:46:24.780
There's just cool ways to say like,


00:46:24.780 --> 00:46:27.180
ship the Python runtime to places


00:46:27.180 --> 00:46:29.080
where maybe it would have been hard to get.


00:46:29.080 --> 00:46:30.820
Now you've dropped this WASM file


00:46:30.820 --> 00:46:32.960
plus something that can run WASM.


00:46:32.960 --> 00:46:35.360
And then now you've got a deployable,


00:46:35.360 --> 00:46:40.000
shippable CPython runtime without Tkinter


00:46:40.000 --> 00:46:43.820
and a few things, but still, you might not miss it.


00:46:43.820 --> 00:46:45.920
It depends what you're doing.


00:46:45.920 --> 00:46:48.120
I mean, most apps are not Tkinter apps


00:46:48.120 --> 00:46:48.960
is all I'm saying.


00:46:48.960 --> 00:46:50.680
I'm not trying to bang on it.


00:46:50.680 --> 00:46:53.080
- No, no, but I just haven't.


00:46:53.080 --> 00:46:54.960
Every time it comes up that it's still there,


00:46:54.960 --> 00:46:56.000
I'm like, really?


00:46:56.000 --> 00:46:57.300
We still have that, okay.


00:46:57.300 --> 00:47:00.860
- Don't ask me what I've been spending my week


00:47:00.860 --> 00:47:02.380
working on, Brian.


00:47:02.380 --> 00:47:03.880
It's not gonna make you happy.


00:47:03.880 --> 00:47:07.320
- Are you creating a Tkinter base killer


00:47:07.320 --> 00:47:08.840
for against textual?


00:47:08.840 --> 00:47:12.400
- No, no, unfortunately not.


00:47:12.400 --> 00:47:17.460
Awesome, all right.


00:47:17.460 --> 00:47:19.760
Well, Brian, are we at extras?


00:47:19.760 --> 00:47:21.540
- We are at extras.


00:47:21.540 --> 00:47:22.820
Do you wanna kick us off?


00:47:22.820 --> 00:47:24.140
- I will kick us off.


00:47:24.140 --> 00:47:27.400
So I've got a couple of things that I think are interesting.


00:47:27.400 --> 00:47:28.840
Let's start with this one.


00:47:28.840 --> 00:47:33.840
So we've talked about, oh, my Z shell, right?


00:47:33.840 --> 00:47:36.160
A lot, love it.


00:47:36.160 --> 00:47:38.500
I just came across realizing that actually


00:47:38.500 --> 00:47:42.380
this is a Portland company that puts together


00:47:42.380 --> 00:47:46.680
the sort of core maintainers of that.


00:47:46.680 --> 00:47:48.800
So I just thought it was funny to give a quick shout out


00:47:48.800 --> 00:47:51.120
to Planet Argonne.


00:47:51.120 --> 00:47:52.520
They're not really in the Python space,


00:47:52.520 --> 00:47:55.960
but they're in Portland, which I thought was kind of fun.


00:47:55.960 --> 00:47:58.480
And then, what is this?


00:47:58.480 --> 00:48:03.760
This next one comes to us, I think, via PyCoders.


00:48:03.760 --> 00:48:05.720
That's where I got this.


00:48:05.720 --> 00:48:09.840
Django just reformatted all of Django with Black.


00:48:09.840 --> 00:48:12.160
And I know I was just having a discussion with somebody,


00:48:12.160 --> 00:48:15.960
like, oh, your code doesn't follow PEP 8.


00:48:15.960 --> 00:48:17.840
Or like, oh, I don't want it to follow PEP 8.


00:48:17.840 --> 00:48:21.040
But if people are going to use your code,


00:48:21.040 --> 00:48:22.280
like literally you got it imported,


00:48:22.280 --> 00:48:23.880
then it probably should follow,


00:48:23.880 --> 00:48:25.720
like it should not come up with all sorts of warnings.


00:48:25.720 --> 00:48:26.840
And so I thought it was interesting


00:48:26.840 --> 00:48:30.820
that Django just said everything, make it black.


00:48:30.820 --> 00:48:35.520
Steve, what do you think about that?


00:48:35.520 --> 00:48:40.000
- I'm totally on board with just using black on everything.


00:48:40.000 --> 00:48:42.360
I don't agree 100% with the style,


00:48:42.360 --> 00:48:44.480
but I agree 100% with not arguing about it.


00:48:44.480 --> 00:48:46.080
So. - Yeah, it's close enough.


00:48:46.080 --> 00:48:47.520
- Exactly. (laughing)


00:48:47.520 --> 00:48:49.040
- Yeah. - It's close enough.


00:48:49.040 --> 00:48:52.660
- Yeah, plus there's enough tweaks like that make it good.


00:48:52.660 --> 00:48:55.400
Like I really, I'm really grateful that has,


00:48:55.400 --> 00:48:57.960
you can tweak the line length for instance.


00:48:57.960 --> 00:48:58.800
- Yes.


00:48:58.800 --> 00:49:00.560
- Because I mean, here's an example.


00:49:00.560 --> 00:49:01.880
What if I want it really short?


00:49:01.880 --> 00:49:06.620
So for, no, for seriously, for formatting the code


00:49:06.620 --> 00:49:11.000
for the pytest book, I wanted them all quite a bit shorter


00:49:11.000 --> 00:49:13.960
so that they fit better in a book format.


00:49:13.960 --> 00:49:16.560
And I could use black to cover with that


00:49:16.560 --> 00:49:20.080
and convert everything with black to make them like that.


00:49:20.080 --> 00:49:22.080
So it was great.


00:49:22.080 --> 00:49:23.280
- Nice, awesome.


00:49:23.280 --> 00:49:26.320
All right, and the final one is I have been doing


00:49:26.320 --> 00:49:30.200
some stuff with more fun things on YouTube,


00:49:30.200 --> 00:49:31.760
trying to put these little short videos together.


00:49:31.760 --> 00:49:32.920
So here's a, how long is it?


00:49:32.920 --> 00:49:36.600
Six minutes, 44 second video on using time delta


00:49:36.600 --> 00:49:40.320
to get like how many weeks are in some time span.


00:49:40.320 --> 00:49:42.480
The cool tricks you can do there.


00:49:42.480 --> 00:49:43.840
So people should check that out.


00:49:43.840 --> 00:49:45.800
That's my latest Python short thing.


00:49:45.800 --> 00:49:49.400
And yeah, that's it for my extras.


00:49:49.400 --> 00:49:54.300
- Okay, so I've got a quick one, just I've got,


00:49:54.300 --> 00:49:56.340
I don't have a graph, something to throw up,


00:49:56.340 --> 00:50:01.120
but I just, I was looking at the Git history of a repo


00:50:01.120 --> 00:50:03.340
and trying to figure out whether I included


00:50:03.340 --> 00:50:05.640
one of my coworkers branches in it,


00:50:05.640 --> 00:50:08.320
if I merged it yet or not, things like that.


00:50:08.320 --> 00:50:10.320
And I was on the command line and I just learned,


00:50:10.320 --> 00:50:12.760
I'm like, can I just do this with the command line?


00:50:12.760 --> 00:50:14.720
Apparently I didn't know this exists.


00:50:14.720 --> 00:50:18.120
So apparently a get log --graph


00:50:18.120 --> 00:50:20.640
just shows you the get graph,


00:50:20.640 --> 00:50:24.480
your branch history or the branch graph on the command line.


00:50:24.480 --> 00:50:26.760
And I didn't know it was there until today.


00:50:26.760 --> 00:50:29.880
I started using it, tweeted about it.


00:50:29.880 --> 00:50:32.400
And then a whole bunch of people said,


00:50:32.400 --> 00:50:34.040
oh, you should use these flags too.


00:50:34.040 --> 00:50:35.080
That makes it even nicer.


00:50:35.080 --> 00:50:40.080
So it's fun to learn something old as a new thing.


00:50:40.080 --> 00:50:43.760
And then somebody else told me, how about get K?


00:50:43.760 --> 00:50:48.760
So GitK is a graphical browser of your repository


00:50:48.760 --> 00:50:54.600
that just comes with most Git installs


00:50:54.600 --> 00:50:55.920
that I didn't know was there.


00:50:55.920 --> 00:50:57.120
I'm like, do I need to install it?


00:50:57.120 --> 00:50:58.720
I'll just type it and see what happens.


00:50:58.720 --> 00:51:00.680
And it popped up this graphical interface.


00:51:00.680 --> 00:51:01.680
I'm like, this is great.


00:51:01.680 --> 00:51:03.360
This is exactly what I wanted.


00:51:03.360 --> 00:51:05.200
So GitK is pretty cool.


00:51:05.200 --> 00:51:06.700
- I didn't know about that one.


00:51:06.700 --> 00:51:08.800
I've seen the command.


00:51:08.800 --> 00:51:10.840
I've never actually run it to see what happens.


00:51:10.840 --> 00:51:14.600
So I was not feeling quite brave enough.


00:51:14.600 --> 00:51:18.680
Did it kill or was it something else?


00:51:18.680 --> 00:51:25.080
I was just most good command scammy until I've run them the first 100 times or so.


00:51:25.080 --> 00:51:25.680
Yeah.


00:51:25.680 --> 00:51:29.200
how about you?


00:51:29.200 --> 00:51:31.040
Yeah, I got a couple of extras.


00:51:31.040 --> 00:51:32.560
Can I get my screen back up there?


00:51:32.560 --> 00:51:36.800
there's a, I was feeling a little bad about, you know, being a bit self-serving


00:51:36.800 --> 00:51:38.920
here, but then Michael just promoted his video series.


00:51:38.920 --> 00:51:39.960
So I don't feel too bad anymore.


00:51:39.960 --> 00:51:41.720
Get it on, man.


00:51:41.720 --> 00:51:44.800
This is the Python 3.11 alpha 5 download page.


00:51:44.800 --> 00:51:46.680
And we have a new addition this time around,


00:51:46.680 --> 00:51:49.360
which is this Windows Installer for ARM64.


00:51:49.360 --> 00:51:53.280
So ARM64 is not a massive, massive platform for Windows


00:51:53.280 --> 00:51:54.560
yet, but it's growing.


00:51:54.560 --> 00:51:57.360
And we want to have Python support on it.


00:51:57.360 --> 00:52:00.080
So the builds have been running in the background for a while,


00:52:00.080 --> 00:52:01.620
but we've never actually released it.


00:52:01.620 --> 00:52:03.640
We're hoping to get it out with 3.11.


00:52:03.640 --> 00:52:07.600
That is going to depend largely on do people use it?


00:52:07.600 --> 00:52:08.640
Do they love it?


00:52:08.640 --> 00:52:15.240
do they hate it? My experience so far with it has been that it is noticeably faster on


00:52:15.240 --> 00:52:20.600
at least on the arm 64 devices I've had access to compared to the Intel devices, which is


00:52:20.600 --> 00:52:28.160
really, really cool. And that's like the test suite is kind of 30 to 50 percent faster,


00:52:28.160 --> 00:52:34.240
which is huge, huge, really. So I think there's a lot of potential here. I may just have had


00:52:34.240 --> 00:52:35.520
or some hardware. I'm not sure.


00:52:35.520 --> 00:52:37.440
It was a virtual machine, so it's kind of hard to tell.


00:52:37.440 --> 00:52:40.840
But this is this is new.


00:52:40.840 --> 00:52:45.120
If you have an arm 64 device like a Surface Pro X or there's a couple out there


00:52:45.120 --> 00:52:48.680
from other manufacturers, I'm running Windows 11 arm


00:52:48.680 --> 00:52:51.440
on my MacBook Pro and two parallels.


00:52:51.440 --> 00:52:55.400
I then use please in download and install it.


00:52:55.400 --> 00:52:57.840
And let let me know how it goes.


00:52:57.840 --> 00:53:00.840
If you get it through the Windows store, which is currently still not public,


00:53:00.840 --> 00:53:04.000
you need to get the link from basically from one of my tweets.


00:53:04.000 --> 00:53:09.160
to the Windows Store, you'll automatically get the ARM64 version on ARM64 as well.


00:53:09.160 --> 00:53:11.320
So this installer is the traditional one.


00:53:11.320 --> 00:53:14.400
Otherwise, you get it through the store.


00:53:14.400 --> 00:53:16.240
The other thing, which I wasn't going to do,


00:53:16.240 --> 00:53:20.200
and then I spent a bit of time working on this a couple couple of years back


00:53:20.200 --> 00:53:23.400
at the at the Core Dev Sprints.


00:53:23.400 --> 00:53:25.160
I forget who I was chatting with.


00:53:25.160 --> 00:53:28.560
I was chatting with one of the other core devs about everyone typing


00:53:28.560 --> 00:53:32.280
from collections, import deck and misspelling it.


00:53:32.280 --> 00:53:36.120
And it's like you tell, you know, so a deck DQ is double ended queue.


00:53:36.120 --> 00:53:39.280
Very useful data type for certain purposes.


00:53:39.280 --> 00:53:42.020
But people would type it deck like deckers and DEC.


00:53:42.020 --> 00:53:44.980
Because it's phonetically what it sounds like. Exactly.


00:53:44.980 --> 00:53:48.660
And so as a bit of a joke, I made a package that when you


00:53:48.660 --> 00:53:52.020
when you installed it, it would give you from collections import deck.


00:53:52.020 --> 00:53:56.360
And obviously, the thing that that collection should be is a deck,


00:53:56.360 --> 00:54:00.680
a double ended queue of 52 cards representing the cards in a normal deck.


00:54:01.660 --> 00:54:03.940
And over time, for various reasons, it's just kind of grown.


00:54:03.940 --> 00:54:09.180
And and I recently, you know, added support for calculating poker hands to it.


00:54:09.180 --> 00:54:11.700
And so now you can build a game with this.


00:54:11.700 --> 00:54:13.460
It does. It uses enums.


00:54:13.460 --> 00:54:16.140
It's got shuffling, dealing.


00:54:16.140 --> 00:54:20.540
Jokers are optional and you can calculate a poker hand.


00:54:20.540 --> 00:54:25.300
And yeah, I compare them.


00:54:25.300 --> 00:54:27.420
Poker hand one greater than poker hand to.


00:54:27.420 --> 00:54:30.220
I spent a lot of time.


00:54:30.220 --> 00:54:34.380
Most of my work on this over the last week was writing the tests that proved how incorrect


00:54:34.380 --> 00:54:40.140
that function was until I wrote the tests for it. But now at this point, yeah, it's -- you can look


00:54:40.140 --> 00:54:45.500
at the values it gives back. It's actually a tuple with an enumeration saying what the hand is and


00:54:45.500 --> 00:54:50.460
then a selection of the card values in a way that makes the tuples comparable. So you can actually


00:54:50.460 --> 00:54:57.500
look and see, you know, it's a pair of aces that will have the number 14 there for the ace and the


00:54:57.500 --> 00:54:59.660
the next highest card was a 10.


00:54:59.660 --> 00:55:01.060
So if someone else has a pair of aces


00:55:01.060 --> 00:55:02.500
and their next highest card was a nine,


00:55:02.500 --> 00:55:03.700
then you're still gonna compare higher.


00:55:03.700 --> 00:55:06.180
So I'm pretty proud of that function.


00:55:06.180 --> 00:55:07.940
- Yeah, that's clever.


00:55:07.940 --> 00:55:10.860
- But yeah, this is and it's code style block.


00:55:10.860 --> 00:55:13.820
- Oh, very nice.


00:55:13.820 --> 00:55:16.800
- So yeah, it's one short file.


00:55:16.800 --> 00:55:19.380
And it does still override deck


00:55:19.380 --> 00:55:21.080
in the collections module for you.


00:55:21.080 --> 00:55:23.820
(laughing)


00:55:23.820 --> 00:55:25.420
- I love it.


00:55:25.420 --> 00:55:27.620
It doesn't-- so that deck isn't there, right?


00:55:27.620 --> 00:55:29.980
It's like DEQUE is untouched.


00:55:29.980 --> 00:55:32.260
But if you try and import DECK from collections,


00:55:32.260 --> 00:55:34.140
then you'll get it.


00:55:34.140 --> 00:55:35.220
- Nice.


00:55:35.220 --> 00:55:37.220
Hey, one other quick thing to shout out.


00:55:37.220 --> 00:55:39.620
We're hiring contractors to help develop features


00:55:39.620 --> 00:55:40.820
for pypi.org.


00:55:40.820 --> 00:55:43.140
It says at the top of pypi.org.


00:55:43.140 --> 00:55:46.060
That's, do you know anything about this?


00:55:46.060 --> 00:55:47.780
I guess if people want to work on pypi.org,


00:55:47.780 --> 00:55:49.000
that's pretty neat.


00:55:49.000 --> 00:55:51.140
- Yeah, no, they have funding.


00:55:51.140 --> 00:55:55.500
And there is a post that describes the surveys.


00:55:55.500 --> 00:55:57.620
I believe this is the organizational accounts


00:55:57.620 --> 00:55:59.060
project they're looking at.


00:55:59.060 --> 00:56:01.300
Yeah, organization accounts.


00:56:01.300 --> 00:56:07.860
So if, like me, you are kind of one of the primary Python


00:56:07.860 --> 00:56:09.460
people at your company, then you'll


00:56:09.460 --> 00:56:11.620
spend a lot of time helping people publish packages


00:56:11.620 --> 00:56:13.580
to PyPI, if that's the business you're in.


00:56:13.580 --> 00:56:15.260
Certainly is for us.


00:56:15.260 --> 00:56:19.140
There's a lot of packages from Microsoft up on PyPI.


00:56:19.140 --> 00:56:25.020
And the kind of corporate account for that is--


00:56:25.020 --> 00:56:25.780
it does exist.


00:56:25.780 --> 00:56:28.980
We have a user account with 483 projects.


00:56:28.980 --> 00:56:31.860
This is all manually curated right now,


00:56:31.860 --> 00:56:35.040
because PyPI just doesn't have the functionality to kind


00:56:35.040 --> 00:56:36.700
of hand out permissions to it safely.


00:56:36.700 --> 00:56:38.580
Teams and all that kind of stuff, yeah.


00:56:38.580 --> 00:56:39.780
Yeah.


00:56:39.780 --> 00:56:44.020
So I believe the idea of this is to add that functionality


00:56:44.020 --> 00:56:44.660
to PyPI.


00:56:44.660 --> 00:56:48.060
So I would love it if someone comes along and does this.


00:56:48.060 --> 00:56:51.180
I believe we've contributed some of the funding towards this.


00:56:51.180 --> 00:56:52.180
So--


00:56:52.180 --> 00:56:55.500
Yeah, looks like it.


00:56:55.500 --> 00:56:58.540
So Steve, I've got a 3.11 question for you.


00:56:58.540 --> 00:57:00.940
So 3.11 is in alpha.


00:57:00.940 --> 00:57:02.900
So what does that mean, really?


00:57:02.900 --> 00:57:07.380
Does that mean I can start using 3.11, or should I wait?


00:57:07.380 --> 00:57:08.860
It means you can.


00:57:08.860 --> 00:57:12.660
It means we still may change stuff that will break you,


00:57:12.660 --> 00:57:16.060
and we won't apologize.


00:57:16.060 --> 00:57:19.660
OK, but if my code runs, can I trust it or?


00:57:19.660 --> 00:57:23.300
Yeah. Yeah. If if you're if all of your tests pass,


00:57:23.300 --> 00:57:26.420
then you should be you should be out of trust fairly well.


00:57:26.420 --> 00:57:28.020
Certainly existing code.


00:57:28.020 --> 00:57:32.220
There will be new features available in the alpha that have not been


00:57:32.220 --> 00:57:34.340
as thoroughly tested yet or may change again.


00:57:34.340 --> 00:57:37.180
But again, if you're running existing code, you won't be using those.


00:57:37.180 --> 00:57:39.940
So so that won't matter.


00:57:39.940 --> 00:57:41.860
But yeah, it's totally viable to use.


00:57:41.860 --> 00:57:45.180
You can specify three dot 11 dev on GitHub actions.


00:57:45.180 --> 00:57:48.220
I believe it compiles from source when you do that now.


00:57:48.220 --> 00:57:50.880
They don't have a build there.


00:57:50.880 --> 00:57:52.560
They should for beta.


00:57:52.560 --> 00:57:56.060
Beta is when we really want people to start doing stuff at this point.


00:57:56.060 --> 00:57:59.720
Alpha is so that people can test the new features,


00:57:59.720 --> 00:58:02.320
kind of targeted testing on anything new that we've put in.


00:58:02.320 --> 00:58:05.760
Beta is when we really want people to start


00:58:05.760 --> 00:58:09.620
porting libraries, especially kind of the core libraries


00:58:09.620 --> 00:58:11.720
to be able to work with it


00:58:11.720 --> 00:58:15.120
and test it, because if existing code doesn't work,


00:58:15.120 --> 00:58:19.500
on the beta. We want to hear about that so we can fix it in the runtime and not force


00:58:19.500 --> 00:58:20.820
you to fix it in your code.


00:58:20.820 --> 00:58:25.060
Okay, but if I'm like a package maintainer, I can start if it's got GitHub actions for


00:58:25.060 --> 00:58:29.140
it, I can start testing having my CI test against 3.11 then too.


00:58:29.140 --> 00:58:34.140
Absolutely. You will likely want to market as it's okay if it fails.


00:58:34.140 --> 00:58:36.180
Yeah, awesome.


00:58:36.180 --> 00:58:38.420
Okay, thanks.


00:58:38.420 --> 00:58:42.820
Should we do a joke?


00:58:42.820 --> 00:58:43.660
Let's do a joke.


00:58:43.660 --> 00:58:45.860
Let's do a joke.


00:58:45.860 --> 00:58:47.580
All right, so this one,


00:58:47.580 --> 00:58:50.700
it's coming from the Programming Humor one.


00:58:50.700 --> 00:58:52.660
And it's a, like you talked about


00:58:52.660 --> 00:58:54.660
the visualization stuff, Brian.


00:58:54.660 --> 00:58:55.860
And this one, it says,


00:58:55.860 --> 00:58:57.420
there's a search that says,


00:58:57.420 --> 00:59:01.620
how to get labels on MATLAB bar charts to be horizontal.


00:59:01.620 --> 00:59:05.220
- Look what the result came back from Google was.


00:59:05.220 --> 00:59:09.020
It says, you're not alone, help is available.


00:59:09.020 --> 00:59:10.780
If you're experiencing difficult thoughts,


00:59:10.780 --> 00:59:15.780
please call 116-123, or if this is an emergency, call 999.


00:59:15.780 --> 00:59:17.060
(laughing)


00:59:17.060 --> 00:59:19.280
And the underlying bit here is,


00:59:19.280 --> 00:59:21.560
it isn't that drastic, Google, but thanks.


00:59:21.560 --> 00:59:24.340
(laughing)


00:59:24.340 --> 00:59:27.360
And I believe it might also work on Bing, I'm not sure.


00:59:27.360 --> 00:59:29.980
Can you scroll down?


00:59:29.980 --> 00:59:31.380
I think there's a Bing equivalent down here.


00:59:31.380 --> 00:59:34.300
Yeah, not just Google, Bing thinks you're an emergency.


00:59:34.300 --> 00:59:36.980
- Yeah.


00:59:36.980 --> 00:59:39.220
(laughing)


00:59:39.220 --> 00:59:40.460
That's awesome.


00:59:40.460 --> 00:59:41.900
Yeah.


00:59:41.900 --> 00:59:44.760
So it's not that much of an emergency.


00:59:44.760 --> 00:59:46.900
I'll go to Stack Overflow.


00:59:46.900 --> 00:59:49.100
Nice to know that the big search engines are looking out


00:59:49.100 --> 00:59:50.500
for our mental health.


00:59:50.500 --> 00:59:51.300
That's right.


00:59:51.300 --> 00:59:53.420
People become very upset after failing to get


00:59:53.420 --> 00:59:56.300
those bar charts [INAUDIBLE]


00:59:56.300 --> 00:59:58.260
This is not the emergency, but it's coming next


00:59:58.260 --> 01:00:00.300
when you realize what the answer is or something.


01:00:00.300 --> 01:00:01.900
I don't know.


01:00:01.900 --> 01:00:03.300
Nice.


01:00:03.300 --> 01:00:05.940
Anyway, that's the joke I found for us, guys.


01:00:05.940 --> 01:00:07.620
Well, thanks, everybody.


01:00:07.620 --> 01:00:08.900
Thanks, Steve, for coming.


01:00:08.900 --> 01:00:10.620
And thanks, Michael, again.


01:00:10.620 --> 01:00:11.980
- Yeah, thanks for having me.


01:00:11.980 --> 01:00:12.820
- Thanks for having me.

