WEBVTT

00:00:00.000 --> 00:00:05.640
Hello, everyone out there in the live stream. Thanks for being here. And we're about to


00:00:05.640 --> 00:00:11.040
get started. And I've got a bunch of great stuff for you. So, yeah. You guys ready?


00:00:11.040 --> 00:00:15.000
>> Yeah. Let's do it. >> All right. I got to remember what episode


00:00:15.000 --> 00:00:21.440
we're on and all these things. The numbers just keep going, Brian. Hello, and welcome


00:00:21.440 --> 00:00:25.880
to Python Bytes, where we deliver Python news and headlines directly to your earbuds. This


00:00:25.880 --> 00:00:30.880
is episode 216, recorded January 13th, 2021.


00:00:30.880 --> 00:00:34.040
I'm Michael Kennedy.


00:00:34.040 --> 00:00:35.360
- I'm Brian Okken.


00:00:35.360 --> 00:00:37.320
- And Brian, we have a special guest, Yousef.


00:00:37.320 --> 00:00:38.560
Welcome.


00:00:38.560 --> 00:00:40.000
- Hi.


00:00:40.000 --> 00:00:41.120
- Great to have you here.


00:00:41.120 --> 00:00:42.440
You wanna just take a quick moment


00:00:42.440 --> 00:00:44.160
and tell folks about yourself,


00:00:44.160 --> 00:00:46.320
maybe about your podcast real quick?


00:00:46.320 --> 00:00:47.760
- Yeah, sure.


00:00:47.760 --> 00:00:50.980
Thanks for even being able to participate in this podcast.


00:00:50.980 --> 00:00:52.760
So my name is Yousef.


00:00:52.760 --> 00:00:56.080
I might not be well known as you guys are for sure.


00:00:56.080 --> 00:00:57.880
I'm a mechanical engineer from Germany,


00:00:57.880 --> 00:00:59.160
I'm based in Germany as well,


00:00:59.160 --> 00:01:02.480
and I'm working for IT company called SimScale,


00:01:02.480 --> 00:01:05.360
who are providing cloud-based simulation technology.


00:01:05.360 --> 00:01:08.320
On the side, I'm hosting a podcast called Engineered Mind,


00:01:08.320 --> 00:01:10.480
and I'm working on a bunch of other stuff.


00:01:10.480 --> 00:01:14.120
For example, my thesis, which we'll extensively cover,


00:01:14.120 --> 00:01:15.440
let's see, in this podcast.


00:01:15.440 --> 00:01:18.640
- Yeah, yeah, you used a couple of cool libraries


00:01:18.640 --> 00:01:21.960
and stuff over there, which we'll feature here.


00:01:21.960 --> 00:01:25.200
All right, well, the very first item, Brian,


00:01:25.200 --> 00:01:31.760
Ron, let's talk about maybe doing a,


00:01:31.760 --> 00:01:33.820
should I do a pip search a lot?


00:01:33.820 --> 00:01:37.760
- Yeah, well, I kind of forgot pip search was a thing


00:01:37.760 --> 00:01:40.060
'cause when I'm looking for PyPI stuff,


00:01:40.060 --> 00:01:42.280
I go to pypi.org and just-


00:01:42.280 --> 00:01:44.360
- Yeah, so do I, that's, yeah, exactly.


00:01:44.360 --> 00:01:46.080
It's really fast there.


00:01:46.080 --> 00:01:50.160
- Yeah, but there's a feature called a pip.


00:01:50.160 --> 00:01:53.160
you can do a pip search, which the documentation says


00:01:53.160 --> 00:01:57.080
it's supposed to search for pypi packages,


00:01:57.080 --> 00:02:00.880
whose name or summary contains whatever query.


00:02:00.880 --> 00:02:04.240
So I can say pip search pytest, for instance,


00:02:04.240 --> 00:02:09.240
and it should show me if pytest is a package on pypi.


00:02:09.240 --> 00:02:12.920
But right now, if you do that,


00:02:12.920 --> 00:02:16.420
it comes back with a big trace back and it says,


00:02:17.280 --> 00:02:21.320
Fault, what, minus 3,200, 500?


00:02:21.320 --> 00:02:22.660
Runtime error.


00:02:22.660 --> 00:02:25.040
X, the pipe is XML.


00:02:25.040 --> 00:02:27.280
Anyway, the API is broken.


00:02:27.280 --> 00:02:30.080
So this is on purpose.


00:02:30.080 --> 00:02:32.280
What happened is,


00:02:32.280 --> 00:02:33.960
actually, I don't know really what's happened,


00:02:33.960 --> 00:02:34.800
but there's,


00:02:34.800 --> 00:02:38.520
the service is getting swamped.


00:02:38.520 --> 00:02:42.520
The search endpoint is getting hit extremely hard.


00:02:42.520 --> 00:02:44.340
So- - I saw some message


00:02:44.340 --> 00:02:47.200
there's some tweet that was to the effect of,


00:02:47.200 --> 00:02:50.940
is somebody out there running an insane number of searches


00:02:50.940 --> 00:02:52.580
against this endpoint?


00:02:52.580 --> 00:02:53.980
Please don't.


00:02:53.980 --> 00:02:55.380
- Yeah, I don't know what's going on,


00:02:55.380 --> 00:02:56.980
but so there's some guesses,


00:02:56.980 --> 00:03:00.920
maybe it's a rogue continuous integration server


00:03:00.920 --> 00:03:04.220
or something weird's going on.


00:03:04.220 --> 00:03:08.660
But in the meantime, right now,


00:03:08.660 --> 00:03:13.100
we're gonna link to a Python infrastructure status page,


00:03:13.100 --> 00:03:14.460
which has an update on this.


00:03:14.460 --> 00:03:19.140
So if anybody wants to follow, you can check that out.


00:03:19.140 --> 00:03:22.540
It says that the search endpoint remains disabled


00:03:22.540 --> 00:03:24.740
due to ongoing request volume.


00:03:24.740 --> 00:03:29.700
And I think this really started becoming a problem


00:03:29.700 --> 00:03:33.420
mid-December, and so I'm not sure what happened then.


00:03:33.420 --> 00:03:40.220
And then there's a related issue on GitHub for pip.


00:03:41.620 --> 00:03:46.020
So there's an issue open saying remove the pip search command.


00:03:46.020 --> 00:03:50.100
So I think the end result is-- and even the error message


00:03:50.100 --> 00:03:54.500
says the search endpoint will be deprecated in the near future.


00:03:54.500 --> 00:03:58.740
So I think that this way to do pip search


00:03:58.740 --> 00:04:01.140
is just going to go away.


00:04:01.140 --> 00:04:02.340
So--


00:04:02.340 --> 00:04:02.860
And--


00:04:02.860 --> 00:04:04.300
That's actually a little surprising


00:04:04.300 --> 00:04:05.980
because usually a lot of these things


00:04:05.980 --> 00:04:08.420
are so backwards compatible.


00:04:08.420 --> 00:04:09.380
Yeah.


00:04:09.380 --> 00:04:13.820
And there's quite a discussion on the issue thread,


00:04:13.820 --> 00:04:17.220
but the gist of it is the current architecture


00:04:17.220 --> 00:04:20.080
is not, was never designed to handle the volume


00:04:20.080 --> 00:04:21.220
it's getting right now.


00:04:21.220 --> 00:04:26.060
So there's a comment at the end of the thread


00:04:26.060 --> 00:04:27.600
that says if you've got an idea


00:04:27.600 --> 00:04:30.720
for how to do this algorithm better,


00:04:30.720 --> 00:04:35.340
or a way to do it scaled, go ahead and discuss it.


00:04:35.340 --> 00:04:37.620
But there's a link to,


00:04:37.620 --> 00:04:39.100
we're not gonna put that link in the show notes,


00:04:39.100 --> 00:04:44.100
but in the IPI thread or the GitHub thread,


00:04:44.100 --> 00:04:48.220
there's a link to, if you want to comment on that.


00:04:48.220 --> 00:04:50.620
But basically, we're bringing this up.


00:04:50.620 --> 00:04:53.580
You may have figured out it might be a fluke or whatever,


00:04:53.580 --> 00:04:55.740
but it's really going on.


00:04:55.740 --> 00:05:00.220
And a plea to look at your continuous integration scripts.


00:05:00.220 --> 00:05:02.780
And if you're doing a pip search in there, take those out.


00:05:02.780 --> 00:05:04.060
It ain't gonna work anyway.


00:05:04.060 --> 00:05:06.260
- It's gotta be some kind of bot,


00:05:06.260 --> 00:05:07.900
some automatic thing like this,


00:05:07.900 --> 00:05:11.780
because it's already given the error message.


00:05:11.780 --> 00:05:16.580
Like people would stop, you know, if it wasn't.


00:05:16.580 --> 00:05:18.540
Maybe somebody is trying, like constantly trying


00:05:18.540 --> 00:05:21.460
to scrape all of the PyPI data out.


00:05:21.460 --> 00:05:22.300
I don't know.


00:05:22.300 --> 00:05:23.140
- Yeah, why do it?


00:05:23.140 --> 00:05:24.780
It's searched, that's just weird.


00:05:24.780 --> 00:05:25.600
- Yeah, exactly.


00:05:25.600 --> 00:05:27.260
I don't know what's going on here,


00:05:27.260 --> 00:05:30.180
but I guess don't do it.


00:05:30.180 --> 00:05:31.020
- Don't do it.


00:05:31.020 --> 00:05:34.180
- Doctor, it hurts when I do this, stop doing that.


00:05:35.260 --> 00:05:39.260
So the next one I wanna talk about is QPython,


00:05:39.260 --> 00:05:41.800
not QTPython or Qt or anything like that,


00:05:41.800 --> 00:05:46.800
but QPython, which is a way to do Python on Android.


00:05:46.800 --> 00:05:52.820
So we've talked about a couple of interesting applications.


00:05:52.820 --> 00:05:55.460
We've talked about Carnets or Carnet.


00:05:55.460 --> 00:05:58.300
I think it's French pronunciation I've been told.


00:05:58.300 --> 00:06:01.340
And that's a really cool way to do like Jupyter on iPad.


00:06:01.340 --> 00:06:03.460
So local, all of these are local,


00:06:03.460 --> 00:06:05.620
obviously not just running in the browser.


00:06:05.620 --> 00:06:10.520
There's Pythonista, which is really interesting.


00:06:10.520 --> 00:06:12.840
And QPython is also an interesting one


00:06:12.840 --> 00:06:14.240
for a couple reasons,


00:06:14.240 --> 00:06:18.320
'cause you get an SDK and a REPL for your Android device,


00:06:18.320 --> 00:06:20.320
which is pretty interesting.


00:06:20.320 --> 00:06:22.080
But what the reason I'm covering it,


00:06:22.080 --> 00:06:23.480
I think it's interesting.


00:06:23.480 --> 00:06:25.360
Somebody, I think somebody sent this over.


00:06:25.360 --> 00:06:26.880
No, I ran across this myself.


00:06:26.880 --> 00:06:31.160
Anyway, is it allows you just to integrate


00:06:31.160 --> 00:06:36.160
with the underlying Android APIs and features for automation.


00:06:36.160 --> 00:06:38.600
Yeah, cool, right?


00:06:38.600 --> 00:06:41.600
So you can do things like check the system,


00:06:41.600 --> 00:06:48.280
you can send out toast notifications,


00:06:48.280 --> 00:06:49.920
you can interact with applications,


00:06:49.920 --> 00:06:51.240
you can mess with the clipboard,


00:06:51.240 --> 00:06:54.680
you can do barcode scanning, speech recognition,


00:06:54.680 --> 00:06:57.840
send emails, like all those kinds of things


00:06:57.840 --> 00:07:00.840
around even screen brightness,


00:07:00.840 --> 00:07:02.960
checking your battery or whatever.


00:07:02.960 --> 00:07:05.440
So if you wanna get access


00:07:05.440 --> 00:07:09.680
and automate your Android things with Python,


00:07:09.680 --> 00:07:12.360
well, here's a cool little app to do it.


00:07:12.360 --> 00:07:14.680
- Okay, wait a second.


00:07:14.680 --> 00:07:16.640
So I'm not an Android user that much.


00:07:16.640 --> 00:07:18.800
I've got like one Android tablet,


00:07:18.800 --> 00:07:20.600
but I didn't know it can make toast.


00:07:20.600 --> 00:07:26.040
- Yeah, well, it really prefers sourdough,


00:07:26.040 --> 00:07:30.280
but it will go even as far as rye if you have to.


00:07:30.280 --> 00:07:31.280
- No, what's Toast?


00:07:31.280 --> 00:07:32.120
Do you know what Toast is?


00:07:32.120 --> 00:07:34.200
- It's like a pop-up notification, I think.


00:07:34.200 --> 00:07:35.040
- Oh, okay.


00:07:35.040 --> 00:07:38.360
(both laughing)


00:07:38.360 --> 00:07:42.320
- Josef, are you an Android person or an iPhone person?


00:07:42.320 --> 00:07:44.600
- I have to confess I'm an iPhone person.


00:07:44.600 --> 00:07:46.920
I used to be completely against iPhone,


00:07:46.920 --> 00:07:50.760
but once you're in the ecosystem, you never get out.


00:07:50.760 --> 00:07:51.720
- It's like the godfather,


00:07:51.720 --> 00:07:54.200
they just keep pulling you back in, man.


00:07:54.200 --> 00:07:57.580
Yeah, I just recently got a new iPhone as well,


00:07:57.580 --> 00:07:58.680
and I'm general about it,


00:07:58.680 --> 00:08:05.440
But because we have our mobile apps, the training for the courses, I've got an Android tablet


00:08:05.440 --> 00:08:07.960
and I've got an Android phone and so on.


00:08:07.960 --> 00:08:12.880
Oh, also, we've got a comment here on YouTube.


00:08:12.880 --> 00:08:18.360
So is it an own framework or can you use it in Android, Kotlin and Java?


00:08:18.360 --> 00:08:22.360
I believe it's more like an app that you run.


00:08:22.360 --> 00:08:25.000
And then within that, you can do little jobs and stuff.


00:08:25.000 --> 00:08:26.000
So way to aesthetic.


00:08:26.000 --> 00:08:31.000
It's not something you can bring in, that I'm aware of,


00:08:31.000 --> 00:08:32.960
'cause you install it from Google Play, for example,


00:08:32.960 --> 00:08:33.800
to get started and so on.


00:08:33.800 --> 00:08:35.540
But maybe you can plug it in.


00:08:35.540 --> 00:08:40.060
They do talk about having SDK, so possibly,


00:08:40.060 --> 00:08:43.040
but I got the sense that's more for writing code outside


00:08:43.040 --> 00:08:43.960
than getting it on your device.


00:08:43.960 --> 00:08:46.200
But yeah, pretty cool.


00:08:46.200 --> 00:08:47.840
So if you're into Android


00:08:47.840 --> 00:08:50.200
and you wanna do Python automation on it,


00:08:50.200 --> 00:08:51.200
this is pretty cool.


00:08:51.200 --> 00:08:53.080
It's free, get it on the Android store.


00:08:53.080 --> 00:08:55.440
It apparently has ads, but it's also open source.


00:08:55.440 --> 00:08:56.900
So go with that.


00:08:56.900 --> 00:09:00.620
- Do you know if there's a counterpart for iOS?


00:09:00.620 --> 00:09:04.080
- I don't know about the automation side.


00:09:04.080 --> 00:09:08.320
There's a thing called Carnets, which is really cool.


00:09:08.320 --> 00:09:09.760
Let's see if I can find that.


00:09:09.760 --> 00:09:14.400
I believe that's how you spell it.


00:09:14.400 --> 00:09:16.840
Yes, that's Jupyter on the app store.


00:09:16.840 --> 00:09:19.720
And that thing, I don't really want to open the app store,


00:09:19.720 --> 00:09:21.720
but apparently I have to.


00:09:21.720 --> 00:09:24.800
Well, so much for that, but Carnets, it's here.


00:09:24.800 --> 00:09:28.640
- Oh, nice. - Oh, and it's also on Google Play.


00:09:28.640 --> 00:09:31.280
Is that the same thing? No, it's a totally different thing.


00:09:31.280 --> 00:09:36.400
But Carnet is a very cool app that lets you do something similar.


00:09:36.400 --> 00:09:39.520
There's also Pythonista. Those are the two I know for iOS.


00:09:39.520 --> 00:09:41.520
Yeah.


00:09:41.520 --> 00:09:44.160
All right. So, moving along.


00:09:44.160 --> 00:09:47.600
Yosef, maybe tell us a little bit about your research


00:09:47.600 --> 00:09:51.280
and then one of the libraries you've been working with here.


00:09:51.280 --> 00:09:56.280
Yeah, sure. So Open3D is one of the possibilities to visualize.


00:09:56.280 --> 00:10:00.280
Yeah, yeah. Let's talk about PyTorch.


00:10:00.280 --> 00:10:05.280
That's fine. So PyTorch 3D is basically an option, let's say, if you work with meshes,


00:10:05.280 --> 00:10:10.280
that a mesh consists of edges and points, for example,


00:10:10.280 --> 00:10:14.280
and these edges connect all the points and what you get at the end is a mesh.


00:10:14.280 --> 00:10:19.280
So PyTorch, which is for Facebook, Facebook AI Research,


00:10:19.280 --> 00:10:26.340
And they created this framework, so to speak, to be able to work efficiently with 3D data.


00:10:26.340 --> 00:10:28.820
So unfortunately, I'm using point cloud data.


00:10:28.820 --> 00:10:33.080
But the beautiful thing is that if you use PyTorch native application, which you could


00:10:33.080 --> 00:10:40.600
use for your 3D geometry, it runs, I wouldn't say significantly, but roughly 10 times slower


00:10:40.600 --> 00:10:48.840
than this PyTorch 3D, which is implemented especially for 3D problems.


00:10:48.840 --> 00:10:52.320
Okay, so what kind of problem do people solve?


00:10:52.320 --> 00:10:55.440
What problem are you solving when you're working with this?


00:10:55.440 --> 00:10:59.120
Yeah, so in the beginning, it was like I was doing some kind of research.


00:10:59.120 --> 00:11:01.760
Unfortunately, they are coming out paper like every day,


00:11:01.760 --> 00:11:05.880
and not too many actually, in the field of deep learning,


00:11:05.880 --> 00:11:08.360
especially when it comes to point cloud or like geometric data.


00:11:08.680 --> 00:11:14.680
And the goal, just to inform the audience a bit, is my goal is basically to use deep learning


00:11:14.680 --> 00:11:19.080
and use some kind of or create an assistant system for engineers and designers.


00:11:19.080 --> 00:11:23.720
That means, let's say you're an engineer, and we have this CAD model, so C-A-D,


00:11:23.720 --> 00:11:27.560
which stands for computer-aided design. So we'd create a model, for example, of a gear.


00:11:27.560 --> 00:11:32.600
And then you would have that gear. But sometimes we have this differentiation between implicit


00:11:32.600 --> 00:11:37.000
knowledge and explicit knowledge. Explicit knowledge means this is existing knowledge,


00:11:37.000 --> 00:11:42.440
which we already know about, let's say this knowledge, this knowledge can sit in a database.


00:11:42.440 --> 00:11:45.560
And sometimes we are not making use out of it.


00:11:45.560 --> 00:11:48.160
And then we have this implicit knowledge, let's say an engineer comes into a company


00:11:48.160 --> 00:11:52.120
is completely new, and he brings knowledge with him to the company.


00:11:52.120 --> 00:11:56.000
Now the problem I want to tackle is because we're having so many data and we're accumulating


00:11:56.000 --> 00:12:00.000
geometric data in a company, we have to make use of that.


00:12:00.000 --> 00:12:04.740
And my approach is hopefully when I'm at the end of the thesis, which is like in roughly


00:12:04.740 --> 00:12:10.940
two months is that I have a system or web application as a front end where the engineer


00:12:10.940 --> 00:12:16.080
or designer picks or starts a design or picks a point cloud or a design.


00:12:16.080 --> 00:12:21.440
And then it would suggest the engineer or designer with a probability of what they want


00:12:21.440 --> 00:12:22.440
to model.


00:12:22.440 --> 00:12:28.000
Let's say he picks a gear, or maybe you want to have like an arrangement of gears or any


00:12:28.000 --> 00:12:31.600
specific big component, or let's say you take a wheel.


00:12:31.600 --> 00:12:32.600
Okay.


00:12:32.600 --> 00:12:34.640
For example, transmission or something.


00:12:34.640 --> 00:12:38.960
for transmission, or they pick a wheel, and it could be a Tesla or it could be any other


00:12:38.960 --> 00:12:39.960
car.


00:12:39.960 --> 00:12:43.360
And then it would give you a probability, okay, this wheel is maybe from a Tesla.


00:12:43.360 --> 00:12:48.440
And then it would give suggest you a Tesla with a, for example, 89% probability.


00:12:48.440 --> 00:12:50.560
And then you would click on the web application.


00:12:50.560 --> 00:12:51.560
This is the idea.


00:12:51.560 --> 00:12:55.920
And then it would pop the geometry into the web browser in the front end.


00:12:55.920 --> 00:12:57.060
Oh, that's pretty cool.


00:12:57.060 --> 00:12:59.980
So it basically it's like image recognition.


00:12:59.980 --> 00:13:04.220
instead of for pictures, it's image recognition for 3D CAD


00:13:04.220 --> 00:13:04.980
outlines.


00:13:04.980 --> 00:13:08.540
Exactly. It's so cool that you mentioned it, because there's a


00:13:08.540 --> 00:13:11.500
big difference between doing a convolutional neural networks or


00:13:11.500 --> 00:13:14.580
deep learning for images because images are 2d. It's like a 2d


00:13:14.580 --> 00:13:18.100
matrix. But if you have a point cloud, then you have a tensor of


00:13:18.100 --> 00:13:21.380
higher dimensionality. And then you are kind of forced to use,


00:13:21.380 --> 00:13:25.420
for example, NumPy, and all these kind of things. And if


00:13:25.420 --> 00:13:27.780
you're lucky, you could use something like pytorch, pytorch


00:13:27.780 --> 00:13:31.540
3D, which you can also use Qt on to be way more efficient.


00:13:31.540 --> 00:13:36.100
Yeah, yeah. Wow, that's really cool. So it looks like a neat


00:13:36.100 --> 00:13:40.100
thing. This is, you know, I haven't done any 3D work for a


00:13:40.100 --> 00:13:44.020
while. But yeah, it looks, looks pretty cool. I would love to see,


00:13:44.020 --> 00:13:46.820
I don't know, some pictures and stuff. It would not be neat. But


00:13:46.820 --> 00:13:48.060
yeah,


00:13:48.060 --> 00:13:51.620
they have a very good like, if someone is interested in seeing


00:13:51.620 --> 00:13:54.780
what pytorch 3D can do, Facebook AI Research has an own YouTube


00:13:54.780 --> 00:13:59.160
channel and they pitched PyTorch 3D on that channel.


00:13:59.160 --> 00:14:00.760
And they really do a nice,


00:14:00.760 --> 00:14:02.040
they show you what you can do with it.


00:14:02.040 --> 00:14:03.800
So it's really interesting.


00:14:03.800 --> 00:14:05.020
- Yeah. Oh, awesome.


00:14:05.020 --> 00:14:08.280
Why I guess I'd never really thought about applying,


00:14:08.280 --> 00:14:11.760
you know, AI ML stuff to 3D meshes,


00:14:11.760 --> 00:14:13.240
but it makes perfect sense.


00:14:13.240 --> 00:14:16.200
And I can see it's totally different than images.


00:14:16.200 --> 00:14:17.080
- Yeah.


00:14:17.080 --> 00:14:17.920
- Yeah.


00:14:17.920 --> 00:14:19.800
Very cool.


00:14:19.800 --> 00:14:21.680
Brian, do you guys do any,


00:14:21.680 --> 00:14:24.560
you don't do any CAD stuff with your devices, do you?


00:14:24.560 --> 00:14:26.800
- Well, I mean, yeah, some people do.


00:14:26.800 --> 00:14:27.640
(laughing)


00:14:27.640 --> 00:14:28.460
- Not me.


00:14:28.460 --> 00:14:29.760
- There's a lot of chaos that goes on


00:14:29.760 --> 00:14:31.740
in the ASIC design and stuff.


00:14:31.740 --> 00:14:32.900
- Yeah, I can imagine.


00:14:32.900 --> 00:14:35.160
Yeah, cool.


00:14:35.160 --> 00:14:37.040
All right, now, before we get to the next one,


00:14:37.040 --> 00:14:39.680
I wanna get something sorted out, Brian.


00:14:39.680 --> 00:14:40.520
- Okay.


00:14:40.520 --> 00:14:41.600
- I wanna talk about Datadog.


00:14:41.600 --> 00:14:42.960
So they're back to support the show.


00:14:42.960 --> 00:14:44.040
Thank you, Datadog.


00:14:44.040 --> 00:14:45.240
Yay!


00:14:45.240 --> 00:14:48.800
And so they're really about helping you


00:14:48.800 --> 00:14:53.120
troubleshoot latency, CPU, memory bottlenecks in your apps.


00:14:53.120 --> 00:14:54.560
And if you don't know where it's coming from,


00:14:54.560 --> 00:14:58.200
Datadog will seamlessly correlate the logs and the traces


00:14:58.200 --> 00:15:01.480
at the level of individual requests across systems,


00:15:01.480 --> 00:15:04.080
allowing you to quickly troubleshoot your Python app.


00:15:04.080 --> 00:15:07.440
And they have a continuous profiler that allows you to


00:15:07.440 --> 00:15:10.240
find the most resource consuming parts of your app


00:15:10.240 --> 00:15:13.760
in production, just running all the time at any scale,


00:15:13.760 --> 00:15:15.200
and it has very little overhead.


00:15:15.200 --> 00:15:16.040
So that's pretty cool.


00:15:16.040 --> 00:15:18.040
Instead of trying to debug it and then deploy it


00:15:18.040 --> 00:15:20.400
and hope that kind of translates to production,


00:15:20.400 --> 00:15:22.240
just turn it on and watch.


00:15:22.240 --> 00:15:23.800
So yeah, that's cool.


00:15:23.800 --> 00:15:26.360
So be the hero that got that app back on track


00:15:26.360 --> 00:15:28.960
at your company, get started with a free trial


00:15:28.960 --> 00:15:32.600
and support the podcast at pythonbytes.fm/datadog


00:15:32.600 --> 00:15:35.600
or just click the link in your podcast player show notes.


00:15:35.600 --> 00:15:37.420
Now that that's sorted out, Brian.


00:15:37.420 --> 00:15:40.200
- Yeah.


00:15:40.200 --> 00:15:41.380
Yeah, so sorting.


00:15:41.380 --> 00:15:44.740
Sorting is a thing.


00:15:44.740 --> 00:15:48.680
And the default Python containers are not sorted.


00:15:49.760 --> 00:15:53.440
And there's reasons behind that,


00:15:53.440 --> 00:15:55.680
but sometimes you need to sort stuff.


00:15:55.680 --> 00:15:58.480
So there's a Python library called,


00:15:58.480 --> 00:16:00.660
or a package called sorted containers.


00:16:00.660 --> 00:16:02.760
I like it.


00:16:02.760 --> 00:16:04.520
It's a very, I mean, I like the name at least.


00:16:04.520 --> 00:16:06.880
It's a very easy to remember sort of thing.


00:16:06.880 --> 00:16:10.620
But this is amazing.


00:16:10.620 --> 00:16:11.560
I looked into this.


00:16:11.560 --> 00:16:16.460
So this was recommended by Finch and Bao recently


00:16:16.460 --> 00:16:17.920
for us to take a look at.


00:16:17.920 --> 00:16:19.800
And it's a pure Python based,


00:16:19.800 --> 00:16:24.680
sorted collections library.


00:16:24.680 --> 00:16:28.080
And it's as fast as other packages


00:16:28.080 --> 00:16:31.360
that are built using C extensions.


00:16:31.360 --> 00:16:32.200
- Wow.


00:16:32.200 --> 00:16:34.480
- That's the impressive part.


00:16:34.480 --> 00:16:37.680
It's also fairly memory safe,


00:16:37.680 --> 00:16:41.920
but the documentation is pretty cool.


00:16:41.920 --> 00:16:45.080
There's a whole bunch of different benchmarks.


00:16:45.080 --> 00:16:47.120
So you can take a look at how it deals


00:16:47.120 --> 00:16:51.860
with large things, but it was really pretty zippy.


00:16:51.860 --> 00:16:54.220
It was pretty cool.


00:16:54.220 --> 00:16:55.920
The right on the front page, there's some,


00:16:55.920 --> 00:16:57.260
there's some example,


00:16:57.260 --> 00:16:59.580
and we're gonna throw this in the show notes too,


00:16:59.580 --> 00:17:01.660
of just, there's, you've got,


00:17:01.660 --> 00:17:04.900
it handles a handful of different data types.


00:17:04.900 --> 00:17:09.340
It shows sorted list, sorted dictionaries, and sorted set.


00:17:09.340 --> 00:17:12.820
There's also a sorted key list,


00:17:12.820 --> 00:17:15.100
and I had to look that up to figure out what that was.


00:17:15.100 --> 00:17:20.100
So sorted, the sorted function within Python


00:17:20.100 --> 00:17:22.820
allows you to pass in a key,


00:17:22.820 --> 00:17:26.720
which the key really is a function to use


00:17:26.720 --> 00:17:30.260
to create a key for sorting.


00:17:30.260 --> 00:17:33.100
- Right, 'cause the things in there


00:17:33.100 --> 00:17:35.240
might not have a natural sort, right?


00:17:35.240 --> 00:17:37.660
Like if you put a bunch of order objects in there,


00:17:37.660 --> 00:17:38.660
well, how do you sort those?


00:17:38.660 --> 00:17:40.180
Do you sort them by price?


00:17:40.180 --> 00:17:42.100
Do you sort them by date?


00:17:42.100 --> 00:17:44.020
Yeah, right, so you select out that element, yeah?


00:17:44.020 --> 00:17:45.340
- Yeah, you should have it selected out.


00:17:45.340 --> 00:17:49.660
Or you can do something like they might be sortable


00:17:49.660 --> 00:17:52.420
by default, but you want it to be like a reverse sort


00:17:52.420 --> 00:17:53.580
or something like that.


00:17:53.580 --> 00:17:54.420
- Right.


00:17:54.420 --> 00:17:56.940
- So, and there's some caveats listed


00:17:56.940 --> 00:17:58.860
so that you have to make sure that your,


00:17:58.860 --> 00:18:02.380
the key you pass in, it follows some conventions


00:18:02.380 --> 00:18:05.260
like two identical items should be,


00:18:05.260 --> 00:18:07.620
should have the same key, stuff like that.


00:18:07.620 --> 00:18:09.160
That's all reasonable things.


00:18:09.160 --> 00:18:13.860
But it's a fairly easy and complete package


00:18:13.860 --> 00:18:18.680
to just use it looks, it acts just sort of like a normal,


00:18:18.680 --> 00:18:22.100
the normal thing, containers like lists


00:18:22.100 --> 00:18:23.460
and dictionaries and sets.


00:18:23.460 --> 00:18:25.960
It just remains sorted all the time.


00:18:25.960 --> 00:18:28.820
And this is pretty incredible.


00:18:28.820 --> 00:18:32.300
- Yeah, I can totally see bugs get into your code


00:18:32.300 --> 00:18:34.340
'cause you're like, well, we put stuff into this list


00:18:34.340 --> 00:18:36.820
and oh, I want the latest one, so it's the last one,


00:18:36.820 --> 00:18:40.140
but maybe you forgot to sort it before you did that


00:18:40.140 --> 00:18:41.780
or the first one's the last


00:18:41.780 --> 00:18:43.580
'cause you reversed it or whatever.


00:18:43.580 --> 00:18:44.940
So one of the things that confused me


00:18:44.940 --> 00:18:46.460
when I first looked at this,


00:18:46.460 --> 00:18:48.080
I was scratching my head for a second


00:18:48.080 --> 00:18:51.240
'cause it looks like a fairly simple set of like examples


00:18:51.240 --> 00:18:54.740
with just like small set of elements in it.


00:18:54.740 --> 00:18:59.740
So like the first one is a list of like A, B, E, A, C, D, B,


00:18:59.740 --> 00:19:02.940
just a few characters.


00:19:02.940 --> 00:19:05.040
And it's a whole bunch of these examples


00:19:05.040 --> 00:19:06.340
with just a little small amounts.


00:19:06.340 --> 00:19:09.060
And it says underneath,


00:19:09.060 --> 00:19:12.580
it says all of the demo listed above


00:19:12.580 --> 00:19:13.960
takes a gigabyte of memory.


00:19:13.960 --> 00:19:16.000
And I'm like, what the heck?


00:19:16.000 --> 00:19:17.860
Why is it taking so much memory?


00:19:17.860 --> 00:19:18.700
(laughing)


00:19:18.700 --> 00:19:20.560
- It's only five things, come on.


00:19:20.560 --> 00:19:21.400
- Yeah, I mean, like why?


00:19:21.400 --> 00:19:23.180
- I'm gonna keep, don't worry about it.


00:19:23.180 --> 00:19:24.660
- But there's hidden in there,


00:19:24.660 --> 00:19:29.040
there's an example of that five character list,


00:19:29.040 --> 00:19:34.040
sorted list that gets multiplied by 10 million.


00:19:34.040 --> 00:19:39.280
So it's a 10, like a 50 million.


00:19:39.280 --> 00:19:42.540
- 50 million characters in a list that got sorted, right?


00:19:42.540 --> 00:19:45.500
- Yeah, so, and then like things like,


00:19:45.500 --> 00:19:47.140
and then all the operations like count.


00:19:47.140 --> 00:19:49.700
So you can say, count all the Cs in there.


00:19:49.700 --> 00:19:51.380
It'll tell you how many there are.


00:19:51.380 --> 00:19:54.120
And all of, a lot of these operations like counting stuff


00:19:54.120 --> 00:19:58.980
with a sorted set, take, you know, less than linear time.


00:19:58.980 --> 00:20:03.820
So yeah, so there's times you need sort


00:20:03.820 --> 00:20:06.140
and this is a cool one to check out.


00:20:06.140 --> 00:20:06.960
- Yeah, it's cool.


00:20:06.960 --> 00:20:09.060
It's nice that it's pure Python,


00:20:09.060 --> 00:20:10.580
super easy to install, right?


00:20:10.580 --> 00:20:17.300
It's not going to have any like weirdness around that like if you say got an m1 computer and thing won't compile or whatever


00:20:17.300 --> 00:20:20.980
No, this looks really cool yousef. What do you think?


00:20:20.980 --> 00:20:24.020
This looks amazing. i'm also


00:20:24.020 --> 00:20:27.860
I'm in touch with my brother. Um on the side and he's also watching


00:20:27.860 --> 00:20:34.420
Our office at the moment and he's also saying because of the one gigabyte memory for sorting is it's incredible. It's crazy


00:20:36.260 --> 00:20:37.940
- Yeah, that's pretty awesome.


00:20:37.940 --> 00:20:40.100
I guess it's just showing like you can have a ton


00:20:40.100 --> 00:20:41.180
and it's all nice.


00:20:41.180 --> 00:20:43.100
So it's, I mean, it seems really straightforward


00:20:43.100 --> 00:20:45.180
but having these things sorted,


00:20:45.180 --> 00:20:48.680
we just got dictionaries that would stay put.


00:20:48.680 --> 00:20:51.320
So having sorted dictionaries is also cool.


00:20:51.320 --> 00:20:56.020
Right, it used to be that they sort of,


00:20:56.020 --> 00:20:57.280
if they had the same keys and stuff


00:20:57.280 --> 00:20:59.400
or they wouldn't necessarily retain their order


00:20:59.400 --> 00:21:01.540
of the things you added, but now they do.


00:21:01.540 --> 00:21:03.460
- Right, so if people are confused and think,


00:21:03.460 --> 00:21:05.200
well, aren't dictionaries already sorted?


00:21:05.200 --> 00:21:08.760
No, they just stay in the order that they were created.


00:21:08.760 --> 00:21:10.440
- Exactly.


00:21:10.440 --> 00:21:14.520
Yeah, similar, but not exactly the same thing.


00:21:14.520 --> 00:21:18.000
All right, so I wanna, this next one,


00:21:18.000 --> 00:21:20.200
I wanna riff a little bit on typing


00:21:20.200 --> 00:21:23.120
and I wanna do that around a tweet,


00:21:23.120 --> 00:21:25.960
which I think I've got to put into a different type of,


00:21:25.960 --> 00:21:29.740
hold on.


00:21:29.740 --> 00:21:33.520
For some reason, Twitter has stopped showing me


00:21:33.520 --> 00:21:36.580
like the entire conversation of things.


00:21:36.580 --> 00:21:39.580
I don't know why, but I guess it doesn't really matter.


00:21:39.580 --> 00:21:44.040
So Lucas Lenga responded to a tweet that went out there.


00:21:44.040 --> 00:21:47.080
You know, Lucas is obviously he's core developer.


00:21:47.080 --> 00:21:48.480
He's been doing really important stuff,


00:21:48.480 --> 00:21:51.400
but one of the main focuses that he's been working on


00:21:51.400 --> 00:21:55.720
is around type hints and typing with things like mypy.


00:21:55.720 --> 00:21:59.080
He was instrumental in bringing typing to Facebook


00:21:59.080 --> 00:22:02.720
and the Instagram code bases and things like that.


00:22:02.720 --> 00:22:09.200
So there's a tweet that says controversial take types in a Python code base are a net negative


00:22:09.200 --> 00:22:16.080
That's not lucas. This is his he's about to have a whole long conversation about this that i'm gonna talk about but


00:22:16.080 --> 00:22:18.480
um


00:22:18.480 --> 00:22:20.480
Brian, what do you think?


00:22:20.480 --> 00:22:25.120
You retweeted this them's fighting words, them's is fighting words


00:22:25.120 --> 00:22:27.680
Yeah


00:22:27.680 --> 00:22:29.680
So yeah, what do you think?


00:22:32.000 --> 00:22:34.000
I think that they're good.


00:22:34.000 --> 00:22:36.880
Yeah, I do too. I think


00:22:36.880 --> 00:22:41.940
When I first saw them I was a little concerned like oh my goodness. This is going to potentially


00:22:41.940 --> 00:22:44.000
you know


00:22:44.000 --> 00:22:46.500
Turn python into something like typescript


00:22:46.500 --> 00:22:52.240
And while I appreciate what typescript does to make javascript much better


00:22:52.240 --> 00:22:58.000
I almost always walk away from working with typescript with a feeling of like, ah that kind of hurt and was painful


00:22:58.000 --> 00:23:00.000
I wonder why it had to go that way, you know


00:23:00.080 --> 00:23:03.200
Because the TypeScript requires, it's like,


00:23:03.200 --> 00:23:05.800
it's like C# or C++,


00:23:05.800 --> 00:23:08.240
the types have to match and they have to be there.


00:23:08.240 --> 00:23:09.760
And if they don't match at all,


00:23:09.760 --> 00:23:12.800
then it just won't work, right?


00:23:12.800 --> 00:23:13.680
It's super frustrating.


00:23:13.680 --> 00:23:15.200
Oh, this thing is not defined.


00:23:15.200 --> 00:23:15.880
And you know, there's,


00:23:15.880 --> 00:23:17.800
because there's libraries that might not have types.


00:23:17.800 --> 00:23:18.880
And then how do you work with them?


00:23:18.880 --> 00:23:20.200
It's just if I find it,


00:23:20.200 --> 00:23:21.640
there's always some little edge case.


00:23:21.640 --> 00:23:22.960
It's like, oh, this is frustrating.


00:23:22.960 --> 00:23:24.960
But I never feel that way with Python.


00:23:24.960 --> 00:23:27.800
And I really have come to love Python's type hints.


00:23:28.600 --> 00:23:32.940
And obviously, Lucas starts out his conversation saying,


00:23:32.940 --> 00:23:34.300
"This is easily disproven."


00:23:34.300 --> 00:23:36.300
If you ever use PyCharm or VS Code,


00:23:36.300 --> 00:23:40.500
the code completion in there is based on type annotations.


00:23:40.500 --> 00:23:43.340
If you've ever seen your editor highlight a function


00:23:43.340 --> 00:23:47.140
and squiggly say, "This expects something else than what you're giving it,"


00:23:47.140 --> 00:23:49.300
besides the number of variables,


00:23:49.300 --> 00:23:53.340
but like you're giving it a string and it wants a number or something like that,


00:23:53.340 --> 00:23:55.900
you're using type annotations.


00:23:55.900 --> 00:23:58.500
And you can enhance your code by doing that, right?


00:23:58.500 --> 00:24:02.420
So I was actually talking to Yusef about this yesterday.


00:24:02.420 --> 00:24:05.220
My philosophy, or maybe my rule of thumb


00:24:05.220 --> 00:24:06.700
is you don't have to always do it this way,


00:24:06.700 --> 00:24:09.900
but if you're working in your editor


00:24:09.900 --> 00:24:13.740
and you have to type more than say three characters


00:24:13.740 --> 00:24:15.740
to get some kind of symbol to come up,


00:24:15.740 --> 00:24:16.740
you're probably doing it wrong.


00:24:16.740 --> 00:24:19.100
So like if you have email service


00:24:19.100 --> 00:24:23.780
and you wanna have email service send account email,


00:24:23.780 --> 00:24:26.620
you should be able to say .sae,


00:24:26.620 --> 00:24:29.020
and it should know the type that's been returned,


00:24:29.020 --> 00:24:32.620
what an email service is, that it has this property,


00:24:32.620 --> 00:24:34.620
and just write it for you.


00:24:34.620 --> 00:24:36.620
So to me, a lot of the typing stuff,


00:24:36.620 --> 00:24:38.620
I mean, this comment is somewhat about bugs,


00:24:38.620 --> 00:24:40.620
like I never found a good bug because of this.


00:24:40.620 --> 00:24:43.620
To me, that's almost like a side benefit.


00:24:43.620 --> 00:24:46.620
It's about quickly generating code


00:24:46.620 --> 00:24:49.620
without stopping to go look at the code definition,


00:24:49.620 --> 00:24:51.620
without going over to the documentation


00:24:51.620 --> 00:24:53.620
to see what I could have typed over here.


00:24:53.620 --> 00:24:56.380
the documentation to see what I could have typed over here.


00:24:56.380 --> 00:25:01.060
You know, it's for example, AWS people,


00:25:01.060 --> 00:25:04.300
this is insanely frustrating to work with AWS


00:25:04.300 --> 00:25:06.460
because you get these like weird,


00:25:06.460 --> 00:25:08.180
create this service and you give it a name


00:25:08.180 --> 00:25:09.660
and then you get an S3 service back,


00:25:09.660 --> 00:25:12.520
but it has no idea that it's an S3 service.


00:25:12.520 --> 00:25:15.740
So you get zero help on what anything,


00:25:15.740 --> 00:25:17.820
even I think go to definition doesn't quite work


00:25:17.820 --> 00:25:20.660
because it's, you know, use some factory method


00:25:20.660 --> 00:25:22.780
to reach down some weird place and get the thing.


00:25:22.780 --> 00:25:26.700
So I think really driving the code generation experience


00:25:26.700 --> 00:25:28.940
without being in documentation,


00:25:28.940 --> 00:25:31.380
without jumping around and reading all the source,


00:25:31.380 --> 00:25:32.700
just go for it.


00:25:32.700 --> 00:25:33.900
I think it's super nice.


00:25:33.900 --> 00:25:37.820
So to me, that is the biggest win of all of this stuff.


00:25:37.820 --> 00:25:43.060
So let me--


00:25:43.060 --> 00:25:45.300
- The entire thread is very interesting.


00:25:45.300 --> 00:25:46.540
So--


00:25:46.540 --> 00:25:48.460
- So let me touch on a couple of the points of the thread


00:25:48.460 --> 00:25:51.060
'cause I can't get it to come up in the screen share,


00:25:51.060 --> 00:25:51.980
but that's fine.


00:25:51.980 --> 00:25:53.820
I took notes, luckily.


00:25:53.820 --> 00:25:56.500
So some of the things he pointed out,


00:25:56.500 --> 00:25:58.540
he's like, here's tweet one of 10.


00:25:58.540 --> 00:26:02.220
So number one, put enough annotations,


00:26:02.220 --> 00:26:04.420
and then the tooling will connect the dots


00:26:04.420 --> 00:26:06.100
and make plenty of errors evident,


00:26:06.100 --> 00:26:09.740
as well as like heighten this code generation,


00:26:09.740 --> 00:26:11.300
auto magic, right?


00:26:11.300 --> 00:26:12.380
That's one.


00:26:12.380 --> 00:26:15.120
The most common types of errors though,


00:26:15.120 --> 00:26:18.280
that'll creep in is if none is being used


00:26:18.280 --> 00:26:20.500
where you expect a concrete type.


00:26:20.500 --> 00:26:22.340
And things like mypy will say,


00:26:22.340 --> 00:26:25.620
you're using a type that is an optional of something,


00:26:25.620 --> 00:26:27.260
but you're not checking to see if it's none


00:26:27.260 --> 00:26:29.040
before you dereference it.


00:26:29.040 --> 00:26:30.780
You're probably gonna end up at some point


00:26:30.780 --> 00:26:35.180
with an attribute, none type does not contain attribute,


00:26:35.180 --> 00:26:37.820
whatever you tried to do, you know, upper or whatever.


00:26:37.820 --> 00:26:41.260
- None is not scriptable or subscriptable.


00:26:41.260 --> 00:26:44.020
- Yes, so yeah, something like that, right?


00:26:44.020 --> 00:26:46.500
Or callable or any of the things.


00:26:46.500 --> 00:26:50.660
Also, another common bug is the return case.


00:26:50.660 --> 00:26:55.660
So if you've got a function, you can maybe check something


00:26:55.660 --> 00:26:58.660
and return one value, check something else,


00:26:58.660 --> 00:26:59.580
return another value.


00:26:59.580 --> 00:27:02.140
But if you forget at the end and you fall through


00:27:02.140 --> 00:27:05.860
and you don't put up some kind of concrete return type,


00:27:05.860 --> 00:27:07.580
Python functions just return none.


00:27:07.580 --> 00:27:10.740
Like this actually blew me away when I learned Python


00:27:10.740 --> 00:27:12.220
and I learned about functions


00:27:12.220 --> 00:27:14.580
that they always, always, always return something.


00:27:14.580 --> 00:27:17.820
There's no such thing as a void function in Python.


00:27:17.820 --> 00:27:19.140
- Yeah.


00:27:19.140 --> 00:27:20.420
- All right, as a C++ person,


00:27:20.420 --> 00:27:21.820
that probably surprised you too, right?


00:27:21.820 --> 00:27:23.860
Like with your C++ background.


00:27:23.860 --> 00:27:26.240
- I did a bunch of other Perl and stuff like that.


00:27:26.240 --> 00:27:27.820
So it wasn't too bad.


00:27:27.820 --> 00:27:31.620
But the return type is actually


00:27:31.620 --> 00:27:33.780
one of the greatest documentation features as well,


00:27:33.780 --> 00:27:37.540
because sometimes you can kind of figure out


00:27:37.540 --> 00:27:39.780
what the parameters are gonna look like.


00:27:39.780 --> 00:27:41.740
Think, you know, you can guess.


00:27:41.740 --> 00:27:43.620
But what's the return type?


00:27:43.620 --> 00:27:45.700
Is it going to be a list? Is it going to be a tuple?


00:27:45.700 --> 00:27:47.220
Is it going to be a single element?


00:27:47.220 --> 00:27:49.580
What if there's more than one element?


00:27:49.580 --> 00:27:53.060
Yeah, having type hints around return types


00:27:53.060 --> 00:27:55.100
is a great feature.


00:27:55.100 --> 00:27:56.980
- Yeah, absolutely.


00:27:56.980 --> 00:27:58.380
All right, let me touch on a couple more


00:27:58.380 --> 00:28:02.900
and I see some listener comments in the stream as well.


00:28:02.900 --> 00:28:04.940
Squiggly lines in your editor, anyone?


00:28:04.940 --> 00:28:06.340
Like I just got this the other day.


00:28:06.340 --> 00:28:09.620
I thought I was supposed to pass an object ID,


00:28:09.620 --> 00:28:12.540
the primary key Mongo, but we overwritten it


00:28:12.540 --> 00:28:15.640
and it's actually a string and said you're passing object ID


00:28:15.640 --> 00:28:16.480
when you expect a string.


00:28:16.480 --> 00:28:18.060
I'm like, oh, yeah, I guess I am.


00:28:18.060 --> 00:28:20.240
All right, well, change that, right?


00:28:20.240 --> 00:28:23.400
That's really nice instead of that being a runtime error.


00:28:23.400 --> 00:28:28.320
And he talks about the work with TypeScript


00:28:28.320 --> 00:28:30.900
and Anders Halsberg and what he did to help build that.


00:28:30.900 --> 00:28:33.360
And TypeScript, like I said, is pretty neat.


00:28:33.360 --> 00:28:34.800
But he also points out that, you know,


00:28:34.800 --> 00:28:36.960
the same company Microsoft is developing


00:28:36.960 --> 00:28:39.260
powerful type checking and code completion


00:28:39.260 --> 00:28:41.400
for Python with VS Code.


00:28:41.400 --> 00:28:45.020
And they have one of the Python steering council folks


00:28:45.020 --> 00:28:47.800
working on there, hint, maybe that's Brett.


00:28:47.800 --> 00:28:51.500
And also possibly the Python creator himself, Guido.


00:28:51.500 --> 00:28:53.420
So do you think those two people


00:28:53.420 --> 00:28:54.400
would be working on something


00:28:54.400 --> 00:28:56.840
that just provides the illusion of productivity?


00:28:56.840 --> 00:28:58.020
Probably not.


00:28:58.020 --> 00:29:01.220
So let's see a couple of comments.


00:29:01.220 --> 00:29:03.160
Chris May, hey Chris, happy to see you out there.


00:29:03.160 --> 00:29:05.800
He says, "Code completion is such a confidence builder too."


00:29:05.800 --> 00:29:08.040
I think it's so awesome because for me,


00:29:08.040 --> 00:29:09.580
it's both amazing for beginners


00:29:09.580 --> 00:29:12.180
because they can type dot and go, now what?


00:29:12.180 --> 00:29:16.160
And for experts, they can just blast out code so quickly


00:29:16.160 --> 00:29:17.920
because you just type dot a few things


00:29:17.920 --> 00:29:19.640
and you know, like you said, with confidence,


00:29:19.640 --> 00:29:20.640
you just keep going.


00:29:20.640 --> 00:29:24.080
- A lot of these-- - Oh, you go, Brian.


00:29:24.080 --> 00:29:26.600
- Oh, sorry, a lot of these features,


00:29:26.600 --> 00:29:29.200
you get them if everybody around you


00:29:29.200 --> 00:29:32.800
writing the code that you're using is using type hints.


00:29:32.800 --> 00:29:35.760
You don't necessarily need to use type hints yourself,


00:29:35.760 --> 00:29:38.340
but then you're being a bad citizen


00:29:38.340 --> 00:29:41.220
and not helping the people out that you're sharing code with.


00:29:41.220 --> 00:29:42.720
So if you don't share code at all,


00:29:42.720 --> 00:29:44.980
and you're only working on projects with yourself,


00:29:44.980 --> 00:29:47.820
then go ahead, don't use type-ins.


00:29:47.820 --> 00:29:49.060
- It's up to you, right?


00:29:49.060 --> 00:29:50.660
Yeah, absolutely.


00:29:50.660 --> 00:29:52.460
Yusef, what do you think?


00:29:52.460 --> 00:29:55.200
Do you guys use type-ins on your project?


00:29:55.200 --> 00:29:57.340
- No, not really.


00:29:57.340 --> 00:29:59.940
It's not something that's in our conscious mind,


00:29:59.940 --> 00:30:01.180
I would say.


00:30:01.180 --> 00:30:02.740
I'm not sure if that's also something


00:30:02.740 --> 00:30:04.620
really because you're an engineer.


00:30:04.620 --> 00:30:06.220
I wouldn't want to generalize,


00:30:06.220 --> 00:30:09.580
but engineers are usually bothered with the problem itself


00:30:09.580 --> 00:30:13.220
rather than digging down on the types, for example.


00:30:13.220 --> 00:30:15.700
It depends also what language you use.


00:30:15.700 --> 00:30:20.000
- Yeah, it's a bit of a computer science-y topic,


00:30:20.000 --> 00:30:22.960
I can see, but yeah, I just, like I said,


00:30:22.960 --> 00:30:26.740
I love how it generates the content so much easier.


00:30:26.740 --> 00:30:32.720
Maxson also commented, I love, for example, Pydantic,


00:30:32.720 --> 00:30:35.000
but I agree with Romalo, Luciano Romalo,


00:30:35.000 --> 00:30:35.900
who was in this thread.


00:30:35.900 --> 00:30:38.340
Hopefully it won't be required in Python


00:30:38.340 --> 00:30:40.480
to help people get started.


00:30:40.480 --> 00:30:42.640
Yeah, so I think the typing stuff is really interesting.


00:30:42.640 --> 00:30:44.260
Like Pydantic, we've talked about a bunch.


00:30:44.260 --> 00:30:47.700
It's a super interesting example of really using typing


00:30:47.700 --> 00:30:52.140
to generate cool data ingestion and processing.


00:30:52.140 --> 00:30:54.060
Like if you say I've got a Pydantic model


00:30:54.060 --> 00:30:56.060
and one of its fields is a list of integers,


00:30:56.060 --> 00:30:58.580
but you give it a list and the things in the list


00:30:58.580 --> 00:31:00.500
happen to be strings that could be integers,


00:31:00.500 --> 00:31:01.980
it'll automatically convert it


00:31:01.980 --> 00:31:04.340
and stuff like that is really fantastic.


00:31:04.340 --> 00:31:07.840
I think that's always going to be an add-on type of thing.


00:31:07.840 --> 00:31:11.000
Yeah, even though I'm a fan of type hints,


00:31:11.000 --> 00:31:12.300
I don't use them all the time,


00:31:12.300 --> 00:31:16.040
and I would be very opposed to having them be required.


00:31:16.040 --> 00:31:18.140
Yes, I would too. I would too.


00:31:18.140 --> 00:31:20.000
I don't think they need to be on the whole code base.


00:31:20.000 --> 00:31:23.000
I mean, it depends if your goal is to say,


00:31:23.000 --> 00:31:25.600
"I want to use them for my.py or my.pyc


00:31:25.600 --> 00:31:27.700
and completely generate stuff."


00:31:27.700 --> 00:31:30.700
But if your goal really is to get a little bit of help


00:31:30.700 --> 00:31:32.660
with editors, just having it on the boundaries,


00:31:32.660 --> 00:31:34.240
like, "Here's the data access layer.


00:31:34.240 --> 00:31:37.360
the things that come out of there return whatever.


00:31:37.360 --> 00:31:39.200
And you don't have to do anything else


00:31:39.200 --> 00:31:41.560
and the editors will pick it up and run.


00:31:41.560 --> 00:31:43.100
Yeah, yeah, yeah.


00:31:43.100 --> 00:31:45.800
All right, one quick question.


00:31:45.800 --> 00:31:48.000
What is a function return if there is no return?


00:31:48.000 --> 00:31:49.920
It returns none.


00:31:49.920 --> 00:31:50.740
It returns none.


00:31:50.740 --> 00:31:51.880
So that's why you don't ever just say


00:31:51.880 --> 00:31:54.580
whether there's a return type, it always returns none.


00:31:54.580 --> 00:31:59.600
All right, next up,


00:32:00.500 --> 00:32:04.620
I guess we got the one I tried to open with there, Yusef,


00:32:04.620 --> 00:32:07.460
is Open3D.


00:32:07.460 --> 00:32:09.100
That looks fun.


00:32:09.100 --> 00:32:11.320
- Yeah, this is basically a library


00:32:11.320 --> 00:32:13.700
which you could use in Jupyter, which I tried to use,


00:32:13.700 --> 00:32:15.420
but somehow they, at the moment,


00:32:15.420 --> 00:32:17.660
have problems using Open3D.


00:32:17.660 --> 00:32:19.260
So what you can do is you call Open3D


00:32:19.260 --> 00:32:20.140
in your Jupyter notebook


00:32:20.140 --> 00:32:23.220
and then have the point cloud visualized.


00:32:23.220 --> 00:32:24.520
However, there are some ways around it,


00:32:24.520 --> 00:32:27.700
but Open3D, I think if I would start all over again,


00:32:27.700 --> 00:32:28.980
I would probably use Open3D


00:32:28.980 --> 00:32:30.980
to visualize my point cloud,


00:32:30.980 --> 00:32:33.780
which I'm actually working with in my Jupyter notebook.


00:32:33.780 --> 00:32:35.780
I'm not sure if using a Jupyter notebook


00:32:35.780 --> 00:32:37.780
is also something you would recommend personally,


00:32:37.780 --> 00:32:39.820
maybe Brian and Michael,


00:32:39.820 --> 00:32:41.820
if you're a fan of Jupyter notebooks.


00:32:41.820 --> 00:32:43.260
I think it depends on the application.


00:32:43.260 --> 00:32:44.620
- I think it depends as well.


00:32:44.620 --> 00:32:49.620
And to me, it really depends on what I'm trying to do


00:32:49.620 --> 00:32:51.980
and like the kind of code.


00:32:51.980 --> 00:32:53.620
Am I trying to explore data


00:32:53.620 --> 00:32:56.620
and does it have a really strong visualization component


00:32:56.620 --> 00:32:58.740
or is it like a utility type thing?


00:32:58.740 --> 00:33:03.180
So for example, one of the things that I wrote recently


00:33:03.180 --> 00:33:05.420
that I would never put into a Jupyter notebook,


00:33:05.420 --> 00:33:08.060
but I find really helpful is we've got


00:33:08.060 --> 00:33:11.300
literally thousands of video files,


00:33:11.300 --> 00:33:14.420
MP4s and whatnot for the online courses.


00:33:14.420 --> 00:33:16.500
And in order to import them,


00:33:16.500 --> 00:33:18.580
one of the things I have to tell the database


00:33:18.580 --> 00:33:21.940
is how long in seconds is each file


00:33:21.940 --> 00:33:24.180
and where does it live and stuff.


00:33:24.180 --> 00:33:25.700
So I've got a little script and I just say,


00:33:25.700 --> 00:33:29.700
go to this directory and generate a little JSON output


00:33:29.700 --> 00:33:33.340
for all of the files and parse them


00:33:33.340 --> 00:33:34.420
and tell me how long they are.


00:33:34.420 --> 00:33:36.380
Like that kind of app doesn't belong there, right?


00:33:36.380 --> 00:33:37.780
It's just, that's a command line type


00:33:37.780 --> 00:33:39.660
of utility type of thing.


00:33:39.660 --> 00:33:41.660
But if I wanna visualize something like this,


00:33:41.660 --> 00:33:44.900
I think it may well be really good for it actually.


00:33:44.900 --> 00:33:46.120
So I think it varies.


00:33:46.120 --> 00:33:52.980
- Yeah, there's a lot of application parts of my work


00:33:52.980 --> 00:33:55.540
that I think using a Jupyter Notebook


00:33:55.540 --> 00:33:57.800
actually might be more beneficial.


00:33:57.800 --> 00:34:01.720
So I'm often taking big, huge trace data and stuff


00:34:01.720 --> 00:34:04.560
for like spectrum traces.


00:34:04.560 --> 00:34:08.940
And those could easily be driven from a Jupyter notebook


00:34:08.940 --> 00:34:12.240
and with the visualization stuff would be good.


00:34:12.240 --> 00:34:14.880
- Yep.


00:34:14.880 --> 00:34:18.140
Yeah, cool.


00:34:18.140 --> 00:34:23.140
So this thing is a set of both C++ and Python libraries


00:34:24.780 --> 00:34:29.280
for basically working with 3D Meshes, right?


00:34:29.280 --> 00:34:33.740
- Mostly 3D data, for example, if you use a LiDAR,


00:34:33.740 --> 00:34:36.020
so when you work with a laser and...


00:34:36.020 --> 00:34:36.920
This looks, for example, great.


00:34:36.920 --> 00:34:39.540
I never watched the video, but if you scan objects


00:34:39.540 --> 00:34:42.980
in your surroundings, usually what you get is a point cloud,


00:34:42.980 --> 00:34:46.620
and which you can then visualize using Open3D.


00:34:46.620 --> 00:34:48.980
And the big disadvantage with point clouds


00:34:48.980 --> 00:34:51.620
is that they're kind of unstructured.


00:34:51.620 --> 00:34:55.180
So you could have one matrix representing one point cloud,


00:34:55.180 --> 00:34:58.060
and you could have the same matrix switching two points,


00:34:58.060 --> 00:35:00.300
but the matrix would be different.


00:35:00.300 --> 00:35:02.340
So this is also a problem that a lot of papers


00:35:02.340 --> 00:35:04.040
try to tackle and make sure that,


00:35:04.040 --> 00:35:08.820
yeah, get around this bottleneck.


00:35:08.820 --> 00:35:12.500
- Nice, yeah, the example video here is using


00:35:12.500 --> 00:35:17.460
open 3D for 3D object detection, which is,


00:35:17.460 --> 00:35:18.420
that's pretty wild.


00:35:20.900 --> 00:35:21.780
- Yeah, nice.


00:35:21.780 --> 00:35:23.580
- The things people do these days.


00:35:23.580 --> 00:35:25.740
- I know, I think it's really interesting


00:35:25.740 --> 00:35:30.020
all this image processing analysis stuff.


00:35:30.020 --> 00:35:31.180
Yeah.


00:35:31.180 --> 00:35:32.340
- Good question, Brian, by the way.


00:35:32.340 --> 00:35:35.100
This is what I ask myself when I listen to Python bytes.


00:35:35.100 --> 00:35:37.100
As an engineer, what are you guys doing?


00:35:37.100 --> 00:35:37.940
It's great.


00:35:37.940 --> 00:35:40.220
(laughing)


00:35:40.220 --> 00:35:41.160
- Absolutely.


00:35:41.160 --> 00:35:45.340
Cool, all right, well, that's it for all of our main items.


00:35:45.340 --> 00:35:48.140
Brian, you got anything extra


00:35:48.140 --> 00:35:50.020
that you wanna throw out there?


00:35:50.020 --> 00:35:52.500
- Yeah, I just wanted a couple of things.


00:35:52.500 --> 00:35:56.460
One, 2021 has been exhausting so far.


00:35:56.460 --> 00:35:57.300
- Yeah.


00:35:57.300 --> 00:35:59.060
- I don't know if anybody else has got the same experience,


00:35:59.060 --> 00:35:59.880
but wow.


00:35:59.880 --> 00:36:03.580
And also I've got a lot of extra projects,


00:36:03.580 --> 00:36:05.580
side projects that I'm working on right now.


00:36:05.580 --> 00:36:06.720
Python Bytes is one of them,


00:36:06.720 --> 00:36:08.620
but there's other stuff going on as well,


00:36:08.620 --> 00:36:10.200
trying to do more writing.


00:36:10.200 --> 00:36:12.300
And because of that,


00:36:12.300 --> 00:36:17.300
testing code has shifted to an every other week cadence.


00:36:17.300 --> 00:36:19.800
So it's not going away.


00:36:19.800 --> 00:36:22.960
I know a lot of, oddly enough, I've had a lot of feedback


00:36:22.960 --> 00:36:24.800
in the last couple of months of people saying,


00:36:24.800 --> 00:36:27.840
"Thank you for the podcast, I've learned so much."


00:36:27.840 --> 00:36:30.120
So I do not, I don't wanna shut it down.


00:36:30.120 --> 00:36:31.580
I wanna keep it going.


00:36:31.580 --> 00:36:33.080
And there's no plans on shutting it down.


00:36:33.080 --> 00:36:35.600
It's just slowing down so that I have room in my life


00:36:35.600 --> 00:36:37.360
for other projects as well.


00:36:37.360 --> 00:36:39.680
So just wanted to let people know that.


00:36:39.680 --> 00:36:41.080
- Yeah, cool.


00:36:41.080 --> 00:36:43.760
Yeah, I try to, for a Talk Python,


00:36:43.760 --> 00:36:45.320
batch it up and do a whole bunch.


00:36:45.320 --> 00:36:47.240
Just say, "This week, I'm just gonna get nothing done,


00:36:47.240 --> 00:36:48.600
"but I'll do a ton of recording."


00:36:48.600 --> 00:36:50.480
and then just roll them out.


00:36:50.480 --> 00:36:53.520
I had three months of stuff done in like a week and a half.


00:36:53.520 --> 00:36:55.400
I was, I really needed a break after that,


00:36:55.400 --> 00:36:56.740
but then I was good.


00:36:56.740 --> 00:36:59.320
- Cool.


00:36:59.320 --> 00:37:00.160
- Yeah, cool.


00:37:00.160 --> 00:37:02.000
Well, thanks for the update.


00:37:02.000 --> 00:37:04.480
Yusef, anything you want to share


00:37:04.480 --> 00:37:06.320
on the way out into the show?


00:37:06.320 --> 00:37:09.800
- I just want to say thank you for letting me


00:37:09.800 --> 00:37:13.440
or being able to participate in this quick and brief podcast


00:37:13.440 --> 00:37:14.800
and keep doing what you do guys.


00:37:14.800 --> 00:37:16.840
I follow you both on Twitter and what you share


00:37:16.840 --> 00:37:18.560
and what you do is really amazing.


00:37:18.560 --> 00:37:20.320
So it's really inspiring for an engineer


00:37:20.320 --> 00:37:22.080
who wants to delve into the field of Python


00:37:22.080 --> 00:37:26.000
and all fancy kind of things to listen to your podcast,


00:37:26.000 --> 00:37:28.600
taking your courses or following you on social media.


00:37:28.600 --> 00:37:29.440
It's just really great.


00:37:29.440 --> 00:37:30.360
You learn a lot.


00:37:30.360 --> 00:37:34.280
And I actually have to learn more, to be honest to myself.


00:37:34.280 --> 00:37:35.680
- Yeah, I have to learn more.


00:37:35.680 --> 00:37:37.480
It never stops.


00:37:37.480 --> 00:37:38.300
It never stops.


00:37:38.300 --> 00:37:39.400
- Yeah, that's right.


00:37:39.400 --> 00:37:40.240
- Yeah, but that's awesome.


00:37:40.240 --> 00:37:41.060
Thank you so much.


00:37:41.060 --> 00:37:42.240
I really appreciate that.


00:37:42.240 --> 00:37:43.640
- How about you, Michael?


00:37:43.640 --> 00:37:45.400
- I have one quick thing.


00:37:45.400 --> 00:37:48.720
driven by yours, a comment you had last time.


00:37:48.720 --> 00:37:51.560
So Francisco Silva pointed out,


00:37:51.560 --> 00:37:54.560
we had talked about some of the numpyc,


00:37:54.560 --> 00:38:00.300
Pythonic, the idiomatic numpy stuff that you might do


00:38:00.300 --> 00:38:02.480
and how like, instead of looping over stuff,


00:38:02.480 --> 00:38:05.040
you can just like add, say like two numpy arrays


00:38:05.040 --> 00:38:07.420
and it'll add them or you can dot product them


00:38:07.420 --> 00:38:09.040
and whatnot, right?


00:38:09.040 --> 00:38:11.040
So one of the things you can do,


00:38:11.040 --> 00:38:13.000
I guess we also talked about like ones and zeros


00:38:13.000 --> 00:38:16.820
to generate a pre-built list of those.


00:38:16.820 --> 00:38:18.300
So one of the things he talked about


00:38:18.300 --> 00:38:21.260
is the all close method.


00:38:21.260 --> 00:38:23.100
So if you've got floating point numbers,


00:38:23.100 --> 00:38:24.820
one of the things that's really frustrating


00:38:24.820 --> 00:38:26.140
is like, are these equal?


00:38:26.140 --> 00:38:29.420
Well, does it mean floating point numbers equal, right?


00:38:29.420 --> 00:38:34.140
Like they could be so nearly the same, but not the same,


00:38:34.140 --> 00:38:37.900
right, they could be within an insane amount of closeness,


00:38:37.900 --> 00:38:41.460
right, like 10 decimal places and then a one, right?


00:38:41.460 --> 00:38:43.980
So all close is like, well, if they're within,


00:38:43.980 --> 00:38:46.900
you know, one one thousandth of each other,


00:38:46.900 --> 00:38:48.220
consider them the same.


00:38:48.220 --> 00:38:49.860
- Well, all close takes a bunch of parameters


00:38:49.860 --> 00:38:52.660
that you can specify the tolerance though.


00:38:52.660 --> 00:38:54.700
- Yeah.


00:38:54.700 --> 00:38:56.220
Anyway, I thought that was cool.


00:38:56.220 --> 00:38:57.060
- Yeah.


00:38:57.060 --> 00:39:00.180
Hey, while we're on the topic, I may as well throw out,


00:39:00.180 --> 00:39:01.140
I've got it.


00:39:01.140 --> 00:39:04.100
So I tried to use this method of using NumPy


00:39:04.100 --> 00:39:05.900
and I ran into a problem.


00:39:05.900 --> 00:39:08.300
So I'm hoping some data science people can help me


00:39:08.300 --> 00:39:09.980
figure out how to solve it.


00:39:09.980 --> 00:39:12.100
So my problem is just the simple thing.


00:39:12.100 --> 00:39:13.900
If I've got two arrays,


00:39:13.900 --> 00:39:16.500
I wanna see if all of the elements are element wise


00:39:16.500 --> 00:39:20.140
less than or equal to the other element in the other array.


00:39:20.140 --> 00:39:22.460
Okay, I can do that with NumPy,


00:39:22.460 --> 00:39:23.420
but what I can't,


00:39:23.420 --> 00:39:26.100
that assumes that all of the elements


00:39:26.100 --> 00:39:29.580
are the same data type, like comparable.


00:39:29.580 --> 00:39:33.940
If there are strings thrown in there, it doesn't work.


00:39:33.940 --> 00:39:37.320
So obviously, I don't know if it's obvious,


00:39:37.320 --> 00:39:40.760
but so I had to do some cleanup at a time,


00:39:40.760 --> 00:39:42.920
but I don't know what the most, the best way is.


00:39:42.920 --> 00:39:45.880
So reach out to me if you've got any.


00:39:45.880 --> 00:39:46.960
- Awesome, yeah, I don't have an answer,


00:39:46.960 --> 00:39:48.240
but I'm sure people do.


00:39:48.240 --> 00:39:51.720
And a quick, quick comment here.


00:39:51.720 --> 00:39:53.400
This is the one I wanna show.


00:39:53.400 --> 00:39:58.200
Magnus Carlsen says, "Tip, I found out about Copier,


00:39:58.200 --> 00:40:01.800
"an alternative to cookie cutter that can be run later


00:40:01.800 --> 00:40:04.640
"as well to update the project to a newer template."


00:40:05.880 --> 00:40:07.880
That's pretty cool. I hadn't heard of that.


00:40:07.880 --> 00:40:11.120
And also, Toml spec has reached 1.0.


00:40:11.120 --> 00:40:14.460
Parser might be added to the standard lib.


00:40:14.460 --> 00:40:16.840
Also haven't covered that, but that's cool news.


00:40:16.840 --> 00:40:18.840
Thanks for sharing, you guys.


00:40:18.840 --> 00:40:21.840
And I guess...


00:40:21.840 --> 00:40:23.840
Thanks for being here.


00:40:23.840 --> 00:40:26.840
Yousef, thanks for joining us. And Brian, thank you as always, man.


00:40:26.840 --> 00:40:29.840
- Thank you. - Thank you so much, guys.


00:40:29.840 --> 00:40:31.840
- Bye, everyone. - Bye.


00:40:31.840 --> 00:40:41.840
[BLANK_AUDIO]

