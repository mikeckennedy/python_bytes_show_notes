WEBVTT

00:00:00.840 --> 00:00:01.580
Hey, Brian.

00:00:01.580 --> 00:00:02.320
Hey.

00:00:02.320 --> 00:00:02.640
Happy Monday.

00:00:02.640 --> 00:00:04.200
Yeah, happy Monday.

00:00:04.200 --> 00:00:05.520
Yeah, happy Monday.

00:00:05.520 --> 00:00:06.300
Happy Monday, everyone.

00:00:06.300 --> 00:00:09.600
And if you're watching later, well, happy whatever day it is.

00:00:09.600 --> 00:00:10.300
It ends in Y.

00:00:10.300 --> 00:00:11.140
It's one of those days.

00:00:11.140 --> 00:00:12.640
Let's do it, huh?

00:00:12.640 --> 00:00:13.340
Yeah.

00:00:13.340 --> 00:00:21.620
Hello, and welcome to Python Bytes, where we deliver Python news and headlines directly

00:00:21.620 --> 00:00:22.380
to your earbuds.

00:00:22.380 --> 00:00:27.480
This is episode 424, recorded March 17, 2025.

00:00:27.480 --> 00:00:28.340
I'm Michael Kennedy.

00:00:28.340 --> 00:00:29.520
And I'm Brian Okken.

00:00:30.320 --> 00:00:32.840
And this episode is brought to you by us.

00:00:32.840 --> 00:00:40.980
Check out all of our things, courses at pythontest.com, talkpython.fm, all the places.

00:00:40.980 --> 00:00:45.820
If you want to get in touch with us, social media is probably the best place.

00:00:45.820 --> 00:00:48.080
I have a couple of things sent to me on social media.

00:00:48.080 --> 00:00:50.680
I don't know about you, Brian, but a couple that I'll be covering today.

00:00:50.680 --> 00:00:51.240
Yeah.

00:00:51.240 --> 00:00:52.700
So that's always fun.

00:00:52.700 --> 00:00:53.720
Find us on Blue Sky.

00:00:53.720 --> 00:00:55.380
Find us on Mastodon.

00:00:55.380 --> 00:00:56.460
It doesn't matter.

00:00:56.460 --> 00:00:59.060
It doesn't matter what server you're on.

00:00:59.160 --> 00:01:00.720
Everyone talks to everyone on Mastodon.

00:01:01.540 --> 00:01:04.320
So you can find the links for all those at the top of the show.

00:01:04.320 --> 00:01:09.760
And we're refining and improving our newsletter format.

00:01:09.760 --> 00:01:12.140
It's getting better and better and more valuable, I think.

00:01:12.140 --> 00:01:14.200
It's got a nice little TLDR.

00:01:14.200 --> 00:01:15.020
Grab the links.

00:01:15.020 --> 00:01:15.920
Grab the joke.

00:01:16.100 --> 00:01:17.720
And then dive into it if you want.

00:01:17.720 --> 00:01:18.560
And yeah.

00:01:18.560 --> 00:01:20.520
So Python by Setfm.

00:01:20.520 --> 00:01:23.680
Smash that newsletter button and get signed up.

00:01:23.680 --> 00:01:27.680
I think people are getting a lot of value out of it.

00:01:27.680 --> 00:01:28.380
It's really nice, Brian.

00:01:28.380 --> 00:01:29.680
Yeah.

00:01:29.740 --> 00:01:30.860
I think it's great.

00:01:30.860 --> 00:01:32.440
Also, yeah.

00:01:32.440 --> 00:01:37.380
We've mentioned this before, but I really love what you should know.

00:01:37.380 --> 00:01:47.520
If we cover a topic that you don't quite understand what that topic's all about, you can check some of the background links in those.

00:01:47.520 --> 00:01:48.460
So that's cool.

00:01:48.960 --> 00:01:49.400
Absolutely.

00:01:49.400 --> 00:01:50.280
I totally agree.

00:01:50.280 --> 00:01:52.980
And thank you to our Patreon supporters as well.

00:01:52.980 --> 00:01:56.460
Now, let us begin.

00:01:56.460 --> 00:01:58.900
Let us begin, Brian, with your first item.

00:01:58.900 --> 00:01:59.620
What you got for us?

00:02:00.020 --> 00:02:04.900
I have a weird quirk around rounding in Python.

00:02:04.900 --> 00:02:07.900
And actually, this is just apparently normal.

00:02:07.900 --> 00:02:08.560
This is a feature.

00:02:08.560 --> 00:02:11.780
But I didn't know about it or I had forgotten about it.

00:02:11.780 --> 00:02:16.600
So we're linking to the weird quirk around rounding in Python.

00:02:16.600 --> 00:02:23.760
And the weird quirk is really just if your number ends in 0.5, like 1.5, 2.5, things like that.

00:02:23.760 --> 00:02:27.140
If you round it, it'll become even.

00:02:27.140 --> 00:02:28.960
It always goes even.

00:02:28.960 --> 00:02:31.240
So I didn't know this.

00:02:31.240 --> 00:02:33.920
But apparently, it works better that way.

00:02:33.920 --> 00:02:37.580
And that's part of the IEEE standard 754.

00:02:37.580 --> 00:02:40.100
So 0.5 rounds to 0.

00:02:40.100 --> 00:02:41.740
1.5 rounds to 2.

00:02:41.740 --> 00:02:43.420
And so forth and so on.

00:02:43.420 --> 00:02:45.400
Negative numbers also.

00:02:45.400 --> 00:02:48.800
So negative 1.5 will round to negative 2.

00:02:48.800 --> 00:02:52.180
So did you know this?

00:02:52.180 --> 00:02:55.180
I did not know this.

00:02:55.180 --> 00:02:57.900
I do not accept this.

00:02:57.900 --> 00:02:59.020
I don't accept this.

00:02:59.020 --> 00:03:07.660
As a mathematician, formerly, but by lots of training and education, I do not accept that.

00:03:07.660 --> 00:03:09.600
You always round even numbers.

00:03:10.460 --> 00:03:15.240
So normally, it's been a long time since I've been in primary school.

00:03:15.240 --> 00:03:20.700
But isn't the hand math thing that you round up?

00:03:20.700 --> 00:03:21.400
If it's 0.

00:03:21.400 --> 00:03:24.440
It goes to the closest whole number.

00:03:24.440 --> 00:03:25.400
That's it.

00:03:25.400 --> 00:03:27.580
At 0.5, there isn't a closest.

00:03:27.580 --> 00:03:28.420
It's right in the middle.

00:03:29.080 --> 00:03:29.960
I see.

00:03:29.960 --> 00:03:34.680
So if it was 0.1, 0.5, 0, 0, 0, 0, 0, 0, 1.

00:03:34.680 --> 00:03:35.840
It goes up.

00:03:35.840 --> 00:03:36.280
Yeah.

00:03:36.280 --> 00:03:37.060
It goes up.

00:03:37.060 --> 00:03:37.440
I see.

00:03:37.440 --> 00:03:46.460
So it's basically deciding at the decimal representation of the cutoff.

00:03:46.460 --> 00:03:47.020
So 4.

00:03:47.020 --> 00:03:54.700
In my world, 4.99999, non-repeating but as many nines as you care to put, goes down.

00:03:54.700 --> 00:03:57.780
And 0.5 and above goes up.

00:03:57.780 --> 00:03:58.960
Huh?

00:03:59.580 --> 00:04:03.520
If it's 1.4, you round down in regular math, right?

00:04:03.520 --> 00:04:03.700
Yeah.

00:04:03.700 --> 00:04:09.040
If it's 1.4999, you round down.

00:04:09.040 --> 00:04:11.720
If it's 1.499999, as many as you want.

00:04:11.720 --> 00:04:13.440
All the extra decimals don't matter.

00:04:13.440 --> 00:04:16.960
It's only with the actual, just one decimals.

00:04:16.960 --> 00:04:20.500
It's 0.5, 0s, all 0s.

00:04:20.500 --> 00:04:22.340
It's 0.5, 1.5.

00:04:22.340 --> 00:04:24.340
That's a tie, then.

00:04:24.340 --> 00:04:25.680
There is no closest integer.

00:04:25.680 --> 00:04:26.820
So where does it go?

00:04:27.480 --> 00:04:31.860
And I thought in math that we always just like half goes up.

00:04:31.860 --> 00:04:32.600
Yeah.

00:04:32.600 --> 00:04:33.800
That's what I thought too.

00:04:33.800 --> 00:04:35.960
But so it doesn't.

00:04:35.960 --> 00:04:42.880
It makes, and there's reasons around it because if you average, you want the average to be like,

00:04:42.880 --> 00:04:45.240
if you averaged a bunch of these, you want it to be 5.

00:04:45.240 --> 00:04:53.640
Like you have a bunch of random numbers, like 0 through 10 or 1 through, yeah.

00:04:53.640 --> 00:04:54.520
I don't know.

00:04:54.520 --> 00:04:56.620
It's going to, you want it to be 5.

00:04:57.380 --> 00:04:58.180
But it's not.

00:04:58.180 --> 00:04:59.160
It's a little bit off.

00:04:59.160 --> 00:05:03.740
So this standard makes the average work.

00:05:03.740 --> 00:05:14.120
However, if you really want the normal way that we've been taught in grade school, there's a decimal feature that you can have it be round half up.

00:05:15.040 --> 00:05:16.820
So you can make it work normal.

00:05:16.820 --> 00:05:19.040
But apparently it's doing the right thing.

00:05:19.040 --> 00:05:20.680
You just didn't know that was the right thing.

00:05:20.680 --> 00:05:22.180
So anyway.

00:05:22.180 --> 00:05:23.900
It's a feature.

00:05:23.900 --> 00:05:29.160
It's also known as banker's rounding or Dutch rounding, apparently.

00:05:29.160 --> 00:05:31.100
That's a learn something new there.

00:05:32.540 --> 00:05:36.580
And being that Guido is Dutch, maybe that has something.

00:05:36.580 --> 00:05:37.140
I don't know.

00:05:37.140 --> 00:05:41.860
So just if you're rounding numbers, you should be aware of this.

00:05:41.860 --> 00:05:42.640
That's it, really.

00:05:45.260 --> 00:05:45.660
Yeah.

00:05:45.660 --> 00:05:45.700
Yeah.

00:05:45.700 --> 00:05:50.740
You want an easy way to put it back to grade school rounding?

00:05:53.040 --> 00:05:59.720
All you have to do is just say int of your number plus 0.5.

00:05:59.720 --> 00:06:04.420
Int plus 0.5?

00:06:04.420 --> 00:06:04.840
Okay.

00:06:05.740 --> 00:06:10.100
So if it's 1.5 plus 0.5, it's 2 as a decimal.

00:06:10.100 --> 00:06:12.020
But then you turn it to an int, it's 2.

00:06:12.020 --> 00:06:13.980
Oh, right.

00:06:13.980 --> 00:06:15.920
So it basically has a truncation.

00:06:15.920 --> 00:06:17.080
Yeah, it truncates it.

00:06:17.080 --> 00:06:18.920
The 0.5 is like, okay, bump it up.

00:06:18.920 --> 00:06:22.640
If it's 0.5 or above, bump it to the next number, then chop it off.

00:06:22.640 --> 00:06:24.780
Weird.

00:06:24.780 --> 00:06:26.940
I wonder why we do it differently.

00:06:26.940 --> 00:06:27.720
Anyway.

00:06:27.720 --> 00:06:28.780
I don't know.

00:06:28.780 --> 00:06:30.520
Interesting.

00:06:30.520 --> 00:06:31.720
Thanks, Tom, for the article.

00:06:31.720 --> 00:06:34.400
Wild stuff.

00:06:34.400 --> 00:06:36.160
Okay.

00:06:36.160 --> 00:06:37.220
What do you got for us?

00:06:37.220 --> 00:06:45.240
Well, I've got some pretty interesting things here in terms of Python performance improvements.

00:06:45.240 --> 00:06:48.300
So, Brian, are you a fan of recursion?

00:06:48.300 --> 00:06:50.340
Not really.

00:06:50.340 --> 00:06:51.700
I'm not either.

00:06:51.700 --> 00:06:56.700
But I was, against my will, forced to take two programming courses in college.

00:06:56.700 --> 00:06:58.840
One was Fortran and one was Lisp.

00:06:58.840 --> 00:07:02.600
In Lisp, or Scheme, it's all about recursion, right?

00:07:02.600 --> 00:07:03.380
Yeah.

00:07:03.720 --> 00:07:07.240
Like, there's no, the way you do loops is to do recursion and so on.

00:07:07.240 --> 00:07:17.340
And in certain, not in Scheme, but in other languages, you can pretty quickly run out of stack space by doing recursion.

00:07:17.520 --> 00:07:21.140
And you might have gotten a stack overflow exception.

00:07:21.140 --> 00:07:24.140
You know, and people know about stack, that's the name.

00:07:24.140 --> 00:07:25.660
Like, what does this even mean?

00:07:25.660 --> 00:07:42.140
So, there's ways to rewrite that at the runtime level to say, the reason you run out of stack space is every function call gets its own new stack frame allocated.

00:07:42.140 --> 00:07:44.280
And all of its locals and all of its locals and all that kind of stuff.

00:07:44.280 --> 00:08:00.500
What if we could just say, reuse the existing stack space, grabbing some of the local variables that are being passed and just kind of reusing them long as you find a way to save the data to kind of go up the stack when you hit return or something like that, right?

00:08:01.060 --> 00:08:01.420
Yeah.

00:08:01.420 --> 00:08:06.000
And to my limited experience, that's what tail calls do.

00:08:06.520 --> 00:08:17.140
So, if you've heard about adding, like doing tail recursion to make your recursion much faster, that's because not every single, basically every single step in the loop, you don't have to recreate the function frame.

00:08:17.140 --> 00:08:20.640
So, that's really good.

00:08:20.640 --> 00:08:28.080
And so, the idea here, the news is that the Faster CPython project has added tail calls to Python.

00:08:28.260 --> 00:08:32.060
This is not exactly the same thing because it doesn't exactly have to do with recursion.

00:08:32.060 --> 00:08:39.060
It has to do with stepping through the bytecode instructions.

00:08:39.060 --> 00:08:39.620
Okay?

00:08:39.620 --> 00:08:40.280
Okay.

00:08:40.280 --> 00:08:45.980
So, traditionally, there have been different ways in which Python does that.

00:08:45.980 --> 00:08:51.620
And the article from lwn.net says, Python's many interpreters.

00:08:51.620 --> 00:08:54.280
So, when you run a Python program, it converts it to bytecode.

00:08:54.280 --> 00:08:55.100
Yes, we know this.

00:08:55.100 --> 00:08:59.960
It says, however, there's actually a couple of ways in which this could be executed.

00:08:59.960 --> 00:09:05.080
There's the switch-based interpreter version.

00:09:05.080 --> 00:09:08.300
And then there's a go-to, what do they call it?

00:09:08.300 --> 00:09:12.420
The go-to, computed go-to statements version.

00:09:12.420 --> 00:09:13.140
Okay?

00:09:13.140 --> 00:09:18.000
Which they say is a micro-op interpreter.

00:09:18.000 --> 00:09:19.760
So, this is relatively new.

00:09:19.760 --> 00:09:22.800
You maybe have seen the giant switch statement.

00:09:22.800 --> 00:09:30.020
And by giant, I mean 3,500 lines of C switch statement, single switch statement, within a for loop that says,

00:09:30.020 --> 00:09:35.400
for each, you know, go to the next byte instruction, switch on what it is, do that, right?

00:09:35.400 --> 00:09:45.660
That has still stuck around because certain compilers don't support what's called a computed go-to statement,

00:09:45.660 --> 00:09:46.960
or dynamic go-to statements.

00:09:47.120 --> 00:09:54.980
Which sounds terrible, but it's a compiler level thing, not a human code level thing.

00:09:54.980 --> 00:09:54.980
Yeah.

00:09:54.980 --> 00:09:59.180
Like, go-to statements are bad for people, but they're not necessarily bad for compilers.

00:10:00.020 --> 00:10:08.160
So, the reason the old one is around is some of the compilers can't take it, but the new one's a little bit better.

00:10:08.160 --> 00:10:15.180
So, the idea here is that, I'm going to give credit to it.

00:10:15.180 --> 00:10:23.160
So, Ken Jin, member of the Faster C-Python project, has merged a new set of changes that have up to 10%,

00:10:23.160 --> 00:10:26.340
actually up to 40% performance improvements.

00:10:26.340 --> 00:10:29.300
On average, a geometric mean of 10% improvements.

00:10:30.020 --> 00:10:31.160
Which is pretty awesome.

00:10:31.160 --> 00:10:40.720
So, the idea is that we can change the way that that go-to, that computed go-to based interpreter works,

00:10:40.720 --> 00:10:43.260
using tail calls.

00:10:43.260 --> 00:10:48.980
So, kind of like I described for recursion, it's reusing the stack frame as an optimization.

00:10:48.980 --> 00:10:56.600
So, modern compilers like Clang and GCC can do tail call optimizations opportunistically,

00:10:56.600 --> 00:11:00.240
but until recently, they weren't 100% guaranteed.

00:11:00.240 --> 00:11:04.800
You know, like, some compilers have that level, like, dash 01, 02.

00:11:04.800 --> 00:11:08.120
You put it up too high and stuff starts to break, you're like, huh, that's weird.

00:11:08.120 --> 00:11:10.340
You'd think that would just work, but, right?

00:11:10.340 --> 00:11:15.880
And I think that's kind of the cases here, and apparently it's more stable, so they can rely on it.

00:11:16.300 --> 00:11:21.160
So, basically, there's this new interpreter, and as the article points out,

00:11:21.160 --> 00:11:25.160
like, it might seem crazy to add a third interpreter to Python,

00:11:25.160 --> 00:11:26.580
and it seems like a lot of work, right?

00:11:26.580 --> 00:11:27.180
Yeah.

00:11:27.180 --> 00:11:30.260
But if you go down to the bottom, it says somewhere that

00:11:30.260 --> 00:11:36.840
Jin's change is only about 200 lines of Python code,

00:11:36.840 --> 00:11:44.400
which generates the interpreter, and generates the code for the tail calling version.

00:11:45.840 --> 00:11:48.040
So, it's actually not very much effort at all.

00:11:48.040 --> 00:11:53.980
So, what it does is it'll say, like, does your compiler support this faster version of behaviors?

00:11:53.980 --> 00:11:56.260
If it does, we'll give you a faster Python.

00:11:56.260 --> 00:11:57.580
I think that's pretty awesome.

00:11:57.580 --> 00:11:59.120
Yeah.

00:11:59.120 --> 00:12:00.120
Yeah.

00:12:00.120 --> 00:12:02.060
Yeah, I think.

00:12:02.060 --> 00:12:03.200
Yeah, I think so.

00:12:03.200 --> 00:12:03.480
If it works.

00:12:03.480 --> 00:12:04.900
Yeah, as long as it works.

00:12:05.120 --> 00:12:10.300
And so, this is already merged into Python 3.14, which is pretty excellent.

00:12:10.300 --> 00:12:17.000
And it does say, look, if you're on an older build of Python, or you're building Python yourself with an old compiler,

00:12:17.000 --> 00:12:18.100
you're going to get the slow version.

00:12:18.100 --> 00:12:19.580
Like, okay.

00:12:20.760 --> 00:12:28.200
If you care about faster Python, you know, compile it with modern compilers, or download one with a binary.

00:12:28.200 --> 00:12:31.320
Like, I bet you uv is already on top of this.

00:12:31.320 --> 00:12:31.900
You know what I mean?

00:12:32.720 --> 00:12:35.500
So, 3.14 already has this in it?

00:12:35.500 --> 00:12:37.260
That's what it says.

00:12:37.260 --> 00:12:37.780
Okay.

00:12:37.780 --> 00:12:38.420
Cool.

00:12:38.420 --> 00:12:39.560
It says merged.

00:12:39.560 --> 00:12:44.460
Jin's work has been merged and should be available to end users in Python 3.14.

00:12:44.460 --> 00:12:45.040
Expected.

00:12:45.040 --> 00:12:46.400
Whoa.

00:12:46.400 --> 00:12:48.020
Halloween 2025.

00:12:49.020 --> 00:12:56.340
Well, what's really interesting here is Jin measured the performance impact of the change as a 10% on average,

00:12:56.340 --> 00:12:59.800
but up to 40% on some benchmark speed improvement,

00:12:59.800 --> 00:13:03.660
and then framed it this way, which I thought was really interesting.

00:13:03.660 --> 00:13:09.520
The speedup is roughly equal to two CPython releases worth of improvements.

00:13:09.520 --> 00:13:11.700
So, like, 3.11 to 3.13.

00:13:11.700 --> 00:13:15.640
And there's just 200 lines of Python code, which is amazing.

00:13:16.280 --> 00:13:20.780
For example, CPython 3.12 roughly sped up by 5%.

00:13:20.780 --> 00:13:24.120
So, you know, year over year sort of thing.

00:13:24.120 --> 00:13:29.500
So just this one change in 3.14 is going to be pretty mega.

00:13:29.500 --> 00:13:30.120
It's awesome.

00:13:30.120 --> 00:13:31.680
Yeah.

00:13:31.680 --> 00:13:32.760
Yeah.

00:13:32.760 --> 00:13:34.100
No, this is really cool.

00:13:34.100 --> 00:13:42.100
I'm just, when I first heard about this, I was excited that maybe we get tail recursion optimization in Python, but we don't.

00:13:42.100 --> 00:13:45.620
I'm okay without it.

00:13:45.900 --> 00:13:46.900
It would be good to have.

00:13:46.900 --> 00:13:49.260
But let's not encourage them.

00:13:49.260 --> 00:13:50.760
No, I use recursion sometimes.

00:13:50.760 --> 00:13:55.200
Look, if you've got hierarchical data structures, recursion is magical, right?

00:13:55.200 --> 00:13:59.860
It's like it exactly matches what you do with that hierarchy as you kind of traverse it.

00:13:59.860 --> 00:14:09.040
But in life, though, I think I've only used recursion and tail optimization in college.

00:14:10.120 --> 00:14:10.280
Yeah.

00:14:10.280 --> 00:14:18.340
So, but I don't do sort of, because I don't do recursive sort of things very much, but that's all right.

00:14:18.340 --> 00:14:19.220
Yeah, yeah.

00:14:19.220 --> 00:14:27.160
Andrew out there points out, I was overly excited to see this when I first saw these headlines, thinking Python itself was getting tail call optimization.

00:14:27.480 --> 00:14:27.700
Yeah.

00:14:27.700 --> 00:14:33.220
Very nice, nonetheless, going to motivate me to get Clang builds working with the required options.

00:14:33.220 --> 00:14:33.480
Yeah.

00:14:33.480 --> 00:14:34.620
Absolutely cool.

00:14:34.620 --> 00:14:40.420
Like I said, I hope the uv folks are on this, because uv, V, E, and V, and we just get 10% faster.

00:14:40.420 --> 00:14:41.280
Like, let's go.

00:14:41.280 --> 00:14:41.840
I'm here for it.

00:14:41.840 --> 00:14:53.560
Well, yeah, and actually, I think that because of uv, we're getting more people trying new versions of Python faster, because all you have to do is create a virtual environment and pick it, and you get it.

00:14:53.560 --> 00:14:58.060
Yeah, --Python 3.14b, or whatever, however you specify it, yeah.

00:14:58.060 --> 00:14:58.560
Yeah.

00:14:58.560 --> 00:14:59.640
Absolutely.

00:14:59.640 --> 00:15:01.180
All right, back to you.

00:15:01.180 --> 00:15:02.940
Okay.

00:15:02.940 --> 00:15:04.300
Well, let's see.

00:15:04.300 --> 00:15:07.200
We've got something from Rodrigo.

00:15:07.200 --> 00:15:13.080
Rodrigo, and I'm, anyway, Rodrigo, from MathsPP.

00:15:13.080 --> 00:15:14.880
Maths, okay.

00:15:14.880 --> 00:15:16.680
I'm going to have to work on this one.

00:15:16.680 --> 00:15:18.640
But he puts out a lot of great stuff.

00:15:18.640 --> 00:15:22.180
He's writing about Python and very active on Blue Sky.

00:15:22.180 --> 00:15:27.520
And I think I'm, I don't, maybe somehow I missed this.

00:15:27.520 --> 00:15:30.900
This is, he's using translate and make trans together.

00:15:30.900 --> 00:15:36.280
He said, don't use the method replace to remove punctuation from a Python string.

00:15:36.280 --> 00:15:37.880
Use translate instead.

00:15:37.880 --> 00:15:40.760
It's much more efficient and more general.

00:15:40.760 --> 00:15:46.260
And his example, which I had to like parse a little bit to figure this out.

00:15:46.260 --> 00:15:55.600
So, basically, like his example of hello world with a comma and an exclamation point, we want to strip that, all the punctuation out.

00:15:55.600 --> 00:15:56.240
How do you do that?

00:15:56.540 --> 00:16:06.960
Well, you can use make trans, which is, translates from one string, like some things in a string to another set of characters in a string.

00:16:06.960 --> 00:16:08.660
It's kind of a weird function.

00:16:08.660 --> 00:16:10.300
But he's giving it nothing.

00:16:10.300 --> 00:16:12.660
So, the translate from and to are empty.

00:16:13.520 --> 00:16:18.040
But he's also giving the third parameter is stuff to just strip out.

00:16:18.040 --> 00:16:27.280
And the way make trans does, does that is it translates a, takes all of the characters in the third argument and replaces them with none.

00:16:27.280 --> 00:16:30.320
And those, it just gets, it ends up getting removed.

00:16:30.320 --> 00:16:33.500
And for the third character, he's using string dot punctuation.

00:16:33.500 --> 00:16:40.820
So, he's creating a translation table that all it does is remove punctuation.

00:16:40.820 --> 00:16:41.960
And that's what we want.

00:16:41.960 --> 00:16:44.760
Passing it to trans and you get a string.

00:16:44.760 --> 00:16:51.060
And it still seems like maybe there might, there should be an easier way in Python to do this.

00:16:51.060 --> 00:16:53.720
But, you know, that's pretty cool.

00:16:53.720 --> 00:16:54.420
I like it.

00:16:54.960 --> 00:17:04.640
So, he also has an article that talks about not exactly this thing, but he's got an article about string translate and make trans methods.

00:17:04.640 --> 00:17:09.300
If you, if you're, if you want to dive deeper into those, or you can just use this little trick.

00:17:09.300 --> 00:17:09.760
So.

00:17:09.760 --> 00:17:11.220
Very interesting.

00:17:11.220 --> 00:17:21.340
News to me, you know, it's a little bit like when I learned that strip, if I have like str, if I want to take str off of the word string and just leave ing.

00:17:21.340 --> 00:17:22.020
Yeah.

00:17:22.020 --> 00:17:23.540
Right.

00:17:24.260 --> 00:17:31.900
If you say L strip and you put the string str in there, I always thought it would find that string and take it out.

00:17:31.900 --> 00:17:36.560
But no, that just takes the S's and the T's and the R's.

00:17:36.560 --> 00:17:39.020
So, RTS would also be right.

00:17:39.020 --> 00:17:42.440
So, there's remove prefix and remove suffix and stuff like that.

00:17:42.440 --> 00:17:43.580
And this one's a little bit like that.

00:17:43.580 --> 00:17:44.120
Like, huh.

00:17:44.120 --> 00:17:45.760
Yeah.

00:17:45.760 --> 00:17:48.960
It didn't quite do what I thought, but I, apparently there's another way.

00:17:48.960 --> 00:17:49.960
Yeah.

00:17:50.740 --> 00:17:57.560
And one of the interesting things about make trans that always throws me is it's an ordering thing.

00:17:57.560 --> 00:17:59.200
So, you go like from and to.

00:18:00.840 --> 00:18:04.940
And it utilizes the fact that strings are iterable.

00:18:04.940 --> 00:18:08.460
And that's not something I normally think about.

00:18:08.460 --> 00:18:18.180
Unless I'm, I guess when I'm parsing stuff, when I'm parsing a file or parsing a line, I like, I utilize the fact that they're iterable.

00:18:18.640 --> 00:18:22.360
But normally I don't iterate it over characters of a string.

00:18:22.360 --> 00:18:26.440
That's, seems like maybe that's too easy to get wrong.

00:18:26.440 --> 00:18:27.620
But, anyway.

00:18:27.620 --> 00:18:29.040
Yeah.

00:18:29.040 --> 00:18:29.700
Perhaps.

00:18:29.700 --> 00:18:31.960
All right.

00:18:31.960 --> 00:18:33.400
What you got for us next?

00:18:33.400 --> 00:18:34.240
Oh, we're done.

00:18:34.240 --> 00:18:38.580
Well, I got extra, extra, extra, extra.

00:18:38.580 --> 00:18:39.660
Extra.

00:18:39.660 --> 00:18:40.520
Lots of extras.

00:18:40.520 --> 00:18:40.920
Yay.

00:18:41.020 --> 00:18:43.380
Because, you know, we had some short topics.

00:18:43.380 --> 00:18:44.360
So, let's get some extras.

00:18:44.360 --> 00:18:44.420
Yeah.

00:18:44.420 --> 00:18:44.700
Yeah.

00:18:44.700 --> 00:18:46.080
So, let's get some extras.

00:18:46.080 --> 00:18:50.620
So, first of all, this was sent in by several people, including Owen Lamont.

00:18:50.620 --> 00:18:51.380
Thank you for that.

00:18:51.380 --> 00:18:57.300
And this is a nine-minute video of animation versus coding.

00:18:57.300 --> 00:19:00.100
And it's, it's the weirdest.

00:19:00.100 --> 00:19:01.660
I don't even know what to make of it.

00:19:01.660 --> 00:19:04.260
It's an insane amount of work that these people put into it.

00:19:04.260 --> 00:19:06.980
I'll just play a little bit of it as, as we're talking, Brian.

00:19:06.980 --> 00:19:14.840
And so, the idea here is it's like an animation of somebody writing code and seeing how it kind of interacts.

00:19:14.840 --> 00:19:17.440
And then the computer kind of comes alive.

00:19:17.440 --> 00:19:20.660
And there's a battle with the computer.

00:19:20.660 --> 00:19:24.240
The computer will, like, fire up Turtle and all sorts of stuff.

00:19:24.240 --> 00:19:32.440
And it ends up in the end, like, creating AIs that are running around and doing all sorts of stuff.

00:19:32.440 --> 00:19:39.160
And I think, spoiler, I think the person character wins by, like, controlling the computer with AI.

00:19:39.160 --> 00:19:40.680
I'm not entirely sure of the outcome.

00:19:40.680 --> 00:19:41.440
I totally forget.

00:19:41.440 --> 00:19:47.820
But it features Pi Game, Pandas, Pi Torch.

00:19:47.820 --> 00:19:49.560
I mean, it's, it's nuts.

00:19:49.560 --> 00:19:53.900
So, anyway, if you're looking for some entertainment, that's worth checking out.

00:19:53.900 --> 00:19:54.040
That's pretty cool.

00:19:54.040 --> 00:19:54.820
I've got to watch that.

00:19:54.820 --> 00:19:56.080
It's a 10-minute video, though.

00:19:56.080 --> 00:19:57.380
Yeah.

00:19:57.380 --> 00:20:01.540
If you're eating lunch or something, you're like, I need a little break from programming.

00:20:01.540 --> 00:20:02.860
Let me watch a video about programming.

00:20:02.860 --> 00:20:03.760
I can do that.

00:20:03.760 --> 00:20:04.640
Yeah.

00:20:04.640 --> 00:20:05.660
All right.

00:20:05.660 --> 00:20:12.060
Next up in the news, I brought this up more as a parallel, as a other thing.

00:20:12.060 --> 00:20:13.660
Other places are doing this, too, right?

00:20:14.000 --> 00:20:23.420
So, one of the concerns and benefits of a lot of these new tools is they are written in Rust for Python, right?

00:20:23.420 --> 00:20:26.100
So, why is UVFast?

00:20:26.100 --> 00:20:28.780
Mostly algorithms, but also Rust.

00:20:28.780 --> 00:20:30.460
Why is RuffFast?

00:20:30.460 --> 00:20:32.920
Mostly Rust, probably also algorithms.

00:20:32.920 --> 00:20:33.600
You know what I mean?

00:20:33.600 --> 00:20:34.700
Like, things like that, right?

00:20:34.700 --> 00:20:35.860
Yeah.

00:20:35.860 --> 00:20:38.520
Why are we running our website on Granian?

00:20:38.520 --> 00:20:39.840
Rust.

00:20:39.840 --> 00:20:41.820
Hyper.

00:20:41.820 --> 00:20:42.780
All those sorts of things.

00:20:42.780 --> 00:20:57.320
So, the folks over at TypeScript, Anders Heilsberg, the creator of it, and the Microsoft team, just made TypeScript, which is a typed JavaScript thing.

00:20:58.040 --> 00:21:01.540
And I believe the runtime behind it as well, I think there's some kind of runtime.

00:21:01.540 --> 00:21:03.780
I haven't done much with TypeScript that way.

00:21:03.820 --> 00:21:11.240
But certainly, like, it's compiler and it's language LSP for editors and stuff like that.

00:21:11.240 --> 00:21:14.460
Ten times faster by rewriting it in Go.

00:21:14.460 --> 00:21:16.940
Oh, geez.

00:21:16.940 --> 00:21:18.500
So, that's interesting.

00:21:18.500 --> 00:21:21.000
And they said, look, we tried a bunch of different languages.

00:21:21.000 --> 00:21:21.820
We tried Rust.

00:21:21.820 --> 00:21:22.560
We tried C.

00:21:22.560 --> 00:21:23.480
We tried Go.

00:21:23.480 --> 00:21:25.620
We tried, I think, Ziggy.

00:21:25.620 --> 00:21:27.540
They mentioned a lot of languages.

00:21:28.060 --> 00:21:35.000
And he said, look, Go allows us to align the memory stuff as you do in native languages.

00:21:35.000 --> 00:21:39.960
Like, align the memory structures exactly right for the compiler and stuff like that or something.

00:21:39.960 --> 00:21:45.240
So, anyway, like, I know a lot of people listening also do JavaScript and TypeScript stuff.

00:21:45.240 --> 00:21:49.600
And I think it's, you know, here's another ten-minute video to watch that's kind of interesting.

00:21:49.600 --> 00:21:51.940
Ten minutes, technically.

00:21:51.940 --> 00:21:53.420
But you can drop the last.

00:21:53.420 --> 00:21:56.940
Everything that uses TypeScript would be faster then?

00:21:56.940 --> 00:21:57.300
Or?

00:21:57.300 --> 00:22:00.280
So, that's what I'm not.

00:22:00.280 --> 00:22:05.340
There is some kind of runtime that they're doing something with that they rewrote.

00:22:05.340 --> 00:22:09.480
Like, TypeScript used to compile itself with TypeScript.

00:22:09.480 --> 00:22:13.520
But there's also something that runs that does the language server.

00:22:13.520 --> 00:22:15.040
I feel like it's a little like Node.

00:22:15.040 --> 00:22:16.460
But, like I said, this is far.

00:22:16.460 --> 00:22:18.160
I'm far out over my skis at this point.

00:22:18.160 --> 00:22:22.740
I think when you talk about stuff that runs it, mostly that's in the browser.

00:22:22.740 --> 00:22:25.140
And then that's going to be just the JavaScript engine.

00:22:25.140 --> 00:22:31.760
Because the now Go-based transpiler compiler will compile the JavaScript and then it's run natively.

00:22:31.760 --> 00:22:33.420
Natively.

00:22:33.420 --> 00:22:34.020
You know.

00:22:36.300 --> 00:22:36.700
Anyway.

00:22:36.700 --> 00:22:37.640
Pretty interesting.

00:22:37.640 --> 00:22:41.920
I thought it was worth throwing out there because it's like, oh, Python's getting overrun by Rust.

00:22:41.920 --> 00:22:43.300
What in the world is going on?

00:22:43.300 --> 00:22:46.560
Like, this is a trend of more places, not just Python.

00:22:46.560 --> 00:22:48.040
That's what I kind of wanted to point out here.

00:22:48.040 --> 00:22:48.820
Yeah.

00:22:49.700 --> 00:22:53.080
They made different choices for different reasons, but it's still pretty interesting.

00:22:53.080 --> 00:22:56.320
Thanks for showing me that, YouTube.

00:22:56.320 --> 00:22:56.780
All right.

00:22:56.780 --> 00:23:00.480
This next section I entitled Firefox Lies.

00:23:00.480 --> 00:23:02.680
So, Brian, it's very exciting.

00:23:02.680 --> 00:23:06.960
This weekend was the first Formula One race of the year.

00:23:06.960 --> 00:23:09.100
And they're going to have something like 23 more.

00:23:09.100 --> 00:23:12.440
And it was amazing.

00:23:12.440 --> 00:23:13.760
If you haven't watched it, I won't spoil it.

00:23:13.760 --> 00:23:18.400
But it was one of the best Formula One races I've watched in a very long time.

00:23:18.400 --> 00:23:21.500
It was full of drama, full of interesting things.

00:23:21.500 --> 00:23:22.480
It was good.

00:23:22.480 --> 00:23:23.860
And this.

00:23:23.860 --> 00:23:26.060
So, what does this have to do with Firefox?

00:23:26.060 --> 00:23:26.360
Yeah.

00:23:26.360 --> 00:23:27.420
So, I tried to watch it.

00:23:27.420 --> 00:23:36.560
I subscribed to F1 TV so that I can watch all the races, all the replays, all the qualifying, all that kind of stuff.

00:23:36.560 --> 00:23:39.400
Instead of getting cable, which is a complete ripoff.

00:23:39.400 --> 00:23:41.480
You know, paying $200 a month.

00:23:41.560 --> 00:23:43.580
I paid like 80 bucks once.

00:23:43.580 --> 00:23:46.120
And now I watch all those with replays and whatever, right?

00:23:46.120 --> 00:23:50.120
I tried to watch that with Firefox.

00:23:50.120 --> 00:23:52.040
Do you know what it said?

00:23:52.040 --> 00:23:54.920
Your browser is out of date and unsupported.

00:23:54.920 --> 00:23:57.100
You cannot watch this website.

00:23:57.100 --> 00:24:00.440
You must go away because you don't have Chrome, basically.

00:24:00.440 --> 00:24:01.700
And I said, huh.

00:24:01.700 --> 00:24:03.980
I seriously doubt it.

00:24:03.980 --> 00:24:06.820
I seriously doubt that Firefox won't work.

00:24:06.820 --> 00:24:10.220
F-U-F-1, I said.

00:24:10.220 --> 00:24:13.820
And I said, no.

00:24:13.820 --> 00:24:15.700
We're doing it.

00:24:15.700 --> 00:24:16.940
We're watching it in Firefox.

00:24:16.940 --> 00:24:21.760
Because I have all this blocking turned on in my other favorite browser, Vivaldi.

00:24:21.760 --> 00:24:23.120
Right?

00:24:23.120 --> 00:24:26.280
And I don't want to turn off the blocking and stuff.

00:24:26.280 --> 00:24:36.400
So I have like kind of my bare Firefox is the one that allows all the badness through so I can watch stuff that, you know, Peacock and F1 and so on.

00:24:36.400 --> 00:24:39.960
So when they say you can't watch it, I'm like, no, I can watch it.

00:24:39.960 --> 00:24:42.400
So what I did is I put the link.

00:24:42.400 --> 00:24:43.360
I'll link to how you do this.

00:24:43.420 --> 00:24:49.340
But I just went up and just told Firefox its user agent is the latest version of Chrome.

00:24:49.340 --> 00:24:53.440
Hence Firefox lies.

00:24:53.440 --> 00:24:54.460
Went back.

00:24:54.460 --> 00:24:57.880
I went back to F1 TV.

00:24:57.880 --> 00:24:58.800
Welcome.

00:24:58.800 --> 00:25:01.320
Which replay would you like to watch?

00:25:01.320 --> 00:25:01.760
Boom.

00:25:01.760 --> 00:25:02.140
Perfect.

00:25:02.140 --> 00:25:03.160
Played perfectly.

00:25:03.240 --> 00:25:04.660
There's nothing wrong with Firefox.

00:25:04.660 --> 00:25:07.660
The people are just too lazy to test against it.

00:25:07.660 --> 00:25:10.700
And so they're like, well, you got to have Chrome.

00:25:10.700 --> 00:25:11.360
Like, all right, fine.

00:25:11.360 --> 00:25:11.760
I have Chrome.

00:25:11.760 --> 00:25:12.800
Oh, look, it works.

00:25:12.800 --> 00:25:15.040
This is the same reason that Vivaldi works.

00:25:15.040 --> 00:25:20.540
Vivaldi, you cannot know like the market share of Vivaldi per user agent.

00:25:20.540 --> 00:25:24.540
Like some of those sites that track user agent frequency and stuff.

00:25:24.540 --> 00:25:25.040
Yeah.

00:25:25.040 --> 00:25:27.580
Because they just say the same thing.

00:25:27.580 --> 00:25:31.160
They just say my user agent is the latest version of Chrome so that it works.

00:25:31.180 --> 00:25:35.920
Because if everybody had to also say, we also support Vivaldi, it would say crap like that all the time.

00:25:35.920 --> 00:25:36.540
Yeah.

00:25:36.540 --> 00:25:42.000
And so if you love Firefox or any other browser, really, but I have the instructions for Firefox,

00:25:42.000 --> 00:25:45.280
and you run into those problems, just make it lie.

00:25:45.280 --> 00:25:47.880
I'm really, really loving Zen.

00:25:47.880 --> 00:25:49.140
We talked about that a few times.

00:25:49.140 --> 00:25:53.180
And I'm considering making my Zen claim to be the latest Chrome as well.

00:25:53.180 --> 00:25:55.760
Yeah.

00:25:55.760 --> 00:25:59.300
That's one of the reasons why I like Vivaldi as well.

00:25:59.400 --> 00:26:05.580
Because especially in corporations, a lot of internal tools, they don't want to.

00:26:05.580 --> 00:26:08.320
I mean, that's a lot of work for internal tools to test everything.

00:26:08.320 --> 00:26:10.740
So they just usually test against Chrome.

00:26:10.740 --> 00:26:14.880
And so with Vivaldi, I can just use internal tools just fine.

00:26:14.880 --> 00:26:16.240
Yeah, it's indistinguishable.

00:26:16.240 --> 00:26:16.820
It doesn't know.

00:26:16.820 --> 00:26:19.200
Why wouldn't it be?

00:26:19.200 --> 00:26:21.940
It's literally the same embedded engine in the terms of Vivaldi.

00:26:21.940 --> 00:26:23.040
It literally is Chrome.

00:26:23.120 --> 00:26:25.900
It just doesn't have all this scumbaggery to it.

00:26:25.900 --> 00:26:26.120
Yeah.

00:26:26.120 --> 00:26:27.300
Yeah.

00:26:27.300 --> 00:26:27.720
All right.

00:26:27.720 --> 00:26:29.500
This extra is getting long real quick.

00:26:29.500 --> 00:26:29.800
All right.

00:26:29.800 --> 00:26:30.360
Startup Row.

00:26:30.360 --> 00:26:32.900
Startup Row applications are open.

00:26:32.900 --> 00:26:35.740
Does your startup qualify for Startup Row?

00:26:35.740 --> 00:26:36.540
Here's some criteria.

00:26:36.540 --> 00:26:37.700
Use Python.

00:26:37.700 --> 00:26:40.820
Your startup is less than 2.5 years old.

00:26:40.960 --> 00:26:45.220
You have less than 25 employees, et cetera, et cetera.

00:26:45.220 --> 00:26:48.180
You will come to the conference and so on.

00:26:48.180 --> 00:26:49.860
This is a really cool program.

00:26:49.860 --> 00:26:54.160
And if you have a startup and you want to get some awareness, consider applying to this.

00:26:54.580 --> 00:26:57.980
So this is at PyCon on Sundays.

00:26:57.980 --> 00:27:03.740
They take away all of the booths and everything like that.

00:27:03.740 --> 00:27:06.060
And then we have a couple rows of startups.

00:27:06.060 --> 00:27:07.460
Yes.

00:27:07.460 --> 00:27:09.880
I think it even might be Thursday through Saturday.

00:27:09.880 --> 00:27:12.040
I think it might be during the expo.

00:27:12.040 --> 00:27:12.560
Oh, during the expo.

00:27:12.560 --> 00:27:12.980
It was last year.

00:27:12.980 --> 00:27:16.560
It was in a corner, but I think it was during the expo.

00:27:16.560 --> 00:27:16.920
Oh, right.

00:27:17.020 --> 00:27:24.720
Yeah, you basically get a booth, like a $10,000 equivalent booth, as if you were another advertiser there.

00:27:24.720 --> 00:27:26.800
But it's to promote your Python-based startup.

00:27:26.800 --> 00:27:27.940
So people should check that out.

00:27:27.940 --> 00:27:33.940
I actually did an interview two years ago, coming up on two years ago, called a stroll down startup lane,

00:27:33.940 --> 00:27:40.620
where I went and interviewed all the people, all the different startups, like 10 minutes per startup or something like that.

00:27:40.620 --> 00:27:41.540
Nice.

00:27:41.540 --> 00:27:42.360
Yeah.

00:27:42.360 --> 00:27:42.460
Cool.

00:27:42.460 --> 00:27:45.540
Last of the extras.

00:27:46.140 --> 00:27:48.000
I am publishing a book, Brian.

00:27:48.000 --> 00:27:49.220
Wow.

00:27:49.220 --> 00:27:50.020
Neat.

00:27:50.020 --> 00:27:51.160
Yeah, thanks.

00:27:51.160 --> 00:27:52.660
Talk Python in production.

00:27:52.660 --> 00:27:59.020
So the subtitle is A Cloud Agnostic Guide to Building, Scaling, and Managing Your Own Python Infrastructure.

00:27:59.020 --> 00:28:04.020
So I've talked a lot about different ways we're doing different things with infrastructure, but here's a book.

00:28:04.020 --> 00:28:05.980
It's about 250 pages.

00:28:05.980 --> 00:28:15.300
That goes into all the details of how you can run efficient, high performance, but not complex, not expensive.

00:28:15.300 --> 00:28:17.040
Python infrastructure.

00:28:17.040 --> 00:28:22.740
And you can read about the first third of it online.

00:28:22.740 --> 00:28:27.800
And it says buy the book, but you can't quite buy the book just today.

00:28:27.800 --> 00:28:30.500
I'm still trying to get it all ready to go.

00:28:31.500 --> 00:28:34.560
Right now you can subscribe to get notified when you can buy the book.

00:28:34.560 --> 00:28:40.080
And in a week or two, you will be able to buy the book at Amazon and probably Gumroad is what I'm thinking.

00:28:40.080 --> 00:28:41.020
Okay.

00:28:41.020 --> 00:28:41.760
I like Gumroad.

00:28:41.760 --> 00:28:42.800
Yeah.

00:28:42.800 --> 00:28:43.460
Anyway.

00:28:43.720 --> 00:28:48.940
So the link to that is in the show notes and hopefully people will check that out.

00:28:48.940 --> 00:28:49.780
Cool.

00:28:49.780 --> 00:28:50.600
Yeah.

00:28:50.600 --> 00:28:51.260
All right.

00:28:51.260 --> 00:28:52.180
That's it for my extras.

00:28:52.180 --> 00:28:53.680
You got any extra extras?

00:28:54.460 --> 00:28:54.860
No.

00:28:54.860 --> 00:29:01.480
I wanted to announce the changes to the course, but I'm still working on it.

00:29:01.480 --> 00:29:02.660
Life getting in the way.

00:29:02.660 --> 00:29:03.400
Yeah.

00:29:03.400 --> 00:29:04.200
I hear you.

00:29:04.200 --> 00:29:09.940
Well, until then, people don't necessarily have to test, right?

00:29:09.940 --> 00:29:11.240
They don't need to work on your testing course.

00:29:11.260 --> 00:29:12.000
Yes, they do.

00:29:12.000 --> 00:29:14.240
No, they can just test in production.

00:29:14.240 --> 00:29:18.040
So the joke is a Star Trek one.

00:29:18.040 --> 00:29:20.980
This comes to us by Greg Mattiola.

00:29:20.980 --> 00:29:21.580
Thank you.

00:29:21.580 --> 00:29:26.820
He says, as Goran says, we will test in production and die with glorious honor.

00:29:26.820 --> 00:29:31.000
And it's got like a cool little meme over a Star Trek Klingon character.

00:29:31.000 --> 00:29:31.700
It's beautiful.

00:29:31.700 --> 00:29:35.940
But it's usually your customers that will die in glorious honor.

00:29:35.940 --> 00:29:39.080
They die first and then you wither.

00:29:39.080 --> 00:29:39.440
Yeah.

00:29:39.440 --> 00:29:42.380
Okay.

00:29:42.380 --> 00:29:42.980
Yeah.

00:29:42.980 --> 00:29:47.480
So what I'm hearing is you're saying you don't actually support this advice.

00:29:47.480 --> 00:29:48.480
I don't.

00:29:48.480 --> 00:29:55.720
But there is a certain car company that seems to have pieces of their cars flying off.

00:29:55.720 --> 00:29:57.580
I think.

00:29:57.580 --> 00:29:59.140
Does it look a little like a spaceship?

00:29:59.140 --> 00:30:00.520
Yeah, it does.

00:30:00.520 --> 00:30:03.780
And apparently they just glued some of the stuff onto the side.

00:30:03.780 --> 00:30:05.640
Anyway.

00:30:06.780 --> 00:30:12.840
You know, I was in Nashville with my kids the last summer.

00:30:12.840 --> 00:30:18.120
And we were driving along in our rental car, which was not one of these spaceshipy things.

00:30:18.120 --> 00:30:25.800
There was apparently the thing that goes along the column has like a fancy cover, like a bodywork.

00:30:25.800 --> 00:30:26.340
Yeah.

00:30:26.340 --> 00:30:30.180
The columns that hold up the roof and along the windshield.

00:30:30.180 --> 00:30:35.400
And it just peeled back, ripped off and started whacking against the car on the highway.

00:30:35.400 --> 00:30:37.600
And this was on our way to the airport.

00:30:37.600 --> 00:30:42.880
So one of my kids had to reach out and hold the bodywork in place for about 15 minutes.

00:30:42.880 --> 00:30:47.560
And she was kind of done holding the bodywork in place when we got to the airport.

00:30:47.560 --> 00:30:49.240
That's crazy.

00:30:49.240 --> 00:30:50.140
So bad.

00:30:50.140 --> 00:30:51.180
So bad.

00:30:51.180 --> 00:30:55.060
Did you get charged for the damage to the car?

00:30:55.060 --> 00:30:55.900
No.

00:30:55.900 --> 00:30:57.380
I kind of like mushed it back.

00:30:57.380 --> 00:30:58.540
I said, how's the car?

00:30:58.540 --> 00:30:59.040
It was fine.

00:30:59.040 --> 00:31:00.060
That piece is a little bit loose.

00:31:00.060 --> 00:31:00.840
You might want to check it.

00:31:00.840 --> 00:31:01.100
Bye.

00:31:01.100 --> 00:31:01.800
Bye.

00:31:04.800 --> 00:31:06.860
No, it was okay.

00:31:06.860 --> 00:31:08.360
Anyway.

00:31:08.360 --> 00:31:09.280
Anyway.

00:31:09.280 --> 00:31:09.720
Yeah.

00:31:09.720 --> 00:31:10.640
Test in production.

00:31:10.640 --> 00:31:12.140
Test in production.

00:31:12.140 --> 00:31:13.860
No, don't test in production.

00:31:13.860 --> 00:31:15.140
Test before production.

00:31:15.140 --> 00:31:16.160
Absolutely.

00:31:16.160 --> 00:31:19.580
But do listen to the show every week.

00:31:19.580 --> 00:31:21.900
We'll be back next Monday at 10, probably.

00:31:21.900 --> 00:31:22.700
Most likely.

00:31:22.700 --> 00:31:23.860
Tell your friends.

00:31:23.860 --> 00:31:25.000
Until then.

00:31:25.000 --> 00:31:26.660
Thank you, everyone.

00:31:26.660 --> 00:31:30.560
And if you're watching this on YouTube, go ahead and subscribe on YouTube as well.

00:31:30.560 --> 00:31:31.540
You'll get notifications.

00:31:31.540 --> 00:31:32.120
Bye.

00:31:32.120 --> 00:31:32.700
Bye.

00:31:32.700 --> 00:31:33.700
Bye.

00:31:33.700 --> 00:31:35.560
Thank you.

