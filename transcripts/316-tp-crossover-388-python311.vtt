
00:00:00.000 --> 00:00:05.440
Hey folks, for our final episode of 2022 here on Python Bytes, we're crossing the streams with my


00:00:05.440 --> 00:00:10.320
other show, Talk Python to Me. I present to you one of the more important episodes over there


00:00:10.320 --> 00:00:16.800
for the year, the release of Python 3.11 with its new features and 40% performance improvements.


00:00:16.800 --> 00:00:22.560
Thank you for listening to Python Bytes in 2022. Have a great holiday break,


00:00:22.560 --> 00:00:26.640
and Brian and I will see you next week. Here's that Python 3.11 episode.


00:00:29.120 --> 00:00:31.120
Python 3.11 is here!


00:00:31.120 --> 00:00:32.560
Keeping with the annual release cycle,


00:00:32.560 --> 00:00:35.760
the Python Core devs have released the latest version of Python,


00:00:35.760 --> 00:00:37.600
and this one is a big one.


00:00:37.600 --> 00:00:42.160
It has more friendly error messages and is massively faster than 3.10,


00:00:42.160 --> 00:00:45.760
being between 10 to 60% faster in general,


00:00:45.760 --> 00:00:50.640
which is a big deal for a year-over-year release of a 30-year-old platform.


00:00:50.640 --> 00:00:54.400
On this episode, we have Eirik Kutryl, Pablo Galindo-Sogado,


00:00:54.400 --> 00:00:58.560
Mark Shannon, and Brant Booker, all of whom participated in releasing Python this week.


00:00:58.560 --> 00:01:03.120
They're here on Talk Python to tell us all about that process and some of the highlight features.


00:01:03.120 --> 00:01:08.640
This is Talk Python To Me episode 388 recorded October 28th, 2022.


00:01:08.640 --> 00:01:26.880
Welcome to Talk Python To Me, a weekly podcast on Python. This is your host, Michael Kennedy.


00:01:26.880 --> 00:01:31.520
Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes at


00:01:31.520 --> 00:01:37.520
talkpython.fm and follow the show on Twitter via @talkpython. We've started streaming most


00:01:37.520 --> 00:01:43.280
of our episodes live on YouTube. Subscribe to our YouTube channel over at talkpython.fm/youtube


00:01:43.280 --> 00:01:49.440
to get notified about upcoming shows and be part of that episode. Hi everyone. Welcome to Talk


00:01:49.440 --> 00:01:54.640
Python to Me. It's great to have you all here. Ivrit, Brant, Pablo and Mark. It's going to be


00:01:54.640 --> 00:01:57.920
super fun to speak with all of you about Python 3.11.


00:01:57.920 --> 00:02:01.360
You know, before we get into it, I guess just real quickly, I know some of you have been


00:02:01.360 --> 00:02:03.160
on the show before, but not all of you.


00:02:03.160 --> 00:02:08.160
So let's just do a quick introduction about who you are and how you ended up here on the


00:02:08.160 --> 00:02:09.160
show.


00:02:09.160 --> 00:02:10.160
Yarit, do you want to start first?


00:02:10.160 --> 00:02:11.160
>> Yeah.


00:02:11.160 --> 00:02:12.160
Hi, I'm Yarit Kacharel.


00:02:12.160 --> 00:02:13.160
I'm a Python Core Dev.


00:02:13.160 --> 00:02:17.320
Earlier in the week, we streamed the release of Python 3.11.


00:02:17.320 --> 00:02:21.400
And on the back of that, Michael just invited us all here for a chat.


00:02:21.400 --> 00:02:22.400
>> Fantastic.


00:02:22.400 --> 00:02:23.400
Yeah.


00:02:23.400 --> 00:02:25.640
and we'll talk about that for sure in a second.


00:02:25.640 --> 00:02:27.200
But, Brant, welcome back.


00:02:27.200 --> 00:02:28.920
- Hello, my name is Brant Bucher.


00:02:28.920 --> 00:02:31.840
I have been a core dev for like two years now,


00:02:31.840 --> 00:02:33.480
and I work with Mark and Yaret


00:02:33.480 --> 00:02:35.440
on the Faster CPython team at Microsoft.


00:02:35.440 --> 00:02:36.280
- Right on.


00:02:36.280 --> 00:02:37.640
- And I was on the show like a month ago.


00:02:37.640 --> 00:02:40.360
- Yeah, you were talking about the Faster Python stuff,


00:02:40.360 --> 00:02:41.640
which we'll touch on again.


00:02:41.640 --> 00:02:43.240
- Hello, I'm Pablo Galindo.


00:02:43.240 --> 00:02:45.480
I'm the infamous release manager.


00:02:45.480 --> 00:02:47.000
I release Python 3.11,


00:02:47.000 --> 00:02:49.960
and you can redirect all your complaints


00:02:49.960 --> 00:02:51.560
to my email address.


00:02:51.560 --> 00:02:52.720
No, please don't do that.


00:02:52.720 --> 00:02:58.720
So I'm a CPython core dev. I'm also serving this year and last year on the Python steering council.


00:02:58.720 --> 00:03:05.520
And I also released my AI for Python 3.10 and 3.11, which is now the best version of Python.


00:03:05.520 --> 00:03:10.320
I'll load it today. Apart from that, I do a bunch of parser stuff, but now we are not talking about that.


00:03:10.320 --> 00:03:12.780
Yeah, fantastic. Well, welcome. Mark, welcome back.


00:03:12.780 --> 00:03:16.640
Hi there. I'm Alchan. I'm the tech lead of the Fastest CPython team.


00:03:16.640 --> 00:03:21.120
I work with Eric and Brent. I've been a core dev for some number of years, I don't recall.


00:03:21.180 --> 00:03:25.260
You've been spending a couple of years working on this faster CPython thing,


00:03:25.260 --> 00:03:28.940
and I'm very excited to see some of the fruits of those labors, you know,


00:03:28.940 --> 00:03:32.380
starting to show up and get in the hands of everyone with this release.


00:03:32.380 --> 00:03:32.580
Yeah.


00:03:32.580 --> 00:03:35.820
It's good to have the stuff out actually in public and in people's hands.


00:03:35.820 --> 00:03:38.740
It's really rewarding to know that stuff you're working on is actually


00:03:38.740 --> 00:03:40.060
used and used by a lot of people.


00:03:40.060 --> 00:03:41.420
Yeah, that is totally true.


00:03:41.420 --> 00:03:43.620
It's, it's one thing to build software.


00:03:43.620 --> 00:03:47.900
I mean, just by itself, but it's fun, but all of you are working on


00:03:47.900 --> 00:03:50.420
code that touches so many people.


00:03:50.540 --> 00:03:52.300
Think about there's layers, right?


00:03:52.300 --> 00:03:54.660
One layer is how many people use Python?


00:03:54.660 --> 00:03:56.380
Many millions, millions.


00:03:56.380 --> 00:03:58.900
Does anyone know a reasonable estimate of this number?


00:03:58.900 --> 00:04:03.580
I think some, I don't remember who came with the number, but I think they were


00:04:03.580 --> 00:04:06.740
estimating like 6 million Python developers, something like that.


00:04:06.740 --> 00:04:09.860
I mean, probably is between zero and a million.


00:04:09.860 --> 00:04:15.660
Let's say, yeah, that's a massive impact, but, and also maybe nervousness about


00:04:15.660 --> 00:04:17.420
pushing code out to that group.


00:04:17.420 --> 00:04:20.300
But then, you know, those people will build software for others, right?


00:04:20.300 --> 00:04:26.300
if you're using Instagram or using YouTube or other things, right, it's also having massive


00:04:26.300 --> 00:04:31.020
knock-on effects there. So thanks for putting all this together. Thanks for improving the tools that


00:04:31.020 --> 00:04:40.780
we all get to use. So yeah, big news. The big news is that Python 3.11 is out. And as Iritz had said,


00:04:40.780 --> 00:04:47.100
you all live streamed that release. So here we're all together, we're having an awesome chat about


00:04:47.100 --> 00:04:50.840
about the features and what people can do to take advantage of it


00:04:50.840 --> 00:04:53.340
and why they might care about new features and want to learn them.


00:04:53.340 --> 00:04:55.580
But there you did a little bit of that.


00:04:55.580 --> 00:05:00.840
But also Pablo, you actually step by step did the release of CPython,


00:05:00.840 --> 00:05:02.380
mostly live, right?


00:05:02.380 --> 00:05:03.540
Yeah, I did.


00:05:03.540 --> 00:05:05.580
It was except the boring part.


00:05:05.580 --> 00:05:09.340
This is something that I started last year


00:05:09.340 --> 00:05:12.540
because apparently I didn't have enough things to worry


00:05:12.540 --> 00:05:15.180
and I decided to make my life even more difficult.


00:05:15.180 --> 00:05:17.780
I'm an expert on that, quite proficient.


00:05:17.780 --> 00:05:21.420
- I'm also an expert, I'm very bad at doing too many things.


00:05:21.420 --> 00:05:23.580
- You could be a release manager, it's the only requirement.


00:05:23.580 --> 00:05:25.140
(laughing)


00:05:25.140 --> 00:05:28.140
So yeah, the idea is that the kind of releasing Python


00:05:28.140 --> 00:05:30.540
is a process that is quite complicated,


00:05:30.540 --> 00:05:32.500
it's also quite boring, so it's not like


00:05:32.500 --> 00:05:36.860
you need to have a galaxy brain kind of thing to do it,


00:05:36.860 --> 00:05:38.380
but it's just a lot of steps and it's very easy


00:05:38.380 --> 00:05:39.580
to do it wrong.


00:05:39.580 --> 00:05:41.980
And it's very unglamorous, so I said,


00:05:41.980 --> 00:05:45.240
"Oh, wow, I'm sure people really would like to see


00:05:45.240 --> 00:05:47.120
"a very unglamorous process happen in life."


00:05:47.120 --> 00:05:48.960
And then I said, "Let's do it."


00:05:48.960 --> 00:05:50.880
And I asked around and I was surprised


00:05:50.880 --> 00:05:53.280
about how many people enjoy unglamorous processes.


00:05:53.280 --> 00:05:56.660
And then I did the release of Python 3.10 Beta 1,


00:05:56.660 --> 00:05:59.040
which turned out to be much funnier than I thought


00:05:59.040 --> 00:06:00.600
because we just broke GitHub.


00:06:00.600 --> 00:06:02.280
That happened live, yes.


00:06:02.280 --> 00:06:06.600
- Was that when you imported all the issues


00:06:06.600 --> 00:06:08.600
and did that migration or was that separate?


00:06:08.600 --> 00:06:11.040
- You will think that that is a good candidate, but no,


00:06:11.040 --> 00:06:12.680
That was not the thing that broke GitHub.


00:06:12.680 --> 00:06:15.440
We renamed master to main on the CPython repo


00:06:15.440 --> 00:06:17.240
and the whole GitHub platform was down.


00:06:17.240 --> 00:06:18.320
What about that?


00:06:18.320 --> 00:06:19.440
- Wow.


00:06:19.440 --> 00:06:22.000
- Yeah, you can see those Ruby workers


00:06:22.000 --> 00:06:25.680
really struggling with the renaming, all those forks.


00:06:25.680 --> 00:06:27.200
I think we were the, I don't know,


00:06:27.200 --> 00:06:28.880
someone at GitHub may confirm this,


00:06:28.880 --> 00:06:30.640
but I think we were the first big project


00:06:30.640 --> 00:06:32.520
to do the renaming.


00:06:32.520 --> 00:06:33.640
Something went wrong.


00:06:33.640 --> 00:06:36.120
And it was very funny because I literally said,


00:06:36.120 --> 00:06:38.720
"How funny will it be if now I get a 500?"


00:06:38.720 --> 00:06:40.800
There you go, a 500 on the screen.


00:06:40.800 --> 00:06:42.080
- Yeah, yeah, it's recorded.


00:06:42.080 --> 00:06:44.340
Someone actually recorded that clip.


00:06:44.340 --> 00:06:46.440
Yeah, yeah, so I said, "Wow, man, this has been


00:06:46.440 --> 00:06:48.900
"such an exciting thing that I can break such a big project.


00:06:48.900 --> 00:06:49.960
"Let's do it more."


00:06:49.960 --> 00:06:54.160
So I decided also to stream the 3.10 release itself.


00:06:54.160 --> 00:06:57.400
And I said, "Well, technically, the final release


00:06:57.400 --> 00:07:00.060
"is even more boring and longer,


00:07:00.060 --> 00:07:02.400
"so that is actually probably not going to be


00:07:02.400 --> 00:07:04.920
"even something that someone wants to see."


00:07:04.920 --> 00:07:07.240
So I said, "Okay, let's not do it alone."


00:07:07.240 --> 00:07:09.800
So I invited a bunch of friends and core developers


00:07:09.800 --> 00:07:14.800
so they can actually talk about the things that they worked on the Python 3.10 release.


00:07:14.800 --> 00:07:21.300
And Brand and I were there, so they can probably tell you how they found out.


00:07:21.300 --> 00:07:23.800
But apparently it was something that a lot of people enjoy,


00:07:23.800 --> 00:07:28.300
because it's not only an opportunity to see how the sausage is made,


00:07:28.300 --> 00:07:31.800
because I was just explaining all the commands and all the phases and whatnot.


00:07:31.800 --> 00:07:33.800
But when something became very boring,


00:07:33.800 --> 00:07:36.800
then Brand and I were there to save the day


00:07:36.800 --> 00:07:39.300
and explain the cool things they work on.


00:07:39.300 --> 00:07:47.380
So, you know, which is a very good opportunity because, you know, when is the last time you could hear the author of the feature that you love talk about the feature that you love.


00:07:47.380 --> 00:07:48.980
That is fantastic. And it happened.


00:07:48.980 --> 00:08:01.020
Right. And not only did it happen, but as they were explaining the feature that they built, the action of it being delivered to the entire world was like all coming together in a pretty awesome way.


00:08:01.020 --> 00:08:18.020
Exactly. And I could only do, just to be fair also, and you know, create what create is do, I could only do that because the first time I did the live thing, I was also doing all the, you know, pushing all the buttons and at the same time doing all the video stuff with I don't know what is the software to the streamer, like whatever.


00:08:18.020 --> 00:08:23.020
And the second time we used the help of the Python Discord team,


00:08:23.020 --> 00:08:27.020
which are fantastic and they help us a lot.


00:08:27.020 --> 00:08:31.020
They have this fantastic UI where, you know,


00:08:31.020 --> 00:08:33.020
all the questions that were asked on the chat


00:08:33.020 --> 00:08:35.020
are shown on the screen and we couldn't use it.


00:08:35.020 --> 00:08:36.020
You know why?


00:08:36.020 --> 00:08:40.020
Because Facebook, or now Meta, decided to break DNS globally.


00:08:40.020 --> 00:08:44.020
What an incredible feat, just in time.


00:08:44.020 --> 00:08:44.860
I think one--


00:08:44.860 --> 00:08:47.380
- So what I'm learning is if we need some sort of


00:08:47.380 --> 00:08:49.820
like big cloud global outage,


00:08:49.820 --> 00:08:50.660
you all just need to live stream--


00:08:50.660 --> 00:08:52.020
- Just call Pablo, yes.


00:08:52.020 --> 00:08:53.540
Just exactly, exactly.


00:08:53.540 --> 00:08:55.780
Just please hire me today.


00:08:55.780 --> 00:09:00.780
So yes, now we're like two big outages on Python release.


00:09:00.780 --> 00:09:03.980
You know, there is only a line that passes through two points


00:09:03.980 --> 00:09:08.980
but I, you know, it was a good statistic already.


00:09:08.980 --> 00:09:12.260
So we said, what else can we break?


00:09:12.260 --> 00:09:13.300
So there you go.


00:09:13.300 --> 00:09:15.540
We decided to do the 3.11 release again,


00:09:15.540 --> 00:09:17.460
then Mark was there as well,


00:09:17.460 --> 00:09:20.040
which increases the probability of things being broken


00:09:20.040 --> 00:09:21.640
by a lot. (laughs)


00:09:21.640 --> 00:09:23.620
Sorry, Mark, I had to do the joke.


00:09:23.620 --> 00:09:25.860
He also fixes them, so it's fine.


00:09:25.860 --> 00:09:28.540
And nothing broke, so kudos to Mark.


00:09:28.540 --> 00:09:29.900
Everything thanks to that.


00:09:29.900 --> 00:09:32.340
And we did the release, so we did the same thing.


00:09:32.340 --> 00:09:34.100
We explained the whole thing,


00:09:34.100 --> 00:09:36.620
so people could see from the authors themselves


00:09:36.620 --> 00:09:38.820
like why all the features are very cool,


00:09:38.820 --> 00:09:41.700
and I did the non-boring parts of the release.


00:09:41.700 --> 00:09:44.700
And then we have a bit of some dramas in backstage


00:09:44.700 --> 00:09:47.900
because my JubyKey that I used to sign release broke


00:09:47.900 --> 00:09:49.640
and I freak out quite a lot,


00:09:49.640 --> 00:09:52.420
but I thankfully have a backup JubyKey.


00:09:52.420 --> 00:09:54.700
So nobody had, yeah, yeah.


00:09:54.700 --> 00:09:56.980
So crazy, because if I didn't have that,


00:09:56.980 --> 00:09:59.180
then I will have to stop the whole thing.


00:09:59.180 --> 00:10:02.220
But we didn't have to, it was just backstage.


00:10:02.220 --> 00:10:03.780
So yeah, quite exciting.


00:10:03.780 --> 00:10:05.060
Nothing broke except my JubyKey.


00:10:05.060 --> 00:10:06.300
I suppose that's the third thing that broke.


00:10:06.300 --> 00:10:08.580
It's not a global, you know, software,


00:10:08.580 --> 00:10:10.700
but I still mourn it is here.


00:10:10.700 --> 00:10:14.100
- Yeah, it served you well, but now it's,


00:10:14.100 --> 00:10:16.060
it gave its life for Python 3.11.


00:10:16.060 --> 00:10:18.620
- Too much power, like 3.11 was too powerful.


00:10:18.620 --> 00:10:19.460
It just broke.


00:10:19.460 --> 00:10:21.340
(laughing)


00:10:21.340 --> 00:10:23.220
- This is a dangerous job that you got.


00:10:23.220 --> 00:10:24.820
- Yeah, yeah, yeah.


00:10:24.820 --> 00:10:25.860
- But you've handed it off, right?


00:10:25.860 --> 00:10:29.340
This is your last time, last main release.


00:10:29.340 --> 00:10:31.500
- Yeah, yeah, I need to do the security


00:10:31.500 --> 00:10:34.740
and bug fix releases, but I don't need to do the ones


00:10:34.740 --> 00:10:36.500
that you need to chase people down


00:10:36.500 --> 00:10:38.420
and ask for cherry picking.


00:10:38.420 --> 00:10:39.860
There was a bunch of things of the release


00:10:39.860 --> 00:10:40.860
that were quite boring.


00:10:40.860 --> 00:10:44.200
Like, normally we release the previous version,


00:10:44.200 --> 00:10:45.820
like before the final version,


00:10:45.820 --> 00:10:47.320
there is something called the release candidate,


00:10:47.320 --> 00:10:48.900
which is, you know, like the last version


00:10:48.900 --> 00:10:50.200
that people need to try out


00:10:50.200 --> 00:10:51.820
before we do the final release.


00:10:51.820 --> 00:10:54.960
And ideally, that is the last version that we publish.


00:10:54.960 --> 00:10:57.840
Normally, it means that you publish from that commit.


00:10:57.840 --> 00:10:59.300
But this was not the case.


00:10:59.300 --> 00:11:02.140
This is the first release that had 130-something commits


00:11:02.140 --> 00:11:03.420
on top of that.


00:11:03.420 --> 00:11:06.020
And I had to painstakingly cherry pick,


00:11:06.020 --> 00:11:07.220
and it was not fun,


00:11:07.220 --> 00:11:08.760
but I did that before the release.


00:11:08.760 --> 00:11:13.560
like two hours because you need to fix conflicts and things like that. Yeah, very, very boring.


00:11:13.560 --> 00:11:17.880
But yeah, I started the stream with that already launched. So it was fine.


00:11:17.880 --> 00:11:21.880
Yeah, fantastic. Now, before we get into all the features, and I want to maybe just talk


00:11:21.880 --> 00:11:27.840
a little bit about some of the tools for actually doing the release, and maybe start with you


00:11:27.840 --> 00:11:34.400
is what does 3.11 mean for you all? Getting this out, what does that mean for the Python


00:11:34.400 --> 00:11:36.240
community from your perspective?


00:11:36.240 --> 00:11:39.180
Well, 3.11 is a huge release.


00:11:39.180 --> 00:11:43.280
There's a lot packed into it compared to the last few releases.


00:11:43.280 --> 00:11:44.700
There are no features,


00:11:44.700 --> 00:11:46.200
there's the performance work,


00:11:46.200 --> 00:11:48.740
it's just massive changes internally.


00:11:48.740 --> 00:11:50.640
It's just a huge release.


00:11:50.640 --> 00:11:55.140
Personally, I've started working on exception groups about two years ago.


00:11:55.140 --> 00:11:59.420
For me, it almost feels like finishing another PhD or something.


00:11:59.420 --> 00:12:03.980
It's a massive effort and here it is, it's done.


00:12:03.980 --> 00:12:05.700
It was a big day Monday.


00:12:05.700 --> 00:12:07.780
I had a bottle of champagne ready for the stream.


00:12:07.780 --> 00:12:09.020
It was a celebration.


00:12:09.020 --> 00:12:09.860
Yeah, it was.


00:12:09.860 --> 00:12:10.860
Brent, how about you?


00:12:10.860 --> 00:12:14.920
I'm really excited about 3.11 because I think there's something for everyone.


00:12:14.920 --> 00:12:18.020
And I think you'd be hard pressed to find someone who doesn't want their code to


00:12:18.020 --> 00:12:21.660
run faster and who doesn't want better error messages, and then you have all


00:12:21.660 --> 00:12:23.100
these other improvements on top of that.


00:12:23.100 --> 00:12:27.460
It's really nice to see both these like new features, which are something that we


00:12:27.460 --> 00:12:32.080
get in most Python releases, but also just the stuff that's there for everyone else


00:12:32.080 --> 00:12:35.060
who just wants to upgrade Python and just have a better experience all around.


00:12:35.060 --> 00:12:35.500
Yeah.


00:12:35.640 --> 00:12:36.480
I totally agree with that.


00:12:36.480 --> 00:12:39.900
It's cool to see people's responses to that too, because responses have been


00:12:39.900 --> 00:12:43.100
really, really positive, which is another thing that I liked about the live stream.


00:12:43.100 --> 00:12:47.060
Cause we did, you know, live Q and a and we had the chat and everything going on.


00:12:47.060 --> 00:12:50.400
And when you're starting at the same code base for like a year, you're like, okay,


00:12:50.400 --> 00:12:53.420
I'm pretty sure that what we've done here is really, really cool.


00:12:53.420 --> 00:12:56.520
But you know, like, is it actually as awesome as I think it is?


00:12:56.520 --> 00:13:00.840
You know, have I just been staring at it for too long and release it to the world


00:13:00.840 --> 00:13:02.860
and people are even more stoked about it than you are.


00:13:02.860 --> 00:13:03.860
And that's a really good feeling.


00:13:03.860 --> 00:13:04.660
Yeah, it is.


00:13:04.660 --> 00:13:05.200
Awesome.


00:13:05.200 --> 00:13:06.200
Mark?


00:13:06.200 --> 00:13:11.440
Yeah, well, I guess I started on trying to get Python faster 15 years ago, I guess, early


00:13:11.440 --> 00:13:12.440
PhD time.


00:13:12.440 --> 00:13:13.440
Yeah, with HotPy, right?


00:13:13.440 --> 00:13:14.440
Yeah, yeah.


00:13:14.440 --> 00:13:16.280
So it was a long, long, this has been a long time coming.


00:13:16.280 --> 00:13:20.520
So yeah, it's amazing to have it actually out and starting to see the speed ups.


00:13:20.520 --> 00:13:22.440
And obviously we're keeping working on it.


00:13:22.440 --> 00:13:24.240
So it's pretty good.


00:13:24.240 --> 00:13:25.400
Yeah, fantastic.


00:13:25.400 --> 00:13:29.640
You must be really proud because like you said, you have been proposing this for a really


00:13:29.640 --> 00:13:30.640
long time.


00:13:30.640 --> 00:13:34.880
You've had a lot of ideas and finally you've got a group of people working on it and you


00:13:34.880 --> 00:13:37.880
- You're all on the same team with Mark and Guido.


00:13:37.880 --> 00:13:38.720
- Yes.


00:13:38.720 --> 00:13:42.200
- And just making legitimate, serious progress here.


00:13:42.200 --> 00:13:45.480
So you must be really proud to just sort of see this


00:13:45.480 --> 00:13:46.480
actually go out the door.


00:13:46.480 --> 00:13:47.360
- Yes, definitely.


00:13:47.360 --> 00:13:50.080
- Especially in main, I thought too,


00:13:50.080 --> 00:13:52.280
it's really nice that we're able to, you know,


00:13:52.280 --> 00:13:53.320
deliver this for everyone.


00:13:53.320 --> 00:13:54.160
- Yeah.


00:13:54.160 --> 00:13:56.240
For me, I see basically three things,


00:13:56.240 --> 00:13:57.560
like kind of like you said, Brent,


00:13:57.560 --> 00:13:59.600
I see that obviously there's these new features


00:13:59.600 --> 00:14:01.800
like exception groups, which are lovely


00:14:01.800 --> 00:14:03.560
and make the language better,


00:14:03.560 --> 00:14:07.160
but it also gets friendlier for, especially for beginners,


00:14:07.160 --> 00:14:10.000
but for everyone, of course, with the better error messages


00:14:10.000 --> 00:14:13.200
and better reporting and tracebacks, and it gets faster.


00:14:13.200 --> 00:14:16.480
And so, I mean, and all the axes that seem to matter,


00:14:16.480 --> 00:14:18.000
it's really fantastic.


00:14:18.000 --> 00:14:20.000
Okay, so let's dive in.


00:14:20.000 --> 00:14:22.160
I just, Pablo, let's go back just a little bit


00:14:22.160 --> 00:14:24.380
to the release process,


00:14:24.380 --> 00:14:25.940
'cause people got to watch you do it,


00:14:25.940 --> 00:14:27.880
but they didn't actually, you know,


00:14:27.880 --> 00:14:30.160
see exactly what you're typing on your screen


00:14:30.160 --> 00:14:31.000
the whole time.


00:14:31.000 --> 00:14:32.820
It was more of about a, like an event of it.


00:14:32.820 --> 00:14:34.900
sometimes your screen was up, sometimes it wasn't.


00:14:34.900 --> 00:14:36.940
But there's an official PEP that talks about,


00:14:36.940 --> 00:14:39.780
like, here's the recipe for doing this, right?


00:14:39.780 --> 00:14:43.180
- That is correct, it's PEP 101, doing Python releases.


00:14:43.180 --> 00:14:46.860
And that is a curious document, it's a peculiar document,


00:14:46.860 --> 00:14:48.620
talks about how it's done, but it's like,


00:14:48.620 --> 00:14:49.820
it's kind of weird.


00:14:49.820 --> 00:14:51.820
So the document is up to date,


00:14:51.820 --> 00:14:54.820
like you can actually search PEP 101,


00:14:54.820 --> 00:14:56.900
and it will show you the thing.


00:14:56.900 --> 00:14:59.060
So what is there is the actual process.


00:14:59.060 --> 00:15:02.380
It's just, it also contains these weird sentences,


00:15:02.380 --> 00:15:06.820
Like if you search for it, there is a bunch of places that says, "Stop, stop, stop, stop,


00:15:06.820 --> 00:15:07.820
stop."


00:15:07.820 --> 00:15:08.820
Quite funny.


00:15:08.820 --> 00:15:11.540
And that was, if I recall correctly, Larry Hastings.


00:15:11.540 --> 00:15:14.220
He wrote those things.


00:15:14.220 --> 00:15:19.300
And the idea is that he could search for those places and he knows that at that stage he


00:15:19.300 --> 00:15:21.380
needs to wait for something to happen or something.


00:15:21.380 --> 00:15:22.660
And we left it there.


00:15:22.660 --> 00:15:26.220
So there's a bunch of like weird artifacts.


00:15:26.220 --> 00:15:30.500
And you know, it's full of bullet points because at some stages you need to do some things


00:15:30.500 --> 00:15:32.500
and some others and things like that.


00:15:32.500 --> 00:15:34.500
And you know, he says, okay, if you're running a beta release,


00:15:34.500 --> 00:15:35.880
then you need to do this bunch of things.


00:15:35.880 --> 00:15:37.080
And if you're running an alpha release,


00:15:37.080 --> 00:15:38.180
you need to do this bunch of things.


00:15:38.180 --> 00:15:40.500
And I have done the--


00:15:40.500 --> 00:15:43.080
I have done a state machine that goes through the whole thing,


00:15:43.080 --> 00:15:45.180
because, like, if you actually write this down,


00:15:45.180 --> 00:15:47.580
it's quite--you know, the--


00:15:47.580 --> 00:15:48.180
how is this called?


00:15:48.180 --> 00:15:51.580
The maintainability index of this process is insane.


00:15:51.580 --> 00:15:53.500
It just rejects your thing.


00:15:53.500 --> 00:15:55.300
It just--don't merge it.


00:15:55.300 --> 00:15:58.040
Right, and I said, like, yeah, I'm not doing this reading.


00:15:58.040 --> 00:16:02.680
So one thing I did, which is the thing that I was using at the stream,


00:16:02.680 --> 00:16:05.140
my first work as a release manager is to say,


00:16:05.140 --> 00:16:07.140
"I'm not going to do this by hand."


00:16:07.140 --> 00:16:08.420
And that is the vision.


00:16:08.420 --> 00:16:13.820
And then I did this script that is on github/python/releasetools.


00:16:13.820 --> 00:16:18.960
And it's my attempt at automating this process as much as possible,


00:16:18.960 --> 00:16:22.500
which unfortunately, you know, it still requires a bunch of manual steps


00:16:22.500 --> 00:16:24.560
because, like, that's life and things happen.


00:16:24.560 --> 00:16:26.340
But it's quite automatic.


00:16:26.340 --> 00:16:28.760
like at least things that are not like final releases.


00:16:28.760 --> 00:16:31.260
So Alphas and release candidates


00:16:31.260 --> 00:16:33.720
and now that we are in backfix releases,


00:16:33.720 --> 00:16:36.100
it mostly runs automatically,


00:16:36.100 --> 00:16:38.140
except that, you know, in the final release,


00:16:38.140 --> 00:16:40.980
everything fails because there's the final release for you.


00:16:40.980 --> 00:16:42.680
And then you need to fix things manually.


00:16:42.680 --> 00:16:44.440
So I think you saw me, you know,


00:16:44.440 --> 00:16:46.940
executing a bunch of those fixes.


00:16:46.940 --> 00:16:49.280
At some point, I added division by zero


00:16:49.280 --> 00:16:50.700
just to know that something was hit


00:16:50.700 --> 00:16:52.080
and that was seen on the screen


00:16:52.080 --> 00:16:53.700
because like, and people were like,


00:16:53.700 --> 00:16:56.340
division by zero, why do you need that to release Python?


00:16:56.340 --> 00:16:57.340
I don't know.


00:16:57.340 --> 00:16:58.860
That's very complicated.


00:16:58.860 --> 00:17:00.780
I could have asserted false.


00:17:00.780 --> 00:17:01.780
Come on, anything would have worked.


00:17:01.780 --> 00:17:03.100
No, no, we divide by zero.


00:17:03.100 --> 00:17:04.700
I'm a physicist, so that's what I do.


00:17:04.700 --> 00:17:05.700
Okay, okay.


00:17:05.700 --> 00:17:06.700
I'm a computer scientist.


00:17:06.700 --> 00:17:08.380
You studied black holes, right?


00:17:08.380 --> 00:17:09.380
Yeah, yeah.


00:17:09.380 --> 00:17:13.700
You were looking for some sort of like infinite sort of thing there, divide by zero.


00:17:13.700 --> 00:17:13.940
Yeah.


00:17:13.940 --> 00:17:15.260
I'm too tired for today.


00:17:15.260 --> 00:17:17.940
Let's just collapse the universe, divide it by zero.


00:17:17.940 --> 00:17:19.540
But Python was too friendly.


00:17:19.540 --> 00:17:21.780
Instead of collapsing the universe, it sold me an exception.


00:17:21.780 --> 00:17:23.500
You know, quite nice.


00:17:23.500 --> 00:17:25.300
Only in 3.11. No, no, I'm joking.


00:17:25.300 --> 00:17:28.260
Anyway, so yes, yes, you can follow this pep and, you know,


00:17:28.260 --> 00:17:31.060
just enjoy the whole process on its glory,


00:17:31.060 --> 00:17:32.560
or you can see the script.


00:17:32.560 --> 00:17:33.760
But yeah, it's quite verbose.


00:17:33.760 --> 00:17:35.800
You can see that there's lots of places


00:17:35.800 --> 00:17:38.800
when everything can go wrong and you can panic.


00:17:38.800 --> 00:17:41.560
Now we know one more, finally your JubyKey can break.


00:17:41.560 --> 00:17:43.060
So that's something that can happen as well.


00:17:43.060 --> 00:17:45.060
But like, you know, it's quite annoying.


00:17:45.060 --> 00:17:48.060
And that's the main job of the release manager,


00:17:48.060 --> 00:17:49.560
go through this annoying process.


00:17:49.560 --> 00:17:50.900
So, yeah.


00:17:50.900 --> 00:17:52.660
- Yeah, I see that there's some parts in here.


00:17:52.660 --> 00:17:53.960
You should have a few more stops.


00:17:53.960 --> 00:17:55.160
I should say, stop, stop, stop.


00:17:55.160 --> 00:17:56.460
Make sure GitHub still works.


00:17:56.460 --> 00:17:57.300
Stop, stop, stop.


00:17:57.300 --> 00:17:58.500
Make sure Azure still works.


00:17:58.500 --> 00:17:59.700
Stop, stop, stop.


00:17:59.700 --> 00:18:00.660
- Yeah, don't cry.


00:18:00.660 --> 00:18:01.740
Don't cry at this stage.


00:18:01.740 --> 00:18:03.100
Everybody's looking at you.


00:18:03.100 --> 00:18:05.980
But yeah, the one thing that is known in this pub


00:18:05.980 --> 00:18:08.100
is that you also are in charge in theory


00:18:08.100 --> 00:18:11.140
of this extreme abstract mandate,


00:18:11.140 --> 00:18:13.300
which is that you are in charge of the stability


00:18:13.300 --> 00:18:15.180
of the release, whatever that means.


00:18:15.180 --> 00:18:17.240
That translates more in chasing people


00:18:17.240 --> 00:18:18.500
because they broke things.


00:18:18.500 --> 00:18:21.580
Another unfortunate event that we are trying to also


00:18:21.580 --> 00:18:24.980
fix a bit for the releases is that most people


00:18:24.980 --> 00:18:27.300
turn to the release manager to solve problems.


00:18:27.300 --> 00:18:30.900
So they say, hey, this person says that we should do X,


00:18:30.900 --> 00:18:33.220
while this other person says that we should do Y.


00:18:33.220 --> 00:18:34.460
We need someone to decide.


00:18:34.460 --> 00:18:36.900
Let's reach to the release manager,


00:18:36.900 --> 00:18:39.100
but the release manager is this guy on the corner.


00:18:39.100 --> 00:18:40.260
Like he doesn't know shit.


00:18:40.260 --> 00:18:43.780
So I like, you know, he's not the best person to fetch it,


00:18:43.780 --> 00:18:45.700
but everybody was like, what do you think, Pablo?


00:18:45.700 --> 00:18:47.340
So we merged this, and like, I don't know, man,


00:18:47.340 --> 00:18:48.820
this is some enum things.


00:18:48.820 --> 00:18:50.260
Like, I don't know about this.


00:18:50.260 --> 00:18:51.660
I have no context whatsoever.


00:18:51.660 --> 00:18:54.460
- Your only concern is, will it still build and ship?


00:18:54.460 --> 00:18:58.100
- Exactly, it's like, yeah, what about these 2,000 lines?


00:18:58.100 --> 00:18:59.540
Of course, it's all this tiny bag.


00:18:59.540 --> 00:19:01.740
It's like, well, maybe let's not merge that.


00:19:01.740 --> 00:19:05.100
But yeah, we are trying to also redirect all of this


00:19:05.100 --> 00:19:06.700
to the steering council, which also,


00:19:06.700 --> 00:19:07.700
I am in the steering council,


00:19:07.700 --> 00:19:10.300
so apparently I'm not going to get rid of these questions.


00:19:10.300 --> 00:19:11.940
I'm joking, I enjoy all these questions,


00:19:11.940 --> 00:19:13.260
but as a release manager, I don't.


00:19:13.260 --> 00:19:15.300
So the key here is that the release managers


00:19:15.300 --> 00:19:17.180
should not take unilateral decisions


00:19:17.180 --> 00:19:18.540
on the evolution of these things,


00:19:18.540 --> 00:19:19.980
because it's just the release manager.


00:19:19.980 --> 00:19:21.900
So the reason the steering council is five people--


00:19:21.900 --> 00:19:23.940
- But you are the one who delivers the code.


00:19:23.940 --> 00:19:26.420
You could kind of, you could sneak a feature in there.


00:19:26.420 --> 00:19:28.300
- No, no, no, I don't decide important things.


00:19:28.300 --> 00:19:30.100
I just execute and chase people


00:19:30.100 --> 00:19:31.460
and I'm this annoying guy that says,


00:19:31.460 --> 00:19:32.360
you wrote this, fix it.


00:19:32.360 --> 00:19:34.860
But like then, if there is some important decisions


00:19:34.860 --> 00:19:37.620
to be taken, you know, that's the steering council job,


00:19:37.620 --> 00:19:39.740
which is five people, because you know,


00:19:39.740 --> 00:19:41.300
one person shouldn't decide these things.


00:19:41.300 --> 00:19:43.700
It's like, and this happens, like sometimes I say,


00:19:43.700 --> 00:19:46.300
hey, there is this PR when people are asking,


00:19:46.300 --> 00:19:47.140
what should we do?


00:19:47.140 --> 00:19:48.500
And then this is my opinion


00:19:48.500 --> 00:19:50.340
as the member of the steering council


00:19:50.340 --> 00:19:52.300
and the other four members maybe they say,


00:19:52.300 --> 00:19:53.980
well, actually that's not a good opinion.


00:19:53.980 --> 00:19:54.980
So what about this?


00:19:54.980 --> 00:19:56.540
You know, we ended up in a much better place


00:19:56.540 --> 00:19:58.260
because it was five people,


00:19:58.260 --> 00:20:01.020
five persons doing a decision instead of one, but yeah.


00:20:01.020 --> 00:20:04.580
- This portion of Talk Python to Me


00:20:04.580 --> 00:20:08.020
is brought to you by Microsoft for Startups Founders Hub.


00:20:08.020 --> 00:20:09.740
Starting a business is hard.


00:20:09.740 --> 00:20:12.260
By some estimates, over 90% of startups


00:20:12.260 --> 00:20:15.120
will go out of business in just their first year.


00:20:15.120 --> 00:20:17.060
With that in mind, Microsoft for Startups


00:20:17.060 --> 00:20:20.480
set out to understand what startups need to be successful


00:20:20.480 --> 00:20:22.280
and to create a digital platform


00:20:22.280 --> 00:20:24.260
to help them overcome those challenges.


00:20:24.260 --> 00:20:26.880
Microsoft for Startups Founders Hub was born.


00:20:26.880 --> 00:20:29.840
Founders Hub provides all founders at any stage


00:20:29.840 --> 00:20:33.800
with free resources to solve their startup challenges.


00:20:33.800 --> 00:20:36.240
The platform provides technology benefits,


00:20:36.240 --> 00:20:39.120
access to expert guidance and skilled resources,


00:20:39.120 --> 00:20:42.400
mentorship and networking connections, and much more.


00:20:42.400 --> 00:20:43.920
Unlike others in the industry,


00:20:43.920 --> 00:20:46.120
Microsoft for Startups Founders Hub


00:20:46.120 --> 00:20:49.120
doesn't require startups to be investor-backed


00:20:49.120 --> 00:20:51.960
or third-party validated to participate.


00:20:51.960 --> 00:20:54.440
Founders Hub is truly open to all.


00:20:54.440 --> 00:20:56.020
So what do you get if you join them?


00:20:56.020 --> 00:20:58.120
You speed up your development with free access


00:20:58.120 --> 00:21:01.000
to GitHub and Microsoft Cloud computing resources


00:21:01.000 --> 00:21:04.240
and the ability to unlock more credits over time.


00:21:04.240 --> 00:21:05.480
To help your startup innovate,


00:21:05.480 --> 00:21:07.880
Founders Hub is partnering with innovative companies


00:21:07.880 --> 00:21:11.360
like OpenAI, a global leader in AI research and development


00:21:11.360 --> 00:21:14.320
to provide exclusive benefits and discounts.


00:21:14.320 --> 00:21:16.620
Through Microsoft for Startups Founders Hub,


00:21:16.620 --> 00:21:19.380
becoming a founder is no longer about who you know.


00:21:19.380 --> 00:21:21.180
You'll have access to their mentorship network,


00:21:21.180 --> 00:21:23.240
giving you a pool of hundreds of mentors


00:21:23.240 --> 00:21:25.900
across a range of disciplines and areas


00:21:25.900 --> 00:21:28.320
like idea validation, fundraising,


00:21:28.320 --> 00:21:30.440
management and coaching, sales and marketing,


00:21:30.440 --> 00:21:33.060
as well as specific technical stress points.


00:21:33.060 --> 00:21:34.700
You'll be able to book a one-on-one meeting


00:21:34.700 --> 00:21:35.540
with the mentors,


00:21:35.540 --> 00:21:38.320
many of whom are former founders themselves.


00:21:38.320 --> 00:21:39.940
Make your idea a reality today


00:21:39.940 --> 00:21:43.440
with the critical support you'll get from Founders Hub.


00:21:43.440 --> 00:21:47.080
To join the program, just visit talkpython.fm/foundertub,


00:21:47.080 --> 00:21:49.580
all one word, the link's in your show notes.


00:21:49.580 --> 00:21:51.880
Thank you to Microsoft for supporting the show.


00:21:51.880 --> 00:21:54.960
Amazing, okay, so if people wanna follow along


00:21:54.960 --> 00:21:57.440
with the process, they can check out PEP 101.


00:21:57.440 --> 00:21:58.880
Let's keep over here, you also talked about


00:21:58.880 --> 00:22:00.920
the Python buildbot that people can check out,


00:22:00.920 --> 00:22:05.080
but I think maybe we wanna jump into our first feature.


00:22:05.080 --> 00:22:08.580
As Erit said, there's a ton of features and things in here,


00:22:08.580 --> 00:22:11.060
but there's also maybe some top-level ones


00:22:11.060 --> 00:22:13.020
that'll be really important for a lot of folks,


00:22:13.020 --> 00:22:15.560
And you really want to tell us about your work.


00:22:15.560 --> 00:22:18.280
You mentioned before the exception groups and exception star.


00:22:18.280 --> 00:22:20.640
This is kind of a major new feature that we added.


00:22:20.640 --> 00:22:26.520
And the idea is that sometimes you'll have a situation where you did several


00:22:26.520 --> 00:22:30.440
things and maybe more than one of them raised an exception, and now you need


00:22:30.440 --> 00:22:34.140
to report that there was more than one error in whatever you did and what you


00:22:34.140 --> 00:22:38.520
did could have been a bunch of asynchronous tasks, which is that that was


00:22:38.520 --> 00:22:40.400
the use case that motivated this whole thing.


00:22:40.600 --> 00:22:45.600
But there are also situations where you just iterate over a few things


00:22:45.600 --> 00:22:47.760
and repeat them and accumulate exceptions,


00:22:47.760 --> 00:22:50.480
and you want to report all of them.


00:22:50.480 --> 00:22:55.320
And the PEP lists a bunch of examples of where this can happen.


00:22:55.320 --> 00:22:59.960
So people, typically what they do is they'll take a list of exceptions,


00:22:59.960 --> 00:23:02.440
wrap it in another exception, multi-error,


00:23:02.440 --> 00:23:06.360
some other wrapper, and throw that, and then you have to catch it.


00:23:06.360 --> 00:23:09.200
And then you have to iterate over the list and look at the exceptions,


00:23:09.200 --> 00:23:12.320
But you don't have a method to handle the exceptions.


00:23:12.320 --> 00:23:15.920
Like you have to try except like catch these, but not catch it.


00:23:15.920 --> 00:23:16.440
Right.


00:23:16.440 --> 00:23:16.760
Right.


00:23:16.760 --> 00:23:21.080
Because then you accept, you might have like, except socket error, or you might


00:23:21.080 --> 00:23:26.760
have an except like file not found type of thing, but if those both happen, neither


00:23:26.760 --> 00:23:28.440
of those would run in Python 3.10.


00:23:28.440 --> 00:23:28.680
Right.


00:23:28.680 --> 00:23:31.800
Cause it's some kind of weird wrapper and it's not a socket exception.


00:23:31.800 --> 00:23:34.040
It's not a file exception, but it kind of contains both.


00:23:34.040 --> 00:23:36.640
And so in a sense, both run, I don't know.


00:23:36.720 --> 00:23:40.480
And then if you catch the wrapper, even you do something with some of the exceptions,


00:23:40.480 --> 00:23:43.920
you better not forget to raise the rest because you're not handling them.


00:23:43.920 --> 00:23:47.520
So, yeah, there are a lot of problems when you try to work around this.


00:23:47.520 --> 00:23:49.760
And like what happened with Trio.


00:23:49.760 --> 00:23:54.320
So Trio had multi-error, would raise this wrapper and it was,


00:23:54.320 --> 00:23:58.800
it had to do a lot of complicated acrobatics just to have some error handling.


00:23:58.800 --> 00:24:03.200
So the motivation was, yeah, we have task groups in Python 3.11,


00:24:03.200 --> 00:24:05.360
which are kind of like trio nurseries,


00:24:05.360 --> 00:24:09.840
kind of a structured collection of asynchronous tasks.


00:24:09.840 --> 00:24:12.160
And task groups were on the cards.


00:24:12.160 --> 00:24:14.240
They started, like Yuri Serebanov,


00:24:14.240 --> 00:24:17.040
who was kind of maintaining asyncio in the beginning,


00:24:17.040 --> 00:24:18.800
he wrote a lot of asyncio.


00:24:18.800 --> 00:24:22.960
He wanted to add task groups since 2017, 2018,


00:24:22.960 --> 00:24:23.840
something like that.


00:24:23.840 --> 00:24:26.960
And what was holding it up was error handling.


00:24:26.960 --> 00:24:29.360
There was no good way to handle errors.


00:24:29.360 --> 00:24:30.800
So now we have Accept*,


00:24:30.800 --> 00:24:37.040
which is, which generalizes except and works with groups. So you can say except star socket error


00:24:37.040 --> 00:24:42.240
and then it will just extract all the socket errors from the group and give you those and


00:24:42.240 --> 00:24:46.640
automatically re-erase everything else. That's basically the idea. This is pretty interesting.


00:24:46.640 --> 00:24:52.320
We have try, do your thing and then except star, you know, one error type, except star,


00:24:52.320 --> 00:24:58.560
another error type, except star, a set of errors potentially. So what happens if I'm in this


00:24:58.560 --> 00:25:06.160
situation and say the first error type and maybe something from the third error catch clause is


00:25:06.160 --> 00:25:10.800
thrown in one of these task groups, exception groups. Each exception in the group will be


00:25:10.800 --> 00:25:15.840
handled by at most one of the clauses. So the first clause that matches its type will consume


00:25:15.840 --> 00:25:23.200
it and each clause executes once. So if there are more than one errors of that type, then what gets


00:25:23.200 --> 00:25:28.800
kind of bound in the except star for error as E, what gets bound to E is a group of for errors.


00:25:28.800 --> 00:25:33.600
So you get all the for errors in a group, execute that clause and then move on to the next clause


00:25:33.600 --> 00:25:40.480
with whatever is not handled yet. Interesting. So it might run two of the clauses. And whereas


00:25:40.480 --> 00:25:45.280
in traditional exception handling, it goes from top to bottom and it looks for an inheritance


00:25:45.280 --> 00:25:49.760
type of match and the first one that matches, that's it. But in this case with the star,


00:25:49.760 --> 00:25:55.760
You could get multiple ones. I guess the star to me when I look at this, the star is reminiscent of


00:25:55.760 --> 00:26:02.880
args star where you have unpacking. Yeah, yeah, exactly. It's not exactly unpacking, but it was


00:26:02.880 --> 00:26:07.280
it was kind of the intention to make it look a bit like unpacking. Nice. Yeah, this looks like a


00:26:07.280 --> 00:26:13.120
really cool feature. You talked about the task groups and trio and those things. So when I saw


00:26:13.120 --> 00:26:17.360
this concurrent errors obviously come to mind because if I try to both write something to a


00:26:17.360 --> 00:26:21.440
a database and call a web service asynchronously and I start both of those


00:26:21.440 --> 00:26:24.160
and they both crash or you know multiple ones crash,


00:26:24.160 --> 00:26:26.960
which error do you want? The database error or do you want the API error?


00:26:26.960 --> 00:26:28.640
You probably want to know about both of them, right?


00:26:28.640 --> 00:26:31.680
So that's a real natural reason to bring these together.


00:26:31.680 --> 00:26:36.360
But maybe you'd also list out some of the other reasons that you might run into this.


00:26:36.360 --> 00:26:37.880
Maybe give people some other ideas.


00:26:37.880 --> 00:26:41.800
So the example of in the socket model, we have the create connection function.


00:26:41.800 --> 00:26:46.560
And that function, I was showing it in the stream, it iterates over all the


00:26:46.560 --> 00:26:51.700
Configurations that you could try to connect with them and depending on what's going on on the other side


00:26:51.700 --> 00:26:54.140
Hopefully one of the works, but if none of them work


00:26:54.140 --> 00:26:59.240
You have to report errors and what we do in Python 3.10 is we just raised the last exception


00:26:59.240 --> 00:27:04.020
So you don't know what happened really you already know right the last attempt failed


00:27:04.020 --> 00:27:08.520
You don't even know how many attempts were made to connect to how many configurations did we try?


00:27:08.520 --> 00:27:14.100
So that was a long-standing open problem kind of can we do better than just report the last error?


00:27:14.600 --> 00:27:16.880
And then we closed it and we just added it for,


00:27:16.880 --> 00:27:18.880
to then give me a demo for in a group.


00:27:18.880 --> 00:27:20.640
- Another place that comes to mind is,


00:27:20.640 --> 00:27:23.840
maybe you all are familiar with some of these retry libraries


00:27:23.840 --> 00:27:26.380
like retry, but yeah, I think there's others as well,


00:27:26.380 --> 00:27:29.120
where you put a decorator onto some function,


00:27:29.120 --> 00:27:31.520
you say, try this multiple times.


00:27:31.520 --> 00:27:34.640
And if it fails, do like some sort of exponential backoff,


00:27:34.640 --> 00:27:36.720
'cause maybe the server's overloaded, right?


00:27:36.720 --> 00:27:38.680
Those types of things would be really great.


00:27:38.680 --> 00:27:41.200
Like if it retries all the times it's supposed to,


00:27:41.200 --> 00:27:43.680
and it fails, it'd be good to get all the errors,


00:27:43.680 --> 00:27:47.280
just the last one or the first one or whatever it decided it was going to give you.


00:27:47.280 --> 00:27:48.640
Yeah. It's the kind of thing.


00:27:48.640 --> 00:27:53.440
Yeah. Nice. Okay. Well, congratulations on getting that feature out. That's great.


00:27:53.440 --> 00:27:58.080
All right. What do we got next here? I think also related to this, I wanted to talk about


00:27:58.080 --> 00:28:00.880
this pep 678.


00:28:00.880 --> 00:28:08.480
That's a very small and simple feature that Zach had for Dodds Road, this pep. He was trying out


00:28:08.480 --> 00:28:13.760
Exception groups, he was the first user, even before the PR was merged, he was trying it out.


00:28:13.760 --> 00:28:18.560
He was trying to integrate it with the hypothesis library. So there, you write a test,


00:28:18.560 --> 00:28:22.400
and the library executes it many times with different inputs, and you get


00:28:22.400 --> 00:28:27.440
failures in some of the inputs, and you want to report all of them. So Zach had an exception group,


00:28:27.440 --> 00:28:32.240
kind of an exception wrapper, kind of like Trio Multi, or he had his own version that he built


00:28:32.240 --> 00:28:40.680
in his library and he could associate each exception he attached to it which input generated this error,


00:28:40.680 --> 00:28:45.440
which is very important, you need to tell people what the input was and what happened with it.


00:28:45.440 --> 00:28:50.200
And he couldn't do that in a convenient way with exception groups.


00:28:50.200 --> 00:28:57.520
So we added this to base exception, this is not a group feature, it's any exception you can add strings.


00:28:57.520 --> 00:29:04.200
You call add note, give it a string, and you can call it as many times as you want and add notes to the exceptions,


00:29:04.200 --> 00:29:08.760
and they will appear in the default traceback that the interpreter prints.


00:29:08.760 --> 00:29:15.040
So that's all it is, it's a very simple feature, but it was received surprisingly well, people kind of like it,


00:29:15.040 --> 00:29:18.040
that you can enrich an exception after you catch it.


00:29:18.040 --> 00:29:21.720
So you have the information that, you know, the error message and the type,


00:29:21.720 --> 00:29:25.440
you decide that when you raise the exception, but then sometimes when you catch it,


00:29:25.440 --> 00:29:30.200
There's some more information, some context, like what was I trying to do when this error happened?


00:29:30.200 --> 00:29:37.760
Sure. Yeah, because often you'll see, except some type, some exception type, you'll deal with what you can, but you can't really handle it there.


00:29:37.760 --> 00:29:38.800
So you got to raise it again.


00:29:38.800 --> 00:29:43.320
And this is a place to add more information without completely wrapping it, right?


00:29:43.320 --> 00:29:44.440
Right, exactly.


00:29:44.440 --> 00:29:48.280
A lot of people have to chain it, say this raised from that.


00:29:48.280 --> 00:29:52.040
So there will be situations where maybe you won't need to do that.


00:29:52.040 --> 00:29:53.920
Yeah, I'd love to see that go away.


00:29:53.920 --> 00:29:57.360
I sort of template libraries and stuff in the web all the time.


00:29:57.360 --> 00:29:59.360
I see like there's all these different errors


00:29:59.360 --> 00:30:02.360
and you got to hunt through a bunch of stuff to figure out what happened.


00:30:02.360 --> 00:30:04.800
Yeah, also think about, for instance,


00:30:04.800 --> 00:30:07.440
like I think this is super useful actually for end users even.


00:30:07.440 --> 00:30:11.360
Like, think about that you're doing some query to the database, right?


00:30:11.360 --> 00:30:14.160
And then, I don't know, it may fail for six million reasons


00:30:14.160 --> 00:30:17.160
and then you want to add what you're asking for, right?


00:30:17.160 --> 00:30:20.480
So you add your query or your user or whatever


00:30:20.480 --> 00:30:23.600
because probably the exception that the Postgres thingy


00:30:23.600 --> 00:30:27.400
that is underneath is not going to contain your actual thing.


00:30:27.400 --> 00:30:30.560
So this actually may save you hours, right?


00:30:30.560 --> 00:30:33.740
Because in many enterprise environments,


00:30:33.740 --> 00:30:36.560
you don't even have easy access to that, sorry, to prod.


00:30:36.560 --> 00:30:39.700
So you cannot just go there and see what's going on.


00:30:39.700 --> 00:30:42.040
So it would be super cool that you say,


00:30:42.040 --> 00:30:44.540
"Oh, if something fails, you know,


00:30:44.540 --> 00:30:46.240
I was trying to do this with this data


00:30:46.240 --> 00:30:47.080
and like with these things."


00:30:47.080 --> 00:30:49.380
So like, if it fails now, you can know what's going on


00:30:49.380 --> 00:30:50.620
and you don't even need to log in,


00:30:50.620 --> 00:30:52.800
which is, I think it's a quite good thing.


00:30:52.800 --> 00:30:54.760
- Yeah, yeah, it's a great idea.


00:30:54.760 --> 00:30:58.300
Or if you know, look, here's probably why this happened


00:30:58.300 --> 00:30:59.900
as a library developer, you're like,


00:30:59.900 --> 00:31:02.100
look, this is the error, but here's a note,


00:31:02.100 --> 00:31:03.940
this is probably 'cause you didn't initialize


00:31:03.940 --> 00:31:05.660
the connection before you called this.


00:31:05.660 --> 00:31:07.320
So make sure, you know, like,


00:31:07.320 --> 00:31:09.780
another area where I see this could be useful


00:31:09.780 --> 00:31:13.220
is I want to raise, like the example you have


00:31:13.220 --> 00:31:16.080
in the docs is type error, but it could also,


00:31:16.080 --> 00:31:17.540
you know, it could be value error


00:31:17.540 --> 00:31:19.600
or some other built-in low-level type.


00:31:19.600 --> 00:31:20.620
You know, like, really, this is just,


00:31:20.620 --> 00:31:22.180
I wanna raise that error,


00:31:22.180 --> 00:31:25.300
But it doesn't have a place for me to put additional information.


00:31:25.300 --> 00:31:27.840
And so I want to kind of enrich that with more.


00:31:27.840 --> 00:31:31.980
And so not just catch, add the data and then raise it again, but actually I want


00:31:31.980 --> 00:31:34.920
to use a base error type that doesn't let me put more details in it and then


00:31:34.920 --> 00:31:35.880
just raise that, right.


00:31:35.880 --> 00:31:36.600
That would also work.


00:31:36.600 --> 00:31:37.180
I think so.


00:31:37.180 --> 00:31:41.000
I mean, I think the intention was, there was some discussions about using


00:31:41.000 --> 00:31:44.140
notes in the interpreter and I pushed back on it because I said, this, this


00:31:44.140 --> 00:31:48.760
is owned by the application, the interpretation, you know, because people


00:31:48.760 --> 00:31:51.600
can wipe out the notes, they can change the order, they can do what they want.


00:31:51.600 --> 00:31:54.720
It's, it's, it's the applications, at least the way I see it.


00:31:54.720 --> 00:31:55.720
The cation owns it.


00:31:55.720 --> 00:31:57.840
You put whatever context you want to put.


00:31:57.840 --> 00:32:01.360
Is there only one note when I say add note, does that set the


00:32:01.360 --> 00:32:03.200
note or can I have a list of notes?


00:32:03.200 --> 00:32:04.400
It's a list of notes.


00:32:04.400 --> 00:32:04.640
Okay.


00:32:04.640 --> 00:32:04.880
Got it.


00:32:04.880 --> 00:32:05.040
Yeah.


00:32:05.040 --> 00:32:06.440
And you can wipe it out if you want.


00:32:06.440 --> 00:32:08.760
You can, it's, it's just a list.


00:32:08.760 --> 00:32:10.120
It's attached to the exception.


00:32:10.120 --> 00:32:11.040
You can do what you want with it.


00:32:11.040 --> 00:32:11.520
Really?


00:32:11.520 --> 00:32:11.800
Yeah.


00:32:11.800 --> 00:32:12.640
Okay.


00:32:12.640 --> 00:32:13.040
Yeah.


00:32:13.040 --> 00:32:14.440
It's a great, it's a really great feature.


00:32:14.440 --> 00:32:18.840
I mean, it's, I'm sure it was way less work than except star, but it's


00:32:18.840 --> 00:32:20.160
also going to be really valuable.


00:32:20.160 --> 00:32:20.560
I think.


00:32:20.600 --> 00:32:22.200
It's very simple, but it's yeah.


00:32:22.200 --> 00:32:22.500
Yeah.


00:32:22.500 --> 00:32:25.960
Brent or Mark, you guys got any thought about this before we move on to the next?


00:32:25.960 --> 00:32:26.800
I think it's really cool.


00:32:26.800 --> 00:32:27.600
I like it.


00:32:27.600 --> 00:32:28.360
Great work here.


00:32:28.360 --> 00:32:28.920
Indeed.


00:32:28.920 --> 00:32:30.120
Uh, I think it is as well.


00:32:30.120 --> 00:32:31.440
Actually, I'm really excited about it.


00:32:31.440 --> 00:32:35.800
I want to talk about, let's, let's talk about faster Python for a little bit.


00:32:35.800 --> 00:32:39.600
So Mark, I had you and Guido on back on, wow.


00:32:39.600 --> 00:32:41.520
Almost to the day a year ago.


00:32:41.520 --> 00:32:44.640
We're off by November 1st, 2021.


00:32:44.640 --> 00:32:47.920
So quite not, not that long ago.


00:32:48.080 --> 00:32:50.960
Let's talk a little bit about the work that you're doing there.


00:32:50.960 --> 00:32:58.440
I guess the headline is that Python 3.11 is 10 to 60, 10 to 50% faster than


00:32:58.440 --> 00:33:01.540
previous sort of on a reasonable range of applications.


00:33:01.540 --> 00:33:02.320
Is that the story?


00:33:02.320 --> 00:33:06.360
Yeah, somewhere between minus a few percent and plus a hundred,


00:33:06.360 --> 00:33:08.440
but it varies a huge amount.


00:33:08.440 --> 00:33:12.680
I mean, I mean, if you've got some application that basically spends all


00:33:12.680 --> 00:33:16.120
its time in NumPy or something like that, you're not really going to speed up at all.


00:33:16.440 --> 00:33:21.120
But if it's pure Python, you'd expect it to be a good 40, 50% faster.


00:33:21.120 --> 00:33:22.800
So, but it depends.


00:33:22.800 --> 00:33:23.080
Right.


00:33:23.080 --> 00:33:29.720
That's a good point because a lot of people do make Python faster by writing C or Rust or other languages.


00:33:29.720 --> 00:33:31.880
And at that point, like it's out of your hands, right?


00:33:31.880 --> 00:33:32.280
Yeah.


00:33:32.280 --> 00:33:38.840
So I mean, we're looking hopefully for 3.12 to start looking at the sort of interface between Python and C code.


00:33:38.840 --> 00:33:41.840
So we should speed up code even though there's quite a lot of C code.


00:33:41.840 --> 00:33:46.280
We won't spend up the time spent in the C code in doing the actual work in the C code, but there's


00:33:46.280 --> 00:33:50.400
still quite a lot of sort of marshaling of data that happens and hopefully we'll streamline that.


00:33:50.400 --> 00:33:56.200
But it's the existence of C extensions is sort of in some ways limits our opportunity to speed things up,


00:33:56.200 --> 00:34:00.480
but it's also, you know, why Python is so proper in the first place or one of the main reasons.


00:34:00.480 --> 00:34:02.200
So definitely need to acknowledge it.


00:34:02.200 --> 00:34:03.360
Yeah, absolutely.


00:34:03.360 --> 00:34:06.640
So, Brent, I'll definitely have you talk about the specializing interpreters,


00:34:06.640 --> 00:34:11.720
but Mark, maybe give us a rundown of some of the things from your plan that made it in here.


00:34:11.720 --> 00:34:15.120
I know some were aimed for 3.10, but they didn't make it until here, right?


00:34:15.120 --> 00:34:21.840
Yeah, so the whole thing, that original plan I put up, that was more of a just to get the discussion going sort of thing.


00:34:21.840 --> 00:34:24.160
And it's basically more or less a year off.


00:34:24.160 --> 00:34:26.320
So if you just shift everything one forward.


00:34:26.320 --> 00:34:30.960
I mean, there was a lot of discussion on speeding up the interpreter in the first iteration,


00:34:30.960 --> 00:34:34.400
and then looking more to the data structures in the second thing.


00:34:34.400 --> 00:34:35.680
It's much more jumbled than that.


00:34:35.680 --> 00:34:37.040
We're doing sort of a bit of everything.


00:34:37.040 --> 00:34:40.560
So obviously, I was planning on expanding a smaller team.


00:34:40.560 --> 00:34:42.720
So things are being a bit shuffled.


00:34:42.720 --> 00:34:48.640
So yeah, there's this specializing interpreter. Obviously, that's kind of key. There's also quite a lot of stuff we've done with data structures


00:34:48.640 --> 00:34:54.560
I mean we shrunk the python object. So we've been I mean the python object, you know has been shrinking for years


00:34:54.560 --> 00:34:56.800
I mean i've got some numbers here


00:34:56.800 --> 00:35:02.240
So like in 2.7 and 3.2, I like an object with just four attributes would take


00:35:02.240 --> 00:35:09.360
352 bytes on a 64-bit machine and for 3.11 we've got it down to 112 and for 3.12 it would be 96.


00:35:09.760 --> 00:35:14.800
Well, before you get too excited, there's only 32 in C++, so you know, we've got a bit of way to go.


00:35:14.800 --> 00:35:18.480
Yeah, but you know, it's going in the right direction for sure.


00:35:18.480 --> 00:35:21.200
And you know, I'm sure some people out there listening just say like,


00:35:21.200 --> 00:35:24.480
"Okay, well, it's half the size roughly, and it's going to be less than that."


00:35:24.480 --> 00:35:26.960
So, yay, we can use less memory.


00:35:26.960 --> 00:35:32.800
But maybe you could talk a little bit about how that affects things like L1, L2, L3 cache hits


00:35:32.800 --> 00:35:37.360
and other sort of, like, it's more important than just, "I need less RAM," right?


00:35:37.360 --> 00:35:43.600
Yes, there's two things that happen. Things are faster because the hardware is just happier.


00:35:43.600 --> 00:35:47.760
If you pack everything together, it's in a high-level cache, so you're not getting these


00:35:47.760 --> 00:35:52.240
long pauses as you hit main memory. And the other thing is just the data structures,


00:35:52.240 --> 00:35:57.280
because there's less of them, there's less indirection. So, for example, to load an attribute,


00:35:57.280 --> 00:36:02.320
we've got it down for basically in older versions of Python, it was effectively five


00:36:02.320 --> 00:36:05.840
memory reads, and they were dependent memory reads. You have to read one before the next one,


00:36:05.840 --> 00:36:11.680
and so on. Go to the class, go to the object, find its dictionary, then find the pointer that's in


00:36:11.680 --> 00:36:16.400
the dictionary and then go to that, right? Yeah, yeah, very much that. And that's down to more or


00:36:16.400 --> 00:36:21.120
less two now. So, I mean, obviously there's still interpretive overhead on that. So,


00:36:21.120 --> 00:36:27.920
it's not quite that much faster, but it's getting there. So, yeah, there's a data structure. And


00:36:27.920 --> 00:36:33.680
then the frames, the Python frames, every time you call a Python function, we used to just allocate


00:36:33.680 --> 00:36:36.560
a heap object for the frame and all the stuff would go in there.


00:36:36.560 --> 00:36:40.240
And now they're all basically in a big contiguous sort of block of memory.


00:36:40.240 --> 00:36:44.960
So it's just bumping a pointer rather than allocating, which is also faster.


00:36:44.960 --> 00:36:48.960
And frames are just smaller anyway because of the zero cost exceptions,


00:36:48.960 --> 00:36:52.560
which I think we mentioned on the release thing.


00:36:52.560 --> 00:36:53.680
But yeah, this is...


00:36:53.680 --> 00:36:55.840
Well, let's tell people about zero cost exceptions.


00:36:55.840 --> 00:36:57.120
Okay, well, zero cost...


00:36:57.120 --> 00:36:59.920
You shouldn't have to pay for errors if you're not raising errors, right?


00:36:59.920 --> 00:37:02.320
Yeah, that's the idea. And that's why they're called zero cost.


00:37:02.320 --> 00:37:07.840
But zero cost is in quotes in this, and the reason for that is that's just, that's the name it has got.


00:37:07.840 --> 00:37:13.520
They're definitely not zero cost. The idea is that they're pretty low cost if you don't have an exception,


00:37:13.520 --> 00:37:17.680
but they tend to be even more expensive if you do get an exception because you have to do more lookup.


00:37:17.680 --> 00:37:22.160
The important thing here is that just there was lots of runtime information we need to maintain,


00:37:22.160 --> 00:37:26.720
and we don't now. So that again shrinks the frames and just makes calls faster because


00:37:26.720 --> 00:37:31.520
calls in Python were notoriously slow. So that's one thing we've sped up significantly.


00:37:31.520 --> 00:37:44.960
Yeah. So the idea was in previous releases of Python, if you just enter a try block, even if it was successful, there was a little bit of overhead to set up the mechanisms of potentially handling the errors and the information you needed. Right?


00:37:44.960 --> 00:37:47.080
Yeah. And this wasn't just the overhead.


00:37:47.080 --> 00:37:48.200
You defer more of that, right?


00:37:48.200 --> 00:37:54.380
Yeah, I mean, it's actually not so much that overhead as the just the space you had to put that data in


00:37:54.380 --> 00:37:58.500
had to be allocated every time you made a call in case there was an exception.


00:37:58.500 --> 00:38:02.680
And then we had to, it was massively over allocated to the amount of space anyone ever needed.


00:38:02.680 --> 00:38:04.940
So just that was the big sort of advantage.


00:38:04.940 --> 00:38:06.820
Nice. Yeah, this is fantastic.


00:38:06.820 --> 00:38:11.420
You don't want to discourage people from putting proper error handling in their code.


00:38:11.420 --> 00:38:16.280
What do you think? I see your name on this feature here in GitHub.


00:38:16.280 --> 00:38:17.160
What are your thoughts on it?


00:38:17.160 --> 00:38:29.160
Yeah, I think it's cool. I mean, I was kind of, you know, it was a nice touch that Mark implemented it between when I wrote the prototype for exception groups and when the PEP was approved.


00:38:29.160 --> 00:38:40.160
So, that kind of went a bit. But it was good. I got intimately acquainted with zero cost exceptions through that exercise.


00:38:40.160 --> 00:38:43.160
Well, it's zero cost for some people.


00:38:43.160 --> 00:38:47.000
Yeah, I tease Mark a lot about that.


00:38:47.000 --> 00:38:50.040
No, I think it's a cool feature and I mean,


00:38:50.040 --> 00:38:51.960
I followed up on that.


00:38:51.960 --> 00:38:55.720
We now have, after we removed that, we still had a,


00:38:55.720 --> 00:38:59.320
I was talking about this on Monday, we had a jump over the exception handler


00:38:59.320 --> 00:39:02.760
and then I told Mark, wait a minute, there's a jump, it's not zero.


00:39:02.760 --> 00:39:06.040
You have to jump over the exception handler if there's no exception.


00:39:06.040 --> 00:39:08.760
So now we have, we did,


00:39:08.760 --> 00:39:11.480
we identify exception handlers as called blocks


00:39:11.480 --> 00:39:15.460
And before we lay out the code of the function, we put all the code blocks in the end.


00:39:15.460 --> 00:39:20.360
So now if there's no exception, there isn't even an exception handler to jump over.


00:39:20.360 --> 00:39:21.780
That would be in 3.12.


00:39:21.780 --> 00:39:23.180
So excellent.


00:39:23.180 --> 00:39:25.280
You mean zero cost even faster.


00:39:25.280 --> 00:39:27.780
So now it's smaller.


00:39:27.780 --> 00:39:28.060
Yeah.


00:39:28.060 --> 00:39:31.260
It's asymptotically approaching zero.


00:39:31.260 --> 00:39:31.940
Yeah.


00:39:31.940 --> 00:39:38.380
So, but it's kind of nice that we have this notion of cold blocks and hot blocks and we can maybe do other things with it.


00:39:38.420 --> 00:39:43.280
Kind of nice that all the, all the happy, but the fast code is kind of in the


00:39:43.280 --> 00:39:46.100
beginning of the functions, bytecode block.


00:39:46.100 --> 00:39:50.020
And, you know, in terms of caches and all that, you don't have to, I think it


00:39:50.020 --> 00:39:53.380
would, it will bring a few benefits beyond just not having to jump.


00:39:53.380 --> 00:39:53.700
Yeah.


00:39:53.700 --> 00:39:54.780
No, this is excellent.


00:39:54.780 --> 00:39:56.900
Uh, it's a really great feature and pretty straightforward.


00:39:56.900 --> 00:39:57.180
All right.


00:39:57.180 --> 00:40:00.380
Brent, tell us about the specializing adaptive interpreter.


00:40:00.380 --> 00:40:01.460
That's a big deal.


00:40:01.460 --> 00:40:04.300
You and I spoke about that about six weeks ago, I think.


00:40:04.300 --> 00:40:04.820
Yeah.


00:40:04.820 --> 00:40:05.220
Yeah.


00:40:05.420 --> 00:40:10.660
Basically the headline is the bytecode changes while it's running to adapt to your code, which is really neat.


00:40:10.660 --> 00:40:17.980
So it's kind of finding places where we can do the same thing, but using less work by like cheating a little bit.


00:40:17.980 --> 00:40:21.420
But cheating in a way that is not visible at all.


00:40:21.420 --> 00:40:27.540
A good example is something like a global load or a load from the builtin.


00:40:27.540 --> 00:40:32.020
So if I'm looking up like the len function, that requires two dictionary lookups.


00:40:32.040 --> 00:40:34.680
Every time I want to look at the land function anywhere, I first need to


00:40:34.680 --> 00:40:37.200
check the global namespace and that's going to be a failed lookup.


00:40:37.200 --> 00:40:39.400
Then I need to check the built-ins dictionary and that's


00:40:39.400 --> 00:40:40.560
going to be a successful lookup.


00:40:40.560 --> 00:40:45.520
So every time I want to use land or range or list or any of those built-ins,


00:40:45.520 --> 00:40:47.840
that's the cost that I have to pay.


00:40:47.840 --> 00:40:50.800
But people don't change the global namespace that often.


00:40:50.800 --> 00:40:54.080
And people change the built-ins namespace even less often, or at least


00:40:54.080 --> 00:40:55.760
they shouldn't be changing it very often.


00:40:55.760 --> 00:40:58.120
I'm going to make false true and true false.


00:40:58.120 --> 00:40:59.000
So let's see what that does.


00:41:00.680 --> 00:41:15.840
And so you can make these observations where it's like, okay, well, if the set of keys in the global namespace hasn't changed since last time this bytecode instruction ran, then I know that that lookup is going to fail because if it failed last time, and the keys are the same, then it's going to fail this time as well.


00:41:15.840 --> 00:41:16.800
So we can just skip that.


00:41:16.800 --> 00:41:19.400
And same for the built-ins dictionary.


00:41:19.400 --> 00:41:26.520
You know, if we know that the keys in that dictionary haven't changed, that actually means that the internal layout of the dictionary is the same.


00:41:26.520 --> 00:41:30.920
and we don't even need to look up len in the built-ins dictionary.


00:41:30.920 --> 00:41:35.520
We can reach directly to the last location where it was before and give you that instead.


00:41:35.520 --> 00:41:36.520
And so that's cool.


00:41:36.520 --> 00:41:41.920
You'll often see in a lot of code, as like a older code, is a kind of a micro-optimization.


00:41:41.920 --> 00:41:45.720
Whenever someone was using a built-in in like a very hot Python loop,


00:41:45.720 --> 00:41:48.720
sometimes you'd see them like do this kind of quark trick


00:41:48.720 --> 00:41:51.920
where they make it a local variable by saying like len equals len


00:41:51.920 --> 00:41:54.520
or something like that as part of the functions arguments.


00:41:54.520 --> 00:42:02.880
So that you turn it into a fast local load. And what we've essentially done is, you know, made ugly acts like that totally unnecessary.


00:42:02.880 --> 00:42:03.880
Yeah, which is really good.


00:42:03.880 --> 00:42:05.520
You do that behind the scenes transparently. Yeah.


00:42:05.520 --> 00:42:15.680
Exactly. And so that's, that's just, you know, one example, we've done tons of specializations for all sorts of things ranging from calls to attribute lookups, to attribute stores, etc.


00:42:15.680 --> 00:42:18.880
So yeah, it's a, it's a really, really powerful thing.


00:42:18.880 --> 00:42:22.600
What was it? 5, 6, 9?


00:42:22.600 --> 00:42:23.760
Yeah, Mark wrote it.


00:42:23.760 --> 00:42:24.760
It was 6, 5, 9.


00:42:24.760 --> 00:42:26.480
6, 5, 9. Almost there, yeah.


00:42:26.480 --> 00:42:29.040
Yeah, so this interpreter is Mark's baby.


00:42:29.040 --> 00:42:30.680
He could tell you much more about it than I could.


00:42:30.680 --> 00:42:33.440
Yeah, I just want to give you a chance to give a shout out about Specialist.


00:42:33.440 --> 00:42:36.200
Yeah, yeah. So this is why I was on your show a couple weeks ago.


00:42:36.200 --> 00:42:39.840
So looking at bytecode disassemblies is not fun.


00:42:39.840 --> 00:42:43.440
And so one thing that's kind of cool is, you know, if you upgrade to Python 3.11,


00:42:43.440 --> 00:42:46.880
you run your code, you saw it got, you know, 10, 20, 30% faster.


00:42:46.880 --> 00:42:51.680
you might be wondering like, okay, where did it get faster? Like, what is faster about my code?


00:42:51.680 --> 00:42:58.000
And so specialist is basically a package that I made, it's pip installable, it only works on 3.11.


00:42:58.000 --> 00:43:02.960
And basically, if you run your code using specialist instead of Python, so you just type


00:43:02.960 --> 00:43:09.040
specialist, my project dot py or whatever, it will open a web browser and show you your code,


00:43:09.040 --> 00:43:14.000
but color highlighted to show you where the interpreter was able to specialize your code


00:43:14.000 --> 00:43:16.120
where it wasn't, and that's really neat.


00:43:16.120 --> 00:43:18.040
So you can see like, oh, actually, you know,


00:43:18.040 --> 00:43:19.760
these are the attribute loads that got faster.


00:43:19.760 --> 00:43:21.600
These are the places where my global loads


00:43:21.600 --> 00:43:23.200
are being cached, that sort of thing.


00:43:23.200 --> 00:43:24.040
- Yeah, that's awesome.


00:43:24.040 --> 00:43:25.120
Yeah, this is a really cool project.


00:43:25.120 --> 00:43:27.800
And it has some proactive features,


00:43:27.800 --> 00:43:30.760
not just informational aspects, I think anyway.


00:43:30.760 --> 00:43:32.520
You know, if you run a profiler,


00:43:32.520 --> 00:43:35.000
it'll show you where your code's spending time,


00:43:35.000 --> 00:43:37.440
but it doesn't mean you should go change everything


00:43:37.440 --> 00:43:38.280
to make it faster.


00:43:38.280 --> 00:43:39.880
You should look at like, oh, this loop,


00:43:39.880 --> 00:43:41.880
or this one function is like the thing


00:43:41.880 --> 00:43:47.080
that maybe we should think about slightly changing the algorithm or the way we do a loop or something.


00:43:47.080 --> 00:43:51.000
And it's a little bit similar here because the specializing adaptive interpreter


00:43:51.000 --> 00:43:56.440
only specializes some things, like it doesn't specialize floats interacting with ints


00:43:56.440 --> 00:44:00.040
or those types of things, or I think division as well.


00:44:00.040 --> 00:44:04.200
And so there's certain ways you might be able to slightly change inside of a really hot loop,


00:44:04.200 --> 00:44:09.320
you know, make something a float ahead of time if you know it's going to be involved in floating point operations, right?


00:44:09.320 --> 00:44:16.040
Yeah, the idea is that this is show us how we can fix things so that you don't need to mess with your code.


00:44:16.040 --> 00:44:20.040
I see. So this is in the future. Okay. Yeah, awesome.


00:44:20.040 --> 00:44:25.640
I would not necessarily encourage people to start tuning individual bytecode instructions in their code


00:44:25.640 --> 00:44:27.640
due to our implementation details.


00:44:27.640 --> 00:44:29.640
Otherwise you will end coding in C.


00:44:29.640 --> 00:44:33.480
You mean I need to take all those decimal points back out of my code? No, just kidding.


00:44:33.480 --> 00:44:36.040
Yeah, I want to get every single bytecode instruction green.


00:44:36.040 --> 00:44:36.880
(laughing)


00:44:36.880 --> 00:44:38.280
Some things will never specialize,


00:44:38.280 --> 00:44:40.100
and that's just an artifact of programs.


00:44:40.100 --> 00:44:43.240
But if we can specialize enough, and we typically do,


00:44:43.240 --> 00:44:45.760
one line may be 20 bytecode instructions.


00:44:45.760 --> 00:44:49.120
If four of them get specialized successfully


00:44:49.120 --> 00:44:50.300
and two of them don't,


00:44:50.300 --> 00:44:51.880
generally that will still be faster.


00:44:51.880 --> 00:44:54.520
- Do you know what you should do for April Fool?


00:44:54.520 --> 00:44:56.720
Like you should do a Python plugin


00:44:56.720 --> 00:44:58.160
that shows you the percentage


00:44:58.160 --> 00:45:00.320
of specialized instructions in your code,


00:45:00.320 --> 00:45:02.280
and people can fix the percentage.


00:45:02.280 --> 00:45:04.200
So they can say, "Fail my test suite


00:45:04.200 --> 00:45:07.000
if my code is not specialized more than 50%.


00:45:07.000 --> 00:45:09.000
If you despecialize it,


00:45:09.000 --> 00:45:11.000
it's like a performance regression.


00:45:11.000 --> 00:45:13.000
Drop it.


00:45:13.000 --> 00:45:15.000
Yeah, it's like a coverage thing.


00:45:15.000 --> 00:45:17.000
I was kind of thinking about this, so


00:45:17.000 --> 00:45:19.400
Paolo can tell you more about this, but his cool new


00:45:19.400 --> 00:45:23.800
tracebacks, the whole reason Specialists is able to do these cool


00:45:23.800 --> 00:45:27.400
column level highlighting of your source code is because we do have


00:45:27.400 --> 00:45:30.400
that fine-grained position information under the hood.


00:45:30.400 --> 00:45:32.400
We kind of just piggybacked on that feature


00:45:32.400 --> 00:45:34.000
in order to give you that.


00:45:34.000 --> 00:45:41.920
But I was kind of thinking another, another thing, another April Fools project could be, you know, column level coverage information.


00:45:41.920 --> 00:45:44.600
So to get to 100% coverage, you have to cover every single column.


00:45:44.600 --> 00:45:45.040
Exactly.


00:45:45.040 --> 00:45:45.520
Yeah.


00:45:45.520 --> 00:45:47.440
I feel like people might take that too seriously.


00:45:47.440 --> 00:45:49.920
Even the white space, all this white space is not covered.


00:45:49.920 --> 00:45:55.280
Yeah, you think you're intense by having branch coverage turned on just wait till you have column coverage turned on.


00:45:55.280 --> 00:45:57.880
Yeah, you can only cover two white spaces per line.


00:45:57.880 --> 00:45:59.040
So you got to call that a lot.


00:45:59.040 --> 00:45:59.620
All right.


00:46:00.000 --> 00:46:06.720
I think that's a perfect segue over to one of the most tangible contributions from Pablo here.


00:46:06.720 --> 00:46:10.160
Maybe tell us about this new fine-grained error locations and tracebacks.


00:46:10.160 --> 00:46:11.040
This is fantastic.


00:46:11.040 --> 00:46:16.560
This will save people being in debuggers or rewriting their code with tons of print statements


00:46:16.560 --> 00:46:17.840
to figure out what's going on, I think.


00:46:17.840 --> 00:46:19.040
Yeah, thank you very much.


00:46:19.040 --> 00:46:20.720
We put a lot of effort into this.


00:46:20.720 --> 00:46:24.080
So this is, I don't even remember my PEP.


00:46:24.080 --> 00:46:26.000
So I don't know, it's PEP something something.


00:46:26.000 --> 00:46:27.440
And it has a horrendous name.


00:46:27.440 --> 00:46:31.680
-657 and let's see. -657, thanks.


00:46:31.680 --> 00:46:34.940
That's include fine grained error locations and tracebacks.


00:46:34.940 --> 00:46:36.020
Yeah, the worst name.


00:46:36.020 --> 00:46:39.320
I think I was talking with Mark in the Python Core Developer Spring


00:46:39.320 --> 00:46:42.320
and he was saying like, what it means like fine grained?


00:46:42.320 --> 00:46:45.460
Like, you know, like is this very fine grained?


00:46:45.460 --> 00:46:48.460
So I think we are renaming the PEP to fancy tracebacks.


00:46:48.460 --> 00:46:50.460
I think that's much better.


00:46:50.460 --> 00:46:55.960
Anyway, so this is a project I worked together with Batuhanta Skya and Omar Askar.


00:46:55.960 --> 00:46:59.200
So kudos to them as well, because they participated equally on this.


00:46:59.200 --> 00:47:03.880
And the idea is that we were like, we started this project to make,


00:47:03.880 --> 00:47:08.200
you know, to improve the error messages in the interpreter and the general experience,


00:47:08.200 --> 00:47:11.000
not only for, you know, people, because when people talk about this,


00:47:11.000 --> 00:47:14.400
they normally refer to people starting to learn Python.


00:47:14.400 --> 00:47:18.160
But like, to be honest, most of these things also affect people that are experts.


00:47:18.160 --> 00:47:21.640
Like, I always say that when I implemented the suggestions,


00:47:21.640 --> 00:47:25.000
I was the first one benefiting from them, because like, I make a lot of typos.


00:47:25.000 --> 00:47:27.880
and it says, "Oh, you mean this."


00:47:27.880 --> 00:47:30.520
So the idea that we have is that most of the time,


00:47:30.520 --> 00:47:32.960
the lack of, you know, the interpreter shows you


00:47:32.960 --> 00:47:34.680
kind of the position when the error happens,


00:47:34.680 --> 00:47:37.880
but it's quite limited because most of the time,


00:47:37.880 --> 00:47:41.000
people tend to have, due to Python flexible syntax,


00:47:41.000 --> 00:47:44.640
a huge amount of complexity even in a single line.


00:47:44.640 --> 00:47:46.320
In the pub, there is a bunch of examples,


00:47:46.320 --> 00:47:48.920
like you access a bunch of keys in a dictionary


00:47:48.920 --> 00:47:51.200
and some of them doesn't work or is not there


00:47:51.200 --> 00:47:52.960
or is none or something like that.


00:47:52.960 --> 00:47:54.440
And then it fails.


00:47:54.440 --> 00:47:57.180
or sometimes you have like several function calls


00:47:57.180 --> 00:48:00.480
or several additions, and you know, it's quite difficult.


00:48:00.480 --> 00:48:02.320
And most of the time, fixing these things


00:48:02.320 --> 00:48:05.180
involve going into a debugger like PDB


00:48:05.180 --> 00:48:07.660
and then trying to inspect every single object


00:48:07.660 --> 00:48:10.460
and say, okay, this dictionary doesn't have this key


00:48:10.460 --> 00:48:12.760
at this level, and like, you know, that sucks.


00:48:12.760 --> 00:48:15.760
It's not, because like, debuggers are cool,


00:48:15.760 --> 00:48:18.400
but like, it's cool or not to use them, right?


00:48:18.400 --> 00:48:21.400
And you know, we thought, what can we do here?


00:48:21.400 --> 00:48:24.200
And we arrived to this idea, actually,


00:48:24.200 --> 00:48:26.840
also to mention everyone involved.


00:48:26.840 --> 00:48:30.740
This was originally inspired by some kind of prototype


00:48:30.740 --> 00:48:34.840
that Carl from the PyPy team made very long ago,


00:48:34.840 --> 00:48:37.780
when he saw like a kind of minimal version of this.


00:48:37.780 --> 00:48:39.960
And then I said, "Okay, can we do this?"


00:48:39.960 --> 00:48:42.860
And what we do now is that we propagate,


00:48:42.860 --> 00:48:45.640
because the parser, our super cool PEC parser,


00:48:45.640 --> 00:48:48.600
knows position of all the tokens and things like that.


00:48:48.600 --> 00:48:51.700
So we are propagating that information


00:48:51.700 --> 00:48:53.140
through the interpreter,


00:48:53.140 --> 00:48:55.940
and we store this information now in code objects.


00:48:55.940 --> 00:48:57.620
So a side effect of this pep actually


00:48:57.620 --> 00:48:59.660
is that code objects are slightly bigger,


00:48:59.660 --> 00:49:01.180
although, you know, because code objects


00:49:01.180 --> 00:49:03.900
don't tend to be a huge percentage of your application,


00:49:03.900 --> 00:49:05.260
it doesn't really matter that much.


00:49:05.260 --> 00:49:06.780
Maybe PYC files are a bit bigger,


00:49:06.780 --> 00:49:10.660
but you know, you have a lot of disk space, I'm sure.


00:49:10.660 --> 00:49:12.140
And the idea is that, you know,


00:49:12.140 --> 00:49:13.980
we store this information in code objects,


00:49:13.980 --> 00:49:15.260
so when you raise an exception,


00:49:15.260 --> 00:49:17.660
we say, "Oh, what is the instruction


00:49:17.660 --> 00:49:19.220
that is right this exception.


00:49:19.220 --> 00:49:21.580
And then once we know which is the instruction


00:49:21.580 --> 00:49:23.340
that raised the exception, then we go and say,


00:49:23.340 --> 00:49:25.740
okay, what is the position information


00:49:25.740 --> 00:49:27.020
that generated this instruction?


00:49:27.020 --> 00:49:29.220
And because we propagated it, we know.


00:49:29.220 --> 00:49:33.100
And then we can say, okay, here is kind of like the lines,


00:49:33.100 --> 00:49:35.420
the columns that this instruction spans.


00:49:35.420 --> 00:49:38.140
So that kind of allows us to underline


00:49:38.140 --> 00:49:39.220
the specific location.


00:49:39.220 --> 00:49:40.700
But we go a bit further.


00:49:40.700 --> 00:49:41.980
I'm sorry, sorry, go ahead, Michael.


00:49:41.980 --> 00:49:43.940
- I was gonna say, this is super valuable.


00:49:43.940 --> 00:49:46.460
The example you have in the PEP is you have a dictionary,


00:49:46.460 --> 00:49:51.160
you say bracket of key A, and then the thing that comes back is another


00:49:51.160 --> 00:49:54.200
dictionary. So you say bracket B and then another dictionary, bracket C,


00:49:54.200 --> 00:49:57.640
and then bracket D. And if you're on 310, the error is just like, if one of


00:49:57.640 --> 00:50:03.560
those is none, say none type is object, object is not subscriptable, or maybe,


00:50:03.560 --> 00:50:07.640
you know, does not contain that key or some weird thing like that. But is it


00:50:07.640 --> 00:50:11.720
A, B, C, or D? You have no idea. You're in a debugger printing them out


00:50:11.720 --> 00:50:15.360
separately or something, but now it just goes, nope, it's the C one. That's


00:50:15.500 --> 00:50:17.740
It's the third subscript one.


00:50:17.740 --> 00:50:19.340
And that's just, just jump right to it.


00:50:19.340 --> 00:50:19.840
Oh, okay.


00:50:19.840 --> 00:50:22.420
Yeah. Also this error, non-type is not subscript.


00:50:22.420 --> 00:50:25.220
It's kind of like, thanks for the info.


00:50:25.220 --> 00:50:27.620
Like, it's like, you know, water is wet.


00:50:27.620 --> 00:50:28.620
Okay, thanks.


00:50:28.620 --> 00:50:30.420
It's not super useful.


00:50:30.420 --> 00:50:31.120
Yeah, exactly.


00:50:31.120 --> 00:50:32.300
So tell me when it's going to rain.


00:50:32.300 --> 00:50:34.100
Anyway, we did like the first version of this


00:50:34.100 --> 00:50:36.100
and then we realized


00:50:36.100 --> 00:50:38.300
that there was some kind of like, you know,


00:50:38.300 --> 00:50:39.060
it was cool.


00:50:39.060 --> 00:50:40.340
Like most people really like it,


00:50:40.340 --> 00:50:42.000
but like, especially for instance,


00:50:42.000 --> 00:50:44.100
with the example with the dictionary


00:50:44.100 --> 00:50:46.300
that has many dictionaries inside.


00:50:46.300 --> 00:50:48.000
There was some confusion because, like, you know,


00:50:48.000 --> 00:50:49.540
it underlines the whole thing.


00:50:49.540 --> 00:50:52.340
And then, you know, the order of operations,


00:50:52.340 --> 00:50:54.980
and, you know, also with complex mathematical expressions,


00:50:54.980 --> 00:50:58.140
like, you do A plus B plus C, and the last addition fails,


00:50:58.140 --> 00:51:00.440
it needs to underline A plus B plus C,


00:51:00.440 --> 00:51:02.880
because what happened is that it first added A plus B,


00:51:02.880 --> 00:51:06.020
and that gives you something that then you added to Z.


00:51:06.020 --> 00:51:08.960
And what happened is that the last addition failed,


00:51:08.960 --> 00:51:10.120
but that includes A plus B,


00:51:10.120 --> 00:51:11.860
so you need to underline the whole thing.


00:51:11.860 --> 00:51:13.560
If you know the order of operations,


00:51:13.560 --> 00:51:15.800
and I just underline A plus B plus C,


00:51:15.800 --> 00:51:18.560
you know that what will fail is the last one,


00:51:18.560 --> 00:51:20.560
because that's the last one that is executed.


00:51:20.560 --> 00:51:22.200
But it is still confusing because,


00:51:22.200 --> 00:51:24.040
you know, specifically also with the dictionary,


00:51:24.040 --> 00:51:25.600
people were saying, "Yeah, okay, but like,


00:51:25.600 --> 00:51:27.200
"you're underlining three keys here,


00:51:27.200 --> 00:51:28.400
"which is the one that failed."


00:51:28.400 --> 00:51:30.160
I mean, you know, you can learn by experience


00:51:30.160 --> 00:51:31.680
that it's the last one, but it's kind of like,


00:51:31.680 --> 00:51:33.720
it was not a great experience.


00:51:33.720 --> 00:51:35.440
So we went a step farther.


00:51:35.440 --> 00:51:37.280
So what we do is that once we know


00:51:37.280 --> 00:51:40.880
the kind of range in the line that shows the problem,


00:51:40.880 --> 00:51:43.720
we reparse that chunk of expression,


00:51:43.720 --> 00:51:45.280
and then we know, okay, so we know now


00:51:45.280 --> 00:51:47.600
that this expression has this AST,


00:51:47.600 --> 00:51:49.800
and then we analyze the AST, and then we say,


00:51:49.800 --> 00:51:53.560
okay, is this AST something that we can further improve


00:51:53.560 --> 00:51:54.400
the error message?


00:51:54.400 --> 00:51:57.300
Like, for instance, is this AST a bunch of key access


00:51:57.300 --> 00:51:59.360
in a dictionary, or a bunch of attribute access,


00:51:59.360 --> 00:52:03.480
or a bunch of function calls, or maybe binary operations?


00:52:03.480 --> 00:52:05.760
And if it's the case, then we use a specialized,


00:52:05.760 --> 00:52:08.280
like, you know, underlying, I don't know,


00:52:08.280 --> 00:52:11.180
or a tilde, or a squiggle, or whatever it's called.


00:52:11.180 --> 00:52:14.280
And you know, the dictionary ones have this different one


00:52:14.280 --> 00:52:16.880
that marks which key access it was known,


00:52:16.880 --> 00:52:19.380
the same thing for binary operations and things like that.


00:52:19.380 --> 00:52:22.040
So we do this extra step at the end


00:52:22.040 --> 00:52:23.640
that does a bunch of extra work,


00:52:23.640 --> 00:52:26.080
but it tries to improve even upon the,


00:52:26.080 --> 00:52:27.720
kind of just underlining the line,


00:52:27.720 --> 00:52:31.120
just so we can offer even more rich information.


00:52:31.120 --> 00:52:34.160
And I'm quite happy, I'm very pleased about this.


00:52:34.160 --> 00:52:38.020
Sorry, Mark, but I think it's the best feature of 3.11.


00:52:38.020 --> 00:52:41.020
- Yeah, this is probably the second stream when I said this,


00:52:41.020 --> 00:52:44.180
but it's true, totally true, 100% true.


00:52:44.180 --> 00:52:45.660
So I'm very excited about this.


00:52:45.660 --> 00:52:46.980
I literally use this every day.


00:52:46.980 --> 00:52:50.140
Today I was deploying Python 3.11, well, this week, sorry.


00:52:50.140 --> 00:52:51.820
I was deploying Python 3.11 at Bloomer,


00:52:51.820 --> 00:52:53.220
and something went wrong,


00:52:53.220 --> 00:52:55.140
and literally, this thing saved my day.


00:52:55.140 --> 00:52:58.180
This saved me to just log in to some forsaken machine


00:52:58.180 --> 00:52:59.580
and understanding what's going on.


00:52:59.580 --> 00:53:00.540
What about that?


00:53:00.540 --> 00:53:01.980
So super cool, very happy.


00:53:01.980 --> 00:53:03.980
I hope that everybody that uses this


00:53:03.980 --> 00:53:06.660
and is happy, reach to us and say, "I am happy."


00:53:06.660 --> 00:53:10.120
because normally people reach to us when they are not happy.


00:53:10.120 --> 00:53:12.020
And they say, "Mmm, evil core developers,


00:53:12.020 --> 00:53:12.860
"you break everything."


00:53:12.860 --> 00:53:15.200
But instead of that, you should reach to us and say,


00:53:15.200 --> 00:53:18.340
"Nice, I did this cool thing."


00:53:18.340 --> 00:53:20.600
- You should tweet at Pablo or something, though.


00:53:20.600 --> 00:53:22.540
Don't open issues saying you're happy.


00:53:22.540 --> 00:53:23.380
- Exactly, exactly.


00:53:23.380 --> 00:53:24.260
(laughs)


00:53:24.260 --> 00:53:26.640
- Just, exactly, just tweet a couple tildes,


00:53:26.640 --> 00:53:28.380
a few carats, and a smiley face at him.


00:53:28.380 --> 00:53:30.500
- Exactly, tweet at happy@python.org,


00:53:30.500 --> 00:53:33.180
which I will take that, and the email address.


00:53:33.180 --> 00:53:34.020
- Awesome.


00:53:34.020 --> 00:53:34.840
- It is that.


00:53:34.840 --> 00:53:36.380
We improve it a bit further.


00:53:36.380 --> 00:53:40.380
One of the things that happens is that sometimes if the whole line is wrong,


00:53:40.380 --> 00:53:42.220
because this example you have there, if you...


00:53:42.220 --> 00:53:44.620
- Sorry, for the ones listening... - The one I had before, yeah.


00:53:44.620 --> 00:53:47.980
We have here some... We are seeing some output, but it doesn't matter.


00:53:47.980 --> 00:53:49.580
Don't worry, I will describe it.


00:53:49.580 --> 00:53:51.660
So, for instance, you're calling a function,


00:53:51.660 --> 00:53:53.580
and that's the whole thing that is in the line.


00:53:53.580 --> 00:53:55.500
We used to underline the whole thing.


00:53:55.500 --> 00:53:58.780
So we'll say, "Okay, even if the whole line is failing,"


00:53:58.780 --> 00:54:02.300
so there's no, like, a part of the line is failing, the whole thing is failing,


00:54:02.300 --> 00:54:05.580
we used to underline that, and that apparently is still on the pip.


00:54:05.580 --> 00:54:08.620
Maybe I should change that because it's not like that anymore.


00:54:08.620 --> 00:54:10.620
Because someone suggested, I mean, come on,


00:54:10.620 --> 00:54:12.300
like if the whole line is failing,


00:54:12.300 --> 00:54:14.420
underline the whole line, it's actually not that useful,


00:54:14.420 --> 00:54:17.800
and you know, you're spending vertical space,


00:54:17.800 --> 00:54:19.260
so you need to scroll a lot.


00:54:19.260 --> 00:54:20.800
And at the beginning I say,


00:54:20.800 --> 00:54:23.560
"Yeah, but it's inconsistent, I don't like it."


00:54:23.560 --> 00:54:25.940
And I pushed back a bit, but like then,


00:54:25.940 --> 00:54:28.180
you know, more people say, "Pablo, you're wrong."


00:54:28.180 --> 00:54:29.900
And then I say, "Okay, okay, I'm wrong."


00:54:29.900 --> 00:54:32.640
We improve this further, so you say,


00:54:32.640 --> 00:54:34.560
"But don't take this as advice.


00:54:34.560 --> 00:54:37.640
Don't tell me that I'm wrong collectively, please.


00:54:37.640 --> 00:54:41.980
But right, so now if the whole line is underlined,


00:54:41.980 --> 00:54:43.980
we don't underline it because it doesn't really add


00:54:43.980 --> 00:54:45.100
any new information, right?


00:54:45.100 --> 00:54:48.520
So only if a part of the line contains the error


00:54:48.520 --> 00:54:49.600
and not the whole line.


00:54:49.600 --> 00:54:52.180
So this means that we are not going to consume


00:54:52.180 --> 00:54:54.600
a lot of vertical space for no reason.


00:54:54.600 --> 00:54:56.900
And the last thing I wanted to say is that,


00:54:56.900 --> 00:54:58.980
there is some people somewhere in the universe


00:54:58.980 --> 00:55:01.720
that may care about that extra disk space


00:55:01.720 --> 00:55:06.280
on their PYC files, or they just really, really hate squiggles.


00:55:06.280 --> 00:55:08.600
I don't know if that is even physically possible,


00:55:08.600 --> 00:55:12.120
but you know, there are very different and diverse set of people.


00:55:12.120 --> 00:55:13.120
You are one of those.


00:55:13.120 --> 00:55:17.120
There is a collection of different ways you can deactivate this feature.


00:55:17.120 --> 00:55:20.240
There is an environment variable with a super long name,


00:55:20.240 --> 00:55:23.640
and there is -x option when you launch the interpreter.


00:55:23.640 --> 00:55:26.240
So you can say Python -x something something.


00:55:26.240 --> 00:55:27.240
I don't know how it's called.


00:55:27.240 --> 00:55:29.880
I think it's called null debug ranges.


00:55:29.880 --> 00:55:32.680
What about that? What an incredible naming.


00:55:32.680 --> 00:55:35.240
And then you set null back ranges to one,


00:55:35.240 --> 00:55:36.840
and it deactivates the feature.


00:55:36.840 --> 00:55:39.080
Incredible. Like magic. It's gone.


00:55:39.080 --> 00:55:41.480
And you can reclaim your PYC files,


00:55:41.480 --> 00:55:44.520
and you can even generate PYC files without this information


00:55:44.520 --> 00:55:46.520
if when you're compiling PYC files,


00:55:46.520 --> 00:55:48.680
you set this evil variant variable.


00:55:48.680 --> 00:55:50.200
But don't do that, listeners.


00:55:50.200 --> 00:55:51.880
Don't do that. It's evil. Don't do that.


00:55:51.880 --> 00:55:53.480
Just use it. It's great.


00:55:53.480 --> 00:55:53.980
Yeah.


00:55:53.980 --> 00:55:57.800
There's another kind of type of errors


00:55:57.800 --> 00:56:00.280
that I think we're going to get is about edge cases


00:56:00.280 --> 00:56:03.400
where the compiler doesn't get the line numbers right


00:56:03.400 --> 00:56:06.360
because all these kind of fine-grained locations,


00:56:06.360 --> 00:56:09.240
it's all new and we're still ironing out.


00:56:09.240 --> 00:56:11.640
- At a front feature, there is a front feature, I think,


00:56:11.640 --> 00:56:14.360
that you put a bunch of things with the front feature,


00:56:14.360 --> 00:56:15.960
it just complains on a random place.


00:56:15.960 --> 00:56:18.280
- Yeah, today I found that one.


00:56:18.280 --> 00:56:20.360
But I've been looking at the compiler


00:56:20.360 --> 00:56:23.080
and the line number, location information,


00:56:23.080 --> 00:56:24.360
and it's a bit off here and there.


00:56:24.360 --> 00:56:27.960
And we have received bug reports from other people as well.


00:56:27.960 --> 00:56:31.720
The range here doesn't look right, the range here looks too broad.


00:56:31.720 --> 00:56:36.520
So yeah, we're going to be ironing that out for I guess for 3.12.


00:56:36.520 --> 00:56:39.640
Yeah, it's really nice when people are using betas and release candidates though,


00:56:39.640 --> 00:56:42.600
because we were able to catch a lot of those before the release.


00:56:42.600 --> 00:56:46.440
Because there were a couple people, I forget exactly the name of the project,


00:56:46.440 --> 00:56:50.440
but they were working on like a code animation tool where it animates your code while it's running.


00:56:50.440 --> 00:56:53.960
And they were using these new ranges to identify AST nodes and stuff.


00:56:53.960 --> 00:56:59.000
And so they did this thing, I guess, where they like run their tool in the entire standard library, make sure it's correct.


00:56:59.000 --> 00:57:06.160
And so we got a bunch of bug reports that basically say, Oh, you know, this column information is off for this weird multi-line attribute access or something.


00:57:06.160 --> 00:57:09.240
If you recall, I think you fix an error.


00:57:09.240 --> 00:57:15.400
That was super weird, because he was like a method access, like, you know, my instance of food.


00:57:15.400 --> 00:57:20.240
And if the method access has like some like bowel or something like that, it was wrong.


00:57:20.240 --> 00:57:23.240
And if you added some extra letter, it was fine.


00:57:23.280 --> 00:57:35.920
Yeah, it was like if you split your method access across two lines, if you do like x.method or x.method or x.method on three lines or two lines or something,


00:57:35.920 --> 00:57:45.240
the way we trace those lines, we always trace the method when we're actually loading the method, even if it's on a different line as like where the actual method load started.


00:57:45.240 --> 00:57:51.000
And then we were doing some weird math to like figure out where the dot is. So we would try to put it on the same line as the dot.


00:57:51.000 --> 00:57:54.160
So we would just like subtract one from the length of the name.


00:57:54.160 --> 00:57:56.000
So there was all sorts of crazy stuff.


00:57:56.000 --> 00:57:58.560
- And that came from the grave because we fixed that.


00:57:58.560 --> 00:58:00.320
And then it was wrong again,


00:58:00.320 --> 00:58:02.760
because we were like miscalculating the name.


00:58:02.760 --> 00:58:04.840
It's just so mad that that is.


00:58:04.840 --> 00:58:05.680
- Oh my goodness.


00:58:05.680 --> 00:58:07.320
- Yeah, so all sorts of fun stuff like that.


00:58:07.320 --> 00:58:08.600
- Yeah, amazing.


00:58:08.600 --> 00:58:11.800
Well, yeah, this is definitely one of the highlight features


00:58:11.800 --> 00:58:14.200
for sure, and also the performance work that you're all doing.


00:58:14.200 --> 00:58:16.360
All right, we're getting very, very short on time.


00:58:16.360 --> 00:58:19.160
So I think maybe a super, super lightning round here.


00:58:19.160 --> 00:58:22.600
Let me just say we also got TomaLib support built in.


00:58:22.600 --> 00:58:26.800
We've got the async I/O task groups, a la trio nurseries.


00:58:26.800 --> 00:58:29.900
We've got new features for atomic grouping


00:58:29.900 --> 00:58:31.900
and regular expressions.


00:58:31.900 --> 00:58:34.560
A self type, a lot of type things have been added.


00:58:34.560 --> 00:58:38.220
So we've got the self type, variatric, generics,


00:58:38.220 --> 00:58:40.060
literal strings, which is very interesting.


00:58:40.060 --> 00:58:43.880
Lukas did a talk about that on the release live stream.


00:58:43.880 --> 00:58:46.720
Stuff for type dict and data class transformations.


00:58:46.720 --> 00:58:48.200
So great stuff.


00:58:48.200 --> 00:58:50.960
Now, let's just really quickly round out,


00:58:50.960 --> 00:58:55.240
what's the Python 3.11 story for PyScript, Pyodied?


00:58:55.240 --> 00:58:57.920
Is there, do you have anyone out there know?


00:58:57.920 --> 00:58:59.320
- I don't know, I suppose it works.


00:58:59.320 --> 00:59:01.960
- I think WebAssembly is now a tier two


00:59:01.960 --> 00:59:04.080
or tier three supported platform, right?


00:59:04.080 --> 00:59:05.920
- So he has been making a lot of improvements


00:59:05.920 --> 00:59:08.520
to the build process, which is not easy.


00:59:08.520 --> 00:59:10.680
So kudos to Christian Himes,


00:59:10.680 --> 00:59:12.480
if you're listening, you're great.


00:59:12.480 --> 00:59:16.920
I suppose that PyScript can, through Pyodied,


00:59:16.920 --> 00:59:18.720
Jesus, how many layers is this?


00:59:18.720 --> 00:59:22.560
So, Pylite through this can leverage all these improvements


00:59:22.560 --> 00:59:25.560
because I don't know how the whole layer


00:59:25.560 --> 00:59:29.360
tower thing is working, but Pylite has a bunch of patches


00:59:29.360 --> 00:59:31.160
that you need to modify CPython


00:59:31.160 --> 00:59:33.700
so it builds nicely on WebAssembly platforms.


00:59:33.700 --> 00:59:35.000
I don't know the details on that.


00:59:35.000 --> 00:59:37.400
I just know that some of them are okay-ish,


00:59:37.400 --> 00:59:39.980
some of them are not okay and quite difficult to maintain.


00:59:39.980 --> 00:59:43.380
And Christian Hines has been making a lot of great effort


00:59:43.380 --> 00:59:46.520
to change here and there and put a lot of macros


00:59:46.520 --> 00:59:48.680
and if-else and things like that.


00:59:48.680 --> 00:59:51.280
So CPython kind of builds easier.


00:59:51.280 --> 00:59:54.560
This probably translates that PyLite, I hope,


00:59:54.560 --> 00:59:57.920
kind of can consume this build in an easier way


00:59:57.920 --> 00:59:59.960
with less patches, and I suppose that translates


00:59:59.960 --> 01:00:04.200
into PyScript, like just using the PyLite thing easier.


01:00:04.200 --> 01:00:07.760
But yeah, I don't think that there is a huge amount


01:00:07.760 --> 01:00:09.780
of improvements more than, you know,


01:00:09.780 --> 01:00:11.880
we are working towards official support,


01:00:11.880 --> 01:00:13.640
as Bram was mentioning.


01:00:13.640 --> 01:00:15.800
We have this next year system, it's super cool.


01:00:15.800 --> 01:00:18.080
- That has like a unrelated fun fact.


01:00:18.080 --> 01:00:20.920
Mike Drapu, one of the early developers of it


01:00:20.920 --> 01:00:23.080
is actually managing our team at Microsoft.


01:00:23.080 --> 01:00:26.880
- Oh, it's funny how the circle comes to the background.


01:00:26.880 --> 01:00:27.720
Indeed.


01:00:27.720 --> 01:00:28.880
- How the darn tables.


01:00:28.880 --> 01:00:31.440
- That's right.


01:00:31.440 --> 01:00:35.280
All right, we are out of time, but super exciting.


01:00:35.280 --> 01:00:37.320
I wish we had some champagne and Pablo,


01:00:37.320 --> 01:00:39.840
we didn't even bring hats to celebrate Python 3.11,


01:00:39.840 --> 01:00:42.280
but I know everyone out there is extremely excited.


01:00:42.280 --> 01:00:44.720
- People cannot see, but I have a Python 3.11 T-shirt.


01:00:44.720 --> 01:00:48.060
- Yes, yeah, it's a great new logo for 3.11 and stuff.


01:00:48.060 --> 01:00:50.780
Not for in general, but just for the release, it's awesome.


01:00:50.780 --> 01:00:51.900
All right, before we get out of here,


01:00:51.900 --> 01:00:53.720
let me just ask you one final question


01:00:53.720 --> 01:00:55.340
and then we'll call it a show.


01:00:55.340 --> 01:00:56.700
Notable PyPI package,


01:00:56.700 --> 01:00:58.180
something you want to give a shout out to.


01:00:58.180 --> 01:01:00.460
We'll go top to bottom in the picture here, Pablo.


01:01:00.460 --> 01:01:02.180
- Notable PyPI package.


01:01:02.180 --> 01:01:07.180
Well, I'm going to say memory, use memory.


01:01:07.180 --> 01:01:09.740
The one and only Python memory profiler.


01:01:09.740 --> 01:01:13.020
Solve your problems on production today with memory.


01:01:13.020 --> 01:01:14.500
- That and the underlying errors,


01:01:14.500 --> 01:01:15.340
I think it'd be all good.


01:01:15.340 --> 01:01:16.160
- Exactly, yeah.


01:01:16.160 --> 01:01:17.000
- All right.


01:01:17.000 --> 01:01:17.840
- A combination, eh?


01:01:17.840 --> 01:01:18.660
(laughing)


01:01:18.660 --> 01:01:19.500
- Arit, how are you?


01:01:19.500 --> 01:01:20.960
- Well, I've had some interaction


01:01:20.960 --> 01:01:23.000
with the author of Bytecode recently,


01:01:23.000 --> 01:01:26.040
'cause I was looking at things to do in the testing


01:01:26.040 --> 01:01:28.160
and in the interpreter that are kind of like that.


01:01:28.160 --> 01:01:29.680
So this is a library you can kind of,


01:01:29.680 --> 01:01:31.360
from Python, write Bytecode.


01:01:31.360 --> 01:01:33.880
And it's pretty neat. - Oh, wow.


01:01:33.880 --> 01:01:36.880
- And it's struggling with zero cost exceptions,


01:01:36.880 --> 01:01:38.240
but it's what it is.


01:01:38.240 --> 01:01:41.480
- It's like inline assembly, but for Python.


01:01:41.480 --> 01:01:43.360
- Yeah, it's like from a Python script,


01:01:43.360 --> 01:01:48.200
you can kind of write bit of byte code and get it to, I don't know, do another


01:01:48.200 --> 01:01:49.160
interesting stuff.


01:01:49.160 --> 01:01:49.720
That's awesome.


01:01:49.720 --> 01:01:50.600
Brent, how about you?


01:01:50.600 --> 01:01:54.000
Well, I'm partial towards specialists, but if I had to choose something else, I,


01:01:54.000 --> 01:01:57.840
speaking of speed, I really like the scaling profiler.


01:01:57.840 --> 01:02:01.040
I've been using it a lot of my own projects and it's, it's awesome.


01:02:01.040 --> 01:02:03.400
I don't know how it's memory profiling compares to memory.


01:02:03.400 --> 01:02:07.040
I'm sure memory is better, but scaling is really nice for measuring the


01:02:07.040 --> 01:02:10.840
performance across both Python and C code, which is cool.


01:02:10.840 --> 01:02:11.280
Excellent.


01:02:11.280 --> 01:02:11.920
Mark?


01:02:12.040 --> 01:02:13.600
It's not actually a pipey eye package.


01:02:13.600 --> 01:02:16.440
I was going to say the CIS module, which is like, it was a pretty much


01:02:16.440 --> 01:02:17.960
the most fundamental module going.


01:02:17.960 --> 01:02:20.760
There's all sorts of fun things in there.


01:02:20.760 --> 01:02:23.720
You can change the recursion limit and see you can model it.


01:02:23.720 --> 01:02:26.120
If you're interested in how Python works, it's actually quite a


01:02:26.120 --> 01:02:27.440
sort of fun thing to play with.


01:02:27.440 --> 01:02:27.720
So.


01:02:27.720 --> 01:02:29.800
Thank you all for all the hard work.


01:02:29.800 --> 01:02:32.880
And I know there are many people who did a ton of work as well, who are not.


01:02:32.880 --> 01:02:35.480
On the show here, but you can represent them as well.


01:02:35.480 --> 01:02:37.160
So thanks all for being here.


01:02:37.160 --> 01:02:38.400
Final call to action.


01:02:38.400 --> 01:02:39.840
People want to get started at three 11.


01:02:39.840 --> 01:02:40.640
What do you tell them?


01:02:40.800 --> 01:02:42.900
Is it ready for them to get going?


01:02:42.900 --> 01:02:43.500
What do you think?


01:02:43.500 --> 01:02:44.160
It's awesome.


01:02:44.160 --> 01:02:44.760
It's awesome.


01:02:44.760 --> 01:02:48.960
And also now 3.11 comes with a bunch of wheels for all your packages


01:02:48.960 --> 01:02:53.300
because there has been a lot of good work in the people of, you know,


01:02:53.300 --> 01:02:54.200
third-party libraries.


01:02:54.200 --> 01:02:57.500
And now that, you know, people are using CI build wheel,


01:02:57.500 --> 01:03:01.660
3.11 was released with wheels for NumPy and Pandas and a bunch of other things


01:03:01.660 --> 01:03:05.160
that previously was failing massively because nobody could compile them on


01:03:05.160 --> 01:03:06.460
their crappy laptop.


01:03:06.460 --> 01:03:07.600
But now you don't need that.


01:03:07.600 --> 01:03:09.300
You can just download them and it works.


01:03:09.300 --> 01:03:10.400
So just use 3.11.


01:03:10.400 --> 01:03:11.240
And there is no reason.


01:03:11.240 --> 01:03:11.560
Yeah.


01:03:11.560 --> 01:03:12.640
That's actually just boring.


01:03:12.640 --> 01:03:16.280
That would be a reason if you're boring and you don't want to use 3.11, then don't use it.


01:03:16.280 --> 01:03:17.400
It didn't break anything.


01:03:17.400 --> 01:03:19.680
Not even a package, much less GitHub.


01:03:19.680 --> 01:03:20.680
Right.


01:03:20.680 --> 01:03:22.920
And we need more benchmarks.


01:03:22.920 --> 01:03:24.280
So that's true.


01:03:24.280 --> 01:03:25.160
Yeah, absolutely.


01:03:25.160 --> 01:03:27.240
That's how people can help us make things faster.


01:03:27.240 --> 01:03:28.080
It's more benchmarks.


01:03:28.080 --> 01:03:34.400
So, yeah, we have a, there's a sort of standard Python performance suite, but it's kind of a bunch of toy programs and so on.


01:03:34.400 --> 01:03:38.600
So if you've got something that might make a nice sort of benchmark, you know,


01:03:38.600 --> 01:03:42.520
sort of some self-contained, but sort of realistic program, then yeah, that's no.


01:03:42.520 --> 01:03:43.280
All right, cool.


01:03:43.280 --> 01:03:44.120
Well, thanks again.


01:03:44.120 --> 01:03:44.920
Great work on it.


01:03:44.920 --> 01:03:47.080
Cam gear lock out in the audience says, yay.


01:03:47.080 --> 01:03:47.920
See, I build wheel.


01:03:47.920 --> 01:03:48.880
Yeah, absolutely.


01:03:48.880 --> 01:03:49.520
Great stuff.


01:03:49.520 --> 01:03:51.200
So thanks again, everyone.


01:03:51.200 --> 01:03:54.120
I'm super excited to start using three 11 myself.


01:03:54.120 --> 01:03:55.800
So thank you, Michael, for inviting us.


01:03:55.800 --> 01:03:56.880
Yeah, it's great to have you here.


01:03:56.880 --> 01:03:57.320
Thank you.


01:03:57.320 --> 01:03:57.640
Thank you.


01:03:57.640 --> 01:03:58.000
Bye all.


01:03:58.000 --> 01:04:01.600
I hope you enjoyed this crossover talk Python episode.


01:04:02.080 --> 01:04:06.960
If you did, please consider subscribing to Talk Python to Me if you don't already do so.


01:04:06.960 --> 01:04:10.960
On behalf of myself and Brian Okken, thanks for being part of Python Bytes.


01:04:10.960 --> 01:04:11.920
Bye now.

