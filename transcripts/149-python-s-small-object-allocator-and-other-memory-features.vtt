
00:00:00.000 --> 00:00:05.000
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:05.000 --> 00:00:10.000
This is episode 149, recorded September 18th, 2019.


00:00:10.000 --> 00:00:11.000
I'm Michael Kennedy.


00:00:11.000 --> 00:00:12.000
And I am Brian Okken.


00:00:12.000 --> 00:00:14.000
And this episode is brought to you by Datadog.


00:00:14.000 --> 00:00:16.000
Tell you more about them later.


00:00:16.000 --> 00:00:25.000
Brian, this first item that you have here, it actually sparked some philosophical sort of challenge to my way of seeing the world here.


00:00:25.000 --> 00:00:28.000
So why don't you run it by and I'll tell you about my problem.


00:00:28.000 --> 00:00:29.000
Maybe you can help me through it.


00:00:29.000 --> 00:00:33.840
me through it. I'm curious about this now. Yes. I'm pretty sure we've covered this before,


00:00:33.840 --> 00:00:41.280
but Dropbox is kind of behind a lot of the push to do different type checking or type


00:00:41.280 --> 00:00:47.680
hinting and checking those type hints within Python. The mypy project is, I think, spearheaded


00:00:47.680 --> 00:00:52.380
by Dropbox. Yes. There's an article that they put out called "Our Journey to Type Checking


00:00:52.380 --> 00:00:58.900
4 Million Lines of Python." Wow, 4 million lines. That's a big code base. That's a lot


00:00:58.900 --> 00:01:03.500
of Python. Yeah. I wonder how much of it's interconnected. You know, like you've got


00:01:03.500 --> 00:01:06.900
all these little utilities and nothing actually depends on it directly. Maybe


00:01:06.900 --> 00:01:11.340
they depend on the output. On the other hand, it could be like a super


00:01:11.340 --> 00:01:16.060
complicated sort of monolith thing. It's interesting to think about that much


00:01:16.060 --> 00:01:19.540
code. That is a ton. They're leading a lot of stuff but one of the... I like


00:01:19.540 --> 00:01:24.260
this. So why? I mean that's not free. You don't have a huge code base and move it


00:01:24.260 --> 00:01:27.940
to type checking. You don't get that for free. So there has to be


00:01:27.940 --> 00:01:29.700
benefits to this cost.


00:01:29.700 --> 00:01:31.060
And that's one of the things,


00:01:31.060 --> 00:01:33.460
so this article does talk about their,


00:01:33.460 --> 00:01:35.780
kind of their, does go through some of their story


00:01:35.780 --> 00:01:37.620
of how they did it.


00:01:37.620 --> 00:01:39.700
What I really liked is it covered some of the benefits.


00:01:39.700 --> 00:01:41.900
And this isn't even that surprising.


00:01:41.900 --> 00:01:45.620
It says, "Experience tells us that understanding code


00:01:45.620 --> 00:01:49.300
"becomes the key to maintaining developer productivity,


00:01:49.300 --> 00:01:51.940
"and that grows with a larger code base.


00:01:51.940 --> 00:01:54.140
"So without type of annotation,


00:01:54.140 --> 00:01:56.360
"basic reasoning such as figuring out


00:01:56.360 --> 00:01:58.720
what the valid arguments to a function are,


00:01:58.720 --> 00:02:02.400
or the return types, that's a key one for me,


00:02:02.400 --> 00:02:04.800
becomes kind of a hard problem.


00:02:04.800 --> 00:02:08.920
And just answering those questions quickly, more quickly,


00:02:08.920 --> 00:02:10.280
what does this function return?


00:02:10.280 --> 00:02:11.940
Does it return none sometimes?


00:02:11.940 --> 00:02:13.360
Can it return none?


00:02:13.360 --> 00:02:14.260
Things like that.


00:02:14.260 --> 00:02:16.220
These become more and more of a drain


00:02:16.220 --> 00:02:18.280
as you're looking at a larger code base.


00:02:18.280 --> 00:02:19.480
I mean, it's definitely true.


00:02:19.480 --> 00:02:21.600
You spend more time reading code than writing it.


00:02:21.600 --> 00:02:25.200
So thinking about the types as you're writing it


00:02:25.200 --> 00:02:26.280
and putting those in place,


00:02:26.280 --> 00:02:28.680
especially for interfaces to functions.


00:02:28.680 --> 00:02:30.400
Those are an easy win.


00:02:30.400 --> 00:02:31.280
I like it.


00:02:31.280 --> 00:02:33.000
They talked about some of the other benefits


00:02:33.000 --> 00:02:36.160
that the type checkers actually finding subtle bugs


00:02:36.160 --> 00:02:39.120
that they wouldn't have caught easily without it.


00:02:39.120 --> 00:02:41.000
Refactoring becomes easier.


00:02:41.000 --> 00:02:43.080
And then running the type checking


00:02:43.080 --> 00:02:46.640
is faster than running the suite of unit tests.


00:02:46.640 --> 00:02:48.120
So the feedback can be faster.


00:02:48.120 --> 00:02:51.100
And I didn't think about that aspect of it.


00:02:51.100 --> 00:02:52.200
That's pretty interesting.


00:02:52.200 --> 00:02:55.320
to include type checking as part of like a TDD flow.


00:02:55.320 --> 00:02:57.160
That'd be, I haven't tried that.


00:02:57.160 --> 00:02:58.480
That'd be kind of fun.


00:02:58.480 --> 00:03:02.360
And then one of the things I do know is that the IDEs


00:03:02.360 --> 00:03:06.240
such as Visual Studio Code and PyCharm allow you,


00:03:06.240 --> 00:03:08.800
allow for better completion and static error checking


00:03:08.800 --> 00:03:11.640
and a whole bunch of goodies that you get from the IDEs


00:03:11.640 --> 00:03:14.100
if you have type hints in there.


00:03:14.100 --> 00:03:16.480
But anyway, the other part of the story


00:03:16.480 --> 00:03:19.480
that I think is, they talk about is the improvements


00:03:19.480 --> 00:03:22.420
to mypy to fit their needs.


00:03:22.420 --> 00:03:24.980
And so if you like mypy now,


00:03:24.980 --> 00:03:27.620
it's probably it's because Dropbox needed it


00:03:27.620 --> 00:03:28.460
to be really good.


00:03:28.460 --> 00:03:30.340
So anyway, it's a good article.


00:03:30.340 --> 00:03:33.420
- I'm a big fan of type hinting and stuff.


00:03:33.420 --> 00:03:35.860
I think it, all these things here that you've laid out,


00:03:35.860 --> 00:03:37.820
I definitely think they're all true.


00:03:37.820 --> 00:03:39.900
I would say absolutely the biggest one for me


00:03:39.900 --> 00:03:43.540
is making the IDEs and the editors just better.


00:03:43.540 --> 00:03:44.940
When I get the return value function


00:03:44.940 --> 00:03:46.860
that declares its return type,


00:03:46.860 --> 00:03:50.580
and I hit dot on that variable, boom,


00:03:50.580 --> 00:03:52.640
there's the list of the things that I can do.


00:03:52.640 --> 00:03:54.940
I type one or two characters, it auto-completes,


00:03:54.940 --> 00:03:56.140
I just, you know, just flow.


00:03:56.140 --> 00:03:57.640
And yes, it's in the docs,


00:03:57.640 --> 00:03:59.020
what comes back from some of these things.


00:03:59.020 --> 00:04:00.140
Yes, you can go look them up,


00:04:00.140 --> 00:04:04.060
what arguments or what operations you can do on them.


00:04:04.060 --> 00:04:07.140
But if it's one character or two typing


00:04:07.140 --> 00:04:08.220
and it's just always there,


00:04:08.220 --> 00:04:10.380
it just massively improves what you're doing


00:04:10.380 --> 00:04:11.940
and your confidence and the speed


00:04:11.940 --> 00:04:13.340
and it doesn't take you out of that flow.


00:04:13.340 --> 00:04:15.100
And I really appreciate that aspect of it.


00:04:15.100 --> 00:04:15.940
- One of the things, I mean,


00:04:15.940 --> 00:04:19.820
bracing more and more as things that can return multiple types,


00:04:19.820 --> 00:04:22.180
because we definitely can do that in Python.


00:04:22.180 --> 00:04:25.500
So arguments that can be set to none,


00:04:25.500 --> 00:04:28.180
but are either a none or a Boolean,


00:04:28.180 --> 00:04:31.220
or they can be an a element or a list


00:04:31.220 --> 00:04:33.780
of those types of elements, those sorts of things


00:04:33.780 --> 00:04:36.740
are great, because if they're one of the types most


00:04:36.740 --> 00:04:38.340
of the time, you don't even really


00:04:38.340 --> 00:04:40.700
think about making sure that it works for the other one.


00:04:40.700 --> 00:04:41.700
- For sure.


00:04:41.700 --> 00:04:43.540
So you want to hear my philosophical dilemma?


00:04:43.540 --> 00:04:44.180
- Yeah, I do.


00:04:44.180 --> 00:04:44.820
- All right.


00:04:44.820 --> 00:04:48.980
So in that article, it says something to the effect of,


00:04:48.980 --> 00:04:51.220
mypy is an open source project, and the core team


00:04:51.220 --> 00:04:53.540
is employed by Dropbox.


00:04:53.540 --> 00:04:56.980
One of the people who is doing major work on this project


00:04:56.980 --> 00:04:58.500
is Guido van Rossum.


00:04:58.500 --> 00:05:01.660
I think he did something in Python, like created.


00:05:01.660 --> 00:05:02.580
Things like that.


00:05:02.580 --> 00:05:04.780
He created the language and whatnot.


00:05:04.780 --> 00:05:07.620
And it wasn't until, gosh, I don't know,


00:05:07.620 --> 00:05:10.980
well into the 2010s or something like that,


00:05:10.980 --> 00:05:13.820
till type-hinting became a thing in the language.


00:05:13.820 --> 00:05:17.460
So Python was created, its sort of core essence


00:05:17.460 --> 00:05:21.260
is a language without type declarations, right?


00:05:21.260 --> 00:05:22.780
So here's my philosophical debate.


00:05:22.780 --> 00:05:26.340
Like, would Guido have gone back and said,


00:05:26.340 --> 00:05:30.660
in 1991, actually a little bit of type hints


00:05:30.660 --> 00:05:34.060
should have been how Python originally came into the world?


00:05:34.060 --> 00:05:37.460
Or is this something that you have to go through


00:05:37.460 --> 00:05:39.780
and you're like, oh, it's fine when you have


00:05:39.780 --> 00:05:41.660
a hundred lines of code that don't have


00:05:41.660 --> 00:05:43.200
any type information,


00:05:43.200 --> 00:05:44.800
But if you have 4 million, all of a sudden


00:05:44.800 --> 00:05:46.520
you're in a bad place with 4 million


00:05:46.520 --> 00:05:48.560
and hundreds of people working on it.


00:05:48.560 --> 00:05:51.000
Well, all of a sudden these types now are super valuable


00:05:51.000 --> 00:05:54.040
because here he is working explicitly on this thing


00:05:54.040 --> 00:05:56.340
that he probably decided not to have


00:05:56.340 --> 00:05:57.200
in his original language.


00:05:57.200 --> 00:05:58.440
And there's my dilemma.


00:05:58.440 --> 00:06:00.440
- I think it's the size thing.


00:06:00.440 --> 00:06:02.200
It's helpful for large projects,


00:06:02.200 --> 00:06:04.720
for tiny little things it's not.


00:06:04.720 --> 00:06:06.440
I mean, has it ever bothered you


00:06:06.440 --> 00:06:10.560
that there are no type declarations in Bash scripts?


00:06:10.560 --> 00:06:12.160
- Yeah, not really, I guess.


00:06:12.160 --> 00:06:15.640
I don't do really huge bash applications.


00:06:15.640 --> 00:06:18.280
Yeah, that's probably some form of anti-pattern right there,


00:06:18.280 --> 00:06:19.560
isn't it?


00:06:19.560 --> 00:06:20.360
Yeah, I don't know.


00:06:20.360 --> 00:06:21.860
Maybe it's also the tooling, right?


00:06:21.860 --> 00:06:24.840
The editors do a lot more with that information now.


00:06:24.840 --> 00:06:26.320
It is an interesting question of,


00:06:26.320 --> 00:06:27.960
why didn't it have it to begin with?


00:06:27.960 --> 00:06:30.200
If someone else was working on this, sure, OK,


00:06:30.200 --> 00:06:32.520
these are two philosophies, and they kind of come together


00:06:32.520 --> 00:06:33.880
or don't in different ways.


00:06:33.880 --> 00:06:35.240
But it's the same person, right?


00:06:35.240 --> 00:06:39.040
So that was my thought as I was looking through this article.


00:06:39.040 --> 00:06:39.560
Yeah.


00:06:39.560 --> 00:06:40.080
But cool.


00:06:40.080 --> 00:06:41.360
I'm happy to see them doing it.


00:06:41.360 --> 00:06:44.680
And I like to bring this sort of stuff into my code as well.


00:06:44.680 --> 00:06:45.800
I think it makes it better.


00:06:45.800 --> 00:06:46.280
All right.


00:06:46.280 --> 00:06:47.480
Well, what do you got for us?


00:06:47.480 --> 00:06:51.280
I did mention that we have these editors these days


00:06:51.280 --> 00:06:55.120
that do so much more than they did in 1991.


00:06:55.120 --> 00:06:58.200
And namely, this would be PyCharm and Visual Studio Code.


00:06:58.200 --> 00:06:59.720
Those are the two main ones.


00:06:59.720 --> 00:07:00.800
Obviously, there's others.


00:07:00.800 --> 00:07:03.240
But these are the main ones that are super rich.


00:07:03.240 --> 00:07:05.520
Our friend Miguel Grimberg decided


00:07:05.520 --> 00:07:09.400
he was going to put together a cool video about setting up


00:07:09.400 --> 00:07:13.640
Visual Studio Code to work with a full-fledged Flask application.


00:07:13.640 --> 00:07:15.120
>> Yeah. >> So with PyCharm,


00:07:15.120 --> 00:07:16.360
I think it's pretty straightforward, right?


00:07:16.360 --> 00:07:18.640
PyCharm kind of is what it is.


00:07:18.640 --> 00:07:21.920
It's you go in and you're like, all right, here's the project, I see that.


00:07:21.920 --> 00:07:24.480
Here's how I run stuff, here's how, and like there's,


00:07:24.480 --> 00:07:26.560
it's sort of really clear what you do.


00:07:26.560 --> 00:07:28.840
There's a lot of stuff going on there and it's really busy, but


00:07:28.840 --> 00:07:30.960
it's, you can look at it and see what you're supposed to do.


00:07:30.960 --> 00:07:33.120
With Visual Studio Code, I don't feel that way.


00:07:33.120 --> 00:07:36.760
I look at it and I go like, all right, I know that this thing can be configured and


00:07:36.760 --> 00:07:38.800
adapted to do all this amazing stuff,


00:07:38.800 --> 00:07:42.300
and it gives me no breadcrumbs or hints


00:07:42.300 --> 00:07:44.140
on how to even take that first step.


00:07:44.140 --> 00:07:47.500
I'm like, man, I know this thing's cool, probably,


00:07:47.500 --> 00:07:50.360
but I'm just gonna edit this file and go on, right?


00:07:50.360 --> 00:07:55.360
But this is a video that also has a blog post version


00:07:55.360 --> 00:07:58.540
from Miguel, and it's actually a follow-up


00:07:58.540 --> 00:08:01.020
to doing the same thing in PyCharm about a year ago.


00:08:01.020 --> 00:08:02.540
And I think the reason he did it in PyCharm,


00:08:02.540 --> 00:08:04.020
even though I just told you how easy it was,


00:08:04.020 --> 00:08:05.960
is he's doing it in PyCharm Community,


00:08:05.960 --> 00:08:09.960
which is not officially able to support web development.


00:08:09.960 --> 00:08:11.240
It's the free version.


00:08:11.240 --> 00:08:13.480
So he's like, how do you set up a web development project


00:08:13.480 --> 00:08:15.020
in a thing that's not meant for that


00:08:15.020 --> 00:08:17.880
or officially configured for that or whatever?


00:08:17.880 --> 00:08:19.060
Anyway, so it goes through


00:08:19.060 --> 00:08:20.720
and it sort of walks you through all the steps.


00:08:20.720 --> 00:08:21.560
And you know what?


00:08:21.560 --> 00:08:22.400
It's really nice.


00:08:22.400 --> 00:08:24.000
And I think that the grand finale,


00:08:24.000 --> 00:08:25.280
you will appreciate here, Brian.


00:08:25.280 --> 00:08:27.520
So as I think a lot of people do,


00:08:27.520 --> 00:08:28.480
so all right, here's what we're gonna do.


00:08:28.480 --> 00:08:30.720
We're gonna go set up, we're gonna clone the repo,


00:08:30.720 --> 00:08:31.800
we'll create a virtual environment,


00:08:31.800 --> 00:08:34.840
we're gonna install the requirements


00:08:34.840 --> 00:08:37.960
and sort of configure environment variables,


00:08:37.960 --> 00:08:40.780
maybe run some custom Flask commands like Flask deploy,


00:08:40.780 --> 00:08:43.280
which initializes the database


00:08:43.280 --> 00:08:46.300
or does database migrations and all that kind of stuff


00:08:46.300 --> 00:08:48.560
in the terminal before we actually get to the editor.


00:08:48.560 --> 00:08:49.980
And this is how I work as well.


00:08:49.980 --> 00:08:50.820
How about you?


00:08:50.820 --> 00:08:52.320
Do you like start from within PyCharm


00:08:52.320 --> 00:08:53.680
or do you kind of get to it eventually?


00:08:53.680 --> 00:08:55.480
- Oh no, I, same thing.


00:08:55.480 --> 00:08:59.040
I'm setting up, well, I've got a little extra little hooks


00:08:59.040 --> 00:09:01.880
to create an environment and activate an environment


00:09:01.880 --> 00:09:03.640
'cause I'm doing that on the command line


00:09:03.640 --> 00:09:05.060
all the time anyway.


00:09:05.060 --> 00:09:07.080
Like if I'm gonna clone a repo and stuff,


00:09:07.080 --> 00:09:08.680
I'm just gonna do that, so.


00:09:08.680 --> 00:09:11.440
- Same, and I have all these aliases and stuff


00:09:11.440 --> 00:09:13.400
that will do multiple steps at once


00:09:13.400 --> 00:09:14.800
and make it a little bit nicer and so on.


00:09:14.800 --> 00:09:16.880
All right, so all that is in Terminal,


00:09:16.880 --> 00:09:17.720
but then he says, all right,


00:09:17.720 --> 00:09:18.600
here's what we're gonna do in VS Code.


00:09:18.600 --> 00:09:19.680
You're gonna open the folder,


00:09:19.680 --> 00:09:21.280
which is a thing you could do in VS Code,


00:09:21.280 --> 00:09:25.520
and it will automatically find the virtual environment.


00:09:25.520 --> 00:09:26.960
But in order for all that stuff to happen,


00:09:26.960 --> 00:09:30.240
you have to encourage Visual Studio Code


00:09:30.240 --> 00:09:33.300
to go into Python mode, so just open any Python file,


00:09:33.300 --> 00:09:36.140
And that activates all the little subsystems


00:09:36.140 --> 00:09:38.660
that fire up, like the environment variable detection


00:09:38.660 --> 00:09:40.900
and all that kind of stuff, the virtual environment


00:09:40.900 --> 00:09:42.340
detection and so on.


00:09:42.340 --> 00:09:44.420
And then, it says, all right, now what we want to do


00:09:44.420 --> 00:09:45.820
is how do you run the thing?


00:09:45.820 --> 00:09:49.340
So he talks about how to set up a run configuration


00:09:49.340 --> 00:09:50.300
in the debugger.


00:09:50.300 --> 00:09:53.180
So you open the Debugger tab, add a configuration.


00:09:53.180 --> 00:09:55.060
And you can actually pick Flask.


00:09:55.060 --> 00:09:56.300
And it knows all about Flask.


00:09:56.300 --> 00:09:57.720
It asks you a couple of questions,


00:09:57.720 --> 00:10:01.340
like, well, what's the app PY called, and things like that.


00:10:01.340 --> 00:10:03.340
but then it'll set it all up.


00:10:03.340 --> 00:10:05.500
And then you can run it in the debugger or run it without,


00:10:05.500 --> 00:10:06.500
and that's pretty nice.


00:10:06.500 --> 00:10:08.140
And then it says, finally, there's


00:10:08.140 --> 00:10:11.580
another thing about this UI that, like I said,


00:10:11.580 --> 00:10:12.880
it's kind of like water, right?


00:10:12.880 --> 00:10:15.300
It can be whatever you want, but you don't look at water


00:10:15.300 --> 00:10:18.540
and go, I bet that could be a sculpture of a seal


00:10:18.540 --> 00:10:21.260
if I froze it and carved it down, right?


00:10:21.260 --> 00:10:21.760
So--


00:10:21.760 --> 00:10:22.660
- That's our example.


00:10:22.660 --> 00:10:23.740
But yeah, sure, go on.


00:10:23.740 --> 00:10:26.060
- Yeah, right, like, OK, ice sculptures.


00:10:26.060 --> 00:10:28.380
So there's another command you can run in VS Code.


00:10:28.380 --> 00:10:29.880
And this I didn't know about is you


00:10:29.880 --> 00:10:32.160
ask it to discover Python tests.


00:10:32.160 --> 00:10:33.000
- That's nice.


00:10:33.000 --> 00:10:34.760
- Yeah, so you can say discover Python tests


00:10:34.760 --> 00:10:37.040
and it'll hunt through and find all the tests


00:10:37.040 --> 00:10:38.840
in your project and it'll even offer


00:10:38.840 --> 00:10:40.320
the what test framework do you wanna run?


00:10:40.320 --> 00:10:43.280
You wanna run unit test or PyCharm or whatever


00:10:43.280 --> 00:10:46.720
and then once you do that, like a new UI element


00:10:46.720 --> 00:10:48.640
sort of pops up and now you can run your tests


00:10:48.640 --> 00:10:49.480
in a pretty cool runner.


00:10:49.480 --> 00:10:51.680
So it's about a half hour video.


00:10:51.680 --> 00:10:54.080
It's good, I think, and there's something really nice


00:10:54.080 --> 00:10:55.800
about seeing it in action.


00:10:55.800 --> 00:10:58.380
I'm a big fan of learning through video stuff


00:10:58.380 --> 00:11:00.940
as people might imagine, since I put some time and energy


00:11:00.940 --> 00:11:01.460
into it.


00:11:01.460 --> 00:11:02.900
But it's one thing to read it.


00:11:02.900 --> 00:11:06.180
It's another to see just that sort of process


00:11:06.180 --> 00:11:08.380
gone through and explain step by step.


00:11:08.380 --> 00:11:10.580
And Miguel does a good job, and I like it.


00:11:10.580 --> 00:11:14.460
At the end, he also talks about a limitation


00:11:14.460 --> 00:11:19.220
of handling crashing Flask applications with a debugger.


00:11:19.220 --> 00:11:22.260
And he says it's a Flask thing, not a VS Code thing.


00:11:22.260 --> 00:11:25.020
So you have to do it in both PyCharm and VS Code.


00:11:25.020 --> 00:11:26.660
But he shows you the little workaround.


00:11:26.660 --> 00:11:28.660
- Yeah, basically you have to stop going


00:11:28.660 --> 00:11:33.340
through the Flask run option and go to the flask.py


00:11:33.340 --> 00:11:37.100
or app.py, run it, and then override some settings


00:11:37.100 --> 00:11:38.180
in the run there.


00:11:38.180 --> 00:11:39.020
So yeah, it's pretty straightforward,


00:11:39.020 --> 00:11:40.340
but that's definitely a nice touch as well.


00:11:40.340 --> 00:11:42.180
- Yeah, and then the other thing I wanted to touch on


00:11:42.180 --> 00:11:45.580
is when he's showing how to run tests in the video,


00:11:45.580 --> 00:11:48.140
they're just sort of magically running in the background


00:11:48.140 --> 00:11:50.220
and you don't see what they're doing.


00:11:50.220 --> 00:11:54.220
And he doesn't cover this, but at the bottom of the screen


00:11:54.220 --> 00:11:56.580
or at the bottom of your VS Code window,


00:11:56.580 --> 00:11:59.580
There's some icons that show you the status of the tests.


00:11:59.580 --> 00:12:01.260
And if you click on that, you can go--


00:12:01.260 --> 00:12:02.740
that's where you go look at the output


00:12:02.740 --> 00:12:04.340
and look at the failures and whatever.


00:12:04.340 --> 00:12:05.020
Yeah, very cool.


00:12:05.020 --> 00:12:05.700
Nice.


00:12:05.700 --> 00:12:06.580
So that's a good one.


00:12:06.580 --> 00:12:10.300
Another thing that I am a big fan of is parallel programming.


00:12:10.300 --> 00:12:12.780
And you've got a few things on that one for us, huh?


00:12:12.780 --> 00:12:15.700
There's an article called "Multiprocessing


00:12:15.700 --> 00:12:17.060
versus Threading in Python--


00:12:17.060 --> 00:12:20.180
What Every Data Scientist Needs to Know."


00:12:20.180 --> 00:12:22.940
It talked about multiprocessing and threading.


00:12:22.940 --> 00:12:25.320
It did not talk about async.


00:12:25.320 --> 00:12:27.560
And I don't know if that's appropriate or not


00:12:27.560 --> 00:12:30.640
with if async's even something that you can,


00:12:30.640 --> 00:12:33.000
would be useful for data science or not.


00:12:33.000 --> 00:12:34.920
- Sometimes, not computationally though.


00:12:34.920 --> 00:12:37.640
- In any case, I liked it because a lot of people


00:12:37.640 --> 00:12:39.440
from data science are coming into program,


00:12:39.440 --> 00:12:42.160
like we know, they're coming in not as programmers,


00:12:42.160 --> 00:12:44.040
they're coming in from other fields.


00:12:44.040 --> 00:12:47.760
So there's a lot of background computer science knowledge


00:12:47.760 --> 00:12:50.100
that they just don't have, or you know,


00:12:50.100 --> 00:12:51.040
there might be gaps.


00:12:51.040 --> 00:12:52.680
So that's one of the reasons why I picked this


00:12:52.680 --> 00:12:53.900
because I like it.


00:12:53.900 --> 00:12:57.460
I like that it talked about some of the basic concepts


00:12:57.460 --> 00:12:59.740
of parallelism, parallel computing,


00:12:59.740 --> 00:13:02.340
how to think about it, has some diagrams,


00:13:02.340 --> 00:13:05.020
and then what the difference between multiprocessing


00:13:05.020 --> 00:13:08.860
and threading is in general, specifically multi,


00:13:08.860 --> 00:13:11.660
or threading is within one process.


00:13:11.660 --> 00:13:14.020
You've got a bunch of stuff going on.


00:13:14.020 --> 00:13:16.660
And multiprocessing is you get a bunch of processes,


00:13:16.660 --> 00:13:18.020
but there's trade-offs.


00:13:18.020 --> 00:13:20.520
And then it also talks about specifically


00:13:20.520 --> 00:13:24.240
that Python has a GIL, so it's a little different.


00:13:24.240 --> 00:13:25.680
But because of the GIL,


00:13:25.680 --> 00:13:28.120
so it talks about that threads wait on,


00:13:28.120 --> 00:13:30.960
you can use either one, but in general,


00:13:30.960 --> 00:13:33.480
the general rule of thumb is CPU intensive work,


00:13:33.480 --> 00:13:36.080
you need multiprocessing.


00:13:36.080 --> 00:13:39.520
If you're IO bound or waiting on users,


00:13:39.520 --> 00:13:42.400
then threads are fine for that.


00:13:42.400 --> 00:13:45.680
So the surprising bit to me was the charts


00:13:45.680 --> 00:13:47.880
and some of the graphs that he has,


00:13:47.880 --> 00:13:52.880
because he sort of does some benchmarks of code


00:13:52.880 --> 00:13:56.160
running something on like both CPU intensive


00:13:56.160 --> 00:13:59.680
and IO intensive work and how it speeds up


00:13:59.680 --> 00:14:02.460
with multi-processing, multi-threading.


00:14:02.460 --> 00:14:05.760
Obviously throwing more processors at it


00:14:05.760 --> 00:14:09.400
and it helps or more threads.


00:14:09.400 --> 00:14:11.320
But what surprised me is that the difference


00:14:11.320 --> 00:14:13.960
between the two wasn't really that great.


00:14:13.960 --> 00:14:15.800
I thought it would be more pronounced.


00:14:15.800 --> 00:14:19.560
Basically, if you're not sure which one to use, pick one,


00:14:19.560 --> 00:14:21.920
and it'll speed up your code.


00:14:21.920 --> 00:14:22.840
- Interesting, yeah.


00:14:22.840 --> 00:14:24.160
- I kind of thought it would be,


00:14:24.160 --> 00:14:26.320
even with CPU intensive stuff,


00:14:26.320 --> 00:14:28.800
at least with stuff he was showing,


00:14:28.800 --> 00:14:31.800
that even multi-threading helped speed things up.


00:14:31.800 --> 00:14:33.360
So I think this is good.


00:14:33.360 --> 00:14:35.000
And then he goes through a couple data,


00:14:35.000 --> 00:14:37.600
specifically data science examples,


00:14:37.600 --> 00:14:40.880
and shows the code and how to throw multi-processing


00:14:40.880 --> 00:14:42.840
and multi-threading at data science problems.


00:14:42.840 --> 00:14:44.000
- That sounds super useful.


00:14:44.000 --> 00:14:45.800
The comparisons are interesting.


00:14:45.800 --> 00:14:50.280
These benchmarks are always so full of landmines


00:14:50.280 --> 00:14:51.520
and special cases.


00:14:51.520 --> 00:14:52.960
And I didn't use it that way, so I


00:14:52.960 --> 00:14:54.880
didn't get the right results that you said.


00:14:54.880 --> 00:14:57.260
You know, like, they're just so tricky to get them right.


00:14:57.260 --> 00:14:58.840
But it is cool to have them here.


00:14:58.840 --> 00:15:00.080
I like that a lot.


00:15:00.080 --> 00:15:02.000
One thing I would like to throw out there is, you know,


00:15:02.000 --> 00:15:03.500
a lot of times you have these sort of,


00:15:03.500 --> 00:15:05.840
I could do it this way, or I could do it that way,


00:15:05.840 --> 00:15:06.920
and we'll see what we get.


00:15:06.920 --> 00:15:09.160
And then sometimes it's this, sometimes it's that.


00:15:09.160 --> 00:15:11.880
So now you've got to know two APIs and how you combine them.


00:15:11.880 --> 00:15:17.880
And I'm a big fan of the unsync, U-N-S-Y-N-C, library,


00:15:17.880 --> 00:15:20.640
which takes the async programming model


00:15:20.640 --> 00:15:22.080
and applies it to multiprocessing,


00:15:22.080 --> 00:15:25.880
to threads, and async methods, and makes it all nice


00:15:25.880 --> 00:15:27.760
and clean, just a couple of decorators,


00:15:27.760 --> 00:15:28.840
and they're all the same.


00:15:28.840 --> 00:15:30.080
So do you still have to pick?


00:15:30.080 --> 00:15:33.000
You have to pick at the implementation level.


00:15:33.000 --> 00:15:34.520
So imagine you have three functions.


00:15:34.520 --> 00:15:37.040
One of them is async, because it actually


00:15:37.040 --> 00:15:38.720
implements async await it uses them.


00:15:38.720 --> 00:15:40.780
One is just a regular function you'd


00:15:40.780 --> 00:15:43.580
like to run on a thread, one is a regular function--


00:15:43.580 --> 00:15:45.940
sorry, one is a function that does computational stuff,


00:15:45.940 --> 00:15:47.440
and one does a weighting.


00:15:47.440 --> 00:15:48.560
So you just put a decorator.


00:15:48.560 --> 00:15:51.500
You say @unsync on the regular async one.


00:15:51.500 --> 00:15:54.680
That will run on async I/O. On the one that's


00:15:54.680 --> 00:15:56.720
doing weighting stuff, it would work for threads.


00:15:56.720 --> 00:15:59.220
You just say @unsync, and it automatically runs on threads


00:15:59.220 --> 00:16:01.300
if it's not an async method.


00:16:01.300 --> 00:16:05.620
In the last one, you would say @unsync CPU bound equals true.


00:16:05.620 --> 00:16:09.780
But then once you consume those, the way you program against it,


00:16:09.780 --> 00:16:12.860
they're all the same, regardless of which style it is.


00:16:12.860 --> 00:16:14.600
So it's like when you define the function,


00:16:14.600 --> 00:16:15.780
oh, this is a CPU bound one.


00:16:15.780 --> 00:16:17.380
Oh, this one is actually async.


00:16:17.380 --> 00:16:19.180
So it just is async.


00:16:19.180 --> 00:16:19.900
And it just adapts.


00:16:19.900 --> 00:16:21.940
It's a pretty cool library.


00:16:21.940 --> 00:16:25.580
It's 126 lines of Python in one file.


00:16:25.580 --> 00:16:27.660
And it does all that to unify all these APIs.


00:16:27.660 --> 00:16:28.180
It's great.


00:16:28.180 --> 00:16:28.700
- Wow, that's cool.


00:16:28.700 --> 00:16:29.420
- Yeah, so pretty cool.


00:16:29.420 --> 00:16:32.140
Anyway, yeah, this is really nice and certainly something


00:16:32.140 --> 00:16:33.740
people want to think about.


00:16:33.740 --> 00:16:35.500
It's a little bit tricky.


00:16:35.500 --> 00:16:38.820
We'll see if this is still a discussion in a couple years.


00:16:38.820 --> 00:16:42.980
In Python 3.9, there's talk of maybe using sub-interpreters


00:16:42.980 --> 00:16:44.660
to remove the limitation of the GIL


00:16:44.660 --> 00:16:47.740
inside a single processes and all sorts of stuff.


00:16:47.740 --> 00:16:48.900
Aaron Snow's working on that.


00:16:48.900 --> 00:16:51.540
So if they actually got that working,


00:16:51.540 --> 00:16:53.260
then you'd probably be better


00:16:53.260 --> 00:16:55.980
'cause you can share data better, more richly,


00:16:55.980 --> 00:16:58.220
and faster within a single process.


00:16:58.220 --> 00:17:01.980
And it's about to get even more crazy.


00:17:01.980 --> 00:17:03.300
- That's a long discussion.


00:17:03.300 --> 00:17:07.020
How much more do you have to care about


00:17:07.020 --> 00:17:08.660
blocking and stuff like that?


00:17:08.660 --> 00:17:11.060
Yeah, it brings all that stuff back in because you


00:17:11.060 --> 00:17:12.260
don't have the GIL anymore.


00:17:12.260 --> 00:17:13.980
Actually, with the sub-interpreters,


00:17:13.980 --> 00:17:15.340
they're talking about a mechanism


00:17:15.340 --> 00:17:18.220
to explicitly share data in a safe way between them.


00:17:18.220 --> 00:17:20.180
So still, it's faster, though.


00:17:20.180 --> 00:17:20.660
OK.


00:17:20.660 --> 00:17:21.160
Cool.


00:17:21.160 --> 00:17:23.420
Well, speaking of making things faster,


00:17:23.420 --> 00:17:25.620
if you're looking at your app and you


00:17:25.620 --> 00:17:27.260
wonder what's going on, it would be


00:17:27.260 --> 00:17:31.060
nice to see everything that's going on across all the layers,


00:17:31.060 --> 00:17:34.620
across the database, across the web tier, things like that.


00:17:34.620 --> 00:17:35.940
So you should check out Datadog.


00:17:35.940 --> 00:17:37.260
They're sponsoring this episode.


00:17:37.260 --> 00:17:40.820
It's a modern cloud scale monitoring platform


00:17:40.820 --> 00:17:44.020
that brings together metrics and logs and distributed traces


00:17:44.020 --> 00:17:44.880
all in one place.


00:17:44.880 --> 00:17:49.080
So it auto-instruments things like Django and Flask


00:17:49.080 --> 00:17:51.300
and Postgres, means you get to see everything


00:17:51.300 --> 00:17:52.900
across all those boundaries.


00:17:52.900 --> 00:17:54.780
And it helps you optimize your Python apps


00:17:54.780 --> 00:17:55.780
in just a few minutes.


00:17:55.780 --> 00:17:57.540
Start monitoring your environment for free


00:17:57.540 --> 00:17:59.420
and get a sweet Datadog t-shirt.


00:17:59.420 --> 00:18:02.380
Just visit pythonbytes.fm/datadog to get started.


00:18:02.380 --> 00:18:02.880
- Nice.


00:18:02.880 --> 00:18:07.600
Well, not to be outdone by your async stuff.


00:18:07.600 --> 00:18:10.240
I also chose some async stuff here.


00:18:10.240 --> 00:18:13.840
So remember, we talked about Starlette a little while ago.


00:18:13.840 --> 00:18:16.840
And Starlette comes from this GitHub organization


00:18:16.840 --> 00:18:19.360
called Encode, E-N-C-O-D.


00:18:19.360 --> 00:18:21.840
And that place is full of magic.


00:18:21.840 --> 00:18:25.760
So they have uvicorn, which is the ASGI server.


00:18:25.760 --> 00:18:27.320
That's pretty awesome, like g-unicorn,


00:18:27.320 --> 00:18:32.320
but for async based on the uv event loop,


00:18:32.320 --> 00:18:34.160
UV loop, event loop, and so on.


00:18:34.160 --> 00:18:36.160
And there's Starlet, there's also Django REST framework,


00:18:36.160 --> 00:18:39.320
but there's HTTPS, which we talked about last time.


00:18:39.320 --> 00:18:41.280
And the last thing I wanna just cover


00:18:41.280 --> 00:18:42.960
is a few more things in here, 'cause like I said,


00:18:42.960 --> 00:18:44.080
there's a lot of great stuff.


00:18:44.080 --> 00:18:48.360
Is there's a project just simply called ORM, right?


00:18:48.360 --> 00:18:50.840
We've got SQLAlchemy and Django ORM,


00:18:50.840 --> 00:18:52.680
and these guys just said, you know what,


00:18:52.680 --> 00:18:55.580
we'll just, the term ORM is just free in Python,


00:18:55.580 --> 00:18:56.580
so let's just do that.


00:18:56.580 --> 00:18:57.640
(laughing)


00:18:57.640 --> 00:19:00.000
Which is an async ORM.


00:19:00.000 --> 00:19:02.480
And they also have a thing called databases,


00:19:02.480 --> 00:19:05.960
which adds async support for talking


00:19:05.960 --> 00:19:09.840
to all these different databases, Postgres and whatnot.


00:19:09.840 --> 00:19:13.360
So this is a really cool project, especially this ORM one,


00:19:13.360 --> 00:19:16.560
because it's kind of like SQLAlchemy,


00:19:16.560 --> 00:19:19.320
and it's actually based on the SQLAlchemy core


00:19:19.320 --> 00:19:21.320
for building queries.


00:19:21.320 --> 00:19:23.160
And that gives you a bunch of benefits, right?


00:19:23.160 --> 00:19:24.780
That means if you already have some stuff


00:19:24.780 --> 00:19:26.000
that works with SQLAlchemy,


00:19:26.000 --> 00:19:28.200
to some degree it will be similar.


00:19:28.200 --> 00:19:34.360
It means that Alembic, which is the tool to do database migrations on SQLAlchemy,


00:19:34.360 --> 00:19:36.280
also works with this ORM.


00:19:36.280 --> 00:19:38.800
So you can automatically just apply Alembic to it.


00:19:38.800 --> 00:19:39.560
And that's pretty cool.


00:19:39.560 --> 00:19:39.960
Wow.


00:19:39.960 --> 00:19:45.040
Yeah, it uses this database project that I talked about for cross-database async


00:19:45.040 --> 00:19:45.680
support.


00:19:45.680 --> 00:19:49.380
And it also has this thing called TypeSystem for data validation, which


00:19:49.380 --> 00:19:49.960
is pretty cool.


00:19:49.960 --> 00:19:51.560
I hadn't heard of that either.


00:19:51.560 --> 00:19:55.960
But yeah, it's a really sweet async API


00:19:55.960 --> 00:19:59.000
for working with databases and ORMs.


00:19:59.000 --> 00:20:00.520
So the way you create the models,


00:20:00.520 --> 00:20:01.920
it's very similar to SQLAlchemy.


00:20:01.920 --> 00:20:04.200
It's not identical, but it's similar.


00:20:04.200 --> 00:20:07.080
And then from there on, you just work with it


00:20:07.080 --> 00:20:10.680
kind of like you would do normal ORM stuff, right?


00:20:10.680 --> 00:20:13.000
Like I would say, if I'm working on an album,


00:20:13.000 --> 00:20:16.360
I might say album.objects.create.


00:20:16.360 --> 00:20:19.440
Or maybe I would do some kind of filter.


00:20:19.440 --> 00:20:23.120
So I'd say track.objects.filter, and I would do something.


00:20:23.120 --> 00:20:25.480
But every one of these operations is async,


00:20:25.480 --> 00:20:27.280
so you just put a weight in front of it.


00:20:27.280 --> 00:20:29.760
And if you have something you've got to scale,


00:20:29.760 --> 00:20:34.280
a whole lot of concurrent data traffic, like say a website,


00:20:34.280 --> 00:20:36.120
well, this is a pretty good combo.


00:20:36.120 --> 00:20:37.120
- Okay.


00:20:37.120 --> 00:20:39.680
So like in the future, will we just have a weight


00:20:39.680 --> 00:20:41.720
in front of every other word?


00:20:41.720 --> 00:20:43.080
- Everything, exactly.


00:20:43.080 --> 00:20:44.960
So I was gonna point out that you've gotta be


00:20:44.960 --> 00:20:47.520
pretty async and await savvy to be doing that.


00:20:47.520 --> 00:20:50.880
Like there's a lot of waiting, isn't there?


00:20:50.880 --> 00:20:52.060
(laughing)


00:20:52.060 --> 00:20:52.900
- Yeah.


00:20:52.900 --> 00:20:53.720
- I think if you want to work with this library,


00:20:53.720 --> 00:20:57.320
you just have to say, we're just going all in on async.


00:20:57.320 --> 00:20:58.380
And that's the way it goes, right?


00:20:58.380 --> 00:20:59.220
- No, it's good.


00:20:59.220 --> 00:21:00.440
If you're already working with async,


00:21:00.440 --> 00:21:01.840
that's when you would think,


00:21:01.840 --> 00:21:05.040
hey, I wonder if there's an async ORM that I can use.


00:21:05.040 --> 00:21:06.260
- Yeah, yeah, it looks good.


00:21:06.260 --> 00:21:08.260
And I like that it's based on SQLAlchemy core.


00:21:08.260 --> 00:21:13.260
That means a big chunk of like the database conversation


00:21:13.260 --> 00:21:17.080
and say the table creation and the migrations,


00:21:17.080 --> 00:21:19.400
All that stuff is already known and proven


00:21:19.400 --> 00:21:20.460
and working really well.


00:21:20.460 --> 00:21:24.880
It's just this API kind of around the side


00:21:24.880 --> 00:21:27.840
of the traditional SQLAlchemy conversation,


00:21:27.840 --> 00:21:29.440
like directly with the database.


00:21:29.440 --> 00:21:32.680
I do wish that SQLAlchemy would take this approach.


00:21:32.680 --> 00:21:34.840
I interviewed Mike Bader about it a long time ago,


00:21:34.840 --> 00:21:37.160
and like four years ago, he said,


00:21:37.160 --> 00:21:39.360
I don't really think it's gonna make that big of a difference,


00:21:39.360 --> 00:21:42.960
but I think it actually would make a huge difference.


00:21:42.960 --> 00:21:45.520
You just gotta think about what is your goal, right?


00:21:45.520 --> 00:21:46.700
If your goal is performance,


00:21:46.700 --> 00:21:48.100
it probably won't make a big difference.


00:21:48.100 --> 00:21:49.980
If your goal is scalability,


00:21:49.980 --> 00:21:53.100
it can make a tremendous difference, right?


00:21:53.100 --> 00:21:56.020
Are you trying to make an individual user's experience


00:21:56.020 --> 00:21:59.060
a little bit faster, or are you trying to make


00:21:59.060 --> 00:22:02.460
the website not take 10 concurrent users, but 10,000?


00:22:02.460 --> 00:22:04.500
Right, like, it probably might even make it


00:22:04.500 --> 00:22:06.100
a tiny bit slower for that one person,


00:22:06.100 --> 00:22:09.740
but it might make that 10 to 10,000 like no big deal.


00:22:09.740 --> 00:22:11.620
So, it depends on what you're after, right?


00:22:11.620 --> 00:22:12.460
- Yeah, definitely.


00:22:12.460 --> 00:22:14.580
- Speaking of what you're after, what's next for us?


00:22:14.580 --> 00:22:15.760
- One of the things you might be after


00:22:15.760 --> 00:22:19.560
is some data on somebody else's website, like through an API.


00:22:19.560 --> 00:22:20.400
- Yes.


00:22:20.400 --> 00:22:21.840
- There's more and more people, and I think it's great


00:22:21.840 --> 00:22:24.120
kind of doing the data science stuff of people coming


00:22:24.120 --> 00:22:27.100
into Python and programming from just trying


00:22:27.100 --> 00:22:28.940
to get their work done.


00:22:28.940 --> 00:22:33.240
And this is a dataquest.io blog post


00:22:33.240 --> 00:22:35.720
called Getting Started with APIs.


00:22:35.720 --> 00:22:38.120
And it's not getting started writing APIs,


00:22:38.120 --> 00:22:41.760
it's getting started consuming them with Python.


00:22:41.760 --> 00:22:44.200
If you've kind of know what all this stuff is,


00:22:44.200 --> 00:22:46.380
but you haven't really thought about the basics.


00:22:46.380 --> 00:22:48.200
That's why I picked up this post


00:22:48.200 --> 00:22:50.680
is because it's really good with the basics.


00:22:50.680 --> 00:22:54.420
Has a conceptual introduction of what a web APIs are


00:22:54.420 --> 00:22:56.340
versus what a website is,


00:22:56.340 --> 00:22:58.560
kind of what the differences are.


00:22:58.560 --> 00:23:01.240
And why, I mean, why also,


00:23:01.240 --> 00:23:03.160
why have APIs if you can just have,


00:23:03.160 --> 00:23:05.200
people could just store the data in CSV files,


00:23:05.200 --> 00:23:06.720
that'd be easier, wouldn't it?


00:23:06.720 --> 00:23:09.320
- That'd be amazing, I'd love to live in that world.


00:23:09.320 --> 00:23:10.160
No.


00:23:10.160 --> 00:23:13.580
- No, but there are a lot of data sets out there


00:23:13.580 --> 00:23:17.340
that are just CSV files sitting around.


00:23:17.340 --> 00:23:18.820
- It depends if it's dynamic, right?


00:23:18.820 --> 00:23:21.460
- Right, dynamic and also if you want to specify it.


00:23:21.460 --> 00:23:25.860
So with APIs you can have parameters to your queries


00:23:25.860 --> 00:23:28.820
to say I only want the data for this user


00:23:28.820 --> 00:23:33.740
or they gave an example of Spotify music or something.


00:23:33.740 --> 00:23:35.980
You don't want to have all the data


00:23:35.980 --> 00:23:38.180
for all the songs that Spotify knows about


00:23:38.180 --> 00:23:41.260
but maybe just the songs from a particular artist


00:23:41.260 --> 00:23:42.320
or something.


00:23:42.320 --> 00:23:44.300
So things like that are good,


00:23:44.300 --> 00:23:46.980
but this is actually the first time I've seen this


00:23:46.980 --> 00:23:48.280
and they're probably all over the place,


00:23:48.280 --> 00:23:51.860
but talked about status codes, especially get status codes,


00:23:51.860 --> 00:23:55.380
because that's what we're doing here is retrieving things.


00:23:55.380 --> 00:23:58.500
And it had a nice list of all the descriptions


00:23:58.500 --> 00:24:01.500
and things that you might run into for error codes,


00:24:01.500 --> 00:24:05.740
including like the 301, which isn't necessarily a problem,


00:24:05.740 --> 00:24:06.980
but you're getting redirected.


00:24:06.980 --> 00:24:09.000
So maybe you want to know about that.


00:24:09.860 --> 00:24:14.100
And then the 400 is something's not wrong on their end,


00:24:14.100 --> 00:24:16.340
it's wrong on your end.


00:24:16.340 --> 00:24:19.060
The server thinks you made a bad request.


00:24:19.060 --> 00:24:22.300
So that might be an endpoint that expects data,


00:24:22.300 --> 00:24:24.860
or parameters, but you didn't send any parameters with it.


00:24:24.860 --> 00:24:27.660
- Or you sent an int when it expected a string, or whatever.


00:24:27.660 --> 00:24:29.460
- And then it talks about endpoints,


00:24:29.460 --> 00:24:31.380
and endpoints that take query parameters,


00:24:31.380 --> 00:24:35.140
endpoints being the specific API.


00:24:35.140 --> 00:24:38.420
So we think of a service providing an API,


00:24:38.420 --> 00:24:40.700
but it's usually not just one API.


00:24:40.700 --> 00:24:44.820
It's usually a whole bunch of related different bits of data


00:24:44.820 --> 00:24:48.500
that you can query together or query separately


00:24:48.500 --> 00:24:50.220
for different aspects of it.


00:24:50.220 --> 00:24:53.900
And then of course, what APIs usually return is JSON data.


00:24:53.900 --> 00:24:56.040
So it has a little bit of an explanation


00:24:56.040 --> 00:24:57.700
for what JSON looks like.


00:24:57.700 --> 00:25:01.380
And then using the JSON module to convert back and forth


00:25:01.380 --> 00:25:04.980
between native Python stuff and JSON.


00:25:04.980 --> 00:25:06.420
And it also talks about requests


00:25:06.420 --> 00:25:08.380
and a bunch of examples for how to pull this.


00:25:08.380 --> 00:25:11.700
So if you're getting started trying to pull some data


00:25:11.700 --> 00:25:15.220
from an API somewhere, this is a good way to get started.


00:25:15.220 --> 00:25:18.260
- It's a nice blend of theory and steps, right?


00:25:18.260 --> 00:25:19.900
It doesn't just say, well, you open up requests


00:25:19.900 --> 00:25:20.940
and you do this.


00:25:20.940 --> 00:25:22.900
It's like, here's what an API is,


00:25:22.900 --> 00:25:24.700
here's what the HTTP verbs mean,


00:25:24.700 --> 00:25:27.180
here's what the status codes are,


00:25:27.180 --> 00:25:28.220
here's how you get to that,


00:25:28.220 --> 00:25:31.300
and how do you manifest that in Python and stuff.


00:25:31.300 --> 00:25:32.140
Yeah, it's nice.


00:25:32.140 --> 00:25:33.180
- Yeah, but it's not at the level


00:25:33.180 --> 00:25:35.540
of like a college course lecture.


00:25:35.540 --> 00:25:38.580
It's just enough to get the concepts right.


00:25:38.580 --> 00:25:40.340
- Exactly, it's not trying to make you read


00:25:40.340 --> 00:25:44.100
the RESTful dissertations, things like that.


00:25:44.100 --> 00:25:45.860
- Yeah, I don't even know if it mentions REST,


00:25:45.860 --> 00:25:47.300
even though that's what we're talking about.


00:25:47.300 --> 00:25:49.380
- Cool, that's probably a good thing.


00:25:49.380 --> 00:25:50.700
That was overdone for a while.


00:25:50.700 --> 00:25:52.140
Now, last thing I want to cover


00:25:52.140 --> 00:25:54.060
is memory management in Python.


00:25:54.060 --> 00:25:56.580
This is an article entitled Memory Management in Python,


00:25:56.580 --> 00:25:59.840
but what it really is it's a narrow slice,


00:25:59.840 --> 00:26:02.620
but a common slice of memory management in Python.


00:26:02.620 --> 00:26:03.940
So you probably don't think about memory


00:26:03.940 --> 00:26:05.260
very much in Python, huh, Brian?


00:26:05.260 --> 00:26:06.420
- No, I usually forget about it.


00:26:06.420 --> 00:26:07.940
- Yeah, just forget about it.


00:26:07.940 --> 00:26:09.500
That's right.


00:26:09.500 --> 00:26:13.180
So you don't use malloc or free or new


00:26:13.180 --> 00:26:14.740
or any of these things.


00:26:14.740 --> 00:26:16.060
Definitely not delete.


00:26:16.060 --> 00:26:18.620
If you use delete, it means something else, sort of.


00:26:18.620 --> 00:26:19.740
And things like that, right?


00:26:19.740 --> 00:26:20.580
- Yeah.


00:26:20.580 --> 00:26:22.420
- So I think it's actually pretty interesting


00:26:22.420 --> 00:26:24.880
that the story of understanding


00:26:24.880 --> 00:26:27.980
how the runtime experience is in CPython,


00:26:27.980 --> 00:26:30.820
it's kind of opaque a little bit, right?


00:26:30.820 --> 00:26:33.420
There's not a lot written about memory management,


00:26:33.420 --> 00:26:35.380
which is why I decided to pick this thing


00:26:35.380 --> 00:26:37.260
and talk a little bit about what it covers,


00:26:37.260 --> 00:26:40.940
because I think it doesn't really matter


00:26:40.940 --> 00:26:43.100
that you know this in some sense, right?


00:26:43.100 --> 00:26:44.760
Like your Python code will still work,


00:26:44.760 --> 00:26:49.220
but you more closely understand what your code is doing,


00:26:49.220 --> 00:26:52.100
how that might map over to like CPU architectures


00:26:52.100 --> 00:26:54.300
and caches and RAM and all that kind of stuff.


00:26:54.300 --> 00:26:57.260
And, you know, just having a high level understanding


00:26:57.260 --> 00:26:58.460
that that's good.


00:26:58.460 --> 00:27:01.620
Yeah, so here's a pretty deep detailed article,


00:27:01.620 --> 00:27:03.300
not too long, get to it pretty quick,


00:27:03.300 --> 00:27:05.180
about memory management in Python,


00:27:05.180 --> 00:27:07.500
but it only covers, like I said, a little bit.


00:27:07.500 --> 00:27:12.420
It's really about how does small object allocation


00:27:12.420 --> 00:27:14.620
and deallocation happen in Python.


00:27:14.620 --> 00:27:15.940
It doesn't talk about the gill,


00:27:15.940 --> 00:27:18.040
which it's about thread safety and memory allocation.


00:27:18.040 --> 00:27:19.940
It doesn't talk about reference counts.


00:27:19.940 --> 00:27:21.940
It doesn't talk about garbage collection


00:27:21.940 --> 00:27:25.100
for cycles or much else.


00:27:25.100 --> 00:27:26.580
So it's all about small objects,


00:27:26.580 --> 00:27:29.920
but most things we make in Python are small objects.


00:27:29.920 --> 00:27:30.760
Even when they're big,


00:27:30.760 --> 00:27:32.220
they're really just a bunch of small things


00:27:32.220 --> 00:27:38.060
pointed at each other, right? So if I've got like a list of a million items, I don't have


00:27:38.060 --> 00:27:44.220
each of those items is 10 bytes, I don't have 10 million bytes, I have this big list with


00:27:44.220 --> 00:27:48.580
a bunch of things, but then each one of those is a pointer out to its actual thing that


00:27:48.580 --> 00:27:54.780
it is right. Even when you have strings, or even numbers, right, a lot of languages, numbers


00:27:54.780 --> 00:27:59.980
are allocated on the stack, and treated as value types and stuff. But you know, everything


00:27:59.980 --> 00:28:03.100
is an object. So every little thing that you make has to get allocated and


00:28:03.100 --> 00:28:07.740
deallocated. So understanding how these small objects get allocated, that's,


00:28:07.740 --> 00:28:10.260
that's pretty interesting. So that's what this article talks about. So I'll


00:28:10.260 --> 00:28:14.260
try to like summarize some of the stuff covered there. One of the problems you


00:28:14.260 --> 00:28:18.740
have with memory allocation is that memory can get super fragmented, right?


00:28:18.740 --> 00:28:21.940
If I just allocate a bunch of stuff and they deleted and keep allocating and


00:28:21.940 --> 00:28:26.620
just, just let that grow, you know, just keep adding on on the end, wherever the


00:28:26.620 --> 00:28:28.860
memory is, and I want to interact with that,


00:28:28.860 --> 00:28:30.020
that can really mess up.


00:28:30.020 --> 00:28:32.300
Like reading from RAM and getting stuff on cache


00:28:32.300 --> 00:28:35.060
to be high performance and stuff like that.


00:28:35.060 --> 00:28:37.300
So what Python does is it actually


00:28:37.300 --> 00:28:42.380
pre-allocates these little 256k chunks,


00:28:42.380 --> 00:28:46.540
and then it partitions those up and it plucks in the small


00:28:46.540 --> 00:28:49.260
objects into those spaces, and then will potentially


00:28:49.260 --> 00:28:51.820
take them back out and then reuse those spaces


00:28:51.820 --> 00:28:54.340
that it had already allocated when it needs


00:28:54.340 --> 00:28:56.420
to make a new small thing.


00:28:56.420 --> 00:28:58.780
All right, so that's supposed to help


00:28:58.780 --> 00:29:01.900
with memory optimization, the locality stuff,


00:29:01.900 --> 00:29:04.220
the fragmentation, and so on.


00:29:04.220 --> 00:29:07.260
So there's a special memory manager in Python


00:29:07.260 --> 00:29:10.500
called PyMalloc, general purpose allocator.


00:29:10.500 --> 00:29:14.860
On top of like C malloc, there's a Python allocator, right?


00:29:14.860 --> 00:29:17.100
So there's like this layer, we have RAM,


00:29:17.100 --> 00:29:19.580
we have the operating systems, virtual memory management,


00:29:19.580 --> 00:29:24.420
we have C's malloc, we have this PyMem, PyMalloc thing,


00:29:24.420 --> 00:29:26.500
We have the Python object allocator


00:29:26.500 --> 00:29:28.180
that then figures out where to place these things


00:29:28.180 --> 00:29:29.420
and we actually have object memory.


00:29:29.420 --> 00:29:30.900
So there's a lot of stuff going on here


00:29:30.900 --> 00:29:35.040
and they break it into three levels of organization.


00:29:35.040 --> 00:29:37.140
Okay, so for small objects,


00:29:37.140 --> 00:29:39.840
which are things that are individually smaller


00:29:39.840 --> 00:29:41.780
than 512 bytes, right?


00:29:41.780 --> 00:29:43.760
Not like maybe a list that has a bunch of stuff,


00:29:43.760 --> 00:29:46.620
but each little bit smaller, right?


00:29:46.620 --> 00:29:48.800
So those are the things we're talking about.


00:29:48.800 --> 00:29:50.540
And what happens is it gets broken


00:29:50.540 --> 00:29:53.140
into these three things called the block,


00:29:53.140 --> 00:29:55.940
the pool, and the arena.


00:29:55.940 --> 00:29:58.980
So a block is a chunk of memory of a certain size,


00:29:58.980 --> 00:30:03.420
and it only holds Python objects of a certain size.


00:30:03.420 --> 00:30:08.220
So maybe there's a block that holds 16 byte Python things.


00:30:08.220 --> 00:30:08.720
Yeah?


00:30:08.720 --> 00:30:09.220
OK.


00:30:09.220 --> 00:30:10.220
That's weird.


00:30:10.220 --> 00:30:10.720
Yeah.


00:30:10.720 --> 00:30:13.700
So the reason is Python can then--


00:30:13.700 --> 00:30:17.220
it knows how to exactly fill up and then reuse those blocks.


00:30:17.220 --> 00:30:17.780
Oh, yeah.


00:30:17.780 --> 00:30:18.180
OK.


00:30:18.180 --> 00:30:20.100
So if it's like, oh, I'm going to get a bunch of numbers,


00:30:20.100 --> 00:30:21.580
all the numbers are the same size


00:30:21.580 --> 00:30:23.620
unless they become utterly huge.


00:30:23.620 --> 00:30:26.140
So we can just like allocate them into the spot.


00:30:26.140 --> 00:30:27.120
Some of those numbers go away.


00:30:27.120 --> 00:30:27.960
We got another block.


00:30:27.960 --> 00:30:29.940
We drop that new number pointer in right there


00:30:29.940 --> 00:30:32.860
or the number which we then point at right there and so on.


00:30:32.860 --> 00:30:34.640
So there's these different blocks.


00:30:34.640 --> 00:30:39.540
Each one is a uniform size between eight and 512 bytes.


00:30:39.540 --> 00:30:41.900
And then the blocks are managed by this thing


00:30:41.900 --> 00:30:44.180
called a pool, which is usually limited


00:30:44.180 --> 00:30:47.560
to a memory page size, so four kilobytes.


00:30:47.560 --> 00:30:49.700
And then the pools are managed


00:30:49.700 --> 00:30:51.780
as these things called arenas.


00:30:51.780 --> 00:30:54.980
And these are the things that are allocated on the heap.


00:30:54.980 --> 00:30:59.220
I believe they are 256k pieces of memory, which


00:30:59.220 --> 00:31:03.920
hold 64 pools, which hold some number of blocks and things


00:31:03.920 --> 00:31:04.540
like that.


00:31:04.540 --> 00:31:06.540
So there's this really intricate way


00:31:06.540 --> 00:31:10.440
in which memory is trying to be grouped together and then also


00:31:10.440 --> 00:31:13.800
trying to be reused without reallocating it


00:31:13.800 --> 00:31:15.460
from the operating system.


00:31:15.460 --> 00:31:18.900
So even though Python might new up a bunch of objects,


00:31:18.900 --> 00:31:21.680
it actually says, well, but we already have this block


00:31:21.680 --> 00:31:23.220
that holds those size of things


00:31:23.220 --> 00:31:24.180
and there's some spots in there,


00:31:24.180 --> 00:31:25.420
so let's fill that bad boy up.


00:31:25.420 --> 00:31:26.260
- Oh, all right.


00:31:26.260 --> 00:31:28.220
- Yeah, anyway, so it's pretty interesting


00:31:28.220 --> 00:31:30.380
how all this stuff is working together,


00:31:30.380 --> 00:31:33.220
but that's the Python small object allocator.


00:31:33.220 --> 00:31:36.560
- Never thought about that before, but kind of interesting.


00:31:36.560 --> 00:31:39.740
Also, I'm trying to visualize like a sports arena


00:31:39.740 --> 00:31:41.380
with 64 swimming pools in it.


00:31:41.380 --> 00:31:43.580
- That's not a bad one.


00:31:43.580 --> 00:31:46.720
And then each pool is filled with exactly the same size


00:31:46.720 --> 00:31:49.060
people or creatures swimming around, something like that.


00:31:49.060 --> 00:31:49.900
- Yeah. - Yeah, there you go.


00:31:49.900 --> 00:31:51.540
That makes a lot of sense.


00:31:51.540 --> 00:31:53.400
The first part of it totally made sense.


00:31:53.400 --> 00:31:54.680
The last bit, maybe not so much.


00:31:54.680 --> 00:31:56.600
All right, well, anyway,


00:31:56.600 --> 00:31:58.400
what I like about this article is it seems like


00:31:58.400 --> 00:32:00.160
it has a lot of stuff from like,


00:32:00.160 --> 00:32:04.120
here's the actual C code that defines what an arena is.


00:32:04.120 --> 00:32:06.040
Here you can see it's like a doubly linked list


00:32:06.040 --> 00:32:06.880
and how it all fits together.


00:32:06.880 --> 00:32:08.480
And it's just got some good analysis.


00:32:08.480 --> 00:32:11.640
So have a look if you've wondered about this.


00:32:11.640 --> 00:32:13.080
All right, well, that's it for our main items.


00:32:13.080 --> 00:32:17.640
I know Brian, you have big news for the entire world


00:32:17.640 --> 00:32:19.680
if they live near Portland.


00:32:19.680 --> 00:32:22.520
- If they live in Portland or really close to Portland.


00:32:22.520 --> 00:32:24.040
- Or want to come to Portland.


00:32:24.040 --> 00:32:26.680
- September 26th, I'll be speaking downtown


00:32:26.680 --> 00:32:29.240
at the Portland Python User Group


00:32:29.240 --> 00:32:32.840
and I'm still working on my talk, but I'll be there.


00:32:32.840 --> 00:32:33.780
That'll be fun.


00:32:33.780 --> 00:32:36.080
And then I'll probably polish it more


00:32:36.080 --> 00:32:38.760
and people have to volunteer for this other talk.


00:32:38.760 --> 00:32:46.920
So on October 6th, it's the inaugural first day of meeting the Python PDX West.


00:32:46.920 --> 00:32:51.100
So we've got a new user group for Python in town.


00:32:51.100 --> 00:32:52.720
I'm hosting it along with you.


00:32:52.720 --> 00:32:53.720
Yeah, it'll be fun.


00:32:53.720 --> 00:32:54.720
I'm really looking forward to it.


00:32:54.720 --> 00:32:55.920
Yeah, and you'll be speaking there.


00:32:55.920 --> 00:32:56.920
I will.


00:32:56.920 --> 00:32:58.880
And I'm trying to get other people to volunteer to speak.


00:32:58.880 --> 00:33:01.600
And if they don't, then it'll just be you and me speaking.


00:33:01.600 --> 00:33:02.840
But I think it'll be fun.


00:33:02.840 --> 00:33:05.320
So we've got a bunch of people signed up so far.


00:33:05.320 --> 00:33:07.700
So it's filling up fast.


00:33:07.700 --> 00:33:08.700
People should sign up.


00:33:08.700 --> 00:33:11.400
Maybe we could do a live Python Bytes sometime there as well


00:33:11.400 --> 00:33:13.260
at the end of the day or something, who knows?


00:33:13.260 --> 00:33:14.980
- That's a great idea, yeah, we could have--


00:33:14.980 --> 00:33:16.700
- Maybe not Tuesday, October 6th,


00:33:16.700 --> 00:33:18.140
but maybe someday we can make that happen.


00:33:18.140 --> 00:33:19.180
- Maybe someday, yeah.


00:33:19.180 --> 00:33:20.100
- Yeah, that's great news.


00:33:20.100 --> 00:33:23.620
If you happen to be around, definitely drop in.


00:33:23.620 --> 00:33:25.460
That'd be great, it's on meetup.com, right?


00:33:25.460 --> 00:33:26.380
People can just sign up there.


00:33:26.380 --> 00:33:27.980
- Yep, and a link in the show notes.


00:33:27.980 --> 00:33:29.900
- Do you have any intention of recording,


00:33:29.900 --> 00:33:32.940
live casting, or otherwise spreading this


00:33:32.940 --> 00:33:34.940
in a farther path?


00:33:34.940 --> 00:33:36.100
- It's not a bad idea.


00:33:36.100 --> 00:33:38.300
We don't have anything like that set up right away.


00:33:38.300 --> 00:33:39.940
in the future maybe we could do that.


00:33:39.940 --> 00:33:42.980
Probably people would be interested in watching these.


00:33:42.980 --> 00:33:45.180
But I also wanna make it really accessible


00:33:45.180 --> 00:33:48.420
to people that are new to presenting as well.


00:33:48.420 --> 00:33:50.780
I'd love to have people come in and do


00:33:50.780 --> 00:33:52.500
like a talk that they're working on.


00:33:52.500 --> 00:33:54.220
It's not quite polished yet.


00:33:54.220 --> 00:33:57.300
I want it to not just be experts talking to everybody else,


00:33:57.300 --> 00:34:00.500
but I'd like it to be people working out things


00:34:00.500 --> 00:34:02.260
that they're just interested in.


00:34:02.260 --> 00:34:03.860
So I think it'd be good.


00:34:03.860 --> 00:34:05.580
- Yeah, that sounds like a great philosophy for it.


00:34:05.580 --> 00:34:06.420
- How about you?


00:34:06.420 --> 00:34:07.340
Any extras?


00:34:07.340 --> 00:34:11.340
I have a couple presenting and speaking PyCon 2020,


00:34:11.340 --> 00:34:12.840
which is a little earlier this year.


00:34:12.840 --> 00:34:14.740
I believe it's like in April or something.


00:34:14.740 --> 00:34:15.580
The website's up.


00:34:15.580 --> 00:34:16.420
- Yeah.


00:34:16.420 --> 00:34:19.740
- Yeah, so April 15th to 23rd.


00:34:19.740 --> 00:34:24.260
So the call for proposals is now open for PyCon 2020.


00:34:24.260 --> 00:34:26.360
So if you would like to be considered,


00:34:26.360 --> 00:34:27.900
a talk of yours to be considered there,


00:34:27.900 --> 00:34:29.020
then now is the time.


00:34:29.020 --> 00:34:30.460
- Yeah, go ahead and submit those.


00:34:30.460 --> 00:34:32.500
'Cause you know you're only gonna spend like a week


00:34:32.500 --> 00:34:34.940
writing it up anyway, so may as well get that done.


00:34:34.940 --> 00:34:36.060
Right, and away.


00:34:36.060 --> 00:34:38.260
>> That's right, do it like a band-aid, stop worrying about it,


00:34:38.260 --> 00:34:39.260
just get it over with.


00:34:39.260 --> 00:34:40.180
>> Yeah. >> Pull it right off.


00:34:40.180 --> 00:34:43.140
All right, another thing, have you heard of Gitbook?


00:34:43.140 --> 00:34:45.300
>> Yeah, but I haven't really looked into it much.


00:34:45.300 --> 00:34:49.740
>> I hadn't either, I was interviewing the guy, Joe, from Masonite,


00:34:49.740 --> 00:34:51.220
the Masonite web framework.


00:34:51.220 --> 00:34:57.380
And I noticed that Masonite's documentation is written in Gitbook.


00:34:57.380 --> 00:34:59.820
And so I looked at it, and Gitbook is pretty interesting.


00:34:59.820 --> 00:35:05.020
You can use it as kind of like almost a base camp project management type thing.


00:35:05.020 --> 00:35:09.780
So stuff, personal notes or things you want to track or stuff like that, but


00:35:09.780 --> 00:35:13.740
you can also use it for documentation and knowledge bases and whatnot.


00:35:13.740 --> 00:35:15.340
So it looked pretty cool.


00:35:15.340 --> 00:35:17.740
And so I thought I'd just, you know, let people know that it's out there.


00:35:17.740 --> 00:35:22.180
It's free for small teams, like with some limitations, it's costs a little


00:35:22.180 --> 00:35:28.220
bit of money for non-trivial small teams, like $7 user, but it's also free for


00:35:28.220 --> 00:35:30.620
open source and nonprofit teams, which is kind of cool.


00:35:30.620 --> 00:35:32.900
So I'm also a big fan of read the docs.


00:35:33.100 --> 00:35:35.500
So it's, you know, I'm not saying they shouldn't use that,


00:35:35.500 --> 00:35:37.600
but here's an interesting project that I ran across


00:35:37.600 --> 00:35:38.440
that I hadn't heard of.


00:35:38.440 --> 00:35:39.280
- It looks nice.


00:35:39.280 --> 00:35:42.820
If people, for some reason, are opposed to read the docs,


00:35:42.820 --> 00:35:44.180
I don't know why you would be,


00:35:44.180 --> 00:35:46.940
or just like this look better, here's another opportunity.


00:35:46.940 --> 00:35:48.540
So good to have options.


00:35:48.540 --> 00:35:49.380
- Good to have options.


00:35:49.380 --> 00:35:50.700
Also good to have laughs.


00:35:50.700 --> 00:35:52.140
- Yeah, let's do some jokes.


00:35:52.140 --> 00:35:53.180
- All right.


00:35:53.180 --> 00:35:54.100
How about you go first?


00:35:54.100 --> 00:35:55.060
- Okay.


00:35:55.060 --> 00:35:57.660
So I pulled these out of a list of dad jokes


00:35:57.660 --> 00:36:00.460
you had posted somewhere on our Trello,


00:36:00.460 --> 00:36:01.820
but changed it a little bit.


00:36:01.820 --> 00:36:05.580
So what do you call a 3.14 foot long snake?


00:36:05.580 --> 00:36:06.420
- I don't know.


00:36:06.420 --> 00:36:08.460
- Well, that would be a python, of course.


00:36:08.460 --> 00:36:10.700
- With the Greek symbol, thon, yeah, python.


00:36:10.700 --> 00:36:14.540
- Yeah, so if it's not feet but 3.14 inches,


00:36:14.540 --> 00:36:15.580
then what is it?


00:36:15.580 --> 00:36:16.420
It's a micropython.


00:36:16.420 --> 00:36:19.980
- It's a micropython, a mu-py-thon.


00:36:19.980 --> 00:36:22.100
Yeah, I feel like we're back in calculus or physics.


00:36:22.100 --> 00:36:24.180
- Yeah, so do you wanna do some of these?


00:36:24.180 --> 00:36:25.260
- Sure.


00:36:25.260 --> 00:36:28.300
So why doesn't Hollywood make more big data movies?


00:36:28.300 --> 00:36:29.140
- I don't know, why?


00:36:29.140 --> 00:36:29.980
- No sequel.


00:36:29.980 --> 00:36:31.420
(laughing)


00:36:31.420 --> 00:36:32.980
This last one is a little bit crass.


00:36:32.980 --> 00:36:34.380
I don't know, it's a little low level,


00:36:34.380 --> 00:36:35.980
but I'll see what I can do here.


00:36:35.980 --> 00:36:38.580
So why didn't the angle bracket div


00:36:38.580 --> 00:36:40.260
get invited to the dinner party?


00:36:40.260 --> 00:36:41.100
- I don't know, why?


00:36:41.100 --> 00:36:42.620
- It had no class.


00:36:42.620 --> 00:36:44.780
(laughing)


00:36:44.780 --> 00:36:45.780
Oh yeah, that's a good one.


00:36:45.780 --> 00:36:47.540
All right, well thanks for throwing those in there.


00:36:47.540 --> 00:36:48.380
These are fun.


00:36:48.380 --> 00:36:50.940
- Yeah, thank you once again for talking with me


00:36:50.940 --> 00:36:52.140
on a nice Wednesday.


00:36:52.140 --> 00:36:53.300
- Absolutely, see you later.


00:36:53.300 --> 00:36:54.140
- Bye.


00:36:54.140 --> 00:36:55.580
- Thank you for listening to Python Bytes.


00:36:55.580 --> 00:36:58.060
Follow the show on Twitter via @pythonbytes.


00:36:58.060 --> 00:37:01.100
That's Python Bytes as in B-Y-T-E-S.


00:37:01.100 --> 00:37:05.740
get the full show notes at pythonbytes.fm. If you have a news item you want featured,


00:37:05.740 --> 00:37:10.540
just visit pythonbytes.fm and send it our way. We're always on the lookout for sharing something


00:37:10.540 --> 00:37:15.340
cool. On behalf of myself and Brian Okken, this is Michael Kennedy. Thank you for listening and


00:37:15.340 --> 00:37:17.740
sharing this podcast with your friends and colleagues.

