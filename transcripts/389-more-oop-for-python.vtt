WEBVTT

00:00:00.001 --> 00:00:04.640
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.

00:00:04.640 --> 00:00:10.000
This is episode 389 recorded June 24th. I'm Brian Okken.

00:00:10.000 --> 00:00:11.440
And I am Michael Kennedy.

00:00:11.440 --> 00:00:16.880
This episode is brought to you by Scout APM. Listen to their spot later in the show and check

00:00:16.880 --> 00:00:22.320
them out by going to the show notes and clicking it. You can connect with us on Mastodon. We love

00:00:22.320 --> 00:00:28.880
hearing from you. And if you're listening to this later, join us live every once in a while if you

00:00:28.880 --> 00:00:35.840
want. Go to pythonbytes.fm/live to be part of the audience and it'll tell you when the next episode

00:00:35.840 --> 00:00:42.160
is. And I'd like to say thank you to everybody that signed up for the mailing list to get our

00:00:42.160 --> 00:00:49.760
show notes. It's nice to see that little creeping up and in listeners. And I actually find it quite

00:00:49.760 --> 00:00:55.440
handy to find those notes later on. Absolutely. Brian, I would like to add we're coming up on a

00:00:55.440 --> 00:01:00.320
milestone number there and I feel like we should probably do some kind of giveaway or some kind of

00:01:00.320 --> 00:01:05.680
contest. And it'll probably happen in about the next month to six weeks. So you got to be on the

00:01:05.680 --> 00:01:10.720
list to win the prize that we invent for the thing that we'll talk about later. So sign up.

00:01:10.720 --> 00:01:11.120
Yeah.

00:01:11.120 --> 00:01:14.240
Python Bytes.fm. Click on newsletter. Put your info in.

00:01:14.240 --> 00:01:20.080
All right. Well, why don't you kick us off with it's a nice sunny day. Maybe some sort of solar

00:01:20.080 --> 00:01:21.120
topic for...

00:01:21.120 --> 00:01:27.040
Yes, let's do it. Let's do it. How about this, Brian, let's talk about Solara. And this one

00:01:27.040 --> 00:01:32.640
comes to us as a recommendation from a listener. So thank you to Florian for sending this in.

00:01:32.640 --> 00:01:39.920
Solara is a... Solara, Solara? I don't know. Tomato, tomato? Solara is a pure Python framework,

00:01:39.920 --> 00:01:46.160
but in React style. So it is a sort of rapid application development, somewhat data science

00:01:46.160 --> 00:01:52.080
focused front end framework or framework for building front end UIs. That's like React.

00:01:52.080 --> 00:01:59.280
That allows you to write better Jupyter and web apps. So it does this by basically

00:01:59.280 --> 00:02:06.480
integrating IPy widgets and other types of React based APIs, programmable like code,

00:02:06.480 --> 00:02:12.480
not APIs you call on top of IPython widgets. So that's super cool. It can either be stuff that

00:02:12.480 --> 00:02:18.320
runs inside notebooks that makes them better interactive things, or it can just be standalone

00:02:18.320 --> 00:02:22.720
web apps like FastAPI or stuff like that. Yeah. Pretty neat, huh?

00:02:22.720 --> 00:02:23.360
Yeah.

00:02:23.360 --> 00:02:29.440
So we always need more, more UI frameworks in Python, I believe. I would put this if I was

00:02:29.440 --> 00:02:36.080
considering Streamlit or Dash or something along those lines. It's kind of in that realm. Okay.

00:02:36.080 --> 00:02:40.640
So let's see. It talks about the benefits of putting things together, but the most important

00:02:40.640 --> 00:02:46.160
thing I would recommend to you is probably check out their examples to start. So let's

00:02:46.160 --> 00:02:52.400
check out their examples. So in this area, we've got a whole bunch of different examples that don't

00:02:52.400 --> 00:02:57.200
want to scroll. Why won't you scroll? Hold on. There we go. Now it scrolls. Yay, browser.

00:02:57.200 --> 00:03:01.680
So let's pick one of these. Let's go to the full screen ones. These are fun.

00:03:01.680 --> 00:03:06.560
Jesus, really doesn't like to scroll, does it? Full screen. Okay. So we've got different ones

00:03:06.560 --> 00:03:11.600
here. You can just pull these up and let's just say the scatter one's kind of interesting. Check

00:03:11.600 --> 00:03:17.760
this out, right? This is how this works. So you take your iPython widgets, your notebook-like

00:03:17.760 --> 00:03:25.040
stuff, and look what you would see on the screen if you load this up. It's like a full UI. It fills

00:03:25.040 --> 00:03:28.560
the screen here, right? And you can either upload a dataset and figure out, I don't know how to

00:03:28.560 --> 00:03:32.880
figure out what the dataset's supposed to be, but probably a CSV or something. And then you can also

00:03:32.880 --> 00:03:37.520
just click show me the sample data and check it out. You get this cool, interactive, probably

00:03:37.520 --> 00:03:45.600
Plotly. Yes, Plotly UI here. And I can change the size of all these things that it works on. I can

00:03:45.600 --> 00:03:50.800
say, I would like to see, this talks about like GDP, life expectancy by country. So I could say,

00:03:50.800 --> 00:03:58.080
I want to see the life expectancy by country and pull that up. Continent rather, I think is how

00:03:58.080 --> 00:04:02.080
they have data. Where's this? It was working just a minute ago. Why is this not running for me?

00:04:02.080 --> 00:04:10.240
Maybe I made the size too weird for it. Don't know. Let's go. I guess I'm picking the wrong thing.

00:04:10.240 --> 00:04:14.000
That's just the live demo, Chris. It just won't work. It totally is. I don't know why it's not

00:04:14.000 --> 00:04:17.440
working. Anyway, there we go. I have to do, I just have to reverse it. There we go. This is looking

00:04:17.440 --> 00:04:24.000
good. So you can say, show me the life expectancy by country. And then you get all these really

00:04:24.000 --> 00:04:31.360
interesting, interactive bits. You can resize it. So this is all a super easy UI to build, Brian,

00:04:31.360 --> 00:04:36.240
with this UI framework. That's pretty cool. And if you go back and look at the example,

00:04:36.240 --> 00:04:41.760
they'll show you like one of the cells in a Jupyter notebook can just be this graph here.

00:04:41.760 --> 00:04:46.000
And it has a full screen option, or it can just be like the output of a cell. It's one of these

00:04:46.000 --> 00:04:52.160
interactive apps. How wild is that? Isn't that crazy? Yeah. And then you can also go and see,

00:04:52.160 --> 00:04:58.640
you know, what does a tutorial look like? Somewhere. I got to go to get started. Quick

00:04:58.640 --> 00:05:04.080
start. So if you go to the quick start, it'll show you basically how to program this stuff.

00:05:04.080 --> 00:05:10.480
And it's, it's super easy. Just put a decorator, say this is a component and shows up in your page.

00:05:10.480 --> 00:05:15.040
It's really focused on building these little reasonable and composable components. So it's a

00:05:15.040 --> 00:05:20.320
little bit like shiny, actually, I think, actually. So anyway, super cool way to build these

00:05:20.320 --> 00:05:24.960
interactive dashboards and stuff. That's more than just a picture, but a thing you can actually

00:05:24.960 --> 00:05:29.280
play with and publish to the web. Yeah, especially I love stuff like this, like, especially if you

00:05:29.280 --> 00:05:35.120
don't really know how you want to look at the data yet. So you can, you can give people lots of

00:05:35.120 --> 00:05:42.160
options to. Absolutely. And it, I don't see a price. All I see is Starus on GitHub. So I think

00:05:42.160 --> 00:05:47.200
it's just a open source project that you can use for your stuff. Not a commercial thing from what

00:05:47.200 --> 00:05:51.360
I can tell. So one of the things I was, I was looking at this the other day, and I don't know

00:05:51.360 --> 00:05:56.960
if you came across an answer to this question, but was it said a pure Python React style framework

00:05:56.960 --> 00:06:05.520
for scaling Jupyter and web apps. The and is like, I was a little bit confused. Does it, do I have to

00:06:05.520 --> 00:06:12.240
be a Jupyter type programmer to do this? Or do you know if I can? No, if you want to use FastAPI,

00:06:12.240 --> 00:06:18.960
it can, and there's a thing called, what do they call it? A Solaris server or something like that.

00:06:18.960 --> 00:06:23.920
So you can run that and it says, look, it'll run on FastAPI, Starlet, Flask, and so on.

00:06:23.920 --> 00:06:30.000
Okay. I imagine you just create, just basically serve up some common template that like starts

00:06:30.000 --> 00:06:32.800
at all, you know, those, those kinds of things. The other thing that's worth pointing out in this

00:06:32.800 --> 00:06:39.760
whole discussion is, so this is built on top of React-on and React-on is this interesting project

00:06:39.760 --> 00:06:47.600
here. It says it's like React for, yeah, it is. It's, it's, it's a really good logo. It's a Python

00:06:47.600 --> 00:06:53.520
logo as the nucleus of an atom. And then a bunch of little small Python logos circling it like

00:06:53.520 --> 00:06:59.360
electrons. That's good. So this basically lets you create code for IPython widgets that is in

00:06:59.360 --> 00:07:07.120
the style of React. So if you go down here here, you can create, for example, a component, which

00:07:07.120 --> 00:07:12.400
is a clickable button and you basically initialize the state and then you write the handler.

00:07:12.400 --> 00:07:14.240
And just like the handful.

00:07:14.240 --> 00:07:19.600
Yeah. Yeah. Yeah. That's pretty neat. And so that's what this thing is all about is creating

00:07:19.600 --> 00:07:24.880
these little widget type things or components and then building up your UI out of it. So I say

00:07:24.880 --> 00:07:25.920
certainly worth checking out.

00:07:25.920 --> 00:07:30.960
I kind of want to just do one of those, like just a button that just tells you how many times

00:07:30.960 --> 00:07:31.520
you've clicked it.

00:07:31.520 --> 00:07:34.260
Exactly.

00:07:34.260 --> 00:07:36.320
I'm not going to do anything.

00:07:36.320 --> 00:07:40.640
But after it gets out, yeah, after it gets past a hundred, it'll be like, what are you doing with

00:07:40.640 --> 00:07:43.520
your life? Leave and go do something else. Stop clicking me.

00:07:43.520 --> 00:07:44.420
Yeah.

00:07:44.420 --> 00:07:46.800
Yeah. People check that out. Thanks, Florian.

00:07:46.800 --> 00:07:51.280
Next up, I want to I wanted to talk about coverage a little bit.

00:07:51.280 --> 00:07:56.080
Think? No, I'm on the wrong page. I do want to talk about coverage.

00:07:56.080 --> 00:07:58.800
So Ned Batchelder wrote an article called

00:07:58.800 --> 00:08:04.720
"Coverage at a Crossroads." And so there's a couple of things I wanted to point out about this.

00:08:05.520 --> 00:08:14.800
The really so just the gist of it is it's a there's we Ned wants to make coverage.py faster.

00:08:14.800 --> 00:08:21.840
And one of the issues is the way with the way coverage is written right now and the way it's

00:08:21.840 --> 00:08:28.240
composed. So so he starts the conversation discussing really how coverage works.

00:08:28.240 --> 00:08:32.320
And that's the part where I really like, even if you don't care whether coverage is fast or not,

00:08:32.320 --> 00:08:37.120
this is a nice, fun article to realize how coverage works.

00:08:37.120 --> 00:08:40.000
And so coverage uses a thing called a trace function.

00:08:40.000 --> 00:08:44.400
So it takes your code and adds these trace functions to every line so that

00:08:44.400 --> 00:08:49.200
coverage can know when any line gets hit. And then it coverage also does branch coverage.

00:08:49.200 --> 00:08:54.000
So coverage does branch coverage with with allowing a thing called the arcs.

00:08:54.000 --> 00:08:57.600
So it generates these four lines that look like branches,

00:08:58.400 --> 00:09:04.320
these arcs of like it could go like your line. You could go from line one to line two or line

00:09:04.320 --> 00:09:08.240
two to line three, things like that. And so it keeps track of all that.

00:09:08.240 --> 00:09:15.200
And and the reason why things could be faster is because, like, let's say you hit line two already.

00:09:15.200 --> 00:09:19.680
You don't have to. And there's no branches in there or anything. It's just a line of code.

00:09:19.680 --> 00:09:26.320
You wouldn't need to actually hit the trace function every time you hit that,

00:09:26.320 --> 00:09:32.000
but there's no way to take it out. So there there's some ideas around making it faster.

00:09:32.000 --> 00:09:34.960
And slipcover, for instance, has a bunch of ways. So he's taking

00:09:34.960 --> 00:09:41.040
uses a bytecode thing that there's a discussion around slipcover as a different coverage tool.

00:09:41.040 --> 00:09:47.040
There's also discussion around sys.monitoring that came in in Python 3.12.

00:09:47.040 --> 00:09:50.800
And with sys.monitoring, you can do something like a trace function,

00:09:50.800 --> 00:09:56.000
but it's something that you can take away later. So the idea, like, for line coverage,

00:09:56.000 --> 00:10:01.920
this would work just great. So you could just say with sys.monitoring every time if I hit this

00:10:01.920 --> 00:10:06.480
line, great. Now I can take that out so I don't have to worry about that line ever again.

00:10:06.480 --> 00:10:14.080
And and then but there's there's some discussion that Ned has around how do you deal with

00:10:14.080 --> 00:10:21.600
branching for that? And it's an interesting it's an interesting take on kind of an interesting idea.

00:10:21.600 --> 00:10:27.680
There's an interesting problem set for how to get deal with it, kind of like maybe arcs aren't the

00:10:27.680 --> 00:10:32.320
right way to do it. Maybe there's some other way to to deal with with branch coverage. And there's

00:10:32.320 --> 00:10:39.680
a in it's not trivial because there's there's an example of a try finally block with a return

00:10:39.680 --> 00:10:47.200
statement happening in the try. So you don't necessarily hit you always will hit the finally,

00:10:47.200 --> 00:10:52.160
even with the return, but you don't know if you'll hit the line after that. You know,

00:10:52.160 --> 00:10:57.200
you'd have to look at the code, but really fun discussion. There's a call out of where if you

00:10:57.200 --> 00:11:02.640
want to get involved, you'd like to to offer some solutions or just help with the discussion.

00:11:02.640 --> 00:11:07.680
There's that too. But even if you're not going to help, I think it's a cool, cool discussion

00:11:07.680 --> 00:11:14.960
of how coverage works. And I also just wanted to thank Ned for putting time and effort into

00:11:14.960 --> 00:11:19.120
making sure coverage is an awesome tool. So thanks, Ned. Yeah, that's pretty excellent.

00:11:19.120 --> 00:11:24.640
And of course, there's going to be functions and branches of execution that are in some kind of

00:11:24.640 --> 00:11:30.160
tight loop and run a million times. But after the third time, you've already realized it's 100%

00:11:30.160 --> 00:11:36.320
covered. So if you could just because running with coverage and stuff like that, all this profiling

00:11:36.320 --> 00:11:40.400
and coverage stuff puts a serious hurting on the performance. So if you could say, all right,

00:11:40.400 --> 00:11:46.800
that part's done 100%, stop, stop slowing it down. That'd be cool. Yeah, I did like the this,

00:11:46.800 --> 00:11:52.800
this, this cool idea of with the other ones of creating, like adding no op statements in

00:11:52.800 --> 00:11:58.400
just so that for branches, so that you just like, check to see, you know, if I, if I hit that,

00:11:58.400 --> 00:12:02.800
then that branch was taken. That's kind of a neat idea. You could, you know, add these extra little

00:12:02.800 --> 00:12:12.800
hooks. But yeah, anyway, cool. Awesome. Awesome. Up next, thank you to Scout APM. Let me tell you

00:12:12.800 --> 00:12:19.280
real quick about Scout APM. They're big supporters of Python bites. So we appreciate that very much.

00:12:19.280 --> 00:12:24.800
So if you are tired of spending hours trying to find the root cause of issues impacting your

00:12:24.800 --> 00:12:30.400
performance, then you owe it to yourself to check out Scout APM. They're a leading Python application

00:12:30.400 --> 00:12:36.320
performance monitoring tool, APM, that helps you identify and solve performance abnormalities

00:12:36.320 --> 00:12:41.840
faster and easier. Scout APM ties bottlenecks such as memory leaks, slow database queries,

00:12:41.840 --> 00:12:47.680
background jobs, and the dreaded N plus one queries that you can end up if you do lazy loading in your

00:12:47.680 --> 00:12:52.640
ORM, then you say, Oh, no, why is it so slow? Why are you doing 200 database queries for what should

00:12:52.640 --> 00:12:56.720
be one? So you can find out things like that. And it links it back directly to source code. So you

00:12:56.720 --> 00:13:01.920
can spend less time in the debugger and healing logs and just finding the problems and moving on.

00:13:01.920 --> 00:13:05.680
And you'll love it because it's built for developers by developers. It makes it easy

00:13:05.680 --> 00:13:10.160
to get set up. Seriously, you can do it in less than four minutes. So that's awesome. And the

00:13:10.160 --> 00:13:15.680
best part is the pricing is straightforward. You only pay for the data that used with no

00:13:15.680 --> 00:13:21.360
hidden overage fees or per seat pricing. And I just learned this, Brian, they also have,

00:13:21.920 --> 00:13:27.200
they provide the pro version for free to all open source projects. So if you're an open source

00:13:27.200 --> 00:13:32.160
maintainer, and you want to have Scout APM for that project, just shoot them a message or something

00:13:32.160 --> 00:13:37.520
on their pricing page about that. So you can start your free trial and get instant insights today.

00:13:37.520 --> 00:13:42.560
Visit Python by set of him slash Scout. The link is in your podcast player show notes as well.

00:13:42.560 --> 00:13:47.040
And please use that link. Don't just search for them because otherwise they don't think you came

00:13:47.040 --> 00:13:51.120
from us. And then they'd stop supporting the show. So please use our link by them by set of him

00:13:51.120 --> 00:13:57.440
slash Scout, check them out. It really supports the show. This one, Brian comes to us from another

00:13:57.440 --> 00:14:04.480
Brian way in the past though. This is Brian's skin that back in January said, Hey, guess what?

00:14:04.480 --> 00:14:10.160
Pep six, nine, eight. It's been accepted. How awesome is that? And I haven't, it hasn't bubbled

00:14:10.160 --> 00:14:16.720
to the top of my list until now, but I think it's worth talking about. This is in Python three 12.

00:14:16.720 --> 00:14:23.200
And yeah, let's, let's check it out. So if we go over to the pep, it is an override decorator

00:14:23.200 --> 00:14:29.600
for static typing. So, you know, some languages, C#, I think C++, but it's been a

00:14:29.600 --> 00:14:34.560
while since I messed with it, you know, have explicit override keywords and virtual methods.

00:14:34.560 --> 00:14:38.320
I know C++ has virtual methods. I just don't know if you indicate that you're overriding

00:14:38.320 --> 00:14:41.840
it. Tell me, Brian, do you use the overriding keyword or you just, do you just write the

00:14:41.840 --> 00:14:46.880
function? You just, just write it, but you can, that's what I thought. Yeah. Yeah. And in C#,

00:14:46.880 --> 00:14:50.960
you actually say there's a virtual function in the base class, which is intended to have a

00:14:50.960 --> 00:14:56.560
potential people overriding it. And then in the, the derived classes, you say override instead

00:14:56.560 --> 00:15:00.720
of virtual to indicate that you have to say that right to say that you're, you're replacing this

00:15:00.720 --> 00:15:04.960
behavior and you might need to call the base class version and all that kind of stuff. Well,

00:15:04.960 --> 00:15:10.160
basically Python gets that if you want it as a lot of things with typing, it's multiple,

00:15:10.160 --> 00:15:15.920
it's an optional and multiple ways. So let's jump over. If you scroll down, it's kind of weird to me.

00:15:15.920 --> 00:15:22.480
The pep says this pep is here for historical reasons. It's now part of Python. So please see

00:15:22.480 --> 00:15:27.440
override when you click it, though, it doesn't take you to the Python documentation. It takes

00:15:27.440 --> 00:15:32.720
you a separate typing documentation for Python, but is also in the Python documentation.

00:15:32.720 --> 00:15:37.280
Interesting. Which one wins? I don't know, but whatever the example here in the link from the

00:15:37.280 --> 00:15:43.440
pep is super clear. So you got a parent class and you don't say virtual because we don't have that,

00:15:43.440 --> 00:15:50.160
but you can say at override. So the parent class, the base class has a foo function that takes no

00:15:50.160 --> 00:15:56.000
parameters and returns an integer. I'd hear you in the child class. You say override and then as a

00:15:56.000 --> 00:16:01.520
decorator and then foo same signature. And if you were to say override something that didn't exist,

00:16:01.520 --> 00:16:06.880
type checking will say, there's no signature. You, your intention is to override this thing,

00:16:06.880 --> 00:16:12.240
but it doesn't exist. Maybe, maybe you meant to type. I don't like these examples, but this is

00:16:12.240 --> 00:16:18.560
what's written here. So here we go. You overrode foo because that existed, but you tried to override

00:16:18.560 --> 00:16:23.600
baz, but it's bar and you misspelled it or something like that. Now I don't know what

00:16:23.600 --> 00:16:28.880
happens if you mismatch the parameters, but you get the name, right? You know what I mean? Like

00:16:28.880 --> 00:16:33.200
I'm overriding, it takes two parameters. Like, no, it takes one. I don't know. I have to test

00:16:33.200 --> 00:16:42.560
that out. But anyway, if you want to have a little bit more validation in your Python typing for your

00:16:42.560 --> 00:16:47.440
classes and your inheritance, check this out. It's part of Python. It's nothing special that you add.

00:16:47.440 --> 00:16:53.840
It only executes at definition time for the class. So, so it's not like a runtime type thing. So it

00:16:53.840 --> 00:16:59.840
should be low overhead. Yeah. Pretty neat. Why not use it, right? Yeah. Low overhead, high override.

00:17:00.720 --> 00:17:04.640
High override, low overhead. That's right. There you go. All right. Well, thanks, Brian Skinn,

00:17:04.640 --> 00:17:08.480
for sending this in. And yeah, interesting. Cool.

00:17:08.480 --> 00:17:19.040
One of the other things that's neat is speeding up Python bits. And so there's a, there's kind

00:17:19.040 --> 00:17:25.280
of a neat article called from Gage. Oh, that must be the group that makes this stuff. Anyway,

00:17:26.080 --> 00:17:34.160
called "Parsing Python ASTs 20 Times Faster with Rust." So, so this, this article is talking about

00:17:34.160 --> 00:17:41.200
speeding up a tool called TAC. Now, TAC is a CLI, says it's a CLI tool that lets you define and

00:17:41.200 --> 00:17:46.400
enforce import boundaries between Python modules in your project. Yeah. And remember, I talked

00:17:46.400 --> 00:17:51.040
about that a few weeks ago. Yep. Actually, right? Yeah. Episode 384, you talked about it. So,

00:17:52.160 --> 00:17:57.760
yeah, that was just May 21st, just a couple of months ago, or last month. Nice. Anyway,

00:17:57.760 --> 00:18:04.080
at first I'm like, okay, you sped up with Rust. We're kind of hearing that.

00:18:04.080 --> 00:18:11.360
Why I'm calling this out, though, is that I'm not just that TAC seems cool, is that I really liked

00:18:11.360 --> 00:18:16.960
the methodology that they're talking through here. So, they talk about not just how they made it

00:18:16.960 --> 00:18:25.520
faster, but like the process they went to to figure out which parts. So, they used profiling,

00:18:25.520 --> 00:18:33.520
but in specific, I think they used a tool called PySpy and SpeedScope to visualize and get flame

00:18:33.520 --> 00:18:39.200
graphs for performance. Interesting. I've not heard of either of those. I have not, or, you know,

00:18:39.200 --> 00:18:48.640
maybe I have, but we cover a lot of tools, man. Anyway, these look slick, but the output of it

00:18:48.640 --> 00:18:54.400
showed that there was roughly 90% of the total time was taken by a function called get project

00:18:54.400 --> 00:19:00.800
imports. And in that, it spent about two-thirds of the time parsing the ASTs and the remaining one

00:19:00.800 --> 00:19:08.240
third traversing them. So, some great information and some great examples of instead of trying to

00:19:08.240 --> 00:19:14.720
just throw rust at it to speed things up or even just, you know, using Python to optimize your own

00:19:14.720 --> 00:19:22.560
Python, taking a look at exactly what you're doing and only speeding up the little bits that are slow,

00:19:22.560 --> 00:19:31.280
which is, I love that aspect of this. So, okay. So, they took those bits, also went by and there's

00:19:31.280 --> 00:19:39.440
a discussion of why the AST parsing was slow anyway, because that should have been some C code

00:19:39.440 --> 00:19:49.600
as well. But there's a little bit of a deep dive into there, but then they jumped into just

00:19:49.600 --> 00:19:58.480
rewriting it in Rust. And then we've covered these tools before using Py03 and Maturin to help

00:19:59.920 --> 00:20:07.440
quickly develop some Rust for a couple functions. And yeah, so that was it. And it like went from

00:20:07.440 --> 00:20:14.800
the example they had was a code base. It was a common code base, which was the Sentry code base,

00:20:14.800 --> 00:20:23.280
about 3,000 lines of Python files that took like 10 seconds to test. And with this speed up,

00:20:23.280 --> 00:20:30.400
it dropped it down to one second. So, yeah, that seems like a pretty fast speed up. So, nice.

00:20:30.400 --> 00:20:31.600
Yeah. Yeah, it's real nice.

00:20:31.600 --> 00:20:40.800
Also, just kind of a great user example and a short write up on using profiling to really look

00:20:40.800 --> 00:20:44.720
at where your bottlenecks are and then maybe throwing Rust at it there.

00:20:44.720 --> 00:20:49.520
Yeah. And it looks like they just basically re-implemented that one function in Rust and

00:20:49.520 --> 00:20:54.160
then just used it as a dependency, right? With their Py03 extension.

00:20:54.160 --> 00:20:58.960
Yeah. So, I totally want to try that. Like, just that'd be a great way to get into

00:20:58.960 --> 00:21:04.480
to Rust a little bit is to just not try to make a Rust application, but just replacing

00:21:04.480 --> 00:21:06.320
like one function or something.

00:21:06.320 --> 00:21:10.160
This one algorithm is called a ton of times. It's super slow,

00:21:10.160 --> 00:21:14.560
relatively. It's where we spend all our time. But it's not that big, right? Like we could write it,

00:21:14.560 --> 00:21:17.600
probably figure it out in a day or two in Rust and then off you go.

00:21:17.600 --> 00:21:21.520
Yeah. I don't need to learn all the Rust. I just need to make this thing faster.

00:21:21.520 --> 00:21:23.760
Tell me how to do a for loop in Rust. Tell me. Okay.

00:21:23.760 --> 00:21:27.120
Well, tell me, Brian, you got extras?

00:21:27.120 --> 00:21:37.120
Do I have extras? Let me check. Yeah, I do. Last, when was it? Let's go ahead. Episode 388.

00:21:37.120 --> 00:21:38.480
That was just last week, wasn't it?

00:21:38.480 --> 00:21:42.480
It was last week where we talked about not deleting all the repos.

00:21:42.480 --> 00:21:48.240
Yeah. Well, one of the things I talked about was, what did I talk about? I talked about

00:21:48.240 --> 00:21:52.880
import by string with packageutil.resolveName.

00:21:52.880 --> 00:22:00.800
Bad on me for not doing my homework a little bit. Brett Cannon notes that discussions around this

00:22:00.800 --> 00:22:07.600
are maybe not really great things because packageutil is deprecated or it's going to be

00:22:07.600 --> 00:22:14.160
or something. So Brett's recommending not using packageutil, just FYI.

00:22:14.160 --> 00:22:18.320
If it doesn't give you a deprecation warning now, it will someday. Don't go that way.

00:22:18.320 --> 00:22:27.520
Okay. Next up, really quickly, kind of a fun thing. At the Python Language Summit,

00:22:27.520 --> 00:22:34.880
there was a discussion, should Python adopt calendar versioning? And this kind of fun

00:22:34.880 --> 00:22:43.360
discussion. So we have Python 3.12 right now. Should somehow it be like cal versioning? And

00:22:43.360 --> 00:22:50.240
if we went to cal versioning, what would it be? And a fun, I think it was Carol Willing,

00:22:50.240 --> 00:22:57.920
yeah, Carol Willing brought up that we want to at least keep our current versioning through 3.14

00:22:57.920 --> 00:23:02.480
because then it would be the Py version. Yes. We've got to do 3.14 now.

00:23:02.960 --> 00:23:13.200
Yeah. So a lot of this boils into a PEP 2026, which is also nice numbering because the shout

00:23:13.200 --> 00:23:21.840
out of 2026 is when we would switch. So the idea would be what? We've got, oh, there's a table here.

00:23:21.840 --> 00:23:31.200
3.14, no change. That comes out in 2025 if we go to this. And instead of 3.15, we just make

00:23:31.200 --> 00:23:40.720
the 2026 version 3.26. No. Which would-- We're going to end up with a year 3K problem.

00:23:40.720 --> 00:23:46.400
That's okay. But that's like 75 years in the future that we have to care about that.

00:23:46.400 --> 00:23:51.200
I guess they could put a 1.26, then it'll be a thousand years. It probably doesn't matter

00:23:51.200 --> 00:23:58.720
at that point. Oh, yeah. We can add it. Yeah. So I think we're okay. Well, actually, I'm not sure.

00:23:58.720 --> 00:24:03.040
That would be weird, wouldn't it? I don't know. You could have 126. I think you can get to

00:24:03.040 --> 00:24:11.440
2009, year 2099 without going too bizarrely. Yeah. Maybe we're ready for Python 4 by then.

00:24:11.440 --> 00:24:18.080
No, we're not ready. Too soon. Too soon. So what do you think of this?

00:24:18.080 --> 00:24:26.400
It's a little weird to me. Why not just 3.2026, 3.2027? Because to me,

00:24:27.440 --> 00:24:32.400
this doesn't communicate calendar versioning. We already have calendar versioning if you don't

00:24:32.400 --> 00:24:39.120
care about what the number is, because it's yearly release cycles, right? 3.12 means 2024.

00:24:39.120 --> 00:24:47.120
3.13 means 2025. And so if you're not using the calendar numbers, I know 26 is closer to 2026

00:24:47.120 --> 00:24:52.240
than 15, but there's still-- To me, it's like, well, 16, 27. I don't know. It's just like,

00:24:52.240 --> 00:24:57.760
here's the next year's version. Okay. I'm all for it. I think we should switch,

00:24:57.760 --> 00:25:03.200
because I think that since we've gone to a one-year release cycle anyway,

00:25:03.200 --> 00:25:08.160
why not somehow encode that in the number? I totally agree with that. I agree with that.

00:25:08.160 --> 00:25:14.160
My vote's for 3.2026, like most calendar versioning things.

00:25:14.160 --> 00:25:17.840
Oh, yeah. Just do four digits? Yeah, exactly. That's all I'm saying. Just put four digits,

00:25:17.840 --> 00:25:21.360
so it really is the year on the end, and it's really clear that it means the year.

00:25:21.360 --> 00:25:28.960
You don't have to know the code. That's all I'm saying. But I'm also with Carol on leaving 3.14.

00:25:28.960 --> 00:25:34.480
Yeah. I mean, there's nothing saying, since it's bigger, there's nothing saying we could go to

00:25:34.480 --> 00:25:40.000
two digits, and then at some point go, "Let's just throw four digits in there." Anyway. Okay.

00:25:40.000 --> 00:25:47.840
Last thing I wanted, last extra, is Brett Cannon wrote an article called "Saying Thanks to Open

00:25:47.840 --> 00:25:54.240
Source Maintainers." I just want to shout out, this is a really good idea. Quickly, what are our

00:25:54.240 --> 00:26:02.640
ideas? First of all, just be nice to the maintainers. This is great advice. If you disagree

00:26:02.640 --> 00:26:08.320
with something, be polite, be nice. It's good. Great advice. Start with being nice. Be an advocate.

00:26:08.320 --> 00:26:12.560
You don't have to actually thank them directly, but you could advocate for the thing. So Brett's

00:26:12.560 --> 00:26:17.440
involvement with byproject.toml, he sees other people promoting it, makes him feel good. It's a

00:26:17.440 --> 00:26:24.560
good thing. Produce your own open source code, because maybe the maintainer might use your stuff

00:26:24.560 --> 00:26:29.600
now. And then actually say thanks. Nothing wrong with saying thanks to people. And then there's

00:26:29.600 --> 00:26:36.720
financial support, which is good for some projects that have open source. Ways to help fund the

00:26:36.720 --> 00:26:40.960
maintainers, those are good too. But you don't have to fund them. You can just be nice to them,

00:26:40.960 --> 00:26:47.680
say thanks, advocate their thing. That's good. So in that end, I kind of always forget that

00:26:47.680 --> 00:26:53.600
Brett was involved with byproject.toml, and we might not be using it as we are today without

00:26:53.600 --> 00:26:59.840
Brett. So thank you, Brett. I love byproject.toml. I promote it and encourage everybody to use it.

00:26:59.840 --> 00:27:04.160
Awesome. Yeah. Thanks, Brett. Thanks to everyone. There's a lot of people I have to thank in this

00:27:04.160 --> 00:27:06.960
community for this kind of stuff. Yeah. Do you have any extras?

00:27:07.760 --> 00:27:15.760
I do. Let us check them out. I think I only one extra. And that is last week I talked about the

00:27:15.760 --> 00:27:21.520
Shiny for Python Reactive Web Dashboard with Shiny. That course over at Talk Python, I said it

00:27:21.520 --> 00:27:27.120
was going to be available soon. It is now available 100%. You can go sign up for it and take that

00:27:27.120 --> 00:27:32.640
course. The course is completely free, no strings attached. So just click the link and take the

00:27:32.640 --> 00:27:36.960
course if you want to learn about building interactive dashboards a little bit, actually

00:27:36.960 --> 00:27:43.200
like the Solara stuff, but more full featured, I suppose, and a little more packaged, a little more

00:27:43.200 --> 00:27:49.440
like Streamlit in that sense. And then also I talked about working with PyCharm to get people

00:27:49.440 --> 00:27:54.480
six months of PyCharm Pro for free, as long as you don't already have an account that would have to

00:27:54.480 --> 00:27:59.840
renew. With this course, you could just go to your account page after signing up for this and get

00:27:59.840 --> 00:28:06.800
that as well. So two extras on one tab. How about that? Nice. Yeah. All right, Brian, I need you to

00:28:06.800 --> 00:28:12.000
put yourself in like a calm and centered place for what is coming next. Okay. Are you ready?

00:28:12.000 --> 00:28:18.000
This has been recommended to us. Oh my gosh, who sent it in? I'm so sorry, I don't have the name

00:28:18.000 --> 00:28:25.360
here. I don't. Cohen, I believe it was. If I got it wrong, I'll correct it next time. This is the

00:28:25.360 --> 00:28:33.040
Tao of programming. This is a big, long book here that covers many things, but I will, because we

00:28:33.040 --> 00:28:38.480
may come back to this, right? But I want to start with book one, The Silent Void, and just read you

00:28:38.480 --> 00:28:45.120
a few bits of it. And if you visit this webpage, folks, this is best viewed in Netscape Navigator

00:28:45.120 --> 00:28:53.280
4.0 or older, because it's got like the digital noise background and all sorts of like, whoever

00:28:53.280 --> 00:28:58.880
thought like this arts and craft paper was the proper background for reading, but here we are.

00:28:58.880 --> 00:29:03.120
Oh, and it also has a frame. There's a frame inside of it. So it's just missing the blank

00:29:03.120 --> 00:29:08.080
text. Nonetheless, here we go. Here's the introduction for the chapter. Thus spake

00:29:08.080 --> 00:29:12.560
a master programmer. When you have learned to snatch the error code from the trap frame,

00:29:12.560 --> 00:29:17.120
it will be your time. It'll be time for you to leave. So let me just read you a couple little

00:29:17.120 --> 00:29:23.760
sections from this. 1.1. Something mysterious is formed, born in the silent void, waiting alone

00:29:23.760 --> 00:29:30.080
and unmoving. It is at once still and yet in constant motion. It is the source of all programs.

00:29:30.080 --> 00:29:34.640
I do not know its name, so I will call it the Tao of programming. If the Tao is great,

00:29:34.640 --> 00:29:39.920
the operating system is great. If the operating system is great, the compiler is great. If the

00:29:39.920 --> 00:29:44.960
compiler is great, then the application is great. The user is pleased and there is harmony in the

00:29:44.960 --> 00:29:50.400
world. The Tao of programming flows far and returns on the wind of morning. Oh dear.

00:29:51.680 --> 00:29:57.600
I think it's a little cheesy. This one's good. I like this one too. This is the last one.

00:29:57.600 --> 00:30:02.400
The Tao gave birth to machine language. Machine language gave birth to the assembler. The

00:30:02.400 --> 00:30:07.760
assembler gave birth to the compiler. Now there are 10,000 languages. Each language has its purpose,

00:30:07.760 --> 00:30:13.120
however humble. Each language expresses the yin and the yang of software. Each language has its

00:30:13.120 --> 00:30:19.280
place within the Tao. But do not program in Cobalt if you can avoid it. And Fortran and

00:30:19.840 --> 00:30:24.880
Perl. Exactly. Anyway, this goes on and on. There's books of this stuff. People check it out.

00:30:24.880 --> 00:30:34.080
Oh, that is fun. Nine books. Exactly. Oh, dear. Well, that's the joke for today. If you will,

00:30:34.080 --> 00:30:39.520
it's the entertainment segment, Liz. I'm not sure it's a joke. Yeah. No, it's good. I like it.

00:30:39.520 --> 00:30:48.640
It's the meditation section, Brian. All right. So with that, I'd like to encourage everyone out

00:30:48.640 --> 00:30:55.760
there to send us good programming jokes because we're running dry. No, that was good. But also,

00:30:55.760 --> 00:31:00.400
yeah, I always love good programming jokes and dad jokes all together. So keep them coming.

00:31:00.400 --> 00:31:06.160
Yeah, they're always good. As always, really enjoyed talking with you. Enjoy talking with

00:31:06.160 --> 00:31:11.600
everybody in the community. And yeah, keep on coding and having fun. Thanks, Michael.

