00:00:00 Hello and welcome to Python Bytes, where we deliver Python news and headlines directly

00:00:04 to your earbuds. This is episode 135, recorded June 12th, 2019. I'm Michael Kennedy.

00:00:10 And I'm Brian Okken.

00:00:11 And I'm Max Sklar.

00:00:12 Yeah, welcome to the show. It's great to have you here.

00:00:14 Good to be here today.

00:00:15 You're here. You've got your own podcast, and we're definitely going to talk a little bit

00:00:18 about that at the end, and that'll be great. I do, before we kick things off, though,

00:00:21 I also want to say thank you to DigitalOcean for sponsoring the show. Check them out at

00:00:24 pythonbytes.fm/digitalocean. More about them later as well.

00:00:28 Okay, so Reuven Lerner, he's got an email list that I'm signed up to. One of the things

00:00:34 that he pointed out in one of the recent, I can't remember if it was on his email list

00:00:38 or if it was on one of his blog posts. So I'm linking to a blog post. But it's this idea that

00:00:43 I didn't even know you could do this. It's titled, why do Python lists let you do plus equals

00:00:49 or in place assign addition with a tuple? We can't do plus with a tuple. So here's the idea is you got

00:00:56 you got a list, and you want to add, combine the elements of a list and a tuple end up with a

00:01:03 list at the end. You can't just add them because they're different types. But you can do incremental

00:01:09 add. And it's just weird. I was like, I didn't know you could do that. But it turns out it's a

00:01:16 little surprising. But it just is because the plus equals is not, I always think of it as equivalent

00:01:22 to like x equal x plus equals one is the same as x equals x plus one. That's what I thought. But it

00:01:29 turns out it's actually a different, it's a different call. It's implemented as a different call. I see like

00:01:34 a different Dunder method, like a different magic method is being called. Yeah. And the Dunder method for

00:01:40 list increment or in place add is what it does is it takes any iterable on the right hand side,

00:01:46 and adds it one element at a time to the left side. So you can plus equals any iterable onto a list.

00:01:53 That's neat. I didn't know you could do that. That's cool.

00:01:56 This is so weird. I mean, it's cool. And it's it's fine that plus equals will do that. And I actually

00:02:01 just tried it. I created a list of a bunch of numbers. And then I plus equaled it with a string.

00:02:06 And now I have a list that's full of numbers and single characters that made up that string,

00:02:11 which is, which is, it's okay, if that's the behavior, and it seems actually like the most

00:02:15 reasonable behavior. But then why can't you just plus them, right? Like, it seems odd that it's

00:02:19 inconsistent. Plus, it seems like it should just create another list with that same behavior.

00:02:25 So yeah, not sure. Yeah, exactly. I assume there's a better way to turn a tuple into a list. But

00:02:31 now that I'm looking at this, you could just create an empty list and then do plus equals your tuple.

00:02:36 There you go. Your conversion. It's all it's all filled up. Yeah, it's definitely not the most

00:02:41 obvious way. Yeah, probably the initializer constructor of the list is best just pass it

00:02:46 the iterable. But yeah, this is interesting. Also, if the three of us didn't know you could do this,

00:02:52 probably don't do this in your code, because nobody will understand it. But it's interesting.

00:02:57 Yeah. Also, please don't put this in a job interview.

00:03:02 Yeah. Don't make this one of these things.

00:03:04 Oh, one of those questions that you mean an interview question?

00:03:08 Yeah, exactly. Like, what form of sort does a list use? What does a list plus a tuple mean? What

00:03:14 does list plus equals? No, this belongs in a Watt talk, not in a job interview.

00:03:19 Yeah, definitely.

00:03:21 I think this is interesting, because Python is mostly devoid of these like weird oddities,

00:03:27 right? It's mostly a pretty polished, simple, clean language. But yeah, this is weird.

00:03:31 Gary Bernhardt could incorporate this in a talk, I'm pretty sure. Nice. All right. Speaking of

00:03:37 jobs and growth and things that you might actually want to pay attention to or decide on, Max,

00:03:43 what's this next one you got?

00:03:44 This is an article called R versus Python. R is out of the top 20 languages, despite statistical

00:03:50 boom. And I know you guys have covered on the show before the whole R versus Python dynamic,

00:03:56 all these articles coming out. This is I'm not going to be anti R here, but even though I'm a Python guy.

00:04:02 So the article is about an index on the popularity of programming languages. And this organization,

00:04:07 TIOB does one. I know that there could be, I imagine that there's some controversy around

00:04:13 how to rank them. I'm just going to assume that they're doing a pretty good job. There's a few

00:04:17 stories here, a few headlines. The first is that like Python hit an all time high. It's now

00:04:21 language is at ranking number three on the chart. So it's just beats out, it beats out C++,

00:04:29 I believe for the first time, only Java and C are more popular than Python. And the other story is

00:04:36 that the statistical language R dipped to number 21. And so the speculation is that Python has sort

00:04:43 of taken over as the preferred statistical language to R. And then personally, I got into Python because

00:04:48 I kind of came at data science and ML from a software development perspective. I took CS, I learned C and

00:04:56 Java. And so going over to Python was came a lot more naturally to me than going over to R.

00:05:01 If you were say a statistician, maybe, maybe coming from R makes more sense, right? Or from MATLAB or

00:05:06 something like that, right?

00:05:07 Yes, yes. And I have worked with and met people who do that. And they have probably extra skills that I

00:05:14 don't have, like they could do certain things a lot faster. So again, I'm not like anti R, but I'm just,

00:05:19 I think from the programmer's perspective, Python is a lot nicer for some people, people like me.

00:05:25 So personally, I'm going to stick with Python, because there's so many statistical libraries that

00:05:29 even I have yet to learn, and it's served me very well thus far. And then the third thing I wanted to

00:05:33 point out the language that I use most in the recent years in is Scala. And that's surprisingly down

00:05:38 to 31, which I looking at companies around here in New York at like startups, there's a lot that use

00:05:43 Scala. So I was surprised it was that low. But Well, I feel like Scala and those functional languages, they tend to be very popular in the

00:05:51 financial space, right?

00:05:52 Maybe, yeah.

00:05:53 You definitely are in the center of that and being in New York, right?

00:05:56 Yes, but a lot of, you know, Foursquare, where I worked for a long time was Scala based,

00:06:00 Twitter. So there's a lot of companies like that, social media, consumer app companies that use it.

00:06:06 So why do you think this is? Why do you think Python is? I mean, you talked about why you were

00:06:12 more comfortable with it, but it's a general trend. Even people who are scientific are taking up Python

00:06:18 at much larger numbers. Why do you think that is?

00:06:19 When companies actually want to apply machine learning or statistical methods to their data,

00:06:25 they already have a lot of engineers and developers. And if you already have people who are

00:06:33 fluent in Python, then why not use Python? Python has a lot of great libraries,

00:06:38 NumPy is really great. And then a lot of the more sophisticated machine learning libraries are

00:06:44 really great. So there's too many benefits, I think.

00:06:47 Yeah, I definitely agree with that. I think another one has to do with the fact that Python

00:06:51 is a full spectrum language. Like, I can come with a very partial understanding of what Python is and

00:06:57 what it does. And I can still be productive. If I know how to pip install a thing, write code,

00:07:01 I don't even know what a function or a class is. I can do amazing. I could spin up a machine learning

00:07:06 model and do something with it, right?

00:07:07 Yeah.

00:07:08 But at the same time, that piece can grow and grow into a fully distributed application or something

00:07:14 like that, right? There's not many languages that start that simple. And yet, most of the simple

00:07:20 languages, they top out. And you say, well, now you go do C++. I hope you like templates. Good luck.

00:07:25 Yeah.

00:07:25 I'm still stumped as to why Java is at the top.

00:07:28 That is a good question.

00:07:31 You know what I think?

00:07:32 Probably a lot of legacy.

00:07:33 Yeah, I think that that's true. And I think the legacy is in two places. I think if you care

00:07:38 about open source, but you want a compiled modern language, Java is a pretty good choice. Like,

00:07:44 you know, C#, C++, those are also good. But C++ doesn't have garbage collection and C#

00:07:50 is tied to Microsoft, right?

00:07:52 So, I can see that that's one of the things. I also think the academics, Stanford and Carnegie

00:08:00 Mellon and all that stuff, very much for many, for a long time, taught Java, Java, Java as the

00:08:06 way to do things. And so, the folks at the high end of decision making probably had that experience

00:08:12 as well. So, I don't know. That's my theory.

00:08:14 Okay. I'm not sure if there's this article or another one related to this that predict,

00:08:19 I don't know if you already covered this, that predicted that Python will be at the top

00:08:23 within like four years.

00:08:24 Yeah, that it's going to surpass Java and C.

00:08:26 Yeah.

00:08:27 I mean, just look at the growth curves, right? Some are either flat or downward and Python

00:08:30 is like highly up. So, pretty awesome. Very cool to be working in the Python space. It's exciting.

00:08:35 Like every day is super exciting.

00:08:37 If, like we said, Java is very popular because of, you know, there's a lot of legacy code written

00:08:43 in Java, but new projects, I don't know if there's another score for new projects, but I assume that

00:08:49 Python is way higher.

00:08:51 Yeah, that's probably, it probably is. I don't know where to find that either, but it'd be cool to have

00:08:54 that data.

00:08:55 Yeah.

00:08:55 Speaking of exciting, Max, what OS do you use?

00:08:57 I'm on macOS.

00:08:58 Yeah. So, so am I. So is Brian. Even though the majority of Python developers are on Windows,

00:09:02 we happen to all be there. So, we can all appreciate this next one that's coming here.

00:09:06 So, I recently watched the WWDC and somehow I didn't notice this or they didn't announce it.

00:09:13 It was just in the fine print, but Dan Bader from RealPython sent this over and there was an

00:09:18 announcement, at least in the release notes for the new macOS. What is it? Catalina? Something like

00:09:23 that. Whatever their name is it for the new macOS, the one that replaces Mojave. It is deprecating

00:09:29 Python too. So finally, you know, finally we have like a super old version of Python running in macOS.

00:09:35 And if you type Python, you get Python too. It doesn't ship with Python 3. Ideally, I would

00:09:41 love to see Python 3 shipping. I kind of like what the Windows store and Microsoft is doing

00:09:47 as an app that is auto updating and stuff like a really nice way to get it there. Instead,

00:09:52 they're just saying, we've decided that Python and all the scripting runtimes, so Perl and Ruby and

00:09:58 Python, those are not our problem anymore. We're washing our hands of them. That's the announcement.

00:10:02 We are no longer recommending them. It is deprecated. We have to leave Python 2 there

00:10:08 because stuff is depending upon it, but we do not recommend you use it at all, period. Find another

00:10:14 way to get it there.

00:10:14 Yeah, that is interesting.

00:10:15 Yeah. So on one hand, like that's good news. They're like, please don't, I know it has Python

00:10:20 on it, but this is a broken old one. Don't use that. I feel like there's maybe some better way

00:10:24 they could approach that. I don't know if there'll be some kind of warning when you run it.

00:10:28 That would be great, but it does make it actually harder to get the right version of Python onto your

00:10:35 system. Like if you want to use homebrew, brew install Python, installs Python 3, but you know

00:10:40 what brew runs on? Ruby, I believe, something like that. It depends on one of these things.

00:10:45 So that's also, so like, if that's also not there, then how do you brew? And like,

00:10:49 so there's a bunch of interesting changes here, but I do think it's interesting that

00:10:53 Apple and the macOS team are addressing this Python story. What do you guys think?

00:10:57 Yeah. Well, when did Python 3 come out? If you could remind me, was it?

00:11:02 2008.

00:11:02 Wow.

00:11:03 But in realistically, I feel like 3.4 is where it really started to get traction. And that's

00:11:09 more like 2012-ish, something like that.

00:11:12 Okay. Yeah. I'm just, now I'm thinking, oh God, I have some scripts in my GitHub that I may need,

00:11:18 may want to, that I built like five years ago. I may want to upgrade.

00:11:21 I think it's a good thing, actually. I think it will be a good thing because

00:11:25 people that just open up a terminal on Mac and type Python, they get 2.7 and that's not the right

00:11:32 answer. So.

00:11:33 Yeah.

00:11:34 Yeah. And I've seen this where you always have two versions of Python on your machine.

00:11:38 And there's always, did this the other day where you run the old version of Python and it doesn't

00:11:44 work. And you're like, oh, I called the wrong command and it would be nice to kind of put an end

00:11:50 to that. So it doesn't waste people's time.

00:11:52 Yeah, absolutely. I'm tempted to put an alias to alias Python to Python 3 inside my startup script.

00:11:57 Yeah.

00:11:58 That's a good idea.

00:11:59 Interesting. Well, I would like a better outcome, but at least there's some kind of like Apple

00:12:05 acknowledges how out of date the stuff they're shipping is. So that's pretty cool. Now, before

00:12:10 we get onto the next one, I want to talk really quickly about DigitalOcean. They've been a huge

00:12:14 supporter of the show and we really appreciate that. Our infrastructure runs on DigitalOcean,

00:12:18 which is pretty cool. So we can definitely recommend it from someone who's using it. Right.

00:12:24 And I want to highlight their hosted database as a service right now. So if you want to use

00:12:30 Postgres SQL, which is probably the most popular relational database these days in the Python space,

00:12:36 you know, you look at the Stack Overflow survey and stuff like that. It's got a lot of love

00:12:41 and people love it a lot. So they have hosted as a service. Just go there and say,

00:12:45 I want Postgres. Turn it on. Here's the connection string. They'll do all the backups

00:12:49 and scaling and failover and all that stuff for you. So super great. Check them out at

00:12:53 pythonbytes.fm/DigitalOcean. And for new users, you get a $50 credit to get started,

00:12:58 which is also cool. Brian, would you say that dictionaries are important in Python?

00:13:03 Yeah, definitely. The whole thing's built on dictionaries. It's turtles all the way down.

00:13:07 Exactly. It's turtles all the way down. It's dictionaries all the way down.

00:13:10 So what's up with this one?

00:13:11 This is just a small article from L. Swigert, Pythonic ways to use dictionaries. And I thought

00:13:17 it was a good reminder because dictionaries really are not, I mean, they're not hard. They're not hard

00:13:22 to use. People coming from, I guess I came from Perl before Python. So I was used to, I guess,

00:13:28 what were they called in Perl? Hashes.

00:13:30 Yeah. Hashes and hash maps and all these things, right?

00:13:33 Yeah. Dictionaries are a lookup thing. And using them like that is not that hard. But there's some

00:13:39 gotchas in there that some people try to do weird things to work around them. So this is just a

00:13:45 highlight article that a few ways to use them smartly. One of them is to use the get function for,

00:13:51 if you try to retrieve an element out of a dictionary and the element isn't there, that the key isn't

00:13:56 isn't there, you get a, I don't know, a lookup error or something.

00:14:00 A key error.

00:14:00 A key error. But if you know it might not be there, so you can check beforehand or you can just use the

00:14:06 get with a default. And the default value will return something other than if it's not there,

00:14:12 it returns something else.

00:14:13 That's the primary way that I get stuff out of dictionaries these days. I used to do square

00:14:17 brackets, but I don't do that anymore. It's always about .get.

00:14:19 Yeah, me too.

00:14:20 I do that as well, especially since almost every dictionary is either, you know, something like

00:14:27 a histogram or a sum of something where, you know, the default's always going to be zero. And

00:14:32 I don't want to distinguish between that and it not being there.

00:14:35 The key for me is almost always there's other kinds of validation you have to do anyway.

00:14:42 So I'm thinking of the web, right? Like I want to get something posted on a form.

00:14:45 I want to get the, say the email they've submitted. I want to know that it's there,

00:14:50 but I also got to make sure that it's not empty or it's not none. Like if I'm already doing the

00:14:54 if test, I don't want to do the conditional test and a try except you might as well just do one.

00:14:59 The only one that's going to work is the if. So just use get.

00:15:02 The set default actually was something I didn't even know was there, which I learned something new.

00:15:07 I don't use that normally, but.

00:15:09 What does that do?

00:15:10 Set default will only set the value if the element does not exist yet.

00:15:16 Yeah, that's perfect. Yeah, it makes a lot of sense.

00:15:17 So like their example, his example and the thing is perfect is if you're storing a counter or something like a number of hours

00:15:23 and you just want to increment, if you're trying to increment something, you want to set it to zero to begin with,

00:15:29 but you only want it to set it to zero if it isn't there already.

00:15:32 So that makes sense.

00:15:33 Yeah. Yeah. Perfect.

00:15:35 So you don't have to do that test.

00:15:36 Then it also talks about using dictionaries as a switch statement, which I thought was a funny language hack.

00:15:41 I actually went and created a switch statement for the language in Python.

00:15:45 It's on GitHub.

00:15:46 And it's really nice.

00:15:47 I use it in some of like some really gnarly code that has got like 50 or 100 cases.

00:15:53 And, you know, it's just a lot nicer because it'll do things like not let you have the same key twice, for example, things like that.

00:16:00 So you do use it?

00:16:02 Oh, yeah. I use it. I love it.

00:16:03 It's like, I think it's great.

00:16:04 It uses a width block.

00:16:06 So it uses the width block as the switch block, basically.

00:16:10 And then you just have cases in there.

00:16:11 Anyway, it's kind of funky, but I'll put a link into it.

00:16:15 But I do think it's interesting that dictionaries can be used for switch statements.

00:16:18 Yeah.

00:16:19 I think it's good to comment because not everybody's going to understand what's going on.

00:16:24 So make a comment about what your code's doing.

00:16:26 Yeah. Yeah, for sure.

00:16:27 All right, Max, what's this next one you got?

00:16:29 All right.

00:16:30 Short article I found.

00:16:32 Things you're probably not using in Python 3 but should.

00:16:35 This is from datawhatnow.com.

00:16:37 So this is particularly relevant for me because I used Python legacy at four square for many years.

00:16:42 Now I'm coming back to it, taking another look at V3 over the last couple of years.

00:16:47 So just a couple of things it has that stood out for me.

00:16:51 One that looks very useful is f-strings, where you can put the variable name in braces in a string and just have it replaced.

00:16:57 So long as you remember to put the character F before the string.

00:17:01 That's very important.

00:17:02 So I've seen things like this in other languages.

00:17:05 Scala has it.

00:17:06 PHP, most front-end scripts have things like this.

00:17:09 It makes the code very readable.

00:17:10 Except I know myself.

00:17:12 I know I'm going to screw up by leaving out that straight F in front of the string.

00:17:16 So I almost feel like it should be automatic.

00:17:19 But it is very useful.

00:17:20 Yeah, I feel the same way.

00:17:21 I'm always like I'm halfway through writing a string.

00:17:24 And I'm like, oh, I should have put the F at the front.

00:17:26 Well, now I'm just going to do a format on the end.

00:17:27 Because with my editor, I type dot and F and it auto completes format.

00:17:31 So it's just we're just going to keep rolling.

00:17:33 You know what I mean?

00:17:33 Like it's one of these things that is really nice.

00:17:36 But you got to be a little cognizant up front, right?

00:17:39 Yeah.

00:17:39 If you're correct, it looks very good.

00:17:41 And actually, we did some things at Foursquare.

00:17:44 And this was for Scala code where we had like GitHub hooks that looked to see, hey, this is a formatted string.

00:17:52 And if you were trying to check in code, that was a formatted string.

00:17:55 But you didn't actually put, I think in Scala, there was an S in front of it or something.

00:18:00 If you didn't actually format the string, it's like, okay, this is probably an error.

00:18:04 You probably shouldn't be checking this in.

00:18:05 Oh, interesting.

00:18:06 That's sort of a workaround.

00:18:07 Yeah, it was helpful.

00:18:09 But yeah, it'd be nice to have the language.

00:18:10 But just having the formatted strings is always helpful.

00:18:13 Another thing I didn't know that Python 3 had is enumerations.

00:18:17 You know, again, with the functional programming, I've been using enums for years.

00:18:21 They tend to make code way more readable, in my opinion.

00:18:25 And so that was good to know.

00:18:28 I'll keep that in mind when developing in Python 3.

00:18:30 Nice.

00:18:30 I love the discoverability that enums give you, right?

00:18:32 You can say enumy thing dot.

00:18:35 And then there's a list of things.

00:18:36 You don't have to go research like, well, what values can I pass for level?

00:18:40 Is it one, two, three?

00:18:41 Is it a zero to one?

00:18:42 And it's like low, medium, high.

00:18:45 Pick one.

00:18:45 Yeah, yeah.

00:18:46 And they're reusable.

00:18:47 And oftentimes, you know, I could look at an enum and figure out, oh, I know what this,

00:18:52 you know, I know what this code is doing without having to really read tons of comments or really work through.

00:18:59 No, if I see your enums, I kind of know what you're doing.

00:19:01 Yeah, I feel like that's underutilized in general.

00:19:04 Brian, what do you think?

00:19:05 Definitely underutilized by me.

00:19:07 I mean, it's one of those things that I've, it's on my list to try to use more.

00:19:10 I don't use magic numbers too much, but I mean, we do have cases where it's, I just use a string, but it really ought to be an enum instead of a set of possible strings.

00:19:22 Yeah, for sure.

00:19:23 Cool.

00:19:24 Well, I think, you know, one of the themes of the show today is that modern Python is definitely making its way past legacy Python, right?

00:19:33 Python 3 is coming on strong.

00:19:35 And if you look at what the real challenge, I think there's a lot of things that made this move a little bit difficult.

00:19:41 But if you look at the heart of it, really the heart of what made the Python 2 to 3 migration challenging were strings, right?

00:19:50 So the fact that strings used to be the same as bytes and you could either treat it as like a byte list or actually an encoded string and you had to kind of know, that was a problem.

00:20:00 But it was also an opportunity to have simpler code like requests, for example, could talk to the network differently than it has to now because it doesn't have to like do the encoding and all these changes, right?

00:20:10 But it's important that we have emojis and support other languages that have umlauts and things like that.

00:20:15 So having a Unicode is really important.

00:20:18 But I do feel like if you look at all the stuff, like people say, oh, Python 3, I can't move to that.

00:20:23 That's so, it sounds like a, you know, like a huge problem.

00:20:27 It's going to be so hard.

00:20:28 But then when you look at the code, like how hard is it to write Python 2 code that's compatible with 3?

00:20:33 It's like not very different.

00:20:35 But one of the big differences is strings.

00:20:37 So what's interesting is that I want to cover, this comes from James Small.

00:20:41 He sent over an episode of the CppCast, which is a C++ podcast.

00:20:47 I think one of the bigger ones.

00:20:49 I don't really know all of them.

00:20:50 But I definitely know of that one.

00:20:52 And Herb Sutter, who was instrumental in C++, he was interviewed there.

00:20:58 And the interviewers asked, if you could go back and change C++ types, what changes would you make?

00:21:06 And so on.

00:21:07 And basically, the answer was almost exactly what happened going from Python 2 to 3.

00:21:11 Yeah, that was interesting.

00:21:13 Yeah, pretty interesting, right?

00:21:14 So if it was possible, the C++ guys very well may have done exactly what we did to go from Python 2 to 3.

00:21:20 And it was like, we're going to take strings and split them into Unicode characters and byte arrays and things like that.

00:21:26 And so, I don't know.

00:21:27 I feel like if that's really the essence of what is holding back people switching from 2 to 3, I don't know.

00:21:33 It just doesn't seem like that's that big of a deal.

00:21:35 I know if you're writing requests or you're writing stuff that literally is a web server and you're talking on the network, okay, that's kind of a bigger deal.

00:21:43 But in general, it doesn't seem like it's that big of a deal.

00:21:45 Yeah, the big deal was that the Python, I think, from my perspective, that the Python strings used in 2 matched the idea of a character array in C.

00:21:57 And so all of the DLLs that some packages interacted with could just interact with it directly.

00:22:04 And if you were interacting with bytes, you were already doing something funky anyway.

00:22:08 But now you have to split that up.

00:22:10 And sometimes, you know what it's like working with C.

00:22:13 Sometimes you're using a character array, but it's really not characters.

00:22:17 It's really bytes.

00:22:18 And so separating that out of when they were really strings and when they were just byte arrays, yeah, it's messy.

00:22:24 Yeah, it's definitely messy.

00:22:26 So I haven't used Python for the purpose of byte arrays before.

00:22:30 Most of my Python codes have been scripts.

00:22:35 I haven't used it for web services.

00:22:37 So is this something that's very common?

00:22:38 And I have used, you know, Cython.

00:22:41 So is that does that make use of strings as byte arrays?

00:22:44 Or am I overthinking this?

00:22:45 I think in Cython, they have their own types for these types of things.

00:22:50 I'm not 100% sure, but I think so.

00:22:51 Like you could have pointers in Cython and stuff like that.

00:22:54 In terms of so you know, basically, now we have strings and we have lists, right?

00:23:00 But lists are not at all like byte arrays, right?

00:23:03 I can't pass that off to C as a contiguous block of memory of like similar data, right?

00:23:08 But you can actually create arrays that are typed.

00:23:10 I can say I have like arrays that hold bytes or arrays that hold integers.

00:23:14 And there's some...

00:23:15 You could do that in Python.

00:23:16 I forget exactly what module you got to use to do it.

00:23:20 But there's some way to say like I have this homogeneous thing that I'm creating.

00:23:24 Like it's something I've extremely rarely have done.

00:23:27 So I forgot the steps of it.

00:23:29 But yeah, there's some mechanism in there to do that.

00:23:32 Yeah.

00:23:32 And you can prefix a string with the B character in it.

00:23:35 And then you can put byte codes inside of it for constants.

00:23:39 That doesn't sound so bad.

00:23:41 Although the prefix strings are...

00:23:43 There's only 26 of them.

00:23:44 So we'll see.

00:23:45 We know there's an F and a B.

00:23:46 So...

00:23:47 Oh, we could probably put an OXU114 as a prefix.

00:23:52 Yeah.

00:23:52 Yeah.

00:23:52 So I don't know.

00:23:53 I guess when I was thinking about this, like the idea is pretty straightforward.

00:23:57 But I'm just wondering like, you know, could the PSF...

00:24:01 It just got me thinking about the whole transition from two to three.

00:24:03 Like could the PSF been more proactive and strategical?

00:24:08 Like could the PSF said, hey, it's super important we make this change.

00:24:11 It looks like these seven libraries are the foundation of all the other libraries that are all stuck on Python 2 because none of these are changing.

00:24:20 Could we just raise $200,000, hire some people and just in three months upgrade all these libraries and just be done with it?

00:24:28 Like how would the world look different if like there was a quick and focused response to like this challenge?

00:24:35 Right.

00:24:35 Because I feel like the actual problem that most people hit was the library I care about doesn't support Python 2.

00:24:40 That library actually...

00:24:42 Sorry, three.

00:24:42 That library only supported Python 2 not because that's what it wanted but because the library it was based on only supported 2.

00:24:49 It was like this sort of chain and like the lowest level pieces were getting everyone stuck.

00:24:54 So I don't know.

00:24:55 It's interesting.

00:24:56 There's so many corner cases that like for instance, the hiccup for me was it was one library and it was one...

00:25:04 It was because the DLL that the library is a thin wrapper around a DLL and that DLL interaction was all this...

00:25:14 The different ways...

00:25:15 This character pointer type thing, yeah.

00:25:16 Yeah, but it's on top of that, one of the hiccups wasn't just because of this.

00:25:21 It was also because the way that Python libraries interact with DLLs, that changed completely also from 2 to 3.

00:25:29 Yeah.

00:25:30 Okay.

00:25:31 Interesting.

00:25:31 Yeah, the C extensions and stuff like that, huh?

00:25:33 Yeah.

00:25:33 So the library that I needed was...

00:25:35 That was just some complicated beast that a university in Germany finally had some people that converted it to Python 3.

00:25:44 So...

00:25:44 Okay.

00:25:45 Well done.

00:25:46 Well done, academia.

00:25:47 Well done.

00:25:48 Nice.

00:25:49 All right.

00:25:49 Well, that's our main topics today.

00:25:51 I want to just throw out, see if you all have a couple of extras, real quick things to touch on.

00:25:56 I do want to bring up this thing that Devo Kaplan sent over.

00:26:00 He was listening to one of our episodes.

00:26:01 I don't remember what we were even talking about, Brian.

00:26:04 It was something crazy about what happens when you pip install a thing, maybe running some code as part of the setup UI and so on.

00:26:12 And so he said, all right, well, let me see if I can create something that's kind of funny and amusing based on what we've been talking about.

00:26:18 So he created a package called Mystery.

00:26:21 Okay.

00:26:22 This sounds like a Russian roulette type situation.

00:26:25 Yes, it does to me too.

00:26:26 So if you pip install Mystery, it will then go and randomly pick something else out of PyPI, out of the package index, and then install that.

00:26:34 So you never know what you get.

00:26:35 You can just pip.

00:26:36 It's going to be a mystery.

00:26:39 I don't actually recommend using this in production, by the way.

00:26:42 Well, it would be fun to give a try.

00:26:45 It could be – you could be installing NumPy or NumPy.

00:26:49 We had – I've always thought about which one to describe.

00:26:52 Or it could be something that totally changes the language or something that takes 10 hours to install.

00:26:58 You never know.

00:26:58 Yeah.

00:26:59 Maybe do it in a virtual machine that you can erase later.

00:27:01 Yeah.

00:27:01 Also, I just want to give a shout out to the book that I released, the Effective PyCharm book, and point out that if people are interested in the PyCharm course and or the PyCharm book, if you go to EffectivePyCharm.com, Matt Harrison and I are running a bundle deal so you can get the course and the book discounted together.

00:27:20 So check that out.

00:27:21 And people, if they've already bought the course or they bought the bundle, just shoot me a note and I'll give you the discount towards as – because you maybe bought it before this existed.

00:27:28 So check that out.

00:27:29 That's awesome.

00:27:29 Yeah, thanks.

00:27:30 Brian, how about you?

00:27:32 What you got?

00:27:32 Just really quickly, the Python 3.8.0 beta 1 is out.

00:27:37 So if you're a package supporter, please go test your package and make sure that – that sounded weird – but go test your code to make sure that it works with Python 3.8.

00:27:47 That's super new.

00:27:49 So this is beta 1, right?

00:27:50 This is a big deal.

00:27:51 It's like the first feature freeze.

00:27:52 Yeah.

00:27:53 Yeah.

00:27:53 Cool.

00:27:53 Max, how about you?

00:27:56 All right.

00:27:56 Well, thanks for letting me talk about my own podcast, which is called The Local Maximum.

00:28:01 Of course.

00:28:01 It's a good one.

00:28:02 I've listened to it.

00:28:03 It's high quality.

00:28:04 I definitely like it.

00:28:05 Tell people about it.

00:28:05 Yeah.

00:28:06 Very cool.

00:28:06 Well, it's a weekly tech podcast, and so I cover both the theoretical issues in probability theory, philosophy, and machine learning, but then I kind of apply it in a practical way to things like current events and product development and interviews.

00:28:19 And I do some like opinion piece type stuff as I did this week.

00:28:24 So, for example, a few weeks ago, my co-host asked a question, how do you estimate the probability of an event that has never occurred?

00:28:32 And so, you know, we dove into that question.

00:28:35 And I started with, well, every event has never occurred, but what are you really asking me here?

00:28:39 And some of the news that we've dived into recently is Apple's decision to break up iTunes, what that means in terms of product development, you know, how the internet is shaping up in places like Cuba.

00:28:51 I find that stuff.

00:28:52 I find that stuff really interesting.

00:28:54 And the controversy around YouTube's recommendation algorithm.

00:28:56 I also talk a lot about data science careers.

00:28:59 And I interview people like Hillary Mason here in New York and Mark Senadella, who's the CEO of the ladders.

00:29:05 He critiqued my resume on my podcast.

00:29:08 That was very fun.

00:29:08 That's a little stressful, huh?

00:29:10 Yeah, he had me rewrite my resume.

00:29:12 So, yeah, there's probably something for everybody.

00:29:17 It's the type of thing.

00:29:18 I don't know if it's – I don't know if there's anyone who's into it every single week or if most people kind of skip around.

00:29:27 But either way is cool with me.

00:29:29 Yeah, it's cool.

00:29:29 I like that it's technical but not, you know, deeply technical.

00:29:34 You can kind of make it casual listening too.

00:29:36 Yeah, yeah.

00:29:36 Nice.

00:29:37 All right.

00:29:37 Well, I have a quick joke for you guys.

00:29:40 And then Brian has an idea for something completely different.

00:29:43 So, you know, Brian, they say there's only two hard problems in computer science, right?

00:29:47 Yeah.

00:29:48 Tell me what they are.

00:29:48 It's cache invalidation, naming things, and off by one errors.

00:29:51 I love that joke.

00:29:54 Yeah, that's a good one.

00:29:55 All right.

00:29:56 So, I think you need to give a short explanation.

00:29:59 There's also off by two errors.

00:30:00 That's right.

00:30:01 I think you need to give an explanation for what is about to come because it actually is something completely different.

00:30:08 Why are we going to do what we're about to do?

00:30:09 Okay.

00:30:10 So, the Python 3.8.0 beta 1 release notes, I was skimming down this.

00:30:16 And there's some pretty exciting stuff there.

00:30:18 So, I'm excited to try it out.

00:30:19 But at the bottom, it says, and now for something completely different.

00:30:24 And then it has like a skit from, it looks like a little snippet of an interview from some of the Monty Python people.

00:30:32 Yeah.

00:30:33 And just, I suspect most people know, but for those of you who don't, Python has nothing to do with a snake in its naming.

00:30:39 It comes from Monty Python.

00:30:41 That's what Guido got the inspiration from, right?

00:30:43 Yeah.

00:30:43 Even though all the logos are snakes, nobody knows why.

00:30:46 Yes, I know.

00:30:46 They should be cheese or something.

00:30:48 I don't know.

00:30:48 We should change our logos to like cheese and maybe a knight with no legs.

00:30:51 Yeah.

00:30:51 Yeah.

00:30:52 Rabbit.

00:30:52 Killer rabbit.

00:30:53 Oh.

00:30:54 Get the holy hand grenade out there.

00:30:56 All right.

00:30:57 So, now for something completely different.

00:30:59 Yeah.

00:30:59 I thought we could read this skit out.

00:31:01 So, are you guys ready?

00:31:02 Let's do it.

00:31:03 I'll try to do it with feeling, but I'm not very good with accents.

00:31:06 So, we'll see what happens.

00:31:08 Okay.

00:31:09 This is entirely in rehearsal.

00:31:10 Let's do it.

00:31:11 Okay.

00:31:11 So, who'd have thought 30 years ago that we'd all be sitting here drinking Chateau de Chasselet

00:31:16 wine?

00:31:17 Aye.

00:31:17 In them days, we'd be glad to have the price of a cup of tea.

00:31:21 A cup of cold tea.

00:31:22 With milk.

00:31:24 Without milk or sugar.

00:31:25 Or tea.

00:31:26 In a filthy crack cup.

00:31:27 We never used to have a cup.

00:31:28 We used to drink tea out of a rolled up newspaper.

00:31:31 The best we could manage was to suck on a piece of damp cloth.

00:31:35 But you try and tell the young people today that they won't believe you.

00:31:38 No.

00:31:39 Nope.

00:31:39 Nope.

00:31:39 Nope.

00:31:40 Not at all.

00:31:40 Okay.

00:31:43 All right, folks.

00:31:43 That was literally at the end of the official release note for Python 3.8.

00:31:47 So, pretty cool.

00:31:48 Good read through, people.

00:31:49 All right.

00:31:50 Max, thank you for joining us, Brian, and me on the show today.

00:31:53 It was fun to have you as a guest.

00:31:54 Thank you so much for having me.

00:31:55 Thanks.

00:31:56 This was a lot of fun.

00:31:56 Yep.

00:31:57 You bet.

00:31:57 Brian, thanks as always.

00:31:58 See you later.

00:31:58 Yep.

00:31:59 Thank you.

00:31:59 Bye.

00:31:59 Thank you for listening to Python Bytes.

00:32:01 Follow the show on Twitter via at Python Bytes.

00:32:04 That's Python Bytes as in B-Y-T-E-S.

00:32:07 And get the full show notes at pythonbytes.fm.

00:32:10 If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:32:14 We're always on the lookout for sharing something cool.

00:32:17 On behalf of myself and Brian Okken, this is Michael Kennedy.

00:32:20 Thank you for listening and sharing this podcast with your friends and colleagues.

