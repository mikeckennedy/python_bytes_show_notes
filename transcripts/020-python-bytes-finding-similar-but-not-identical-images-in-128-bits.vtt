WEBVTT

00:00:00.001 --> 00:00:08.940
Hello and welcome to Python Bytes. This is episode 20 where we are delivering Python news and headlines directly to your earbuds.

00:00:08.940 --> 00:00:10.400
I'm Michael Kennedy.

00:00:10.400 --> 00:00:11.460
And I'm Brian Ockin.

00:00:11.460 --> 00:00:18.700
And we've got a bunch of stuff lined up for you today. I'm really excited to share, especially this first article, which is so clever that you chose, Brian.

00:00:18.700 --> 00:00:25.140
Before we do, I want to say thank you. Thank you to Rollbar, who's back to sponsor a bunch more Python Bytes.

00:00:25.140 --> 00:00:28.100
And we'll talk more about Rollbar later, but thanks, Rollbar.

00:00:28.100 --> 00:00:28.720
That's awesome.

00:00:28.720 --> 00:00:33.840
Yep. So we were just talking about pictures. Like I have many gigabytes of pictures.

00:00:33.840 --> 00:00:41.600
And if you ran a website that accepted uploads in large numbers of pictures, how do you deal with all that data?

00:00:41.600 --> 00:00:43.960
Especially there's probably a lot of duplicate data, right?

00:00:43.960 --> 00:00:49.680
I'm not sure. And so this is an interesting article. There's an article from jetsetter.com.

00:00:49.680 --> 00:00:53.180
And they're an invitation-only travel community.

00:00:53.440 --> 00:00:58.980
But the article is duplicate image detection with perceptual hashing in Python.

00:00:58.980 --> 00:01:01.560
And that actually sounds more...

00:01:01.560 --> 00:01:03.680
Perceptual hashing. That's awesome.

00:01:03.680 --> 00:01:05.860
Perceptual hashing. It's awesome.

00:01:06.320 --> 00:01:12.040
And the idea is they've got... I mean, the site's got a bunch of pictures of different places around the world.

00:01:12.040 --> 00:01:17.080
And they don't want pictures that are mostly close to each other.

00:01:17.080 --> 00:01:20.160
I mean, for family photos, you got a ton that are close to each other.

00:01:20.160 --> 00:01:21.780
But I get for like...

00:01:21.780 --> 00:01:24.780
There's a lot of cases where you don't want things that are almost the same.

00:01:24.940 --> 00:01:31.320
Right. Like pictures of hotels or pictures of a marina to say, here's the view out of the hotel.

00:01:31.320 --> 00:01:38.800
Like if they're going to have a listing on like some location of some hotel and they ask people to upload them, they don't need like 100 ones from this one view.

00:01:38.800 --> 00:01:43.380
And if you check out jetsetter.com, it is an intensely photo-heavy site.

00:01:43.380 --> 00:01:46.420
Like I'm pretty impressed with the number of photos on that page.

00:01:46.420 --> 00:01:50.720
With the idea of perceptual hashing, I was definitely interested in reading about this.

00:01:50.720 --> 00:01:54.020
And I expected it to be a fairly complicated algorithm.

00:01:54.020 --> 00:01:56.560
But it's actually ingenious.

00:01:56.560 --> 00:01:57.660
And it's a...

00:01:57.660 --> 00:02:00.220
They use Python and get...

00:02:00.220 --> 00:02:03.620
Transfer the image down to just a 9x9 square.

00:02:03.620 --> 00:02:04.820
I don't get...

00:02:04.820 --> 00:02:05.780
Of gray values even.

00:02:05.780 --> 00:02:07.800
I don't get how that's enough information.

00:02:07.800 --> 00:02:14.460
But it is apparently enough to determine whether or not an image is close to another image.

00:02:15.120 --> 00:02:16.440
And they do a delta.

00:02:16.440 --> 00:02:18.200
I'm not going to be able to...

00:02:18.200 --> 00:02:19.580
Can you explain that much better?

00:02:19.580 --> 00:02:20.320
I can try.

00:02:20.320 --> 00:02:28.600
I mean, when I read, we take a 5 megapixel image and we generate a 128-bit hash.

00:02:28.600 --> 00:02:30.100
And that means a thing.

00:02:30.100 --> 00:02:31.140
Like that means uniqueness.

00:02:31.140 --> 00:02:34.180
Or actually it means similarity, which is actually more important.

00:02:34.180 --> 00:02:36.620
I was like, okay, I have to figure this out.

00:02:36.620 --> 00:02:42.460
And I guess what they do is they take a large image and they like average it down to a 9x9.

00:02:42.540 --> 00:02:46.100
They say for larger images, like a 17x17 image.

00:02:46.100 --> 00:02:54.220
And to determine the similarity, maybe somebody's off by 5 feet to one side or the other to take a picture of a hotel or a view or something.

00:02:54.220 --> 00:03:01.980
But if you kind of average it down to that 9x9, that's where the similarities kind of collapse into those grids.

00:03:01.980 --> 00:03:04.880
And then they run an algorithm on that grayscale grid, right?

00:03:04.880 --> 00:03:05.360
Yeah.

00:03:05.360 --> 00:03:12.640
And then the interesting thing is that, of course, it's clear to me that you could come up with a hash algorithm for an image.

00:03:12.640 --> 00:03:19.580
But the difference in the hashes is enough to tell you how close the image is.

00:03:19.580 --> 00:03:19.780
Yeah.

00:03:19.780 --> 00:03:27.220
And it's actually the opposite that really blows me away is like two similar images that are not the same generate the same hash.

00:03:27.220 --> 00:03:28.440
That's what's the magic.

00:03:28.440 --> 00:03:29.860
Like that totally blows my mind.

00:03:29.920 --> 00:03:35.880
I could see like, well, obviously hash is different, images are different, but images are similar, not the same, hash the same.

00:03:35.880 --> 00:03:36.800
That blows me away.

00:03:36.800 --> 00:03:37.240
Yeah.

00:03:37.320 --> 00:03:42.080
And I like it that it's not that complicated of an algorithm and it's a fun read.

00:03:42.080 --> 00:03:42.380
Yeah.

00:03:42.380 --> 00:03:47.580
That's, you know, so I think there's a couple levels of interesting that you brought up this article.

00:03:47.580 --> 00:03:53.620
And one of them I think is really interesting is when I first heard that, I thought, okay, one, this is going to be super hard, super computational.

00:03:53.620 --> 00:03:58.160
Two, maybe this is like machine learning or something like that.

00:03:58.240 --> 00:04:02.840
Like two machines, like two images given to an AI, like a deep learning neural network or something.

00:04:02.840 --> 00:04:07.180
You say, yeah, these are sufficiently similar in ways that I don't really, people don't really understand.

00:04:07.180 --> 00:04:11.900
But magic on GPUs and lots of, you know, neurons, it works out somehow.

00:04:11.900 --> 00:04:18.500
But the fact that it's really, really a simple algorithm is what's, what's I think kind of special about it.

00:04:18.500 --> 00:04:18.700
Right.

00:04:18.700 --> 00:04:24.520
It's like, hey, there's still lots of places to be clever and not just throw AI plus GPUs at a thing.

00:04:24.520 --> 00:04:25.480
Yes, definitely.

00:04:25.480 --> 00:04:26.000
Yeah.

00:04:26.120 --> 00:04:29.220
And not only that, you get to take it with you, right?

00:04:29.220 --> 00:04:30.080
It's available on GitHub.

00:04:30.080 --> 00:04:31.960
Yeah, they do have it.

00:04:31.960 --> 00:04:32.720
It's a, what is it?

00:04:32.720 --> 00:04:34.540
P-Y-B-K-Tree?

00:04:34.540 --> 00:04:37.100
Py-B-K-Tree, whatever that means.

00:04:37.100 --> 00:04:37.840
Okay, awesome.

00:04:37.840 --> 00:04:39.340
I'm sure it's part of the algorithm.

00:04:39.340 --> 00:04:40.460
Excellent.

00:04:40.460 --> 00:04:45.800
So keeping with open source projects that you can go find and just grab and do cool things with,

00:04:45.800 --> 00:04:50.760
one of the listeners pointed me towards, pointed us towards Google open source.

00:04:50.760 --> 00:04:55.600
In fact, it was the guy from Google Fire, Python Fire, which we'll talk more about later.

00:04:56.000 --> 00:04:58.560
But he has one of the projects there.

00:04:58.560 --> 00:05:05.540
And on Google open source, they've basically created like a listing directory of all of the open source projects.

00:05:05.540 --> 00:05:07.680
Now, many of the projects still live on GitHub.

00:05:07.680 --> 00:05:13.280
But this is like a place where you can go search and analyze and discover projects from Google.

00:05:13.720 --> 00:05:15.660
And what's cool is you can sort by language.

00:05:15.660 --> 00:05:17.300
So show me the Python projects.

00:05:17.300 --> 00:05:18.740
Show me the C++ projects, whatever.

00:05:18.740 --> 00:05:21.960
So I grabbed six or seven interesting projects.

00:05:21.960 --> 00:05:23.640
I just wanted to run them down for you, Brian.

00:05:23.640 --> 00:05:24.100
Okay.

00:05:24.220 --> 00:05:24.660
Yeah.

00:05:24.660 --> 00:05:29.820
So one of them is subprocess 32, a reliable subprocess module for Python 2.

00:05:29.820 --> 00:05:34.040
Apparently, subprocess built in is not reliable for Python 2.

00:05:34.040 --> 00:05:35.220
I don't know.

00:05:35.220 --> 00:05:37.140
But I didn't know that either.

00:05:37.140 --> 00:05:39.760
That's partly why it's interesting to me.

00:05:39.760 --> 00:05:40.880
But also, you know, there it is.

00:05:40.880 --> 00:05:41.360
That's cool.

00:05:41.360 --> 00:05:42.100
Grumpy.

00:05:42.100 --> 00:05:43.500
We've talked about grumpy before.

00:05:43.500 --> 00:05:46.560
Grumpy is Python on Go instead of Python on CPython.

00:05:46.900 --> 00:05:47.100
Yeah.

00:05:47.100 --> 00:05:47.260
Yeah.

00:05:47.260 --> 00:05:47.800
That's a good one.

00:05:47.800 --> 00:05:48.780
That's a...

00:05:48.780 --> 00:05:49.860
Python Fire, of course.

00:05:49.860 --> 00:05:50.940
Python Fire, of course.

00:05:50.940 --> 00:05:55.660
Like I pointed out, that's a way to take any Python object or module and turn it into a command

00:05:55.660 --> 00:05:56.140
line interface.

00:05:56.140 --> 00:05:59.480
There's a Python client for Google Maps services.

00:05:59.480 --> 00:06:03.180
So if you want to consume Google Maps from Python, do it.

00:06:03.180 --> 00:06:10.140
There's Hue, H-Y-O-U, a Python interface for manipulating Google spreadsheets.

00:06:10.140 --> 00:06:11.540
That's cool, right?

00:06:11.540 --> 00:06:11.880
Okay.

00:06:11.880 --> 00:06:13.280
I'm going to have to try that out.

00:06:13.280 --> 00:06:13.740
That's neat.

00:06:13.740 --> 00:06:13.980
Yeah.

00:06:13.980 --> 00:06:16.100
I mean, I've seen the stuff for working with Doc.

00:06:16.200 --> 00:06:21.060
XLS, X files, the Microsoft Office ones, but I didn't know about the Google spreadsheet.

00:06:21.060 --> 00:06:21.740
So this is cool.

00:06:21.740 --> 00:06:25.960
Another thing that's always tricky for me is working with OAuth, right?

00:06:25.960 --> 00:06:27.720
There's always this, like, I've got some app.

00:06:27.720 --> 00:06:31.840
The app needs to go, like, open a browser window, and there's some sort of funky callback, and

00:06:31.840 --> 00:06:32.520
things happen.

00:06:32.520 --> 00:06:38.940
And so one of the places that's especially challenging, I think, is over a command line interface.

00:06:38.940 --> 00:06:41.800
Well, there's OAuth 2L.

00:06:41.800 --> 00:06:42.760
I think it's L.

00:06:43.480 --> 00:06:47.960
And what that is, is it's a way, a command line tool to get an OAuth token.

00:06:47.960 --> 00:06:49.920
Just let that sink in for you.

00:06:49.920 --> 00:06:50.380
Okay.

00:06:50.380 --> 00:06:51.680
So I want to log in as Google.

00:06:51.680 --> 00:06:53.660
I can do that, like, through my app.

00:06:53.660 --> 00:06:59.080
Like, I could basically create a shell script that, through the CLI, gets an OAuth token from

00:06:59.080 --> 00:06:59.440
the user.

00:06:59.440 --> 00:07:00.280
That's pretty interesting.

00:07:01.400 --> 00:07:01.680
Okay.

00:07:01.680 --> 00:07:04.100
And also, I talked about the Google Maps API.

00:07:04.100 --> 00:07:08.800
Like, that sounds like that's something that's really hard to, like, unit test or test at

00:07:08.800 --> 00:07:10.720
all without actually going to Google.

00:07:10.720 --> 00:07:12.740
So there's a mock maps API.

00:07:12.740 --> 00:07:18.240
So a small little app engine app for testing, like, basically mocking out Google Maps API.

00:07:18.240 --> 00:07:20.540
And last but not least, TensorFlow.

00:07:21.060 --> 00:07:24.660
The amazing deep learning, machine learning stuff.

00:07:24.660 --> 00:07:31.320
That's about 50% Python, 50% C++, and a lot of GPUs in action there.

00:07:31.320 --> 00:07:37.100
And I don't know where I read this, but I think that this Google open source location is not

00:07:37.100 --> 00:07:39.100
just all projects.

00:07:39.100 --> 00:07:41.940
It's projects that they consider still active.

00:07:41.940 --> 00:07:42.300
Okay.

00:07:42.580 --> 00:07:43.440
Yeah, that's cool.

00:07:43.440 --> 00:07:45.640
I mean, obviously, you don't want just, like, a dumping ground, right?

00:07:45.640 --> 00:07:47.180
Yeah, cool.

00:07:47.180 --> 00:07:49.940
I mean, everything in there looked pretty neat and fresh, so it's good.

00:07:49.940 --> 00:07:54.380
It's a fairly neat interface, too, with, I guess, panels and stuff.

00:07:54.380 --> 00:07:55.240
Yeah, it's worth checking out.

00:07:55.240 --> 00:07:55.660
Okay.

00:07:55.660 --> 00:07:56.700
What do we got next?

00:07:56.700 --> 00:07:57.620
Oh, next is me.

00:07:57.620 --> 00:08:00.160
Yeah, more machine learning type stuff.

00:08:00.160 --> 00:08:00.640
Yeah.

00:08:00.640 --> 00:08:07.380
So there's an article from Jason Brownlee called, and I just clicked away, How to Handle Missing

00:08:07.380 --> 00:08:08.240
Data with Python.

00:08:08.940 --> 00:08:13.860
And this is something that I definitely deal with measurement values that deal with at work,

00:08:13.860 --> 00:08:18.560
but there's, the gist of it is, is a lot of times you're dealing with a lot, large or small

00:08:18.560 --> 00:08:21.940
data sets, and some of the values are missing.

00:08:21.940 --> 00:08:26.300
And there's a whole bunch of different ways you can deal with missing data, but there are

00:08:26.300 --> 00:08:31.920
a few of them that he talks about are replacing, you know, you have to know what the magic number

00:08:31.920 --> 00:08:36.820
is that some data collection will fill in a zero, maybe, if there's no data, or some other

00:08:36.820 --> 00:08:38.640
known number.

00:08:38.640 --> 00:08:43.580
But all your math is going to get messed up if you actually just leave that there.

00:08:43.580 --> 00:08:46.020
So there's a couple ways to get around it.

00:08:46.020 --> 00:08:50.760
One of the ways he lists is using magic, not a number values.

00:08:50.760 --> 00:08:55.640
And I think pandas can deal with that correctly and not average those in.

00:08:55.640 --> 00:09:00.360
Yeah, what I think is really nice about it is like, I could be given a CSV file or some

00:09:00.360 --> 00:09:06.840
sort of data thing, set of data, and I could like work my way through it and maybe find

00:09:06.840 --> 00:09:08.460
the bad data and fill it in potentially.

00:09:08.460 --> 00:09:14.000
But his fix are like, you run this one line in pandas and magic happens and it's better,

00:09:14.000 --> 00:09:14.200
right?

00:09:14.200 --> 00:09:17.680
It's like the fix is so much better than the fixes that I would come up with.

00:09:17.760 --> 00:09:18.000
Yeah.

00:09:18.000 --> 00:09:23.020
And I do like that he's talking about different ways to deal with it with numpy, even without

00:09:23.020 --> 00:09:26.320
pandas also, because you might not be using pandas.

00:09:26.320 --> 00:09:31.340
But the, like one of the ways you would do it with any math package really would be to,

00:09:31.340 --> 00:09:33.120
oh, I guess I don't know how to do that.

00:09:33.120 --> 00:09:34.040
Actually.

00:09:34.040 --> 00:09:35.020
Nevermind.

00:09:35.020 --> 00:09:41.180
Filling in the, you'd somehow have to find all of the values anyway and fill them in with,

00:09:41.180 --> 00:09:45.380
like one of the ways is if you're, if you're calculating an average, calculate the average

00:09:45.380 --> 00:09:49.900
of everything else and then fill in the blanks with the average.

00:09:49.900 --> 00:09:50.160
Right.

00:09:50.160 --> 00:09:51.780
I guess it depends on what you're going to do.

00:09:51.780 --> 00:09:52.620
Are you going to average it?

00:09:52.620 --> 00:09:53.720
Are you going to max it in a minute?

00:09:53.720 --> 00:09:55.220
You could like push that through, right?

00:09:55.220 --> 00:09:55.640
Yeah.

00:09:55.640 --> 00:09:55.920
Yeah.

00:09:55.920 --> 00:09:56.280
Interesting.

00:09:56.280 --> 00:10:01.940
The best solution definitely, I think is, is using the not a number and letting the,

00:10:01.940 --> 00:10:03.860
the libraries take care of it for you.

00:10:03.860 --> 00:10:08.360
But it's definitely, I wanted to bring this up partly because anybody that's working with

00:10:08.360 --> 00:10:14.240
data collection or, and doing math with that has to deal with the fact that sometimes there's

00:10:14.240 --> 00:10:16.080
not numbers there and you have to deal with it.

00:10:16.080 --> 00:10:16.360
So.

00:10:16.360 --> 00:10:16.800
Okay.

00:10:16.800 --> 00:10:17.780
Awesome.

00:10:17.780 --> 00:10:20.400
He's from machine learning mastery.com.

00:10:20.400 --> 00:10:20.840
I think.

00:10:20.840 --> 00:10:25.040
And he's got just a ton of cool stuff going on over there.

00:10:25.040 --> 00:10:25.340
Right.

00:10:25.340 --> 00:10:27.560
It's not just this one article.

00:10:27.560 --> 00:10:27.740
Right.

00:10:27.740 --> 00:10:29.840
So if you're into these kinds of things, definitely check it out.

00:10:29.840 --> 00:10:30.180
Yeah.

00:10:30.180 --> 00:10:30.620
It looks good.

00:10:30.620 --> 00:10:32.140
Okay.

00:10:32.140 --> 00:10:36.480
So what's up next is the hug rest framework.

00:10:37.040 --> 00:10:39.440
But before we get to them, I want to give roll bar a hug.

00:10:39.440 --> 00:10:41.160
Roll bar is awesome.

00:10:41.160 --> 00:10:45.500
I've been, as people know, I've been using them for a long time on the websites and the

00:10:45.500 --> 00:10:46.960
websites are getting more and more traffic.

00:10:46.960 --> 00:10:52.980
And I recently, I'm not sure whether it was a wise decision or not, because I'm really busy

00:10:52.980 --> 00:10:57.700
with other stuff, but I just got really frustrated with the way my servers are working, the way

00:10:57.700 --> 00:11:00.760
I could sort of move them around and performance and stuff.

00:11:00.760 --> 00:11:01.640
So I said, that's it.

00:11:01.640 --> 00:11:03.040
One day I just woke up, so that's it.

00:11:03.040 --> 00:11:04.440
Converting it all to MongoDB.

00:11:05.580 --> 00:11:07.260
And so that was last week.

00:11:07.260 --> 00:11:12.740
And that took like three days of rewriting all my sites to Mongo, which I really think

00:11:12.740 --> 00:11:13.700
Mongo is the right choice.

00:11:13.700 --> 00:11:16.100
And I'm just loving the way it's working now.

00:11:16.100 --> 00:11:22.560
But that was a pretty serious, like take the guts out of all my web apps and stick in a new set

00:11:22.560 --> 00:11:25.400
of guts that are similar, but not entirely compatible.

00:11:25.400 --> 00:11:30.840
I spent a little time with roll bar and they, they, they helped me out and find a few

00:11:30.840 --> 00:11:33.400
problems like where maybe types used to be strings.

00:11:33.400 --> 00:11:37.100
I compare them where one was no longer a string and they didn't compare the same.

00:11:37.100 --> 00:11:40.160
So I got weird errors, but roll bar made it super easy to track that down.

00:11:40.160 --> 00:11:47.740
So if you want to have reliability and most importantly, awareness of the state of your

00:11:47.740 --> 00:11:49.860
apps, plug in roll bar to your web apps.

00:11:49.860 --> 00:11:55.400
You can use it in pyramid, flash, Django, whatever, just plug it in and you'll get notifications

00:11:55.400 --> 00:11:55.860
right away.

00:11:56.000 --> 00:12:01.700
So be sure to visit rollbar.com slash Python bytes, and you'll get a special offer to get

00:12:01.700 --> 00:12:02.180
started there.

00:12:02.180 --> 00:12:07.800
And I bet that you definitely noticed those messages, but I didn't even notice you were

00:12:07.800 --> 00:12:08.620
mucking with things.

00:12:08.620 --> 00:12:11.860
And I'm pretty sure that nobody else did or very few people did either.

00:12:11.860 --> 00:12:12.700
Yeah, that's true.

00:12:12.700 --> 00:12:13.800
And thank you for saying that.

00:12:13.800 --> 00:12:17.380
But I actually know how many people ran into problems, right?

00:12:17.380 --> 00:12:22.620
There was a couple, but I got an email from a couple of people saying, Hey, I had this problem

00:12:22.620 --> 00:12:23.180
with your app.

00:12:23.180 --> 00:12:25.560
I'm like, I know, but I didn't know your email address.

00:12:26.060 --> 00:12:28.500
But I know what your problem was, and it's already fixed.

00:12:28.500 --> 00:12:30.180
I just couldn't contact them.

00:12:30.180 --> 00:12:32.120
So because they hadn't actually created an account yet.

00:12:32.120 --> 00:12:36.380
So it was really nice to be able to just say, yeah, actually, the problem you're telling me

00:12:36.380 --> 00:12:36.960
is already fixed.

00:12:36.960 --> 00:12:38.680
I just couldn't communicate that back to you.

00:12:38.680 --> 00:12:39.720
Really sorry about that.

00:12:39.720 --> 00:12:40.420
It's awesome.

00:12:40.420 --> 00:12:42.920
You seem like a big team then because of that.

00:12:42.920 --> 00:12:44.160
So oh, yeah, definitely.

00:12:44.160 --> 00:12:46.880
It's all the folks here in the cubicle farm.

00:12:46.880 --> 00:12:47.480
We're busy.

00:12:47.480 --> 00:12:53.960
You know, one of the next things that I want to do is build some some nice APIs.

00:12:54.360 --> 00:12:58.640
And I think it's really an interesting time for the web in Python.

00:12:58.640 --> 00:13:00.940
There's a lot of flowers blooming, if you will.

00:13:00.940 --> 00:13:01.840
Right?

00:13:01.840 --> 00:13:03.880
We've got Pyramid, Django, Flask.

00:13:03.880 --> 00:13:06.240
Those guys are all doing super stuff.

00:13:06.240 --> 00:13:07.640
And like most of my stuff is Pyramid.

00:13:07.640 --> 00:13:10.480
But we've got Jopronto coming along, Sanic.

00:13:10.480 --> 00:13:15.760
And another one that I just learned about is called Hug at Hug.rest.

00:13:15.760 --> 00:13:17.740
How's that for a name and a domain?

00:13:17.740 --> 00:13:19.140
Yeah, actually, it is.

00:13:19.200 --> 00:13:20.720
It's www.hug.rest.

00:13:20.720 --> 00:13:21.660
Hug.rest.

00:13:21.660 --> 00:13:22.120
That's beautiful.

00:13:22.120 --> 00:13:30.560
So Hug is a Python framework, web framework, just specifically for building restful, documented,

00:13:30.560 --> 00:13:33.220
documentable, versionable APIs.

00:13:33.820 --> 00:13:39.180
And it's built both for like super simplicity and flexibility as well as performance.

00:13:39.180 --> 00:13:41.100
So I started looking this up.

00:13:41.100 --> 00:13:42.720
Wow, this is quite interesting.

00:13:42.720 --> 00:13:43.440
Okay.

00:13:43.480 --> 00:13:49.040
So the idea is you can create an API once and you can consume it in all these different ways.

00:13:49.040 --> 00:13:54.460
So you can import it as a module or a package into your project and use the API that way.

00:13:54.460 --> 00:13:59.040
You can communicate it, obviously, over HTTP as like a RESTful API.

00:13:59.040 --> 00:14:03.620
Or it also has a CLI, command line interface, way to expose that.

00:14:03.620 --> 00:14:07.620
So if you write like some kind of a web app or functionality you want to expose over an API,

00:14:07.620 --> 00:14:11.420
but you also want to call it locally, it's like the same code.

00:14:11.420 --> 00:14:12.040
Oh, wow.

00:14:12.040 --> 00:14:12.480
That's interesting.

00:14:12.560 --> 00:14:14.480
It's also written in Python 3.

00:14:14.480 --> 00:14:17.920
It uses Cython all over the place.

00:14:17.920 --> 00:14:20.000
So it's like super fast.

00:14:20.000 --> 00:14:23.340
It's one of the fastest web frameworks out there for these kinds of things.

00:14:23.340 --> 00:14:27.040
At least the non-async version, let's say.

00:14:27.040 --> 00:14:28.920
If you compare those, it's pretty cool.

00:14:28.920 --> 00:14:31.700
It's got a decorator model, so the code looks really clean.

00:14:31.700 --> 00:14:35.600
Yeah, and the decorator model is cool because the decorator model will do like version management.

00:14:35.600 --> 00:14:40.080
You can have like version 1 and version 2 of the API that have like different data formats.

00:14:40.080 --> 00:14:41.520
And they can just coexist.

00:14:41.640 --> 00:14:45.220
You get automatic documentation based on that.

00:14:45.220 --> 00:14:50.440
Like it'll do type annotations and then like use the type annotations as part of the documentation and things like that.

00:14:50.440 --> 00:14:51.020
Oh, that's great.

00:14:51.020 --> 00:14:53.000
It's a pretty cool, simple little framework.

00:14:53.200 --> 00:14:55.280
So, you know, hug for those guys.

00:14:55.280 --> 00:14:55.720
Nice job.

00:14:55.720 --> 00:14:56.380
Definitely.

00:14:56.380 --> 00:14:57.360
Speaking of CLIs.

00:14:57.360 --> 00:15:06.040
Yeah, speaking of CLIs, I'm actually working on, I had an example I wanted to do that I'm running with the pytest book that I'm working on.

00:15:06.720 --> 00:15:13.420
And for the front end of it, I was punting before and not using actually putting a front end on the application.

00:15:13.420 --> 00:15:16.020
But I wanted to at least put a command line interface in.

00:15:16.400 --> 00:15:19.700
And my first attempt was to go down arg parse.

00:15:19.980 --> 00:15:24.900
And the particular quirks of this application, I needed sub commands.

00:15:24.900 --> 00:15:28.380
Actually, just the tutorials I found were out of date.

00:15:28.380 --> 00:15:29.140
It doesn't work.

00:15:29.780 --> 00:15:32.000
And I was having a little bit of difficulty.

00:15:32.000 --> 00:15:34.020
So I went ahead and tried CLIQ.

00:15:34.020 --> 00:15:37.300
I'd heard of CLIQ before and hadn't tried it.

00:15:37.300 --> 00:15:42.540
And, man, a tutorial from like three years ago was about what I needed.

00:15:42.540 --> 00:15:45.540
And it works right away.

00:15:45.540 --> 00:15:50.160
I've got like half a page of code and my interface, my command line interface is done.

00:15:50.160 --> 00:15:50.920
That's really cool.

00:15:50.920 --> 00:15:52.640
That's also decorator heavy, right?

00:15:52.820 --> 00:15:55.640
Yeah, in my sublime editor, it's colored nicely.

00:15:55.640 --> 00:15:58.820
And my wife walked by and said, that's such beautiful code.

00:15:58.820 --> 00:16:00.140
Oh, lovely.

00:16:00.140 --> 00:16:02.860
Let's take that on many, many levels, right?

00:16:02.860 --> 00:16:03.300
That's awesome.

00:16:03.300 --> 00:16:05.800
Yeah, that's by Armin Roeneker, a guy from Flask.

00:16:05.800 --> 00:16:06.740
So definitely.

00:16:06.740 --> 00:16:08.100
Oh, did he do CLIQ?

00:16:08.100 --> 00:16:08.560
I think so, yeah.

00:16:08.560 --> 00:16:09.160
I believe so.

00:16:09.160 --> 00:16:11.000
Yeah, nice.

00:16:11.000 --> 00:16:11.640
CLIQ is cool.

00:16:11.640 --> 00:16:13.280
I've done a little bit of work with it.

00:16:13.280 --> 00:16:14.540
And I've liked what I've seen.

00:16:14.540 --> 00:16:17.840
But I also kind of want to, yeah, we'll talk about it later.

00:16:17.840 --> 00:16:21.180
But I might want to try adding a different CLI interface to it as well.

00:16:21.180 --> 00:16:21.760
Yeah, cool.

00:16:22.520 --> 00:16:27.700
So the last one that I chose for us is kind of a refresher, back to the fundamentals type

00:16:27.700 --> 00:16:27.880
thing.

00:16:27.880 --> 00:16:34.700
So Python inheritance class and instance class and static methods demystified.

00:16:34.700 --> 00:16:37.120
So this one is on realpython.com.

00:16:37.120 --> 00:16:38.680
And I went over there and checked it out.

00:16:38.680 --> 00:16:40.580
And I said, oh, OK, realpython.com.

00:16:40.580 --> 00:16:41.040
That's cool.

00:16:41.040 --> 00:16:42.780
And then I realized this is actually from Dan Bader.

00:16:42.780 --> 00:16:45.900
And we seem to be covering a lot of Dan's stuff over here.

00:16:45.900 --> 00:16:47.660
And I actually have more to say about Dan later still.

00:16:47.660 --> 00:16:52.040
So this was a guest pose Dan did for that, although I didn't realize that until I started

00:16:52.220 --> 00:16:52.720
getting into it.

00:16:52.720 --> 00:16:58.400
And the idea was to demystify what's behind class methods, static methods, and regular

00:16:58.400 --> 00:16:59.360
instance methods.

00:16:59.360 --> 00:17:05.440
If you learn Python classes, if you learn classes and inheritance and object-oriented programming

00:17:05.440 --> 00:17:09.800
only through Python, this will be obvious to you.

00:17:09.900 --> 00:17:16.680
But if you come from other languages like C++ or Java or C Sharp or JavaScript, there's differences

00:17:16.680 --> 00:17:19.860
to the way Python classes and inheritance works.

00:17:19.860 --> 00:17:22.660
And it's worth kind of a compare and contrast.

00:17:22.660 --> 00:17:24.080
So he comes up with a class.

00:17:24.080 --> 00:17:26.940
And it's got like a regular method, a class method.

00:17:26.940 --> 00:17:28.580
So an at class method decorator.

00:17:28.580 --> 00:17:30.400
And takes a CLS parameter.

00:17:30.400 --> 00:17:33.360
And a static method with an at static method decorator.

00:17:33.360 --> 00:17:33.660
Nothing.

00:17:34.300 --> 00:17:36.860
And basically compares and contrasts how they work.

00:17:36.860 --> 00:17:41.340
And so some of the things that I think are not obvious when you're first getting started

00:17:41.340 --> 00:17:42.920
is like instance classes.

00:17:42.920 --> 00:17:43.980
Those are pretty straightforward.

00:17:43.980 --> 00:17:47.700
Like you call them on instances like all other languages.

00:17:47.700 --> 00:17:54.520
But the fact that I can call static methods or class methods on instances, that's a little

00:17:54.520 --> 00:17:55.020
bit funky.

00:17:55.020 --> 00:17:56.120
Right?

00:17:56.120 --> 00:17:56.480
Yeah.

00:17:56.480 --> 00:17:57.240
That seems a little weird.

00:17:57.240 --> 00:18:00.220
And then the other one, the main one I think is like what's the difference?

00:18:00.220 --> 00:18:02.460
Why are there two things like static method and class method?

00:18:02.460 --> 00:18:03.400
They seem the same.

00:18:03.400 --> 00:18:04.680
Why are there two?

00:18:04.680 --> 00:18:07.020
And then like when would I use one versus the other?

00:18:07.020 --> 00:18:08.400
Right?

00:18:08.400 --> 00:18:12.160
The class method takes a CLS method, which is literally the type that it's on.

00:18:12.160 --> 00:18:14.400
And the static method just doesn't.

00:18:14.400 --> 00:18:15.800
But other than that, they seem the same.

00:18:15.800 --> 00:18:16.040
Right?

00:18:16.040 --> 00:18:21.380
And so if you're going to say like interact with the class, like during the class method,

00:18:21.380 --> 00:18:27.120
if you're going to create an instance of the class, you can use the CLS parameter to support

00:18:27.120 --> 00:18:28.300
like inheritance and stuff.

00:18:28.300 --> 00:18:36.320
So if I got like a, let's say a vehicle class and a car, like a Tesla car class, that static

00:18:36.320 --> 00:18:39.600
method could say like allocate a CLS, whatever that is.

00:18:39.600 --> 00:18:44.260
And if you called it on a Tesla static ish function class method, it would actually create

00:18:44.260 --> 00:18:44.740
a Tesla.

00:18:44.880 --> 00:18:48.280
It would change like the thing, the type that it knows it is, where the static method is

00:18:48.280 --> 00:18:49.240
just like a grouping.

00:18:49.240 --> 00:18:51.240
So I thought that was interesting.

00:18:51.240 --> 00:18:54.320
Does the class method follow then the hierarchy then?

00:18:54.320 --> 00:19:01.480
So if I declare a class method on a base class, does it, is it available to the subclass?

00:19:01.480 --> 00:19:02.220
Yes, always.

00:19:02.220 --> 00:19:03.700
And that's always true for static methods.

00:19:03.820 --> 00:19:08.780
But the difference is the static method doesn't really know what type it's being called on.

00:19:08.780 --> 00:19:09.320
Oh, okay.

00:19:09.320 --> 00:19:12.040
Whereas the class method, it's given the type.

00:19:12.040 --> 00:19:16.180
So if there's like, you call it farther down in the inheritance chain, that whatever level

00:19:16.180 --> 00:19:20.320
you're at, that instant or that type actually is communicated to it.

00:19:20.800 --> 00:19:24.160
And so you're kind of, you're told where you are in the hierarchy in a class method, where

00:19:24.160 --> 00:19:26.040
in static, it's just like, it's just a method.

00:19:26.040 --> 00:19:27.160
Go for it.

00:19:27.160 --> 00:19:27.460
Okay.

00:19:27.460 --> 00:19:27.700
Yeah.

00:19:27.700 --> 00:19:29.660
I don't think I've ever used static methods for anything.

00:19:29.660 --> 00:19:29.960
Yeah.

00:19:29.960 --> 00:19:32.520
Well, they're out there hanging out with their friend class methods.

00:19:32.520 --> 00:19:34.960
Interesting.

00:19:34.960 --> 00:19:35.340
Indeed.

00:19:35.440 --> 00:19:37.380
So I have a quick follow-up from the last show.

00:19:37.380 --> 00:19:41.940
David Bieber from Google, the guy who works on Python Fire, sent us a note.

00:19:41.940 --> 00:19:48.300
And you said something to the effect of, look, Python Fire is awesome, but IPython is a serious

00:19:48.300 --> 00:19:51.180
dependency to take if I just want to see a lie, right?

00:19:51.180 --> 00:19:52.080
And I think that's fair.

00:19:52.080 --> 00:19:52.820
That's fair.

00:19:52.820 --> 00:19:55.100
But he said, hey, you know what?

00:19:55.100 --> 00:19:59.360
One of our primary plans is to remove IPython as a dependency.

00:19:59.360 --> 00:20:00.540
We're just not there yet.

00:20:00.540 --> 00:20:05.000
So if anybody in the audience wants to help those guys move forward, they're totally working

00:20:05.000 --> 00:20:05.420
on that.

00:20:05.840 --> 00:20:13.240
And so Python Fire from Google is definitely getting some interesting thinning out, and

00:20:13.240 --> 00:20:13.940
it'll be very nice.

00:20:13.940 --> 00:20:19.740
And actually, I like to hear that, that they're working on eventually getting rid of that dependency.

00:20:19.740 --> 00:20:21.620
And it's pretty cool.

00:20:21.620 --> 00:20:27.760
Also, it's something I had mentioned when we talked about Python Fire, that your development

00:20:27.760 --> 00:20:28.920
time is important, too.

00:20:28.920 --> 00:20:32.200
And putting an interface together with that is pretty fast.

00:20:32.200 --> 00:20:33.640
So keep that in mind.

00:20:33.640 --> 00:20:33.840
Yeah.

00:20:34.020 --> 00:20:36.160
It's not always about optimizing for the machines.

00:20:36.160 --> 00:20:36.900
Definitely.

00:20:36.900 --> 00:20:47.500
Hey, one more follow-up is we did cover PDR2 or PDR a couple episodes ago with the DUR colors

00:20:47.500 --> 00:20:48.180
prints out.

00:20:48.880 --> 00:20:54.580
One of the complaints I had was that it didn't look that great on my black terminal.

00:20:54.580 --> 00:20:55.500
I had the same problem.

00:20:55.500 --> 00:20:56.760
I like darker stuff.

00:20:56.760 --> 00:20:58.160
And I'm like, wait, where's all the words?

00:20:58.160 --> 00:20:59.760
They just updated it.

00:21:00.220 --> 00:21:02.840
And I guess yesterday, I think.

00:21:02.840 --> 00:21:05.820
And it does have color configuration now.

00:21:05.820 --> 00:21:11.040
So you can drop a PDR2 config file in your home directory.

00:21:11.040 --> 00:21:18.200
And I set my background color to magenta so that it was visible for docs, visible on both

00:21:18.200 --> 00:21:18.760
black and white.

00:21:18.760 --> 00:21:19.420
And now it looks great.

00:21:19.420 --> 00:21:19.860
Oh, nice.

00:21:19.860 --> 00:21:21.940
PDR2 now has themes.

00:21:21.940 --> 00:21:22.560
Love it.

00:21:22.560 --> 00:21:24.400
All right.

00:21:24.740 --> 00:21:26.220
How's the book coming?

00:21:26.220 --> 00:21:27.560
I heard there's a spotting.

00:21:27.560 --> 00:21:28.460
Yeah.

00:21:28.460 --> 00:21:34.040
So on Twitter the other day, somebody, a guy named Jacob Jarros, I think that's right,

00:21:34.040 --> 00:21:38.660
noticed that it was listed on the Pragmatic Publishers website.

00:21:38.660 --> 00:21:40.160
So it's out there.

00:21:40.160 --> 00:21:40.840
That's awesome.

00:21:40.840 --> 00:21:41.740
I love the cover.

00:21:41.740 --> 00:21:42.780
The rocket is cool.

00:21:43.180 --> 00:21:43.420
Yeah.

00:21:43.420 --> 00:21:44.940
A 50s sci-fi nerd.

00:21:44.940 --> 00:21:45.680
So yeah.

00:21:45.680 --> 00:21:47.560
And just the perfect, it's perfect.

00:21:47.560 --> 00:21:51.180
Like it's 50s, 60s vintage rocket.

00:21:51.180 --> 00:21:51.900
So how about you?

00:21:51.900 --> 00:21:55.220
Well, it has been a super busy couple of weeks.

00:21:55.220 --> 00:21:57.340
I've been working on a couple of classes.

00:21:57.340 --> 00:22:00.200
One of them I'm about to release.

00:22:00.200 --> 00:22:02.580
By the time this recording comes out, it will be out.

00:22:02.580 --> 00:22:04.080
So tomorrow, basically.

00:22:04.080 --> 00:22:07.540
A course called Using and Mastering Cookie Cutter.

00:22:07.540 --> 00:22:10.820
So really deep dive into what is cookie cutter?

00:22:10.820 --> 00:22:13.120
How do you create and manage projects with cookie cutter?

00:22:13.560 --> 00:22:15.620
I think it's going to be a really fun course.

00:22:15.620 --> 00:22:22.280
And I also just a few hours ago launched Managing Python Dependencies with pip in Virtual Environments,

00:22:22.280 --> 00:22:28.760
which Dan Bader, speaking of Dan Bader, came over to join me to write a class for us over here.

00:22:28.760 --> 00:22:30.680
And we're shipping that as well.

00:22:30.680 --> 00:22:34.020
So I took that course and I actually learned quite a bit from it.

00:22:34.020 --> 00:22:36.340
It's not just like pip install done.

00:22:36.340 --> 00:22:41.120
It's what is the process that you use to manage your dependencies?

00:22:41.440 --> 00:22:48.240
How do you like, what is the thinking and workflow you use to evaluate whether a package is worth taking a dependency on?

00:22:48.240 --> 00:22:49.740
And all sorts of cool stuff like that.

00:22:49.740 --> 00:22:50.660
Bunch of best practices.

00:22:50.660 --> 00:22:51.980
Launched both of those.

00:22:51.980 --> 00:22:57.640
And I just started selling course bundles on Talk Python training as well to sort of go along with those.

00:22:57.640 --> 00:22:58.680
So lots of stuff.

00:22:58.680 --> 00:22:59.620
That's pretty exciting.

00:22:59.620 --> 00:23:01.480
I got to check out the cookie cutter thing.

00:23:01.480 --> 00:23:02.080
Yeah, thanks, Ed.

00:23:02.080 --> 00:23:03.360
It'll be out tomorrow morning.

00:23:03.360 --> 00:23:04.600
For everyone listening, that's today.

00:23:04.600 --> 00:23:05.220
That's today.

00:23:05.220 --> 00:23:08.280
But for you, Brian, that's tomorrow morning.

00:23:08.280 --> 00:23:10.240
The magic of time travel.

00:23:10.240 --> 00:23:13.700
Thanks so much for finding all these great items.

00:23:13.700 --> 00:23:15.440
That was fun as always, Brian.

00:23:15.440 --> 00:23:16.700
It was fun for me too.

00:23:16.700 --> 00:23:19.600
And thanks to everybody for all your feedback that you send in.

00:23:19.600 --> 00:23:19.840
Yep.

00:23:19.840 --> 00:23:20.580
Thanks, everyone.

00:23:20.580 --> 00:23:22.340
And thank you, Rollbar, for supporting the show.

00:23:23.340 --> 00:23:25.140
Thank you for listening to Python Bytes.

00:23:25.140 --> 00:23:27.700
Follow the show on Twitter via at Python Bytes.

00:23:27.700 --> 00:23:30.580
That's Python Bytes as in B-Y-T-E-S.

00:23:30.580 --> 00:23:34.000
And get the full show notes at pythonbytes.fm.

00:23:34.000 --> 00:23:38.360
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:23:38.360 --> 00:23:41.060
We're always on the lookout for sharing something cool.

00:23:41.060 --> 00:23:44.440
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:23:44.440 --> 00:23:48.080
Thank you for listening and sharing this podcast with your friends and colleagues.

