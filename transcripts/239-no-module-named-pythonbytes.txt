00:00:00 Hello and welcome to Python Bytes, where we deliver news and headlines directly to your earbuds.

00:00:05 This is episode 239, recorded June 23rd.

00:00:09 It's almost the end of June. Wow.

00:00:10 2021. I am Brian Okken.

00:00:13 I'm Michael Kennedy.

00:00:14 And I am Nick Moore.

00:00:16 Welcome, Nick. Thanks for joining the show.

00:00:18 Before we jump in, tell me a little bit about yourself.

00:00:21 Yeah, sure. So as I said, Nick Moore.

00:00:24 I'm based out of Ohio and I work as a data engineer, Trimble Transportation.

00:00:30 It's a software company aiming to like revolutionize the way we supply the world and like simplify and connect like the world supply chain.

00:00:38 Like it tries to make it easier to move goods and freight all around the world.

00:00:43 I'm also the co-organizer of ClePy, which is Cleveland's Python meetup group.

00:00:49 Thank you, Michael, for sharing it up on the screen.

00:00:52 So, yeah, that's a bit about me.

00:00:54 Nice. I enjoyed Cleveland when we were there for PyCon.

00:00:57 Yeah, I think I met you guys there.

00:01:00 Cool.

00:01:00 I think you guys were in the JetBrains.

00:01:02 That's right. We were.

00:01:04 It was really great to be in Cleveland for a couple of years.

00:01:07 And I guess we just completely missed Pittsburgh.

00:01:09 But they're going to get another round out of here as a redo, which is cool from COVID.

00:01:14 I got a chance to speak at the Cleveland Python meetup and talked about memory.

00:01:20 Was that right?

00:01:21 Yeah.

00:01:21 You talked about how Python manages memory.

00:01:24 It was like a really cool deep dive into that.

00:01:26 Yeah.

00:01:26 Thanks.

00:01:27 That was super fun for having me.

00:01:28 Now it's good to have you on our show.

00:01:29 Yeah.

00:01:30 So was that on purpose?

00:01:31 Did you make a joke that you couldn't remember what the talk was about?

00:01:34 No.

00:01:36 I know how my brain might store the memory of what I spoke about, but I just, it could have been that or async and I wasn't 100% sure which one it was.

00:01:44 We did talk about async too, though.

00:01:47 Cool.

00:01:48 Yeah.

00:01:48 Yeah.

00:01:49 For sure.

00:01:49 Speaking of async, Brian, you see what databases tells us about it.

00:01:52 Well, this is object relational mappers also.

00:01:57 So we have ORMAR, which is an async mini ORM for Python, which supports Postgres, MySQL, and SQLite.

00:02:07 This was a suggestion sent to us by John Hagen.

00:02:13 So thanks, John, for sending this in.

00:02:14 And I actually haven't played with this a lot.

00:02:17 I was looking around.

00:02:18 It looks pretty neat.

00:02:18 But I'm going to quote John here.

00:02:20 He says, it's a really cool ORM that combines Pydantic models and SQL models into a single definition.

00:02:27 What is great about this is it can be used to reduce the repetitive duplication between the models for an ORM and the Pydantic models for that FastAPI needs to describe serialization.

00:02:40 So I guess you do have to specify that twice normally.

00:02:43 Yeah.

00:02:44 Normally what you do is you would have the data model, the classes that do the exchange on the API level.

00:02:51 So those would probably be Pydantic.

00:02:53 But maybe then you have something like a SQLAlchemy model.

00:02:56 And then somewhere in the middle, you've got to copy the SQLAlchemy data over to the Pydantic model, send out over FastAPI and you get it back.

00:03:03 Then you've got to copy that from FastAPI and Pydantic back into SQLAlchemy.

00:03:08 Because SQLAlchemy types are not really meant to be transferred on the wire.

00:03:11 You don't get the open API documentation that you get from Pydantic integration and all those sorts of things.

00:03:17 So that's normally what happens.

00:03:18 But if your database model can also be a Pydantic model, then you don't do that back and forth.

00:03:24 Yeah.

00:03:24 And anytime you've got duplication, it's like that dry issue of just you're going to mess it up sometime.

00:03:30 It's going to be wrong.

00:03:31 And I think that's why SQLAlchemy, I think in version 1.4, they've been playing around with a lot of ideas on how to integrate data, not Pydantic, but data classes and the ORM style base models.

00:03:49 Four different propositions of how that should be done, but it's not yet perfect.

00:03:54 So I think that's something that it looks like they could learn from Omar here.

00:03:59 Or at least it's good to have these sort of experiments going on for everybody to look around and see how do we move forward so that we can do this cleanly.

00:04:07 Yeah.

00:04:08 The one thing I will say is that with all of these ORMs, I don't know why they never give some love to SQL Server.

00:04:15 I always see Postgres, MySQL, and SQLite.

00:04:18 But like SQL Server is pretty cool too.

00:04:20 Where is the support for that?

00:04:23 What's SQL Server?

00:04:24 So that's like Microsoft's, you know what?

00:04:28 I think it really matters what audience you're addressing, Nick, right?

00:04:36 So if you're talking startups and a lot of the open source crowd, yeah, it's all Postgres.

00:04:42 Or, you know, if you're talking to Michael, it's all MongoDB, right?

00:04:45 But if you're talking to enterprises, boy, oh, boy, do a big bunch of those enterprises run on the Microsoft stack.

00:04:53 Yeah.

00:04:54 Windows, Windows Servers, Microsoft SQL Server.

00:04:57 And that's a non-trivial amount of the use cases for these things.

00:05:02 So I agree that it should get some attention, even if it's not necessarily the one that the maintainers or many of the people are most keen to use.

00:05:10 Yeah, and I agree.

00:05:11 It was a joke, but one of the things I wanted to point out that John mentioned is that one of the benefits of Ormar is there's a quick start specifically for FastAPI.

00:05:25 So you can look at the documentation and there's a FastAPI quick start on how to get this running with FastAPI.

00:05:30 What an interesting combination of descriptors from the ORM class side and Pydantic models you get here.

00:05:40 So for this, we have like the Pydantic model-based type of thing.

00:05:45 We've got the columns specified with type information that Pydantic would use, but then you set them to things like an integer column that's a primary key or a string that has a max length setting and things like that.

00:05:56 Yeah, it's like the worst of every world.

00:05:58 But it's better than repeating stuff, right?

00:06:03 So, yeah, interesting.

00:06:05 Yeah, I think it's pretty good.

00:06:06 And Nick, you mentioned SQL, Alchemy, and Data Classes.

00:06:11 Pydantic also has some integration for working with Data Classes as well.

00:06:15 So maybe there's a way to bridge those things across for like FastAPI and similar situations as well.

00:06:21 I haven't tried that, but it's possible.

00:06:23 Yeah, let's see.

00:06:24 Out there in the live stream, we've got Sam Morley.

00:06:25 Hey, Sam.

00:06:26 Says, this looks a lot like a Django ORM.

00:06:28 Yeah, absolutely.

00:06:28 It really does.

00:06:30 And then Dean is hoping that we'll get some support for a very important database, AccessDB.

00:06:35 That and, oh gosh, what was it?

00:06:39 DB2 and a couple of the others.

00:06:40 Yeah, there's some really important ones that we might be forgetting, but I think it's going to be okay.

00:06:44 Oh man, Access, that gives me PTSD from college.

00:06:47 I can imagine.

00:06:50 I can imagine.

00:06:51 All right.

00:06:52 Well, speaking of people who might be getting some trauma, let's talk about NoModuleNamed.com.

00:07:01 In fact, it's now its own website.

00:07:03 You used to think of it as like an error, and now it's actually a service.

00:07:08 So error explanations of a service, I guess, is what you would call it.

00:07:11 All right.

00:07:11 So Garrett Dune pointed out that there's this website called NoModuleNamed.

00:07:17 And it looks super plain.

00:07:18 And I went to it like, what is this?

00:07:20 It has 3,626 packages.

00:07:24 And, oh my goodness, like 2 million modules or something like that.

00:07:28 And it has 151,000 package install guidelines.

00:07:32 So for example, what if I'm working with HTTPX?

00:07:34 And I get the message that says, Python error, no module named HTTPX.

00:07:39 Right?

00:07:40 This is what you would have if you wrote import HTTPX and you went and tried to run it,

00:07:44 but you were new and you didn't realize there were external dependencies or that HTTPX wasn't

00:07:49 built into the standard library, you would get that error, right?

00:07:52 Yeah.

00:07:53 So this tells you how to fix it.

00:07:55 It says, oh, this is probably because you don't have the package HTTPX.

00:07:58 Let's see if I can go something like FastAPI.responses.

00:08:03 Is that a thing?

00:08:04 And what will it tell me if I try, oh, no such module.

00:08:07 Yeah.

00:08:08 But so NumPy, for example, it'll give you a lot of these and it'll tell you, this is

00:08:13 probably because you don't have the package NumPy or NumPy MIPS64 installed.

00:08:19 So that's what I was looking for is if it would sort of show like, well, the package name is

00:08:23 not exactly what you're looking for.

00:08:25 So maybe BS4, right?

00:08:28 Sometimes there's these modules that, yeah.

00:08:30 So for example, if I say BS4, it'll say, oh, it's because you don't have, if you have

00:08:34 the error, no module name BS4, it's because you don't have beautiful Super 4 installed,

00:08:38 right?

00:08:38 So it's more than just like, duh, pip install the thing that there's no module of.

00:08:42 It tries to help a little bit more with understanding that and it tells you how to get the latest

00:08:47 version.

00:08:47 It tells you how to install it.

00:08:48 So yeah.

00:08:49 And there's even a related article.

00:08:51 Extremely beautiful like SEO on that with people just Googling error messages as well.

00:08:57 Yeah.

00:08:58 So pretty, pretty interesting.

00:09:00 Garrett Dunn, thank you so much for sending that in.

00:09:03 It's simple, but you know, these kinds of things can help people who are new and are getting

00:09:08 in.

00:09:08 And I think one of the powers of Python is we have people coming from all these different

00:09:13 backgrounds and experiences, and they are not all computer science people that know about

00:09:17 package managers and like love that.

00:09:19 They're just like, oh, I know that I can do cool.

00:09:21 I can like load this file and make a picture out of it that I need to work on.

00:09:24 But I get this stupid no module named this.

00:09:26 What is this?

00:09:27 Right.

00:09:27 And then they can, you know, these kinds of things can help.

00:09:29 Yeah.

00:09:30 Well, I'm trying to teach my 11 year old some programming and we started with packaging.

00:09:34 Yeah.

00:09:34 We didn't.

00:09:35 I know you started with virtual environments and then packaging.

00:09:39 Yeah.

00:09:41 Brian, I thought you would have started with testing first.

00:09:44 Yeah.

00:09:44 I always test first.

00:09:45 Yeah.

00:09:46 I think this is like a really, this is like a really cool project.

00:09:50 I find it's like a really cool thing.

00:09:51 I find it super useful when I'm working on projects related to GUIs like Qt or Phoenix.

00:10:00 No, no.

00:10:00 WX Python.

00:10:01 Because like those packages come with so many underlying dependencies.

00:10:06 And sometimes you might miss one or might miss something that like is an OS dependency that you don't know.

00:10:12 I feel like this could help you out.

00:10:13 And I've run through this a few times where like I'm using like a package that is built on top of Qt.

00:10:19 But then it tells me you don't have PyQt GT.

00:10:23 PyQt 5.

00:10:24 Right.

00:10:24 Exactly.

00:10:25 Well, I like that.

00:10:27 I think you probably already mentioned this, but the error message is the module not found.

00:10:33 That's often not the same.

00:10:35 It's not the same name as the thing you pip install.

00:10:37 Yeah.

00:10:39 Like one that drives me crazy is DateUtil.

00:10:41 I love DateUtil.

00:10:42 I think it's like magic for the pain of parsing dates.

00:10:45 But that's not what you install.

00:10:47 You install Python underscore DateUtil.

00:10:49 Right.

00:10:49 And so there's just, it's those situations where you're like, why is there no DateUtil?

00:10:53 I pip install DateUtil.

00:10:55 And then it's not even the right thing.

00:10:56 Or, you know, it's just, yeah, I think it's helpful to sort of put those things together for people.

00:11:01 Yeah.

00:11:01 And for people doing new packages, don't do this if you can.

00:11:04 Even if you have the perfect name for your package, maybe come up with something else that you can actually, it's available on PyPI.

00:11:12 Yeah.

00:11:13 Yeah, for sure.

00:11:13 All right.

00:11:14 Nick, you got the next one, right?

00:11:15 Yep.

00:11:16 I got the next one.

00:11:18 So I was looking through Jupyter.

00:11:23 So I'm going to get, as I said, as a data engineer, I often use Jupyter for like data wrangling and just trying out how to like clean up some kind of data before I actually do the actual cleaning in our data pipeline.

00:11:37 And so I stumbled, I got the new iPad.

00:11:39 And I was, I went, I went to like tinkering around with like Python code and I was like researching into how to do that.

00:11:46 And I stumbled across Jupyter light and I was like, okay, cool.

00:11:49 Jupyter light.

00:11:50 But sometimes I'm not going to always going to be connected to internet using my iPad.

00:11:55 And then I looked deeper into it and it's a, Jupyter distribution that runs entirely in the browser.

00:12:02 And it's like built from the ground up using Jupyter lab components and extensions.

00:12:07 And that's cool.

00:12:09 And the, and the kernels that are available are like in the browser.

00:12:14 So like there's a Python kernel that is like in the browser and it's built using PyIodide.

00:12:19 That was like really cool to see.

00:12:21 and there's also like, I think there is a, where is it in the user guide, there are other kernels such as, yeah.

00:12:31 JavaScript and P5 JS, which I think is like a graphics library to build like things on canvas, but it was really cool to see like it's supports Python 3.8.

00:12:42 And, you get like start session.

00:12:45 You can run Python code, Python completion, which is really cool.

00:12:50 It's interesting.

00:12:50 They call the kernel Pyolite.

00:12:53 Pyolite based on PyIodide.

00:12:56 Yeah.

00:12:57 And this is, I pulled it on.

00:12:59 This is how it looks like.

00:13:00 And it looks pretty cool.

00:13:02 So it also supports, right.

00:13:04 I think for now it supports Altair and, I think Matplotlib as well.

00:13:10 I think.

00:13:10 Yeah.

00:13:11 Matplotlib.

00:13:12 And so like open up this Altair notebook.

00:13:17 it even has something called Micropip.

00:13:20 which is like, I don't know what this means, but if you're, it, I think it means that it's, like, is a package manager, but for the browser for Python, which is interesting.

00:13:32 Oh, and it's, it's, it's, asynchronous because it's JavaScript basically.

00:13:37 Right.

00:13:37 So it's a wait micro pip installed like Jinja2, or Altair or something like that.

00:13:42 How interesting.

00:13:42 That's very cool.

00:13:44 I think it also, everything that you download and everything that, all the data that you, like, load up,

00:13:52 it's being stored in the browsers, like local storage or some other, I don't know, indexed DB.

00:13:59 So it's, like, self-contained.

00:14:02 The only thing I noticed is that right now, it's not, what was the word here?

00:14:09 A PWA.

00:14:10 Yes, I was just thinking it would be fantastic if that was a progressive web app

00:14:15 and then you could just have it in mostly offline mode, yeah.

00:14:18 Edge does a great job with PWAs and every time it detects, like, a manifest adjacent

00:14:25 to show you, do you want to install this app?

00:14:26 And I would just love to have, like, just click install and then have Jupyter Lite wherever I go

00:14:32 or load it up on my iPad and then disconnect and still be tinkering around with what I want.

00:14:36 So this is all browser-based.

00:14:38 So that's really cool.

00:14:39 I'm not going to run any of these, but I encourage everybody to check this out.

00:14:43 It's pretty cool.

00:14:44 Yeah, yeah, this is really cool.

00:14:45 I do the same thing with, I use Brave.

00:14:47 So I have, like, a YouTube app installed on my Mac and I've got a Twitter app installed.

00:14:54 All is progressive web apps, so you can just launch them.

00:14:56 I do wish Firefox supported that.

00:14:58 Firefox, people, if you're listening, bring back the progressive web app.

00:15:01 We all need this.

00:15:02 Yep.

00:15:03 Yeah, that's cool.

00:15:03 What are some of the other notebooks in there that look cool?

00:15:05 Are these, like, demo ones or did you create these?

00:15:09 Yeah, there's a demo one.

00:15:10 So there's a P5JS one.

00:15:13 There's the Altair one.

00:15:15 I don't know what Folium is.

00:15:16 There's the interactive widgets, which is cool.

00:15:19 So it still uses Jupyter's iPython notebook widgets, Matplotlib.

00:15:26 Oh, Plotly as well.

00:15:28 Nice.

00:15:29 And Plotly, cool.

00:15:30 And so this is a de facto, like, Pyolite one.

00:15:33 So it supports Matplot, Pandas.

00:15:36 That's cool.

00:15:37 It supports LaTeX as well.

00:15:39 Yeah, it's great.

00:15:40 And so, like, as I was saying before, Pyolite is, what is it?

00:15:46 It's, like, implementation of Python on the browser.

00:15:51 Actually, implementation of Python is on the computing stack on the browser.

00:15:56 So I think things like Pandas, NoobPy, SciPy, SciCutLearn are already, like, available.

00:16:02 It's within the Pyolite ecosystem.

00:16:05 So you don't have to...

00:16:05 Yeah, I had the guys behind it, you know, Firefox and Mozilla were behind it originally, at least.

00:16:10 And I had them on Talk Python.

00:16:12 I believe it's WebAssembly based.

00:16:14 I think what they did is they took all these major visualization libraries and things like Pandas and NumPy

00:16:20 and compiled them all into a Python plus those WebAssembly thing that runs in the browser.

00:16:26 instead of a JavaScript version, which is pretty awesome.

00:16:28 Oh, even Symbol.

00:16:29 Yeah, the symbolic output, like, got the math symbol integral of the square root of one over XDX.

00:16:35 Beautiful.

00:16:36 I wonder if you could get hand calcs on it.

00:16:38 Oh, yeah.

00:16:39 Awesome.

00:16:42 Cool.

00:16:43 All right.

00:16:43 Well, that's a really good one.

00:16:44 I love it.

00:16:45 All the data scientists out there can definitely enjoy that.

00:16:48 Yeah, cool.

00:16:49 What do we got next?

00:16:51 I think you're up next.

00:16:52 Oh, right.

00:16:53 Okay.

00:16:54 So next, we've got...

00:16:56 More plotting, maybe?

00:16:57 Yeah, more plotting.

00:16:58 So this is a long title.

00:17:02 Basically, it's lots of plots.

00:17:03 There's eight popular graphs made with Pandas, Map, Plotlib, Seaborn, and Plotly Express.

00:17:11 And I've seen a lot of articles and stuff talking about how to do different plots in one or more of these.

00:17:19 And a lot of them are...

00:17:20 A lot of the articles, and rightly so, are focused on something cool you can do with one library that you can't do with others.

00:17:26 And I've seen Seaborn ones like that.

00:17:29 And that's great.

00:17:30 What I like about this article is it's like, well, let's just take these different pandas plotting and Map, Plotlib, Seaborn, Plotly Express, and do the same plot.

00:17:42 Let's do something they can all do.

00:17:44 And so that's what this article does.

00:17:46 It does a whole list.

00:17:49 You've got normal line charts, grouped bar charts, stacked bars, pies, a whole bunch of things, and histograms.

00:17:57 And then you can just compare to see what it looks like before you try.

00:18:01 And for one, it's got the output, what do the graphs look like, which is important.

00:18:08 But also, it's a fairly simple article.

00:18:11 It's talking about what the plots look like, but also how do you make them?

00:18:14 It's in a Jupyter Notebook Viewer.

00:18:18 And it shows you what's the code look like to get these plots set up.

00:18:23 And I think that's a big part of choosing your plotting library is looking at the API to see what kind of API looks comfortable to you.

00:18:30 Yeah, I've got to write this code.

00:18:32 Will I be able to remember this?

00:18:33 Yeah.

00:18:34 Or will it be like regular expressions and I learn it every time I use it?

00:18:37 Yeah, or if you get stuck with one and you want to switch to other to sort of look at what the deltas are.

00:18:42 I like these side-by-side apples-to-apples comparison sort of articles.

00:18:46 So I think this is good for choosing the simple parts of plotting.

00:18:50 But some of the comparisons are sort of funny because the bar charts just kind of all look the same.

00:18:55 That one's orange versus orange and blue versus green and blue.

00:19:02 It's not all the same.

00:19:03 Yeah, but you get down into some of the fancy ones and they do look great.

00:19:08 Some of the area charts.

00:19:10 Yeah, that one looks great.

00:19:12 What's that?

00:19:13 Polly Express area charts look awesome.

00:19:15 Yeah, the area charts look good.

00:19:17 And I didn't know what a donut chart was.

00:19:20 A donut chart looks like a pie chart with a hole in it.

00:19:22 Yep.

00:19:23 Why do people use that?

00:19:24 I think it's because of like with the pie charts, the sectors are kind of, it's kind of, sometimes it can be hard to see like how much width.

00:19:35 No, like, yeah, the circumference of like this sector.

00:19:39 So maybe the donut chart kind of makes it easier to see like, okay, this takes like all of this.

00:19:44 It's just a visual thing, to be honest.

00:19:46 Yeah.

00:19:46 Okay, good.

00:19:48 Nick, this is your world.

00:19:49 What do you think?

00:19:49 I think this is really cool, but to be honest, all of these APIs don't compare to the grammar of graphics from R.

00:19:57 And so I usually, if I am going to do graphics in Python, I would prefer to use something that like conforms to the grammar of graphics.

00:20:07 Because to me, that's kind of, you know how like Python has the import this and it's all philosophy of how to write Python.

00:20:16 The grammar of graphics like has that.

00:20:18 So it has like, gives you these like sentences, so to speak, to build graphics.

00:20:23 And I was like, that makes so much sense in my head.

00:20:25 So like for graph, for graphing lab reads, it's either Altair or ggplot.

00:20:30 And there is like a Python port of ggplot that's pretty good.

00:20:36 But I think Altair is like the Pythonic de facto version that I've used.

00:20:40 That's really nice.

00:20:42 All the other ones that make me have to do like, like, like, like, do these method calls on objects.

00:20:50 Just, I can't, I can't remember it.

00:20:52 I have to come back to something like this.

00:20:54 So how do you use gnm.lib?

00:20:56 Are you using Seaborn?

00:20:57 I really like the fact that like Seaborn has a lot of one liners to like do simple charts in one line, which is great.

00:21:05 Like with the grammar graphics, right?

00:21:06 It still makes you have to build everything out.

00:21:08 But if I'm building something really custom or I am just building something that I have, I want to have complete control over.

00:21:18 The grammar graphics just gives me a better way of like remembering what to do compared to having to remember all this API, all this API, all this method API calls.

00:21:27 Well, I mean, the author, Dylan Castillo, says, let me know what you think.

00:21:32 So maybe we can give him some feedback to add Altair and a couple others.

00:21:37 Oh, yeah, that'd be cool.

00:21:38 Dean also has some thoughts out there, right?

00:21:41 Oh, Seaborn and Pandas use Matplotlib in the backend.

00:21:44 So you can do everything they can do with Matplotlib.

00:21:47 Okay, maybe harder, but not impossible.

00:21:49 And also, that's probably why they look all the same.

00:21:51 They are the same.

00:21:55 Turtles all the way down.

00:21:56 And he also says, remember, kids, almost every command in Matplotlib returns the object it charts.

00:22:01 That's the start of OOP, object-oriented plotting.

00:22:04 All right, right on.

00:22:05 Oop, it'd be two Ps.

00:22:07 Oop, oop, oop.

00:22:08 I don't know how to pronounce that.

00:22:10 All right, well, Brian, you got to talk about databases.

00:22:14 So I'm going to talk about databases, too.

00:22:16 But my databases are going to be smaller and in-memory and embedded, but also about MongoDB.

00:22:22 So there's this really cool one created by David Latwi called MontyDB.

00:22:28 So it's a Monty.

00:22:31 It's a MongoDB tiny-ified.

00:22:34 So it's MongoDB implemented in Python.

00:22:37 And you can have it in process, kind of like SQLite, I believe.

00:22:41 We've covered a couple of these libraries that are starting to show up that let you do sort of embedded MongoDB, which I think is really neat.

00:22:48 So it's inspired by TinyDB and its extension TinyMongo.

00:22:52 So the way you work with it, it's super simple.

00:22:55 You just import the Monty client.

00:22:57 And if you want to go crazy, you could say as Mongo client and make it basically the same.

00:23:01 And then you can give it connection strings like colon memory colon.

00:23:04 That should look familiar from something like SQLite.

00:23:07 And then you can insert data to it, do all sorts of things, and do queries against it, run the MongoDB query syntax against it, and you get the responses back, which I think is pretty cool.

00:23:18 It's certainly interesting for testing.

00:23:20 If you told it to use a file storage, it could be an interesting little embedded database and things like that.

00:23:27 So pretty cool.

00:23:28 It supports many of the MongoDB versions up to 4.2 and 4.4 on the way with wave emoji.

00:23:34 I'm not really sure about that, but also supports the...

00:23:38 What's that?

00:23:38 I think it's sweat.

00:23:39 Oh, gotcha.

00:23:41 Like the work is being done.

00:23:42 Gotcha.

00:23:42 So you can pip install MontyDB, and it will work in sort of its way.

00:23:49 If you want to use the actual serialization library from MongoDB itself, you can say install MontyDB bracket BSON to install that as well.

00:23:59 And it also has a lightning memory map DB, LMDB library.

00:24:05 You can use that as the storage engine as well.

00:24:07 So you can pip install, you know, add that on as well.

00:24:10 So for the storage, you've got in memory, you've got a flat file.

00:24:13 It'll actually use SQLite as a back-end store, which is pretty cool.

00:24:16 And then that LMDB lightning memory mapped DB.

00:24:20 So this looks pretty neat to me if you're going to do some kind of embedded thing or you're going to do some testing and you want something lightweight that's not a separate server you've got to set up and run and all those kinds of things.

00:24:32 This is cool.

00:24:33 I think it's awesome.

00:24:35 Could you make this a pytest fixture, Brian, that just gives you, like, presets up your database and gives you access to the connection or something?

00:24:41 Yeah.

00:24:42 I mean, actually, I'm not really a fan of people switching their databases too much for testing because most modern databases have in-memory options or smaller version options.

00:24:52 But, I mean, we use SQLite for tons of stuff that's not just for testing.

00:24:57 And if you've got SQLite at the back-end, there's no reason why this couldn't be a production thing then.

00:25:02 Yeah, absolutely.

00:25:04 No, this is really cool.

00:25:05 This could be really useful for, like, CLI apps that need to store your things.

00:25:11 Yes, exactly.

00:25:12 You want to have a little thing, but you don't want to say, oh, you want to run my little utility I packaged up with Py2 app or Py2.exe or something?

00:25:20 Yeah.

00:25:20 You're going to need to install MongoDB and become an admin of that.

00:25:23 No, you just use, like, a SQLite file as the back-end store or the LMDB version.

00:25:29 Another thing that's common from the MongoDB world is there's a set of CLI tools that allows you to manage it.

00:25:35 So I can connect to it.

00:25:37 I can import a bunch of exported files from some other or backed-up files from some other MongoDB instance and import that into my current server or whatever or create those exports, right?

00:25:51 There's actually a bunch of utilities called Monty Import, Monty Export, Monty Restore, Monty Dump.

00:25:57 All of these are the parallels of Mongo, Mongo Dump, Mongo Restore, and so on, right?

00:26:04 So if you were used to working with MongoDB, it's not just explicitly that there's some API to talk to some file.

00:26:11 There's also, like, the tools that are there as well.

00:26:13 Yeah.

00:26:14 Yeah, I don't know.

00:26:15 I think that could be a cool project.

00:26:17 So why don't I make this mostly for just fun and practicing on it, but also need it to run in this limited little environments for, like, render farms in the film industry.

00:26:26 So that's pretty cool.

00:26:27 It's a side project also with render farms.

00:26:33 It's a side project for my supercomputer, yes.

00:26:35 I love the name, by the way, Monty, Monty Python.

00:26:40 I love it.

00:26:40 Yeah, I mean, yeah, it really brings the MongoDB wordplay in with Monty Python, Python origin.

00:26:47 Yeah, pretty cool.

00:26:48 All right, Nick, you got the last one.

00:26:49 Awesome.

00:26:52 Exhaustiveness checking with mypy.

00:26:54 So essentially what exhaustiveness checking is, is a feature of, like, a lot of type checkers where they guarantee that the programmer has covered all their cases.

00:27:06 And so with mypy, you could essentially check things, like, whether you've covered all the, like, you have written all the if statements you're supposed to write at compile time rather than figuring that out at runtime.

00:27:22 And, like, I really got into using mypy and trying to, like, have it save my bot a lot in the way I think about code by embracing types.

00:27:34 So I stumbled across this, which was, like, really interesting, where this article written by Haki Benita went into how, like, exhaustive net checking actually works.

00:27:46 So they start out with an enum that has order status.

00:27:51 And you have a function that is called handle order that takes a status, which is an instance, which should be an instance of order status.

00:28:01 And so in his function, he has this, like, if status is order ready, you do something.

00:28:07 If status is order shipped, you do something.

00:28:09 But then he gave this, like, added this, like, new, like, scenario where what if you wanted to check the status of something scheduled?

00:28:20 And so he tried to run mypy right now.

00:28:23 I didn't complain about it.

00:28:24 So it was like, okay, cool.

00:28:25 Yeah.

00:28:26 Because one of the things that's very common is if you have something like a set of cases, in this case, it's put together in an enumeration.

00:28:32 Yeah.

00:28:33 You have more cases over time.

00:28:35 But all these if, else if, else if, else if statements all over your code, have you exhaustively gone through and added that case check for all of them?

00:28:44 Probably not.

00:28:45 Yeah, probably not.

00:28:46 Unless you've got good tests.

00:28:46 A really good test.

00:28:47 Yeah.

00:28:48 Okay.

00:28:49 And so he proposed, like, one quick way of checking that you handled all cases is by adding this assert false, comma, unhandled status.

00:29:01 And you pass in the status using f-strings.

00:29:04 And so then when you try to pass a state that you have not actually handled before, you actually get assertion error, right?

00:29:12 Which is all right, but if you use mypy, there's this clever trick where you create a function called assert never that takes a value called no return and returns no return.

00:29:26 And in it, it has the assert false unhandled value.

00:29:29 And so then when you use that function in your handle order function, at the end case, you have this else assert never and you pass in the status.

00:29:41 Now when you check with mypy, mypy will know, hey, argument one to assert never has incompatible type, literal, order status schedule, expected, no return.

00:29:50 Oh, how interesting.

00:29:52 Yeah.

00:29:52 And this is a compile time and you can actually get this.

00:29:54 Yeah, yeah.

00:29:55 That's, I think that's the important thing because I was looking at that going, oh, I could just add the else statement and put the assert there and have nothing to do with mypy and it would catch that error.

00:30:03 But that catches that error when that code runs.

00:30:06 Like I said before, you know, hopefully there's tests, but oftentimes there's not tests for everything.

00:30:10 Yeah.

00:30:11 Yeah.

00:30:11 And so especially there might not be a test for the new thing you've added.

00:30:16 And so this is cool in that it checks all the possible types that could go in there.

00:30:20 That's cool.

00:30:20 Yeah.

00:30:21 Yeah.

00:30:21 Yeah.

00:30:21 And the part that really got me was that it integrates with your IDE.

00:30:27 So PyCharm, VS Code, or any editor that implements a language server can then like look at this and say, hey, you haven't handled all your cases.

00:30:37 Right.

00:30:38 And you get that immediate feedback rather than having to run your code and then find out, oh, dang it, I missed this case.

00:30:45 Right.

00:30:46 Yeah.

00:30:47 So people who are not looking at the live stream YouTube stream, which is almost all the people listening.

00:30:52 Nick is showing on the screen this assert function that's checking the numeration.

00:30:59 And there's just a red squiggly line that literally says assert never has incompatible order status that's scheduled.

00:31:05 That's the missed enumeration case.

00:31:08 I think that's incredible that actually finds this.

00:31:10 Yeah.

00:31:10 And it works because mypy uses this technique called type narrowing.

00:31:18 And essentially what that means is that it would, given a variable as it goes through like a control flow, like if statements, switch statements, my loop, mypy will like kind of confine or in other words, narrow down the types as it goes through those control flow.

00:31:39 And so it works with enumeration types, unions, literals.

00:31:45 So I have in the article, there are examples of how you could pass in a union of different types, strings, float, and you could still use this technique and to tell you, hey, you've missed a case.

00:31:57 Or you could do this with literals.

00:31:59 So you have like RGB and then you only implemented the, you only check for like two cases, which are R and G.

00:32:07 And then to tell you, hey, you did not handle the B case.

00:32:11 So yeah.

00:32:12 And so like the article goes further into different ways in which you could set this up.

00:32:18 Have mypy check all of the different cases for you, which is really cool.

00:32:23 You've even got like the, the various sweets for cards, like clubs, diamonds, hearts.

00:32:29 Yeah.

00:32:29 It's interesting that like to mypy, when it sees an enum that has like clubs, diamonds, hearts, and spades, all it sees is like a union of literals, which are sweets, cards, sweet clubs, sweet hearts, which is actually interesting.

00:32:45 That's how mypy sees it.

00:32:46 Yeah.

00:32:46 That's very interesting.

00:32:47 I mean, basically it's emojis.

00:32:49 Yeah.

00:32:49 It's emojis.

00:32:51 Right.

00:32:52 The one other thing I wanted to mention here is that there was a specific, oh yeah.

00:33:00 This feature is actually something that Guido actually thought was pretty cool.

00:33:07 And so I think it's part of a PEP 622, a structural pattern matching already.

00:33:12 So if you are matching against an enum or something that has like multiple different like states, the matching, hopefully Python 310 will give you a nice error saying, hey, you missed a particular case.

00:33:28 And this could really, and if you're a Django developer or you just use Django or even, yeah, you just use any ORM and the ORM provides something like choices where like yes, no, or dollar, euro, like these kinds of choices in the field.

00:33:45 This works pretty well.

00:33:46 And so in your Django code, you could actually have mypy telling you, hey, you missed handling a particular case.

00:33:53 Crazy.

00:33:54 Yeah.

00:33:54 That's awesome.

00:33:55 Yeah.

00:33:55 Which is really cool.

00:33:56 Yeah.

00:33:57 Sam out in the live stream was sort of on to the same thoughts you were talking about with Peter there.

00:34:01 I wonder if one could hack on the match mechanism to deliver this functionality at runtime using by somehow getting all the variants of the enum and checking the branches, the AST or something.

00:34:13 Yeah.

00:34:13 That's interesting because I know that part of the structural pattern matching, like any object can implement the magic method match.

00:34:24 And maybe that's like, yeah.

00:34:28 And maybe that's your gate, like that's your entry point into providing that kind of checking at runtime.

00:34:31 Of course, with Python, anything that is around runtime checking, there's like performance costs with that.

00:34:39 So be careful.

00:34:40 Yeah.

00:34:41 But having this built into mypy already would be good.

00:34:44 And Juergen is talking about it on the live stream.

00:34:48 He says, I wonder whether you could rewrite the code to not use if statements at all,

00:34:52 but be more polymorphic, which I agree.

00:34:56 It's a really interesting idea with the method overloading and stuff.

00:35:00 And it reminds me back a couple of weeks ago, Brian talked about function overloading

00:35:05 with single dispatch and multiple dispatch.

00:35:06 And yeah, you could kind of more or less make that happen there.

00:35:10 So yeah, pretty neat.

00:35:11 Although you still may miss a case.

00:35:12 I'm not entirely sure.

00:35:13 At least in the enumeration bit, that won't help you, right?

00:35:16 Because the enum will still be the same type.

00:35:18 It'll just have more values.

00:35:20 Yeah.

00:35:20 Awesome.

00:35:21 Good one, Nick.

00:35:22 Brian, what else we got?

00:35:23 Well, I've got a couple of things.

00:35:25 One of the things I wanted to note was that this is the second week in a row

00:35:30 we've featured an article by Haki and the third in this year.

00:35:36 So we should probably try to get him on the show or something.

00:35:38 Yeah, absolutely.

00:35:40 That sounds good.

00:35:41 He's doing some good writing.

00:35:42 So thanks.

00:35:43 The other thing I wanted to mention is I've got...

00:35:48 Oh, yeah.

00:35:49 By the way, my book is out.

00:35:50 Yay!

00:35:52 This is the book, too.

00:35:54 Yeah.

00:35:55 Second edition of pytest is available for beta.

00:35:57 So people can tell me everything that's...

00:36:00 I already got it.

00:36:01 Somebody said they have got an issue.

00:36:03 It's a minor issue with it already.

00:36:06 So thanks.

00:36:08 But it's just been me and my editor so far working through it.

00:36:11 So having more people, more eyes before we go to shipping the physical book would be great.

00:36:16 So, of course, this is through Pragmatic.

00:36:19 But if you go to pytestBook.com, it'll take you there.

00:36:23 So that was my extra.

00:36:24 Right on.

00:36:25 Cool.

00:36:25 I've got a couple as well.

00:36:26 Yeah, I got some neat ones here.

00:36:28 So how often do you maybe have like a blueprint floor plan?

00:36:32 Maybe you're looking at a house and you're trying to decide whether you want to buy it.

00:36:36 What would it be like to actually live there?

00:36:39 Maybe you're trying to figure out, well, I'm planning out this apartment or I have this place.

00:36:43 I want to remodel it like IKEA it all out or something along those lines.

00:36:47 I ran across this thing that uses some interesting models called plan to scene.

00:36:53 So the idea is it'll take what is literally a floor plan, like a blueprint floor plan that shows like swinging doors and bits.

00:37:01 And then you tell it what kind of room it is.

00:37:03 It's like a bedroom or a bathroom or whatever.

00:37:05 And it will generate a 3D world that has things like sinks and toilets and couches that are three dimensional, not just somehow projected in there.

00:37:16 So there's all of these interesting things you can see.

00:37:19 If you pull up the site, there's all these like spinning worlds.

00:37:21 And you can see that they've created these little environments just from floor plans, which I think is pretty insane.

00:37:27 So anyway, you can go ahead, Nick.

00:37:30 No, that's really cool.

00:37:32 And I think I wonder if like, because like Trimble, we, we own like SketchUp.

00:37:36 I wonder if they do this kind of stuff.

00:37:38 They take floor plans and then they make it 3D.

00:37:42 That's really cool.

00:37:43 Yeah.

00:37:44 There's a whole bunch of comparisons of how it used to be done, how you can pick like different, you know, different flooring and walls and source codes available on GitHub.

00:37:53 People can run with that.

00:37:54 So that's pretty cool.

00:37:55 It's called Plan to Scene.

00:37:56 And then just a quick shout out to this TCAS podcast I happen to be a guest of recently.

00:38:02 And we got to talk about Python and data science and how Python and data are sort of changing the world and stuff.

00:38:09 And it's really fun.

00:38:09 So people can check that out.

00:38:11 Yeah.

00:38:11 And that's it for the things I got.

00:38:12 Nick, anything else you want to throw out there?

00:38:14 Yeah.

00:38:14 Just a shameless plug.

00:38:16 As I said earlier on the live stream, I co-host the Clipi, which is Cleveland's area Python meetup group.

00:38:26 And so we have meetups every second Monday of the month.

00:38:31 And one of the reasons why I would encourage anybody across the world or U.S. or everywhere to still come and present is because oftentimes meetups are a great place to present talks that you are planning on giving.

00:38:48 And maybe like continental conferences or like other larger conferences, you know, smaller crowd.

00:38:56 And, you know, we show you guys a good time.

00:38:59 Right.

00:38:59 So it's a great place to come, give your talk, get feedback from that, and then, you know, take and improve on it.

00:39:06 So that's one.

00:39:07 And then the other shameless plug is that Pye Ohio has its own conference coming up on July 31st.

00:39:19 Registrations are open.

00:39:20 We have pretty cool T-shirts.

00:39:21 So, yeah, register.

00:39:23 And that's a, is that live or streaming?

00:39:26 Yes, that is being streamed.

00:39:29 Okay.

00:39:29 How about your meetups?

00:39:30 Are those being, are those streamed or live?

00:39:32 Those are virtual.

00:39:33 We used to have them like in person.

00:39:35 And that's, I really, that's when like.

00:39:37 And then it really messed things up because you have stuff like pizza over and those have a good time talking about Python.

00:39:43 But no, the virtual setting has given a lot more people access.

00:39:48 You know, we're able to have more people on.

00:39:51 So.

00:39:51 Nice.

00:39:52 Yeah, that's fantastic.

00:39:53 And Pye Ohio is definitely one of those big regional conferences that a lot of people pay attention to, even if they're not in Ohio.

00:39:59 Definitely.

00:40:00 Are you going to go back to in-person only?

00:40:02 Are you going to do like a hybrid stream and in-person or is it going to be, what's your plans for when the world returns to normal?

00:40:09 That's if it ever returns to normal.

00:40:11 I think we'll change forever.

00:40:14 But to answer your question, I think my co-organizer and I have been thinking about them.

00:40:20 We don't, we're not yet set yet.

00:40:22 Like we see the benefits of the virtual, but we also see the benefits of the live.

00:40:27 And there are things that have changed so much.

00:40:29 We don't even know whether the live person is still available.

00:40:33 But no, it's something we're thinking about.

00:40:34 Yeah.

00:40:35 Cool.

00:40:36 Well, it's a challenge.

00:40:37 I think all the meetups and other events are having, especially these smaller, like monthly, biweekly sort of things.

00:40:44 Yeah.

00:40:44 You know, it's one thing to say that there's going to be a big conference and we'll all go to it or not.

00:40:48 But you're doing it every couple of weeks and it's mostly local, but not 100% local.

00:40:52 Yeah, it's a challenge.

00:40:53 Yeah.

00:40:54 Fantastic.

00:40:55 All right.

00:40:55 Brian, you ready for a joke?

00:40:57 Definitely.

00:40:58 Okay.

00:40:58 So I've got one and then Nick has one.

00:41:01 So this one, the title of the joke is Root Beer Float.

00:41:04 Okay.

00:41:05 So a programmer walks into a bar.

00:41:07 He orders 1.000000119 root beers.

00:41:13 The bartender says, I'm going to have to charge you extra.

00:41:15 That's a root beer float.

00:41:17 The programmer says, well, in that case, make it a double.

00:41:20 It's bad, right?

00:41:22 That's bad.

00:41:24 Yeah.

00:41:24 All right.

00:41:25 And Nick, you've got one as well.

00:41:27 You want to do this one for us?

00:41:28 Yeah.

00:41:28 Would someone like to joke?

00:41:30 You want me to be the bearded person?

00:41:32 Yeah, I really have something going on there anyway.

00:41:34 All right.

00:41:35 So will refactoring the code improve the loading time?

00:41:39 Not really.

00:41:40 Will it improve the security then?

00:41:42 No.

00:41:42 So it's for browser compatibility?

00:41:45 Yeah, no, not really.

00:41:46 Nope.

00:41:47 So tell me, why is it always the same old story with you guys wanting to refactor everything

00:41:53 I need to know?

00:41:55 Because as devs, if we know, excuse me, if we know we've left behind some messy code,

00:42:01 we can't stop thinking about it.

00:42:02 We wake up in the morning at lunchtime in the evening when we go home and when we're trying

00:42:07 to go to sleep.

00:42:08 It haunts us.

00:42:09 You know, it haunts us.

00:42:11 I love it.

00:42:14 And it's true too.

00:42:15 It's totally true.

00:42:18 It's totally true.

00:42:19 All right.

00:42:19 I have one more joke for you guys.

00:42:21 Oh yeah.

00:42:22 Hit us.

00:42:22 All right.

00:42:23 How much does a chimney cost?

00:42:25 No idea.

00:42:26 Nothing.

00:42:27 It's on the house.

00:42:27 Very good.

00:42:31 That's, I have a friend that is so, so into dad jokes, which is weird because it's only

00:42:36 22.

00:42:37 Practicing.

00:42:41 Practicing for the future.

00:42:42 Yeah.

00:42:43 I don't think dads can be blamed for all bad jokes.

00:42:46 Anyway.

00:42:50 Yeah.

00:42:50 I want to highlight, Juergen, says that they cost 2,500 euros.

00:42:55 That's expensive.

00:42:56 Well, thanks a lot for joining us today.

00:43:00 this was a lot of fun and, thanks everybody in the stream for showing up and, we'll talk

00:43:05 to everybody next week.

00:43:07 Thanks.

00:43:07 Bye everyone.

