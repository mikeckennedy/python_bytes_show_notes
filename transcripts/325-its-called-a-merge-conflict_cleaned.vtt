
00:00:00.000 --> 00:00:05.000
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:05.000 --> 00:00:12.600
This is episode 325, recorded February 28th, the last day of February in 2023.


00:00:12.600 --> 00:00:13.700
I am Brian Okken.


00:00:13.700 --> 00:00:14.900
And I am Michael Kennedy.


00:00:14.900 --> 00:00:19.800
And before we jump in, I want to thank everybody that shows up for the livestream.


00:00:19.800 --> 00:00:22.700
If you haven't shown up for the livestream before, it's a lot of fun.


00:00:22.700 --> 00:00:28.100
People can stop and ask questions and chat and everything, and it's a good way to say hi.


00:00:28.100 --> 00:00:33.500
And we enjoy having you here or watch it afterwards if this is a bad time for you.


00:00:33.500 --> 00:00:39.140
Also want to thank Microsoft for Startup Founders Hub for sponsoring this episode.


00:00:39.140 --> 00:00:41.880
They've been an excellent sponsor of the show and


00:00:41.880 --> 00:00:47.380
they've also agreed to have us like be able to play with the sponsor spots and do some AI reading.


00:00:47.380 --> 00:00:49.140
So this one's going to be a fun one, this one.


00:00:49.140 --> 00:00:50.680
So I'm excited about it.


00:00:50.680 --> 00:00:52.180
>> I am too, it's going to be fun.


00:00:52.180 --> 00:00:56.340
>> So why don't you kick us off with our first topic today.


00:00:56.340 --> 00:00:59.020
>> All right. Let's jump right in.


00:00:59.020 --> 00:01:00.380
You like solid code.


00:01:00.380 --> 00:01:02.540
How about some Codesolid.com?


00:01:02.540 --> 00:01:03.900
Has nothing to do with solid code,


00:01:03.900 --> 00:01:06.060
but it's still interesting and it does have to do with code.


00:01:06.060 --> 00:01:10.140
This one is something called Parquet and Arrow.


00:01:10.140 --> 00:01:14.380
Have you heard of Apache Arrow or the Parquet file format, Brian?


00:01:14.380 --> 00:01:18.300
>> I've heard of Arrow, but I don't think I've heard of Parquet.


00:01:18.300 --> 00:01:20.380
>> When people do a lot of data science,


00:01:20.380 --> 00:01:24.620
you'll see them do things like open up Jupyter Notebooks and import Pandas.


00:01:24.620 --> 00:01:27.720
And then from Pandas, they'll say "Load CSV".


00:01:27.720 --> 00:01:30.920
Well, if you could think of a whole bunch of different file formats


00:01:30.920 --> 00:01:34.520
and how fast and efficient they might be stored on disk in red,


00:01:34.520 --> 00:01:37.620
how do you think CSVs might turn out?


00:01:37.620 --> 00:01:41.320
Pretty slow, pretty large, and so on.


00:01:41.320 --> 00:01:47.020
And Arrow through PyArrow has some really interesting in-memory structures


00:01:47.020 --> 00:01:49.720
that are a little more efficient than Pandas,


00:01:49.720 --> 00:01:52.720
as well as it has access to this Parquet format.


00:01:52.720 --> 00:01:54.280
So does Pandas through an add-on,


00:01:54.280 --> 00:01:58.040
but you'll see that it's still faster using PyArrow.


00:01:58.040 --> 00:02:01.120
So basically, that's what this article


00:02:01.120 --> 00:02:02.120
that I found is about.


00:02:02.120 --> 00:02:04.440
It highlights how these things compare,


00:02:04.440 --> 00:02:07.440
and it basically asks the questions like,


00:02:07.440 --> 00:02:11.840
can we use Pandas data frames and arrow tables together?


00:02:11.840 --> 00:02:13.360
Like if I have a Pandas data frame,


00:02:13.360 --> 00:02:15.760
but I wanna then switch it into PyArrow


00:02:15.760 --> 00:02:19.180
for better performance at some point for some analysis,


00:02:19.180 --> 00:02:20.020
can I do that?


00:02:20.020 --> 00:02:21.040
Or if I start with PyArrow,


00:02:21.040 --> 00:02:22.780
could I then turn it into a data frame


00:02:22.780 --> 00:02:24.840
and hand it off to Seaborn


00:02:24.840 --> 00:02:27.780
or some other thing that expects a pandas data frame?


00:02:27.780 --> 00:02:28.620
Answer is yes.


00:02:28.620 --> 00:02:30.620
Short version there.


00:02:30.620 --> 00:02:32.380
Are they better?


00:02:32.380 --> 00:02:33.340
In which ways are they better?


00:02:33.340 --> 00:02:34.300
Which way are they worse?


00:02:34.300 --> 00:02:38.100
And then the bulk of the analysis here is like,


00:02:38.100 --> 00:02:39.780
yeah, we could save our data,


00:02:39.780 --> 00:02:40.700
read and write our data


00:02:40.700 --> 00:02:42.500
from a bunch of different file formats,


00:02:42.500 --> 00:02:44.980
Parquet, but also things like Feather,


00:02:44.980 --> 00:02:47.620
Org, CSV and others, even Excel.


00:02:47.620 --> 00:02:49.820
What should we maybe consider using?


00:02:49.820 --> 00:02:50.820
- Okay. - Okay?


00:02:50.820 --> 00:02:55.180
So installing it is just pip install pyarrow, super easy,


00:02:55.180 --> 00:02:56.580
same type of story.


00:02:56.580 --> 00:02:59.260
If you want to use it with pandas,


00:02:59.260 --> 00:03:01.740
so I've got some pandas data, a data frame,


00:03:01.740 --> 00:03:04.340
and then I want to then convert it over,


00:03:04.340 --> 00:03:05.660
that's super easy.


00:03:05.660 --> 00:03:09.700
So you can use, go to pyarrow,


00:03:09.700 --> 00:03:12.420
and you say pyarrow.table, say from pandas,


00:03:12.420 --> 00:03:15.180
and give it a pandas data frame, and then boom,


00:03:15.180 --> 00:03:17.620
you've got it in pyarrow format.


00:03:17.620 --> 00:03:18.460
- Okay.


00:03:18.460 --> 00:03:19.900
- One of the things that's interesting


00:03:19.900 --> 00:03:23.940
is with Pandas is a real nice like wrangling,


00:03:23.940 --> 00:03:27.020
exploration style of data.


00:03:27.020 --> 00:03:30.180
So I can go and I can just show the data frame


00:03:30.180 --> 00:03:32.940
and it'll tell me like there are 14 columns


00:03:32.940 --> 00:03:35.740
and this example, 6,433 rows


00:03:35.740 --> 00:03:38.740
and it'll list off the headers and then the column data.


00:03:38.740 --> 00:03:40.580
If I do the same thing in Pyro,


00:03:40.580 --> 00:03:43.740
I just get, it's kind of human readable.


00:03:43.740 --> 00:03:47.340
You just get like a dump of junk basically.


00:03:47.340 --> 00:03:48.460
It's not real great.


00:03:48.460 --> 00:03:50.940
So that aspect, certainly using pandas,


00:03:50.940 --> 00:03:52.980
is nice for this kind of exploration.


00:03:52.980 --> 00:03:55.580
Another thing about PyArrow is the data is immutable.


00:03:55.580 --> 00:03:58.680
So you can't say, oh, every time that this thing appears,


00:03:58.680 --> 00:04:01.300
actually replace it with this canonical version.


00:04:01.300 --> 00:04:03.660
You know, if you get like a Y,


00:04:03.660 --> 00:04:05.260
lowercase yes and capital yes,


00:04:05.260 --> 00:04:08.580
you wanna make them all just lowercase yes or just the Y,


00:04:08.580 --> 00:04:11.420
like you gotta make a copy instead of change it in place.


00:04:11.420 --> 00:04:14.940
So that's one of the reasons you might stick with pandas,


00:04:14.940 --> 00:04:16.340
which is pretty interesting.


00:04:16.340 --> 00:04:24.660
But you can do a lot of really interesting parsing and performance stuff that you would do with, like you would do with pandas.


00:04:24.660 --> 00:04:32.460
But if your goal is performance, and performance measured in different ways, how much memory does it take up in computer RAM?


00:04:32.460 --> 00:04:36.100
How much disk space type of memory does it take up?


00:04:36.100 --> 00:04:38.100
How fast is it to read and write from those?


00:04:38.100 --> 00:04:41.460
It's pretty much always better to go with PyArrow.


00:04:41.460 --> 00:04:46.860
So for example, if I take those same sets of data, those two sets of data from, I think


00:04:46.860 --> 00:04:51.380
this is the New York City taxi data, some subset of that really common data set.


00:04:51.380 --> 00:04:54.560
It's like a digit grouping.


00:04:54.560 --> 00:04:59.060
It's a little over three megs of memory for the data frame and it's just under a hundred,


00:04:59.060 --> 00:05:00.060
sorry, three megs.


00:05:00.060 --> 00:05:01.960
Yeah, I don't know if I said three megs.


00:05:01.960 --> 00:05:07.300
Three megs of data for pandas, whereas it's just under one meg for high era.


00:05:07.300 --> 00:05:10.860
So that's three times smaller, which is pretty interesting there.


00:05:10.860 --> 00:05:11.660
>> Yeah.


00:05:11.660 --> 00:05:14.700
>> The other one is if you do like mathy things on it,


00:05:14.700 --> 00:05:16.820
like if you got tables of numbers,


00:05:16.820 --> 00:05:21.900
you're really likely to talk about things like the max,


00:05:21.900 --> 00:05:24.460
or the mean, or the average, and so on.


00:05:24.460 --> 00:05:29.140
Now, if you do that to pandas and you do it to PyArrow,


00:05:29.140 --> 00:05:31.820
you'll see it's about eight times faster to do


00:05:31.820 --> 00:05:34.660
math with PyArrow than it is to do it with pandas.


00:05:34.660 --> 00:05:35.700
That's pretty cool, right?


00:05:35.700 --> 00:05:39.540
>> Yeah. The syntax is a little grosser, but yeah.


00:05:39.540 --> 00:05:45.420
the syntax is a little grosser, I will show you a way to get to this in a moment that is less gross, I believe.


00:05:45.420 --> 00:05:45.920
Okay.


00:05:45.920 --> 00:05:46.420
Okay.


00:05:46.420 --> 00:05:53.540
And then Alvaro out there does say, if you want fast data frames, Polars plus Parquet is the way to go.


00:05:53.540 --> 00:05:54.040
Okay.


00:05:54.040 --> 00:05:59.040
He's reading, skating to where the puck is going to be, indeed.


00:05:59.040 --> 00:06:03.720
And Kim says, presumably the immutability plays a large part in the performance.


00:06:03.720 --> 00:06:05.020
I suppose so.


00:06:05.020 --> 00:06:05.520
Yeah.


00:06:06.180 --> 00:06:09.860
And then also some feedback of real-time analytics here.


00:06:09.860 --> 00:06:11.940
Alvaro says, "I got a broken script from a colleague.


00:06:11.940 --> 00:06:15.780
I rewrote it in Pandas, and it took about two hours to process.


00:06:15.780 --> 00:06:17.780
In Polars, it took three minutes."


00:06:17.780 --> 00:06:22.180
So that's a non-trivial sort of bonus there.


00:06:22.180 --> 00:06:26.420
All right, let me go over the file formats, and I'll just really quickly--


00:06:26.420 --> 00:06:29.300
I think we've talked about Polars, but I'll just reintroduce it really quick.


00:06:29.300 --> 00:06:34.820
So if we go and look at the different file formats, we could use Parquet.


00:06:34.820 --> 00:06:41.480
So we could say 2 parquet with PyArrow and you get it out and these numbers are all kind of like insane.


00:06:41.480 --> 00:06:44.720
4 milliseconds versus reading it with 2 milliseconds.


00:06:44.720 --> 00:06:50.820
If you use the fast parquet, which is the thing that allows data frames to do it, it's 14 milliseconds,


00:06:50.820 --> 00:06:54.820
which is a little over three times slower, but it's still really, really fast, right?


00:06:54.820 --> 00:07:01.820
There's Feather, which is the fastest of all the file formats with a 2 millisecond save time, which is blazing.


00:07:01.820 --> 00:07:02.440
There's Ork.


00:07:02.440 --> 00:07:03.760
I have no idea what Ork is.


00:07:03.760 --> 00:07:04.840
It's a little bit faster.


00:07:04.840 --> 00:07:09.380
Or if you, you want to show that you're taking lots of time and doing lots of


00:07:09.380 --> 00:07:12.820
print processing, doing lots of data science-y things, you could always do


00:07:12.820 --> 00:07:14.980
Excel, which takes about a second almost.


00:07:14.980 --> 00:07:17.640
I mean, on a larger data set, it might take a lot longer, right?


00:07:17.640 --> 00:07:18.680
You're like, Oh, I'm busy.


00:07:18.680 --> 00:07:19.300
I can't work.


00:07:19.300 --> 00:07:20.800
I'm getting a coffee because I'm saving.


00:07:20.800 --> 00:07:25.480
Well, I mean, there's some people that really have to export it to Excel so


00:07:25.480 --> 00:07:27.300
that other people can make mistakes later.


00:07:27.300 --> 00:07:28.280
Yes, exactly.


00:07:28.280 --> 00:07:30.640
Cause life is better when it's all go-to's.


00:07:30.640 --> 00:07:31.200
Yeah.


00:07:31.200 --> 00:07:33.200
But no, you're right.


00:07:33.200 --> 00:07:36.200
If the goal is to deliver an Excel file, then obviously.


00:07:36.200 --> 00:07:40.200
But this is more like considering what's a good intermediate storage format.


00:07:40.200 --> 00:07:43.200
And then CSV is actually not that slow.


00:07:43.200 --> 00:07:45.200
It's still slower, but it's only 30 milliseconds.


00:07:45.200 --> 00:07:47.200
But the other part that's worth thinking about,


00:07:47.200 --> 00:07:50.200
remember this is only 6,400 rows.


00:07:50.200 --> 00:07:53.200
The Parquet format is 191K.


00:07:53.200 --> 00:07:56.200
The Pandas one is almost 100K more, which is interesting.


00:07:56.200 --> 00:07:58.200
The Feather is almost half a meg.


00:07:58.200 --> 00:08:01.700
Orac is three quarters of a meg, Excel is half a meg,


00:08:01.700 --> 00:08:03.000
CSV is a meg, right?


00:08:03.000 --> 00:08:06.600
So a meg, it's almost a five times file size increase.


00:08:06.600 --> 00:08:07.840
So if you're storing tons of data


00:08:07.840 --> 00:08:11.020
and it's five gigs versus 50 gigs,


00:08:11.020 --> 00:08:13.240
you know, you maybe want to think about


00:08:13.240 --> 00:08:14.360
storing it in a different format.


00:08:14.360 --> 00:08:16.880
Plus you read and write it faster, right?


00:08:16.880 --> 00:08:19.040
So these are all pretty interesting.


00:08:19.040 --> 00:08:24.020
And Polars, polars.rs is the lightning fast data frame


00:08:24.020 --> 00:08:25.680
built in Rust and Python.


00:08:25.680 --> 00:08:27.720
This is built on top of PyArrow.


00:08:27.720 --> 00:08:31.660
I had a whole, built on top of Apache Arrow.


00:08:31.660 --> 00:08:33.800
I had a whole Talk Python episode on it.


00:08:33.800 --> 00:08:35.860
I'm pretty sure I'd talked about Polars before


00:08:35.860 --> 00:08:38.980
on here as well, but it's got like a really cool


00:08:38.980 --> 00:08:41.220
sort of fluent programming style


00:08:41.220 --> 00:08:43.660
and under the covers it's using PyArrow as well.


00:08:43.660 --> 00:08:45.300
So pretty neat.


00:08:45.300 --> 00:08:47.260
Yeah, so if you're really looking to say like,


00:08:47.260 --> 00:08:51.180
I just wanna go all in on this, as Alvaro pointed out,


00:08:51.180 --> 00:08:53.220
I think it was Alvaro, that Polars is,


00:08:53.220 --> 00:08:54.940
yeah, that Polars is pretty cool.


00:08:54.940 --> 00:08:56.100
- Okay, neat.


00:08:56.100 --> 00:08:58.980
And Henry out there, real time feedback is,


00:08:58.980 --> 00:09:01.540
Pandas is fully supporting PyArrow for all data types


00:09:01.540 --> 00:09:04.380
in the upcoming 1.5 and 2.0 releases.


00:09:04.380 --> 00:09:06.740
There was just a ball of post on it


00:09:06.740 --> 00:09:08.420
on the Data Pythonista blog.


00:09:08.420 --> 00:09:11.620
It's not clear if they're switching to it.


00:09:11.620 --> 00:09:14.300
I believe it's NumPy at the moment as the core,


00:09:14.300 --> 00:09:17.700
but it's, it'd be supporting it, which is awesome.


00:09:17.700 --> 00:09:19.860
Yeah, thanks Henry for that update there.


00:09:19.860 --> 00:09:22.460
- Well, and then also, they said,


00:09:22.460 --> 00:09:25.340
but it did say basically starting to get native PyArrow speed


00:09:25.340 --> 00:09:27.420
with pandas by just selecting the backend


00:09:27.420 --> 00:09:28.900
in the new pandas version.


00:09:28.900 --> 00:09:30.020
So cool. - Indeed.


00:09:30.020 --> 00:09:31.740
Awesome, yeah, yeah, very, very cool.


00:09:31.740 --> 00:09:34.540
So lots of options here, but I think a takeaway


00:09:34.540 --> 00:09:37.100
that it's kind of worth paying attention to here


00:09:37.100 --> 00:09:39.660
is choosing maybe parquet as a file format,


00:09:39.660 --> 00:09:42.620
regardless of whether you're using pandas


00:09:42.620 --> 00:09:44.340
or PyArrow or whatever, right?


00:09:44.340 --> 00:09:46.420
'Cause I think the default is read and write CSV.


00:09:46.420 --> 00:09:49.060
And if your CSV files are ginormous,


00:09:49.060 --> 00:09:51.340
that might be something you wanna not do.


00:09:51.340 --> 00:09:53.500
- Yeah, okay. - All right, over to you.


00:09:53.500 --> 00:09:56.580
- Well, you said have ever heard of Parquet.


00:09:56.580 --> 00:09:58.940
And before we get to the next topic,


00:09:58.940 --> 00:10:02.940
I was thinking like, is it butter or is it Parquet?


00:10:02.940 --> 00:10:05.660
It was a thing from when we were kids, but.


00:10:05.660 --> 00:10:07.580
- That's right, margarine.


00:10:07.580 --> 00:10:09.340
Yum.


00:10:09.340 --> 00:10:11.980
- Parquet, had a little tub that talked, it was neat.


00:10:11.980 --> 00:10:15.060
- That's right, it did, it had a little mouth, yeah.


00:10:15.060 --> 00:10:18.260
- Yeah, I wanna talk about FastAPI a bit.


00:10:18.260 --> 00:10:23.140
So this topic, FastAPI filter comes from us from Arthur Rio


00:10:23.140 --> 00:10:25.280
and Arthur, actually, it's his library,


00:10:25.280 --> 00:10:30.840
FastAPI Filter, and this is pretty cool.


00:10:30.840 --> 00:10:35.160
So I'm gonna pop over to the documentation quickly,


00:10:35.160 --> 00:10:37.920
but what it is, it's a query string filters


00:10:37.920 --> 00:10:42.020
for API endpoints, and so you can show them in Swagger


00:10:42.020 --> 00:10:43.920
and use them in stuff for cool things.


00:10:43.920 --> 00:10:48.720
So I'll pop over to the documentation.


00:10:48.720 --> 00:10:51.940
So it says query string filters


00:10:51.940 --> 00:10:55.340
that supports backends SQLAlchemy and MongoEngine.


00:10:55.340 --> 00:10:56.600
So that's nice.


00:10:56.600 --> 00:10:59.320
But let's say, well, we'll get to what the filters


00:10:59.320 --> 00:11:01.700
look like later, but in the Swagger interface,


00:11:01.700 --> 00:11:02.540
this is pretty neat.


00:11:02.540 --> 00:11:05.260
So let's say you're grabbing the users


00:11:05.260 --> 00:11:07.620
and you wanna filter them by like the name,


00:11:07.620 --> 00:11:12.080
you can do a query in the name or the age less than


00:11:12.080 --> 00:11:14.540
or age greater than or equal.


00:11:14.540 --> 00:11:15.780
These are pretty nice.


00:11:15.780 --> 00:11:19.740
There's a, so it says the philosophy of FastAPI filters


00:11:19.740 --> 00:11:21.620
to be very declarative.


00:11:21.620 --> 00:11:24.100
you define fields that you want to be able to filter on


00:11:24.100 --> 00:11:26.140
as well as the type of operator


00:11:26.140 --> 00:11:29.340
and then tie your filters to a specific model.


00:11:29.340 --> 00:11:30.660
It's pretty easy to set up.


00:11:30.660 --> 00:11:33.700
The syntax is pretty, well, we'll let you look at it,


00:11:33.700 --> 00:11:36.700
but it's not that bad to set up the filters.


00:11:36.700 --> 00:11:38.980
- Yeah, a lot of pedantic models,


00:11:38.980 --> 00:11:40.900
as you might expect it being FastAPI.


00:11:40.900 --> 00:11:43.180
- Yeah, so you plug in these filters,


00:11:43.180 --> 00:11:45.020
but then you get things like,


00:11:45.020 --> 00:11:47.420
the built-in ones are like not equal,


00:11:47.420 --> 00:11:49.300
greater than, greater than equal,


00:11:49.300 --> 00:11:51.620
in those sorts of things.


00:11:51.620 --> 00:11:54.960
But you could do some pretty complex query strings then,


00:11:54.960 --> 00:11:57.640
like, oh, there's some good examples down here.


00:11:57.640 --> 00:12:01.280
So like the users, but order by descending name


00:12:01.280 --> 00:12:04.600
or order by ascending ID,


00:12:04.600 --> 00:12:06.280
there's like plus and minus for ascending


00:12:06.280 --> 00:12:07.560
and you can have order by,


00:12:07.560 --> 00:12:11.480
and you can filter by like the name, custom orders.


00:12:11.480 --> 00:12:16.480
And actually putting some filters right in your API string


00:12:16.480 --> 00:12:18.120
is kind of an interesting idea.


00:12:18.120 --> 00:12:19.720
I don't know if it's a good idea or a bad idea,


00:12:19.720 --> 00:12:21.120
but it's interesting.


00:12:21.120 --> 00:12:24.960
- Yeah, this is a real interesting philosophy


00:12:24.960 --> 00:12:29.960
of how do I access the data in my database as an API?


00:12:29.960 --> 00:12:35.220
And I would say there's sort of two really common ways,


00:12:35.220 --> 00:12:38.280
and then there's a lot of abuse of what APIs look like


00:12:38.280 --> 00:12:39.280
and what you should do, you know,


00:12:39.280 --> 00:12:42.000
just remote procedure calls and all sorts of randomness.


00:12:42.000 --> 00:12:45.320
But the philosophy is I've got data in a database


00:12:45.320 --> 00:12:47.240
and I want to expose it over an API.


00:12:47.240 --> 00:12:50.860
do I go and write a bunch of different functions


00:12:50.860 --> 00:12:54.420
in FastAPI in this example, where I decide,


00:12:54.420 --> 00:12:58.060
here's a way where you can find the recent users


00:12:58.060 --> 00:13:01.340
and you can then possibly take some kind of parameter


00:13:01.340 --> 00:13:04.480
about a sort, or maybe how recent of the users


00:13:04.480 --> 00:13:06.760
do you wanna be, but you're writing the code


00:13:06.760 --> 00:13:08.900
that decides here's the database query


00:13:08.900 --> 00:13:12.180
and it's generally focused on recent users, right?


00:13:12.180 --> 00:13:14.260
That's one way to do API.


00:13:14.260 --> 00:13:16.600
The other is I kinda wanna take my database


00:13:16.600 --> 00:13:20.760
and just make it queryable over the internet, right?


00:13:20.760 --> 00:13:22.440
And this is with the right restrictions.


00:13:22.440 --> 00:13:24.560
It's not necessarily a security vulnerability,


00:13:24.560 --> 00:13:26.720
but it's just pushing all of the thinking


00:13:26.720 --> 00:13:29.360
about what the API is to the client side, right?


00:13:29.360 --> 00:13:31.280
So if I'm doing Vue.js, it's like,


00:13:31.280 --> 00:13:33.600
well, we'll wrap this onto our database


00:13:33.600 --> 00:13:35.840
and you ask it any question you can imagine


00:13:35.840 --> 00:13:39.040
as if you had a direct query line to the database, right?


00:13:39.040 --> 00:13:42.520
So that's why you would do maybe the age greater than,


00:13:42.520 --> 00:13:45.000
or you could do some of those filters where you say,


00:13:45.000 --> 00:13:47.120
give me all the users where the created date


00:13:47.120 --> 00:13:50.040
is less than such and such, or greater than such,


00:13:50.040 --> 00:13:52.000
that would basically be like the new users, right?


00:13:52.000 --> 00:13:55.000
But it's up to the client to kind of know the data schema


00:13:55.000 --> 00:13:55.880
and talk to it.


00:13:55.880 --> 00:13:57.800
And this is that latter style.


00:13:57.800 --> 00:13:59.440
If you like that, awesome.


00:13:59.440 --> 00:14:02.640
You can expose a relational database over SQLAlchemy


00:14:02.640 --> 00:14:06.480
or MongoDB through Mongo Engine, and it looks pretty cool.


00:14:06.480 --> 00:14:08.040
- My thoughts on where I probably,


00:14:08.040 --> 00:14:09.680
I mean, I'm not using this in production,


00:14:09.680 --> 00:14:11.840
but my thoughts on where I might use this,


00:14:11.840 --> 00:14:15.960
even disregarding like one of the Brandon's concerns,


00:14:15.960 --> 00:14:17.680
Brandon Brainer says,


00:14:17.680 --> 00:14:20.400
exposing my API field names makes me nervous.


00:14:20.400 --> 00:14:23.840
But there's a part of your, oops,


00:14:23.840 --> 00:14:27.020
part of your development where you're not quite sure


00:14:27.020 --> 00:14:28.840
what queries you want.


00:14:28.840 --> 00:14:31.920
So custom writing them, maybe you're not ready to do that


00:14:31.920 --> 00:14:34.360
or it'll be a lot of back and forth.


00:14:34.360 --> 00:14:37.840
So a great, I think a great place to be for this would be


00:14:37.840 --> 00:14:40.440
when you're working with, you've got your front end


00:14:40.440 --> 00:14:42.540
and your backend code, your API code,


00:14:42.540 --> 00:14:44.380
and you're trying to figure out


00:14:44.380 --> 00:14:46.380
what sort of searches you want,


00:14:46.380 --> 00:14:48.160
and you can use something like this


00:14:48.160 --> 00:14:52.660
to have it right be in the actual API query.


00:14:52.660 --> 00:14:56.460
And then once you figure out all the stuff you need,


00:14:56.460 --> 00:14:57.860
then you could go back if you want to


00:14:57.860 --> 00:15:00.680
and hard code different API endpoints


00:15:00.680 --> 00:15:03.300
with similar stuff, maybe, I don't know.


00:15:03.300 --> 00:15:05.780
- Yeah, yeah, and not everything's built the same, right?


00:15:05.780 --> 00:15:08.500
Kim out there points out that many of the APIs


00:15:08.500 --> 00:15:11.660
that he uses or builds are for in-house use only.


00:15:11.660 --> 00:15:12.660
- Yeah. - Right?


00:15:12.660 --> 00:15:14.980
And so it's just like, instead of coming up


00:15:14.980 --> 00:15:16.840
with very, very focused API endpoints,


00:15:16.840 --> 00:15:18.400
it's like, well, kind of just leave it open


00:15:18.400 --> 00:15:21.100
and people can use this service to access the data


00:15:21.100 --> 00:15:24.840
in a somewhat safe way, like a restricted way.


00:15:24.840 --> 00:15:25.900
- Yeah. - So it's,


00:15:25.900 --> 00:15:26.740
what are you building?


00:15:26.740 --> 00:15:28.580
Like, are you putting it just on the open internet


00:15:28.580 --> 00:15:31.060
or are you putting it, you know, inside?


00:15:31.060 --> 00:15:32.020
- That's very true.


00:15:32.020 --> 00:15:34.460
Yeah, like I've got a bunch of projects I'm working on


00:15:34.460 --> 00:15:37.180
that are internal and like, who cares


00:15:37.180 --> 00:15:40.180
if somebody knows what my data names are and stuff.


00:15:40.180 --> 00:15:41.660
- Right, well, and what is in it?


00:15:41.660 --> 00:15:44.520
Are you storing social security numbers and addresses,


00:15:44.520 --> 00:15:48.940
or are you storing voltage levels for RF devices?


00:15:48.940 --> 00:15:49.780
- Exactly.


00:15:49.780 --> 00:15:52.400
- Oh no, the voltage levels have leaked, oh no.


00:15:52.400 --> 00:15:55.160
Right, I mean, that flexibility might be awesome.


00:15:55.160 --> 00:15:58.740
- Yeah, I mean, the end, it's secretive.


00:15:58.740 --> 00:16:00.300
We don't want it to get out in the public,


00:16:00.300 --> 00:16:03.720
but it's not something that internal users


00:16:03.720 --> 00:16:05.440
are gonna do anything with, so yeah.


00:16:05.440 --> 00:16:06.720
- Yeah, yeah, exactly.


00:16:06.720 --> 00:16:10.380
- Cool, well yeah, that's really a nice one.


00:16:10.380 --> 00:16:13.120
So Brian, sponsor this week?


00:16:13.120 --> 00:16:15.680
- Yeah, Microsoft for Startups Founders Hub.


00:16:15.680 --> 00:16:19.280
But if you remember last week, we did an ad


00:16:19.280 --> 00:16:24.280
where we asked an AI to come up with the ad text for us.


00:16:24.280 --> 00:16:27.760
- In like an official, sort of official sounding way.


00:16:27.760 --> 00:16:32.400
- Yeah, so this week, you pushed it through the filter


00:16:32.400 --> 00:16:37.400
said to try to come up with the wording in a hipster voice, right?


00:16:37.400 --> 00:16:39.400
So here we go.


00:16:39.400 --> 00:16:40.400
Tell us about it.


00:16:40.400 --> 00:16:41.400
With a hipster style, I'll try.


00:16:41.400 --> 00:16:49.400
Yo Python Bytes fam, this segment is brought to you by the sickest program out there for startup founders, Microsoft for Startup Founders Hub.


00:16:49.400 --> 00:16:56.400
If you're a boss at running a startup, you're going to want to listen up because this is the deal of a lifetime.


00:16:56.400 --> 00:17:00.560
Microsoft for Startup Founders Hub is your ticket to scaling efficiently and


00:17:00.560 --> 00:17:05.360
preserving your runway, all while keeping your cool factor intact.


00:17:05.360 --> 00:17:09.720
With over six figures worth of benefits, the program is serious next level.


00:17:09.720 --> 00:17:12.680
You'll get 150K in Azure credits,


00:17:12.680 --> 00:17:15.380
the richest cloud credit offering on the market,


00:17:15.380 --> 00:17:21.420
access to the OpenAI APIs and the new Azure OpenAI service,


00:17:21.420 --> 00:17:26.020
where you can infuse some serious generative AI into your apps,


00:17:26.020 --> 00:17:29.820
and a one-on-one technical advisor from the Microsoft squad


00:17:29.820 --> 00:17:33.220
who will help you with your technical stack and architectural plans.


00:17:33.220 --> 00:17:35.520
This program is open to all,


00:17:35.520 --> 00:17:39.020
whether you're just getting started or already killing it.


00:17:39.020 --> 00:17:41.620
And the best part, there's no funding requirement.


00:17:41.620 --> 00:17:45.820
All it takes is five minutes to apply and you'll be reaping the benefits in no time.


00:17:45.820 --> 00:17:49.420
Check it out and sign up for Microsoft for Startup Founders Hub


00:17:49.420 --> 00:17:53.520
at pythonbytes.fm/foundershub2022.


00:17:53.520 --> 00:17:55.120
Peace out and keep listening.


00:17:55.120 --> 00:17:58.720
It's insane the power of these AIs these days.


00:17:58.720 --> 00:18:03.600
And now if you want to get access to OpenAI and Azure and GitHub and all those things,


00:18:03.600 --> 00:18:05.960
well, a lot of people seem to be liking that program.


00:18:05.960 --> 00:18:07.440
So it's cool they're supporting us.


00:18:07.440 --> 00:18:10.400
>> Yeah. Also cool that they're letting us play with the ad.


00:18:10.400 --> 00:18:12.280
>> Yes, with their own tools indeed.


00:18:12.280 --> 00:18:14.240
Okay. What I got next Brian,


00:18:14.240 --> 00:18:18.800
is stuff to take your code to the next level, brah.


00:18:18.800 --> 00:18:21.080
But this sounds pretty interesting.


00:18:21.080 --> 00:18:24.200
Twelve Python decorators to take your code to the next level.


00:18:24.200 --> 00:18:25.840
- Nice. - Decorators are awesome.


00:18:25.840 --> 00:18:29.720
And they're kind of like a little bit of magic Python dust


00:18:29.720 --> 00:18:32.500
you can sprinkle onto a method and make things happen.


00:18:32.500 --> 00:18:35.160
Now, about half of these are homegrown.


00:18:35.160 --> 00:18:36.600
Half of those I'd recommend.


00:18:36.600 --> 00:18:38.440
And then a bunch of them are also,


00:18:38.440 --> 00:18:40.000
the other half is maybe the built-in ones


00:18:40.000 --> 00:18:41.280
that come from various places.


00:18:41.280 --> 00:18:43.000
So I'll just go through the list of 12


00:18:43.000 --> 00:18:44.160
and you tell me what you think.


00:18:44.160 --> 00:18:46.720
The first one that they started off with in this article


00:18:46.720 --> 00:18:47.560
doesn't thrill me.


00:18:47.560 --> 00:18:49.040
It says, "Hey, I can wrap this function


00:18:49.040 --> 00:18:50.000
"with this thing called logger


00:18:50.000 --> 00:18:51.600
"and it'll tell me when it starts and stops."


00:18:51.600 --> 00:18:54.080
Like, yeah, no thanks, that doesn't seem interesting.


00:18:54.080 --> 00:18:58.640
But the next one, if, especially if you're already focused on decorators and


00:18:58.640 --> 00:19:01.680
psyched about that is the funk tools wraps.


00:19:01.680 --> 00:19:02.160
Yeah.


00:19:02.160 --> 00:19:02.480
Right.


00:19:02.480 --> 00:19:03.480
Because if you're going to


00:19:03.480 --> 00:19:04.960
definitely you got to use it.


00:19:04.960 --> 00:19:05.360
Yeah.


00:19:05.360 --> 00:19:06.440
It's basically required.


00:19:06.440 --> 00:19:10.320
If you create a decorator and they show you how to do that on the screen here and


00:19:10.320 --> 00:19:13.800
you try to interact with the function that is decorated, well, you're going to


00:19:13.800 --> 00:19:14.920
get funky results.


00:19:14.920 --> 00:19:16.040
Like what is the functions name?


00:19:16.040 --> 00:19:18.360
Well, it's the name of the decorator, not the actual thing.


00:19:18.360 --> 00:19:19.280
What if it's arguments?


00:19:19.280 --> 00:19:21.360
It's star star star KWR.


00:19:21.360 --> 00:19:22.520
What is the documentation?


00:19:22.680 --> 00:19:25.800
whatever the name, the documentation of the decorators and all that.


00:19:25.800 --> 00:19:29.400
So with wrapper or with wraps, you can wrap it around and you're actually


00:19:29.400 --> 00:19:32.180
kind of pass through that information, which is pretty cool.


00:19:32.180 --> 00:19:36.400
So if you're going to do decorators wrapped as kind of a meta decorator here.


00:19:36.400 --> 00:19:41.160
Another one I think is really cool and not for all use cases, not really great


00:19:41.160 --> 00:19:45.220
on the web because of the scale out across process story that often happens


00:19:45.220 --> 00:19:48.360
in deployment, but if you're doing data science-y things or a bunch of


00:19:48.880 --> 00:19:52.340
repetitive processing, the LRU cache is like magic,


00:19:52.340 --> 00:19:54.780
unless you are really memory constrained or something.


00:19:54.780 --> 00:19:56.740
- Yeah, love LRU cache.


00:19:56.740 --> 00:19:58.620
- Yeah, you just put it on a function,


00:19:58.620 --> 00:20:02.040
and you say @LRU cache, and you can even give it a max size,


00:20:02.040 --> 00:20:06.260
and it just says, as long as given a fixed input,


00:20:06.260 --> 00:20:08.140
you'll get the same output every time,


00:20:08.140 --> 00:20:10.100
then you can put the LRU cache on it,


00:20:10.100 --> 00:20:11.760
and the second time you call it the same arguments,


00:20:11.760 --> 00:20:13.460
it just goes, you know what, I know the answer,


00:20:13.460 --> 00:20:16.120
here you go, and it's an incredibly easy way


00:20:16.120 --> 00:20:18.180
to speed up stuff that takes like numbers


00:20:18.180 --> 00:20:20.480
like well-known things that are not objects,


00:20:20.480 --> 00:20:22.980
but it can be tested like, yeah, these are the same values.


00:20:22.980 --> 00:20:24.720
- And if you don't care about the max size,


00:20:24.720 --> 00:20:26.440
you can just use the decorator cache.


00:20:26.440 --> 00:20:28.880
Now you don't need to have the LRU part.


00:20:28.880 --> 00:20:30.440
- No, nice, great addition.


00:20:30.440 --> 00:20:32.480
Next up we have @repeat.


00:20:32.480 --> 00:20:35.120
Suppose for some reason I want to call a function


00:20:35.120 --> 00:20:38.480
multiple times, like if I want to try to say,


00:20:38.480 --> 00:20:41.520
what if I call this a bunch of times just for say,


00:20:41.520 --> 00:20:44.280
load testing, or I want to just,


00:20:44.280 --> 00:20:45.320
kind of in during development,


00:20:45.320 --> 00:20:47.880
I can't see this being used in any realistic way,


00:20:47.880 --> 00:20:49.760
but you can just say this is one that they built.


00:20:49.760 --> 00:20:52.240
You just wrap it and say repeat this n number of times.


00:20:52.240 --> 00:20:53.560
That might be useful.


00:20:53.560 --> 00:20:54.600
>> Yeah.


00:20:54.600 --> 00:20:59.640
>> Timeit. So Timeit is one that you could create that I think is pretty nice.


00:20:59.640 --> 00:21:01.880
Like this is one of the homegrown ones that I do think is good.


00:21:01.880 --> 00:21:04.520
Is a lot of times you want to know how long a function takes.


00:21:04.520 --> 00:21:07.320
One thing you could do is you could grab the time at the start.


00:21:07.320 --> 00:21:09.680
Here they're using perf counters which is pretty excellent.


00:21:09.680 --> 00:21:12.640
Then at the end, grab the time, print it out.


00:21:12.640 --> 00:21:14.360
But then you're messing with your code, right?


00:21:14.360 --> 00:21:16.040
It'd be a lot easier to just go, "You know what?


00:21:16.040 --> 00:21:19.200
I just want to wrap a decorator over some function


00:21:19.200 --> 00:21:20.400
and have it print out stuff.


00:21:20.400 --> 00:21:22.600
Just usually during development or debugging


00:21:22.600 --> 00:21:23.800
or something, not in production.


00:21:23.800 --> 00:21:25.800
But you're like, well, how long did this take?


00:21:25.800 --> 00:21:28.800
So just yesterday I was fiddling with a function.


00:21:28.800 --> 00:21:31.340
I'm like, if I change it this way, will it get any faster?


00:21:31.340 --> 00:21:32.480
It's a little more complicated,


00:21:32.480 --> 00:21:34.300
but maybe there's a big benefit, right?


00:21:34.300 --> 00:21:36.420
And I put this on, something like this on there


00:21:36.420 --> 00:21:38.040
and like, yeah, it didn't make any difference.


00:21:38.040 --> 00:21:40.480
So we'll keep them the simple bit of code in place.


00:21:40.480 --> 00:21:42.280
- Yeah, and if it's like super fast,


00:21:42.280 --> 00:21:44.960
- You can also do things like loop it,


00:21:44.960 --> 00:21:48.200
like add a loop thing there so that it runs like 100 times


00:21:48.200 --> 00:21:50.440
and then do the division or something.


00:21:50.440 --> 00:21:51.440
- That's a really good point.


00:21:51.440 --> 00:21:54.840
And these are composable, right?


00:21:54.840 --> 00:21:55.940
Decorators are composable.


00:21:55.940 --> 00:21:59.320
So you could say @timeit @repeat1000.


00:21:59.320 --> 00:22:00.400
- Oh, yeah, yeah.


00:22:00.400 --> 00:22:01.240
- Right?


00:22:01.240 --> 00:22:04.320
I mean, all of a sudden, repeat's starting to sound useful.


00:22:04.320 --> 00:22:07.720
They have a retry one for retrying a bunch of times.


00:22:07.720 --> 00:22:08.920
No.


00:22:08.920 --> 00:22:09.760
Tenacity.


00:22:09.760 --> 00:22:11.720
Don't do that.


00:22:11.720 --> 00:22:14.840
There's some that are really, really fantastic with many options.


00:22:14.840 --> 00:22:18.120
Don't bother rewriting some of those because you've got things like tenacity


00:22:18.120 --> 00:22:23.000
that has exponential back off, limiting the number of retries, customizing


00:22:23.000 --> 00:22:26.000
different behaviors and plans based on exceptions.


00:22:26.000 --> 00:22:27.640
So grab something like tenacity.


00:22:27.640 --> 00:22:30.280
But the idea of understanding the retries is kind of cool.


00:22:30.280 --> 00:22:30.760
Yeah.


00:22:30.760 --> 00:22:32.880
Thanks for reminding us about tenacity.


00:22:32.880 --> 00:22:33.400
I forgot about that.


00:22:33.400 --> 00:22:33.840
Yeah.


00:22:33.840 --> 00:22:34.440
That's a good one.


00:22:34.440 --> 00:22:34.720
Right.


00:22:34.720 --> 00:22:35.960
Count call.


00:22:35.960 --> 00:22:39.800
If you're doing debugging or performance stuff, you're just like, why does it


00:22:39.800 --> 00:22:41.900
seem like this is getting called like five times.


00:22:41.900 --> 00:22:42.900
It should be called once.


00:22:42.900 --> 00:22:43.980
This is weird.


00:22:43.980 --> 00:22:47.380
And so you could actually, they introduced this count call


00:22:47.380 --> 00:22:49.420
decorator that just every time a function is called,


00:22:49.420 --> 00:22:51.700
it's now been called this many times, which sounds silly,


00:22:51.700 --> 00:22:54.460
but are you trying to track down like an N plus one


00:22:54.460 --> 00:22:56.980
database problem or other weird things like that?


00:22:56.980 --> 00:22:58.980
If you don't really know why something bizarre


00:22:58.980 --> 00:23:01.860
is happening a ton of times, this could be kind of helpful.


00:23:01.860 --> 00:23:03.380
- Yeah.


00:23:03.380 --> 00:23:04.360
- Rate limited.


00:23:04.360 --> 00:23:05.660
This one sounds cool as well.


00:23:05.660 --> 00:23:07.940
Like I only want you to call this function


00:23:07.940 --> 00:23:09.560
so often per second.


00:23:09.560 --> 00:23:12.280
and you can decide what to do.


00:23:12.280 --> 00:23:14.200
In this case, it says we're gonna time.sleep.


00:23:14.200 --> 00:23:15.760
I'm not so sure that makes a lot of sense,


00:23:15.760 --> 00:23:16.920
but it was asynchronous.


00:23:16.920 --> 00:23:18.920
You could await asyncIO.sleep


00:23:18.920 --> 00:23:20.780
and it would cause no overhead on the system.


00:23:20.780 --> 00:23:21.920
It wouldn't clog anything up.


00:23:21.920 --> 00:23:23.760
It would just make the caller wait.


00:23:23.760 --> 00:23:26.460
So there's some interesting variations there as well.


00:23:26.460 --> 00:23:28.440
Keep scrolling.


00:23:28.440 --> 00:23:30.840
And then some more built-in ones, data classes.


00:23:30.840 --> 00:23:34.080
If you wanna have a data class, just @dataclass, the class.


00:23:34.080 --> 00:23:35.640
Brian, do you use data classes much?


00:23:35.640 --> 00:23:36.760
- Yes, quite a bit.


00:23:36.760 --> 00:23:37.840
- Nice.


00:23:37.840 --> 00:23:39.760
I like my classes to be VC funded,


00:23:39.760 --> 00:23:41.980
so I use Pydantic more often.


00:23:41.980 --> 00:23:44.000
(laughing)


00:23:44.000 --> 00:23:45.720
See last week, no, congratulations


00:23:45.720 --> 00:23:47.720
to the Samuel team there.


00:23:47.720 --> 00:23:50.760
But I honestly, I typically use Pydantic a little bit more


00:23:50.760 --> 00:23:53.880
because I'm often gonna use it with FastAPI or Beanie


00:23:53.880 --> 00:23:55.120
or something over the wire,


00:23:55.120 --> 00:23:58.800
but I really like the idea of data classes too.


00:23:58.800 --> 00:24:01.760
All right, a couple more, register.


00:24:01.760 --> 00:24:02.840
Let me know if you know about this one.


00:24:02.840 --> 00:24:03.840
I heard about it a little while,


00:24:03.840 --> 00:24:05.920
but I haven't ever had a chance to use it.


00:24:05.920 --> 00:24:10.160
But the AT, at exit module in Python,


00:24:10.160 --> 00:24:13.200
it has a way to say, when my program is shutting down,


00:24:13.200 --> 00:24:16.000
even if the user, like, Control + C is out of it,


00:24:16.000 --> 00:24:18.400
I need to make sure that I delete, say,


00:24:18.400 --> 00:24:21.640
some file I created, or call an API and tell it real quick,


00:24:21.640 --> 00:24:23.080
like, you know what, we're gone.


00:24:23.080 --> 00:24:24.560
Or, I don't know, something like that, right?


00:24:24.560 --> 00:24:26.280
You just need, there's something you gotta do


00:24:26.280 --> 00:24:29.200
on your way out, even if it's a force exit.


00:24:29.200 --> 00:24:30.360
- Yeah. - You can go.


00:24:30.360 --> 00:24:33.000
- I have, as, sorry to interrupt, I have used this.


00:24:33.000 --> 00:24:33.960
- Oh, good. - Yeah.


00:24:33.960 --> 00:24:34.800
- Yeah, when did you use it?


00:24:34.800 --> 00:24:35.880
What do you use it for?


00:24:35.880 --> 00:24:39.060
similar sort of thing. I've got like some, some thing in the background that I,


00:24:39.060 --> 00:24:42.820
I want to make sure that we, there's a little bit of cleanup that's done before


00:24:42.820 --> 00:24:48.420
it goes away. but they, I just wanted to correct this. This says from import,


00:24:48.420 --> 00:24:53.040
from at exit import register and then decorate with register. I think it looks


00:24:53.040 --> 00:24:57.780
better if you just import out of the exit and do the decorator as at exit dot


00:24:57.780 --> 00:24:59.760
register, because it's better documentation.


00:24:59.760 --> 00:25:03.220
I totally agree. I totally agree. There's, there's,


00:25:03.240 --> 00:25:07.240
There's a couple things in this article where the code is a little bit...


00:25:07.240 --> 00:25:09.840
No, it was the other article that I did that was a little bit...


00:25:09.840 --> 00:25:11.040
that I talked about that was a little bit weird.


00:25:11.040 --> 00:25:13.840
But I agree, keeping the namespace tells you, like,


00:25:13.840 --> 00:25:15.840
well, what the heck are you registering for, right?


00:25:15.840 --> 00:25:18.740
I think namespaces are a good idea. I definitely use them.


00:25:18.740 --> 00:25:21.040
But anyway, so you can just put this decorator on a function,


00:25:21.040 --> 00:25:24.640
and when you exit, they show an example of some loop going just while true,


00:25:24.640 --> 00:25:25.640
and they control C out of it.


00:25:25.640 --> 00:25:28.740
It says, "Hey, we're cleaning up here. Now bye."


00:25:28.740 --> 00:25:30.740
Which is... that's a pretty nice way to handle it,


00:25:30.740 --> 00:25:32.960
instead of trying to catch all the use cases


00:25:32.960 --> 00:25:35.400
with exceptions and try finalize and so on.


00:25:35.400 --> 00:25:39.760
All right, property, give your fields behaviors


00:25:39.760 --> 00:25:42.680
and validation, getters, setters, and so on, love it.


00:25:42.680 --> 00:25:45.640
And single dispatch, I believe we've spoken about before


00:25:45.640 --> 00:25:48.880
where you can give, basically you do argument


00:25:48.880 --> 00:25:51.120
over overloads for functions.


00:25:51.120 --> 00:25:52.520
So you can say, here's a function


00:25:52.520 --> 00:25:54.160
and here's the one that takes an integer


00:25:54.160 --> 00:25:55.320
and here's the one that takes a list.


00:25:55.320 --> 00:25:56.640
And these are separate functions


00:25:56.640 --> 00:25:58.020
and separate implementations.


00:25:58.020 --> 00:26:00.620
and you do that with that single dispatch decorator.


00:26:00.620 --> 00:26:03.300
>> I actually always forget about this.


00:26:03.300 --> 00:26:04.620
>> I do too.


00:26:04.620 --> 00:26:08.180
>> I'm glad I forget about it because I think-


00:26:08.180 --> 00:26:09.500
>> I would use it too much.


00:26:09.500 --> 00:26:10.500
>> Maybe.


00:26:10.500 --> 00:26:15.380
>> I used to love function overloading when I was doing C,


00:26:15.380 --> 00:26:17.380
C++, C# type stuff,


00:26:17.380 --> 00:26:18.860
I would really count on it.


00:26:18.860 --> 00:26:21.900
I thought I would miss it in Python and I haven't.


00:26:21.900 --> 00:26:25.940
>> Well, I noticed that some people that convert to Python from C,


00:26:25.940 --> 00:26:28.340
we'll just assume that it has function overloading,


00:26:28.340 --> 00:26:30.340
and it just doesn't work.


00:26:30.340 --> 00:26:32.420
>> That's known as function erasure.


00:26:32.420 --> 00:26:33.220
>> Function erasure.


00:26:33.220 --> 00:26:34.660
>> The last one wins, right?


00:26:34.660 --> 00:26:34.900
>> Yeah.


00:26:34.900 --> 00:26:36.380
>> We talked about that last time.


00:26:36.380 --> 00:26:38.420
No, we talked about that when we talked on


00:26:38.420 --> 00:26:40.740
Talk Python which maybe we'll mention at the end.


00:26:40.740 --> 00:26:42.820
But the last time we talked, yeah.


00:26:42.820 --> 00:26:44.060
>> Yeah.


00:26:44.060 --> 00:26:47.540
>> Anyway, those are the 12 that they put in the article.


00:26:47.540 --> 00:26:49.380
Most of them are really great.


00:26:49.380 --> 00:26:51.740
Some of them point you at things like tenacity,


00:26:51.740 --> 00:26:53.140
which is also really good.


00:26:53.140 --> 00:26:54.220
So that's what I got.


00:26:54.220 --> 00:26:58.540
>> Nice. Well, I would like to talk about testing too a bit.


00:26:58.540 --> 00:27:00.780
Let's talk about PyHamcrest.


00:27:00.780 --> 00:27:08.260
This topic is contributed by TXLs on the socials.


00:27:08.260 --> 00:27:09.860
Thanks, TXLs.


00:27:09.860 --> 00:27:13.180
PyHamcrest, and the thought was,


00:27:13.180 --> 00:27:15.140
Brian talks about testing a lot,


00:27:15.140 --> 00:27:16.860
so why haven't you covered this?


00:27:16.860 --> 00:27:18.740
What PyHamcrest is,


00:27:18.740 --> 00:27:24.180
is a matcher object declarative rule matcher thing


00:27:24.180 --> 00:27:26.980
that helps you with the certs and stuff like that.


00:27:26.980 --> 00:27:27.860
Have you used this?


00:27:27.860 --> 00:27:28.580
I have not.


00:27:28.580 --> 00:27:33.940
My first thought it was like some kind of menu item on a holiday dinner,


00:27:33.940 --> 00:27:34.740
but no.


00:27:34.740 --> 00:27:38.180
I literally only heard about this because you put it in the show notes.


00:27:38.180 --> 00:27:39.220
So this is news to me.


00:27:39.220 --> 00:27:42.260
The idea is instead of like all the assert,


00:27:42.260 --> 00:27:44.980
so you've got a whole bunch of certain things like assert that,


00:27:44.980 --> 00:27:46.820
assert that and equal to,


00:27:46.820 --> 00:27:49.060
and a bunch of ham crust things that you can import.


00:27:49.060 --> 00:27:51.860
So you can do things like, instead of saying,


00:27:51.860 --> 00:27:55.100
assert the biscuit equals my biscuit,


00:27:55.100 --> 00:27:58.660
you can say, assert that the biscuit equal to my biscuit.


00:27:58.660 --> 00:28:01.940
So at first, so I've always thought asserts are,


00:28:01.940 --> 00:28:04.420
like, I get this for unit test,


00:28:04.420 --> 00:28:06.540
but for pytest, what, do we need it?


00:28:06.540 --> 00:28:09.220
Because you could just use assert in pytest.


00:28:09.220 --> 00:28:13.100
However, I'm kind of easing up on that argument


00:28:13.100 --> 00:28:15.620
because I can see a lot of places where just,


00:28:15.620 --> 00:28:20.820
Really, if you can make your assertions more readable in some context, then why not?


00:28:20.820 --> 00:28:22.420
So, sure.


00:28:22.420 --> 00:28:26.980
And I don't know about this one, but if it's got things like go through a list and assert


00:28:26.980 --> 00:28:28.980
everything is equal in the list, right?


00:28:28.980 --> 00:28:29.980
Yeah.


00:28:29.980 --> 00:28:34.860
Or higher order things where it would be kind of kind of complex to implement the test.


00:28:34.860 --> 00:28:36.420
That is the thing you want to assert.


00:28:36.420 --> 00:28:39.380
Like these three fields are equal of these three things, right?


00:28:39.380 --> 00:28:41.140
Then it becomes a little less obvious.


00:28:41.140 --> 00:28:43.620
And if this has a really nice story.


00:28:43.620 --> 00:28:44.620
>> Well, so there's a whole-


00:28:44.620 --> 00:28:45.620
>> Looks like it does.


00:28:45.620 --> 00:28:47.740
>> Yep, there's a whole bunch of matchers within it.


00:28:47.740 --> 00:28:52.940
Like for objects, it's like equal to and has length, it has property.


00:28:52.940 --> 00:28:56.620
Has properties is interesting, so you could like assert on duck typing.


00:28:56.620 --> 00:29:00.700
Hopefully, it has these values or something.


00:29:00.700 --> 00:29:03.380
Numbers close to, greater than, less than.


00:29:03.380 --> 00:29:08.900
Of course, these asserts are fine with this, but the logical stuff, the logical and sequences


00:29:08.900 --> 00:29:11.380
is what I think where I probably might use it.


00:29:11.380 --> 00:29:17.460
like all of or any of or anything or that's neat like all of these things are true


00:29:17.460 --> 00:29:25.060
and you can combine this with or like all of these or all of those or something sequences


00:29:25.060 --> 00:29:34.020
contains contains in any order that's kind of interesting yeah nice has items is in again


00:29:34.020 --> 00:29:36.740
These are things that are testable in Python,


00:29:36.740 --> 00:29:40.340
raw, like just raw test, not too bad.


00:29:40.340 --> 00:29:43.900
But if it's more readable, sure, why not?


00:29:43.900 --> 00:29:47.360
There's some that are shown,


00:29:47.360 --> 00:29:50.240
especially with raising error, like exceptions.


00:29:50.240 --> 00:29:54.100
Where did I get it? Oh, the tutorial has a bunch of cool stuff in it.


00:29:54.100 --> 00:29:57.180
The things like assert that calling


00:29:57.180 --> 00:30:00.620
translate with args curse word raises a language error.


00:30:00.620 --> 00:30:02.660
Well, that's neat.


00:30:02.660 --> 00:30:04.380
>> Very naughty.


00:30:04.380 --> 00:30:07.940
>> Assert that broken function raises exception.


00:30:07.940 --> 00:30:13.260
In pytest, you've got the raises thing with pytest raises,


00:30:13.260 --> 00:30:15.500
but some people have a hard,


00:30:15.500 --> 00:30:20.300
it's not obvious and maybe this looks better.


00:30:20.300 --> 00:30:26.500
This is neat, you can use assertion exceptions with async methods.


00:30:26.500 --> 00:30:28.700
It has a resolved item,


00:30:28.700 --> 00:30:31.300
so you can say assert that await resolved


00:30:31.300 --> 00:30:36.300
future results in future raising value error or something.


00:30:36.300 --> 00:30:37.540
- Yeah, nice, that's cool.


00:30:37.540 --> 00:30:40.460
- So, yeah, so a lot of predefined matchers


00:30:40.460 --> 00:30:43.960
and I guess it has some syntactic shirker things


00:30:43.960 --> 00:30:48.260
like is underscore, so just if it sounds better


00:30:48.260 --> 00:30:50.340
to have an is in there, you can add it.


00:30:50.340 --> 00:30:53.500
So assert that the biscuit is equal to,


00:30:53.500 --> 00:30:56.300
doesn't do anything but it like sounds better,


00:30:56.300 --> 00:30:59.100
so why not, I guess.


00:30:59.100 --> 00:31:00.540
- If you wanted to read that in English,


00:31:00.540 --> 00:31:03.020
like insert a no op verb.


00:31:03.020 --> 00:31:09.300
>> Yeah. But I guess I do want to highlight this because why not?


00:31:09.300 --> 00:31:12.000
I mean, since I'm writing a lot of test code,


00:31:12.000 --> 00:31:14.020
I'm used to all the different ways you can


00:31:14.020 --> 00:31:17.820
check different equivalence of values or comparisons.


00:31:17.820 --> 00:31:19.940
I don't know how much I would use this,


00:31:19.940 --> 00:31:22.380
but I've seen a lot of people


00:31:22.380 --> 00:31:25.300
struggle with how to write an assertion.


00:31:25.300 --> 00:31:28.660
Having some help with the library, why not? This is pretty neat.


00:31:28.660 --> 00:31:30.340
>> Yeah, this totally resonates with me.


00:31:30.340 --> 00:31:30.840
I like it.


00:31:30.840 --> 00:31:35.340
So, well, that's our six items, six, four items.


00:31:35.340 --> 00:31:40.940
Do you have any extras for us this week?


00:31:40.940 --> 00:31:42.740
I do have a few extras.


00:31:42.740 --> 00:31:44.240
Let me throw them in here.


00:31:44.240 --> 00:31:45.940
First of all, it's a few weeks old.


00:31:45.940 --> 00:31:53.740
I didn't remember to put it up here, but Python 3.11.2 is out as well as 3.10.10


00:31:53.740 --> 00:31:56.540
and the alpha 5 of 3.12.


00:31:56.540 --> 00:31:58.540
We're getting kind of close to beta.


00:31:58.540 --> 00:32:02.540
it feels like for 3.12, which will be exciting because then we'll get real visibility into


00:32:02.540 --> 00:32:06.300
what's probably going to be happening for the next version of Python. That's cool.


00:32:06.300 --> 00:32:11.740
Yeah. I'm testing for 3.12 already with our CI builds.


00:32:11.740 --> 00:32:21.260
Nice. For example, with 3.11.2, there were 192 commits since 3.11.1, 194 rather. So that's pretty


00:32:21.260 --> 00:32:26.380
non-trivial right there. And they link over to somewhere that looks, I don't know, just


00:32:26.380 --> 00:32:29.580
What am I supposed to learn from that? Here's the changes from 3.11 to 3.12.


00:32:29.580 --> 00:32:31.780
So I always go to downloads, full list of downloads.


00:32:31.780 --> 00:32:34.680
Dun-na-na-na-na-na-na. Scroll down to the particular version.


00:32:34.680 --> 00:32:36.980
Here, and go to release notes. And there you go.


00:32:36.980 --> 00:32:38.480
That's probably what they should be linking to.


00:32:38.480 --> 00:32:41.580
And here's all the things. There's some that are in here that are


00:32:41.580 --> 00:32:44.580
things that you might actually care about. Like for example,


00:32:44.580 --> 00:32:49.180
fixed race condition while iterating over thread states in thread.local.


00:32:49.180 --> 00:32:50.880
You might not want that in your code.


00:32:50.880 --> 00:32:52.880
And various other things.


00:32:52.880 --> 00:32:55.880
Yeah, a bunch of-- look at all these changes here. This is a lot.


00:32:55.880 --> 00:32:58.280
>> Yeah, nice. Go team.


00:32:58.280 --> 00:33:00.120
>> Yeah, go team. You might think,


00:33:00.120 --> 00:33:03.160
"Oh, it's just a dot plus one,


00:33:03.160 --> 00:33:06.320
plus 0.0.1 sort of thing to it."


00:33:06.320 --> 00:33:10.260
But now it's got some interesting changes as well as,


00:33:10.260 --> 00:33:12.240
I haven't looked at what's happening in the others,


00:33:12.240 --> 00:33:13.640
but maybe some of those are important


00:33:13.640 --> 00:33:15.480
enough to pull backwards those fixes.


00:33:15.480 --> 00:33:18.940
Also, more recent as in eight days ago,


00:33:18.940 --> 00:33:23.880
we've got Django 4.2 Beta, Beta 1.


00:33:23.880 --> 00:33:27.180
- You know, typically the philosophy is,


00:33:27.180 --> 00:33:29.440
once it hits beta, the API should be stable,


00:33:29.440 --> 00:33:30.480
the features should be stable,


00:33:30.480 --> 00:33:31.920
it's just about fixing bugs.


00:33:31.920 --> 00:33:32.960
Doesn't always work out that way,


00:33:32.960 --> 00:33:34.000
but that's generally the idea.


00:33:34.000 --> 00:33:38.120
So basically, here's your concrete look at Django 4.2.


00:33:38.120 --> 00:33:39.320
- Yeah. - Right?


00:33:39.320 --> 00:33:41.760
- And 4.2 looks exciting, so.


00:33:41.760 --> 00:33:42.640
- Yeah, absolutely.


00:33:42.640 --> 00:33:45.100
So you can, you know, they've got some release nodes


00:33:45.100 --> 00:33:47.000
and various things about what's going on.


00:33:47.000 --> 00:33:47.880
You can go check that out.


00:33:47.880 --> 00:33:52.680
So they got Psycho PG3, so Postgres support.


00:33:52.680 --> 00:33:57.240
It now supports post-PsychoPG version 3.1.8 or higher.


00:33:57.240 --> 00:33:59.720
You can update your code to use that as a backend.


00:33:59.720 --> 00:34:01.640
- I'm still using two, so I better,


00:34:01.640 --> 00:34:03.240
I didn't know there was a three.


00:34:03.240 --> 00:34:05.200
- No, careful, Brian.


00:34:05.200 --> 00:34:07.160
PsychoPG 2 is likely to be deprecated


00:34:07.160 --> 00:34:08.880
and removed at some point in the future.


00:34:08.880 --> 00:34:09.720
- Okay.


00:34:09.720 --> 00:34:10.560
- Yeah.


00:34:10.560 --> 00:34:12.960
- Comments on columns and tables.


00:34:12.960 --> 00:34:15.240
So that's kind of neat in the database model.


00:34:15.240 --> 00:34:17.480
So the ORM gets some love there.


00:34:17.480 --> 00:34:18.920
- No comment on that.


00:34:18.920 --> 00:34:19.760
- Yeah, no comment.


00:34:19.760 --> 00:34:20.600
Very good.


00:34:20.600 --> 00:34:22.900
some stuff about the so-called breach attack.


00:34:22.900 --> 00:34:24.980
I have no idea what it seems to have to do with gzip.


00:34:24.980 --> 00:34:26.120
So check that out.


00:34:26.120 --> 00:34:28.940
Another one that's interesting is in-memory file storage


00:34:28.940 --> 00:34:30.620
and custom file stores.


00:34:30.620 --> 00:34:33.260
This is for making testing potentially faster.


00:34:33.260 --> 00:34:36.380
So if you're gonna write some files as part of a behavior,


00:34:36.380 --> 00:34:37.700
you can say, just write them to in-memory.


00:34:37.700 --> 00:34:40.260
Don't have to clean them up and they write really fast.


00:34:40.260 --> 00:34:42.660
- Yeah, it phenomenally speeds up testing.


00:34:42.660 --> 00:34:43.500
It's good.


00:34:43.500 --> 00:34:44.320
- Yeah, I bet.


00:34:44.320 --> 00:34:45.620
All right, so there's that.


00:34:45.620 --> 00:34:48.500
And then also I wanna give a shout out,


00:34:48.500 --> 00:34:49.340
I'll put it like this.


00:34:49.340 --> 00:34:54.340
a shout out to an app real quick that people might find useful by way of a journey.


00:34:54.340 --> 00:35:00.740
So rewriting the Talk Python apps in Flutter, which all the APIs are Python, but we're having


00:35:00.740 --> 00:35:05.260
apps on macOS, Windows, Linux, iOS, and Android.


00:35:05.260 --> 00:35:08.460
That's really hard to do with Python, so Flutter is what we're using, and it's going along


00:35:08.460 --> 00:35:09.460
really well.


00:35:09.460 --> 00:35:12.820
Here's a little screenshot for you, Brian, to show you what we've got so far.


00:35:12.820 --> 00:35:13.820
Isn't that cool?


00:35:13.820 --> 00:35:14.820
>> Yeah.


00:35:14.820 --> 00:35:17.220
>> Yeah, and another, like, here's the little app and stuff.


00:35:17.220 --> 00:35:18.700
So I think I'm really happy with how it's coming together.


00:35:18.700 --> 00:35:23.940
I think it's going to be a better mobile app experience for an existing desktop experience


00:35:23.940 --> 00:35:26.100
for like offline mode with the talk Python courses.


00:35:26.100 --> 00:35:27.100
Oh, cool.


00:35:27.100 --> 00:35:28.740
Yeah, so that that'll be really neat.


00:35:28.740 --> 00:35:31.660
Thing I want to tell you about is something I just applied to it.


00:35:31.660 --> 00:35:34.120
This thing called image optimum.


00:35:34.120 --> 00:35:37.100
And what you can do is you can just take the top level of your project.


00:35:37.100 --> 00:35:39.900
So I did this for say the Talk Python Training website.


00:35:39.900 --> 00:35:43.880
I did this for the mobile app, just take the very top level project folder and just throw


00:35:43.880 --> 00:35:44.880
it on this app.


00:35:44.880 --> 00:35:47.840
go find all the images, all the vector graphics


00:35:47.840 --> 00:35:50.480
and everything and minimize the heck out of them.


00:35:50.480 --> 00:35:53.080
So for example, when I did that on the mobile app,


00:35:53.080 --> 00:35:55.280
it went from 10 megs of image assets


00:35:55.280 --> 00:35:57.560
to eight megs of image assets, lossless.


00:35:57.560 --> 00:36:00.320
Like no one will know the difference other than me


00:36:00.320 --> 00:36:03.360
that I've done it and it dropped 20% of the file size,


00:36:03.360 --> 00:36:04.800
which is not the end of the world,


00:36:04.800 --> 00:36:07.440
but given how much work it is, it's not too bad.


00:36:07.440 --> 00:36:09.960
- Well, the lossless part is the important bit,


00:36:09.960 --> 00:36:11.680
so that's pretty exciting.


00:36:11.680 --> 00:36:12.500
- Yeah, exactly.


00:36:12.500 --> 00:36:17.340
it'll do things like if it's a PNG and it sees you're using a smaller color


00:36:17.340 --> 00:36:18.820
palette than what it's actually holding.


00:36:18.820 --> 00:36:21.780
It's like, oh, we can rewrite that in a way that doesn't make it actually look


00:36:21.780 --> 00:36:23.300
different, but takes up less storage.


00:36:23.300 --> 00:36:31.940
Basically it's a wrapper over things like Moze JPEG, PNG Crush, Google Zappfile.


00:36:31.940 --> 00:36:34.900
I don't know how to say these things, but there are a bunch of image, like


00:36:34.900 --> 00:36:37.420
lossless image manipulation tools.


00:36:37.420 --> 00:36:40.020
And it just applies those to all of them, like in a super easy way.


00:36:40.020 --> 00:36:41.380
And this thing's open source itself.


00:36:41.380 --> 00:36:41.820
Cool.


00:36:41.900 --> 00:36:45.200
So yeah, anyway, if people have websites out there,


00:36:45.200 --> 00:36:47.300
you know, they could consider just like,


00:36:47.300 --> 00:36:48.900
take your website, throw it on here,


00:36:48.900 --> 00:36:50.000
and it'll tell you, you know,


00:36:50.000 --> 00:36:52.100
make sure it's all checked in and get, do this,


00:36:52.100 --> 00:36:54.100
see what it says, it gives you a report at the bottom,


00:36:54.100 --> 00:36:57.600
like you saved either 10k or you saved 5 megs,


00:36:57.600 --> 00:36:59.900
depending, you can decide whether to keep the changes.


00:36:59.900 --> 00:37:00.900
Yeah, cool.


00:37:00.900 --> 00:37:02.900
Yep, alright, that's all my extras.


00:37:02.900 --> 00:37:03.600
How about you?


00:37:03.600 --> 00:37:04.600
I just have a couple.


00:37:04.600 --> 00:37:08.100
Yesterday I talked with you on Python Byte,


00:37:08.100 --> 00:37:09.800
now on Talk Python,


00:37:09.800 --> 00:37:13.480
about pytest tips and tricks. And I just wanted to point out that


00:37:13.480 --> 00:37:16.760
the post is available for people to read if they want.


00:37:16.760 --> 00:37:20.440
Go look through it. And if you have comments, please, or questions,


00:37:20.440 --> 00:37:23.640
let me know, of course. Also in March,


00:37:23.640 --> 00:37:27.800
I think I've brought this up before, but I'll be speaking at PyCascades.


00:37:27.800 --> 00:37:31.080
There's a picture of me without hair.


00:37:31.080 --> 00:37:34.760
And I did stick up a


00:37:34.760 --> 00:37:37.960
blog post on pythontest.com,


00:37:37.960 --> 00:37:43.200
just a placeholder so that I can link the slides and code afterwards.


00:37:43.200 --> 00:37:44.120
So that's it.


00:37:44.120 --> 00:37:44.880
>> Yeah, awesome.


00:37:44.880 --> 00:37:46.120
>> And that's it.


00:37:46.120 --> 00:37:48.280
>> Yeah, that's going to be a really cool talk.


00:37:48.280 --> 00:37:50.200
I think a lot of people are interested in how you share


00:37:50.200 --> 00:37:54.720
fixtures and build them for your team or cross-project as well.


00:37:54.720 --> 00:37:56.840
As it was really great to have you on Talk Python.


00:37:56.840 --> 00:37:59.160
We talked a bunch of cool pytest things.


00:37:59.160 --> 00:38:00.520
That'll be out in a few weeks for people,


00:38:00.520 --> 00:38:02.000
if they don't want to watch the YouTube version.


00:38:02.000 --> 00:38:05.240
>> And then we'll let people know when that's available.


00:38:05.240 --> 00:38:06.360
>> Yeah, absolutely.


00:38:06.360 --> 00:38:09.120
But hopefully they're all subscribed to Talk Python already anyway.


00:38:09.120 --> 00:38:10.520
Of course, I'm sure they are.


00:38:10.520 --> 00:38:10.800
Yeah.


00:38:10.800 --> 00:38:14.200
They are. How about a joke? Are we ready?


00:38:14.200 --> 00:38:15.480
Yes, let's do a joke.


00:38:15.480 --> 00:38:18.480
Let's do it. This one, this is a quick and easy one,


00:38:18.480 --> 00:38:20.400
and for people listening, no pictures even.


00:38:20.400 --> 00:38:24.240
This one comes from Nick's craft on Twitter,


00:38:24.240 --> 00:38:26.280
and it says, "Developers,


00:38:26.280 --> 00:38:29.000
let us describe you as a group."


00:38:29.000 --> 00:38:32.320
Groups of things sometimes have weird names.


00:38:32.320 --> 00:38:35.480
A group of wolves is called a pack,


00:38:35.480 --> 00:38:37.680
A group of crows is called a murder.


00:38:37.680 --> 00:38:41.120
We think we should call a group of developers, Brian.


00:38:41.120 --> 00:38:45.440
>> That's hilarious. A group of developers is called a merge conflict.


00:38:45.440 --> 00:38:47.080
>> Isn't that good?


00:38:47.080 --> 00:38:47.760
>> Yeah.


00:38:47.760 --> 00:38:50.960
>> It is. The comments are pretty good.


00:38:50.960 --> 00:38:53.380
If you scroll down here,


00:38:53.380 --> 00:38:55.040
some of them are silly,


00:38:55.040 --> 00:38:57.440
some are just like, "Yup."


00:38:57.440 --> 00:39:00.760
Anyway, they're pretty good.


00:39:00.760 --> 00:39:04.160
But yeah, a group of developers is called a merge conflict,


00:39:04.160 --> 00:39:05.600
And so true it is.


00:39:05.600 --> 00:39:08.240
You can even have a merge conflict with yourself.


00:39:08.240 --> 00:39:09.160
Be a group of one.


00:39:09.160 --> 00:39:13.680
- How about a group of tech CEOs


00:39:13.680 --> 00:39:15.400
with social media accounts?


00:39:15.400 --> 00:39:17.320
That'd be a lawsuit.


00:39:17.320 --> 00:39:19.200
- That's right.


00:39:19.200 --> 00:39:22.440
An SEC investigation, that's right.


00:39:22.440 --> 00:39:23.280
- Yeah, yeah.


00:39:23.280 --> 00:39:27.080
- Wow, fun as always, thank you.


00:39:27.080 --> 00:39:29.320
- Thanks everybody for showing up as always.


00:39:29.320 --> 00:39:32.160
And we'll see everybody next week.

