WEBVTT

00:00:00.001 --> 00:00:04.500
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to

00:00:04.500 --> 00:00:11.580
your earbuds. This is episode 168, recorded February 5th, 2020. I'm Brian Okken.

00:00:11.580 --> 00:00:12.380
I'm Michael Kennedy.

00:00:12.380 --> 00:00:13.580
And I'm Kojo Adresa.

00:00:13.580 --> 00:00:15.660
Yay, we have Kojo here as a special guest.

00:00:15.660 --> 00:00:17.640
Hey, Kojo, welcome to the show. Happy you're here.

00:00:17.640 --> 00:00:18.980
Hello. Thank you, thank you.

00:00:18.980 --> 00:00:22.680
This episode is brought to you by DigitalOcean. Thank you, DigitalOcean.

00:00:22.680 --> 00:00:25.340
Michael, I'm actually confused about this.

00:00:25.340 --> 00:00:28.460
It's a little bit of a funny name, right? So let me tell you about Donkey Car.

00:00:29.000 --> 00:00:36.120
Have either of you participated in or at least watched a proper RC remote control car race?

00:00:36.120 --> 00:00:40.340
Not really. Just sort of like the random ones. Like, random people have random remote control

00:00:40.340 --> 00:00:44.500
cars and running them around the neighborhood, but not an actual official proper one. No, I have not.

00:00:44.500 --> 00:00:44.800
Brian?

00:00:44.800 --> 00:00:49.220
Yeah, I just watched a little video that you sent me and it was quite exciting.

00:00:49.220 --> 00:00:54.920
These are really weird things. If you've never seen one of these, I put a link to like a three-minute

00:00:54.920 --> 00:00:58.700
video from GoPro where they put a GoPro on one of these little RC race cars.

00:00:58.700 --> 00:01:03.500
I used to have one of these when I was a kid, like high school, maybe late middle school. And

00:01:03.500 --> 00:01:06.900
they're insane. They're these little cars and your remote control and they go like 35 miles

00:01:06.900 --> 00:01:11.820
an hour. They're super quick and responsive. Really interesting. But what would be even cooler

00:01:11.820 --> 00:01:16.320
is if I could use Python to like win an RC car race. Don't you think?

00:01:16.320 --> 00:01:17.820
Ah, yeah, that would be cool.

00:01:17.820 --> 00:01:18.400
Yeah.

00:01:18.400 --> 00:01:18.780
You're right.

00:01:19.240 --> 00:01:23.780
I mean, you've already got the GoPro on there. It's already got a camera that's high quality.

00:01:24.040 --> 00:01:29.980
So, the thing that I want to talk about is this thing called Donkey Car. And it's a minimalist,

00:01:29.980 --> 00:01:34.480
modular, self-driving library, self-driving car library for Python.

00:01:35.040 --> 00:01:40.060
So, people are always looking for ways to get kids into programming or themselves to get into

00:01:40.060 --> 00:01:45.440
programming if they don't have some like formal project. Like, I want to build this website or I've

00:01:45.440 --> 00:01:49.640
got the data science thing I want to do. Something like a self-driving car I think could be really

00:01:49.640 --> 00:01:56.800
interesting. They have some much tamer vehicles that they have pictures of on the Donkey Car repo where

00:01:56.800 --> 00:02:01.900
it's more like little Lego cars and stuff. But you basically have these little tiny cars and you can

00:02:01.900 --> 00:02:06.960
put cameras on them and then you put a Raspberry Pi and then you teach it how to drive. And I think

00:02:06.960 --> 00:02:07.500
that's pretty awesome.

00:02:07.500 --> 00:02:09.960
Yeah. That looks fun.

00:02:09.960 --> 00:02:15.380
Doesn't it? Yeah. So, it says you can use Donkey Car if you want to make an RC car drive itself and

00:02:15.380 --> 00:02:20.640
win an RC car race. That would be awesome. If you want to compete in self-driving races like DIY

00:02:20.640 --> 00:02:27.480
RoboCars are, you know, the great robot race from DARPA way back in the day. I guess that's probably

00:02:27.480 --> 00:02:32.800
a little bit quite enough, but still quite cool. If you want to experiment with like autopilot or

00:02:32.800 --> 00:02:38.820
mapping computer vision and neural networks, if you want to log sensor data while you're driving around,

00:02:38.820 --> 00:02:46.000
if you want to drive a car via an Xbox game controller, that's pretty cool. Because you can

00:02:46.000 --> 00:02:50.660
then communicate, you know, with the controller over to the Raspberry Pi and then just tell it to drive

00:02:50.660 --> 00:02:57.620
however it tells it. Yeah. A lot of cool stuff. And yeah, I think if you have anything to do with

00:02:57.620 --> 00:03:02.980
like you're playing with AI and computer vision, this seems like a really fun way to make it interactive

00:03:02.980 --> 00:03:07.360
or kind of exciting without a lot of code. There's, it's pretty simple actually.

00:03:07.360 --> 00:03:13.760
Do you know if any of these RoboCars are going, or the self-driving are going like 35 miles an hour?

00:03:14.500 --> 00:03:18.920
I don't see, well, when I watched the video that I included, like on one hand, like I don't see why

00:03:18.920 --> 00:03:22.580
it would be hard because they have these little rails and it's kind of clear where the edge of the track is.

00:03:22.580 --> 00:03:27.980
You could even put up markers, like little things that you could like shine, you know, have detected

00:03:27.980 --> 00:03:35.080
with the computer vision, but they're so bouncy and incredibly jiggly. And it's really hard.

00:03:35.080 --> 00:03:39.220
I think, I think it would be a little bit hard. So maybe slow, but I don't know. I, my joke about winning

00:03:39.220 --> 00:03:43.140
the race, it seems a little far fetched. You'd have to have a really stable camera, which I guess you could get.

00:03:43.160 --> 00:03:43.480
Yeah.

00:03:43.480 --> 00:03:48.620
But anyway, I think this is a fun one. So if people are out there looking to play with a little AI

00:03:48.620 --> 00:03:50.940
computer vision, this seems cool. Check it out.

00:03:50.940 --> 00:03:51.680
It's very interesting.

00:03:51.680 --> 00:03:54.920
Yeah, for sure. Brian, there's a bit of a sad one coming up, right?

00:03:54.920 --> 00:03:55.520
What's going on?

00:03:55.520 --> 00:04:02.800
Yeah. Rest in peace. I ran across an interesting article by Nick Timkovic, I think, called,

00:04:02.880 --> 00:04:11.140
RIP Pipenv. Try too hard. Do what you need with pip-tools. So I didn't realize that that

00:04:11.140 --> 00:04:17.840
Pipenv was kind of stagnating. There's not been a release in 2019. I didn't check to see if maybe

00:04:17.840 --> 00:04:24.880
they slipped one in in 2020 yet. But apparently there's some problems with the subdependencies

00:04:24.880 --> 00:04:28.400
and complicated release process or something. But...

00:04:28.400 --> 00:04:33.260
Well, I want to add one really bit of a small bit of detail here because I think it's interesting.

00:04:33.260 --> 00:04:39.740
There's not been a release of Pipenv in 2019. And that makes it sound like all people have walked

00:04:39.740 --> 00:04:44.860
away, haven't done anything. There are 650 commits to that project and there's still not a release in

00:04:44.860 --> 00:04:48.740
the year, which is kind of rough, right? Like the people who worked on it, if that stuff's not

00:04:48.740 --> 00:04:50.020
getting released, that can't be great.

00:04:50.020 --> 00:04:55.300
Yeah. So I'm not sure what's going on. But the main emphasis of the article really isn't that

00:04:55.300 --> 00:05:00.500
whether, I mean, whether or not Pipenv survives or it's really dead. I don't think it's dead.

00:05:00.500 --> 00:05:07.240
I don't know what the state of it is. But one of the benefits that we saw with Pipenv was this idea

00:05:07.240 --> 00:05:14.580
of pinning everything and using, like having a pip file and a pip lock file or a lock file that says,

00:05:14.580 --> 00:05:20.000
these are the packages that I really depend on. And then all of those, plus all of the subpackages,

00:05:20.000 --> 00:05:27.500
I put those in another file, a lock file with their hashes so that I can know that I can reproduce

00:05:27.500 --> 00:05:33.320
that environment. And that's a, it's a really cool idea. I like the concept. Most of the bulk of the

00:05:33.320 --> 00:05:38.660
article is just basically saying, you can do that yourself without Pipenv. You can use pip compile

00:05:38.660 --> 00:05:44.720
that comes from pip-tools and there's a generate hashes function. But basically you do that yourself.

00:05:44.720 --> 00:05:49.940
You just have a smaller requirements file that just has what you really need, your direct

00:05:49.940 --> 00:05:56.800
dependencies. And then you can generate a hash file that is directly readable by pip. You can pip install

00:05:56.800 --> 00:06:04.060
from this, this other generated hash requirements file. The other part of Pipenv that people are using

00:06:04.060 --> 00:06:09.580
is virtual environment support. But I guess I'm on board with Nick to say, I don't understand why these

00:06:09.580 --> 00:06:16.860
were bundled into one tool and I'm using virtual VENV, the built-in just fine. I don't really need

00:06:16.860 --> 00:06:22.860
Pipenv for that. So I think I'm going to try to incorporate this possibly in my workflow, at least

00:06:22.860 --> 00:06:24.300
on one project to see how it goes.

00:06:24.300 --> 00:06:29.080
Yeah, that's pretty cool. I didn't realize you could output the requirements.txt with the hashes

00:06:29.080 --> 00:06:34.240
using pip compile either. That definitely was one of the selling points of pip enf was like,

00:06:34.240 --> 00:06:39.380
everything is locked, not just by pinning the version, but by the hash as well to make sure

00:06:39.380 --> 00:06:45.380
that it couldn't get messed up. Pipenv uses pip compile anyway. So I see. And it uses pip file

00:06:45.380 --> 00:06:51.840
and pip file.lock. You know more about this than I do, Brian. Isn't pyproject.toml the new hotness

00:06:51.840 --> 00:06:53.460
instead of pip file?

00:06:53.460 --> 00:06:58.460
The pyproject.toml doesn't have, I don't think that it supports doing hashes and stuff like that. So

00:06:58.460 --> 00:07:06.700
they still kind of support different ideas. I think the pyproject.toml is, I'm not sure where

00:07:06.700 --> 00:07:14.040
they cross over, but there still is this difference between a library that you can use for lots of

00:07:14.040 --> 00:07:19.280
stuff with lots of different versions of things in an application. With an application, you definitely

00:07:19.280 --> 00:07:22.480
want to lock things down to know what you're doing.

00:07:22.980 --> 00:07:28.720
For sure. Kojo, did you use pip enf any? What's your virtual environment preference?

00:07:28.720 --> 00:07:33.860
So I used it a small amount. I never used it a huge amount. I think my virtual environment

00:07:33.860 --> 00:07:38.860
preference has been virtual. Well, I had been virtual env wrapper, but I've recently started using

00:07:38.860 --> 00:07:45.880
pyenv. Well, actually, I started using pyenv, but that's more for managing different versions of Python.

00:07:46.160 --> 00:07:51.260
Right, right. I want this virtual environment to be Python 3.7 and that one to 3.8 and gasp that one too.

00:07:51.260 --> 00:07:58.520
Yeah. And so I've been using pyenv to manage different versions of Python, but then there's a pyenv-virtualenv

00:07:58.520 --> 00:08:04.460
module. And so that makes it a little easier to create virtual environments as you switch between

00:08:04.460 --> 00:08:10.660
Python versions. But for me, so pipenv, again, I'd never really gotten into using it, but having looked

00:08:10.660 --> 00:08:14.700
at it a little bit and I saw some of the early talks about it, it introduced me to that idea of a lock

00:08:14.700 --> 00:08:20.460
file. And then my personal blog is Jekyll, which is in Ruby. And Ruby uses a similar thing, that sort

00:08:20.460 --> 00:08:26.240
of gem lock file. And so just the familiarity with it there from pipenv was helpful to me as far as

00:08:26.240 --> 00:08:31.220
having to try to sort out stuff with Jekyll because I don't, Jekyll is the only thing, the only Ruby

00:08:31.220 --> 00:08:36.100
project I use. It's the only time I ever really use Ruby. So it was helpful at least to be familiar

00:08:36.100 --> 00:08:43.220
with that set of concepts there. Yeah. Yeah. Cool. And Brian, I'm very excited about Python 3.9 having the

00:08:43.220 --> 00:08:49.280
--prompt dot. So you get the folder name without the extra bits that you have to put in

00:08:49.280 --> 00:08:53.060
there to make that happen in the shell. Yeah. That's going to be cool. I love using prompt. Yeah,

00:08:53.060 --> 00:08:57.620
for sure. Kojo, what you got next? I'm going to talk about string, a string method called case fold.

00:08:57.620 --> 00:09:02.520
And this is something that's interesting. It actually just came up this morning. I was working on something

00:09:02.520 --> 00:09:10.980
this morning and you can use case fold in places where you're trying to do comparisons without

00:09:10.980 --> 00:09:15.640
having to look at the case of a string. And so they call it caseless matching. And so the standard thing

00:09:15.640 --> 00:09:20.400
in Python or the more common thing that you would do in Python is maybe you use like the string method,

00:09:20.400 --> 00:09:24.280
like string dot lower. And so you're not worried about whether someone types something in with,

00:09:24.280 --> 00:09:26.940
you know, uppercase or lowercase. And that works in a lot of situations.

00:09:27.020 --> 00:09:30.440
Wait a minute. Wait a minute. You're telling me that I've been doing it wrong for all these years?

00:09:30.440 --> 00:09:31.800
Completely wrong? Shame on you.

00:09:31.800 --> 00:09:37.480
Yes. I didn't. I knew the function case fold was here, but until you brought it up, I'm like,

00:09:37.480 --> 00:09:42.820
oh, whatever, like lowers. I've been doing it wrong. Carry on. This is awesome. I'm ready to hear about it.

00:09:42.820 --> 00:09:46.320
Well, and so the interesting thing about this is that, you know, lower works in a lot of,

00:09:46.320 --> 00:09:52.200
it works. It covers a lot of, a lot of use cases, especially if you're, you're using English or

00:09:52.200 --> 00:09:56.700
a similar language. It's interesting in the, the docs that case folding is similar to lower casing,

00:09:56.700 --> 00:10:00.980
but more aggressive, which is just a little funny to hear when my coworkers got a kick out of that.

00:10:00.980 --> 00:10:07.040
And I think where case fold becomes especially useful is if you're using a lot of Unicode characters.

00:10:07.040 --> 00:10:12.200
And I think, Michael, you had an example here, but so it stood out to me partially because I was

00:10:12.200 --> 00:10:16.080
working on a thing where I wanted to make sure cases, things were being compared and I didn't have

00:10:16.080 --> 00:10:18.460
to worry about the case of what was entered versus what was expected.

00:10:18.600 --> 00:10:22.700
Right, right, right. And until like today I would have written dot lower dot strip and been happy

00:10:22.700 --> 00:10:23.000
with that.

00:10:23.000 --> 00:10:28.000
Exactly. And so, and I started looking for some other ways. I, in addition to other things,

00:10:28.000 --> 00:10:32.440
I lived in China for two and a half years, so I can read and write Mandarin, a functional ability to

00:10:32.440 --> 00:10:39.580
read and write Japanese. I taught myself to read and write Hangul. And so I tend to use Unicode characters

00:10:39.580 --> 00:10:43.840
maybe a little more, a little more frequently than, than the average American. And so for me,

00:10:43.840 --> 00:10:48.740
I was like, and if I'm trying to build something and I'm concerned about handling text or case

00:10:48.740 --> 00:10:53.320
matching, I'm always interested in things that will support Unicode because the Unicode characters,

00:10:53.320 --> 00:10:58.260
because, you know, of course, like emoji, probably the most popular Unicode characters among English

00:10:58.260 --> 00:11:03.360
speakers, but you also have a number of other languages where the entire language is represented

00:11:03.360 --> 00:11:07.960
in Unicode characters. So something like this that will work in these, in these situations

00:11:07.960 --> 00:11:12.200
where you get Unicode characters is important. So like I said, I just discovered that this morning

00:11:12.200 --> 00:11:16.220
and ended up using it in a test I was writing and I'm like, okay, I can see how I can use this

00:11:16.220 --> 00:11:20.780
going forward. And I think, Michael, I think you've got like a, a slightly more flushed out example.

00:11:20.780 --> 00:11:24.920
Yeah. Yeah. So let me just give people an example because aggressively lower casing,

00:11:24.920 --> 00:11:28.960
that doesn't mean anything to me. When I read this, I'm like, I still have no, I read what the,

00:11:28.960 --> 00:11:33.640
the docs said about it. I'm like, I still have no idea what this means. Like if I had like

00:11:33.640 --> 00:11:38.100
Michael dash Kennedy with the dash be down, like underscore now, like, I mean, I just,

00:11:38.100 --> 00:11:42.980
I don't even know. Right. And so I found this example and it has two strings,

00:11:42.980 --> 00:11:48.980
the river in German, and there's sort of the formal German way to spell it where you have an,

00:11:48.980 --> 00:11:53.320
what's called an S set. It's like a, looks like a beta symbol, which is like two sharp,

00:11:53.320 --> 00:11:58.320
two S's together, like a super S. And then you could just, if you were on like an American or English

00:11:58.320 --> 00:12:02.000
keyboard, you're like, I can't find that character. I'm just type two S's as common in German.

00:12:02.000 --> 00:12:08.080
And if you case fold those, it will actually convert their flus with the S set that like the

00:12:08.080 --> 00:12:14.640
beta thing down to lowercase F L U S S and compare it, which I had no idea. That's pretty cool. So it,

00:12:14.640 --> 00:12:20.160
it'll take these letters that are, I guess, considered uppercase, but you know, not quite the same.

00:12:20.160 --> 00:12:24.460
And it'll sort of normalize the string more than just lower is the way I see it. It's like the

00:12:24.460 --> 00:12:28.960
canonical lowercase version of it. Yeah. And, and, I've, I've seen the,

00:12:28.960 --> 00:12:35.180
the example like that and I have no knowledge of German at all. And so, but it was useful to see

00:12:35.180 --> 00:12:39.060
that example. It's like, okay, here's, you know, here's another concrete reason, you know,

00:12:39.060 --> 00:12:43.140
why you might want to use this. but, but I think also with a lot of applications,

00:12:43.140 --> 00:12:47.760
be they web applications or standalone apps, when people are dealing with internationalization and

00:12:47.760 --> 00:12:53.560
localization, that kind of thing, having some sort of a method for caseless matching that,

00:12:53.720 --> 00:12:56.440
that, you know, will work across the Unicode characters, then, you know,

00:12:56.440 --> 00:13:00.400
it's not going to break once you get outside of, you know, the 26 letters of the, you know,

00:13:00.400 --> 00:13:05.200
the English alphabet is helpful. So yeah. Yeah. Brian, did you know about this? I I'm like blown

00:13:05.200 --> 00:13:11.400
away. I've always been doing lowercase. And so you've been doing it wrong. Yeah. I think it's

00:13:11.400 --> 00:13:15.700
pretty new from like, I think it's a, it got added in Python 3.3. So it's not, you know, it's not

00:13:15.700 --> 00:13:19.340
like, you know, it's not like a thing that you haven't been using for a very long time. Cause it

00:13:19.340 --> 00:13:23.480
hasn't been around that long, but as a, I think one, another thing that drew me to it

00:13:23.480 --> 00:13:27.940
was that the idea that in Python 3 and going forward, everything is, you know,

00:13:27.940 --> 00:13:33.260
everything is Unicode, the default sort of text handling mode is Unicode. And so it's not brand

00:13:33.260 --> 00:13:37.100
new, but it's also not like super old. So if you haven't been using it, you haven't been, you know,

00:13:37.100 --> 00:13:42.220
missing out in, and again, bring that lower still works unless you run into a situation where you

00:13:42.220 --> 00:13:46.200
were actively having to deal with Unicode characters, which, which a lot of us, you know,

00:13:46.200 --> 00:13:48.120
honestly, a lot of folks here in the U S don't. So.

00:13:48.320 --> 00:13:50.400
Yeah. Yeah. Pretty interesting. Thank you. That's awesome.

00:13:50.400 --> 00:13:55.540
This episode of Python bytes is sponsored by digital ocean. They have awesome infrastructure

00:13:55.540 --> 00:14:01.280
and awesome product. And we use them in our services. Do you have a memory intensive workload,

00:14:01.280 --> 00:14:06.420
maybe something like a high performance SQL or no SQL database or an in-memory cache,

00:14:06.420 --> 00:14:12.760
like maybe Redis or some indexes or some kind of large data analysis runtime? Well, check out

00:14:12.760 --> 00:14:18.240
digital oceans, new memory optimized droplets. They're optimized, especially for these high

00:14:18.240 --> 00:14:24.320
memory workloads. So check them out at pythonbytes.fm/digital ocean, and you can get a hundred

00:14:24.320 --> 00:14:29.040
dollar credit. Awesome. Yeah. Thanks to digital ocean for sponsoring the show, Brian. I feel like

00:14:29.040 --> 00:14:34.860
we're kind of in the same groove this week. You pick this rest in peace, pip enf, which to be clear,

00:14:34.860 --> 00:14:39.480
the pip enf people didn't say rest in peace, our project. Someone from the outside looked at it and

00:14:39.480 --> 00:14:44.440
made this declaration, but it's still an interesting article, right? Yes. Something that I have often

00:14:44.440 --> 00:14:50.000
wondered about is like, you see a lot of times people talking about virtual enf, and this was like

00:14:50.000 --> 00:14:55.840
the way to create virtual environments prior to VE and V being built in in Python, right? Yeah. Yeah.

00:14:55.840 --> 00:15:01.600
There's a new release of it. And my first thought was, why? Why is there a new release of it? Because

00:15:01.600 --> 00:15:07.360
Python 3-M, VNV, whatever I'm going to type after that, seems like it's solving my problem for me.

00:15:07.360 --> 00:15:11.940
And so why would you continue to work on this? You know, like it's, we're technically in the post

00:15:11.940 --> 00:15:17.240
Python 2 era officially, right? I mean, not in practice, there's a lot of Python 2 still out there,

00:15:17.240 --> 00:15:23.380
but it is now no longer supported being past January 1st, 2020. So why work on this thing,

00:15:23.380 --> 00:15:28.140
right? Well, Brian Skin sent in this and I'm like, all right, I'll take a look. Brian usually recommends

00:15:28.140 --> 00:15:34.200
good stuff. And it's this announcement by Bernat Gabor, who is working on the project and said,

00:15:34.200 --> 00:15:40.160
hey, we just did a major release of virtual enf. I'm like, okay, I got to figure out why this is

00:15:40.160 --> 00:15:44.620
still a thing. And he said, look, there's a couple of pain points that exist with current,

00:15:44.620 --> 00:15:49.740
you know, the dash MV and V style that creating a virtual environment is slow. It takes around three

00:15:49.740 --> 00:15:54.580
seconds, even in offline mode. Unless you're on Windows, then it takes longer. I don't know how

00:15:54.580 --> 00:15:59.460
much longer, but it seems to be that it copies more into the virtual environment rather than sim

00:15:59.460 --> 00:16:03.500
linking it on Windows. So it seems like it's a little slower. The other thing is that the API

00:16:03.500 --> 00:16:10.340
used around PEP 405 is great if you just want to create virtual environments, but it doesn't allow

00:16:10.340 --> 00:16:16.660
you to target very much around that or describe the target environment without actually creating the

00:16:16.660 --> 00:16:25.380
environment. And then the duality of virtual ENV versus VNV. So Python 3.4 has VNV added, as I said.

00:16:25.380 --> 00:16:30.060
So in theory, you could just switch away. But there's some other benefits that he talks about as well.

00:16:30.060 --> 00:16:37.320
So over specifically over VNV, which is the ability to discover and use alternate pythons, right? I can say

00:16:37.320 --> 00:16:43.320
dash P2 to create a virtual Python 2 virtual environment or kind of like you were saying, Kojo, I could say

00:16:43.320 --> 00:16:51.740
dash P3.8 or 3.7 or even dash P pypi 3 and get one of those environments created. So I can select from the

00:16:51.740 --> 00:16:57.860
different installed pythons as I create these, which is pretty cool. It also packages out of the box,

00:16:57.860 --> 00:17:02.440
out of the box, it packages the wheel package as part of the seed package, or caches part of the seed,

00:17:02.440 --> 00:17:09.080
the wheels as part of the seed packages, which after it's been created and cached, it speeds up the install

00:17:09.080 --> 00:17:14.620
time, especially for things like micro whiskey or whatever, like that thing takes 15 seconds to pip install

00:17:14.620 --> 00:17:22.120
at least. So making that faster seems awesome. And it's also guaranteed to work in places where VNV is

00:17:22.120 --> 00:17:28.280
not included with Python by default. For example, if you get the Debian or certain versions of Ubuntu,

00:17:28.280 --> 00:17:35.120
and you say Python 3 dash MVNV, it'll say VNV is not installed on this computer, and you've got to

00:17:35.120 --> 00:17:41.340
apt install it, right? Which is kind of funky. And then around that as well, you can also,

00:17:41.760 --> 00:17:47.680
because it's pip installed, not apt installed, it will, you know, you can upgrade it right away with

00:17:47.680 --> 00:17:53.420
pip whenever there's new changes and version it separately than what the OS is versioning VNV. So

00:17:53.420 --> 00:17:56.980
I don't know, what do you guys think? Does that, that sounds like a pretty good reason for it to be

00:17:56.980 --> 00:18:03.300
around actually, all those reasons. Yeah. The downside of it's confusing to have two.

00:18:03.300 --> 00:18:07.300
It is confusing to have two. Well, and I was confused about as well. And I'm not saying I'm switching to

00:18:07.300 --> 00:18:12.240
it necessarily, but I can see why that it's pretty interesting. I guess I'm sort of between the two

00:18:12.240 --> 00:18:17.540
of you from the standpoint of, I like that there is a lot of activity in this space as far as both,

00:18:17.540 --> 00:18:22.840
like we just, we just talked about PipBend with, you know, virtual environments and with, you know,

00:18:22.840 --> 00:18:27.760
installing and package management, that sort of thing. It's sort of a tricky issue. And so the fact

00:18:27.760 --> 00:18:32.240
that people are trying to improve, you know, people are looking at pain points and trying to build tools

00:18:32.240 --> 00:18:37.780
to improve on those is fantastic. I think sort of the confusing part is, and again, as someone who

00:18:37.780 --> 00:18:40.900
just started a new job and I've just been going through the process of setting up a new machine.

00:18:40.900 --> 00:18:42.920
You've been installing all the things, right?

00:18:42.920 --> 00:18:47.280
Yeah. Well, either installing all the things, or unfortunately there's, you run into sort of like

00:18:47.280 --> 00:18:54.540
a namespace pollution thing where like almost everything is called like Pi ENV something or,

00:18:54.540 --> 00:19:00.340
or pip Venve, or, you know, like a lot of the names are very similar. It's one of those things where

00:19:00.340 --> 00:19:06.340
it's, you know, sort of the good side of the bad side of the coin. Again, like it's great that these

00:19:06.340 --> 00:19:10.520
things are being worked on because, you know, especially with Python, you want to have, you know,

00:19:10.520 --> 00:19:15.020
some sort of separation, some sort of dependency management. And so wanting to make sure that

00:19:15.020 --> 00:19:18.920
you're developing the right version of Python and that you're not overriding things or creating

00:19:18.920 --> 00:19:25.260
conflicts. But I guess it's a situation where one or two dominant solutions show up. We'll sort of

00:19:25.260 --> 00:19:28.920
standardize on those, but now there's, you know, a little bit of confusion as we get to that point.

00:19:29.220 --> 00:19:34.160
Yeah. Yeah. It's good to see a thousand flowers blooming, but it is tricky to know which one's

00:19:34.160 --> 00:19:39.000
going to be around. All right. Which flower do you pick? You know, there are literally a thousand

00:19:39.000 --> 00:19:42.840
of them blooming, Seth. Exactly. Exactly. Brian, what you got next for us?

00:19:42.840 --> 00:19:47.280
Well, a little bit of testing. I don't know if we've talked much about hypothesis, but people

00:19:47.280 --> 00:19:52.060
probably know about hypothesis, property-based testing. Hypothesis is kind of mind-blowing a little

00:19:52.060 --> 00:19:57.540
bit, to be honest. It isn't a silver bullet, but it's kind of a cool thing. So I am highlighting a

00:19:57.540 --> 00:20:04.660
project, which is relatively new by Zach Hatfield, Dodds, and Paul Gansel are two people working on it so far.

00:20:04.660 --> 00:20:10.520
This is the idea of adding property-based tests for the Python standard library and for the built-ins.

00:20:11.000 --> 00:20:18.460
And their comments are that the CPython's existing test suite is actually very good, but bugs do still

00:20:18.460 --> 00:20:24.240
slip through occasionally. And maybe throwing some property-based testing tools at some parts of it

00:20:24.240 --> 00:20:30.880
could help. It's not a magic bullet, but computer-assisted testing techniques routinely try inputs that humans

00:20:30.880 --> 00:20:37.740
wouldn't. And hypothesis is what we got for Python. So why not? There's not very much covered yet in this

00:20:37.740 --> 00:20:42.400
project, so I'm highlighting it to try to get other people that are interested on board. But they want

00:20:42.400 --> 00:20:49.540
to try to have a compelling proof of concept by PyCon US this year to be running as a, and to see if it'd be

00:20:49.540 --> 00:20:56.100
worthwhile to have it running as part of the Python continuous integration suite to see how that goes.

00:20:56.100 --> 00:21:03.180
I think it's really, my view on the hypothesis really is that it's especially geared towards helpful for

00:21:03.180 --> 00:21:09.740
algorithmic pure functions. And in a lot of cases where you have like two functions that work kind of

00:21:09.740 --> 00:21:15.800
in opposite directions, so you can do round trip, it's easier to set up a test for hypothesis to see,

00:21:15.800 --> 00:21:20.920
like for instance, encode or decode. You can take some sort of string or something and encode it,

00:21:20.920 --> 00:21:26.100
and then use the decode to make sure that you've got the final output is the same as your input.

00:21:26.100 --> 00:21:32.260
These are easier tests. Functions that have, that are not pure, that have state, that depend on state,

00:21:32.260 --> 00:21:38.080
those are harder things to test with hypothesis. So I think there's actually quite, and that kind of

00:21:38.080 --> 00:21:42.560
applies to a whole bunch of the standard library. So I think there's a whole bunch of stuff that could

00:21:42.560 --> 00:21:46.040
be tested more thoroughly with hypothesis. So this is pretty cool.

00:21:46.040 --> 00:21:49.720
Yeah, it's a really interesting way of testing, and I'm glad to see the project. It looks cool.

00:21:49.720 --> 00:21:52.700
One of the things I like about it is these are some people that I respect,

00:21:53.100 --> 00:22:00.000
and having some people do these focused examples of how to use hypothesis in this way,

00:22:00.000 --> 00:22:04.300
I think will actually help as a teaching tool to help other people learn how to use it.

00:22:04.300 --> 00:22:13.100
Yeah. I would love to see like a big set of the standard unit tests for CPython moved over

00:22:13.100 --> 00:22:18.640
and maybe condensed and brought down into like this hypothesis style to see what the two sets of test

00:22:18.640 --> 00:22:22.340
suites look like. That would be interesting. Feels like a lot of work. That would be interesting.

00:22:22.440 --> 00:22:29.040
Oh, but even like a specific case of taking like one, what are the functional tests in that exist in

00:22:29.040 --> 00:22:34.800
CPython already? What do those look like compared to the property-based test? They're testing different

00:22:34.800 --> 00:22:38.120
things. So I think it'd be cool to see them side by side too. That's neat.

00:22:38.120 --> 00:22:43.320
Yeah. So property-based testing is a thing that I saw in my prior job, I did mostly QA.

00:22:43.320 --> 00:22:47.740
And so I started to look into property-based testing. It's one of those things that it sounds very

00:22:47.740 --> 00:22:51.760
interesting and that something that I'd like to know more about and just have another time to dig into.

00:22:51.780 --> 00:22:58.880
But this project looks interesting. And it also kind of flows right into my topic. So the people

00:22:58.880 --> 00:23:04.140
that you were just talking about, Zach Hatfield-Dowd and Paul, they are doing a tutorial on

00:23:04.140 --> 00:23:08.240
property-based testing. And so what I wanted to talk about was just about, what time is it now?

00:23:08.240 --> 00:23:13.360
Three of my time. So about two hours ago, I got an email from PyCon saying that the PyCon tutorials,

00:23:13.840 --> 00:23:19.280
the schedule for the PyCon US tutorials, PyCon US 2020, the schedule for those tutorials is up and

00:23:19.280 --> 00:23:24.900
available and you can register for them now. And so if you are thinking about going to PyCon,

00:23:24.900 --> 00:23:30.540
depending on what you do, different people, you know, some people work in places where their

00:23:30.540 --> 00:23:34.040
companies would just send them PyCon and it's not a big deal. Other people have to make a business case

00:23:34.040 --> 00:23:38.600
to try to sort of convince their organizations to let them go. If you are in a situation where you need

00:23:38.600 --> 00:23:43.580
to make a business case, the tutorials are often an excellent tool for that because you can get

00:23:43.580 --> 00:23:49.900
a lot of high quality training from people who are very knowledgeable in their fields. And so one of

00:23:49.900 --> 00:23:55.320
the sets of people, one of the tutorials is actually an introduction to property-based testing by the same

00:23:55.320 --> 00:24:00.860
people that Brian was just talking about. So there's a link here, you know, to PyCon.org. So

00:24:00.860 --> 00:24:05.000
there's a full schedule of the different tutorials that are available and you can register for them

00:24:05.000 --> 00:24:09.580
now if you'd like. They do tend to sell out pretty quickly though. The PyCon tutorials tend to be

00:24:09.580 --> 00:24:15.840
pretty popular. They tend to sell out pretty quickly. The good news is that the videos of the tutorials are

00:24:15.840 --> 00:24:21.100
all available. So even if you haven't, if you weren't able to make it to a prior PyCon, the videos for

00:24:21.100 --> 00:24:26.500
those tutorials are available. And so you can look at past tutorials. The big advantage of actually going to

00:24:26.500 --> 00:24:31.000
PyCon and going to a tutorial is again, just the fact that you have a chance to interact with the

00:24:31.000 --> 00:24:35.540
people who are giving the tutorial and to be able to ask specific questions that meet your specific

00:24:35.540 --> 00:24:39.380
use case. Yeah. And make connections, right? Yeah, exactly. I mean, make it, make connections with

00:24:39.380 --> 00:24:44.180
people. Again, like if you are trying to say, for instance, you know, just to say with the hypothesis,

00:24:44.180 --> 00:24:48.980
with the properties-based testing, if you're trying to implement that where you are, not only now is

00:24:48.980 --> 00:24:54.880
there this effort to bring some property-based testing into CPython, but you take a tutorial,

00:24:55.080 --> 00:24:59.320
you can actually interact with the people who are sort of leading this effort. And then if you have

00:24:59.320 --> 00:25:04.000
specific questions, you've made a connection where you can reach out to those folks and try to get some

00:25:04.000 --> 00:25:07.700
help as far as implementing, you know, trying to figure out, you know, what to do to implement that kind of

00:25:07.700 --> 00:25:12.500
thing where you are to get a better understanding of the use cases, that sort of thing. So I went through,

00:25:12.500 --> 00:25:18.060
like I said, I think the schedule just went up an hour or so ago. So I went through and sort of looked at ones

00:25:18.060 --> 00:25:22.700
that were interesting to me. A couple of standouts to me were one, there's a tutorial on migration from

00:25:22.700 --> 00:25:27.800
Python 2 to Python 3. And as Michael was just talking about, you know, Python 2 is now end of

00:25:27.800 --> 00:25:33.180
life. And so, you know, if you have not moved to Python 3, now, you know, now is the time, you know,

00:25:33.180 --> 00:25:38.640
earlier was really a better time, but you know, there's no time better than now if you haven't

00:25:38.640 --> 00:25:42.860
done it before. So a tutorial on that, that'll be really helpful. Another one called Welcome to

00:25:42.860 --> 00:25:48.380
Circuit Python by Katni Rembor. We were talking before with Michael's point about the remote control

00:25:48.380 --> 00:25:51.920
cars. If you're looking at ways to get started with programming or to get other people into

00:25:51.920 --> 00:25:57.320
programming, actually programming hardware is a good way to do that. You know, few things get

00:25:57.320 --> 00:26:00.920
people's attention, like writing some code and making it, making the light turn on and making the light

00:26:00.920 --> 00:26:05.560
change color or making it flash in a certain pattern. And so the Circuit Python, I remember, I think at

00:26:05.560 --> 00:26:11.420
PyCon last year, everybody got like a Circuit Python playground board, like a small little mini circular

00:26:11.420 --> 00:26:16.640
board that had lights and various sensors on it. And so I've been to one of Katni's tutorials,

00:26:16.640 --> 00:26:23.140
like a PyOhio in 2018, maybe. And so it's the Circuit Python boards are really interesting.

00:26:23.140 --> 00:26:26.980
You've got lights and sensors and you can, you know, you can build all sorts of things with them.

00:26:26.980 --> 00:26:31.140
And it's a great gateway into programming, great, great way to get started. Or if you're an experienced

00:26:31.140 --> 00:26:34.940
developer, a great way to start get started with hardware programming. And then the intro to

00:26:34.940 --> 00:26:39.160
property based testing. And then there's another tutorial called Minimum Viable Documentation by a

00:26:39.160 --> 00:26:43.060
woman named Heidi Waterhouse. And I've met Heidi, we spoke at PyCaribbean together, I think a couple of

00:26:43.060 --> 00:26:50.280
years ago. But it's this idea about how do you set up a proper technical, you know, a proper

00:26:50.280 --> 00:26:54.600
documentation structure for your projects, and focusing on the technical writing aspect. I think

00:26:54.600 --> 00:26:58.820
it's one of those things, especially as a project gets larger, but even in a smaller project that gets

00:26:58.820 --> 00:27:02.940
overlooked, sometimes there's so much focus on, let's write code that does this thing. And that's

00:27:02.940 --> 00:27:07.060
fantastic. But what if you want to add a second person, add a third person to that project,

00:27:07.060 --> 00:27:13.580
and your options then become either the first person sits down and just spends four hours talking

00:27:13.580 --> 00:27:18.620
to the new person, you know, or if you have good documentation, a good documentation, a good

00:27:18.620 --> 00:27:23.060
documentation structure, you can just point them to the documentation and let them get up to speed on

00:27:23.060 --> 00:27:27.280
their own. I mean, there are multiple other tutorials, but those are ones that just sort of stood out to me.

00:27:27.780 --> 00:27:33.020
But if you haven't been to a PyCon US, the tutorials are, I think, one of the strong reasons

00:27:33.020 --> 00:27:36.960
to want to go, among other things, you know, meeting people and making connections and that sort of

00:27:36.960 --> 00:27:41.580
stuff. And the open, you know, the open spaces in the hallway track, but the tutorials, especially

00:27:41.580 --> 00:27:46.600
also if you're in a situation where you need to make a business case to your company to get support to

00:27:46.600 --> 00:27:49.720
go, the tutorials are really good, a really good option for that.

00:27:49.720 --> 00:27:53.440
I love that angle. And I also approached it the same way that you do is like, oh, these are out,

00:27:53.440 --> 00:27:59.040
let me see which are interesting to me. So I came up with three as well, maps and machine learning,

00:27:59.040 --> 00:28:03.760
spatial analysis with TensorFlow, scikit-learn and PyTorch. And I think it's really cool,

00:28:03.760 --> 00:28:08.560
kind of like you're talking about the hardware is like, you take geospatial data and real world

00:28:08.560 --> 00:28:13.020
things and do awesome stuff with it with Python. So here's kind of the map version of that. I think

00:28:13.020 --> 00:28:22.020
that one's a fun one. And then hands-on web app test automation by Andrew Knight. Brian,

00:28:22.020 --> 00:28:25.060
that'd be a good one for you as well, right? Like that sounds pretty interesting.

00:28:25.060 --> 00:28:26.380
Yeah, it does look good.

00:28:26.380 --> 00:28:31.460
Yeah. And finally, bigger, better, faster, more building applications in Python. That also looks

00:28:31.460 --> 00:28:36.200
pretty cool to me. So there's a bunch of other great, and this is not like the best of list or

00:28:36.200 --> 00:28:40.220
whatever. This is just like stuff that stood out to me like, oh, I'd go to these. Sounds pretty cool.

00:28:40.220 --> 00:28:44.500
And these tutorials are priced way lower than any sort of corporate training is going to be

00:28:44.500 --> 00:28:49.100
priced. Yeah. Yeah. Very cool. You guys are both going to be at PyCon, right? Brian,

00:28:49.100 --> 00:28:54.340
you're speaking. Is that true? I am speaking. Yes. On what topic do you speak? I am talking about

00:28:54.340 --> 00:28:58.340
parameterized testing. Awesome. And Kojo, I'm guessing that you're going to be there. You're at a lot of

00:28:58.340 --> 00:29:03.360
the conferences. Yeah. And actually, so this year, I just started a new job. I'm working with a company

00:29:03.360 --> 00:29:07.940
called RevSys now. They're sponsoring it, so I will be there. But yeah, Ian, I would have been there either way,

00:29:07.940 --> 00:29:12.020
probably so. Yeah. Awesome. I'm glad you're going to be there as well. All right, Brian,

00:29:12.020 --> 00:29:15.780
I guess that's it for our main items, huh? Yeah, it is. You got anything to share with folks?

00:29:15.780 --> 00:29:19.320
I was going to share with folks that I'm speaking at PyCon, but we already covered that.

00:29:19.320 --> 00:29:24.660
We snuck it in the previous one. How about you, Kojo? Anything extra you want to throw out there for

00:29:24.660 --> 00:29:28.300
the world? No, I don't think I have any new, exciting Python-related stuff.

00:29:28.300 --> 00:29:34.180
Well, I've got a couple to share. One, Eric Cho, just released the third edition of his

00:29:34.180 --> 00:29:39.000
Mastering Python Networking, which is a cool little use Python to control all the network

00:29:39.000 --> 00:29:43.840
things and set up network topologies and whatnot book, which is quite interesting. And I got a chance

00:29:43.840 --> 00:29:49.420
to write the foreword for that. So thank you, Eric, and I'll link to the book. Also, speaking of network

00:29:49.420 --> 00:29:57.160
things, both Pyramid, through the Waitress web server thing, and Django have issued vulnerability

00:29:57.160 --> 00:30:02.580
CVEs. So yeah, if you have either of those in production and they're on the internet,

00:30:02.580 --> 00:30:07.320
or even not, you might want to do a little upgrade, a Pippin's all upgrade, all the things on it.

00:30:07.320 --> 00:30:12.860
Because yeah, there's like a SQL injection vulnerability, like a little Bobby Tables

00:30:12.860 --> 00:30:17.940
vulnerability in Django, and some other similar type of thing for Waitress, and those are not

00:30:17.940 --> 00:30:22.180
good to have. And why is Pyramid and Waitress together? Is Waitress bundled with Pyramid?

00:30:22.320 --> 00:30:28.740
It comes with Pyramid. And I think the guys who work on Pyramid may also work on Waitress. I'm not

00:30:28.740 --> 00:30:32.280
sure I could be wrong about that. So sorry, people who work on Waitress, if I got that wrong. But

00:30:32.280 --> 00:30:36.540
certainly when you install Pyramid, you get Waitress, and you want that to be up to date.

00:30:36.540 --> 00:30:38.940
Waitress server, you know, things like that.

00:30:38.940 --> 00:30:46.560
Okay, and then the last thing, kind of like your item here, Kojo, even shorter time, like 45 minutes

00:30:46.560 --> 00:30:52.900
ago, the Stack Overflow 2020 survey is open. So everyone should go fill that out. There's a ton

00:30:52.900 --> 00:30:59.440
of information about where the broader ecosystem is at here. So it takes about 10 minutes. It's a

00:30:59.440 --> 00:31:01.240
little bit long, but it's totally worth it, I think.

00:31:01.240 --> 00:31:05.540
Yeah, and if there's anywhere in there where you can plug our podcasts, go for it.

00:31:05.540 --> 00:31:06.260
I don't know if there is.

00:31:06.260 --> 00:31:06.920
There totally should be.

00:31:06.920 --> 00:31:08.960
Like, where do you get your news or something like that?

00:31:08.960 --> 00:31:14.960
Yes, exactly. Other. All right, Brian, I picked a joke for us that's graphical, so we have to do a

00:31:14.960 --> 00:31:20.420
little work describing it. But I think it's going to come out pretty well, because I think it's right

00:31:20.420 --> 00:31:27.060
up your alley, actually, here. So this is a comic, which is Richard's Guide to Software Development.

00:31:27.060 --> 00:31:34.760
And I'll kick it off. There's like a cat with little like super bionic legs. And underneath the

00:31:34.760 --> 00:31:38.060
caption is, how the software is designed. You want to take it from here?

00:31:38.260 --> 00:31:46.300
Okay, well then the next one is, how much time has to be spent on each part? And there's like 4%

00:31:46.300 --> 00:31:52.020
for the head, and then 2% for the middle of it, 80% for the tail. Oh yeah, that's totally true.

00:31:52.020 --> 00:31:59.360
Nice. The next one is, how the software looks before the beta test. It's a cat, but it has no back

00:31:59.360 --> 00:32:01.620
legs at all, but it's still like suspended somehow.

00:32:01.620 --> 00:32:06.520
Yeah, and then how the software looks after the beta test, there's no front legs, but there are back

00:32:06.520 --> 00:32:10.680
legs. I'm just trying to imagine what happened here. Like, no, no, we wanted legs on the back of

00:32:10.680 --> 00:32:13.780
the cat. Like, oh, you want the legs on the back? Sure, we'll put them on the back. Okay, we'll just

00:32:13.780 --> 00:32:14.560
move them. Yeah.

00:32:14.560 --> 00:32:21.080
And then how the software is advertised is like a tiger springing out of a picture with like action.

00:32:21.080 --> 00:32:25.520
Yeah. What the customer really wanted, there's just a question mark, because nobody asked.

00:32:26.100 --> 00:32:33.220
Exactly. And then how the software looks two versions later, it has a nose like an anteater or an elephant.

00:32:33.220 --> 00:32:36.280
It's just a random human arm coming out the back of it.

00:32:36.280 --> 00:32:43.060
Oh man. And the last scene has like a dude petting this cat that has the arm sticking out with the

00:32:43.060 --> 00:32:46.460
elephant nose saying, I still like you anyway.

00:32:46.460 --> 00:32:48.400
The cat says toots. Yeah.

00:32:49.320 --> 00:32:53.380
Anyway, there's a nice little testing one. Actually for you as well, Kojo, right? You were in QA.

00:32:53.380 --> 00:32:56.780
Yeah, it used to be. Yeah, the developers love their software.

00:32:56.780 --> 00:33:03.240
That's great. All right. Well, this is a lot of fun. Kojo, thanks for being here. And Brian,

00:33:03.240 --> 00:33:04.960
thanks as always. Glad to have you back this week.

00:33:04.960 --> 00:33:06.240
Yeah, yeah. Thanks.

00:33:06.240 --> 00:33:07.400
Thanks for having me, you guys.

00:33:07.400 --> 00:33:08.960
Yep. Bye, everyone.

00:33:08.960 --> 00:33:09.320
Bye.

00:33:09.320 --> 00:33:33.320
Bye.

