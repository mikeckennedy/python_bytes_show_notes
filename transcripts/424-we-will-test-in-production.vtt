WEBVTT

00:00:00.001 --> 00:00:10.620
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds. This is episode 424, recorded March 17th, 2025. I'm Michael Kennedy.

00:00:11.100 --> 00:00:11.160
And

00:00:11.160 --> 00:00:11.800
I'm Brian Okken.

00:00:11.980 --> 00:00:19.560
And this episode is brought to you by us. Check out all of our things, courses at pythontest.com,

00:00:19.860 --> 00:00:20.480
talkpython

00:00:20.480 --> 00:00:31.040
.fm, all the places. If you want to get in touch with us, social media is probably the best place. I have a couple of things sent to me on social media. I don't know about you, Brian, but a couple that I'll be covering today.

00:00:31.400 --> 00:00:31.540
Yeah.

00:00:31.900 --> 00:00:33.040
So that's always fun.

00:00:33.280 --> 00:00:35.720
Find us on blue sky, find us on Mastodon.

00:00:36.000 --> 00:00:36.840
It doesn't matter.

00:00:37.180 --> 00:00:39.200
Doesn't matter what server you're on.

00:00:39.260 --> 00:00:40.820
Everyone talks to everyone on Mastodon.

00:00:41.180 --> 00:00:48.640
So you can find the links for all those at the top of the show and we're refining and improving our newsletter format.

00:00:48.840 --> 00:00:50.660
It's getting better and better and more valuable.

00:00:50.760 --> 00:00:56.100
I think it's got a nice little TLDR, grab the links, grab the joke and then dive into it if you want.

00:00:56.260 --> 00:00:57.260
And yeah, so.

00:00:57.780 --> 00:01:01.640
Buy them by SET-FM, smash that newsletter button and get signed up.

00:01:03.640 --> 00:01:04.080
I

00:01:04.080 --> 00:01:05.560
think people are getting a lot of value out of it.

00:01:05.560 --> 00:01:06.280
It's really nice, Brian.

00:01:06.660 --> 00:01:08.040
Yeah, I think, I think it's great.

00:01:08.320 --> 00:01:17.580
also, yeah, we've mentioned this before, but I really love the, the, what you should know if we cover a topic that you're, you're not quite understand.

00:01:17.800 --> 00:01:21.060
Don't not quite, don't quite understand what that topic's all about.

00:01:21.180 --> 00:01:24.000
You can check some of the background links in those.

00:01:24.240 --> 00:01:24.940
So, so that's cool.

00:01:25.520 --> 00:01:25.960
Absolutely.

00:01:26.130 --> 00:01:26.760
I totally agree.

00:01:27.020 --> 00:01:28.980
And thank you to our Patreon supporters as well.

00:01:29.420 --> 00:01:29.620
Now,

00:01:30.300 --> 00:01:31.040
let us begin.

00:01:31.600 --> 00:01:33.420
Let us begin, Brian, with your first item.

00:01:33.480 --> 00:01:34.120
What you got for us?

00:01:34.560 --> 00:01:38.780
I, I have, a weird quirk around rounding in Python.

00:01:39.280 --> 00:01:41.780
And actually this is just apparently normal.

00:01:41.940 --> 00:01:45.340
This is a feature, but I didn't know about it or I had forgotten about it.

00:01:45.800 --> 00:01:49.980
So, we're linking to the weird quirk around rounding in Python.

00:01:50.120 --> 00:01:56.940
And the weird quirk is really just if your number ends in 0.5, like 1.5, 2.5, things like that.

00:01:57.460 --> 00:01:59.600
If you round it, it'll become even.

00:01:59.960 --> 00:02:01.340
It always goes even.

00:02:01.720 --> 00:02:06.080
So I didn't know this, but apparently it works better that way.

00:02:06.180 --> 00:02:09.759
And that's part of the IEEE standard 754.

00:02:10.179 --> 00:02:15.180
So 0.5 rounds to 0, 1.5 rounds to 2, and so forth and so on.

00:02:15.840 --> 00:02:16.800
Negative numbers also.

00:02:17.000 --> 00:02:20.120
So negative 1.5 will round to negative 2.

00:02:21.120 --> 00:02:22.860
So did you know this?

00:02:24.000 --> 00:02:35.320
I did not know this. I do not accept this. I don't accept this as a mathematician, formerly, but by lots of training and education, I do not accept.

00:02:35.680 --> 00:02:36.420
So what do you do?

00:02:36.420 --> 00:02:38.280
You always round to even numbers.

00:02:38.940 --> 00:02:49.780
So normally, like when I, it's been a long time since I've been in primary school, but isn't the, isn't the like hand math thing that you round up if it's like 1.5?

00:02:50.200 --> 00:02:51.960
It goes to the closest whole number.

00:02:52.420 --> 00:02:52.980
Wait, but That's it.

00:02:53.040 --> 00:02:55.900
At.5 there isn't a closest, it's right in the middle.

00:02:56.300 --> 00:02:59.900
Ah, I see. So if it was.1,.5, 0,

00:02:59.900 --> 00:03:02.600
0, 0, 0, 0, 0, 1 It goes up, yeah.

00:03:02.940 --> 00:03:07.400
It goes up, I see. So it's basically deciding at the...

00:03:07.700 --> 00:03:08.720
Where does the tie go?

00:03:08.720 --> 00:03:22.140
The decimal representation of the cutoff. So 4 point, in my world, 4.999999, non-repeating but as many nines as you care to put, goes down. And.5 and above goes up.

00:03:22.760 --> 00:03:26.440
If it's 1.4, you round down in regular math, right?

00:03:26.460 --> 00:03:26.600
- Yeah.

00:03:26.920 --> 00:03:29.560
- If it's 1.4999,

00:03:30.400 --> 00:03:30.800
you round

00:03:30.800 --> 00:03:30.960
out.

00:03:31.040 --> 00:03:31.420
If it's 1

00:03:31.420 --> 00:03:33.660
.4999999, as many as you want.

00:03:33.980 --> 00:03:35.340
- All the extra decimals don't matter.

00:03:35.500 --> 00:03:41.220
It's only with the actual, just one, if it's.5, zero.

00:03:41.420 --> 00:03:41.960
All zeros.

00:03:42.080 --> 00:03:43.880
So this is like 0.5, 1.5.

00:03:44.400 --> 00:03:46.640
That's a tie, then there is no closest integer.

00:03:46.940 --> 00:03:47.800
So where does it go?

00:03:48.100 --> 00:03:52.580
And I thought in math that we always just like, half goes up. Yeah,

00:03:52.860 --> 00:03:53.740
that's what I thought too.

00:03:54.140 --> 00:04:08.360
But so it doesn't it makes it make and there's reasons around it because if you if you average you want the average to be like if you averaged a bunch of these you want it to be five like you have a bunch of random numbers like

00:04:08.360 --> 00:04:09.320
zero

00:04:09.320 --> 00:04:37.520
through ten or one through yeah I don't know it's gonna you want it to be five, but it's not. It's a little bit off. So this standard makes the average work. However, if you really want the normal way that we've been taught in grade school, there's a decimal feature that you can have it be round half up. So you can make it work normal, but apparently it's doing the right thing. You just didn't know that was the right thing. So

00:04:37.520 --> 00:04:38.300
anyway.

00:04:38.940 --> 00:04:39.440
It's a feature.

00:04:40.520 --> 00:04:43.860
It's also known as banker's rounding or Dutch rounding, apparently.

00:04:44.280 --> 00:04:45.720
That's learned something new there.

00:04:47.120 --> 00:04:50.920
And being that Guido is Dutch, maybe that has something.

00:04:51.100 --> 00:04:51.440
I don't know.

00:04:52.540 --> 00:04:55.420
So just if you're rounding numbers, you should be aware of this.

00:04:55.480 --> 00:04:56.160
That's it, really.

00:04:57.260 --> 00:04:58.820
So, yeah.

00:04:59.210 --> 00:04:59.960
You want an easy

00:04:59.960 --> 00:05:03.100
way to put it back to like grade school rounding?

00:05:04.000 --> 00:05:08.540
All you have to do is just say int of your number plus.5.

00:05:08.860 --> 00:05:09.760
Int plus.5.

00:05:10.040 --> 00:05:10.260
>> Okay.

00:05:10.530 --> 00:05:16.540
>> So if it's 1.5 plus 0.5, it's two as a decimal, but then you turn it to an int, it's two.

00:05:16.930 --> 00:05:17.700
>> Right.

00:05:17.790 --> 00:05:19.680
>> So it's basically just a truncation.

00:05:20.020 --> 00:05:20.840
Yeah, it truncates it.

00:05:20.870 --> 00:05:22.640
The 0.5 is like, okay, bump it up.

00:05:22.960 --> 00:05:25.580
If it's 0.5 or above, bump it to the next number, then chop it off.

00:05:25.990 --> 00:05:26.080
>>

00:05:26.080 --> 00:05:28.480
Weird. I wonder why we do it different.

00:05:28.920 --> 00:05:29.280
Anyway.

00:05:29.530 --> 00:05:29.940
>> I don't know.

00:05:30.780 --> 00:05:31.140
Interesting.

00:05:31.500 --> 00:05:32.400
Thanks, Tom, for the article.

00:05:33.340 --> 00:05:33.920
Lots of stuff.

00:05:34.250 --> 00:05:35.540
>> Okay. What do you got for us?

00:05:36.070 --> 00:05:42.780
>> Well, I've got some pretty interesting things here in terms of Python performance improvements.

00:05:43.340 --> 00:05:45.460
So Brian, are you a fan of recursion?

00:05:46.000 --> 00:05:46.700
>> Not really.

00:05:47.420 --> 00:05:53.080
>> I'm not either, but I was against my will forced to take two programming courses in college.

00:05:53.300 --> 00:05:55.180
One was Fortran and one was Lisp.

00:05:55.400 --> 00:05:58.260
In Lisp or Scheme, it's all about recursion, right?

00:05:58.460 --> 00:05:58.720
>> Yeah.

00:05:58.880 --> 00:06:02.300
>> Like there's no, the way you do loops is to do recursion and so on.

00:06:02.540 --> 00:06:10.740
And in certain, not in Scheme, but in other languages, you can pretty quickly run out of stack space by doing recursion.

00:06:10.940 --> 00:06:15.240
And you might have gotten a stack overflow exception, you know, and--

00:06:15.460 --> 00:06:16.540
- That's the name. - We know about stack,

00:06:16.660 --> 00:06:18.720
that's the name, like, what does this even mean?

00:06:19.120 --> 00:06:32.880
So there's ways to rewrite that at the runtime level to say the reason you run out of stack space is every function call gets its own new stack frame allocated and all of its locals and all that kind of stuff.

00:06:33.120 --> 00:06:46.480
What if we could just say, reuse the existing stack space, grabbing some of the local variables that are being passed and just kind of reusing them long as you find a way to save the data to kind of go up the stack when you hit return or something like that, right?

00:06:46.780 --> 00:06:46.920
- Yeah.

00:06:47.060 --> 00:06:50.760
- And to my limited experience, that's what tail calls do.

00:06:51.060 --> 00:07:01.560
So if you've heard about adding, like doing tail recursion to make your recursion much faster, that's because not every single, basically every single step in the loop, you don't have to recreate the function frame.

00:07:02.560 --> 00:07:02.920
So

00:07:02.920 --> 00:07:04.300
that's

00:07:04.300 --> 00:07:04.780
really good.

00:07:04.830 --> 00:07:12.060
And so the idea here, the news is that the faster CPython project has added tail calls to Python.

00:07:12.200 --> 00:07:15.980
This is not exactly the same thing because it doesn't exactly have to do with recursion.

00:07:16.210 --> 00:07:21.740
It has to do with stepping through the bytecode instructions.

00:07:22.080 --> 00:07:22.180
Okay.

00:07:22.540 --> 00:07:22.660
Okay.

00:07:23.060 --> 00:07:27.220
So traditionally there've been different ways in which Python does that.

00:07:27.260 --> 00:07:35.400
The article from LWN.net says, "Python's Many Interpreters." So when you run a Python program, it converts it to bytecode.

00:07:35.560 --> 00:07:36.240
Yes, we know this.

00:07:36.460 --> 00:07:40.740
It says, however, there's actually a couple of ways in which this could be executed.

00:07:41.160 --> 00:07:54.140
There's the switch-based interpreter version, and then there's a go-to, what do they call it, the computed go-to statements version, which they say is a micro-op interpreter.

00:07:54.620 --> 00:07:55.580
This is relatively new.

00:07:55.860 --> 00:08:10.800
Like you maybe have seen the giant switch statement and by giant, I mean, 3,500 lines of C switch statement, single switch statement within a for loop that says for each, you know, go to the next byte instruction, switch on what it is, do that, right?

00:08:11.040 --> 00:08:24.640
That has still stuck around because certain compilers don't support what's called a computed go-to statement or dynamic go-to statements, which sounds terrible, but it's a compiler level thing, not a human

00:08:24.640 --> 00:08:26.160
code

00:08:26.160 --> 00:08:26.980
level thing.

00:08:27.160 --> 00:08:30.940
My go-to statements are bad for people, but they're not necessarily bad for compilers.

00:08:31.300 --> 00:08:37.560
So the reason the old one is around is some of the compilers can't take it, but the new one's a little bit better.

00:08:38.180 --> 00:08:58.000
So the idea here is that, I'm going to give credit to it, so Ken Jin, member of the Faster Steep Python project has merged a new set of changes that have up to 10% actually up to 40% performance improvements on an average geometric mean of 10% improvements, which is pretty awesome.

00:08:58.130 --> 00:09:40.760
So the idea is that we can change the way that that go-to that computed go-to based interpreter works using tail calls. So kind of like I described for recursion, it's reusing the stack frame as an optimization. So modern compilers like Clang and GCC can do tail call optimizations optimistically, but until recently they weren't 100% guaranteed. You know, like some compilers have that level like -01, -02, like you put it up too high and stuff starts to break, you're like, "Huh, that's weird." You think that would just work, but right. And I think that's kind of the case is here. And apparently it's more stable so they can rely on it. So basically there's this new interpreter.

00:09:41.040 --> 00:10:10.220
And as the article points out, like it might seem crazy to add a third interpreter to Python, and it seems like a lot of work, right? But if you go down to the bottom, it says somewhere that Jin's change is only about 200 lines of Python code, which generates the interpreter and generates the code for the tail calling version. So it's actually not very much effort at all. So what it does is it'll say like, does your compiler support this faster version of behaviors? If it does, we'll give you a faster Python.

00:10:10.500 --> 00:10:11.280
I think that's pretty awesome.

00:10:11.810 --> 00:10:11.900
>>

00:10:11.900 --> 00:10:14.680
Yeah. I think.

00:10:14.910 --> 00:10:15.420
>> Yeah, I think so.

00:10:15.420 --> 00:10:15.760
>> If it works.

00:10:16.450 --> 00:10:22.020
>> Yeah, as long as it works. So this is already merged into Python 3.14, which is pretty excellent.

00:10:22.100 --> 00:10:29.740
It does say, look, if you're on an older build of Python, or you're building Python yourself with an old compiler, you're going to get the slow version.

00:10:29.860 --> 00:10:38.140
Like, okay, if you care about faster Python, compile it with modern compilers or download one with a binary.

00:10:38.360 --> 00:10:41.240
I bet you uv is already on top of this, you know what I mean?

00:10:41.640 --> 00:10:41.840
So

00:10:41.840 --> 00:10:43.840
3.14 already has this in it?

00:10:44.160 --> 00:10:44.680
That's what it says.

00:10:45.100 --> 00:10:45.620
Okay, cool.

00:10:45.760 --> 00:10:46.880
It says merged.

00:10:47.400 --> 00:10:51.100
Jin's work has been merged and should be available to end users in Python 3.14.

00:10:51.440 --> 00:10:54.120
Expected Halloween 2025.

00:10:54.640 --> 00:11:06.740
But what's really interesting here is Jin measured the performance impact of the change as a 10% on average, but up to 40% on some benchmark speed improvement, and then framed it this way, which I thought was really interesting.

00:11:06.920 --> 00:11:11.620
the speedup is roughly equal to two CPython releases worth of improvements.

00:11:12.020 --> 00:11:17.020
So like 3.11 to 3.13 in this just 200 lines of Python code, which is amazing.

00:11:17.200 --> 00:11:17.460
>> That's pretty cool.

00:11:17.460 --> 00:11:21.540
>> For example, CPython 3.12 roughly sped up by 5%.

00:11:22.140 --> 00:11:23.960
So, year over year sort of thing.

00:11:24.120 --> 00:11:28.700
So just this one change in 3.14 is going to be pretty mega.

00:11:28.860 --> 00:11:29.260
It's awesome.

00:11:29.380 --> 00:11:29.520
>>

00:11:29.520 --> 00:11:29.920
Yeah.

00:11:30.320 --> 00:11:31.740
Yeah, no, this is really cool.

00:11:33.000 --> 00:11:39.440
When I first heard about this, I was excited that maybe we get tail recursion optimization in Python, but we don't.

00:11:40.440 --> 00:11:41.060
I'm okay

00:11:41.060 --> 00:11:42.700
without it. It would be good to have.

00:11:43.820 --> 00:11:46.360
But let's not encourage them. Now, I use recursion sometimes.

00:11:46.930 --> 00:11:50.680
Look, if you've got hierarchical data structures, recursion is magical, right?

00:11:50.720 --> 00:11:55.080
It's like it exactly matches what you do with that hierarchy as you kind of traverse it.

00:11:55.720 --> 00:12:02.580
But in life, though, I think I've only used recursion and tail optimization in college.

00:12:04.299 --> 00:12:04.699
But

00:12:04.699 --> 00:12:05.100
I

00:12:05.100 --> 00:12:08.660
don't do sort of, because I don't do recursive sort of things very much.

00:12:08.800 --> 00:12:09.540
But that's all right.

00:12:09.720 --> 00:12:10.060
>> Yeah, yeah.

00:12:10.340 --> 00:12:18.060
Andrew out there points out, "I was overly excited to see this when I first saw these headlines thinking Python itself was getting tail call optimization.

00:12:18.880 --> 00:12:24.980
Very nice nonetheless going to motivate me to get Clang builds working with the required options." Yeah, absolutely cool.

00:12:25.060 --> 00:12:30.360
Like I said, I hope the uv folks are on this because uv venv and we just get 10% faster.

00:12:30.740 --> 00:12:31.240
Like let's go.

00:12:31.840 --> 00:12:41.900
>> Well, yeah, and actually I think that because of UV, we're getting more people trying new versions of Python faster because all you have to do is create a virtual environment and pick it.

00:12:41.910 --> 00:12:42.060
>> Yeah.

00:12:42.060 --> 00:12:42.520
>> And you get it.

00:12:42.520 --> 00:12:42.540
>>

00:12:42.540 --> 00:12:46.600
--Python 3.14B or whatever, however you specify it.

00:12:46.620 --> 00:12:47.180
>> Yeah.

00:12:47.390 --> 00:12:48.120
>> Absolutely.

00:12:48.440 --> 00:12:48.840
All

00:12:48.840 --> 00:12:49.300
right, back to you.

00:12:50.300 --> 00:12:52.020
>> Okay. Well, let's see.

00:12:52.440 --> 00:12:54.760
We've got something from Rodrigo.

00:12:55.439 --> 00:13:00.000
Rodrigo and I'm, anyway, Rodrigo from MathsPP.

00:13:00.360 --> 00:13:01.820
Math, that's okay.

00:13:02.380 --> 00:13:03.500
I'm gonna have to work on this one.

00:13:03.680 --> 00:13:05.480
But he puts out a lot of great stuff.

00:13:05.580 --> 00:13:08.920
He's writing about Python and very active on Blue Sky.

00:13:10.320 --> 00:13:13.740
And I think I don't, maybe somehow I missed this.

00:13:13.860 --> 00:13:16.940
This is, he's using translate and make trans together.

00:13:16.980 --> 00:13:22.000
He said, "Don't use the method replace "to remove punctuation from a Python string.

00:13:22.440 --> 00:13:23.500
"Use translate instead.

00:13:24.140 --> 00:13:31.340
"It's much more efficient and more general." and his example, which I had to like parse a little bit to figure this out.

00:13:31.960 --> 00:13:37.680
So basically like his example of hello world with a comma and an exclamation point.

00:13:37.920 --> 00:13:40.440
We want to strip that all the punctuation out.

00:13:40.440 --> 00:13:41.060
How do you do that?

00:13:41.340 --> 00:13:51.140
Well, you can use make trans, which is translates from one string, like some things in a string to another set of characters in a string.

00:13:51.370 --> 00:13:54.240
It's kind of a weird function, but he's giving it nothing.

00:13:54.500 --> 00:13:56.580
So the translate from and to are empty.

00:13:57.540 --> 00:14:01.580
But he's also giving the third parameter is stuff to just strip out.

00:14:02.240 --> 00:14:13.280
The way make trans does that is it translates a takes all of the characters in the third argument and replaces them with none, and those just end up getting removed.

00:14:13.600 --> 00:14:16.280
For the third character, he's using string.punctuation.

00:14:16.680 --> 00:14:27.060
He's creating a translation table that all it does is remove punctuation, and that's what we want, passing it to trans, and you get a string.

00:14:27.180 --> 00:14:34.940
And it still seems like maybe there should be an easier way in Python to do this, but that's pretty cool.

00:14:35.080 --> 00:14:35.600
I like it.

00:14:35.880 --> 00:14:47.640
So he also has an article that talks about not exactly this thing, but he's got an article about string translate and make trans methods if you want to dive deeper into those.

00:14:47.780 --> 00:14:49.320
Or you can just use this little trick.

00:14:49.640 --> 00:14:50.440
So-- Very interesting.

00:14:50.620 --> 00:14:51.200
News to me.

00:14:51.820 --> 00:14:52.960
It's a little bit like when

00:14:52.960 --> 00:15:00.060
I learned that strip, if I have like str, if I want to take str off of the word string and just leave ing, right?

00:15:00.380 --> 00:15:12.420
If you say L strip and you put the string str in there, I always thought it would find that string and take it out, but no, that just takes the S's and the T's and the R's, so R2S would also be right.

00:15:12.940 --> 00:15:15.860
So there's remove prefix and remove suffix and stuff like that.

00:15:15.920 --> 00:15:21.020
And this one's a little bit like that, like, huh, it didn't quite do what I thought, but I, apparently there's another way.

00:15:21.300 --> 00:15:34.920
>> Yeah. One of the interesting things about MakeTrans that always throws me is, it's an ordering thing, so you go from and to, and it utilizes the fact that strings are iterable.

00:15:35.420 --> 00:15:47.100
That's not something I normally think about unless I'm, I guess when I'm parsing stuff, when I'm parsing a file or parsing a line, I utilize the fact that they're iterable.

00:15:47.400 --> 00:15:51.180
But normally I don't iterate over characters of a string.

00:15:51.360 --> 00:15:54.820
That's seems like maybe that's too easy to get wrong.

00:15:55.100 --> 00:15:55.860
But anyway.

00:15:56.820 --> 00:15:57.600
>> Yeah, perhaps.

00:15:58.960 --> 00:16:01.680
>> All right. What you got for us next? Oh, we're done.

00:16:02.520 --> 00:16:05.060
>> Well, I got extra, extra, extra, extra.

00:16:05.600 --> 00:16:06.800
>> Extra, lots of extras.

00:16:07.060 --> 00:16:09.620
Yeah, because we had some short topics.

00:16:09.820 --> 00:16:10.900
So let's get some

00:16:10.900 --> 00:16:12.160
extras.

00:16:12.260 --> 00:16:16.720
>> So first of all, this was sent in by several people including Owen Lamont.

00:16:16.800 --> 00:16:17.440
Thank you for that.

00:16:17.720 --> 00:16:22.060
And this is a nine minute video of animation versus coding.

00:16:22.300 --> 00:16:25.320
And it's the weirdest-- I don't even know what to make of it.

00:16:25.460 --> 00:16:27.900
It's an insane amount of work that these people put into it.

00:16:27.960 --> 00:16:30.540
I'll just play a little bit of it as we're talking, Brian.

00:16:30.630 --> 00:16:37.340
And so the idea here is it's like an animation of somebody writing code and seeing how it interacts.

00:16:37.920 --> 00:16:42.780
And then the computer comes alive, and there's a battle with the computer.

00:16:43.340 --> 00:16:46.440
The computer will fire up Turtle and all sorts of stuff.

00:16:46.480 --> 00:16:53.860
And it ends up in the end, like creating AIs to run around and doing all sorts of stuff.

00:16:54.000 --> 00:17:00.260
And I think spoiler, I think the person character wins by like controlling the computer with AI.

00:17:00.400 --> 00:17:01.820
I'm not entirely sure the outcome.

00:17:01.820 --> 00:17:07.780
I totally forget, but it features pie game, pandas, pie torch.

00:17:08.000 --> 00:17:09.339
I mean, it's, it's nuts.

00:17:09.800 --> 00:17:13.180
So anyway, if you're looking for some entertainment, that's pretty cool.

00:17:13.180 --> 00:17:13.959
I got to watch that.

00:17:14.120 --> 00:17:15.180
It's a 10 minute video though.

00:17:15.819 --> 00:17:16.000
Yeah.

00:17:16.199 --> 00:17:16.439
Yeah.

00:17:16.870 --> 00:17:20.180
If you're eating lunch or something, you're like, I need a little break from programming.

00:17:20.260 --> 00:17:21.540
Let me watch a video about programming.

00:17:21.709 --> 00:17:22.240
I can do that.

00:17:22.540 --> 00:17:22.740
Yeah.

00:17:23.240 --> 00:17:23.420
All right.

00:17:23.740 --> 00:17:30.240
Next up in the news, I brought this up more as a parallel, as a other thing, other places are doing this too.

00:17:30.340 --> 00:17:30.460
Right?

00:17:30.840 --> 00:17:38.520
So one of the concerns and benefits of a lot of these new tools is they are written in Rust for Python, right?

00:17:38.780 --> 00:17:40.600
So why is uv fast?

00:17:41.220 --> 00:17:42.880
Mostly algorithms, but also Rust.

00:17:43.480 --> 00:17:44.300
Why is rough fast?

00:17:44.560 --> 00:17:46.480
Mostly Rust, probably also algorithms.

00:17:46.560 --> 00:17:47.100
You know what I mean?

00:17:47.160 --> 00:17:47.940
Like things like that.

00:17:48.040 --> 00:17:48.220
Right.

00:17:48.600 --> 00:17:54.440
why are we running our website on Granian, Rust, Hyper, all those sorts of things.

00:17:54.760 --> 00:18:05.380
So the folks over at TypeScript, Anders Halsberg, the creator of it and the Microsoft team just made TypeScript, which is a typed JavaScript thing.

00:18:05.700 --> 00:18:07.880
And I believe the runtime behind it as well.

00:18:07.900 --> 00:18:08.980
I think there's some kind of runtime.

00:18:09.000 --> 00:18:09.540
I haven't done

00:18:09.540 --> 00:18:10.220
much

00:18:10.220 --> 00:18:17.860
with TypeScript that way, but certainly like it's compiler and it's language LSP for editors and stuff like that.

00:18:18.100 --> 00:18:20.520
10 times faster by rewriting it in Go.

00:18:20.790 --> 00:18:21.580
>> Oh, geez.

00:18:21.830 --> 00:18:25.060
>> That's interesting. They said, "Look, we tried a bunch of different languages.

00:18:25.240 --> 00:18:31.300
We tried Rust, we tried C, we tried Go, we tried, I think, Zig." They mentioned a lot of languages.

00:18:31.960 --> 00:18:43.400
They said, "Look, Go allows us to align the memory stuff as you do in native languages." Like align the memory structures exactly write for the compiler and stuff like that or something.

00:18:43.600 --> 00:18:48.080
So anyway, I know a lot of people listening also do JavaScript and TypeScript stuff.

00:18:48.140 --> 00:18:51.560
And I think it's, you know, here's another 10 minute video to watch.

00:18:51.640 --> 00:18:52.480
That's kind of interesting.

00:18:52.620 --> 00:18:54.100
I think 13 minutes technically.

00:18:54.240 --> 00:18:55.560
But so that's like the drop loss.

00:18:56.320 --> 00:18:59.320
Everything that uses TypeScript would be faster then or.

00:19:00.040 --> 00:19:00.760
So that's what I'm not.

00:19:01.160 --> 00:19:05.780
There is some kind of runtime that they're doing something with that they rewrote.

00:19:06.160 --> 00:19:09.620
Like TypeScript used to compile itself with TypeScript.

00:19:09.720 --> 00:19:13.280
But there's also something that runs that does the language server.

00:19:13.310 --> 00:19:17.920
I feel like it's a little like node, but like I said, this is far, I'm far out over my skis at this point.

00:19:17.980 --> 00:19:22.320
I think when you talk about stuff that runs it, mostly that's in the browser.

00:19:22.580 --> 00:19:24.740
And then that's going to be just the JavaScript engine.

00:19:24.880 --> 00:19:32.860
Cause the now Go-based transpiler compiler will compile the JavaScript and then it's run natively, natively, you know, anyway, pretty interesting.

00:19:32.890 --> 00:19:33.860
I thought it was worth throwing out there.

00:19:33.960 --> 00:19:36.940
Cause it's like, Oh, Python's getting overrun by Rust.

00:19:37.040 --> 00:19:38.340
What's what in the world's going on?

00:19:38.340 --> 00:19:41.600
I'm like, this is a trend of more places, not just Python.

00:19:41.790 --> 00:19:43.060
That's what I kind of want to point out here.

00:19:43.780 --> 00:19:47.120
They made different choices for different reasons, but it's still pretty interesting.

00:19:47.420 --> 00:19:47.700
Okay.

00:19:47.700 --> 00:19:48.660
Thanks for showing me that YouTube.

00:19:48.840 --> 00:19:49.100
All right.

00:19:49.600 --> 00:19:52.780
I, this next section I entitled Firefox lies.

00:19:53.260 --> 00:19:54.940
So Brian, it's very exciting.

00:19:55.120 --> 00:20:00.520
This weekend was the first formula one race of the year, and they've going to have something like 23 more.

00:20:00.920 --> 00:20:01.180
Very good.

00:20:01.200 --> 00:20:02.240
And it was amazing.

00:20:02.250 --> 00:20:07.500
If you haven't watched it, I won't spoil it, but it's, it was one of the best formula one races I've watched in a very long time.

00:20:07.500 --> 00:20:09.900
It was full of drama, full of interesting things.

00:20:10.140 --> 00:20:10.500
It was good.

00:20:10.740 --> 00:20:12.760
And this, so what does this have to do with Firefox?

00:20:13.200 --> 00:20:14.160
So I tried to watch it.

00:20:14.840 --> 00:20:31.360
I subscribed to F1 TV so that I can watch all the, all the races, all the replays, all the qualifying, all that kind of stuff, instead of getting cable, which is a complete rip off, you know, pay 200 bucks a month, I paid like 80 bucks once and I watch all those with replays and whatever, right.

00:20:31.600 --> 00:20:33.840
I tried to watch that with Firefox.

00:20:34.700 --> 00:20:35.360
Do you know what it said?

00:20:35.660 --> 00:20:37.880
Your browser is out of date and unsupported.

00:20:38.240 --> 00:20:39.740
You cannot watch this website.

00:20:40.480 --> 00:20:42.780
You must go away because you don't have Chrome basically.

00:20:43.280 --> 00:20:45.520
And I said, huh, I seriously doubt it.

00:20:45.780 --> 00:20:48.340
I seriously doubt that Firefox won't work.

00:20:49.040 --> 00:20:50.060
FUF1 I said,

00:20:50.280 --> 00:20:51.860
and

00:20:51.860 --> 00:20:54.420
I said, no, we're doing it.

00:20:54.560 --> 00:21:00.180
We're watching it in Firefox because I have all this blocking turned on in my other favorite browser, Vivaldi.

00:21:00.640 --> 00:21:00.800
Right.

00:21:01.160 --> 00:21:03.480
And I don't want to turn off the blocking and stuff.

00:21:03.580 --> 00:21:12.760
So I have like kind of my bare Firefox is the one that allows all the badness through so I can watch stuff that, you know, Peacock and F1 and so on.

00:21:13.020 --> 00:21:15.800
So when they say you can't watch them, like, no, I can watch it.

00:21:16.080 --> 00:21:23.880
So what I did is I put the link, I'll link to how you do this, but I just went up and just told Firefox it's user agent is the latest version of Chrome.

00:21:24.940 --> 00:21:25.880
Hence Firefox lies.

00:21:26.340 --> 00:21:26.880
Went back.

00:21:27.260 --> 00:21:29.460
I went back to, F1 TV.

00:21:30.080 --> 00:21:30.380
Welcome.

00:21:30.920 --> 00:21:32.860
Which, which replay would you like to watch?

00:21:33.200 --> 00:21:33.260
Boom.

00:21:33.340 --> 00:21:33.620
Perfect.

00:21:34.020 --> 00:21:34.660
Played perfectly.

00:21:34.720 --> 00:21:36.140
There's nothing wrong with Firefox.

00:21:36.530 --> 00:21:38.980
The people are just too lazy to test against it.

00:21:39.240 --> 00:21:41.340
And so they're like, well, you got to have Chrome.

00:21:41.520 --> 00:21:41.960
Like, all right, fine.

00:21:41.960 --> 00:21:42.380
I have Chrome.

00:21:42.540 --> 00:21:43.420
Oh, look, it works.

00:21:43.760 --> 00:21:45.460
This is the same reason that Vivaldi works.

00:21:45.640 --> 00:21:50.580
Vivaldi, you cannot know like the market share of Vivaldi per user agent.

00:21:50.720 --> 00:21:54.100
Like, some of those sites that track user agent frequency and stuff.

00:21:54.380 --> 00:21:54.520
Yeah.

00:21:54.550 --> 00:21:56.840
They just, because they just say the same thing.

00:21:56.840 --> 00:21:59.120
They just say my user agent is the latest version of Chrome.

00:21:59.580 --> 00:22:05.060
So that it works because if everybody had to also say, we also support Vivaldi, It would say crap like that all the time.

00:22:05.360 --> 00:22:05.480
- Yeah.

00:22:05.640 --> 00:22:13.420
- And so if you love Firefox or any other browser really, but I have instructions for Firefox and you run into those problems, just make it lie.

00:22:13.720 --> 00:22:16.040
I'm really, really loving Zen.

00:22:16.200 --> 00:22:21.300
We talked about that a few times and I'm considering making my Zen claim to be the latest Chrome as well.

00:22:23.080 --> 00:22:34.600
- Yeah, that's one of the reasons why I like Vivaldi as well, because especially in corporations, a lot of internal tools, they don't wanna, I mean, that's a lot of work for internal tools to test everything.

00:22:35.280 --> 00:22:37.080
So they just usually test against Chrome.

00:22:37.360 --> 00:22:41.080
And so with Vivaldi, I can just use internal tools just fine.

00:22:41.520 --> 00:22:42.420
- Yeah, it's indistinguishable.

00:22:42.520 --> 00:22:43.000
It doesn't know.

00:22:44.300 --> 00:22:45.240
Why wouldn't it be?

00:22:45.380 --> 00:22:48.020
It's literally the same embedded engine in the terms of Vivaldi.

00:22:48.120 --> 00:22:49.120
It literally is Chrome.

00:22:49.160 --> 00:22:51.820
It just doesn't have all this scumbaggery to it.

00:22:51.840 --> 00:22:52.100
- Yeah.

00:22:52.760 --> 00:22:53.240
- Yeah, all right.

00:22:53.480 --> 00:22:54.780
This is extra, it's getting long, real quick.

00:22:54.840 --> 00:22:55.600
All right, Startup Row.

00:22:56.160 --> 00:22:58.140
Startup Row applications are open.

00:22:58.420 --> 00:23:01.000
Does your startup qualify for Startup Row?

00:23:01.080 --> 00:23:01.860
Here's some criteria.

00:23:02.180 --> 00:23:02.640
Use Python.

00:23:02.940 --> 00:23:05.660
Your startup is less than 2.5 years old.

00:23:05.770 --> 00:23:10.060
You have less than 25, fewer than 25 employees, et cetera, et cetera.

00:23:10.540 --> 00:23:12.960
You will come to the conference and so on.

00:23:13.220 --> 00:23:14.300
This is a really cool program.

00:23:14.640 --> 00:23:17.940
And if you have a startup and you want to get some awareness, consider applying to this.

00:23:18.260 --> 00:23:18.780
So this is,

00:23:19.020 --> 00:23:21.540
this is at PyCon on Sundays.

00:23:23.160 --> 00:23:26.980
There's there's a, they, they take away all of the booths and everything like that.

00:23:27.020 --> 00:23:30.120
And then we have, we have a couple of rows of startups that you

00:23:30.120 --> 00:23:30.200
can.

00:23:30.340 --> 00:23:30.540
Yes.

00:23:30.600 --> 00:23:32.920
I think it even might be Thursday through Saturday.

00:23:33.460 --> 00:23:34.940
I think it might be during the expo.

00:23:35.160 --> 00:23:35.900
Oh, during the expo.

00:23:36.000 --> 00:23:39.440
It was in a corner, it was in a corner, but it was, I think it was during the expo.

00:23:39.440 --> 00:23:39.800
Oh, right.

00:23:39.920 --> 00:23:40.120
Yeah.

00:23:40.240 --> 00:23:40.300
Yeah.

00:23:40.340 --> 00:23:40.460
Yeah.

00:23:40.520 --> 00:23:49.240
You basically get a booth as like a $10,000 equivalent booth as if you were another advertiser there, but it's to promote your Python based startup.

00:23:49.460 --> 00:23:50.440
So people should check that out.

00:23:50.700 --> 00:24:01.680
I actually did an interview two years ago, coming up on two years ago, called a stroll down startup lane, where I went and interviewed all the people, all the different startups, like 10 minutes per startup or something like that.

00:24:01.920 --> 00:24:02.240
Nice.

00:24:02.580 --> 00:24:02.740
Yeah.

00:24:03.040 --> 00:24:04.820
Ooh, last, last of the extras.

00:24:05.480 --> 00:24:07.220
I am publishing a book, Brian.

00:24:07.580 --> 00:24:08.000
Wow.

00:24:08.340 --> 00:24:08.680
Neat.

00:24:09.100 --> 00:24:09.340
Yeah.

00:24:09.380 --> 00:24:09.620
Thanks.

00:24:09.820 --> 00:24:11.100
Talk Python in production.

00:24:11.560 --> 00:24:16.820
So the subtitle is a cloud agnostic guide to building, scaling, and managing your own Python infrastructure.

00:24:17.200 --> 00:24:23.040
So I've talked a lot about different ways we're doing different things with infrastructure, but here's a book, it's about 250 pages.

00:24:23.320 --> 00:24:31.880
That goes into all the details of like how you can run efficient, high performance, but not complex, not expensive Python infrastructure.

00:24:32.600 --> 00:24:36.700
And you can buy, you can read about the first third of it online.

00:24:37.040 --> 00:24:40.940
And it says buy the book, but you can't quite buy the book just today.

00:24:41.040 --> 00:24:43.520
I'm still trying to get it all ready to go.

00:24:43.960 --> 00:24:47.260
So right now you can subscribe to get notified when you can buy the book.

00:24:47.440 --> 00:24:51.980
And in a week or two, you will be able to buy the book at Amazon and probably Gumroad is what I'm thinking.

00:24:52.320 --> 00:24:52.420
Okay.

00:24:52.680 --> 00:24:53.200
I like Gumroad.

00:24:53.660 --> 00:24:53.840
Yeah.

00:24:54.060 --> 00:24:54.300
Anyway.

00:24:54.520 --> 00:24:57.140
So the link to that is in the show notes

00:24:57.140 --> 00:24:57.840
and

00:24:57.840 --> 00:24:59.340
hopefully people will check that out.

00:24:59.520 --> 00:24:59.720
Cool.

00:25:00.040 --> 00:25:00.160
Yeah.

00:25:00.420 --> 00:25:00.640
All right.

00:25:00.680 --> 00:25:01.620
That's it for my extras.

00:25:01.940 --> 00:25:03.080
You got any extra extras?

00:25:04.040 --> 00:25:11.020
No, I wanted to announce the changes to the course, but I, but I'm still working on it, life getting in

00:25:11.020 --> 00:25:11.260
the way.

00:25:11.600 --> 00:25:12.680
So yeah, I hear you.

00:25:12.920 --> 00:25:16.500
Well, until then people don't necessarily have to test, right.

00:25:16.560 --> 00:25:17.620
They don't need work on your testing.

00:25:17.720 --> 00:25:18.540
Yes, they do.

00:25:18.840 --> 00:25:18.940
Yeah.

00:25:19.000 --> 00:25:20.860
No, they can just test in production.

00:25:22.240 --> 00:25:23.720
So the joke is a Star Trek one.

00:25:23.720 --> 00:25:26.420
This comes to us by Greg Matiola.

00:25:26.830 --> 00:25:27.040
Thank you.

00:25:27.060 --> 00:25:32.060
It says, as Goron says, we will test in production and die with glorious honor.

00:25:32.150 --> 00:25:36.060
And it's got like a cool little meme over a Star Trek Klingon character.

00:25:36.480 --> 00:25:36.700
Yeah.

00:25:37.320 --> 00:25:37.560
Yeah.

00:25:37.900 --> 00:25:40.620
But it's usually your customers that will die in glorious honor.

00:25:41.500 --> 00:25:41.940
They

00:25:41.940 --> 00:25:43.420
die first and then you wither.

00:25:45.140 --> 00:25:45.480
Yeah.

00:25:45.900 --> 00:25:46.080
Okay.

00:25:46.420 --> 00:25:46.600
Yeah.

00:25:47.640 --> 00:25:51.140
So you, what I'm hearing is you're saying you don't actually support this advice.

00:25:51.300 --> 00:25:52.040
I don't.

00:25:52.480 --> 00:25:59.060
But I, but there is a certain car company that seems to have pieces of their cars flying off.

00:25:59.700 --> 00:26:01.860
I think, does it look a little like a spaceship?

00:26:02.180 --> 00:26:02.720
Yeah, it does.

00:26:02.720 --> 00:26:07.380
And apparently they just glued some of the stuff onto the side is some of this.

00:26:07.660 --> 00:26:07.840
Anyway,

00:26:07.940 --> 00:26:09.240
you

00:26:09.240 --> 00:26:10.940
know, I was, in

00:26:10.940 --> 00:26:18.140
Nashville with my kids the last summer and we were driving along and our rental car, which was not one of these spaceship.

00:26:18.240 --> 00:26:45.660
things. The, the, there was apparently a, the thing that goes on the column has like a fancy cover, like a bodywork. Yeah. The, the columns that hold up the roof and along the windshield. And it just peeled back, ripped off and started whacking against the car on the highway. And this was on our way to the airport. So one of my kids had to reach out and hold, hold the body work in place for about 15 minutes. And she was, she was kind of done holding the bodywork in place. So we got to to the airport.

00:26:46.080 --> 00:26:47.080
- That's crazy.

00:26:47.440 --> 00:26:49.040
- So bad, so bad.

00:26:49.240 --> 00:26:52.900
- Did you get charged for the damage to the car?

00:26:53.440 --> 00:26:55.100
- No, I kinda like mushed it back.

00:26:55.100 --> 00:26:57.780
I said, "How's the car?" It was fine, that piece is a little bit loose.

00:26:57.840 --> 00:26:58.800
You might wanna check it, bye.

00:26:59.260 --> 00:26:59.460
- Bye.

00:27:00.080 --> 00:27:00.480
(laughing)

00:27:01.760 --> 00:27:02.160
Yeah.

00:27:03.080 --> 00:27:03.740
- No, it was okay.

00:27:04.460 --> 00:27:04.860
- Anyway.

00:27:05.180 --> 00:27:06.740
- Anyway, yeah, test in production.

00:27:07.220 --> 00:27:08.100
- Test in production.

00:27:08.580 --> 00:27:09.840
No, don't put test in production.

00:27:09.980 --> 00:27:11.080
Test before production.

00:27:11.400 --> 00:27:11.740
- Absolutely.

00:27:12.520 --> 00:27:15.100
But do, do listen to the show every week.

00:27:15.200 --> 00:27:18.140
We'll be back next Monday at 10, probably, most likely.

00:27:18.500 --> 00:27:19.020
- Tell your friends.

00:27:19.480 --> 00:27:21.700
- Until then, thank you everyone, bye.

00:27:21.980 --> 00:27:22.160
- Bye.

