
00:00:00.000 --> 00:00:01.800
Hey there, thanks for listening.


00:00:01.800 --> 00:00:05.060
Before we jump into this episode, I just want to remind you that this episode is brought


00:00:05.060 --> 00:00:10.120
to you by us over at TalkBython Training and Brian through his pytest book.


00:00:10.120 --> 00:00:15.220
So if you want to get hands on and learn something with Python, be sure to consider our courses


00:00:15.220 --> 00:00:16.980
over at TalkBython Training.


00:00:16.980 --> 00:00:20.560
Visit them via pythonbytes.fm/courses.


00:00:20.560 --> 00:00:24.940
And if you're looking to do testing and get better with pytest, check out Brian's book


00:00:24.940 --> 00:00:27.860
at pythonbytes.fm/pytest.


00:00:27.860 --> 00:00:28.860
Enjoy the episode.


00:00:28.860 --> 00:00:34.060
Welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.


00:00:34.060 --> 00:00:41.180
This is episode 245, so it's not the first time. Recorded August 4th, 2021. I'm Brian Okken.


00:00:41.180 --> 00:00:42.300
I'm Michael Kennedy.


00:00:42.300 --> 00:00:42.860
I'm Juanpe.


00:00:42.860 --> 00:00:49.340
So Juanpe, thanks so much for coming on the show. Can you introduce yourself a little bit


00:00:49.340 --> 00:00:50.460
before we get into it?


00:00:50.460 --> 00:00:56.700
Thank you very much for having me. So my name is Juanpe. I'm from Spain, and my PhD in particle


00:00:56.700 --> 00:00:59.580
of Physics, I've been working at CERN for four years.


00:00:59.580 --> 00:01:01.900
Then two years after my PhD finished,


00:01:01.900 --> 00:01:04.820
I decided to step away from academia


00:01:04.820 --> 00:01:06.140
and start working in industry.


00:01:06.140 --> 00:01:08.100
And right now I'm working at FinancialForce,


00:01:08.100 --> 00:01:11.380
which is a company that develops products for Salesforce.


00:01:11.380 --> 00:01:14.460
So I'm not developing products, I'm in the analytics team.


00:01:14.460 --> 00:01:17.180
So my job is to analyze internal data,


00:01:17.180 --> 00:01:20.620
as well as usage, product usage from a customer


00:01:20.620 --> 00:01:23.540
to allow the board to take data-driven decisions


00:01:23.540 --> 00:01:25.380
on how the company should go forward.


00:01:25.380 --> 00:01:27.260
- Nice. - Yeah, super interesting.


00:01:27.260 --> 00:01:29.760
Give us your thoughts real quick on one hand,


00:01:29.760 --> 00:01:31.360
working for a place like CERN,


00:01:31.360 --> 00:01:32.720
and then the other working on a place


00:01:32.720 --> 00:01:36.040
that provides enhancements to Salesforce.


00:01:36.040 --> 00:01:37.120
Like those sounds so different.


00:01:37.120 --> 00:01:39.320
Are they really that different or are they similar


00:01:39.320 --> 00:01:40.380
or what's the story?


00:01:40.380 --> 00:01:42.200
- Part, I mean, of course they're different,


00:01:42.200 --> 00:01:45.440
but there is a big part which is very much the same,


00:01:45.440 --> 00:01:47.520
at least in the team that I'm working on.


00:01:47.520 --> 00:01:49.960
Because at CERN, basically what you do


00:01:49.960 --> 00:01:51.760
is you don't know the answer to anything


00:01:51.760 --> 00:01:54.440
and you need to first know what you need to ask yourself.


00:01:54.440 --> 00:01:57.840
And this is very similar to what happens today


00:01:57.840 --> 00:02:00.400
in my current job, because for instance,


00:02:00.400 --> 00:02:04.840
marketing come and say, we have this whatever campaign


00:02:04.840 --> 00:02:07.000
and we want to know if we are targeting right.


00:02:07.000 --> 00:02:10.000
And I need to know what do I need to do


00:02:10.000 --> 00:02:12.960
to answer that question, but neither marketing knows.


00:02:12.960 --> 00:02:15.820
So it's like, let's figure things out.


00:02:15.820 --> 00:02:19.200
But yeah, I mean, it's a pretty drastic change,


00:02:19.200 --> 00:02:21.600
but I don't know, I got the feeling


00:02:21.600 --> 00:02:23.160
that I needed to switch.


00:02:23.160 --> 00:02:26.160
I like coding a lot and I felt at some point


00:02:26.160 --> 00:02:28.760
that I was enjoying more the coding part


00:02:28.760 --> 00:02:31.320
of being a physicist than the physics part.


00:02:31.320 --> 00:02:32.160
So I said, I mean--


00:02:32.160 --> 00:02:33.680
- I mean, you basically described


00:02:33.680 --> 00:02:35.120
why I'm not in math anymore.


00:02:35.120 --> 00:02:37.960
(laughing)


00:02:37.960 --> 00:02:38.800
- Yeah.


00:02:38.800 --> 00:02:41.000
- I was working on projects and I was having so much fun


00:02:41.000 --> 00:02:42.960
and writing code on these Silicon graphics,


00:02:42.960 --> 00:02:44.520
like huge computers and stuff.


00:02:44.520 --> 00:02:46.280
And then there'd be parts where I'd be like,


00:02:46.280 --> 00:02:47.680
"Ah, this part's not so fun.


00:02:47.680 --> 00:02:48.620
This part's amazing."


00:02:48.620 --> 00:02:50.480
And I realized the programming parts were amazing.


00:02:50.480 --> 00:02:52.400
And then when it had to get down to solving the math bits,


00:02:52.400 --> 00:02:54.800
I'm like, "Ah, darn, gotta put it away.


00:02:54.800 --> 00:02:56.160
"Go work on the math again."


00:02:56.160 --> 00:02:58.180
- I mean, I remember the last year and a half


00:02:58.180 --> 00:03:00.000
I was working on a project that was literally


00:03:00.000 --> 00:03:04.400
designing a system that worked within GitLab CI


00:03:04.400 --> 00:03:08.180
to automate paper review and publishing.


00:03:08.180 --> 00:03:10.760
So you don't need to have a lot of people


00:03:10.760 --> 00:03:13.880
reading the paper and say, "Oh, this rule is not matched


00:03:13.880 --> 00:03:15.560
"or you need to fix this image."


00:03:15.560 --> 00:03:17.780
So I built an entire pipeline in Python


00:03:17.780 --> 00:03:20.720
to check all of this that works based on pull requests


00:03:20.720 --> 00:03:22.560
and groups and so on in GitLab CI.


00:03:22.560 --> 00:03:25.160
And I thought, I've been a year and a half


00:03:25.160 --> 00:03:26.560
not doing almost any physics.


00:03:26.560 --> 00:03:29.920
So my physics work, it was related to review paper


00:03:29.920 --> 00:03:32.160
because I was a chair of an editorial board.


00:03:32.160 --> 00:03:34.200
So I had an analysis, it was pretty cool,


00:03:34.200 --> 00:03:36.240
but I wasn't doing it.


00:03:36.240 --> 00:03:38.520
I received version, reviewed them, made comment,


00:03:38.520 --> 00:03:39.760
fixed this, fixed that,


00:03:39.760 --> 00:03:43.000
then go back to write a pipeline to make the pipeline.


00:03:43.000 --> 00:03:44.760
- Yeah, exactly.


00:03:44.760 --> 00:03:45.880
Yeah, it sounds really cool.


00:03:45.880 --> 00:03:47.680
- To Brown. - Yeah, go ahead.


00:03:47.680 --> 00:03:49.040
- Will you kick us off today?


00:03:49.040 --> 00:03:50.880
- Will, you wanna hear about the state


00:03:50.880 --> 00:03:52.800
of the developer world?


00:03:52.800 --> 00:03:53.640
How's that sound?


00:03:53.640 --> 00:03:54.460
- I like state.


00:03:54.460 --> 00:03:55.300
- Yeah, yeah.


00:03:55.300 --> 00:03:58.400
So here's an interesting survey results, I guess,


00:03:58.400 --> 00:03:59.600
put together by JetBrains,


00:03:59.600 --> 00:04:02.360
the state of the developer ecosystem 2021.


00:04:02.360 --> 00:04:03.880
And I thought this would be fun to talk about


00:04:03.880 --> 00:04:08.880
because we do cover like the PSF state of Python survey


00:04:08.880 --> 00:04:11.000
and things like that.


00:04:11.000 --> 00:04:12.760
But I thought it'd be fun to just have a quick look


00:04:12.760 --> 00:04:15.960
at the broader landscape, what people are doing


00:04:15.960 --> 00:04:17.440
and where Python fits into that.


00:04:17.440 --> 00:04:20.780
JetBrains has done a really good job with a PSF survey.


00:04:20.780 --> 00:04:22.860
So I thought, you know, this will be similar.


00:04:22.860 --> 00:04:23.940
So let's check that out.


00:04:23.940 --> 00:04:27.120
So let me give you some stats and some rundown on this.


00:04:27.120 --> 00:04:30.120
So basically the idea is it presents the results


00:04:30.120 --> 00:04:33.200
of the fifth annual developer ecosystem survey


00:04:33.200 --> 00:04:36.240
conducted by JetBrains, and it went out to 31,000


00:04:36.240 --> 00:04:39.080
or had input from 31,000, 32,000 people.


00:04:39.080 --> 00:04:41.620
All right, so there's a couple of interesting things


00:04:41.620 --> 00:04:42.800
they're doing in the presentation here,


00:04:42.800 --> 00:04:45.000
but let's say in that world,


00:04:45.000 --> 00:04:47.300
JavaScript is still the most popular language.


00:04:47.300 --> 00:04:50.980
Not a few as stack overflow, but of those 32,000 people or whatever,


00:04:50.980 --> 00:04:54.060
Python's more popular than Java overall.


00:04:54.060 --> 00:04:58.780
However, Java is used more as the main language.


00:04:58.780 --> 00:05:03.540
So there's more people using Python for extra things or for other things and so


00:05:03.540 --> 00:05:06.980
on, which I think that jives pretty well with my understanding of Python is that


00:05:06.980 --> 00:05:10.860
it's this really amazing way to like bring in a little interactivity, bring


00:05:10.860 --> 00:05:13.720
and a little bit of analysis, a little Jupyter notebook


00:05:13.720 --> 00:05:16.940
or something, even if it's not your main focus, right?


00:05:16.940 --> 00:05:19.500
You might be an economist, you're not even a programmer,


00:05:19.500 --> 00:05:21.560
but you're still a Python person in a sense,


00:05:21.560 --> 00:05:23.980
whereas you probably wouldn't be a Java person


00:05:23.980 --> 00:05:25.620
as an economist most of the time.


00:05:25.620 --> 00:05:28.560
- Yeah, I use Python for testing.


00:05:28.560 --> 00:05:29.920
- Yeah, for sure.


00:05:29.920 --> 00:05:33.080
So let's see, the top five languages


00:05:33.080 --> 00:05:35.420
that developers are planning to adopt


00:05:35.420 --> 00:05:38.820
are Go, Kotlin, TypeScript, Python, and Rust.


00:05:38.820 --> 00:05:42.780
And the fastest growing languages are Python, TypeScript, Kotlin, SQL, and Go.


00:05:42.780 --> 00:05:47.400
So for example, JavaScript, was the most popular language.


00:05:47.400 --> 00:05:50.580
Java was the most popular main language, but it's, they're neither


00:05:50.580 --> 00:05:51.780
the fastest growing language.


00:05:51.780 --> 00:05:54.600
So that's pretty much a pretty interesting of this group.


00:05:54.600 --> 00:06:01.320
71% people work on some sort of web backend APIs, Flask apps,


00:06:01.320 --> 00:06:02.860
or, you know, Go apps or whatever.


00:06:02.860 --> 00:06:07.040
So they have a lot of interesting stuff here in terms of analysis.


00:06:07.040 --> 00:06:10.480
So they have these blocks that show how popular a language is,


00:06:10.480 --> 00:06:15.480
it's been used, or how likely people are to adopt it


00:06:15.480 --> 00:06:16.320
and pick it up.


00:06:16.320 --> 00:06:18.520
So there's a bunch of grids if you go to the report


00:06:18.520 --> 00:06:19.360
and you can check them out.


00:06:19.360 --> 00:06:22.660
And basically the orange is the current state of the world


00:06:22.660 --> 00:06:25.800
and there's a darker, almost black,


00:06:25.800 --> 00:06:27.160
that is like the derivative.


00:06:27.160 --> 00:06:31.400
Like how quickly is that world changing for the upswing?


00:06:31.400 --> 00:06:35.320
So for example, JavaScript has more orange squares,


00:06:35.320 --> 00:06:37.500
but it doesn't have as quick of a growth


00:06:37.500 --> 00:06:39.120
or a planned growth, I guess.


00:06:39.120 --> 00:06:41.460
So Python has one of the larger ones of those.


00:06:41.460 --> 00:06:43.220
So does TypeScript as well.


00:06:43.220 --> 00:06:44.640
And those are interesting to look into.


00:06:44.640 --> 00:06:46.380
You can compare those against different things.


00:06:46.380 --> 00:06:49.260
You can also see the popularity of the language over time.


00:06:49.260 --> 00:06:50.940
Python's been going up and up and up,


00:06:50.940 --> 00:06:53.820
although this year is kind of plateaued in this report.


00:06:53.820 --> 00:06:57.020
So that's maybe something worth noting.


00:06:57.020 --> 00:06:59.380
There's obvious things going down like Objective-C.


00:06:59.380 --> 00:07:01.900
You'd be insane to work on Objective-C right now


00:07:01.900 --> 00:07:04.180
when Swift is like replaced it,


00:07:04.180 --> 00:07:05.540
although that's going down as well.


00:07:05.540 --> 00:07:07.140
Let's see, there's a few more things.


00:07:07.140 --> 00:07:08.740
They have these really interesting graphs


00:07:08.740 --> 00:07:11.460
that are both like grids, but also heat map.


00:07:11.460 --> 00:07:13.460
So it'll let you answer questions like,


00:07:13.460 --> 00:07:16.740
okay, if I am currently a Swift developer,


00:07:16.740 --> 00:07:19.940
what is the likelihood that I'm going to adopt Python?


00:07:19.940 --> 00:07:20.740
6%.


00:07:20.740 --> 00:07:22.580
But if I'm a Kotlin developer,


00:07:22.580 --> 00:07:25.380
that's 8% likelihood that I'm going to adopt.


00:07:25.380 --> 00:07:27.540
Oh no, I'm going the wrong way.


00:07:27.540 --> 00:07:29.300
If I'm a Kotlin developer,


00:07:29.300 --> 00:07:33.300
I'm 10% likely to adopt, to move to Python and so on.


00:07:33.300 --> 00:07:36.640
So there's a lot of sort of like flow from one language to another.


00:07:36.640 --> 00:07:39.100
I haven't seen any analysis like this anywhere else.


00:07:39.100 --> 00:07:39.380
Have you?


00:07:39.380 --> 00:07:40.700
No, that's pretty interesting.


00:07:40.700 --> 00:07:42.820
My hands looking at correlation or something.


00:07:42.820 --> 00:07:43.840
What's the first row?


00:07:43.840 --> 00:07:44.500
I'm curious.


00:07:44.500 --> 00:07:46.140
Uh, I'm not planning on changing.


00:07:46.140 --> 00:07:48.420
So they are the most likely to change.


00:07:48.420 --> 00:07:50.300
Yeah.


00:07:50.300 --> 00:07:51.020
There's just stock.


00:07:51.020 --> 00:07:51.620
There's days.


00:07:51.620 --> 00:07:52.060
Yeah.


00:07:52.060 --> 00:07:52.860
All right.


00:07:52.860 --> 00:07:53.300
Let's see.


00:07:53.300 --> 00:07:56.740
Uh, also interesting operating systems people use for development.


00:07:56.740 --> 00:08:02.420
61% windows, 47% Linux, 44% Mac iOS, which that's pretty high for Mac OS given its


00:08:02.500 --> 00:08:06.540
general popularity amongst like the computing world, I think.


00:08:06.540 --> 00:08:09.060
Yeah, I think Linux is pretty high too.


00:08:09.060 --> 00:08:09.780
Yeah.


00:08:09.780 --> 00:08:10.780
This doesn't surprise me.


00:08:10.780 --> 00:08:11.940
Yeah, exactly.


00:08:11.940 --> 00:08:14.060
And then 1% other, who knows what that is?


00:08:14.060 --> 00:08:16.900
Also questions about people using the windows subsystem for


00:08:16.900 --> 00:08:19.060
Linux and stuff like that.


00:08:19.060 --> 00:08:23.180
Um, there's also, if you're interested, a similar heat map for like


00:08:23.180 --> 00:08:25.260
what type of software do you develop?


00:08:25.260 --> 00:08:30.340
So if you're trying to understand where, like if I develop this kind of software,


00:08:30.340 --> 00:08:33.620
what is the distribution for programming languages there, right?


00:08:33.620 --> 00:08:37.060
Like it's interesting to say Python is popular or JavaScript is popular,


00:08:37.060 --> 00:08:39.420
but if I'm an embedded system developer,


00:08:39.420 --> 00:08:41.160
is JavaScript still popular?


00:08:41.160 --> 00:08:42.620
I don't know. Probably not.


00:08:42.620 --> 00:08:44.220
Maybe, but maybe not.


00:08:44.220 --> 00:08:46.100
Maybe C is really popular.


00:08:46.100 --> 00:08:49.400
So there's a really cool thing called what types of software do you develop?


00:08:49.400 --> 00:08:53.160
There's like a grid plus heat map plus intersection of language and type.


00:08:53.160 --> 00:08:55.420
So if I develop security software,


00:08:55.420 --> 00:08:58.980
there's a nine percent chance that I would be doing


00:08:58.980 --> 00:09:02.340
Python versus a 6% chance of Java.


00:09:02.340 --> 00:09:04.020
On the other hand, if I do Blockchain,


00:09:04.020 --> 00:09:05.360
how does that break down and so on?


00:09:05.360 --> 00:09:09.500
Let's see where is Python notable on utility little scripts.


00:09:09.500 --> 00:09:11.820
It's quite popular there.


00:09:11.820 --> 00:09:16.460
Database backends, pretty popular in that area.


00:09:16.460 --> 00:09:19.500
See another one that maybe is standout,


00:09:19.500 --> 00:09:20.900
would be programming tools.


00:09:20.900 --> 00:09:23.180
Actually, that's pretty interesting and so on.


00:09:23.180 --> 00:09:24.500
What do you guys think of this?


00:09:24.500 --> 00:09:26.940
>> I think it's weird that there's 39 percent of


00:09:26.940 --> 00:09:29.580
the C++ developers are developing websites.


00:09:29.580 --> 00:09:30.420
What the heck?


00:09:30.420 --> 00:09:31.240
- Yeah.


00:09:31.240 --> 00:09:32.080
- Yeah, what are they doing back there?


00:09:32.080 --> 00:09:33.980
- Maybe the backend.


00:09:33.980 --> 00:09:37.660
She reported in the middle, I don't know.


00:09:37.660 --> 00:09:38.720
But it's weird, yeah.


00:09:38.720 --> 00:09:40.740
- Yeah, yeah, that is quite interesting.


00:09:40.740 --> 00:09:43.180
- And then you get the standard business intelligence,


00:09:43.180 --> 00:09:44.100
it makes sense.


00:09:44.100 --> 00:09:45.660
- Yeah, the business intelligence one,


00:09:45.660 --> 00:09:48.020
that one Python is definitely crushing it there, right?


00:09:48.020 --> 00:09:51.460
It's like 30% versus 10, 15, 20% for the others.


00:09:51.460 --> 00:09:53.020
Yeah, I guess one more,


00:09:53.020 --> 00:09:56.020
there's all these different things you all can dive into.


00:09:56.020 --> 00:09:58.860
I guess one more area that might be worth addressing


00:09:58.860 --> 00:10:01.140
is they broke down like the type of coding


00:10:01.140 --> 00:10:04.140
and software activities you do based on gender.


00:10:04.140 --> 00:10:06.740
So for example, if you're male,


00:10:06.740 --> 00:10:09.260
like how likely are you to do straight programming


00:10:09.260 --> 00:10:12.540
versus testing versus user experience type stuff


00:10:12.540 --> 00:10:13.760
or versus female?


00:10:13.760 --> 00:10:16.180
And let's see, so there were some takeaways.


00:10:16.180 --> 00:10:17.660
It says women are more likely than men


00:10:17.660 --> 00:10:20.840
to be involved in data analysis, machine learning,


00:10:20.840 --> 00:10:22.620
UI design and research,


00:10:22.620 --> 00:10:25.220
but less likely to be directly doing


00:10:25.220 --> 00:10:27.580
infrastructure development or DevOps.


00:10:27.580 --> 00:10:30.040
But I mean, I kind of had that sense as well,


00:10:30.040 --> 00:10:30.880
but just from talking to people.


00:10:30.880 --> 00:10:32.500
- I mean, my personal experience


00:10:32.500 --> 00:10:34.140
is completely the opposite.


00:10:34.140 --> 00:10:38.180
So most of the DevOps people I work with are women.


00:10:38.180 --> 00:10:39.180
- Oh yeah.


00:10:39.180 --> 00:10:41.100
- But I think it kind of makes sense,


00:10:41.100 --> 00:10:43.520
I mean, in the industry for what I'm seeing.


00:10:43.520 --> 00:10:45.820
But for my, it's completely the opposite.


00:10:45.820 --> 00:10:46.660
- Interesting.


00:10:46.660 --> 00:10:48.140
Yeah, so I'll leave this out here


00:10:48.140 --> 00:10:50.180
for people to go dive into and explore more.


00:10:50.180 --> 00:10:52.920
I feel like I've gone probably over enough details there


00:10:52.920 --> 00:10:53.760
to give you all a sense,


00:10:53.760 --> 00:10:56.400
but there are some interesting things to be learned, I think.


00:10:56.400 --> 00:10:57.440
- Yeah, definitely.


00:10:57.440 --> 00:10:58.280
- Pretty cool.


00:10:58.280 --> 00:11:00.340
- Yeah, and Matt out there in the live stream


00:11:00.340 --> 00:11:02.080
points out that that might be more than 100%.


00:11:02.080 --> 00:11:03.440
I'm not sure which part you're talking about.


00:11:03.440 --> 00:11:06.240
I do believe a lot of these had multiple,


00:11:06.240 --> 00:11:07.480
you could check multiple things,


00:11:07.480 --> 00:11:09.280
like which languages am I willing to adopt?


00:11:09.280 --> 00:11:12.600
Well, I might be adopting both SQL and Python


00:11:12.600 --> 00:11:14.160
in the next year, something like that.


00:11:14.160 --> 00:11:16.400
- Yeah, and I think a lot of people are perpetually


00:11:16.400 --> 00:11:18.760
going to start learning Rust or Go,


00:11:18.760 --> 00:11:21.080
but never starting.


00:11:22.280 --> 00:11:24.380
>> That's true. It's a solid landing goat.


00:11:24.380 --> 00:11:25.540
>> It's not much.


00:11:25.540 --> 00:11:28.500
>> All right. Cornell.


00:11:28.500 --> 00:11:32.060
This was suggested by Yale Mintz.


00:11:32.060 --> 00:11:35.860
Michael, you know where Cornell comes from apparently?


00:11:35.860 --> 00:11:37.820
>> I'm thinking Soundgarden.


00:11:37.820 --> 00:11:40.500
Some good 90s grunge.


00:11:40.500 --> 00:11:46.900
>> Okay. Maybe. Cornell is a record and replay mock server.


00:11:47.380 --> 00:11:50.260
We're going to link to the tool,


00:11:50.260 --> 00:11:54.020
but also there's an introduction blog post about it.


00:11:54.020 --> 00:11:58.260
It supposedly makes it really simple to record and


00:11:58.260 --> 00:12:00.220
replay features to perform


00:12:00.220 --> 00:12:04.460
end-to-end testing in an isolated test environment.


00:12:04.460 --> 00:12:06.340
The gist around it,


00:12:06.340 --> 00:12:08.300
there's a cool tool called VCRPi,


00:12:08.300 --> 00:12:12.740
which saves cassette files.


00:12:12.740 --> 00:12:15.340
You send a request and you get replies back,


00:12:15.340 --> 00:12:19.340
and then you can save those request reply sessions and stuff.


00:12:19.340 --> 00:12:24.860
This is bundling VCRpy with Flask to make a little server.


00:12:24.860 --> 00:12:27.600
It's actually really a cool idea.


00:12:27.600 --> 00:12:31.280
The idea, one of the things around it is that you can do,


00:12:31.280 --> 00:12:33.140
you're not just mocking one service,


00:12:33.140 --> 00:12:36.500
you can just mock in any external service that you're dealing with.


00:12:36.500 --> 00:12:39.200
It'll do replays on that.


00:12:39.200 --> 00:12:41.940
One of the benefits over rolling your own mocks or


00:12:41.940 --> 00:12:47.000
rolling your own test server or test service is that you can,


00:12:47.000 --> 00:12:50.440
that you don't really have to think about designing the whole thing.


00:12:50.440 --> 00:12:52.240
It just replays everything.


00:12:52.240 --> 00:12:53.400
>> Yeah, that is cool.


00:12:53.400 --> 00:12:56.500
>> Looks pretty fun. I haven't played with it yet, but definitely want to.


00:12:56.500 --> 00:12:57.760
>> Hey, speaking of play with it,


00:12:57.760 --> 00:13:00.120
click on documentation, I think it is,


00:13:00.120 --> 00:13:01.840
on that page right there, on the bottom left.


00:13:01.840 --> 00:13:03.320
>> Okay, documentation.


00:13:03.320 --> 00:13:06.280
>> Then click on the documentation of that page.


00:13:06.280 --> 00:13:11.560
There you go. So you have this series of animated GIFs of scene and


00:13:11.560 --> 00:13:13.680
action and I think that that's kind of cool, right?


00:13:13.680 --> 00:13:15.440
Like you can, it'll go along and say, oh yeah,


00:13:15.440 --> 00:13:20.120
here you're recording a bunch of API calls and then the workflow of like how you create it.


00:13:20.120 --> 00:13:23.040
I just want to give a shout out to the animated GIFs for like,


00:13:23.040 --> 00:13:24.120
is this interesting to me?


00:13:24.120 --> 00:13:28.360
Let me just watch the GIFs instead of actually take the time to try to adopt it.


00:13:28.360 --> 00:13:31.120
It's simple but it seems really effective.


00:13:31.120 --> 00:13:31.840
Pompei, what do you think?


00:13:31.840 --> 00:13:33.680
>> Good idea. No, it's a really good idea.


00:13:33.680 --> 00:13:38.240
I mean, there are many projects that you think this might be cool to work with and


00:13:38.240 --> 00:13:40.200
then you start reading walls of texts


00:13:40.200 --> 00:13:43.000
and halfway through, I don't know if it's interesting,


00:13:43.000 --> 00:13:44.840
but I mean, half an hour,


00:13:44.840 --> 00:13:48.360
so how much I give is eye catching, yeah.


00:13:48.360 --> 00:13:50.200
- Yeah, for sure, for sure.


00:13:50.200 --> 00:13:53.160
Yeah, also I just want a quick shout out to the live stream.


00:13:53.160 --> 00:13:55.160
German points out from his experience,


00:13:55.160 --> 00:13:57.360
the data analysis have more men than women,


00:13:57.360 --> 00:13:59.200
but it could be biased due to the tech sector


00:13:59.200 --> 00:14:00.160
having more men in general.


00:14:00.160 --> 00:14:01.040
I do think that that's true.


00:14:01.040 --> 00:14:03.120
I think what they said is, if you're a woman,


00:14:03.120 --> 00:14:04.640
what are you more likely to be doing?


00:14:04.640 --> 00:14:07.000
If you're a man, what are you more likely to be doing?


00:14:07.000 --> 00:14:09.520
And it's like, of that population,


00:14:09.520 --> 00:14:11.000
what areas do you work in?


00:14:11.000 --> 00:14:13.520
Not that user experience has more men or women.


00:14:13.520 --> 00:14:16.340
I don't think it addresses that question.


00:14:16.340 --> 00:14:18.360
I think my thoughts here,


00:14:18.360 --> 00:14:21.240
there's a lot of women who end up in programming


00:14:21.240 --> 00:14:24.400
not down the traditional computer science path.


00:14:24.400 --> 00:14:26.080
You know, they go into biology and then they're like,


00:14:26.080 --> 00:14:28.240
"Oh, I've actually learned a little Python


00:14:28.240 --> 00:14:30.580
"and now I really like it and I work here and it's amazing."


00:14:30.580 --> 00:14:33.440
But you know, they kind of get pulled in tangentially


00:14:33.440 --> 00:14:34.260
where there's a lot of guys


00:14:34.260 --> 00:14:35.680
that like sign up for computer science


00:14:35.680 --> 00:14:37.160
and they just go through that path.


00:14:37.160 --> 00:14:39.080
And some of the areas that were called out


00:14:39.080 --> 00:14:40.680
are more likely to take the straight


00:14:40.680 --> 00:14:42.680
computer science path people,


00:14:42.680 --> 00:14:44.480
rather than the, I got interested


00:14:44.480 --> 00:14:46.560
and I came in through like psychology


00:14:46.560 --> 00:14:49.340
or something else where there would be more women.


00:14:49.340 --> 00:14:51.280
So, I don't know, I would love to have more women in there,


00:14:51.280 --> 00:14:52.360
but I think that this is my,


00:14:52.360 --> 00:14:55.680
and broadly speaking, but I think this is my thoughts


00:14:55.680 --> 00:14:59.040
about why maybe those different areas


00:14:59.040 --> 00:15:01.100
seem to attract people not so directly


00:15:01.100 --> 00:15:02.400
down the computer science path.


00:15:02.400 --> 00:15:03.240
Anyway, yeah.


00:15:03.240 --> 00:15:06.120
All right, Juanpe, you're up.


00:15:06.120 --> 00:15:07.880
Talk to us about the next thing you got here.


00:15:07.880 --> 00:15:09.000
- Sure.


00:15:09.000 --> 00:15:11.360
So I wanna talk about Factory Boy.


00:15:11.360 --> 00:15:13.560
I think it's a very well-known library


00:15:13.560 --> 00:15:19.680
to basically mock objects when you're running tests.


00:15:19.680 --> 00:15:22.380
And both this and the next tool I'm gonna talk about


00:15:22.380 --> 00:15:25.140
came because we were working on a system


00:15:25.140 --> 00:15:28.500
that replicates an entire Salesforce org.


00:15:28.500 --> 00:15:31.000
So we have infrastructure we've built


00:15:31.000 --> 00:15:32.780
that takes everything you have,


00:15:32.780 --> 00:15:34.480
every object you have in Salesforce


00:15:34.480 --> 00:15:35.800
and copy it to a database.


00:15:35.800 --> 00:15:38.720
This is a way we have to have daily snapshot of the data


00:15:38.720 --> 00:15:41.200
that we can do a time series and analysis


00:15:41.200 --> 00:15:43.040
and all the models that we have on it


00:15:43.040 --> 00:15:45.040
instead of being a few minutes, let's say,


00:15:45.040 --> 00:15:46.440
when you modify it, it's lost.


00:15:46.440 --> 00:15:49.720
So for this, we obviously need to communicate a lot


00:15:49.720 --> 00:15:51.120
with the API in Salesforce.


00:15:51.120 --> 00:15:53.920
And when you get API responses,


00:15:53.920 --> 00:15:59.960
you need to not only treat the JSON plainly,


00:16:00.000 --> 00:16:02.440
say, just the plain JSON object.


00:16:02.440 --> 00:16:04.360
But you would like also to have some kind


00:16:04.360 --> 00:16:05.800
of object representation.


00:16:05.800 --> 00:16:07.920
And for this, I think it's not news for anyone.


00:16:07.920 --> 00:16:12.120
The Pydantic right now is taking the floor.


00:16:12.120 --> 00:16:15.120
And the biggest issue came when we


00:16:15.120 --> 00:16:16.740
needed to start writing tests for it.


00:16:16.740 --> 00:16:20.640
Because we get the JSON file.


00:16:20.640 --> 00:16:22.520
We stick it in the Pydantic object.


00:16:22.520 --> 00:16:23.480
It validates everything.


00:16:23.480 --> 00:16:25.060
Everything's beautiful and works fine.


00:16:25.060 --> 00:16:26.640
But then we have a bunch of objects,


00:16:26.640 --> 00:16:29.480
a bunch of fields on the object that cannot be nulled,


00:16:29.480 --> 00:16:31.160
for instance, or they are not optional.


00:16:31.160 --> 00:16:32.680
So they need to come in the API


00:16:32.680 --> 00:16:33.880
and we need to validate for those


00:16:33.880 --> 00:16:36.080
because if the API does not return any of those,


00:16:36.080 --> 00:16:38.600
it should break and tell us, look, this is wrong.


00:16:38.600 --> 00:16:39.760
It's not what you expected.


00:16:39.760 --> 00:16:43.000
So when we wanted to write tests for those


00:16:43.000 --> 00:16:46.160
and we wanted to create objects for those in each test,


00:16:46.160 --> 00:16:48.720
we noticed that out of hundreds of fields,


00:16:48.720 --> 00:16:50.960
we might need to fill, I don't know,


00:16:50.960 --> 00:16:54.840
probably 80, 90 of them because they were mandatory.


00:16:54.840 --> 00:16:56.360
And it started to be very tedious.


00:16:56.360 --> 00:16:59.080
And I remember I opened an issue in the PyDantic.


00:16:59.080 --> 00:17:03.360
I say, "Hey, have you thought about probably allowing


00:17:03.360 --> 00:17:07.400
creating an object with random fields that validate properly?


00:17:07.400 --> 00:17:10.000
Like this field is an integer between 10 and 20.


00:17:10.000 --> 00:17:11.600
So I just don't want to feel it.


00:17:11.600 --> 00:17:12.920
I don't want to feel any of those


00:17:12.920 --> 00:17:14.440
because I don't care for this test.


00:17:14.440 --> 00:17:15.560
Is there a way that I can say,


00:17:15.560 --> 00:17:17.720
"Okay, just fill whatever it validates."


00:17:17.720 --> 00:17:19.880
And they say, "No, it's out of the scope of Quedantic,"


00:17:19.880 --> 00:17:20.760
which also makes sense.


00:17:20.760 --> 00:17:22.880
I just wanted to ask in case.


00:17:22.880 --> 00:17:24.600
They said that probably in Factory Boy,


00:17:24.600 --> 00:17:25.920
they might be interested in this.


00:17:25.920 --> 00:17:28.720
So I went to Factory Boy and I read the documentation.


00:17:28.720 --> 00:17:31.720
It was pretty cool because it allows you to create,


00:17:31.720 --> 00:17:33.760
you define an inside class.


00:17:33.760 --> 00:17:35.280
So it's a meta class,


00:17:35.280 --> 00:17:39.200
not a meta class in the terms of Python meta classes,


00:17:39.200 --> 00:17:40.840
but it's a class called meta


00:17:40.840 --> 00:17:43.800
within the factory that you want.


00:17:43.800 --> 00:17:44.960
It's weird because every time you say,


00:17:44.960 --> 00:17:46.160
yeah, this is the meta class,


00:17:46.160 --> 00:17:47.160
why do meta class?


00:17:47.160 --> 00:17:48.080
No, it's a class.


00:17:48.080 --> 00:17:49.840
So you inherit from factory,


00:17:49.840 --> 00:17:52.440
then you define a class called meta,


00:17:52.440 --> 00:17:54.520
meta where you define what is your model.


00:17:54.520 --> 00:17:57.880
So this is the object I want to mock with this factory.


00:17:57.880 --> 00:18:02.180
and then you can define many fields with their default values.


00:18:02.180 --> 00:18:05.060
The cool thing about this is that it implements also Faker.


00:18:05.060 --> 00:18:07.240
You can say, if I have a username,


00:18:07.240 --> 00:18:08.940
I don't want to fill it, just give me a username,


00:18:08.940 --> 00:18:10.040
and Faker will give you.


00:18:10.040 --> 00:18:12.840
>> Yeah, Faker is really cool for generating stuff like that.


00:18:12.840 --> 00:18:13.280
>> Really cool.


00:18:13.280 --> 00:18:13.760
>> Yeah.


00:18:13.760 --> 00:18:17.360
>> The amount of plugins you find for Faker is outstanding.


00:18:17.360 --> 00:18:20.040
You can fake almost anything you think of.


00:18:20.040 --> 00:18:22.160
The cool thing about this is that it's not


00:18:22.160 --> 00:18:25.400
only you plug in the class that you have and it will fill it,


00:18:25.400 --> 00:18:27.040
but you also can work with ORMs,


00:18:27.040 --> 00:18:31.280
like you can use SQL, KMORIM, or Django ORM.


00:18:31.280 --> 00:18:35.240
And it will generate an object for this ORM


00:18:35.240 --> 00:18:38.680
based on whatever you set these are the default values.


00:18:38.680 --> 00:18:41.440
So I thought it would be great if I could do this also


00:18:41.440 --> 00:18:42.120
for Pydantic.


00:18:42.120 --> 00:18:45.400
So I could just say, OK, these are the mandatory fields.


00:18:45.400 --> 00:18:46.360
It puts something fake.


00:18:46.360 --> 00:18:47.480
You can think about it.


00:18:47.480 --> 00:18:48.800
And then we're ready to go.


00:18:48.800 --> 00:18:51.200
But reading the documentation, it didn't appear anywhere.


00:18:51.200 --> 00:18:53.960
And I thought, hmm, maybe I cannot use it for this case.


00:18:53.960 --> 00:18:55.960
So I went ahead and opened it easy and say,


00:18:55.960 --> 00:18:57.360
Are you thinking about putting this


00:18:57.360 --> 00:18:58.440
also to work with Pydantic?


00:18:58.440 --> 00:19:01.600
I mean, it's now is booming and everyone is using it.


00:19:01.600 --> 00:19:03.880
And if you are reading JSON from an API,


00:19:03.880 --> 00:19:05.840
it's very likely that you have hundreds of fields


00:19:05.840 --> 00:19:06.680
you don't care about.


00:19:06.680 --> 00:19:08.360
You might want to fill it with whatever.


00:19:08.360 --> 00:19:11.700
And I remember the author said, I didn't know this.


00:19:11.700 --> 00:19:14.520
I didn't know Pydantics, cool you mentioning it,


00:19:14.520 --> 00:19:16.680
but internally what FactoryVault is doing


00:19:16.680 --> 00:19:18.400
is creating a dictionary with the parameters


00:19:18.400 --> 00:19:20.560
you want to fill in and just unpacking it


00:19:20.560 --> 00:19:22.160
in the construction of the class.


00:19:22.160 --> 00:19:23.000
Have you tried it?


00:19:23.000 --> 00:19:24.840
And I was like, no, I have not.


00:19:24.840 --> 00:19:26.200
And when I tried it worked.


00:19:26.200 --> 00:19:27.480
So it was perfectly.


00:19:27.480 --> 00:19:31.840
I mean, maybe there are some quirks of Pydante that it kind of covers.


00:19:31.840 --> 00:19:38.360
But if you're using Pydante to store your data from API calls and so on, from JSON validates


00:19:38.360 --> 00:19:40.560
and so on, Factory is pretty cool.


00:19:40.560 --> 00:19:45.000
I mean, the amount of things you can do with this, you can create many factories for the


00:19:45.000 --> 00:19:46.000
same class.


00:19:46.000 --> 00:19:49.080
You can create fixtures like, I don't know if you want to mock a user, you can have an


00:19:49.080 --> 00:19:51.720
admin or a buyer or whatever.


00:19:51.720 --> 00:19:56.560
And then you can just define different factories and it will give you the usage you've defined.


00:19:56.560 --> 00:20:02.120
And it's also pretty cool because the faker is randomized beneath it.


00:20:02.120 --> 00:20:08.040
So if there are parts of your object that your code does not care about, it's also a


00:20:08.040 --> 00:20:11.000
good test to have those parts being random.


00:20:11.000 --> 00:20:14.160
Because if it really doesn't care, you don't care what those fields are.


00:20:14.160 --> 00:20:18.920
And then at some point your test fail, it happens once, it means that you actually can


00:20:18.920 --> 00:20:19.920
fix something.


00:20:19.920 --> 00:20:20.920
Yeah, absolutely.


00:20:20.920 --> 00:20:21.760
- Absolutely.


00:20:21.760 --> 00:20:24.440
I did see that if you need repeatable tests,


00:20:24.440 --> 00:20:26.280
but you want Faker to generate random stuff,


00:20:26.280 --> 00:20:28.360
there's a way to seed Faker.


00:20:28.360 --> 00:20:29.200
- Exactly.


00:20:29.200 --> 00:20:30.520
- Generate the random values,


00:20:30.520 --> 00:20:31.900
but do it in a consistent way.


00:20:31.900 --> 00:20:34.240
And one way you might want that is if you have an edge case


00:20:34.240 --> 00:20:36.160
or some value that breaks the test,


00:20:36.160 --> 00:20:38.880
and then you want to put a break point and press debug


00:20:38.880 --> 00:20:40.560
and go through it again,


00:20:40.560 --> 00:20:42.840
but like, you know, how are you going to get it to hit


00:20:42.840 --> 00:20:45.000
that case again in a predictable way, right?


00:20:45.000 --> 00:20:47.400
So if you trigger, if you tell it to say,


00:20:47.400 --> 00:20:50.000
always do the same thing, but randomly, you know,


00:20:50.000 --> 00:20:53.240
>> You can go back and look at it a second time and figure out what's up.


00:20:53.240 --> 00:20:56.860
>> Yeah, you can fix that. Sometimes it's also good to have them fixed,


00:20:56.860 --> 00:20:58.200
even if you don't care.


00:20:58.200 --> 00:21:00.440
I mean, you need to have a date time,


00:21:00.440 --> 00:21:02.880
and for some reason you need to have the date time being whatever,


00:21:02.880 --> 00:21:04.800
and whatever, but you can validate for it.


00:21:04.800 --> 00:21:08.160
You can just or either set it or ensure that it's fixed.


00:21:08.160 --> 00:21:10.360
Yeah, there are many use cases that you can


00:21:10.360 --> 00:21:12.560
exploit that thing and it's actually really cool.


00:21:12.560 --> 00:21:18.840
>> Yeah, I almost always seed Faker because I'm not using it


00:21:18.840 --> 00:21:20.400
because I want the randomness.


00:21:20.400 --> 00:21:23.520
I'm using it because I don't want to come up with the data.


00:21:23.520 --> 00:21:26.940
>> Yeah, exactly. So make it so that it does the same thing every time,


00:21:26.940 --> 00:21:28.600
just gives you the random data that you want.


00:21:28.600 --> 00:21:30.300
That's right. Agreed. Very, very cool.


00:21:30.300 --> 00:21:35.120
All right. The next one up actually is pretty related to that.


00:21:35.120 --> 00:21:36.520
It's called PyInstrument.


00:21:36.520 --> 00:21:38.520
Have either of you heard of PyInstrument?


00:21:38.520 --> 00:21:39.640
>> Not until now.


00:21:39.640 --> 00:21:39.920
>> Yeah.


00:21:39.920 --> 00:21:41.800
>> I read the notes and it sounds pretty cool.


00:21:41.800 --> 00:21:42.800
>> Yeah. Brian?


00:21:42.800 --> 00:21:43.760
>> No, I haven't.


00:21:43.760 --> 00:21:47.400
>> Yeah. So it's a call stack profiler for Python,


00:21:47.400 --> 00:21:48.600
which is pretty cool, right?


00:21:48.600 --> 00:21:50.600
it's just going to tell you where your code is slow,


00:21:50.600 --> 00:21:53.520
but it looks really clean.


00:21:53.520 --> 00:21:55.260
When you look at the output,


00:21:55.260 --> 00:21:59.720
it can actually give you the results in the terminal.


00:21:59.720 --> 00:22:01.800
If you want to see,


00:22:01.800 --> 00:22:03.360
like you run this thing,


00:22:03.360 --> 00:22:04.800
instead of saying Python,


00:22:04.800 --> 00:22:07.440
my Python.py file,


00:22:07.440 --> 00:22:09.440
you would just say py instrument,


00:22:09.440 --> 00:22:11.000
that same file and it'll run it,


00:22:11.000 --> 00:22:12.880
but then at the end, it's going to generate


00:22:12.880 --> 00:22:16.120
a whole bunch of things about how long it took and whatnot.


00:22:16.120 --> 00:22:20.620
And then you actually get like colored output in the terminal


00:22:20.620 --> 00:22:23.700
showing which lines of code are spending how much time


00:22:23.700 --> 00:22:24.780
in different places.


00:22:24.780 --> 00:22:26.740
And it seems like it's a real good way


00:22:26.740 --> 00:22:28.020
to just sort of quickly dive in


00:22:28.020 --> 00:22:29.380
on where you're spending your time.


00:22:29.380 --> 00:22:30.700
- Yeah, I'm definitely gonna try this.


00:22:30.700 --> 00:22:31.540
It's cool.


00:22:31.540 --> 00:22:33.520
- Yeah, one thing I like about it is the simplicity


00:22:33.520 --> 00:22:35.180
of like pip install pyinstrument,


00:22:35.180 --> 00:22:37.020
pyinstrument your file.


00:22:37.020 --> 00:22:38.940
That'll give you the answer, right?


00:22:38.940 --> 00:22:40.780
- That for me solved it.


00:22:40.780 --> 00:22:43.300
I mean, every time you want to do some profiling,


00:22:43.300 --> 00:22:45.980
feel like they spent some time tweaking things.


00:22:45.980 --> 00:22:47.220
So you get what you want.


00:22:47.220 --> 00:22:49.420
The fact that this is just running with PI instrument,


00:22:49.420 --> 00:22:50.900
whatever script you want.


00:22:50.900 --> 00:22:52.620
I mean, I'm going to try for sure.


00:22:52.620 --> 00:22:53.460
- Yeah, yeah, for sure.


00:22:53.460 --> 00:22:55.140
And when you do profiling,


00:22:55.140 --> 00:22:58.980
you end up in this sort of quantum mechanics world


00:22:58.980 --> 00:23:01.460
of if you observe a thing, you've changed it.


00:23:01.460 --> 00:23:03.700
And so there might be code that is like,


00:23:03.700 --> 00:23:07.180
this half is 50/50 and this half is 50/50 at the time,


00:23:07.180 --> 00:23:09.940
but one is calling an external system once


00:23:09.940 --> 00:23:11.220
and the other is a tight loop.


00:23:11.220 --> 00:23:14.100
And if you profile that with instrumentation,


00:23:14.100 --> 00:23:15.940
it's going to wreck it.


00:23:15.940 --> 00:23:17.980
it's going to make the loop look way slower


00:23:17.980 --> 00:23:20.400
'cause now you've added a bunch of overhead to each step


00:23:20.400 --> 00:23:21.980
where there's very little overhead


00:23:21.980 --> 00:23:23.940
to this external service sort of thing.


00:23:23.940 --> 00:23:25.740
And this one uses sampling,


00:23:25.740 --> 00:23:28.620
and the sampling doesn't really have that effect.


00:23:28.620 --> 00:23:31.820
It just every so often, every millisecond or something


00:23:31.820 --> 00:23:33.160
that says, what are you doing now?


00:23:33.160 --> 00:23:34.260
What are you doing now?


00:23:34.260 --> 00:23:35.100
Who called you?


00:23:35.100 --> 00:23:35.940
What are you doing now, right?


00:23:35.940 --> 00:23:39.420
And so it's more of a polling sort of thing


00:23:39.420 --> 00:23:43.300
rather than slowing down line by line code.


00:23:43.300 --> 00:23:45.140
So that's probably worth doing as well.


00:23:45.140 --> 00:23:46.220
>> Yeah, it's pretty cool.


00:23:46.220 --> 00:23:46.500
>> Yeah.


00:23:46.500 --> 00:23:46.620
>> Yeah.


00:23:46.620 --> 00:23:49.620
>> It looks like you can specifically jump in and


00:23:49.620 --> 00:23:52.660
just do a section of your code that you care about also.


00:23:52.660 --> 00:23:54.740
>> Exactly. If you want to say,


00:23:54.740 --> 00:23:57.460
so one of the things that I hate about profiling is,


00:23:57.460 --> 00:23:59.340
it'll say 87 percent of


00:23:59.340 --> 00:24:01.860
your time was in the startup code and the imports.


00:24:01.860 --> 00:24:04.640
You're like, "Yeah, okay, that's not relevant to me.


00:24:04.640 --> 00:24:08.180
What I want to know is the part that I'm actually trying to test here.


00:24:08.180 --> 00:24:09.780
How long did I spend there?"


00:24:09.780 --> 00:24:12.740
Please don't pollute that with other junk about


00:24:12.740 --> 00:24:16.740
like starting up Python or loading modules or whatever, right?


00:24:16.740 --> 00:24:19.940
And so you can, there's an API and you can say


00:24:19.940 --> 00:24:22.540
from PyInstrument import profiler,


00:24:22.540 --> 00:24:27.180
and then you can do a context block in there and run it.


00:24:27.180 --> 00:24:30.180
And just that code will tell you like how long it takes.


00:24:30.180 --> 00:24:32.700
Does anything else jump out there at you, Brian,


00:24:32.700 --> 00:24:34.780
in like with this example I got on the screen here?


00:24:34.780 --> 00:24:35.900
That would be hard.


00:24:35.900 --> 00:24:38.300
- It's an async example for one.


00:24:38.300 --> 00:24:39.980
- Yeah, as an async and a wait.


00:24:39.980 --> 00:24:43.280
And so they recently released PyInstrument 4,


00:24:43.280 --> 00:24:46.540
which will actually give you the information


00:24:46.540 --> 00:24:50.460
about the async code as well, right?


00:24:50.460 --> 00:24:52.540
So it'll, let's see what it says.


00:24:52.540 --> 00:24:54.700
Has async support, PyInstrument now detects


00:24:54.700 --> 00:24:56.740
when an async task hits an await


00:24:56.740 --> 00:25:00.320
and tracks the time spent outside of the async context


00:25:00.320 --> 00:25:01.180
under the await.


00:25:01.180 --> 00:25:03.260
Whereas before it would basically just profile


00:25:03.260 --> 00:25:06.940
the async IO event loop or something silly like that, right?


00:25:06.940 --> 00:25:10.020
So if you're trying to profile async in a way,


00:25:10.020 --> 00:25:12.620
in async IO, this might be your best option


00:25:12.620 --> 00:25:14.300
'cause it specifically supports that.


00:25:14.300 --> 00:25:15.140
- That's good.


00:25:15.140 --> 00:25:19.500
So what happened before if you use a different profile?


00:25:19.500 --> 00:25:22.460
- It would say, yeah, it says you only see the time spent


00:25:22.460 --> 00:25:25.700
in the run loop and it'll basically tell you like,


00:25:25.700 --> 00:25:28.340
here you see like run once, the select


00:25:28.340 --> 00:25:30.820
and then the queue control built in.


00:25:30.820 --> 00:25:33.300
It's just like, there's this async IO event loop


00:25:33.300 --> 00:25:35.220
that's cranking around waiting for the signal


00:25:35.220 --> 00:25:36.340
for the IO to be done.


00:25:36.340 --> 00:25:38.180
and it just says, well, you're waiting on this,


00:25:38.180 --> 00:25:39.100
you're in the loop.


00:25:39.100 --> 00:25:39.940
You know what I mean?


00:25:39.940 --> 00:25:40.760
- Yeah, yeah, yeah.


00:25:40.760 --> 00:25:42.860
- Yeah, so, yeah.


00:25:42.860 --> 00:25:44.020
So now you get a little bit better.


00:25:44.020 --> 00:25:46.720
Like it says, okay, you're awaiting on this line


00:25:46.720 --> 00:25:48.960
of your code for a second or whatever it is.


00:25:48.960 --> 00:25:51.500
Yeah, there's also, I'll shout out a few more things here.


00:25:51.500 --> 00:25:52.460
Is it in the stock?


00:25:52.460 --> 00:25:55.920
Yeah, so there's also a bunch of simple authentication


00:25:55.920 --> 00:25:59.060
they did previously about network calls and stuff.


00:25:59.060 --> 00:26:03.300
And there's an interactive Vue.js app


00:26:03.300 --> 00:26:04.780
that you can get with Flame Graphs.


00:26:04.780 --> 00:26:06.460
So instead of looking at it in the terminal,


00:26:06.460 --> 00:26:08.100
you can look at it in your web browser


00:26:08.100 --> 00:26:09.780
and explore into those.


00:26:09.780 --> 00:26:11.580
Yeah, there's a lot of neat little things here


00:26:11.580 --> 00:26:12.420
pulled out of the show notes,


00:26:12.420 --> 00:26:15.300
but it seemed like a really nice way to do some profiling


00:26:15.300 --> 00:26:18.220
and you just PyInstrument your code and you have a look.


00:26:18.220 --> 00:26:21.060
- Yeah, I personally kind of like the default output.


00:26:21.060 --> 00:26:23.060
I know that a lot of people like flame graphs,


00:26:23.060 --> 00:26:25.220
like they don't really do much for me.


00:26:25.220 --> 00:26:27.340
They look like, I don't see the data,


00:26:27.340 --> 00:26:29.100
but it's cool that it has both.


00:26:29.100 --> 00:26:31.580
- Yeah, a couple of things from the live chat.


00:26:31.580 --> 00:26:33.680
Maddy says, "PyInstrument is a statistical


00:26:33.680 --> 00:26:35.480
"or sampling profiler,


00:26:35.480 --> 00:26:37.560
"which is better prepared for profiling."


00:26:37.560 --> 00:26:38.640
I think it depends.


00:26:38.640 --> 00:26:40.680
I mean, the instrumentation ones


00:26:40.680 --> 00:26:43.360
do give you more precise information,


00:26:43.360 --> 00:26:48.000
but it's also skewed with the overhead of that information.


00:26:48.000 --> 00:26:49.100
So it depends,


00:26:49.100 --> 00:26:51.920
but this is the least influential one for sure.


00:26:51.920 --> 00:26:54.620
And then Avaro does,


00:26:54.620 --> 00:26:57.160
"How would you use PyInstrument with an entry point?"


00:26:57.160 --> 00:26:58.520
That's a good question.


00:26:58.520 --> 00:27:00.560
Not knowing the answer off the top of my head,


00:27:00.560 --> 00:27:03.620
maybe make another Python file that just imports your library


00:27:03.620 --> 00:27:05.760
and calls the entry point and then profile that.


00:27:05.760 --> 00:27:09.360
But there's a real quick cheat,


00:27:09.360 --> 00:27:12.880
just make it call it and then PyInstrument that file.


00:27:12.880 --> 00:27:15.840
But there may be some way to say like -m


00:27:15.840 --> 00:27:18.280
and give it a module and a thing to do.


00:27:18.280 --> 00:27:19.760
So yeah, that's it, Brian.


00:27:19.760 --> 00:27:20.880
That's it for PyInstrument.


00:27:20.880 --> 00:27:22.080
- Cool.


00:27:22.080 --> 00:27:23.840
Well, I just wanted to remind everybody


00:27:23.840 --> 00:27:27.840
that Python 3.10 release candidate one came out yesterday.


00:27:27.840 --> 00:27:31.800
So Pablo announced it just on the 3rd, I think.


00:27:31.800 --> 00:27:33.380
I think it was yesterday.


00:27:33.380 --> 00:27:34.220
The 4th today?


00:27:34.220 --> 00:27:35.440
Yeah, anyway.


00:27:35.440 --> 00:27:36.880
So 3.10 is out.


00:27:36.880 --> 00:27:41.880
If you've got, well, 3.10, RC1 is out.


00:27:41.880 --> 00:27:44.360
The timelines that we're looking at then,


00:27:44.360 --> 00:27:46.140
we're getting excited, it's coming up.


00:27:46.140 --> 00:27:49.760
So the September 6th is the plan for RC2.


00:27:49.760 --> 00:27:53.880
And then October 4th is the plan for the official release.


00:27:53.880 --> 00:27:55.880
So we're just really right around the corner.


00:27:55.880 --> 00:27:57.000
It's nice.


00:27:57.000 --> 00:27:58.340
This is definitely a time,


00:27:58.340 --> 00:27:59.880
I know we've brought this up before,


00:27:59.880 --> 00:28:03.280
but if you maintain any third-party Python packages,


00:28:03.280 --> 00:28:07.120
you probably should have already been testing it against 3.10.


00:28:07.120 --> 00:28:10.640
But if you haven't, definitely do it now to make sure


00:28:10.640 --> 00:28:13.080
that people that use your stuff,


00:28:13.080 --> 00:28:15.120
it doesn't break when they need to.


00:28:15.120 --> 00:28:16.760
Then in the show notes,


00:28:16.760 --> 00:28:21.960
we put just a reminder of some of the new changes in 3.10.


00:28:21.960 --> 00:28:24.600
We've definitely talked about some of these before,


00:28:24.600 --> 00:28:29.720
structural pattern matching is the switch statement thing.


00:28:29.720 --> 00:28:33.040
Yeah, lots of these other things we've covered.


00:28:33.040 --> 00:28:39.400
Actually, I like the union types because there's a lot of stuff that I write


00:28:39.400 --> 00:28:43.440
that the default is none but the normal type is something else.


00:28:43.440 --> 00:28:48.520
You can really easily say the type is none or int or something like that.


00:28:48.520 --> 00:28:52.200
That's a lot cleaner than before.


00:28:52.200 --> 00:28:56.280
I've already started using 310 to test everything that I support.


00:28:56.280 --> 00:28:58.440
I hope everybody else has as well.


00:28:58.440 --> 00:29:01.840
>> Yeah, cool. I like the optional length checking in zip.


00:29:01.840 --> 00:29:05.100
Zip taking two collections and you want to pair up the items,


00:29:05.100 --> 00:29:06.240
like if those things don't match,


00:29:06.240 --> 00:29:07.600
that should be a problem.


00:29:07.600 --> 00:29:10.480
Also like the or for the types information.


00:29:10.480 --> 00:29:15.720
I think DIC and some of those types don't require a from typing imports.


00:29:15.720 --> 00:29:16.880
>> Oh, right. Yeah.


00:29:16.880 --> 00:29:18.800
>> Yeah. I don't see it called out here,


00:29:18.800 --> 00:29:21.680
but one of the problem was,


00:29:21.680 --> 00:29:24.360
maybe that's explicit type aliases, I'm not entirely sure.


00:29:24.360 --> 00:29:29.520
But if you want to say this type is a dictionary of strings and integers,


00:29:29.520 --> 00:29:32.760
you would have to say from type in import capital D dict,


00:29:32.760 --> 00:29:36.480
and then dict square bracket string comma int.


00:29:36.480 --> 00:29:40.560
Whereas now you can just use the lowercase d-i-c-t,


00:29:40.560 --> 00:29:42.040
and you don't have to have that import,


00:29:42.040 --> 00:29:43.520
and you can do that sort of thing to it.


00:29:43.520 --> 00:29:44.720
I'm looking forward to that.


00:29:44.720 --> 00:29:49.780
>> Yeah. With this, a lot of the common type hints,


00:29:49.780 --> 00:29:53.200
you won't have to do the import anymore, and that's great.


00:29:53.200 --> 00:29:55.560
I think that's really all I was using the import for,


00:29:55.560 --> 00:29:58.280
was things like dict and set, things like that.


00:29:58.280 --> 00:29:59.320
>> Yeah, exactly.


00:29:59.320 --> 00:30:00.720
>> Didn't that, I mean,


00:30:00.720 --> 00:30:04.080
I seem to remember that 3.10 was the one that was


00:30:04.080 --> 00:30:07.920
including these built-in types without having to import from typing.


00:30:07.920 --> 00:30:13.200
Didn't that update might break some of the libraries that is typing?


00:30:13.200 --> 00:30:15.620
- Like Pydantic and FastAPI.


00:30:15.620 --> 00:30:19.580
The thing that that was, was to use it in,


00:30:19.580 --> 00:30:21.320
basically use it as a string


00:30:21.320 --> 00:30:23.620
and not actually evaluate the type.


00:30:23.620 --> 00:30:25.920
I think that, like, so if you had your own type,


00:30:25.920 --> 00:30:28.200
your own Pydantic type that was a customer,


00:30:28.200 --> 00:30:29.480
I think you could put customer,


00:30:29.480 --> 00:30:31.400
but it wouldn't be actually evaluated


00:30:31.400 --> 00:30:34.400
until a type checker hit it or something like that.


00:30:34.400 --> 00:30:35.640
- Like a forward typing.


00:30:35.640 --> 00:30:37.040
- Yeah, yeah, exactly.


00:30:37.040 --> 00:30:40.040
So this ability to specify the type


00:30:40.040 --> 00:30:42.640
on like lowercase ddict is related,


00:30:42.640 --> 00:30:43.700
but it's not the same.


00:30:43.700 --> 00:30:46.980
- And I'm pretty sure that that fear around Pydantic


00:30:46.980 --> 00:30:48.980
is not in 3.10.


00:30:48.980 --> 00:30:52.400
- Yeah, it either got postponed or rolled back or modified.


00:30:52.400 --> 00:30:53.240
Yeah, yeah.


00:30:53.240 --> 00:30:56.920
- I just want to talk about the one that says,


00:30:56.920 --> 00:30:59.900
what was the number?


00:30:59.900 --> 00:31:02.400
Six to six, do you have it?


00:31:02.400 --> 00:31:05.520
- Yeah, the precise line numbers for debugging


00:31:05.520 --> 00:31:06.360
in other tools.


00:31:06.360 --> 00:31:09.340
- Yeah, I think it's very underrated.


00:31:09.340 --> 00:31:11.200
(laughs)


00:31:11.200 --> 00:31:12.520
It's gonna be one of those things


00:31:12.520 --> 00:31:13.720
that when people get used to it,


00:31:13.720 --> 00:31:15.560
it's like, I don't know how you live without this.


00:31:15.560 --> 00:31:17.400
- Oh yeah, yeah.


00:31:17.400 --> 00:31:19.900
There's not a good example shown right off the bat,


00:31:19.900 --> 00:31:22.120
but it's pretty cool.


00:31:22.120 --> 00:31:23.440
- Yeah, yeah, absolutely.


00:31:23.440 --> 00:31:25.400
Very cool, and then we also have better stack trace


00:31:25.400 --> 00:31:26.400
error messages, right?


00:31:26.400 --> 00:31:27.640
- Yeah. - Yeah, those are coming.


00:31:27.640 --> 00:31:29.320
A lot of good things to look forward to.


00:31:29.320 --> 00:31:31.520
All right, Juanpe, you got the last item.


00:31:31.520 --> 00:31:33.400
- Great. - I think it's time for it.


00:31:33.400 --> 00:31:34.920
You wanna take us out, right?


00:31:34.920 --> 00:31:36.440
- Sure. (laughs)


00:31:36.440 --> 00:31:38.880
Yeah, so let's talk about Time Machine.


00:31:39.760 --> 00:31:43.320
I said we were building this tool that copies


00:31:43.320 --> 00:31:44.800
an entire Salesforce org.


00:31:44.800 --> 00:31:46.920
One of the things that we need to orchestrate everything


00:31:46.920 --> 00:31:49.560
is to timestamp almost every action we do.


00:31:49.560 --> 00:31:53.240
This means that in many places all over the code,


00:31:53.240 --> 00:31:57.040
we have a daytimeUTCNow method call.


00:31:57.040 --> 00:32:00.440
And when we are testing it, we need to be able to mock it.


00:32:00.440 --> 00:32:04.560
And if you've tried to patch daytimeUTCNow


00:32:04.560 --> 00:32:07.680
with the usual patch method, it works, you can do it,


00:32:07.680 --> 00:32:09.700
But you need to do it with a patch


00:32:09.700 --> 00:32:11.100
and then you pass the string,


00:32:11.100 --> 00:32:15.000
but the module where this UTC now call is,


00:32:15.000 --> 00:32:16.540
and then you're good to go.


00:32:16.540 --> 00:32:18.700
But when you have this in many files in the same test,


00:32:18.700 --> 00:32:20.380
you need to patch every one of those


00:32:20.380 --> 00:32:21.700
because otherwise it wouldn't work.


00:32:21.700 --> 00:32:25.220
So I tried to use patch object and patch daytime and say,


00:32:25.220 --> 00:32:27.980
okay, I want to patch the UTC now method, this object.


00:32:27.980 --> 00:32:30.540
And it will of course complain and say,


00:32:30.540 --> 00:32:34.880
you cannot patch a built-in type like daytime, daytime.


00:32:34.880 --> 00:32:37.760
So I was looking for how we could patch this


00:32:37.760 --> 00:32:42.760
and I found FreeScan, which is a very well-known library thing


00:32:42.760 --> 00:32:44.480
to patch this kind of things.


00:32:44.480 --> 00:32:48.320
But suddenly I noticed that once I started using FreeScan,


00:32:48.320 --> 00:32:51.740
all of my tests took much longer to complete.


00:32:51.740 --> 00:32:55.580
It's not like deal breaker,


00:32:55.580 --> 00:32:58.760
so it went for probably five minutes to seven,


00:32:58.760 --> 00:33:01.080
or seven and a half, but it was very surprised


00:33:01.080 --> 00:33:03.960
because our pipeline or deployment pipeline


00:33:03.960 --> 00:33:05.160
ready to take a long time.


00:33:05.160 --> 00:33:08.000
So every time I can reduce a minute, it's good for me.


00:33:08.000 --> 00:33:09.720
And when I saw it going up two minutes,


00:33:09.720 --> 00:33:11.800
I was surprised, why is this happening?


00:33:11.800 --> 00:33:13.680
And then I learned that what Freescan is doing


00:33:13.680 --> 00:33:16.720
is actually scanning all your dependencies


00:33:16.720 --> 00:33:19.080
and make a batch for every call you make


00:33:19.080 --> 00:33:20.640
to the methods of data.


00:33:20.640 --> 00:33:24.280
And then in trying to see if there was something else,


00:33:24.280 --> 00:33:26.840
I found out Time Machine.


00:33:26.840 --> 00:33:31.840
Time Machine is a very cool, not so well-known, I think,


00:33:32.720 --> 00:33:35.440
library that allows you to do basically the same


00:33:35.440 --> 00:33:37.100
that Freescan allows you to do.


00:33:37.100 --> 00:33:41.480
So you can just patch almost any method call


00:33:41.480 --> 00:33:45.280
in daytime or time with a simple decorator in your test.


00:33:45.280 --> 00:33:48.160
It also supports pytest fixtures that you can use.


00:33:48.160 --> 00:33:51.340
The good thing about this is that it does not scan


00:33:51.340 --> 00:33:53.560
for imports of date and daytime.


00:33:53.560 --> 00:33:56.800
And what it does is actually change the underlying


00:33:56.800 --> 00:34:00.860
C-level calls that you make to get the time.


00:34:00.860 --> 00:34:04.760
So every time you say, I want to patch any call


00:34:04.760 --> 00:34:08.000
to be on January 1st of 2019, for instance,


00:34:08.000 --> 00:34:09.240
it will just call it normally,


00:34:09.240 --> 00:34:12.760
but the C, the underlined C calls that will be made


00:34:12.760 --> 00:34:14.680
will return this time instead of the other ones.


00:34:14.680 --> 00:34:16.480
You don't need to scan everything to patch it.


00:34:16.480 --> 00:34:19.280
Another thing that I thought it was pretty cool


00:34:19.280 --> 00:34:22.840
is this, you can let the time tick after you patched it.


00:34:22.840 --> 00:34:27.160
So you say, this is for February 1st of 2018.


00:34:27.160 --> 00:34:28.920
And once you enter the mock,


00:34:28.920 --> 00:34:32.720
either with a decorator or with a context manager,


00:34:32.720 --> 00:34:35.760
you can also use like standard patch call.


00:34:35.760 --> 00:34:37.120
Then time start passing,


00:34:37.120 --> 00:34:41.360
starting on that time that you mocked it for.


00:34:41.360 --> 00:34:44.520
So you can do perf counters and all this thing normally,


00:34:44.520 --> 00:34:46.680
but if you need to stay in a given day for a test,


00:34:46.680 --> 00:34:47.960
you can do it.


00:34:47.960 --> 00:34:49.080
So I thought it was pretty cool.


00:34:49.080 --> 00:34:51.540
It solved my two extra minutes running


00:34:51.540 --> 00:34:53.640
because we have many places and many files


00:34:53.640 --> 00:34:55.400
in the project where we used it C now.


00:34:55.400 --> 00:34:57.000
And it was pretty well.


00:34:57.000 --> 00:35:00.540
So this must have had incremental,


00:35:00.540 --> 00:35:01.760
I mean it has a little bit of time


00:35:01.760 --> 00:35:02.740
that it has to do its work,


00:35:02.740 --> 00:35:05.520
but it's fast enough that you're not noticing it then?


00:35:05.520 --> 00:35:06.660
- No, I'm not noticing anything.


00:35:06.660 --> 00:35:08.420
I mean it runs more or less the same.


00:35:08.420 --> 00:35:10.160
- Okay, wow, that's pretty cool.


00:35:10.160 --> 00:35:11.700
- I imagine there should be some delay,


00:35:11.700 --> 00:35:15.060
but it's not as noticeable as what happened with Freescan,


00:35:15.060 --> 00:35:16.900
'cause it took some time.


00:35:16.900 --> 00:35:18.700
- Yeah, I'm really glad you brought this up.


00:35:18.700 --> 00:35:19.540
This is cool.


00:35:19.540 --> 00:35:21.260
- Yeah, we have a bunch of tests.


00:35:21.260 --> 00:35:22.100
- Yeah, exactly.


00:35:22.100 --> 00:35:23.340
I was gonna say, Brian, you probably,


00:35:23.340 --> 00:35:25.180
this is kind of in your world, right?


00:35:25.180 --> 00:35:27.340
like dealing with time as a dependency?


00:35:27.340 --> 00:35:31.980
>> Definitely. Sometimes you want it fixed


00:35:31.980 --> 00:35:33.900
because you really want fixed answers because


00:35:33.900 --> 00:35:36.620
like your timestamps and stuff are in your data.


00:35:36.620 --> 00:35:37.900
You're going to have to, I mean,


00:35:37.900 --> 00:35:40.900
it's good to compare against known oracles.


00:35:40.900 --> 00:35:43.820
But there's also times where you,


00:35:43.820 --> 00:35:47.220
and this is where FreezeGAN isn't so bad,


00:35:47.220 --> 00:35:49.620
but maybe this would be really useful too,


00:35:49.620 --> 00:35:52.480
is if you want to test certain things.


00:35:52.480 --> 00:35:53.720
There's weird quirky dates,


00:35:53.720 --> 00:35:56.640
you want to make sure that your software deals with certain times.


00:35:56.640 --> 00:35:59.200
Fine. Does it work fine when it's running


00:35:59.200 --> 00:36:03.360
overnight on December 31st to January 1st,


00:36:03.360 --> 00:36:05.920
things like that when the year changes and things like that.


00:36:05.920 --> 00:36:06.960
>> Exactly.


00:36:06.960 --> 00:36:07.840
>> Yeah.


00:36:07.840 --> 00:36:10.560
>> You always want to test your boundary conditions,


00:36:10.560 --> 00:36:15.720
and crossing over time or weird cases like March 29th, stuff like that.


00:36:15.720 --> 00:36:18.520
You're like, let me just try that and see if this is going to survive.


00:36:18.520 --> 00:36:22.040
>> Yeah. But then to be fair,


00:36:22.040 --> 00:36:25.480
I think most of the time, things like this are used are,


00:36:25.480 --> 00:36:29.480
like was brought up is that the time shows up in the data.


00:36:29.480 --> 00:36:32.640
In order to compare the log or something,


00:36:32.640 --> 00:36:34.960
in order to compare those apples to apples,


00:36:34.960 --> 00:36:36.880
it's nice to have the same dates there.


00:36:36.880 --> 00:36:39.720
I can't tell you how many times I've had to compare


00:36:39.720 --> 00:36:44.120
two log files and strip out the times because those are the,


00:36:44.120 --> 00:36:47.800
every line is different because the timestamp is different.


00:36:47.800 --> 00:36:50.520
>> Yeah, very cool. Nice find.


00:36:50.520 --> 00:36:52.280
So that's all for time machine.


00:36:52.280 --> 00:36:53.520
>> Yeah, super.


00:36:53.520 --> 00:36:57.200
>> Well, that's our six items, everybody.


00:36:57.200 --> 00:36:59.160
Have you got anything extra, Michael?


00:36:59.160 --> 00:37:02.320
>> Well, I have the old thing that is new again.


00:37:02.320 --> 00:37:04.200
Let's see. I have some bandits.


00:37:04.200 --> 00:37:07.560
So the drama around


00:37:07.560 --> 00:37:11.640
supply chain vulnerabilities and open source repositories goes on.


00:37:11.640 --> 00:37:14.400
So this one, I think actually,


00:37:14.400 --> 00:37:16.440
the other article I'm going to talk about,


00:37:16.440 --> 00:37:18.640
comes to us from Joe Ridley.


00:37:18.640 --> 00:37:19.820
Thank you, Joe, for sending that in.


00:37:19.820 --> 00:37:24.060
But basically there's some more malicious things


00:37:24.060 --> 00:37:27.220
in PyPI again, and people just remind everyone


00:37:27.220 --> 00:37:29.980
to be careful and be white list stuff.


00:37:29.980 --> 00:37:33.000
Yeah, this one, I don't know what this one was.


00:37:33.000 --> 00:37:35.260
If it was typo squatting this time around


00:37:35.260 --> 00:37:37.940
or it was just something else that got put up there.


00:37:37.940 --> 00:37:41.340
Yeah, there's one headline is credit card stealing malware


00:37:41.340 --> 00:37:43.580
found in official Python repository.


00:37:43.580 --> 00:37:45.740
And the other one is the same one


00:37:45.740 --> 00:37:48.140
about our technical article says software downloaded


00:37:48.140 --> 00:37:51.580
30,000 times from PyPI ransacks developer machines,


00:37:51.580 --> 00:37:52.780
developers machines,


00:37:52.780 --> 00:37:55.300
expect to see more of these Frankenstein type things


00:37:55.300 --> 00:37:57.580
'cause it'd say basically a systemic threat,


00:37:57.580 --> 00:37:59.620
like how does it get dealt with?


00:37:59.620 --> 00:38:01.100
Right, I'm not sure if they list out.


00:38:01.100 --> 00:38:04.460
Yeah, so they used, they did interesting stuff as well.


00:38:04.460 --> 00:38:07.300
Like they did simple obfuscation of the code


00:38:07.300 --> 00:38:08.300
that was being run.


00:38:08.300 --> 00:38:09.820
So you couldn't look at it and, you know,


00:38:09.820 --> 00:38:12.700
say look for a credit card or look for a Bitcoin wallet


00:38:12.700 --> 00:38:15.340
and then go do your evil deeds in Python source code.


00:38:15.340 --> 00:38:19.820
So they would do things like base 64 and code the Python code


00:38:19.820 --> 00:38:23.100
and then just in memory, decode it, then run it.


00:38:23.100 --> 00:38:25.060
So they were trying to get around things like that.


00:38:25.060 --> 00:38:27.740
So anyway, people can check that out.


00:38:27.740 --> 00:38:31.160
And it's not ideal, but just a reminder to beware.


00:38:31.160 --> 00:38:33.060
- Yuck.


00:38:33.060 --> 00:38:34.540
- Yuck, yuck, yuck.


00:38:34.540 --> 00:38:35.700
This is why we can't have nice things.


00:38:35.700 --> 00:38:36.540
Come on, people.


00:38:36.540 --> 00:38:37.540
- This is why we can't have nice things.


00:38:37.540 --> 00:38:40.780
Well, I got a couple of things I wanted to bring up,


00:38:40.780 --> 00:38:42.460
just things I've been up to.


00:38:42.460 --> 00:38:46.620
just released episode 162 of Test and Code.


00:38:46.620 --> 00:38:50.020
I run through all the different flavors


00:38:50.020 --> 00:38:52.460
of test-driven development that I know of.


00:38:52.460 --> 00:38:54.660
There are quite a few versions.


00:38:54.660 --> 00:38:57.500
Check it out if you're interested in test-driven development.


00:38:57.500 --> 00:39:00.180
Then I'm just working on wrapping up


00:39:00.180 --> 00:39:02.740
the talks and continuous integration chapter


00:39:02.740 --> 00:39:05.060
for the second edition of the pytest.


00:39:05.060 --> 00:39:06.860
It'll be coming out hopefully within a week.


00:39:06.860 --> 00:39:08.780
>> Very cool. Good to see you making progress there.


00:39:08.780 --> 00:39:11.020
>> Do you have anything extra, Juanpe?


00:39:11.020 --> 00:39:12.920
>> No, not from my side.


00:39:12.920 --> 00:39:14.600
I'm very happy to be here.


00:39:14.600 --> 00:39:15.900
>> Let's go to a joke.


00:39:15.900 --> 00:39:17.500
>> Yeah, it's good to have you here. All right.


00:39:17.500 --> 00:39:20.220
Let's go to a joke. So this one's a visual.


00:39:20.220 --> 00:39:22.600
If you're listening,


00:39:22.600 --> 00:39:24.540
you're going to have to scroll down


00:39:24.540 --> 00:39:26.660
to your podcast show notes at the bottom.


00:39:26.660 --> 00:39:27.840
Just click on the joke link.


00:39:27.840 --> 00:39:30.440
One of the things you guys I like about Python


00:39:30.440 --> 00:39:33.720
is there's a lot of stability in the code that we write.


00:39:33.720 --> 00:39:36.380
If I wrote something on Flask five years ago,


00:39:36.380 --> 00:39:37.580
chances are it'll still run.


00:39:37.580 --> 00:39:38.980
If I write my Python code now,


00:39:38.980 --> 00:39:40.220
it's probably still going to run.


00:39:40.220 --> 00:39:41.180
Yeah, there's new things.


00:39:41.180 --> 00:39:44.860
There's new shiny visualization frameworks and stuff, but generally it's pretty stable.


00:39:44.860 --> 00:39:46.540
You know, what is the opposite of that?


00:39:46.540 --> 00:39:47.340
JavaScript.


00:39:47.340 --> 00:39:52.460
So, so here's a little animation say, and it says JavaScript developer


00:39:52.460 --> 00:39:54.180
bouncing from framework to framework.


00:39:54.180 --> 00:39:58.700
And it's this incredible, like almost people are awesome type of thing where


00:39:58.700 --> 00:40:03.740
somebody set up, you know, 50 workout balls on a running track, the whole


00:40:03.740 --> 00:40:06.180
straight of a quarter mile running track.


00:40:06.180 --> 00:40:10.700
and somebody jumps on it and just like glides from one to the next.


00:40:10.700 --> 00:40:11.300
What do you all think?


00:40:11.300 --> 00:40:14.900
>> The fact that he's able to do this is surprising.


00:40:14.900 --> 00:40:17.620
>> It's really impressive that he pulls it off.


00:40:17.620 --> 00:40:21.860
It's on one of these like sandy, gritty running tracks.


00:40:21.860 --> 00:40:23.780
It's going to hurt like crazy if he misses it.


00:40:23.780 --> 00:40:26.180
So maybe there's the motivation.


00:40:26.180 --> 00:40:30.900
>> Yeah. I remember the GenBrain report you said before,


00:40:30.900 --> 00:40:32.580
I was thinking, I didn't say anything,


00:40:32.580 --> 00:40:34.620
but I didn't want to mean what you're saying.


00:40:34.620 --> 00:40:36.620
How likely are you to change languages?


00:40:36.620 --> 00:40:37.980
And it was like, we're JavaScript.


00:40:37.980 --> 00:40:39.260
They're going to change a lot.


00:40:39.260 --> 00:40:42.540
Then I thought, oh, they're languages, not frameworks.


00:40:42.540 --> 00:40:43.380
- Exactly.


00:40:43.380 --> 00:40:45.420
How likely are you to change your framework?


00:40:45.420 --> 00:40:48.180
Well, that's like, nearly a hundred percent.


00:40:48.180 --> 00:40:50.820
- Yeah, that's true.


00:40:50.820 --> 00:40:52.460
I mean, people stick around like,


00:40:52.460 --> 00:40:55.820
you got Django developers have been doing it for years.


00:40:55.820 --> 00:40:57.900
- Yeah, 10 years and they're more excited today


00:40:57.900 --> 00:40:58.860
than ever about it, right?


00:40:58.860 --> 00:41:00.100
They're not like, we're ditching this.


00:41:00.100 --> 00:41:01.180
- Yeah.


00:41:01.180 --> 00:41:03.420
- All right, well, that's, does that count?


00:41:03.420 --> 00:41:04.460
Does that count as a joke?


00:41:04.460 --> 00:41:04.960
>> Yeah.


00:41:04.960 --> 00:41:06.420
>> I laughed.


00:41:06.420 --> 00:41:09.360
>> All right, perfect. Well, that's what I brought for you all.


00:41:09.360 --> 00:41:14.180
>> Well, thanks everyone for showing up and had a fun day today.


00:41:14.180 --> 00:41:15.220
Hope everybody else did.


00:41:15.220 --> 00:41:16.380
>> Thanks a lot for having me here.


00:41:16.380 --> 00:41:18.380
>> Thanks, Brian, and thanks for being with us, Pompeii.


00:41:18.380 --> 00:41:18.820
>> Bye.


00:41:18.820 --> 00:41:19.540
>> Bye-bye.


00:41:19.540 --> 00:41:21.260
>> Thanks for listening to Python Bytes.


00:41:21.260 --> 00:41:24.020
Follow the show on Twitter via @PythonBytes.


00:41:24.020 --> 00:41:27.040
That's Python Bytes as in B-Y-T-E-S.


00:41:27.040 --> 00:41:29.780
Get the full show notes over at PythonBytes.fm.


00:41:29.780 --> 00:41:31.740
If you have a news item we should cover,


00:41:31.740 --> 00:41:34.940
just visit pythonbytes.fm and click submit in the nav bar.


00:41:34.940 --> 00:41:37.100
We're always on the lookout for sharing something cool.


00:41:37.100 --> 00:41:38.980
If you want to join us for the live recording,


00:41:38.980 --> 00:41:44.340
just visit the website and click "Live Stream" to get notified of when our next episode goes live.


00:41:44.340 --> 00:41:48.620
That's usually happening at noon Pacific on Wednesdays over at YouTube.


00:41:48.620 --> 00:41:52.020
On behalf of myself and Brian Auken, this is Michael Kennedy.


00:41:52.020 --> 00:41:55.660
Thank you for listening and sharing this podcast with your friends and colleagues.

