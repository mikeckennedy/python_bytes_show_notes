WEBVTT

00:00:00.001 --> 00:00:04.120
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to

00:00:04.120 --> 00:00:10.020
your earbuds. This is episode 220, recorded February 10th, 2021. I'm Michael Kennedy.

00:00:10.020 --> 00:00:11.000
I'm Brian Okken.

00:00:11.000 --> 00:00:12.540
And we have a special guest, Hannah. Welcome.

00:00:12.540 --> 00:00:13.220
Hello.

00:00:13.220 --> 00:00:16.900
Hannah Stepnick, welcome to the show. It is so great to have you here.

00:00:16.900 --> 00:00:18.900
Thank you. I'm happy to be here.

00:00:18.900 --> 00:00:23.000
Yeah, it's good to have you. It's so cool. The internet is a global place. We can have

00:00:23.000 --> 00:00:26.500
people from all over. So we've decided to make it an all Portland show this time.

00:00:27.060 --> 00:00:30.720
We could do this in person, actually. Well, not really, because we can't go anywhere. But

00:00:30.720 --> 00:00:35.080
theoretically, geographically, anyway. Yeah, so all three of us are from Portland, Oregon. Very nice.

00:00:35.080 --> 00:00:41.240
Before we jump into the main topics, a few quick things. One, this episode is brought to you by

00:00:41.240 --> 00:00:45.860
Datadog. Check them out at Pythonbytes.fm.datadog. And Hannah, do you just want to give people a quick

00:00:45.860 --> 00:00:47.120
background on yourself?

00:00:47.120 --> 00:00:56.760
Yeah, so I'm Hannah. I have written a book, which is weird to say, about pandas. But I also just go

00:00:56.760 --> 00:01:03.900
around, like, give talks at various conferences, like on Python. So yeah, like I gave re-architecting

00:01:03.900 --> 00:01:05.040
legacy code base recently.

00:01:05.040 --> 00:01:06.760
That sounds interesting and challenging.

00:01:06.760 --> 00:01:07.080
Yeah.

00:01:07.080 --> 00:01:10.440
What was the legacy language? Was it Python or something?

00:01:10.440 --> 00:01:18.860
It was Python. It was like a Flask web application. And then also the front end of it was Vue, like

00:01:18.860 --> 00:01:19.480
Vue.js.

00:01:19.480 --> 00:01:20.140
Oh, yeah.

00:01:20.140 --> 00:01:26.120
So yeah, that's been a fun project. That was through work as developers. Like, you're pretty much always

00:01:26.120 --> 00:01:30.460
working with some form of legacy code. Just depends on how legacy it really is.

00:01:30.460 --> 00:01:36.000
Well, what could be cutting edge in one person's viewpoint might be super legacy in another, right?

00:01:36.000 --> 00:01:38.800
Like, it's Python 3.5. You wouldn't believe it.

00:01:38.800 --> 00:01:39.940
Right.

00:01:39.940 --> 00:01:46.260
Yeah. Very cool. Well, it's great to have you here. I think maybe we'll start off with our

00:01:46.260 --> 00:01:51.300
first topic, which is sort of along the lines of the data science world, some tie-ins to your book.

00:01:51.300 --> 00:01:56.460
And of course, whenever you go to JetBrains, you've got to run your CLI to accept the cookies,

00:01:56.460 --> 00:02:02.520
which is fantastic. And so this topic, this first topic I want to cover is from JetBrains. And it's

00:02:02.520 --> 00:02:08.160
entitled, we downloaded 10 million Jupyter notebooks. I almost said 10,000. 10 million Jupyter notebooks

00:02:08.160 --> 00:02:14.360
from GitHub. Here's what we learned. So this is an article or analysis done by Elena, who's a Harina.

00:02:14.360 --> 00:02:20.160
And yeah, pretty neat. So they went through and downloaded a whole bunch of these notebooks and

00:02:20.160 --> 00:02:25.520
just analyzed them. And there's many, many of them are publicly accessible. And a couple of years ago,

00:02:25.520 --> 00:02:33.020
there were 1.2 million Jupyter notebooks that were public. As of last October, it was eight times as

00:02:33.020 --> 00:02:37.660
many. 9.7 million notebooks available on GitHub. That's crazy, right?

00:02:37.660 --> 00:02:38.120
Wow.

00:02:38.120 --> 00:02:43.460
Yeah. So this is a bunch of really nice pictures and interactive graphs and stuff. So I encourage

00:02:43.460 --> 00:02:49.040
people to go check out the webpage. So for example, one of the questions was, well, what language do you

00:02:49.040 --> 00:02:54.280
think is the most popular for data science, just by judging on the main language of the notebook?

00:02:54.280 --> 00:02:55.200
Anna, you want to take a guess?

00:02:55.200 --> 00:02:58.020
Oh yeah. Python, for sure. Without a doubt.

00:02:58.020 --> 00:03:05.740
That's for sure. The second one, I'm pretty sure no one who's not seen this, there's no way they're

00:03:05.740 --> 00:03:13.480
going to guess. It's Nan. We have no idea. Like we look, we can't tell what language this is in there.

00:03:13.480 --> 00:03:18.060
But then the other contenders are R and Julia. And often people say, oh yeah, well, Julia,

00:03:18.060 --> 00:03:22.640
maybe I should go to Julia from Python. Well, maybe, but that's not where the trends are. Like

00:03:22.640 --> 00:03:26.920
there's 60,000 versus 9 million, you know, as the ratio, I don't know what that number is,

00:03:26.920 --> 00:03:29.660
but it's a percent of a percent type of thing. Wow.

00:03:29.660 --> 00:03:37.000
They also talk about the Python two versus three growth or different. So in 2008, it was about 50%

00:03:37.000 --> 00:03:43.380
was Python two. And in 2020, it's a Python two is down to 11%. And I was thinking about this 11%.

00:03:43.380 --> 00:03:47.180
Like, why do you guys think people, there's still 11% there hanging around?

00:03:47.180 --> 00:03:53.120
I mean, I would guess, speaking of legacy applications, probably it's just hasn't been

00:03:53.120 --> 00:03:59.980
touched, but yeah. Yeah. Those are very likely the ones that were like the original 2016, 17 ones that

00:03:59.980 --> 00:04:04.640
were not quite there. They're still public, right? GitHub doesn't get rid of them. The other one is I

00:04:04.640 --> 00:04:10.040
was thinking, you know, a lot of people do work on Mac or maybe even on some Linux machines that just

00:04:10.040 --> 00:04:13.620
came at the time with Python two. So they're just like, well, I'm not going to change anything. It just,

00:04:13.620 --> 00:04:17.560
I just need to view this thing. I don't have Python problem solved, right? They didn't know

00:04:17.560 --> 00:04:21.540
that there's more, more than one Python. There's a good breakdown of the different versions. Another

00:04:21.540 --> 00:04:27.260
thing that's interesting is looking at the different languages, not language, different libraries used

00:04:27.260 --> 00:04:32.660
during this. So like NumPy is by far the most likely used. And then a tie is pandas and matplotlib,

00:04:32.660 --> 00:04:37.340
and then scikit-learn, and then OS actually for traversing stuff. And then there's a huge long tail.

00:04:37.340 --> 00:04:41.680
And they also talk about combinations like pandas and NumPy are common, and then pandas,

00:04:41.680 --> 00:04:46.620
and then like seaborn, scikit-learn, pandas, NumPy, matplotlib, and so on as a combo. And so

00:04:46.620 --> 00:04:51.100
that's really interesting, like what sets of tools data scientists are using. Yeah. And then another

00:04:51.100 --> 00:04:56.740
one is they looked at deep learning libraries and PyTorch seems to be crushing it in terms of growth,

00:04:56.740 --> 00:05:03.660
but not necessarily in terms of popularity. So it grew 1.3 times or 130%, whereas TensorFlow is more

00:05:03.660 --> 00:05:07.960
popular, but only grew 30% and so on. So there's a lot of these types of statistics in there. I think

00:05:07.960 --> 00:05:12.720
people will find interesting if they want to dive more into this ecosystem. You know, it's one thing

00:05:12.720 --> 00:05:17.320
to have survey and go fill out the survey, like ask people, what do you use? You know, what platform do

00:05:17.320 --> 00:05:21.880
you run on? Vue.js or Linux? Like, okay, well, that's not really a reasonable question, but I guess

00:05:21.880 --> 00:05:26.320
Vue.js, you know, like, but if you just go and look at what they're actually doing on places like

00:05:26.320 --> 00:05:31.060
GitHub, I think you can get a lot of insight. Yeah, for sure. Yeah, I know I use, like I'll go to GitHub

00:05:31.060 --> 00:05:36.100
pretty frequently, like at work when I'm, you know, just like browsing, like, I wonder how you do this

00:05:36.100 --> 00:05:40.380
thing or like, what's the most common way to do this? Or yeah, absolutely. There's just look up,

00:05:40.380 --> 00:05:44.760
like, what's the most popular. So it's a pretty good sign if a lot of people are using it.

00:05:44.760 --> 00:05:49.200
It is. One thing I should probably make more better use of is I know they started adding dependencies,

00:05:49.200 --> 00:05:54.600
like, oh, if you go to Flask, it'll show you Flask is used in these other GitHub repos and stuff.

00:05:54.600 --> 00:05:58.640
Like you could find interesting little connections. I think, oh, this other project uses this cool

00:05:58.640 --> 00:06:01.840
library. I know nothing about, but if they're using it, it's probably good. Yeah, for sure.

00:06:01.840 --> 00:06:07.040
Yeah. I love the dependency feature of looking who's using it. It's neat. Yeah, absolutely. So,

00:06:07.040 --> 00:06:11.120
Brian, you going to cover something on testing this time? Yeah. Will we make you?

00:06:11.120 --> 00:06:19.380
I wanted to bring up something we brought up before. So there's a project called pytest Python Path,

00:06:19.380 --> 00:06:27.860
and it's just a little tiny plugin for pytest. And we did cover it briefly in way back in episode 62,

00:06:27.860 --> 00:06:34.320
two. But at the time I brought it up as, so, okay. So the, I brought it up as a way to, to,

00:06:34.320 --> 00:06:42.040
to just shim, like be able to have your test code, see your source code, but as just like a shortcut,

00:06:42.040 --> 00:06:47.780
like a stop gap until you actually put together like proper packaging for your source code. But the

00:06:47.780 --> 00:06:54.820
more I talked to real life people were testing all sorts of software and hardware, even there's,

00:06:55.160 --> 00:07:00.160
there that that's a simplistic view of the world. So thinking of everybody is working on,

00:07:00.160 --> 00:07:07.420
on packages is, is not real. There's applications for instance, that, that they're never going to set

00:07:07.420 --> 00:07:13.760
up, pull their code together as a package. And that's, that's, that's legitimate. So if you have an

00:07:13.760 --> 00:07:18.540
application and your, your source code is in your source directory and your test code is in your test

00:07:18.540 --> 00:07:23.800
directory, it's just, your tests are just not going to be able to see your source code right off

00:07:23.800 --> 00:07:30.100
the bat. So what's more, tricky is depending on how you run it, they will, or they won't.

00:07:30.100 --> 00:07:34.320
Yeah. Right. Right. If you say run it with PyCharm and you open up the whole thing and it can like put

00:07:34.320 --> 00:07:38.260
together the past, you're all good. But if you then just go into the directory and type pytest, well,

00:07:38.260 --> 00:07:38.860
maybe not.

00:07:38.860 --> 00:07:44.280
It doesn't work. And it just confuses a lot of people. And so more and more, I'm recommending people

00:07:44.280 --> 00:07:52.960
use this, this little plugin and really, the, the, the big benefit is it gives you there's,

00:07:52.960 --> 00:08:00.000
there's, there's a, it does a few things, but the big biggie is just, you can add a Python path,

00:08:00.000 --> 00:08:05.940
uh, setting within your pytest, any file, and you stick your, any file at the top of your project.

00:08:05.940 --> 00:08:11.140
And then you just give it a relative path to where your source code is like source or SRC

00:08:11.140 --> 00:08:17.200
or something else. And then pytest from then on, we'll be able to see your source code.

00:08:17.200 --> 00:08:23.100
It's a really simple solution. It's just, I, I, that's way better than what I do.

00:08:23.100 --> 00:08:27.920
I don't think it's a stop gap. I think it's awesome. So yeah, I totally agree. What I do a lot of times

00:08:27.920 --> 00:08:32.960
is certain parts of my code. I'm like, this is going to get imported. For me, the real tricky thing is

00:08:32.960 --> 00:08:39.180
a limbic, the database, database migration tool and the tests and the web app. And usually I can get the

00:08:39.180 --> 00:08:43.200
tests and the web app to work just fine running them directly. But for some reason, a limbic always

00:08:43.200 --> 00:08:47.580
seems to get weird, like working directories that don't line up in the same way. So it can't import

00:08:47.580 --> 00:08:54.020
stuff. So a lot of times I'll put at the top of some file, you know, go to the Python path and add,

00:08:54.020 --> 00:09:00.260
you know, get the directory name from dunder file and go to the parent, add that to the Python path.

00:09:00.260 --> 00:09:05.260
And now it's going to work from then on basically. And, this seems like a nicer one, although it doesn't

00:09:05.260 --> 00:09:11.860
help me with the limbic, but still, but it, it might, you might be able to add the limbic path right to it.

00:09:11.860 --> 00:09:14.980
So yeah, yeah, for sure. Very cool. So it says, yeah, go ahead, Hannah.

00:09:14.980 --> 00:09:19.700
Oh, I was just going to say, yeah, like this is something I like pretty much every time I set up a new project.

00:09:19.700 --> 00:09:25.840
Like I always have to screw with the Python path. I always like run it initially. And then it's like, Oh,

00:09:25.840 --> 00:09:28.360
can't find blah, blah, blah. And I'm like, Oh, here we go again.

00:09:28.360 --> 00:09:35.560
But I usually always run my projects from Docker though. So I just, you know, hard code that stuff,

00:09:35.560 --> 00:09:41.520
like just once you get it set up. That's cool. Nice. I dream of days when I can use Docker again,

00:09:41.520 --> 00:09:47.980
have an M one Mac and it's in super early, early beta stages. Yeah. It's okay. I don't,

00:09:47.980 --> 00:09:51.000
I don't mind too much because I don't use it that much, but still cool. Brian,

00:09:51.000 --> 00:09:55.700
it says something about dot PTH. I'm guessing path files. What do you know anything about this?

00:09:55.700 --> 00:10:01.040
I have no idea what those are. Oh, dot PTH files. So there's yeah, there's there.

00:10:01.040 --> 00:10:07.620
There are a way to, I don't know a lot. I don't know the detail, the real big details, but it's,

00:10:07.620 --> 00:10:15.360
it's a way to have a you can have a list of different paths when it, within that file. And if you import it

00:10:15.700 --> 00:10:22.060
or don't import it, if you include it in your path, then Python, I think includes all of the

00:10:22.060 --> 00:10:26.820
contents into anyway, I'm actually, I'm blowing smoke. I don't know the details. Okay. Sorry.

00:10:26.820 --> 00:10:30.980
Yeah. But apparently you can have a little more control with TH files, whatever those are.

00:10:30.980 --> 00:10:34.840
Yeah. I don't know much about that either. Yeah. Unfortunately. I mean, I've been using

00:10:34.840 --> 00:10:40.700
OS dot path. So what do I know? All right. Speaking of what do I know? I could definitely learn more

00:10:40.700 --> 00:10:48.160
about pandas and that's one of your items here, huh? Hannah? Yeah. So I thought maybe I just give

00:10:48.160 --> 00:10:55.960
like a little snippet of kind of like some of the stuff I talk about in the book. Fantastic. So yeah,

00:10:55.960 --> 00:11:03.700
here we go. So if we're looking at pandas in terms of like the dependency hierarchy, well,

00:11:03.740 --> 00:11:08.240
and I guess I should start at the beginning. So what is pandas if you're not familiar with it?

00:11:08.240 --> 00:11:16.280
It's a data analysis library for Python. So it's used for doing big data operations. And so like,

00:11:16.280 --> 00:11:21.380
if we look at the dependency hierarchy of pandas, it kind of goes like pandas, which is dependent on

00:11:21.380 --> 00:11:28.600
numpy, which deep down is dependent on this thing called BLOS, which is basic linear algebra subprograms.

00:11:28.600 --> 00:11:33.560
Right. And wasn't there something with BLOS and a Windows and a Windows update in a certain version,

00:11:33.560 --> 00:11:37.500
I think recently? I can't remember. I feel like there was some update that like made that thing

00:11:37.500 --> 00:11:42.300
that wasn't working. Yeah. Usually a big challenge around numpy and versioning and stuff to make it

00:11:42.300 --> 00:11:49.200
work in the short term. Yeah. Usually the BLOS library is built into your OS already. And it just

00:11:49.200 --> 00:11:55.980
points at that. But if you're using something like Anaconda, I think by default, like it installs

00:11:55.980 --> 00:12:01.800
Intel MLK and uses that. But yeah, if you're using like Linux or just like out of the box,

00:12:01.800 --> 00:12:06.760
whatever's on Windows, which is what it is, if you like pip install it, then yeah, there could

00:12:06.760 --> 00:12:15.780
certainly be issues with like dependencies mismatches. Yeah. So, and I've like greatly simplified this,

00:12:15.780 --> 00:12:22.120
but in terms of kind of like the languages and walking down that dependency hierarchy,

00:12:22.620 --> 00:12:31.180
you start out in Python with pandas and then numpy is partially Python and partially C and then BLOS is

00:12:31.180 --> 00:12:35.780
pretty much always written in assembly. And if you don't know what assembly is, it's basically like a

00:12:35.780 --> 00:12:40.380
very, very, very, like probably the lowest level language you can program in. And it's essentially

00:12:40.380 --> 00:12:48.820
like CPU instructions for your processor. And so I've taken this just like basic example here and I'm

00:12:48.820 --> 00:12:56.540
going to kind of like roll with it. So if we're doing just like a basic addition in pandas, say like

00:12:56.540 --> 00:13:01.580
we have column A and we want to add that with column B and like store it back into column C.

00:13:01.580 --> 00:13:05.080
Like a traditional linear algebra vector addition type thing.

00:13:05.080 --> 00:13:13.040
Traditional vector math. So pandas, like if you, if you look at these operations, each,

00:13:13.040 --> 00:13:20.320
each of these like additions on a per row basis is independent, meaning like you could conceivably run

00:13:20.320 --> 00:13:25.720
like each of those additions for each row, like in parallel. Like there's no reason why you have to go

00:13:25.720 --> 00:13:32.020
like row by row. and that's essentially like what kind of like big data analysis libraries are

00:13:32.020 --> 00:13:38.240
like at their core is they, they like understand this conceptually and try to parallelize things as

00:13:38.240 --> 00:13:42.600
much as possible. and so that's kind of like the first like fundamental understanding that you have

00:13:42.600 --> 00:13:47.020
to have, like when working with pandas is like, you should be doing things in parallel as much as you

00:13:47.020 --> 00:13:51.920
can. which means understanding the API and understanding like which functions in the API

00:13:51.920 --> 00:13:59.140
will let you do things in parallel. so like if we're just not using pandas at all, say like

00:13:59.140 --> 00:14:04.380
we're just inventing our own sort of like technique for this, like you might think, well, like each of

00:14:04.380 --> 00:14:09.060
these rows could be broken up like into a thread, right? So like we could say like thread one is going to

00:14:09.060 --> 00:14:14.420
run like the first row addition. And then like thread two is going to run the second row, et cetera.

00:14:14.420 --> 00:14:21.800
but you might find that we'll run into issues with this, in terms of the gill. So like the gill

00:14:21.800 --> 00:14:27.340
is now otherwise known as the global interpreter lock in Python, prevents us from really like

00:14:27.340 --> 00:14:35.660
running a multi-threaded app, operation, like in parallel. basically Python can run the rule

00:14:35.660 --> 00:14:41.980
is it can run one Python op code at a time and that's it. All right. It doesn't matter if you've

00:14:41.980 --> 00:14:49.620
got, you know, 16 cores, it's one at a time. Yeah. Yeah. And this like is really terrible for,

00:14:50.100 --> 00:14:56.060
yeah. For, for like trying to do things in parallel. Right. So like that, that kind of

00:14:56.060 --> 00:15:01.000
use cases out, like pandas and numpy and, and all that stuff is, is not going to be able to use

00:15:01.000 --> 00:15:10.780
multi-threading. and so, and like, I just want to point out like Python, like at its core has

00:15:10.780 --> 00:15:17.860
this like fundamental problem, which is why they went with the gill. So like Python manages memory for you.

00:15:17.980 --> 00:15:26.580
Um, and it, how it does that is it keeps track of references to know when to, free up memory.

00:15:26.580 --> 00:15:33.100
Uh, so like when memory can be like completely destroyed and somebody else can use it essentially.

00:15:33.100 --> 00:15:37.500
Um, and like that's something you've got to do stuff like Brian sometimes probably has to do with C and

00:15:37.500 --> 00:15:43.400
like free and all those things. Right. Yeah, exactly. Yeah. Yeah. So like C, you have to do this with

00:15:43.400 --> 00:15:49.160
yourself with like Malik and free and all that stuff. But, with Python, it does it for you,

00:15:49.160 --> 00:15:54.100
but that comes at a cost, which means like every single object in Python has this little like counter,

00:15:54.100 --> 00:16:00.700
which is like a reference counter. and so basically like way back in the day, like when

00:16:00.700 --> 00:16:07.520
threading first became a thing, like in order to kind of like avoid this threading problem,

00:16:07.520 --> 00:16:13.440
um, they came up with the gill, which basically says you can only run one third at a time or like

00:16:13.440 --> 00:16:15.500
one opcode at a time as, as you said.

00:16:15.500 --> 00:16:20.080
And attempts have been made to remove it. Like Larry Hastings has been working on something

00:16:20.080 --> 00:16:25.980
called the galectomy, the removal of the GIL for a while. And the main problem is, if you take

00:16:25.980 --> 00:16:30.740
it away, the way it works now is you have to do lock on all memory access, all variable access,

00:16:30.740 --> 00:16:35.040
which actually has a bigger hit than a lot of the benefits you would get, at least in the single

00:16:35.040 --> 00:16:39.420
threaded case. And I know Peter said like, if we really don't want to make changes to this,

00:16:39.420 --> 00:16:42.840
if it's going to mean slower, single threaded Python, they'll probably not for a while.

00:16:43.260 --> 00:16:49.900
Yeah. Yeah. Yeah. And that, that is a big problem. So like, I mean, if generally what people use,

00:16:49.900 --> 00:16:55.020
like instead of threads in Python is they use like multi-process and they spin up multiple Python

00:16:55.020 --> 00:17:01.820
processes. Right. And like that truly kind of like achieves the parallelism. but anyways,

00:17:01.820 --> 00:17:10.380
I digress. so, so we can't use the gill, but what's interesting to note is when you're,

00:17:10.380 --> 00:17:16.140
uh, running NumPy at its very low level in C, like when you enter and look at the C files,

00:17:16.140 --> 00:17:21.340
it actually is not subject to the GIL anymore because you're in C. and so you can potentially

00:17:21.340 --> 00:17:30.300
run, you know, multi-threaded things in C, and call it from Python. so, but beyond that,

00:17:31.020 --> 00:17:38.220
if we look at BLOS, BLOS has, built in like parallelization for like, hardware parallelization.

00:17:38.220 --> 00:17:46.380
Um, and how it does that is through vector registers. so if you're not familiar with like the

00:17:46.380 --> 00:17:53.340
architecture of CPUs and stuff, like at its core, you basically, only have like, only can

00:17:53.340 --> 00:18:00.300
have a certain small set, maybe like three or four values in your CPU at any one time that you're running

00:18:00.300 --> 00:18:07.500
like ads and multiplies on. and like how that works is you load those values like into the CPU from

00:18:07.500 --> 00:18:14.140
memory. And that load can be quite time consuming. It's really just based on like how far away your memory is from

00:18:14.140 --> 00:18:18.780
from your CPU at the end of the day, like physically on your board. Right. Right. Is it in the cache?

00:18:18.780 --> 00:18:24.780
Is it in the RAM? Yes. Yeah. And that's why we have caches. So like caches are like memory that's closer

00:18:24.780 --> 00:18:31.660
to your CPU. consequently it's also smaller. but that's, that's how you can kind of, you might hear

00:18:31.660 --> 00:18:37.340
like people say like, oh, like so-and-so wrote this really performant program and it like utilizes like the

00:18:37.340 --> 00:18:43.660
size of the cache or whatever. So like basically like if you can load all of that data, like into your cache and

00:18:43.660 --> 00:18:48.540
run the operations on it without ever like having to go back out to memory, like you can make a really

00:18:48.540 --> 00:18:53.500
fast program. Yeah. Yeah. It could be like a hundred times faster than regular memory. Yeah. Yeah. And so

00:18:53.500 --> 00:19:00.940
essentially like that's what, BLOS is trying to do like underneath and, and to NumPy is they're trying

00:19:00.940 --> 00:19:08.140
to take this giant set of data and break it into chunks and load those chunks into your cache and

00:19:08.140 --> 00:19:13.980
operate on those chunks. and then dump them back out to memory and load the next chunk.

00:19:13.980 --> 00:19:18.780
yeah, very cool. Yeah. Thanks for pointing that out. Like I didn't realize that BLOS leveraged some of

00:19:18.780 --> 00:19:24.620
the OS native stuff, nor that it had like special CPU instruction type optimizations. That's pretty cool.

00:19:24.620 --> 00:19:31.500
Yeah. Yeah. so like it has, like on top of the registers, it also has these things called

00:19:31.500 --> 00:19:38.060
like vector registers, which actually can hold like multiple values at a time in your CPU. so like,

00:19:38.060 --> 00:19:43.980
we could take this like simple example of, like the addition and we could actually, well, we can't

00:19:43.980 --> 00:19:51.180
run those like row per row calculations, in parallel with threads. We can with vector registers.

00:19:51.180 --> 00:19:57.660
Okay. and the limitation there is that the memory has to be, sequential when you load it in.

00:19:57.660 --> 00:20:01.180
Um, this is definitely at a level lower than I'm used to working at. How about you?

00:20:03.580 --> 00:20:08.620
But yeah, so, anyways, this is just like kind of the stuff that I talk about in my book.

00:20:08.620 --> 00:20:14.300
Um, it's not necessarily about like how to use pandas. but it's, it's about like kind of like

00:20:14.300 --> 00:20:18.780
what's going on underneath pandas. And then like, once you kind of like build that foundation of

00:20:18.780 --> 00:20:24.940
understanding, like you can understand like better how pandas is working and like how to use it correctly

00:20:24.940 --> 00:20:28.860
and what all the various functions are doing. Fantastic. Yeah. So people can check out your book.

00:20:28.860 --> 00:20:33.020
Got a link to it in the show notes. So, very nice. It's offering me the European,

00:20:33.020 --> 00:20:38.540
uh, the Euro price, which is fine. I don't mind. So yeah. So like, I mean, it's on Amazon too.

00:20:38.540 --> 00:20:43.500
It's on a lot of different platforms, but I figured I'd just point directly to the publishers.

00:20:43.500 --> 00:20:48.540
Yeah, no, that's perfect. Perfect. quick comment. Roy Larson says,

00:20:48.540 --> 00:20:54.780
NumPy and Intel MKL cause issues. Sometimes you could learn on windows. If something else in the system

00:20:54.780 --> 00:21:00.620
uses Intel MKL. Okay. Yeah. Interesting. I have no experience with that, but I can believe it. Intel

00:21:00.620 --> 00:21:04.700
has a lot of interesting stuff. They even have a special iPhone, compiled version,

00:21:04.700 --> 00:21:08.460
I think for Intel if you use potentially, I'm not sure they have some high performance version.

00:21:08.460 --> 00:21:10.940
Yeah. Yeah. Yeah, they do. Yeah.

00:21:10.940 --> 00:21:13.900
Nice. Also in Portland, you can keep it in Portland. There we go.

00:21:15.580 --> 00:21:19.660
Now, before we move on to the next item, let me tell you about our sponsor today.

00:21:19.660 --> 00:21:25.900
Thank you to data dog. So they're sponsoring data dog. And if you're having trouble visualizing latency,

00:21:25.900 --> 00:21:30.220
CPU, memory bottlenecks, things like that in your app, and you don't know why you don't know where it's

00:21:30.220 --> 00:21:35.020
coming from or how to solve it, you can use data dog to correlate logs and traces at the level of

00:21:35.020 --> 00:21:38.700
individual requests, allowing you to quickly troubleshoot your Python app. Plus they have

00:21:38.700 --> 00:21:44.220
a continuous profiler that allows you to find the most resource consuming parts of your production code

00:21:44.220 --> 00:21:47.740
all the time at any scale with minimal overhead. So you just point out your production

00:21:47.740 --> 00:21:51.980
server, run it, which is not normally something you want to do with diagnostic tools, but you can with

00:21:51.980 --> 00:21:56.060
their continuous profiler, which is pretty awesome. You'll be the hero that got that app back on track at

00:21:56.060 --> 00:22:01.020
your company, get started with a free trial at pythonbytes.fm/datadog, or just click the link in

00:22:01.020 --> 00:22:08.540
your podcast player show notes. Now, I'm sure you all have heard that working with pickle has all sorts

00:22:08.540 --> 00:22:13.900
of issues, right? The pickle is a way to say, take my Python thing, make a binary version of bits that

00:22:13.900 --> 00:22:19.740
looks like that Python thing so I can go do stuff with it, right? That's generally got issues, not the

00:22:19.740 --> 00:22:25.900
least of which actually are around the security stuff. So like you unpickle something to deserialize it,

00:22:25.900 --> 00:22:30.700
sit back is actually potentially running arbitrary code. So people could send you a pickle virus.

00:22:30.700 --> 00:22:34.620
I don't know what that is like a bad, a rotten pickle or whatever. That wouldn't be good.

00:22:34.620 --> 00:22:39.740
So there's a library I came across that solves a lot of the pickle problems.

00:22:39.740 --> 00:22:43.180
It's supposed to be faster than pickle and it was cleverly named quickle.

00:22:43.180 --> 00:22:46.700
Either of you heard of this thing?

00:22:46.700 --> 00:22:47.580
No.

00:22:47.580 --> 00:22:54.380
Yeah, it's cool, right? So here's the deal. It's a fast serialization format for a subset of Python types.

00:22:54.380 --> 00:22:59.180
So you can't pickle everything, but you can pickle like way more say than JSON. And the

00:22:59.180 --> 00:23:03.740
reasons they give to use it are it's fast. If you check out the benchmarks, I'll pull those up in a

00:23:03.740 --> 00:23:09.100
second. It's one of the fastest ways to serialize things in Python. It's safe, which is important.

00:23:09.100 --> 00:23:14.620
And unlike pickle deserializing a user provided message does not allow arbitrary code execution.

00:23:14.620 --> 00:23:19.660
That seems like the minimum bar. Like, oh, I got stuff off the internet. Let's try to execute that.

00:23:19.660 --> 00:23:22.940
What's that going to do? Oh, look, it's reading all my files. That's nice.

00:23:22.940 --> 00:23:23.900
All right.

00:23:23.900 --> 00:23:30.460
It also, it's a flexible because it supports more types. And we'll also learn about a bunch of other

00:23:30.460 --> 00:23:34.060
libraries while we're at it here, which is kind of cool. A bunch of things I heard of like

00:23:34.060 --> 00:23:39.260
MSG pack or well, Jason, you may have heard of that. And the other main problem you get with some

00:23:39.260 --> 00:23:44.300
of these binary formats is you can end up where in a situation where you can't read something.

00:23:44.300 --> 00:23:48.540
If you make a change your code, like, so imagine I've, I've got a user object and I've pickled them

00:23:48.540 --> 00:23:53.820
and put them into a Redis cache. We upgrade our web app, which adds a new field to the user object.

00:23:53.820 --> 00:23:58.540
That stuff is still in cache. After we restart, we try to read it. Oh, that stuff isn't there anymore.

00:23:58.540 --> 00:24:03.740
You can't, you know, user cache anymore. Everything's broken, et cetera, et cetera. So it has a concept of

00:24:03.740 --> 00:24:09.500
schema evolution, having different versions of like history. So there's ways that older messages can be

00:24:09.500 --> 00:24:14.380
read without errors, which is pretty cool. Yeah. That's nice. Yeah. Neat, huh? Yeah. I'll pull up the benchmarks.

00:24:14.380 --> 00:24:18.060
There's actually a pretty cool little site here. It shows you some examples on how to use it. I mean,

00:24:18.060 --> 00:24:22.380
it's incredibly simple. It's like, dump this as a string, read this, you know, deserialize this.

00:24:22.380 --> 00:24:29.100
It's real simple. So, but there's quite interesting analysis, live analysis where you can click around

00:24:29.100 --> 00:24:35.020
and you can actually look at like load speed versus reads like serialized versus deserialized speed,

00:24:35.020 --> 00:24:39.340
how much memory is used and things like that. And it compares against pickle tuples,

00:24:39.340 --> 00:24:44.620
protobuf, pickle itself, ORJSON, MSGPAC, quickle, and quicklestrux.

00:24:44.620 --> 00:24:48.860
There's a lot of things. I mean, I knew about two of those, I think. That's cool.

00:24:48.860 --> 00:24:52.540
But these are all different ways. And you can see, like in all these pictures, generally,

00:24:52.540 --> 00:24:57.020
at least the top one where it's time shorter is better. Right? So you can see if you go with

00:24:57.020 --> 00:25:02.140
there, like quicklestrux, it's quick rule of thumb, maybe four or five times faster than pickle,

00:25:02.140 --> 00:25:04.860
which I presume is a way faster than JSON, for example.

00:25:04.860 --> 00:25:09.420
You know, you'll also see the memory size, which actually varies by about 50% across the

00:25:09.420 --> 00:25:14.540
different things. Also speed of loading up a whole bunch of different objects and so on. So yeah,

00:25:14.540 --> 00:25:19.740
you can come check out these analysis here. Let's see all the different libraries that we had. Yeah,

00:25:19.740 --> 00:25:23.820
I guess we read them all off basically there, but yeah, there's a bunch of different ways which are,

00:25:23.820 --> 00:25:28.540
you know, not pickle itself to do this kind of binary serialization, which is pretty interesting.

00:25:28.540 --> 00:25:33.660
I think it does. Protobuf, that's pretty cool. Actually, I want to try this out. It looks neat.

00:25:33.660 --> 00:25:37.900
Yeah. Yeah, it looks really right. And one of the things I was just looking at the source code,

00:25:37.900 --> 00:25:45.660
I love that they use pytest to test this. Of course, you should use pytest. But the, I can't believe

00:25:45.660 --> 00:25:50.620
I'm saying this, but this would be the perfect package to test with a Gherkin syntax. Don't you think?

00:25:50.620 --> 00:25:54.860
Because it's a pickle thing. Oh my gosh. You've got to use the Gherkin syntax.

00:25:54.860 --> 00:26:02.620
So yeah, you definitely should. And Roy threw out another one like UQ foundation,

00:26:02.620 --> 00:26:07.900
Dill package deals with many of the same issues, but because it's binary and has all the same

00:26:07.900 --> 00:26:12.540
sort of versioning challenges you might run into. Well, Dill, the Dill package. That's funny.

00:26:12.540 --> 00:26:16.860
Yeah, pretty good. Pretty good. All right. So anyway, like, you know, I'm,

00:26:16.860 --> 00:26:22.380
I'm kind of a fan of JSON these days. I've had enough XML with custom namespaces in my life that

00:26:22.380 --> 00:26:27.500
I really don't want to go down that path and XSLT and all that. But, you know, I've really shied away

00:26:27.500 --> 00:26:33.020
from these binary formats for a lot of these reasons here. But, you know, this might make me interested.

00:26:33.020 --> 00:26:36.540
If I was going to say throw something into a cache, the whole point is put it in the cache,

00:26:36.540 --> 00:26:42.060
get it back, read it fast. This might be decent. Yeah. Yeah. It definitely seems to address a lot of the

00:26:42.060 --> 00:26:46.380
concerns I have with pickle for sure. Yeah. And I don't, did I talk about the types

00:26:46.380 --> 00:26:50.140
somewhere in here? We have time. Yeah. Here's, there's quite a list of types. You know, one's

00:26:50.140 --> 00:26:54.860
really nice. Date time. I can't do that with JSON. Why is, why in the world doesn't JSON support

00:26:54.860 --> 00:26:59.820
some sort of time information? Oh, well, but you've got most of the fundamental types that you might run

00:26:59.820 --> 00:27:05.980
into. All right. So, quick, give it a quick look. All right, Brian, what you got here?

00:27:05.980 --> 00:27:14.220
Well, I was actually reading a different article. But the, it came up, we, I think we've talked about

00:27:14.220 --> 00:27:20.220
friendly traceback. It's a package that just sort of tries to make your tracebacks nicer. But,

00:27:20.220 --> 00:27:28.060
but when I didn't realize it had a console built in. So I was pretty blown away by this. So there's a,

00:27:28.060 --> 00:27:31.900
it's, you know, it's not trivial to get set up. It's not that terrible, but you,

00:27:31.900 --> 00:27:38.220
you have to start your own console, start the REPL, import friendly traceback, and then do friendly

00:27:38.220 --> 00:27:45.260
traceback start console. But at that point, you have just like the normal console, but you have better

00:27:45.260 --> 00:27:50.060
tracebacks. And then also you have all these different cool functions you can call like,

00:27:50.060 --> 00:27:58.300
what, what, what, where, why, and explain and more. And basically if something goes

00:27:58.300 --> 00:28:04.540
wrong while you're playing with Python, you can interrogate it and ask like for more information.

00:28:04.540 --> 00:28:11.260
And that's just pretty cool. The, the why is really great. So if you have the, one of the examples I saw

00:28:11.260 --> 00:28:17.660
before, and I'm, I think I might start using this when teaching people is, we often have like

00:28:17.660 --> 00:28:21.980
exceptions, like you assigned to none or you assigned to something that can't be assigned,

00:28:21.980 --> 00:28:27.100
or you, you, you didn't match up the bracket and the parentheses or something like that correctly.

00:28:27.100 --> 00:28:32.700
Um, and you'll get like just syntax error and it'll point to the syntax error, but you might

00:28:32.700 --> 00:28:39.020
not know more. So you can just type why a W H Y with parentheses. Cause it's a, or yeah,

00:28:39.020 --> 00:28:45.260
because it's a function and it'll tell you why, why it's like a, the great storytelling,

00:28:45.260 --> 00:28:52.860
right. The five Y's of a bug. Yeah. so then you get W's of a bug. Yep. You can, you can say

00:28:52.860 --> 00:28:58.380
what, like to, to repeat what the error was, why we'll tell you why that was an error. And then

00:28:58.380 --> 00:29:03.900
specifically what you did wrong. And then where it will show you if you've, if you've been asking

00:29:03.900 --> 00:29:08.540
all sorts of questions and you lost where the actual trace back was, you can say where, and it'll point

00:29:08.540 --> 00:29:13.900
to directly to it. And, I think this is going to be cool. I think I'll use this when trying to teach,

00:29:13.900 --> 00:29:19.500
especially kids, but really just people new to Python. Tracebacks can be very helpful for them.

00:29:19.500 --> 00:29:24.540
Yeah. Like even, I know, like I sometimes have to look up like certain error messages that I'm like,

00:29:24.540 --> 00:29:28.700
not familiar with. So yeah, that would be super helpful. I could just do it right in the console.

00:29:28.700 --> 00:29:32.380
Yeah. I totally agree. You're going to have to help me find a W that goes with this,

00:29:32.380 --> 00:29:37.180
but I want the, what would be effectively Google open closed privacy?

00:29:40.300 --> 00:29:43.740
You know, because so often you get this huge trace back and you've got these errors. And if

00:29:43.740 --> 00:29:46.220
you go through and you select it, like for example, the area you see on the screen,

00:29:46.220 --> 00:29:52.300
unbound local error, local variable greetings in quotes, reference before assignments. Well,

00:29:52.300 --> 00:29:57.020
the quotes means oftentimes in search, like it must have the word greeting. And that's the one thing that

00:29:57.020 --> 00:30:02.380
is not relevant to the, the, the Googling of it. Right? So if I'm a beginner and I even try to Google

00:30:02.380 --> 00:30:08.540
that I might get a really wrong message. Right? So if you could say, Google this in a way that is

00:30:08.540 --> 00:30:14.220
most likely going to find the error, but without carrying through like variable details, file

00:30:14.220 --> 00:30:19.180
name details, but just the essence of the error, that would be fantastic. Now, how do we say that with W?

00:30:21.500 --> 00:30:31.100
You could just say, Whoa, or, or maybe www or WTF. I mean, come on, there's a lot of WTF.

00:30:31.100 --> 00:30:36.460
But wouldn't that be great. And so that's also part of this package that you see,

00:30:36.460 --> 00:30:42.060
at their main site where you've got these really cool, like visualized stuff, right? Where it's

00:30:42.060 --> 00:30:45.180
sort of more tries to tell you the problem of the error with the help text and whatnot.

00:30:45.180 --> 00:30:49.900
Yeah. Yeah. This is cool. Also uses rich, which is a cool library we talked about as well.

00:30:49.900 --> 00:30:54.620
I love rich. I include rich in everything now, even just, just to print out simple,

00:30:54.620 --> 00:30:59.980
better tables. It's great. Yeah, for sure. Hannah, do you see yourself using this or is it,

00:30:59.980 --> 00:31:07.100
are you more, more in a notebooks? Oh no. I, I mean, I usually use like the PDB debugger. So yeah,

00:31:07.100 --> 00:31:14.940
I mean, I'm not sure if really this as it is would be, like a problem. It would depend on how

00:31:14.940 --> 00:31:20.740
much information it has about like obscure errors from dependent libraries which is usually what I

00:31:20.740 --> 00:31:25.440
end up looking at these days but yeah I mean conceivably like yeah that could be helpful

00:31:25.440 --> 00:31:29.540
yeah if we get that WTF feature added then yeah oh yeah for sure gosh

00:31:29.540 --> 00:31:39.800
speaking of errors let's uh cover your last item last item of the show uh yeah so um I uh at work

00:31:39.800 --> 00:31:47.620
uh work in um the security org and I write uh like automation tools for them which means uh

00:31:47.620 --> 00:31:55.480
sometimes the repos that we work on get to be like test subjects um for for new like requirements and

00:31:55.480 --> 00:32:04.140
such um and so recently uh our org was exploring uh like static code analysis looking for like

00:32:04.140 --> 00:32:09.860
security vulnerabilities in the code um and so I ran across bandit and I integrated bandit

00:32:09.860 --> 00:32:15.560
into our we don't have time to uh go through these old legacy code and fix these problems oh wait this

00:32:15.560 --> 00:32:21.320
is what it means oh sorry yes we can do that right now that's the kind of report you gave you got from

00:32:21.320 --> 00:32:29.320
bandit yeah exactly um so yeah we integrated bandit into our legacy code base and we actually it's funny

00:32:29.320 --> 00:32:35.260
you say that because I the bug that I found using bandit was actually like a from the legacy code um

00:32:35.260 --> 00:32:44.440
that does not surprise me yeah uh so it was it was a pretty stupid like error um like it was pretty

00:32:44.440 --> 00:32:49.020
obvious like if you were doing code review but because it was legacy code and it was like already there

00:32:49.020 --> 00:32:55.500
um I just like never noticed um but it was basically like issuing like a request with like no verify

00:32:55.500 --> 00:33:03.600
uh so it was like an unverified like http request um and bandit was like yeah this this broken ssl

00:33:03.600 --> 00:33:09.420
certificate keeps breaking it I just told it to ignore it oh yeah yeah well and I honestly like I think that

00:33:09.420 --> 00:33:14.920
might have been why it was there in the first place because I I know like the oh like several years ago

00:33:14.920 --> 00:33:20.980
like had some certificate issues so yeah that might be and it was it was like an internal talking to

00:33:20.980 --> 00:33:26.480
internal so it was like maybe even a self-signed certificate that nothing trusted but they get

00:33:26.480 --> 00:33:33.860
technically there yeah yeah it was like we'll just we'll just do that um but yeah so um bandit is

00:33:33.860 --> 00:33:40.700
basically like like a linter but it looks for security issues um so you could just like pip install it um

00:33:40.700 --> 00:33:45.460
and then just like run it on your code and it will find a bunch of different potential security issues

00:33:45.460 --> 00:33:52.580
like just by like statically analyzing your code um and I've uh pretty much like come to the opinion

00:33:52.580 --> 00:33:58.160
that like why haven't I done this on all of my other projects like I should be doing this on every single

00:33:58.160 --> 00:34:05.540
project um like because you know like as as like a developer I always run like lint and black and stuff

00:34:05.540 --> 00:34:12.140
like that um so I figure you know I should probably be running bandit too yeah cool yeah well very nice uh

00:34:12.140 --> 00:34:16.380
it's a good recommendation for people as well and it's got a lot of cool you can go and actually see

00:34:16.380 --> 00:34:21.740
the list of the things that it tests for and even has test plugins as well which is pretty cool yeah

00:34:21.740 --> 00:34:27.040
yeah so you can like make your make your own if you want um and it has like all the common linter sort of

00:34:27.040 --> 00:34:32.540
like functionality like ignore these files or like ignore these rules or even you know like ignore this

00:34:32.540 --> 00:34:37.980
rule on this particular line stuff like that yeah absolutely which is pretty sweet I love that things like

00:34:37.980 --> 00:34:45.260
bandit are around because um uh thankfully uh developing web stuff is becoming easier and easier

00:34:45.260 --> 00:34:52.380
but it's then now the barrier to to entry is lower you still have to have all those security concerns

00:34:52.380 --> 00:34:58.540
that you had before that normal I mean usually people were just had more experience but they would make

00:34:58.540 --> 00:35:03.260
mistakes anyway but now I think this is one of the reasons why I love this is because people new to it

00:35:03.260 --> 00:35:08.860
might be terrified about the security part but having uh bandit on there looking over their shoulder is

00:35:08.860 --> 00:35:14.580
great yeah yeah like don't publish with the debug setting on and blast or jango or anything like that

00:35:14.580 --> 00:35:21.580
simple obvious stuff and like honestly like having worked in the security org for about a year now like

00:35:21.580 --> 00:35:29.260
I've come to the understanding that a lot of security issues stem from just like basic like duh sort of

00:35:29.260 --> 00:35:36.380
misconfigurations so like something like this is perfect and I really really like that you added um

00:35:36.380 --> 00:35:42.140
you you wrote in the show notes um some pre-commit uh how to how to hook this up with pre-commit because

00:35:42.140 --> 00:35:48.940
I think having it in pre-commit or in a ci pipeline is important because um like you guys were joking

00:35:48.940 --> 00:35:54.380
about often security problems come in because somebody's just trying to fix something that broke yeah but

00:35:54.380 --> 00:36:00.540
they don't really realize how many other things it affects so yeah yeah yeah besides down just we got

00:36:00.540 --> 00:36:03.900
to make it work quick just just turn on the debug thing we'll just look real quick and then you forget

00:36:03.900 --> 00:36:11.020
to turn it off or whatever yeah yeah for sure yeah yeah just stupid human errors nice all right I want to go

00:36:11.020 --> 00:36:17.020
back real quick Brian because uh your uh mentioned a friendly trace back got a lot of stuff so let me just do a

00:36:17.020 --> 00:36:23.580
quick uh audience reaction Robert says it is cool Brian John Sheehan says I was just thinking it's something

00:36:23.580 --> 00:36:28.940
the same would be cool it's a great teaching concept Anthony says super useful um John says I've been doing

00:36:28.940 --> 00:36:36.140
more demo code in the console rather than the idea this looks like it would help w how to fix it w

00:36:36.140 --> 00:36:44.540
wow how w i love it Robert very good Zach says uh what is this magic this looks amazing and so on all

00:36:44.540 --> 00:36:50.700
right well thanks everyone uh I'm glad you all like that uh so that's it for our main items you know um

00:36:50.700 --> 00:36:55.740
Brian you got any extras you want to throw out there you were uh doing something with climate change or what

00:36:55.740 --> 00:37:02.700
are you doing this week um yeah I'm sharing the room with some people just a sec uh the uh I did do

00:37:02.700 --> 00:37:09.660
two meetups uh with uh with uh Noah and uh then with the Aberdeen python meetup wait wait I got

00:37:09.660 --> 00:37:14.380
I got to interrupt you really quick did all the talk that Hannah did about bandit and viruses get you

00:37:14.380 --> 00:37:25.980
it's all right I'm sorry sorry about that carry on well I missed all this talk with Hannah that Hannah

00:37:25.980 --> 00:37:31.340
had about viruses and in hacking and stuff with bandit did it make you nervous and you had to put on your

00:37:31.340 --> 00:37:37.740
your mask no I just I'm in a group meeting in their group room and somebody came in but it's okay I'm

00:37:37.740 --> 00:37:44.620
just teasing carry on um the that's funny I also wanted to look like a bandit yeah exactly but I was

00:37:44.620 --> 00:37:51.580
thrilled that uh Noah uh asked me to to speak to them that was neat and then the python Aberdeen people

00:37:51.580 --> 00:37:57.340
um and also like but they mentioned that Ian from the python Aberdeen group said that he had an arrangement

00:37:57.340 --> 00:38:02.700
with you that when you Michael that when the the pandemic is over you're gonna go over and they're

00:38:02.700 --> 00:38:06.700
gonna you're gonna do like a whiskey tour or something like that so I'm I don't know the

00:38:06.700 --> 00:38:12.620
details but it sounds good to me already anyway if that happens I want to go along yeah it's a python

00:38:12.620 --> 00:38:19.020
bites outing let's do it and then we have uh uh there are pdx west meetup tomorrow you're gonna speak

00:38:19.020 --> 00:38:23.500
that's kind of exciting so yeah it's gonna be fun and people as virtual so people can attend however

00:38:23.500 --> 00:38:31.020
um I'm also I've got feedback from both uh you and um and Matt Harrison gave me some feedback so I'm

00:38:31.020 --> 00:38:37.180
updating my training page on testing code so um because I really like working with teams so I'd and

00:38:37.180 --> 00:38:43.020
anybody else wants to give me feedback on my training page maybe I could I'd love to hear it so yeah or maybe

00:38:43.020 --> 00:38:48.300
they even want to have some high test training for their team yeah I mean testing is something that uh

00:38:48.300 --> 00:38:53.820
I think teaching a team at a time is a great thing because people can uh can really um I don't know that

00:38:53.820 --> 00:38:59.420
we can talk about their their particular problems not general problems it's good so yeah for sure well

00:38:59.420 --> 00:39:03.340
you also need more of a team buy-in on testing right because like if one person writes code and

00:39:03.340 --> 00:39:07.420
won't write the test another person is like really concerned about making the test fast it's super

00:39:07.420 --> 00:39:12.780
frustrating yeah the person who doesn't want to run the test keeps it breaking the build but like you know

00:39:12.780 --> 00:39:17.500
anyway it's a team sort of sport in that regard yep yeah all right awesome so I got a couple quick

00:39:17.500 --> 00:39:24.620
things PEP 634 structural pattern matching in python has been accepted for python 310 that's like

00:39:24.620 --> 00:39:29.820
imagine a switch case that has about a hundred different options that's what it is yeah with

00:39:29.820 --> 00:39:34.860
like like reg x not quite but sort of like style like you can have like these patterns and stuff that

00:39:34.860 --> 00:39:40.460
happen in the cases I don't know how to feel about this like if uh let me put a perspective like if the

00:39:40.460 --> 00:39:45.900
walrus operated was controversial like this is like this is like a way bigger change to the language so

00:39:45.900 --> 00:39:51.340
I don't know it it's both awesome and terrifying yes exactly yeah I was gonna say I'm kind of surprised

00:39:51.340 --> 00:39:56.460
yeah yeah so am I Hannah that like this got accepted it seemed to be sort of counter to the simplicity of

00:39:56.460 --> 00:40:01.180
python like I I did not at all against having a simple switch statement that does certain things but

00:40:01.180 --> 00:40:05.900
this seems like a lot I may come to love it one thing that maybe would help me come to a better

00:40:05.900 --> 00:40:10.780
understanding and acceptance was if the PEP page had at least one example of it in use like the

00:40:10.780 --> 00:40:15.180
whole page that talks about all the details says I don't believe there's a single code sample ever

00:40:15.180 --> 00:40:20.540
well there's a tutorial page as well so oh is there there's the tutorial page okay maybe that's where

00:40:20.540 --> 00:40:25.260
I should be going to check it out yeah but it still sort of feels like a five barrel foot gun yeah

00:40:25.260 --> 00:40:29.900
it does well but the page that I'm looking like the pip thing that I'm listening to the official PEP I

00:40:29.900 --> 00:40:35.180
don't think it has uh does it have the tutorial yeah no you're right it does it does um somewhere down

00:40:35.180 --> 00:40:40.380
yeah PEP 636 yeah it's a different PEP that is the tutorial for the PEP interesting I didn't realize

00:40:40.380 --> 00:40:46.140
that it's kind of meta honestly anyway I to me I'm a little surprised it's accepted fine um I know people

00:40:46.140 --> 00:40:50.220
worked really hard on it and congratulations a lot of people really want it comes from Haskell right so

00:40:50.220 --> 00:40:53.820
Haskell had this like pattern matching like alternate struct thing I don't know I just feel

00:40:53.820 --> 00:40:58.300
like Haskell and Python are far away from each other so that's my first impression I will

00:40:58.300 --> 00:41:03.180
probably come to love it at some point uh PyCon registration is open so if you want to go to PyCon

00:41:03.180 --> 00:41:07.260
you want to attend and be more part of it than just like watching the live stream on YouTube be part of

00:41:07.260 --> 00:41:11.420
that I think I'm going to try to make a conscious effort to attend the virtual conference not just

00:41:11.420 --> 00:41:18.620
catch some videos so you can do that yeah PyCon is awesome like just I my first conference was PyCon

00:41:18.620 --> 00:41:23.340
and then I went to other conferences and I was like what are wrong with these conferences like

00:41:23.340 --> 00:41:31.020
yeah I know I feel the same way I know it's uh it's really really special I'm sure the virtual one

00:41:31.020 --> 00:41:36.060
will be good I can't wait for the in-person stuff to come back because it really for sure yeah it's a

00:41:36.060 --> 00:41:41.100
whole another experience in person I consider it basically my um geek holiday where I get get away

00:41:41.100 --> 00:41:44.540
and like just get a hang out with my geek friends I happen to learn stuff on there totally

00:41:44.540 --> 00:41:51.260
and then Python web comp is coming up and that's uh registration is open for that as well um and I

00:41:51.260 --> 00:41:56.300
suppose probably PyCascades which Brian and I are on a panel at there as well oh nice I put I put a link

00:41:56.300 --> 00:42:01.820
into an hour of code for Minecraft which has to do with programming Minecraft with Python if people are

00:42:01.820 --> 00:42:06.620
looking to teach kids stuff uh that looks pretty neat so um my daughter's super into Minecraft I don't

00:42:06.620 --> 00:42:10.140
do anything with it but if if you are and you want to make it part of your curriculum uh that's pretty

00:42:10.140 --> 00:42:15.100
cool Hannah anything you want to throw out there before uh we break out the joke nope I'm good

00:42:15.100 --> 00:42:20.220
awesome do it do it all right all right so this one we have something a little more interactive for

00:42:20.220 --> 00:42:28.220
everyone we've got a um a song about PEP 8 about writing clean code this is written and and uh produced

00:42:28.220 --> 00:42:34.940
sung by Leon Sandoy uh goes by Lemon and him and his team over at Python Discord he runs Python Discord and

00:42:34.940 --> 00:42:38.860
apparently it was a team effort creating this and the reason I'm covered is a bunch of people sent it

00:42:38.860 --> 00:42:43.500
over so Michael Rogers Valet uh sent it over so you should cover this Dan Bader said check this out

00:42:43.500 --> 00:42:49.660
Alan McElroy said hey check out this thing so all right I actually uh spoke to Lemon and said hey do

00:42:49.660 --> 00:42:53.020
you mind if we play this he said no that'd be awesome give us a shout out of course so we're

00:42:53.020 --> 00:42:57.340
gonna actually play the song as part of this in the live stream you get the video on the audio you get

00:42:57.340 --> 00:43:02.220
well audio so I'm gonna kick this off and we'll come back and I'd love to hear Brian and Hannah's thoughts

00:43:02.220 --> 00:43:05.020
here we go

00:43:05.020 --> 00:43:24.620
you don't need any curly braces just for spaces just for spaces

00:43:26.140 --> 00:43:35.820
wildcard imports should be avoided in most cases in most cases

00:43:35.820 --> 00:43:46.860
try to make sure there's no trailing white space it's confusing it's confusing

00:43:47.100 --> 00:43:57.900
trailing commas go behind list items get blamed titans get blamed titans

00:43:57.900 --> 00:44:09.820
and comments are important as long as they're maintained when comments are misleading it will drive people insane

00:44:09.820 --> 00:44:16.060
just try to be empathic just try to be empathic just try to be a friend

00:44:16.060 --> 00:44:20.700
it's really not that hard just adhere to

00:44:22.700 --> 00:44:33.140
papade. Papade.

00:44:33.140 --> 00:44:44.640
constants should be named, all capital letters, and live forever, live forever.

00:44:44.640 --> 00:44:55.800
And camel case is not for python, never ever, never ever.

00:44:55.800 --> 00:45:06.580
And never use a bare exception, be specific, be specific.

00:45:06.580 --> 00:45:17.740
No one likes the horizontal scroll bar, keep it succinct, keep it succinct.

00:45:17.740 --> 00:45:23.740
And comments are important, as long as they're maintained.

00:45:23.740 --> 00:45:29.620
When comments are misleading, it will drive people insane.

00:45:29.620 --> 00:45:34.900
Just try to be empathic, just try to be a friend.

00:45:34.900 --> 00:45:40.780
It's really not that hard, just adhere to.

00:45:40.780 --> 00:45:44.060
Papade.

00:45:44.060 --> 00:45:50.060
Papade.

00:45:50.060 --> 00:45:55.060
Papade.

00:45:55.060 --> 00:46:02.060
Papade.

00:46:02.060 --> 00:46:04.900
Papade.

00:46:04.900 --> 00:46:08.340
Papade.

00:46:08.340 --> 00:46:08.900
Papade.

00:46:08.900 --> 00:46:09.900
That was amazing.

00:46:09.900 --> 00:46:14.380
I can sympathize with so much of what he's saying.

00:46:14.380 --> 00:46:19.860
I'm just having flashbacks to a discussion I had with my teammate about comments.

00:46:19.860 --> 00:46:27.220
And being like, "No, this comment doesn't actually describe what the comment is doing."

00:46:27.220 --> 00:46:30.260
It's worse than having no comment. It really is.

00:46:30.260 --> 00:46:31.460
It really is, yeah.

00:46:31.460 --> 00:46:32.460
I love it.

00:46:32.460 --> 00:46:36.460
Or if it describes literally what the code is doing and not high-level.

00:46:36.460 --> 00:46:37.460
Exactly.

00:46:37.460 --> 00:46:40.460
Why or background or anything other than...

00:46:40.460 --> 00:46:41.460
The why.

00:46:41.460 --> 00:46:42.460
The why is important.

00:46:42.460 --> 00:46:43.460
Yeah.

00:46:43.460 --> 00:46:44.460
I love it.

00:46:44.460 --> 00:46:45.460
So, two things.

00:46:45.460 --> 00:46:47.460
Lemon and team, well done on the song.

00:46:47.460 --> 00:46:48.660
And man, you've got a great voice.

00:46:48.660 --> 00:46:49.460
That's actually...

00:46:49.460 --> 00:46:51.060
It was beautiful and funny.

00:46:51.060 --> 00:46:52.060
Yeah.

00:46:52.060 --> 00:46:53.060
It was amazing.

00:46:53.060 --> 00:46:53.060
All right.

00:46:53.060 --> 00:46:54.460
Well, Brian, we probably should wrap it up.

00:46:54.460 --> 00:46:55.460
Yeah.

00:46:55.460 --> 00:46:56.460
All right.

00:46:56.460 --> 00:46:58.020
Well, Hannah, thanks so much for being here.

00:46:58.020 --> 00:46:59.020
It's good to have you on the show.

00:46:59.020 --> 00:47:00.020
And Brian, thanks as always.

00:47:00.020 --> 00:47:01.020
Everyone, thanks for listening.

00:47:01.020 --> 00:47:02.020
Thanks for having me.

00:47:02.020 --> 00:47:03.020
Bye.

00:47:03.020 --> 00:47:04.020
Bye, all.

00:47:04.020 --> 00:47:05.020
Thank you for listening to Python Bytes.

00:47:05.020 --> 00:47:07.020
Follow the show on Twitter via @pythonbytes.

00:47:07.020 --> 00:47:10.220
That's Python Bytes as in B-Y-T-E-S.

00:47:10.220 --> 00:47:13.220
And get the full show notes at pythonbytes.fm.

00:47:13.220 --> 00:47:17.220
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:47:17.220 --> 00:47:20.220
We're always on the lookout for sharing something cool.

00:47:20.220 --> 00:47:23.220
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:47:23.220 --> 00:47:26.920
Kennedy. Thank you for listening and sharing this podcast with your friends and colleagues.

