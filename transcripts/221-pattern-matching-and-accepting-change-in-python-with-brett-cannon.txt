00:00:00 Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode 221, I think.

00:00:08 Recorded, when is it? February 17th, 2021. I am Brian Okken.

00:00:13 I'm Michael Kennedy.

00:00:14 And we also have Brett Cannon. Yeah. I always talk over the third person. I'm not sure why.

00:00:19 Well, you're always going like, is there going to be an introduction or should I just join the Brady Bunch theme? Let's just go in a circle and just introduce ourselves.

00:00:26 But if we're going to do Brady Bunch, we've got to have more people so we can like fill out, what is that, like rows of three or whatever in the picture?

00:00:33 I'm sure Anthony Shaw and Paul Everett are available based on how often they show up here. So I'm sure they're waiting in the wings.

00:00:38 That's right. We'll just swoop them in here for the right picture. Welcome, Brad. It's great to have you here.

00:00:43 Lovely to be back.

00:00:44 You know what, Brian, I'm impressed with Brett's microphone. He has mastered the work from home.

00:00:50 Yeah, I love this. We're going to have to put a link in the show notes to this thing.

00:00:54 - Tell people about this.

00:00:55 So, Bright and I both have good microphones.

00:00:58 We have many different microphones we've tried, but yours has a visual aspect, which is unusual for audio.

00:01:03 - Yeah, so it's a HyperX Quadcast S specifically, and it comes with RGB lighting 'cause it's really a gamer mic.

00:01:11 But obviously in pandemic times, I work from home, and my wife is also at home because of the pandemic, and we always had an issue of her wanting to come in and not knowing whether I was actually occupied actually in a meeting because I'm in them a lot for work or whether or not I was just sitting there with my headphones on listening to music or whatever and she could totally just walk in.

00:01:31 And so the great thing about this microphone is if it has a touch sensitive top and if you tap it, the LEDs turn off.

00:01:38 And so it acts as like an on air light for the room.

00:01:41 I mean, it's not that bright specifically but if she opens the door, she can totally just look in and go, is the mic lit?

00:01:46 And if the mic's not lit, she knows she's not going to be heard or be directly interrupting me and I can just turn and answer any questions she has.

00:01:53 And it's awesome.

00:01:54 It works out great that way.

00:01:55 - That is so fantastic.

00:01:56 The whole mic glows when it's on and active.

00:01:59 Different colors, it's beautiful.

00:02:00 I love it.

00:02:01 - Yeah, and you can even change which colors it uses.

00:02:03 This is, I can't remember if it's waterfall or not, but you can actually change how the color spectrum changes from side to side in terms of colors and whether it's top to bottom or not.

00:02:11 It's very pretty.

00:02:12 I think I once did Harry Potter color themed for a coworker of mine who's a big Harry Potter fan for all the houses.

00:02:17 And I've purposely not played with it and kept with the defaults 'cause it's definitely one of those things I could totally nerd out on and play with the colors all day long.

00:02:25 I tried Python colors once, the transitions didn't look quite as nice, but you know.

00:02:29 - Yeah, no, it's good.

00:02:30 I have the microphone that matches, or sorry, the mouse that matches it.

00:02:33 - Oh, nice. - And it pulses, so.

00:02:35 I didn't get it for the color, but it's the only one I could get that had color.

00:02:38 I'm like, why is it of color?

00:02:39 How do I turn this off?

00:02:40 But no, it just has colors, fine.

00:02:41 But anyway, great, Mike.

00:02:43 I think people should check that out.

00:02:44 If they have like weird work-from-home situations and people are interrupting, it's super cool, I love it.

00:02:49 Definitely get a mic stand, though.

00:02:51 The default stand's a little low, and I have found that getting a cheap $10, $15 stand--

00:02:58 I got this from Amazon-- that pushes it off about 7 inches, I think.

00:03:02 Trying to do the American units.

00:03:04 It pushes up about 15 centimeters.

00:03:06 It's a nice, sweet spot in terms of distance, while still not completely taking up your vision in the screen.

00:03:11 >>Brian: Yeah, excellent.

00:03:12 Excellent.

00:03:13 Well, Brian, you want to kick us off here with our first topic?

00:03:16 >>Brian: Yeah.

00:03:16 - Well, we've got, it's hard to keep up with Will McCougan, sorry Will, Will wrote Rich, which is a, I forget what he calls it.

00:03:28 Basically it's a CLI tool, but there's been a whole bunch of really cool things he's done recently, like really recently.

00:03:35 So in December, he added live view, which allows you to just, you can, it continually updates whenever an event happens something in that part of the screen, which is cool.

00:03:48 He didn't write a blog post on that, but then in January, TreeView came out.

00:03:54 The TreeViews are lovely.

00:03:56 You can do all sorts of stuff with the TreeView.

00:04:00 Yeah, it's a nice thing to have in a CLI tool.

00:04:05 Then what's really impressive to me, I think, was layouts.

00:04:09 This month, he released layouts.

00:04:13 it allows you to split the screen up and his demo even shows it happening within a VS Code.

00:04:23 >> Oh, yeah. Within the bottom.

00:04:26 >> Yeah.

00:04:27 >> Terminal part of VS Code.

00:04:28 Yeah. Brett, you've heard of this, right?

00:04:30 You've heard of this tool?

00:04:31 >> How can I not? I'm a fan of the podcast and Brian loves this tool so I've heard about it multiple times.

00:04:37 >> I guess we've covered it before.

00:04:40 But one of the reasons why I'm covering it again, There's a couple of reasons.

00:04:44 Is the layout's neat and really, now I want to click on stuff and I want to do entry.

00:04:49 He hinted at that, that he's going towards a full TUI, which I had never heard of before, Text User Interface.

00:04:57 >> Yeah, TUIs. All right.

00:04:58 Right on. That'd be cool.

00:05:00 >> I think that would be neat and I'd like to encourage that.

00:05:03 The other thing that's going on with Rich is he's accepting sponsorships now and it's hidden in the demo window.

00:05:11 But we're highlighting it on the show so more people can know about it.

00:05:15 So GitHub is doing sponsorships on GitHub, and I like how GitHub sponsorships work.

00:05:22 It's neat, so check it out.

00:05:25 The other thing that I guess when I was playing with these layout things, that I didn't really realize before is you can just say Python-in rich, and it shows a little demo of a whole bunch of stuff.

00:05:36 Then some of the particular parts of it, you can demo them individually.

00:05:41 Like for the layout, you can say Python-mrich.layout, and it'll show a demo.

00:05:47 The tree also has a demo, and the live one actually, I couldn't escape it.

00:05:54 I had to kill my window.

00:05:55 So the live one just continually updates some.

00:05:59 I don't know if it's actually going out to the Internet, but it's doing some conversions of monetary conversions, and it just kept updating.

00:06:11 It doesn't hit control C.

00:06:13 >> Someone's got a bear except somewhere they shouldn't have.

00:06:16 >> I think it's very reliable.

00:06:18 I mean, the only way to exit is force quit.

00:06:19 So we're all kill that line.

00:06:22 Where's your friend?

00:06:24 >> So yeah, I'd love to have some have rich continue with this and make it a full 2E, that'd be fun.

00:06:31 >> That would be very cool because the presentation is really nice here.

00:06:34 >> I will also fully support Will making this a full-on thing because actually, A couple of months ago, I did a slight dive on a weekend trying to find some TUI libraries, because I have a personal project for work purposes that I've been trying to do a GUI for.

00:06:49 And two years in a row, I've tried to do it during Hackathon week at Microsoft, and I keep failing because I don't have enough time to dive into all the GUI libraries that go from, like, here's how to do Hello World.

00:07:00 Here's the reference.

00:07:01 And it's like, no, no, I need more steps there.

00:07:05 Where's that middle ground?

00:07:06 Come on.

00:07:07 Yeah, exactly.

00:07:08 And then I decided, oh, well, I totally could just do this in Curses.

00:07:11 It's literally just to keep track of what I do every day.

00:07:14 And it's just like it's snippets from Google is where I picked up the habit of just literally just, oh, I did this today that was out of ordinary.

00:07:20 I did this today that was out of ordinary, just to kind of track the high level, not just meetings, but I actually did something different today.

00:07:27 And it's like, oh, I could totally do this in the terminal.

00:07:29 It's like suddenly pull up in Curses library.

00:07:32 It's in the Snider library.

00:07:33 And it's like, oh, yes, you need to know the size of your terminal window and all this other stuff and oh how to move the cursor to this specific position is like yeah no I still don't have time for this so move this along and make input work I mean I would be totally down for giving a shot yeah yeah quite cool and if people don't know you kind of live an alter ego you've got a bright Canon open source steering council and also work closely with VS Code at Microsoft right so having a screenshot on the screen is alright at home yeah yeah just for For people who don't know, I'm the dev manager for the Python extension for VS Code.

00:08:09 That's how I pay for my open source habit, which includes being on the Python steering council on the core dev.

00:08:17 - Yeah, quite cool.

00:08:18 So, Gandalforf says, "I've been using prompt toolkit "for the Tui library for a while, "but this rich seems a lot nicer "if it actually accepted input," which I agree, seems very cool.

00:08:30 - And I've heard some people using them together, I just don't know how to do that.

00:08:33 So if somebody wants to write a tutorial on how to use both Rich and Prompt Toolkit together, that'd be cool.

00:08:39 - Yeah, that would be cool, actually.

00:08:41 All right, what I wanna talk about is this article I ran across and some tools that I went to play with afterwards, after reading it, called 12 Requests Per Second.

00:08:51 Sounds amazing, right?

00:08:52 So it's a realistic look at web frameworks and Python web frameworks.

00:08:58 So if you look out there, you'll hear things like, oh, we're getting 100,000 requests per second on UVLoop.

00:09:03 with a single thread, or we've got Sanic doing 100,000 requests, or even Jopranto up to 1.2 million requests per second, right?

00:09:14 Which is amazing.

00:09:15 And then a lot of these examples are doing like really not real type of work, right?

00:09:21 They're just doing some little tiny thing like, oh, here, let's add two numbers and tell you how fast we can do that.

00:09:27 So this article is more like, well, let's go through a real application and see what kind of performance you might expect.

00:09:34 So I thought it'd be fun to talk about this 'cause it gives some people some things to think about.

00:09:39 You know, how can you compare your app to these types of quotes that people are getting and so on?

00:09:45 And would it be better to choose something like Depronto or AIOHTP or FastAPI or something like that over say Flask or Django, which don't have so much support for things like async.

00:09:57 So I thought this was fun to go through and just kind of look at it.

00:10:00 they start out by profiling just sort of a Hello World app and they get, all right, well, Hello World's pretty good.

00:10:06 If you run Flask on CPython, you get, I don't know, some amount here, maybe it was 500 to 1,000.

00:10:14 You run it on PyPy, they were able to get 3,000.

00:10:18 You run it, and so that's just, you know, Flask run, right?

00:10:20 Which is not really the way you should probably be doing things.

00:10:23 You should be running on G-Unicorn or MicroWizGee or something like that.

00:10:27 So if they ran the same thing on G-Unicorn, it's up to like 12,000.

00:10:32 And you run it on, compare that against Sanic, you get, Sanic was doing like 24,000 or something.

00:10:37 So these comparisons I thought would be fun for people.

00:10:39 You can go through, they've got a bunch of graphs that you can check out, but then they write one that actually talks to a database doing database-y things.

00:10:46 And then let me get down to the numbers here, the bottom for that, and they're like, okay, well with this one, now we're running at quite a bit lower request per second.

00:10:56 And I think in the end they said for our real app, what we ended up with is a whopping like 12 requests for a second.

00:11:02 Yeah, here we go.

00:11:03 Here's the graph as I get for where like, this is Flask running the synchronous Postgres driver there.

00:11:11 And that's all pretty interesting.

00:11:13 I think, you know, even be able to answer the question, you know, well, what about me?

00:11:18 What about my app?

00:11:19 How would it do if I were to run these things against it?

00:11:21 And we've talked about Locust before.

00:11:24 Locust is a really fantastic way to write load testing and user interaction testing against websites, web APIs and so on.

00:11:34 And it's all about Python.

00:11:35 So what you do with this is you go through and you write some kind of class and you say, okay, here's a test, like a representation of what people might do to my website.

00:11:45 They might log in, they might go view the episode page if we were testing the Python Bytes site, or they go check out the episode page, might drill into an episode, they might do a search.

00:11:54 And what you can do is you write simple little bits of Python to say, here's a function that does this action.

00:12:00 Here's a function that does that action.

00:12:01 Like here's one that goes to the episode listing.

00:12:04 And then you can actually, it's not shown in the example here, but you can say things like, well, you know, 10 out of 15 times I want them to view an episode page.

00:12:12 One out of the 10 times I want them to do a search.

00:12:14 And three out of the 10 times I want them to actually go to the listing, right?

00:12:18 So you can sort of break it up to what the normal would be, then you just run Locust and you get like this web UI where you enter some information and then it just runs, if you want even in a distributed way against your site and then pounds it until it gives up basically.

00:12:34 Brett, have you heard of this tool?

00:12:36 - No, I actually haven't.

00:12:37 I mean, you hear about different tools for different things, but this is pretty, looking at this example, it's pretty simple, which is pretty great.

00:12:44 - Yeah, the simplicity is really great.

00:12:46 And then when you run it, you actually get a web view into it, then the web UI lets you basically control and monitor the tests in real time.

00:12:53 So anyway, coming back to some numbers off of that, I decided, well, if they're getting 12 to 80 requests for a second, what does my stuff look like?

00:13:02 Like, for example, a talk to Python training stuff.

00:13:04 It's not using any of this async stuff.

00:13:07 How is it doing?

00:13:08 So it's Python 3, microWSGI, Pyramid, MongoDB on a $20 server.

00:13:13 Would it get 12 requests per second?

00:13:15 I don't know.

00:13:15 I turned this thing loose and it'll do about 125 requests per second.

00:13:22 I felt better than, that's better than 12, I felt pretty good.

00:13:25 But one of the things that's cool about Locust is you can tell it, not just I want you to use this partitioning, but also I would like you to have a distribution of how often the user actually does something.

00:13:37 So you can say, well, this user is going to make between every 10 to 60 seconds, it's going to do one of these things among this mix.

00:13:45 So instead of just pounding it, it's like, well, an average user doesn't just hit F5 or control command R as hard as they can.

00:13:51 They move around and they pause, right? So you can pause that.

00:13:54 So I don't know, maybe it's 10 to 20,000 realistic users I was able to sort of map out with this.

00:13:59 Anyway, it was just a fun deep dive into like, well, what does performance look like?

00:14:03 How important is async? Some of the tools to do it?

00:14:07 I don't know, if people are, if that's interesting people, definitely check out this 12 requests per second article here.

00:14:12 I think you'll enjoy it.

00:14:14 Then also check out Locus if you want to try to answer that question for yourself.

00:14:18 >> I was curious how when you're testing your site, did anybody else experience downtime or something?

00:14:26 >> No. Well, that's the question.

00:14:28 With the Locus thing, you can start to see real-time, what the response times are and everything.

00:14:35 It never crashed.

00:14:36 It just got a little bit slow.

00:14:37 I ran it locally and I'm like, well, what's it look like in production?

00:14:42 I'm like, I really want to know, with all the way that everything's put together, what number will I get?

00:14:47 So I'm like, I'm just gonna turn it loose on it, and if it starts to overwhelm it, I'll just hit the stop button.

00:14:51 And it never died, it just got to where it took like three or 400 milliseconds to get back to me.

00:14:56 So it was okay.

00:14:57 - Okay, good.

00:14:58 - Yeah, so pretty fun, pretty fun example there.

00:15:00 - I think one other thing I appreciate about that blog post actually was they pointed out towards the end that at some point scaling is no longer a Python problem and it's an infrastructure problem.

00:15:08 Like, oh, it's probably better to update your database and stuff.

00:15:11 And I've heard this from a lot of people too, of there's kind of a misnomer if you're not in the Python community that, oh, Python's so slow, it's gonna be your bottleneck.

00:15:20 And instead I've heard it from a lot of people in the community that, oh, actually it's not, I can get my work done in a third of a time, and then the two thirds of time it would have taken me to do it in, I don't know, Java, just choose a different language.

00:15:30 I can optimize my infrastructure.

00:15:32 And guess what?

00:15:33 I end up with the same performance with more time to bug fix and test than I would have in the other platform.

00:15:38 And the other thing is, is obviously, There is always throwing more hardware at the problem if you need a horizontally scale.

00:15:44 But, and honestly, I think one nice thing this post also, I think, from a critical point out, not everyone needs 1,000 requests a second.

00:15:52 - Yeah.

00:15:53 Most people don't.

00:15:54 Even popular websites are not doing 1,000.

00:15:57 I mean, that's a lot of requests, 1,000 requests a second. - That is a lot.

00:16:01 Most people measure in queries per minute, not per second, right?

00:16:05 So even 12 per second, we're still talking 720, my math is not finding me on the spot, request per minute, that's still a decent cliff.

00:16:15 If you're running a business that's getting that much traffic every single minute, you're probably still doing pretty good for yourself.

00:16:20 >> That's 32 million page views per month.

00:16:24 You're at a limit where you've got some real stuff going on, some real infrastructure.

00:16:28 >> Well, okay. But there's also if I've got services running, I've got a bunch of services that include this.

00:16:34 I mean, one user interaction isn't one hit, It might be dozens.

00:16:40 So yeah, so so my rule of thumb is honestly, don't worry unless you're going over 100 a second.

00:16:45 Like you should be able to hit 100 a second without too much effort.

00:16:48 And after that, you might have to start doing some planning.

00:16:50 But I would suspect as your rule of thumb, you can you can handle hundreds without a whole lot of effort in Python.

00:16:55 Yeah, if you get into 1000, you might have to do a bit more planning for it.

00:16:58 But it's totally serviceable for that kind of thing.

00:17:01 Yeah, totally agree.

00:17:03 Magnus Carlsen has a quick comment.

00:17:06 - All right, nice.

00:17:06 So I can now see if my work turning my FastAPI app into async was worth it.

00:17:12 Yes, you can.

00:17:13 This is a very good use of that.

00:17:16 - I'm gonna be biased and just say it was totally worth it, Magnus.

00:17:18 You just don't know yet.

00:17:19 (both laughing)

00:17:21 - Because it's got the cool new design patterns, absolutely.

00:17:23 - Exactly.

00:17:24 - All right, Brett, you're up next.

00:17:26 You've got something special for us.

00:17:28 - Yeah, so the world exclusive, news-breaking thing is The Python launcher for Unix is probably at RC stage.

00:17:39 For those of you who don't know about this, it's a project I've been working on since May of 2018.

00:17:46 And if you're a Windows user, you probably know what I'm talking about.

00:17:49 But on Windows, there is a little app called the Python launcher for Windows.

00:17:54 And it chips with Python.

00:17:55 And it gives you the py command.

00:17:57 So sometimes you might see this on websites where they say, well, if you're on Windows, you run Python using py, and then the command.

00:18:02 and other platforms just run with Python 3.

00:18:05 And I decided that I kind of wanted this on Unix.

00:18:10 I had had enough people complain to me about how it's difficult to get started where having the Windows instructions on how to run something was always different from the Unix version and all this.

00:18:20 - Yes, that is really annoying, the very first thing you gotta do, like right at the start, like, oh, it's so easy, but there's these two ways, there's like this diversion, right?

00:18:27 - Exactly.

00:18:29 And I saw some benefit to the Python launcher because what it does on Windows is it serves kind of two key purposes.

00:18:37 One is it kind of makes up for the lack of shebang support on Windows, because the launcher will actually look for a shebang line, figure out what version of Python is required, and then finds the right version of Python to run it.

00:18:48 The other thing is it does away with the need of caring about what order you installed your Pythons in.

00:18:54 Because like, for instance, on Unix, like Python 3, what does that point at?

00:18:58 Well, what it points at is the last version of Python 3 that you installed, not the newest version of Python.

00:19:04 So if you installed 3.9 today, but then installed the 3.8 security release that I think happened yesterday, you will get 3.8 as your version for Python 3.

00:19:14 So if you don't specify Python 3.9, you won't be running it.

00:19:17 Like you have to either create your virtual environment and be using it that way or remember that.

00:19:21 Python Launcher takes care of all that.

00:19:22 It will automatically just figure out what versions you have installed and just automatically run the newest version.

00:19:28 And so I really like that.

00:19:29 So I decided to implement it in Rust, partially as a Rust project of decent size.

00:19:35 And it's about 1,000 lines of Rust code.

00:19:37 And also because I wanted it, because if this works out, hopefully some projects can stop listing two different ways to run things.

00:19:44 So in the Unix version, it's a little different from the Windows version.

00:19:48 And I'll ask for feedback from the two of you and anyone in the live stream if they want to provide it.

00:19:53 First, it looks to see if a virtual environment's activated.

00:19:55 So it looks for the virtual_env environment variable.

00:19:58 if it's there, it just uses that.

00:19:59 So automatically, this is a little shorter and easier if you have an activated virtual environment, it's just py now instead of having to type Python.

00:20:06 The next one is if you--

00:20:08 - You're here to save us from RSI already.

00:20:10 (laughing)

00:20:11 I'm kidding, but this is really interesting, keep going.

00:20:13 - Yeah, one third of the typing.

00:20:15 The other thing is if you create a virtual environment in a .venv directory, it will also automatically use that without activation.

00:20:25 So once again, if you use the -- I personally think standard nomenclature, naming your virtual environments .venv, you don't have to activate them anymore. Activation is just a shorthand for the shell that honestly I typically just use to make Python do the right thing. I use -m for everything. This takes care of that entire step for me. I don't have to activate my environments anymore.

00:20:49 >> Okay. That's super cool.

00:20:50 >> After that, it does the shebang just like on Windows. Trying to figure out what the Bright Python might be for that.

00:20:56 And then after that, it checks some environment variables.

00:20:58 Like if you want to-- if you have 3.10 installed, for instance, for Python, you have an alpha installed.

00:21:02 But you want to make sure that if you ever say, hey, if I say Python--

00:21:06 if I run Py with no arguments or say, hey, I want to run a Python 3 version of Python, you can actually set the environment variables to restrict it and basically specify the exact version you want.

00:21:16 And then after that, if none of that triggers, it just finds the newest version and runs that.

00:21:20 I've been running this personally for a while.

00:21:23 And when I added the .venv support, I've completely switched.

00:21:28 I don't even bother typing Python anymore because this completely fits my workflow of just doing exactly what I think it should do whenever I need.

00:21:36 Now, the question I have for the two of you and anyone in the audience who cares to answer is, do you think prioritizing virtual environments over shebangs makes sense?

00:21:44 Now, my argument is yes, obviously, or else I wouldn't have done it this way.

00:21:48 But this is, I don't know how much of this is a unixism versus just in general because I do hope to actually add Windows support to this as well and make this a universal Python launcher. So the reason I did it this way was on Unix you can just chmod a file and add the executable bit and that's how you can execute it. And honestly most of my files at this point are going to be in a virtual environment anyway whether installed via pipx or I create an entry point and I install that. So once again I don't need the shebang directly it's just going to be baked into the executable and Windows will do the exact same thing right Like set of tools will give you that little shim.

00:22:22 So to me, if I am running in a project directory with a virtual environment, whether activated or not, I'm assuming that's what I want.

00:22:30 Don't try to figure it out for me or else I'd be running this somewhere else and I would not have a virtual environment installed.

00:22:36 Does that logic make sense?

00:22:37 Do people, do you two think I made the right decision here in choosing virtual environments over shebang lines or am I crazy?

00:22:43 - I forgot shebangs were even supported.

00:22:45 - I'm all about virtual environments, yes.

00:22:48 - Okay, cool.

00:22:49 - I think this is fantastic.

00:22:50 I've long wanted an easy way to just say I'm down inside.

00:22:55 Maybe you can tell me if it works this way.

00:22:58 Does it traverse up looking for a virtual environment?

00:23:01 Like if I'm in a sub directory and I try to pie a file, but one directory up, there's a virtual environment.

00:23:08 Will it go up and find that and then use it?

00:23:10 >> No, I did not implement it that way.

00:23:12 It would not be too difficult to do it that way.

00:23:14 But for simplicity reasons, when I first plugged this in, For my purposes, I'm not an SRC guy like Brian is, for instance.

00:23:21 So I don't need to worry about that as much.

00:23:23 But that'd be totally reasonable feature request to ask for to be able to traverse up a directory is looking for the dot VNV directory.

00:23:31 >> Yeah, very cool.

00:23:32 >> I mean, I'm down a level of my SRC go up a level to find the actual.

00:23:36 >> Right. Like I have a lot of things that will do like maintenance for my website.

00:23:40 So I'll have like a bin folder as one of the subfolders of my website.

00:23:44 Then I'll go in there and I want to run something.

00:23:45 if I'm like, oh, I should have run and gone up and then been slash, right?

00:23:49 I think it'd just be really cool.

00:23:50 Like I'm sort of in the realm of this virtual environment, even if it's not at the same working directory.

00:23:56 - Yeah, and one thing I do want to clarify here is this is very much about simplifying running Python manually.

00:24:01 It is not meant to completely replace running Python, right?

00:24:05 Like a misnomer I hear from people when I tell them about this is like, oh, hey, are you going to add a config file to be able to alias to PyPy versus specifically, or this thing or a framework builder?

00:24:15 that thing is. And for me is if you have that kind of risk, specific requirement of a specific version of Python you have installed, just use the absolute paths of that version of Python. I don't think this is, this is purely for, I just want the newest version. I don't care what it is.

00:24:30 Just give it to me. Or I have a virtual environment.

00:24:32 Just give me the virtual environment. I don't want to have to think about it.

00:24:35 If you have to put thought into what kind of Python you want to run, I think you should be specifying that manually, not be using this.

00:24:41 Well, so on the, on the side of the, being able to go up a couple directories looking for virtual environments.

00:24:48 I'm often not in the source directory.

00:24:50 I'm often sitting in the tests directory running pytest on stuff, in which case, I guess I already am in a virtual environment, so it doesn't matter, but I might just, open up another terminal and, and try to, and, you know, just, just run Python.

00:25:06 So I like this.

00:25:07 I'm excited to hear that this is eventually going to be a windows thing.

00:25:11 Also, hopefully, I don't actually normally use the.

00:25:15 The Python launcher on Windows, it doesn't do looking for virtual environments, does it?

00:25:20 >> No, that is exclusive to the Unix version of this launcher.

00:25:25 So basically, the environment variable it will use, it doesn't actually look on path, it completely uses the Windows registry.

00:25:33 It does the shebang and that's it.

00:25:35 So looking in the .venv folder, that is entirely my addition and the order of execution here is kind of tweaked to what I think.

00:25:45 And it doesn't search on path actually.

00:25:48 So that's a Unix thing specifically.

00:25:50 But I suspect this actually helped with the Windows Store, although I think Steve Dower fixed that issue with the Windows Store install.

00:25:56 But yeah, so there's slight tweaks.

00:25:59 But I figure if I have a logic done already, there's no reason not to just make it universal to support multiple platforms, so why not?

00:26:06 - Yeah.

00:26:08 So your announcement here has kind of lit up the live stream.

00:26:11 So ZDocs is just a Brett Cannon fan, which is awesome.

00:26:16 Gendalfour asks, "Is the Rust version cross-platform?" Is there a chance of this on Windows?

00:26:23 >> No, I've not tried it on Windows.

00:26:27 It definitely works on Mac and Linux.

00:26:29 So it truly is Unix-based, so it will handle that no problem.

00:26:33 I've not tried to wire it up into the registry at all, so that's not there.

00:26:37 I have an open enhancement issue to do that.

00:26:40 I honestly don't know what would happen if you tried running on some Windows.

00:26:43 I haven't tried.

00:26:45 Everything's very hard-coded to Unix at the moment just to get this done.

00:26:48 If you look at the readme, you'll notice everything is slash bin.

00:26:53 It's like for virtual mines.

00:26:54 There's no scripts support here.

00:26:58 If slash one, I do Windows support.

00:27:00 Obviously, I'll look at fix.

00:27:01 But I have tried putting zero effort.

00:27:03 Because the Python launcher for Windows just comes with the install from python.org, right?

00:27:07 So there was no real time pressure to try to get that done.

00:27:09 So I haven't tried it.

00:27:11 - I'm a big fan.

00:27:12 I could try this on my macOS and I'd be happy now.

00:27:14 - Yeah, this is how I do it.

00:27:16 I have it on my Mac.

00:27:16 I just install, you do have to install Rust to install it right now 'cause I haven't figured out how to do distributable binaries that you can just download.

00:27:24 But yeah, if you have Rust installed, which you can get through RustUp or Humber or whatever, it's just a cargo install away.

00:27:30 So if you wanna give it a shot, please do so.

00:27:32 - Fantastic.

00:27:33 And then--

00:27:34 - I kind of forgot that my Mac was Unix-C.

00:27:36 (laughing)

00:27:38 - That's right, and Magnus agrees on the VMV over Shebang.

00:27:41 - Awesome.

00:27:42 - And GandalfForce is same as well.

00:27:44 I don't think I've ever seen a Shebang that was more specific than user bin Python 3 anyway.

00:27:48 - Yeah, and I actually suspect the Shebang support was partially because the Python launch has been around back in Python 2 days, right, where that was much more of a concern.

00:27:56 So like, as I said, I started this in 2018, so it was pre-Python 2 deprecation.

00:28:02 So it's still supported there, but a lot of this I think was also partially to support the 2 to 3 transition.

00:28:07 So those little extras here I don't think are quite as important, unless Python 4 happens someday, which there are zero plans for.

00:28:14 So I don't think so.

00:28:15 >>Yeah, don't hold your breath.

00:28:17 >>By the way, one extra nicety I want to tell people is if you're a Starship user, the Starship cross shell prompt, there is a setting in Starship that lets you specify how it figures out what version of Python you have.

00:28:32 Now, it does look for virtualenv, but otherwise it has a list of binaries that it will execute to try to figure out what version of Python you have.

00:28:39 If you set it to Pi using this, it will always tell you either what the virtual environments Python version is in the prompt or whatever the newest version of Python is installed.

00:28:49 So it has a really nice side effect because if you read the docs in Starship, there's a big tip saying, hey, if you have a Python installed that's default, i.e. macOS, and it'll always say 2.7 unless you happen to have an activated virtual environment, which always threw me 'cause it's like, no, I'm not using 2.7 in this project.

00:29:04 As soon as I added this support for .venv files and tweaked my Starship config for this, it always tells me the exact version that I happen to have set up for my virtual environment.

00:29:14 It's really handy.

00:29:15 - For those of us not in the know, what's Starship?

00:29:18 - So Starship is a cross-platform shell prompt tool.

00:29:22 So it's written in Rust, but basically what you do is it has instructions for Bash and Zesh and Phish and PowerShell and everything else.

00:29:30 And basically it just gives you a line.

00:29:34 Brian's got it pulled up on the screen for those on the live.

00:29:36 And it's basically just an easy way to just say, hey, this is how I want my prompt to look.

00:29:40 Don't worry about whether it being Bash or Zeesh or Phish, whatever.

00:29:44 I'm a Phish user.

00:29:45 I'm sure Michael's probably a Zeesh user being a macOS user like he is.

00:29:48 Yep.

00:29:49 But it shouldn't matter.

00:29:50 My prompt is a prompt.

00:29:52 And pretty much, they have pretty consistent user support.

00:29:55 So I just said, yeah, you know what?

00:29:57 I like some of the niceties it has automatically baked in.

00:30:00 It does notification-- it changed the prompt for the usual, oh, I edited my git checkout.

00:30:06 It'll tell you what branch you're on, all these little nice things.

00:30:09 And setting Fira code as my font gives me all the nice little glyphs I want.

00:30:13 And so I said, nice, all right, cool.

00:30:15 It'll tell me what version of Python's currently activated, except for that annoyance of being on Mac, it kept saying, oh, you've got 2.7 until I activate it.

00:30:23 And I was like, no, I don't like this.

00:30:24 So I prioritized getting the .vnv done, and then lo and behold, it magically now tells me exactly what I want for Python.

00:30:30 - Nice.

00:30:31 - Wow, that's super cool.

00:30:32 Now we know, Starship, fantastic.

00:30:35 >> Yeah. Before we move on, I'd like to thank our sponsor.

00:30:39 This episode of Python Bytes is brought to you by Datadog.

00:30:43 Are you having trouble visualizing latency, CPU, and memory bottlenecks in your apps, and not sure where the issue is coming from or how to solve it?

00:30:51 Datadog seamlessly correlates logs and traces at the level of individual requests, allowing you to quickly troubleshoot your Python application.

00:30:59 Plus their continuous profiler allows you to find most resource consuming parts in your production code all the time at any scale with minimal overhead.

00:31:10 Be the hero that got your app back on track at your company.

00:31:13 Get started today with a free trial at pythonbytes.fm/datadog or just click the link in your podcast player show notes.

00:31:22 Ooh, that's neat.

00:31:22 Yeah, very cool. Thanks, Datadog.

00:31:24 So, Brett, I want to take you down a little bit lower.

00:31:28 or if it's turtles all the way down, a few turtles down to this whole Tui world, and talk about this thing called build a text editor with Python and curses.

00:31:37 Is curses, is that what you do when you get upset because it's too low level or, oh no, it's about the curses, sorry, okay.

00:31:43 - Gotta remember I'm on the Python Bytes podcast.

00:31:45 There are gonna be jokes like that.

00:31:47 - They're gonna be bad too, by the way.

00:31:49 So, now here's a really cool article by Waseem Lorgat about basically walking you through building a text editor like Vim or Emacs in the terminal using Curses, which is a library that lets you control what happens on the screen much better than like Print and Log and Warn and whatnot.

00:32:07 So there's a couple of just interesting things.

00:32:09 I thought going through this might just give people a sense of like what it's like to work with Curses.

00:32:13 And then there's this context of this text editor you can play with.

00:32:16 So for example, a minimal Curses app, all you gotta do is define a function.

00:32:20 That's your main function.

00:32:21 And then while true, go to the screen and get the key.

00:32:25 And that's it, you just say get key and it just gives you whatever it gets pressed.

00:32:28 Without any help here, there's probably not a way to get out of it.

00:32:32 No, maybe Control + C, but yeah, there's not like a quit or anything.

00:32:36 So you can really easily add like some tests and say, "Well, if they gave me the key, you know, "escape, then show the little colon." You can WQ exclamation mark, whatever, to get out of it.

00:32:46 However you wanna exit your text editor that you're building.

00:32:50 And then they talk about how to show stuff on the screen.

00:32:53 So if you wanna just add a line, you can say at this XY screen, you know, cursor location, just write this line of text on the screen and it'll add that.

00:33:04 So really easy and one of the things they do is they pass over the file name and it's kind of meta, like they edit the file that is the demo for the editor with the editor as they're building it, which is always fun to do.

00:33:15 So you can do that.

00:33:17 But then through this article, they go through and they build out like a window class that talks about how big is the screen, this is what Brett was talking about, like, ah, I gotta figure out what my screen looks like and all that stuff, and also a cursor where you are on the screen, how to have a view into the file because you might have moved to the right a little bit and the file might be a thousand lines, but you've only got a 40 on your screen or whatever.

00:33:41 So anyway, if this is interesting to you, I think you should go through this article and check it out.

00:33:45 In the end, you end up with a pretty simple but non-trivial little text editor that lets you do stuff.

00:33:50 So I think it's pretty neat.

00:33:52 What do you guys think?

00:33:53 This shows me why I really hope will grants Brian's wish of making Rich a full TY library.

00:33:59 - Yeah, I do agree.

00:34:00 I think if Rich, if something like that that has a really beautiful display technology, but also has input, like this is cool 'cause it has really great way to accept user input and like update the screen, but it's very low level.

00:34:12 It's like, I don't know, it's OpenGL versus Pi game or arcade, or you're like at the level of, here's what I put at this cursor, this XY coordinate, let's put that there.

00:34:22 Yeah, I think it's a great showing of actually how much work it actually needs to go into making those full text-based UIs that you see, like you used to see at the grocery store.

00:34:31 And those screeners you probably still do at some of your grocery stores on that screen.

00:34:34 And just like-- or when they book your airline ticket, and you're like, oh my god, what the hell are you using?

00:34:38 You do this all day?

00:34:40 Yeah, exactly.

00:34:40 It takes a lot of work to make those things happen.

00:34:43 It's surprising how much work it is, and hence why getting higher level libraries like--

00:34:49 I think it was the Prompt Toolkit we were told about earlier and rich and all that would be very welcome in existing.

00:34:55 - Yeah, absolutely.

00:34:56 Do either of you guys know if there's any cursors libraries for Windows?

00:35:00 Magnus is asking, that's why he's used Prompt Toolkit before, but I'm not sure actually.

00:35:05 - Neither am I.

00:35:06 - Yeah, yeah, cool, cool.

00:35:07 All right, what's the next one?

00:35:10 Brian, you got the next one, right?

00:35:11 - Actually, I skipped, so Brett's next.

00:35:14 - All right, Brett's next, and I'll pull up Brett's thing.

00:35:16 All right, Brett.

00:35:17 - Okay.

00:35:18 - There's been a major language feature announced that is coming in 3.10, right?

00:35:23 - Yes, which actually was in your quick links at the end of episode 220, which Brian called the five-barrel foot gun, which is pattern matching.

00:35:34 So one of the things that always happens whenever there's a new Python feature that gets announced, and especially one of this size that gets out into the general community, is some interesting feelings from people.

00:35:47 And so this is kind of slash--

00:35:51 I don't want to say rant, but little-- just me as a steering council member just trying to explain how this all came about, where we're coming from as a steering council in general.

00:36:01 I mean, obviously I'm speaking for me directly, but in general, I think how the steering council kind of thought.

00:36:06 But also just kind of helping put all this in perspective, because I think for a lot of people, this might be the first big feature that they've seen, because we used to do this all the time in Python, too.

00:36:15 but things kind of slowed down for Python 3.

00:36:18 So as I said, I've seen around the internet a lot of people ranging from, oh, this looks really cool, I can't wait till I can use it, to people screaming bloody murder that we're killing Python and oh my God, it's the death knell of the language.

00:36:29 I've been doing this for 17 years.

00:36:30 - Is that stressful for you?

00:36:32 'Cause it used to be?

00:36:34 - It used to be stressful, now it's just frustrating.

00:36:37 So for instance, I gave a talk at PyCon US 2018, it was one of the keynotes, about participating in open source.

00:36:43 And one of the key things I said in it was people just need to try to be kind to each other.

00:36:48 It's it's kind of a very generic thing I know but it really makes a difference as a project maintainer myself right like having people tell me what they think I need to be doing or what I should be doing is really frustrating right.

00:37:01 Like I put my personal time and effort into helping make this happen.

00:37:06 And the way you respond to that is tell me what I should be doing.

00:37:09 I can only imagine people who are parents having other people tell them how they should be raising their children.

00:37:16 It's worse than helicopter parents. It's like helicopter backseat parenting.

00:37:20 Exactly. And it's kind of the equivalent for open source maintainers. People doing the backseat, "Oh, here's what you really should be doing with your free time, with what little time you have left on this planet." >> Yeah.

00:37:33 >> So it used to get really upsetting, and now I'm just frustrated and just disappointed that this still happens.

00:37:41 It's also a little weird too because in Python, we have tens of millions of people using language at this point.

00:37:47 It's immeasurable. It's just cute.

00:37:50 Which means even if you assume one out of a thousand people are jerks, 0.1 percent, let's do 0.01 percent.

00:37:57 We're still talking tens of thousands of people out there who basically know my face, name, and address, and feel totally fine sending me mail on occasion, or just posting out in the comments outside where we all congregate about what they think I should be doing with my life.

00:38:13 So it's one of these things where, it's just frustrating.

00:38:18 - I don't know how a lot of people feel about it, sorry, but I think when you hear those negative things said to you, even if a thousand people are appreciative, the one negative thing you get feels so much, it makes such a bigger, a disproportionate--

00:38:30 - At least.

00:38:31 - At least.

00:38:32 - At least.

00:38:33 And the problem is it's not relative numbers, it's absolute numbers.

00:38:37 And at the scale that we're at with Python, the absolute number of people who just don't, haven't quite either, just, I mean, honestly some people are just totally ignorant that they are speaking this way and that they don't really realize the way they're phrasing things matters, or even that the way they're phrasing it comes off that way.

00:38:51 Like not everyone who says should really means for it to come off that way.

00:38:54 Thank you, Dean, I appreciate the awesomeness call out.

00:38:58 But it's one of these things where I have to bring this up every couple of years.

00:39:03 And then I usually end up doing a blog post, which honestly, this is kind of a rough draft of the blog post.

00:39:07 I'm just talking out loud with all of you.

00:39:08 - Yeah, yeah.

00:39:10 - And bouncing ideas off all of you for the feedback.

00:39:13 But it's just, it gets a little exhausting that this is something I have to bring up every couple of years.

00:39:17 You'd hope that we'd all learn this by now.

00:39:20 It's not like open source is a newfangled thing we've all just discovered.

00:39:23 But there's still this disconnect between the consumer /users/takers of open source versus the maintainer/producer/givers of the community.

00:39:33 And the disconnect of how to just communicate with each other is still there.

00:39:38 And so specifically when it comes to this stuff with Python, right, is people go like, "Oh my God, this is crazy." And it's like, "No, it's not.

00:39:45 I've been doing this for 17 years.

00:39:47 Everything is controversial when it comes to syntax." True and false were controversial, right?

00:39:52 Like true and false.

00:39:53 There were arguments on Python Dev on whether or not we should add those keywords because they would break code that chose to define those constants as 1 and 0.

00:40:01 >> Is that why it's capital T?

00:40:04 >> Well, it's also because they're singletons, and that's just the practice we follow with none.

00:40:07 So that was really where it tied in.

00:40:09 I mean, it definitely helps that capital T lowered the chances of it being false.

00:40:14 >> Yeah, exactly. It's less likely.

00:40:15 >> But that was an actual discussion we had, was do we want to add Booleans to the language?

00:40:20 Now today, everyone scoffs at that and laughs.

00:40:23 Are you kidding me? Booleans, really?

00:40:25 everything in the language gets debated. And in this too, right? Like everyone's going like, "Oh my God, what are you doing?" Do you understand the timeline of this? Guido brought this up, I think in July, maybe? And as one pep, got a massive amount of feedback on Python Dev on this, went back with his coauthors, broke it up into three peps, 634, 635, and 636, so that there was a pep about the design, a pep about the rationale behind the design, and a pep that acts as a tutorial to try to make it more easy to consume. Brought that out in October. We discussed it on Steering Council 2020. We made a recommendation that probably the next one should accept it, but we still didn't feel we had enough time to accept such a large thing. Fast forward now to today where Steering Council 2021 had a chance to sit down and look at the recommendation and the PEPs and have a discussion, including calling Guido in personally at least two times to talk directly to the Steering Council to help us understand where he was coming from. Like, Like this was not a snap decision, but everyone acts like it was.

00:41:23 Like this is literally taking over.

00:41:24 - Because it finally appears on their radar and they're like, oh, where'd this come from?

00:41:27 - Exactly, oh, it's like on Hacker News today, suddenly it happened.

00:41:30 Like no, no, no, this has been happening, this has been in discussion actively in public for six months.

00:41:35 I first heard Guido talking with someone at a language summit in 2018 about the idea of pattern matching.

00:41:40 Like this has been on people's radar as something people have wanted for that long.

00:41:44 And I'll fully admit, I wanted it.

00:41:46 Pattern matching is something I've wanted for a long time.

00:41:49 But it's just one of these things, once again, people just don't stop and think about the time and effort that go into all this behind the scenes.

00:41:55 It's just, in my worldview, this just happened, versus, oh, there's probably stuff that happened that I'm just not aware of.

00:42:02 And specifically about this, one thing I always notice about this is people need to understand the way the language is designed, right?

00:42:08 Like, we aim to increase your productivity.

00:42:10 Now, that means different things to different people, but in general, it means keeping a language that's easy to understand and small enough to have in your head, but also leads to you being more productive, which also means readability, right?

00:42:21 There's a lot of side effects that we all appreciate that come with productivity, but that's really the ultimate goal to me.

00:42:27 It's not that the language is readable.

00:42:29 Readable makes you productive.

00:42:31 And for pattern matching, there are certain algorithms that are just really difficult to do without pattern matching, right?

00:42:36 Like the classic examples are parsers and compilers, and they're not easy to do without having pattern matching.

00:42:42 There's a reason why functional programming languages that have had pattern matching for a very long time are the best places right now to typically write a parser or a compiler, because the algorithm just works so much better that way.

00:42:54 So there were reasons why we brought this in.

00:42:56 There will be increases in productivity for some people.

00:42:58 We do realize that it is a big lift, but we also realize not everyone's going to see this day one.

00:43:05 It is way more than a switch statement, which I know a lot of people typically look at it as.

00:43:09 The key point is it matches on structure.

00:43:11 It's not matching necessarily just on value.

00:43:14 is the big difference between an if statement versus not. There was a lot of work behind this. There are reasons. This was not major. The other thing I keep seeing about this is people going, oh, this is not Pythonic.

00:43:26 >> Well, it is now.

00:43:28 >> Yeah, I hate to break it to people, but Guido van Rossum, the creator of Python and thus probably the harbinger of what is Pythonic, is a co-author and a big pusher of this pep.

00:43:38 Guido helped make this happen. Unless you want to go up to him at PyCon and tell Guido that he doesn't know what's Pythonic or what's not, I think we kind of just have to go with it that this is now what is considered Pythonic. I will say I have seen people say, oh, my God, this is what happens when we lose the BDFL. Like the person who was the BDFL made this happen, right?

00:43:56 **Jason:** Yeah, yeah. It's not that.

00:43:57 **Tim:** It's a really funny disconnect with people. Like Guido drove this. Like Guido talked to the steering council about this. He was the point person for this. He really helped make this happen. So it's as Pythonic as it can be if you consider Guido the creator and head person in terms of the design of the language, which I will fully admit I still do.

00:44:16 I kind of view Guido no longer as being BDFL, as kind of he relinquished bureaucratic overhead costs in his life of the language.

00:44:23 And the steering council is more or less taking that on, but I still trust Guido's gut more or less.

00:44:27 Like if he really went off the rails, we'd stop him, but I don't think this is him going off the rails.

00:44:31 I think this is us going like, he's that one step ahead of us.

00:44:34 - Yeah, and actually Leon says, I just wrote a horrible if LF statement and he's looking forward to pattern matching.

00:44:41 Yeah, I mean, there are some real places where I think there's going to be benefits to ways to structure things that will just make things look better.

00:44:48 Yeah, and Magnus says, "Greed is me," that Python's full spectrum language and it just extends that spectrum.

00:44:55 Yeah, right. It's, yeah, thanks for that, Magnus. It's one of these things I think some people lose track of that being beginner-friendly does not mean only for beginners.

00:45:04 And that's where this productivity thing comes in.

00:45:07 I think that's actually a huge part of Python success, right?

00:45:10 Visual Basic 6 was awesome for beginners, for example.

00:45:13 But it just stopped.

00:45:14 Like, well, you can't do that here.

00:45:16 You're at the limit.

00:45:17 I'm sorry.

00:45:18 I don't want to be at the limit.

00:45:19 I want to learn C++.

00:45:20 Don't make me.

00:45:21 If you want to be beginner-friendly, go code and scratch.

00:45:24 No one wants to write production code and scratch.

00:45:26 It's great to get going, but there's a limit.

00:45:29 One of the great quotes that I've heard that I think applies to Python is that you can do easy things simply but you can do difficult things are possible.

00:45:39 I know I got that quote wrong.

00:45:41 >> It's definitely close enough that I'll just go with it.

00:45:44 That is very true.

00:45:46 That is the goal here, is to make the common things easy and simple, and definitely approachable, and make the hard things at least possible.

00:45:55 This is part of it. This opens up the possibility for things that were really difficult to do in Python before.

00:46:00 >> Yeah, fantastic.

00:46:01 >> Yeah. I'm thinking of doing a blog post about this whole rant called the social contract of open source to try to harp on this whole should versus need and just--

00:46:08 it's OK.

00:46:11 Sort of criticism is totally acceptable.

00:46:13 It's just be understanding about how you're delivering it, because we're all on the internet.

00:46:16 We do here.

00:46:17 And indirectly, you will suffer, because guess what?

00:46:20 That project you're using is going to then suffer based on what you say.

00:46:23 So it does matter.

00:46:24 >>Yeah.

00:46:25 >>And just one aside, I think last podcast, Michael said this was influenced from Haskell.

00:46:31 is actually the design comes a lot from Scala specifically for this.

00:46:35 But we got list comprehensions from Scala.

00:46:39 So we have actually gotten some nice things out of Scala.

00:46:41 - Interesting, yeah, okay, very interesting, yeah.

00:46:43 Yeah, I mean, my feeling is it's a big step, I think.

00:46:47 It's gonna take a while to really see the value of it if you're not working directly in a place where it's one of these algorithms that applies a lot, but I think it'll be good.

00:46:58 - Yeah, it's definitely one of those things that when you see it for the first time, If you're not used to using a language, like most functional languages that have pattern matching, it's goes like, "What? Why?" >> Yeah.

00:47:08 >> When you get exposed to it, when you start to use it more, it starts much like learning another programming language.

00:47:12 It starts to tweak your approach to certain algorithms and stuff.

00:47:15 It's another tool in your toolbox, really.

00:47:18 >> Nice. Well, Brian, you've got the follow-up.

00:47:21 >> Yeah. Actually, that's why I thought this would be good as a follow-up.

00:47:26 Guido announced that he wrote the introduction to pattern matching and that it's now part of an appendix A of PEP 636.

00:47:39 So I went off and looked at it and it actually really helped me a lot.

00:47:43 So this introduction kind of, I actually, I've been trying to follow this PEP and honestly been confused for a while as to like exactly how it's working.

00:47:53 A lot of people have been focusing on the weird parts, but the easy parts actually are really nice.

00:47:58 So I really, there's an example that it starts off with that kind of looks like a switch statement, right?

00:48:06 So it's a, I want to match a status and like an HTTP status.

00:48:11 And then I do something different based on 400 or 404, 418.

00:48:15 And then, and then of course we're like, well, what about default, right?

00:48:18 So there's gotta be some sort of fall through that I handle all the other cases.

00:48:22 And there's an example of that.

00:48:23 And I was actually curious, the example here shows using just a single underscore magic variable as a catch-all.

00:48:34 And so, Brett, I was just curious, can I use any variable here?

00:48:37 Or does it need to be the single underscore?

00:48:39 Do you know?

00:48:40 So I was actually going to comment on this when you were done.

00:48:44 So the underscore actually has some special semantics here, because in most languages that have pattern matching, the underscore represents the wildcard.

00:48:53 This has actually been one of the most controversial parts of PEP 634 was the selection of this to stay consistent with other languages.

00:49:00 While I will not suggest to people that there is an opportunity to remove pattern matching or to necessarily have massive changes to it, one of the things that if people try this out in real world code and can get feedback to us well before beta one locks in and gets released, 'cause that's our cutoff for feature changes for Python 3.10, which will be in May.

00:49:22 This is one of those areas where we could actually consider changing, right?

00:49:26 Like fixing up code to change this case wildcard syntax of an underscore to something else is totally possible if we got feedback from the community that, yeah, this really was a nasty sticking point and really didn't work out well.

00:49:39 So I do wanna say that there is still a chance to potentially influence the final outcome of how the exact thing is, although I don't wanna suggest that we--

00:49:48 - Right, 'cause it's not shipped in 3.10 yet, right?

00:49:51 - Exactly, it's not shipped in 3.10 yet, so we can tweak if necessary, but don't come out, I wouldn't suggest people come out and try to completely rewrite the entire syntax, but in this specific case, yes, it is special, yes, some people don't like it, and if enough people really came forward and really said this is the one thing I'd wanna tweak, I think we'd be open to considering tweaking.

00:50:12 - Well, the underscore gets used so much for so many interesting things, like why not one more?

00:50:18 I'm OK. I personally I don't care.

00:50:20 I just want to know what it is.

00:50:23 I mean, I didn't like I didn't like spaces instead of braces when I first hit it so.

00:50:31 But what happens if I put it like X there instead of underscore if you put X?

00:50:35 So the rules here basically are if you put a single name that has no dot in it, it's a binding.

00:50:41 You put a name there with a dot.

00:50:43 It will be a binding.

00:50:44 Now this is one of the things that I learned from Guido in one of our help clarify this for me and one of the reasons I ended up voting to accept this was let's look at the like consider these cases right return codes. You're probably not going to hard code 400 and 404 and 14. You're going to import the HTTP dot status module and you're going to specify the constants from there right. Do you really want to rebind those constants by accident in your code? Oh no no, but because it's been imported from a module or off a class for instance, you're not going to be wanting to do assignment. You're just going to want to So if there's a dot in the name, it automatically is just a reference.

00:51:18 Now, some people get really hung up on that when they think about the single binding of a name, understandably.

00:51:24 But here's the thing is, while this is a case right now where if you had just a bare name, that's a bind, where if there's a dot in it, it's actually going to be a reference and a load to do a value check, there is a potential in the future if people come back after trying out the PEP and having experience with pattern matching matching to add to the language a leading dot, which is actually used in Swift, by the way, in the Swift community for something else.

00:51:52 But the key point is we can make it like a dot x to act as a load for comparison for a local--

00:51:58 >> That's an interesting syntactical use.

00:52:00 Like it's not actually coming from anywhere, but treat it as if it were.

00:52:03 >> Exactly.

00:52:04 Now, this was originally in the PEP, and there was massive pushback from people thinking that they would totally miss the dot.

00:52:11 But Corey Benfield, who used to run requests and all that, and has multiple talks from PyCon, person who helped me start pushing Sans I/O development of libraries in the community, he works at Apple now on Swift stuff, and he posted something on Twitter.

00:52:26 And I asked him, like, hey, does that leading dot have any problems with Swift?

00:52:30 And they said, actually, the whole community is totally fine with it.

00:52:32 There's no readability problems.

00:52:33 It just totally works.

00:52:34 Not an issue.

00:52:35 So we could potentially, in the next version of Python, actually make it so that that have it a dot in the name, whether it's just leading or not, we could actually generalize that.

00:52:44 But because it's a forward compatible thing and backwards compatible, we decided not to do that in this path and just try to just keep it simple, simple, keep it simpler than it had to be necessary to go out and then add an opportunity.

00:52:56 So if I just put a bare X, it's going, will it hit it and will it bind to it and assign the value to X?

00:53:04 Yes.

00:53:05 Okay.

00:53:06 Actually, that's what I expected because as I go down this little tutorial, it talks about like, on pattern, like unpacking, which is totally cool.

00:53:15 So let's say you have a, like a, the example is a point object, which is like just an X, Y tuple.

00:53:21 now I want to be able to, if I, in the, the case statements are, you know, specific points that you're going to match to, or like, let's say you don't care what X is, but you, you want to fix Y at zero in, in the case, in the case block you want to know what the value of X was.

00:53:40 So you do want that binding and that's really just cool.

00:53:44 I can't wait to play with it.

00:53:45 So my follow-up question, I'm glad you showed up here is, when can I play with this?

00:53:50 Is this in one of the alphas now or betas or do you know?

00:53:53 - I don't know if it's, I don't think it's landed yet.

00:53:58 Bram Butcher, who's one of the co-authors of the PEP has a working implementation already, which is actually available in a Jupyter, was available in a Jupyter Notebook somewhere.

00:54:09 So there's definitely a fork somewhere where you can try this out.

00:54:13 But this is not landed in mainline, so it's not out in alpha quite yet.

00:54:18 One thing I did want to point out about this that's really kind of cool, with the example that Brian's showing here, is the match against a point argument, as he said, that takes a two-item tuple.

00:54:29 You could actually change this to also accept a single-item tuple that represented x and y with the same value, and that would totally match separately as well.

00:54:36 So once again, this is matching against structure.

00:54:38 So you could actually pass in tuples of different sizes and have it automatically just kind of infer based on--

00:54:43 - Maybe do something different with 2D or 3D.

00:54:46 - Yeah, exactly.

00:54:46 Yeah, exactly.

00:54:48 So because it's a structural thing and not a value thing, it opens those very interesting doors.

00:54:53 - Cool. - Interesting.

00:54:54 Yeah, cool, it's really great to have you here to talk about all this stuff.

00:54:57 Final comment, close this one out, I guess.

00:54:59 ZDoc says, "I think once good syntax highlighting lands, "this will be as natural as list comparisons." - Yeah, and that's actually a good point.

00:55:07 One of the things we had discussed was, Mike, the leading dot, how hard would that be to see with or without syntax highlighting?

00:55:15 And we realized that, honestly, syntax highlighting will probably do it.

00:55:17 One thing some people were a little worried about was the reason this is even possible was because of the new parser that landed in Python 3.9, the new pgm parser.

00:55:27 It can do more contextualized parsing.

00:55:29 So that match, for instance, isn't gonna suddenly make all your match keywords or the match method from the RE module on match objects suddenly not work.

00:55:38 It contextually can tell that that match keyword is for a match statement.

00:55:42 So there might be a little funky coloring for some people based on how your syntax highlighting works.

00:55:46 Like you might suddenly have all your match methods highlighted like it was the match keyword.

00:55:50 But honestly, it'll be from what you're looking at in terms of code, it's gonna be fairly obvious that is not a match statement.

00:55:56 So we weren't too worried about that kind of haziness as it were when it comes to syntax highlighting.

00:56:01 - No, this is cool.

00:56:02 - I know a guy on the VS Code team.

00:56:05 - Yeah, so do I.

00:56:06 - You see him every morning in the mirror.

00:56:10 - A quick plug and thank you to Magic Python, which comes from the Magic Python team, Magic Stack, the people who do EdgeDB.

00:56:19 They actually maintain the syntax highlighting that we use in VS Code, as well as I think is using some blind text and add on, like they have a generic grammar that they use that they just auto-gen out to various editors for their syntax, mostly text format.

00:56:35 But kudos to them for always maintaining that syntax highlighting, 'cause that's actually what VS Code itself ships in the box.

00:56:41 - That's awesome.

00:56:42 - Yeah, nice.

00:56:43 Brian, I don't have any extras, do you?

00:56:44 - I don't, no.

00:56:46 - Brian, anything else you wanna throw out there before we make a bad joke?

00:56:50 - No, just thanks for having me on.

00:56:51 Thank you for everyone listening to me rant on about how to please try to talk to maintainers to help them keep their sanity.

00:56:58 And that's it.

00:57:00 I hope people give the Python Launcher a shot and it works for them.

00:57:03 - Yeah, that's very exciting.

00:57:04 - Let me know.

00:57:05 I can't make any promises about it shipping specifically with Python, but at least it's a tool there that I find useful and I hope others do as well.

00:57:11 - Cool, I'll definitely check that one out.

00:57:13 All right, you guys ready for the joke?

00:57:15 You know, we're all stuck at home, and especially if you're single, it's really tricky to get out and meet people and you know, whatnot, see what's gonna make you happy.

00:57:26 So I got a joke along those lines to kind of help people out there.

00:57:29 Ready?

00:57:30 - Mm-hmm.

00:57:30 There's this tweet by Christian Zhu, says, "If you're not happy single, "you won't be happy in a relationship." I mean, we've all heard this, how important it is to be just like content with yourself.

00:57:39 She says, "No, true happiness comes "from closing 100 Chrome tabs "after solving an obscure programming bug, "not from other people." Come on.

00:57:47 (laughing)

00:57:49 - Yeah.

00:57:50 - Anyway, I thought that was good and kinky.

00:57:52 - Are you two the type of folk who have like a bazillion tabs open at any one time, or are you more like, I'll only keep open exactly what I'm working on, as soon as I'm done, I close them.

00:58:01 - I am not a 100 tab person, but what I do sometimes I'll like leave the tabs open, like, oh, I'm not done with this.

00:58:08 And so I'll close it.

00:58:09 If I got to reboot the computer, the first thing I do is reopen the browser and say history restore previous session.

00:58:14 Cause I'm like, there were things in there.

00:58:15 I don't know what I was doing, but I know they're important.

00:58:17 So I may abuse that a little bit.

00:58:19 - I, my daughter came to me once and said, I need dead like finals.

00:58:24 And then my laptop is too slow.

00:58:26 I need a new laptop.

00:58:27 Like, okay, well, let's talk about what you're doing.

00:58:29 She was doing like three research projects and had like a hundred tabs open I'm like, well, let's just try this first. Can I can I tell you about this cool thing called bookmarks? and Anyway totally fixed it. Yeah, that's awesome dad showing bookmarks to the youngsters Yeah, magnus says the number of tabs is a measure of how hard the problem is and neils says - Great rant, love your work, Brett.

00:58:58 Great to have you on the show, Brett.

00:59:00 - Always happy to be on.

00:59:01 - Thanks for being here, thanks everyone.

00:59:03 Brian, thanks as always.

