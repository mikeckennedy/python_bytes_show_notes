
00:00:00.000 --> 00:00:07.460
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode 175


00:00:07.460 --> 00:00:09.900
recorded March 26


00:00:09.900 --> 00:00:13.600
2020 I'm Michael Kennedy and I'm Brian Okken Brian. We have a special guest


00:00:13.600 --> 00:00:20.160
Welcome Matt Harrison. How you doing, man? Glad to have you here. Good. Good. Yeah, come on. Yeah


00:00:20.160 --> 00:00:23.200
It's always nice to have you on the show before we get into it


00:00:23.200 --> 00:00:28.560
Let me just tell you this episode sponsored by Datadog check them out at pythonbytes.fm/datadog


00:00:28.640 --> 00:00:33.120
I'll tell you more stuff about them later. First, I want to just throw this out to both of you guys.


00:00:33.120 --> 00:00:38.400
The world is, I don't know, is it turned upside down or is it locked down or what has gone on


00:00:38.400 --> 00:00:41.040
with the world? It's crazy. >> We're kind of software people,


00:00:41.040 --> 00:00:45.760
so and I know we're all kind of in different boats. I am definitely grateful that I'm a


00:00:45.760 --> 00:00:51.840
software person. I have a lot of friends that are not, that are in the retail industry or


00:00:51.840 --> 00:00:57.360
the selling stuff to people sort of industry, or self-employed. And those people,


00:00:57.920 --> 00:01:01.440
they're really hurting. I've got a lot of people I know that if they're self-employed, you don't


00:01:01.440 --> 00:01:08.160
qualify for unemployment insurance and stuff. So there's a lot of people hurting them. How are you


00:01:08.160 --> 00:01:13.280
guys? It's crazy. Yeah. Matt, how about you? I just found out this morning that my largest client


00:01:13.280 --> 00:01:18.320
just dropped all my trainings for the rest of the year. So- That's not your favorite phone call or


00:01:18.320 --> 00:01:24.960
email to receive, is it? Not the best news, but the thought that I have on that is past couple


00:01:24.960 --> 00:01:30.880
years have been very good, right? And people have said like the bubble will burst and I don't know


00:01:30.880 --> 00:01:36.800
that we thought that a virus would do this, but I mean it looks like winter came for better for worse


00:01:36.800 --> 00:01:42.720
and so people are going to have to adapt and now if you can weather the storm it might, it's going


00:01:42.720 --> 00:01:47.040
to be tough though. I mean I was even talking with some friends who are in the medical industry


00:01:47.040 --> 00:01:52.240
and they're like we're worried about our jobs, right? And these are like doctors and people who


00:01:52.240 --> 00:01:53.420
who work at the hospital.


00:01:53.420 --> 00:01:56.960
So it's interesting to see what's going on.


00:01:56.960 --> 00:02:00.000
And I've worked from home for the good portion


00:02:00.000 --> 00:02:01.560
of the last 15 years.


00:02:01.560 --> 00:02:04.760
And right now it's scary to see


00:02:04.760 --> 00:02:07.780
that there's a lot of upheaval and we'll see what happens.


00:02:07.780 --> 00:02:09.340
How are things going for you, Michael?


00:02:09.340 --> 00:02:12.240
- Well, you know what, it's really interesting.


00:02:12.240 --> 00:02:15.320
If you'd asked me this question like six years ago


00:02:15.320 --> 00:02:18.040
when I was doing mostly in-person training,


00:02:18.040 --> 00:02:21.200
it would have been like somebody just cut the light switch


00:02:21.200 --> 00:02:23.740
Bob said, "We're all leaving.


00:02:23.740 --> 00:02:25.040
"Lock the door on your way out."


00:02:25.040 --> 00:02:28.440
It would have been purely traumatic.


00:02:28.440 --> 00:02:32.320
Luckily now, online courses are great still.


00:02:32.320 --> 00:02:34.060
Podcasting is great.


00:02:34.060 --> 00:02:38.200
What's ironic is my work life is literally unchanged,


00:02:38.200 --> 00:02:39.900
but the rest of my life is scrambled.


00:02:39.900 --> 00:02:42.920
My daughter is home from school 'cause they closed school.


00:02:42.920 --> 00:02:44.600
Oregon's now on full lockdown.


00:02:44.600 --> 00:02:46.640
It's hard to go out to dinner.


00:02:46.640 --> 00:02:48.400
Everything has changed in some ways,


00:02:48.400 --> 00:02:50.800
but ironically, not my work life, really.


00:02:50.800 --> 00:02:53.440
I'm sure it'll have some effect eventually, but nothing immediate.


00:02:53.440 --> 00:02:55.560
I guess one more thing before we move off.


00:02:55.560 --> 00:02:58.360
I'm just curious, what are your plans around training?


00:02:58.360 --> 00:03:01.840
Are you going to be teaching over Zoom or is it just focus on other stuff until it comes


00:03:01.840 --> 00:03:02.840
back?


00:03:02.840 --> 00:03:03.840
Yeah, I think both of that.


00:03:03.840 --> 00:03:09.000
I do have some clients who are moving to virtual training and I already do a bunch of virtual


00:03:09.000 --> 00:03:10.000
training anyway.


00:03:10.000 --> 00:03:16.360
So, I mean, it's sad that some of them aren't able to or can't due to circumstances or whatnot,


00:03:16.360 --> 00:03:22.440
But try and see if other people want virtual training and just work on other products that


00:03:22.440 --> 00:03:24.200
people are interested in as well.


00:03:24.200 --> 00:03:25.200
Yeah, absolutely.


00:03:25.200 --> 00:03:27.880
Well, hang tough you guys and everyone out there.


00:03:27.880 --> 00:03:30.320
It's going to be a wild ride.


00:03:30.320 --> 00:03:33.720
Hopefully the software side of the world is a little bit less bumpy, but it's still it's


00:03:33.720 --> 00:03:34.720
crazy.


00:03:34.720 --> 00:03:39.360
All right, well, let's talk a little bit about the future, Brian.


00:03:39.360 --> 00:03:42.480
We can't predict when the COVID stuff is going to be better, but you could probably predict


00:03:42.480 --> 00:03:44.200
some stuff about the Python future.


00:03:44.200 --> 00:03:45.960
I'm just still getting excited,


00:03:45.960 --> 00:03:49.200
used to being able to have Python 3.8 everywhere.


00:03:49.200 --> 00:03:52.520
And, but we've got Python 3.9 right around the corner.


00:03:52.520 --> 00:03:55.700
And in October is the scheduled release.


00:03:55.700 --> 00:03:59.480
I don't know if that'll change due to the virus or not,


00:03:59.480 --> 00:04:00.520
but that's where it is.


00:04:00.520 --> 00:04:02.600
And one of the cool things that I noticed


00:04:02.600 --> 00:04:06.220
from a blog article is that there's union operators


00:04:06.220 --> 00:04:09.720
coming for dictionaries in Python 3.9.


00:04:09.720 --> 00:04:11.920
And this is a PEP 584.


00:04:11.920 --> 00:04:16.120
and there's a article called Dictionary Merging and Updating


00:04:16.120 --> 00:04:20.280
in Python 3.9 by, I think, Yong Kui.


00:04:20.280 --> 00:04:22.680
And there's a couple new operators.


00:04:22.680 --> 00:04:27.080
One of them, it's just the bar or the bar equals


00:04:27.080 --> 00:04:29.040
or the pipe operator, whatever.


00:04:29.040 --> 00:04:31.160
Looks normal if you're used to,


00:04:31.160 --> 00:04:32.920
I guess that's the math or operator.


00:04:32.920 --> 00:04:36.440
- It's like a bitwise, it's like a bitwise or, yeah.


00:04:36.440 --> 00:04:37.760
- I'm kind of excited about it.


00:04:37.760 --> 00:04:39.680
So you can combine two dictionaries


00:04:39.680 --> 00:04:44.680
by just doing a dictionary one or dictionary two


00:04:44.680 --> 00:04:45.840
or something like that.


00:04:45.840 --> 00:04:49.240
And then the equivalent assignment operator as well,


00:04:49.240 --> 00:04:52.280
which is really an update operator and a merge.


00:04:52.280 --> 00:04:54.080
The article spent a little bit of time


00:04:54.080 --> 00:04:57.880
talking about the other older methods that you can use


00:04:57.880 --> 00:04:59.320
to combine dictionaries now.


00:04:59.320 --> 00:05:02.520
And I know people have covered those in a lot of places.


00:05:02.520 --> 00:05:05.080
The one thing, the article actually spent a lot of time


00:05:05.080 --> 00:05:07.480
on it and I just think it's something to watch out for


00:05:07.480 --> 00:05:10.280
and be aware of is when you're combining dictionaries,


00:05:10.280 --> 00:05:14.060
usually if there's overlapping values,


00:05:14.060 --> 00:05:16.920
like if there's a value with the same key


00:05:16.920 --> 00:05:19.560
in both dictionaries, you'll get the second one


00:05:19.560 --> 00:05:20.960
will take precedence.


00:05:20.960 --> 00:05:22.520
It's just something to be aware of.


00:05:22.520 --> 00:05:23.780
- Yeah, yeah, and that's the way it works


00:05:23.780 --> 00:05:26.360
in the current operators as well, right?


00:05:26.360 --> 00:05:29.440
Star star sort of combine stuff and whatnot.


00:05:29.440 --> 00:05:31.440
- Yeah, as long as you're aware of it, it's good to know.


00:05:31.440 --> 00:05:34.200
But this is clean, it's actually something that,


00:05:34.200 --> 00:05:36.240
now that I see it, I'm surprised that we don't already


00:05:36.240 --> 00:05:39.720
have an operator already in TicketMineDictionaries


00:05:39.720 --> 00:05:42.200
'cause it's something I kind of do a lot of.


00:05:42.200 --> 00:05:44.760
- Yeah, and if you look at the syntax there for the pipe,


00:05:44.760 --> 00:05:47.520
I mean, the pipe is already in the set operator


00:05:47.520 --> 00:05:50.240
and prior to sets existing,


00:05:50.240 --> 00:05:53.680
when people used to use dictionaries to emulate sets,


00:05:53.680 --> 00:05:55.100
I mean, they wouldn't do the or operator,


00:05:55.100 --> 00:05:57.600
but it's interesting that it's sort of coming


00:05:57.600 --> 00:06:00.040
round circle now that we originally had dictionaries,


00:06:00.040 --> 00:06:02.020
people started using dictionaries


00:06:02.020 --> 00:06:04.160
as a simple replacement for sets.


00:06:04.160 --> 00:06:06.440
Then we got sets, which had the pipe operator.


00:06:06.440 --> 00:06:09.080
Now the pipe is coming back to the dictionary.


00:06:09.080 --> 00:06:09.900
- Interesting.


00:06:09.900 --> 00:06:12.020
So why do you guys think they didn't use plus?


00:06:12.020 --> 00:06:14.780
Like, you want to combine two things,


00:06:14.780 --> 00:06:17.560
like two lists, you don't use a pipe to put them together.


00:06:17.560 --> 00:06:18.400
You use a plus.


00:06:18.400 --> 00:06:20.200
For strings, you use a plus.


00:06:20.200 --> 00:06:21.320
Plus already existed.


00:06:21.320 --> 00:06:23.160
- I think it's because of the union operator


00:06:23.160 --> 00:06:25.280
already being used for sets.


00:06:25.280 --> 00:06:26.540
- Yeah, you think so?


00:06:26.540 --> 00:06:27.380
Yeah, all right, cool.


00:06:27.380 --> 00:06:28.800
Well, yeah, it's good to see


00:06:28.800 --> 00:06:30.440
some nice shorthands coming there.


00:06:30.440 --> 00:06:34.220
But if we can have a pipe equals operator,


00:06:34.220 --> 00:06:36.920
give me the plus plus, come on, I just want the plus plus.


00:06:36.920 --> 00:06:38.680
(both laughing)


00:06:38.680 --> 00:06:39.520
- Double pipe.


00:06:39.520 --> 00:06:41.800
- Yeah, double pipe.


00:06:41.800 --> 00:06:43.120
What does that mean?


00:06:43.120 --> 00:06:44.480
All right, Matt, you got the next one.


00:06:44.480 --> 00:06:47.400
This one is short and sweet, but it looks pretty cool


00:06:47.400 --> 00:06:49.000
if you got the use case for it.


00:06:49.000 --> 00:06:53.580
- Yeah, yeah, so there is this super string library,


00:06:53.580 --> 00:06:58.580
which is a new library that's a replacement of,


00:06:59.240 --> 00:07:02.760
not a replacement, but it's a new string library for holding sequences of characters.


00:07:02.760 --> 00:07:08.160
It's built on this rope data structure, and apparently it's pretty optimized.


00:07:08.160 --> 00:07:12.640
It uses a 20th the amount of memory and a fifth the speed,


00:07:12.640 --> 00:07:17.520
so operates five times faster for a lot of operations.


00:07:17.520 --> 00:07:23.360
I think this could be super useful for people who are manipulating data.


00:07:23.360 --> 00:07:28.720
So it'd be interesting to look at, you know, if the people who are doing NLP could take advantage of this


00:07:28.720 --> 00:07:35.520
Definitely like the memory constraints, you know using a 20th the amount of memory would be awesome


00:07:35.520 --> 00:07:38.160
even in places like pandas


00:07:38.160 --> 00:07:45.280
NLP as well natural language processing the API is pretty basic right now. It's got


00:07:45.280 --> 00:07:50.980
Concatenation getting the length doing some indexing and slicing and stripping and uppercasing and lower casing


00:07:51.600 --> 00:07:58.880
So that could be a good with the speed and memory performance. They're showing that could be a good enough limited set of


00:07:58.880 --> 00:08:00.880
capabilities


00:08:00.880 --> 00:08:06.500
Sort of for me the elephant in the room is the f string for me. That's the best feature of python3


00:08:06.500 --> 00:08:09.120
I know


00:08:09.120 --> 00:08:11.120
implement that and uh


00:08:11.120 --> 00:08:17.280
Let's use it. Yeah, the other thing that's missing is negative indexes, but that can't be hard to add honestly


00:08:17.280 --> 00:08:21.120
Maybe it's hard to add quickly, but it can't be hard to add negative indexing


00:08:21.120 --> 00:08:44.120
That's a good point. I mean, they don't make any reference to whether they support Unicode. So that's, I guess, another question, right? If they do support the Unicode capabilities, the Python supporting, I mean, Unicode can make indexing a little bit more complicated, but that might be what's going on there. But this will be interesting to watch. Interesting library to watch. What do you think, Brian?


00:08:44.120 --> 00:08:50.680
I'm just not in a place where the strings are the memory or the bottleneck in any of my applications.


00:08:50.680 --> 00:08:55.800
Yeah, but to give you an example, like a real world example, like I've been playing with some


00:08:55.800 --> 00:09:02.760
Markdown stuff for like the sort of CMS side of things that I'm writing in Markdown. And if you've


00:09:02.760 --> 00:09:08.440
got something that's maybe 10, 20 pages of Markdown, it takes half a second to convert that from


00:09:08.440 --> 00:09:14.360
markdown to HTML. I don't know how much of that is like the actual string juggling and how much of


00:09:14.360 --> 00:09:20.120
that is just converting it to markdown is slow, but that's a non-trivial amount of processing


00:09:20.120 --> 00:09:24.280
that's like sort of around the corner. I mean, you would never do it manually. You'd use a library,


00:09:24.280 --> 00:09:28.920
right? But still, you can benefit from that. On that, you can think of all the people who are


00:09:28.920 --> 00:09:33.720
using static libraries, right? For web pages who, you know, once you get, they all complain about


00:09:33.720 --> 00:09:38.520
once you get X number of pages in there, they start getting slow and the rebuild takes


00:09:38.520 --> 00:09:44.840
five seconds instead of a half a second or whatever. And so something like this could help there as well.


00:09:44.840 --> 00:09:49.320
Right, theoretically. So this is not a super popular library, but I'm glad you put it on here


00:09:49.320 --> 00:09:54.760
because I think it's pretty cool. I guess two thoughts. One, it'd be interesting to look at


00:09:54.760 --> 00:09:59.800
what they're doing and if there's any easy low-hanging fruit to bring back to CPython,


00:09:59.800 --> 00:10:02.840
because it would be better if just Python strings were faster. And they're like, why would you make


00:10:02.840 --> 00:10:07.800
this it's the same speed you know what I mean? Then the other Brian you may have noticed there's no


00:10:07.800 --> 00:10:13.720
tests. Oh yeah it looks like it's recent it's like I don't know if it's even been around for


00:10:13.720 --> 00:10:18.280
more than a week. So yeah I think it's pretty new so if somebody's like oh this is cool let me try


00:10:18.280 --> 00:10:22.600
it out like maybe a way you could participate is like write some tests just to verify things right


00:10:22.600 --> 00:10:27.720
but yeah pretty cool. It's just imaginary if there's no test it's like no picture no proof man.


00:10:28.760 --> 00:10:33.800
if it continuously deployed in the woods and there were no tests to hear it, did it actually happen?


00:10:33.800 --> 00:10:38.920
Something like that? Yeah, exactly. Sure, that's the same, I think, the historical version.


00:10:38.920 --> 00:10:46.040
I thought the way of your new testing strategy is if it doesn't have tests and you don't commit it.


00:10:46.040 --> 00:10:52.360
Didn't you say you're using something like that? Yeah, that's good. That's a good way, for sure.


00:10:52.360 --> 00:10:57.160
All right, so this next one is going to affect everybody who works with Python. This is a big


00:10:57.160 --> 00:11:00.920
Hopefully it's not a bumpy deal, but it's a big deal.


00:11:00.920 --> 00:11:05.920
So the Python packaging authority folks, the PSF subgroup,


00:11:05.920 --> 00:11:09.700
they recently got funding to hire some developers


00:11:09.700 --> 00:11:11.380
to make pip better.


00:11:11.380 --> 00:11:14.140
So pip is awesome, we all pip things,


00:11:14.140 --> 00:11:15.420
and even if you don't pip things,


00:11:15.420 --> 00:11:17.940
if you pip-emp them or you poetry them,


00:11:17.940 --> 00:11:20.140
you really pip them down below, right?


00:11:20.140 --> 00:11:22.620
So they got a bunch of funding to make that better,


00:11:22.620 --> 00:11:25.100
and one of the challenges, one of the first challenges


00:11:25.100 --> 00:11:28.480
that they're tackling is that pip will,


00:11:28.480 --> 00:11:30.600
it's not, it doesn't take into account


00:11:30.600 --> 00:11:32.220
all the stuff you're trying to do.


00:11:32.220 --> 00:11:34.960
It just says, I see a requirements file,


00:11:34.960 --> 00:11:36.500
let me just go from top to bottom,


00:11:36.500 --> 00:11:38.140
just start hitting it, right?


00:11:38.140 --> 00:11:39.900
Install the first one, install the second one.


00:11:39.900 --> 00:11:43.020
So they're rolling out a new pip resolver


00:11:43.020 --> 00:11:44.440
at the end of the year.


00:11:44.440 --> 00:11:45.280
That's pretty cool, huh?


00:11:45.280 --> 00:11:46.560
- Yeah, this is neat.


00:11:46.560 --> 00:11:48.740
- Yeah, so the idea is basically,


00:11:48.740 --> 00:11:51.560
it's gonna go and it's gonna look at the dependencies


00:11:51.560 --> 00:11:54.120
of the various packages and try to install something


00:11:54.120 --> 00:11:56.560
that is consistent across all of them.


00:11:56.560 --> 00:11:59.500
Like maybe the first package in your requirements files


00:11:59.500 --> 00:12:03.280
requires, I don't know, docutils 16,


00:12:03.280 --> 00:12:06.320
and the second one requires docutils 15,


00:12:06.320 --> 00:12:08.040
or maybe the first one doesn't even specify


00:12:08.040 --> 00:12:09.180
and 16's just the latest.


00:12:09.180 --> 00:12:12.120
If you pip install -r that, you're going to get 16,


00:12:12.120 --> 00:12:14.680
and then it's going to complain that you have 16 and not 15.


00:12:14.680 --> 00:12:15.520
You know what I mean?


00:12:15.520 --> 00:12:19.280
It's like, it just doesn't even factor in the larger system


00:12:19.280 --> 00:12:20.840
that these two things have to coexist.


00:12:20.840 --> 00:12:22.720
So that's one of the things they're working on.


00:12:22.720 --> 00:12:24.400
So to reduce inconsistency,


00:12:24.400 --> 00:12:27.060
it'll no longer install a combination of packages


00:12:27.060 --> 00:12:29.160
that's mutually inconsistent,


00:12:29.160 --> 00:12:31.320
and it will be no pushover,


00:12:31.320 --> 00:12:32.260
it can be strict.


00:12:32.260 --> 00:12:35.800
If you ask it to install two packages


00:12:35.800 --> 00:12:38.080
with incompatible requirements,


00:12:38.080 --> 00:12:40.040
it will say no, it will not do it.


00:12:40.040 --> 00:12:42.000
- Yeah, and then it just doesn't install anything, I think.


00:12:42.000 --> 00:12:43.160
- Yeah, yeah, it just says,


00:12:43.160 --> 00:12:44.520
no, I can't install it.


00:12:44.520 --> 00:12:47.160
- That might cause some problems, right?


00:12:47.160 --> 00:12:48.000
- Yeah, it might.


00:12:48.000 --> 00:12:52.920
or make people's processes work differently.


00:12:52.920 --> 00:12:55.560
Because, I mean, right now I know


00:12:55.560 --> 00:12:59.280
that there's a bunch of libraries on top of each other,


00:12:59.280 --> 00:13:03.200
and I can sort of just install them over on top.


00:13:03.200 --> 00:13:06.320
I have my libraries, and some of them sort of work,


00:13:06.320 --> 00:13:08.480
and some of them work, it doesn't refuse to install them.


00:13:08.480 --> 00:13:11.880
So this might be a speed bump in the road


00:13:11.880 --> 00:13:14.800
for a lot of people, and maybe in the end


00:13:14.800 --> 00:13:19.360
it works out better, but might cause some consternation in the short term.


00:13:19.360 --> 00:13:24.800
Yeah, that was my first thought exactly. It's like, oh, there's going to be a bunch of stuff that just won't install anymore.


00:13:24.800 --> 00:13:31.400
Maybe a library itself can't install because two of its base libraries dependencies themselves are inconsistent.


00:13:31.400 --> 00:13:32.720
How are they working now then?


00:13:32.720 --> 00:13:34.720
You just get a warning and it just still works.


00:13:34.720 --> 00:13:37.920
It's not that they're necessarily truly inconsistent.


00:13:37.920 --> 00:13:41.600
One says, I require library less than equal to this version.


00:13:41.600 --> 00:13:44.600
Another one says, I require library greater than equal to that version.


00:13:44.600 --> 00:13:50.200
That doesn't necessarily mean the one that requires the lower one wouldn't work with the newer one.


00:13:50.200 --> 00:13:52.200
It's just that's what the requirements state.


00:13:52.200 --> 00:13:53.080
You know what I mean?


00:13:53.080 --> 00:13:58.240
Like for example, Bodo3, which is the Python 3 library if we're talking to AWS,


00:13:58.240 --> 00:14:00.240
and its underlying library,


00:14:00.240 --> 00:14:01.560
Bodo core,


00:14:01.560 --> 00:14:04.960
at one point were having different dependency,


00:14:04.960 --> 00:14:06.960
like inconsistent dependency


00:14:06.960 --> 00:14:08.960
statements or something weird like that.


00:14:08.960 --> 00:14:10.960
That I was running into.


00:14:10.960 --> 00:14:12.960
But it did matter, it still ran.


00:14:12.960 --> 00:14:14.340
"Oh, I better run the unit test.


00:14:14.340 --> 00:14:15.680
"It says these aren't going to work together.


00:14:15.680 --> 00:14:16.840
"Let's see if they, you know,


00:14:16.840 --> 00:14:19.540
"maybe there's some corner of that thing that doesn't work,


00:14:19.540 --> 00:14:21.960
"but I don't use that corner, so I don't care."


00:14:21.960 --> 00:14:25.120
- Yeah, or you have, in the machine learning side,


00:14:25.120 --> 00:14:27.160
you have, this library depends on


00:14:27.160 --> 00:14:29.280
some old version of TensorFlow,


00:14:29.280 --> 00:14:31.560
but you're not using TensorFlow,


00:14:31.560 --> 00:14:33.780
you're using some utility library in it,


00:14:33.780 --> 00:14:36.400
but it also has support for TensorFlow,


00:14:36.400 --> 00:14:37.400
but you're not using it.


00:14:37.400 --> 00:14:40.760
So if you had a different version of TensorFlow on it,


00:14:40.760 --> 00:14:41.840
it wouldn't really affect you


00:14:41.840 --> 00:14:43.840
because you weren't using that portion of it.


00:14:43.840 --> 00:14:45.840
Right, but it sounds like pip will say,


00:14:45.840 --> 00:14:47.840
"No, I can't install these things."


00:14:47.840 --> 00:14:49.840
They make statements about two things that


00:14:49.840 --> 00:14:51.840
they can't coexist. But you're like,


00:14:51.840 --> 00:14:53.840
"I don't really care that they're working."


00:14:53.840 --> 00:14:55.840
So I think this is good. I think it makes


00:14:55.840 --> 00:14:57.840
things more predictable. But you're


00:14:57.840 --> 00:14:59.840
right, Matt. It's definitely going to cause


00:14:59.840 --> 00:15:01.840
some challenges. And maybe


00:15:01.840 --> 00:15:03.840
it'll get people to update things


00:15:03.840 --> 00:15:05.840
like the base library statements


00:15:05.840 --> 00:15:07.840
that they depend upon more


00:15:07.840 --> 00:15:09.840
carefully.


00:15:09.840 --> 00:15:14.840
like to see, if we're talking about pip, is that I'd really like to see Python


00:15:14.840 --> 00:15:18.840
come out with dot releases that


00:15:18.840 --> 00:15:22.840
if there's a new version of pip that all the latest versions of Python


00:15:22.840 --> 00:15:26.840
have the latest version of pip. I'm just really tired of


00:15:26.840 --> 00:15:30.840
installing Python places and immediately having pip out of date.


00:15:30.840 --> 00:15:34.840
I actually have an alias that when I create a virtual environment, then it immediately


00:15:34.840 --> 00:15:38.840
does a pip install - - upgrade pip instead of


00:15:38.840 --> 00:15:40.840
because why doesn't it just do that for me?


00:15:40.840 --> 00:15:41.340
Yeah.


00:15:41.340 --> 00:15:41.840
Anyway.


00:15:41.840 --> 00:15:46.640
Can I just update the top level one so that all my new virtual environments get the newest one?


00:15:46.640 --> 00:15:47.140
Yeah.


00:15:47.140 --> 00:15:47.640
Anyway.


00:15:47.640 --> 00:15:50.840
This is coming. They blogged about it. I'll link to the blog post from the PSF.


00:15:50.840 --> 00:15:55.840
They said there's a couple things you can do to help first and most fundamentally


00:15:55.840 --> 00:15:57.840
help them understand how you're using PIP.


00:15:57.840 --> 00:16:01.840
They have some user experience research going on. There's a link to go do part of that.


00:16:01.840 --> 00:16:05.340
You can check right now if this is going to be a problem for you.


00:16:05.340 --> 00:16:09.340
Go to your project, your virtual environment, activate it and type pip check.


00:16:09.340 --> 00:16:12.340
And it will tell you if you are in this inconsistent state.


00:16:12.340 --> 00:16:15.340
I had one website that was, a couple that weren't.


00:16:15.340 --> 00:16:18.340
I hacked around until I fixed them up and everything was good.


00:16:18.340 --> 00:16:20.340
Make sure you test the new version of pip.


00:16:20.340 --> 00:16:22.340
It will probably be out in May. Help spread the word.


00:16:22.340 --> 00:16:25.340
All three of us are doing that. Ta-da! Awesome.


00:16:25.340 --> 00:16:29.340
And if you develop a tool like Poetry or something that lives on top of this,


00:16:29.340 --> 00:16:34.340
make sure that you test integration with the thing coming out in beta in May.


00:16:34.340 --> 00:16:38.940
All right, really quickly before we move on, let me tell you all about Datadog.


00:16:38.940 --> 00:16:42.340
This episode is brought to them, brought to you by them.


00:16:42.340 --> 00:16:43.640
So let me ask you a question.


00:16:43.640 --> 00:16:46.240
Do you have an app in production that's slower than you'd like?


00:16:46.240 --> 00:16:47.940
Is its performance all over the place?


00:16:47.940 --> 00:16:50.240
Maybe fast, sometimes slow others.


00:16:50.240 --> 00:16:51.440
Here's the important question.


00:16:51.440 --> 00:16:54.740
Do you know why it's slow or inconsistent?


00:16:54.740 --> 00:16:55.940
With Datadog, you will.


00:16:55.940 --> 00:16:59.640
You can troubleshoot your app's performance with Datadog's end-to-end tracing,


00:16:59.640 --> 00:17:04.320
Use the detailed frame graphs to identify bottlenecks and latency in that finicky app of yours.


00:17:04.320 --> 00:17:07.640
Be the hero that got the app back on track at your company.


00:17:07.640 --> 00:17:11.240
Get started with a free trial today at pythonbytes.fm/datadog.


00:17:11.240 --> 00:17:13.760
Use a cool product, help support the show.


00:17:13.760 --> 00:17:17.720
Matt, I think this next topic you got here,


00:17:17.720 --> 00:17:19.960
this pretty much is on everyone's mind right now.


00:17:19.960 --> 00:17:23.200
And maybe you're trying to not think about it, but there's some useful stuff going on here.


00:17:23.200 --> 00:17:28.320
Yeah, just with the whole coronavirus, COVID-19,


00:17:28.480 --> 00:17:32.800
I've been thinking, what can I do as an individual to help?


00:17:32.800 --> 00:17:36.040
And I think a lot of people are trying to flatten the curve


00:17:36.040 --> 00:17:37.520
or limit the growth.


00:17:37.520 --> 00:17:40.280
And I think a lot of people, at least in our community,


00:17:40.280 --> 00:17:41.840
understand the importance of that,


00:17:41.840 --> 00:17:45.200
but maybe not the general populace as well.


00:17:45.200 --> 00:17:48.480
So one of the things that I thought that I could do is just


00:17:48.480 --> 00:17:52.600
spread among my local community through my local social media.


00:17:52.600 --> 00:17:55.000
Like, what is the growth locally here where I'm based?


00:17:55.000 --> 00:17:58.000
I'm based out of Salt Lake in Utah.


00:17:58.000 --> 00:18:02.040
And so I had a problem actually getting the data.


00:18:02.040 --> 00:18:04.440
I mean, there aren't any repositories


00:18:04.440 --> 00:18:06.560
that have local Utah data.


00:18:06.560 --> 00:18:09.360
The local Department of Health is reporting on it,


00:18:09.360 --> 00:18:12.040
but their data, there's not a source of data


00:18:12.040 --> 00:18:13.480
that you can cleanly pull.


00:18:13.480 --> 00:18:17.480
So I've been pulling, making my own data source,


00:18:17.480 --> 00:18:20.960
and then I've been just posting those on Twitter and LinkedIn


00:18:20.960 --> 00:18:23.800
just with my local data to sort of track


00:18:23.800 --> 00:18:25.840
what that growth looks like and sort of put that


00:18:25.840 --> 00:18:31.360
people's minds to sort of, "Hey, think about what's going on locally and see what changes you can make."


00:18:31.360 --> 00:18:36.560
And I did some basic modeling to sort of predict what's going on because I've been reading other


00:18:36.560 --> 00:18:41.200
people's models about, you know, this is an exponential growth rate, blah, blah, blah,


00:18:41.200 --> 00:18:46.480
what that looks like. And so I did some basic models using machine learning. But it's also


00:18:46.480 --> 00:18:52.320
in the Twittersphere and elsewhere, people are saying, "All these data scientists are coming


00:18:52.320 --> 00:18:55.200
and just throwing machine learning at this, and that's not the right thing to do. The right thing


00:18:55.200 --> 00:19:01.200
thing to do is read the literature and see what epidemiologists and others have done.


00:19:01.200 --> 00:19:05.480
And so I just want to point to some things that might be interesting.


00:19:05.480 --> 00:19:10.680
I've got a link to a Kaggle project that shows making some basic machine learning models,


00:19:10.680 --> 00:19:16.480
but it also points to a library that's found in SciPy that probably a lot of people don't


00:19:16.480 --> 00:19:17.480
know about.


00:19:17.480 --> 00:19:19.060
I know about it because I teach about it.


00:19:19.060 --> 00:19:24.960
And that's in SciPy, there's an ODEINT function, which is a solver for what's called ordinary


00:19:24.960 --> 00:19:30.720
differential equations. And so this is probably a math class that you may have taken in college.


00:19:30.720 --> 00:19:35.600
I took one in college and it was purely theoretical and I basically forgot everything


00:19:35.600 --> 00:19:45.360
since then. But there's what's called an SIR model and that stands for you have people who are


00:19:45.360 --> 00:19:50.560
susceptible to being sick, you have people who are infected, and you have people who are recovered.


00:19:50.560 --> 00:19:56.400
And so typically these flattened curves are looking at the infected part, the infected growth of that,


00:19:56.400 --> 00:20:00.560
but there's a relationship between all these three different groups and they're more complex models.


00:20:00.560 --> 00:20:07.680
But if you use ordinary differential equations, that is the tool that epidemiologists and statisticians


00:20:07.680 --> 00:20:14.000
use to plot these and determine what's going on here rather than just, you know, throwing it at


00:20:14.000 --> 00:20:20.000
linear regression or trying to do a machine learning model that way. So I just want to point


00:20:20.000 --> 00:20:25.520
people at this Kaggle project. It's got an example of doing this SIR model. It's also got some


00:20:25.520 --> 00:20:31.200
basic machine learning models as well. But be aware that a lot of these things that we learn


00:20:31.200 --> 00:20:36.880
about, that in theory you think, "Oh, this doesn't make sense." This is actually a case where


00:20:36.880 --> 00:20:42.880
ordinary differential equations are the right or one of the right tools to look at this data and


00:20:42.880 --> 00:20:47.280
understand what's going on there. Yeah, that's a cool project. Yeah, definitely a cool project.


00:20:47.280 --> 00:20:52.080
I'm sure there's a ton of data science going on around all of this.


00:20:52.080 --> 00:20:54.120
There's a lot of data.


00:20:54.120 --> 00:20:57.200
It's coming from different places like live dashboards and stuff.


00:20:57.200 --> 00:20:59.240
And I think this is, this is really cool.


00:20:59.240 --> 00:21:00.640
I didn't know about the SIR model.


00:21:00.640 --> 00:21:01.160
That's cool.


00:21:01.160 --> 00:21:05.040
There are a bunch of other Python libraries as well that epidemiologists


00:21:05.040 --> 00:21:08.720
have created and whatnot that, that implement these SIR models.


00:21:08.720 --> 00:21:10.760
And there's another one, SIER.


00:21:10.760 --> 00:21:15.400
And so check those out if you're interested in sort of digging with the data, but a


00:21:15.400 --> 00:21:18.680
a plea to people to think about what you can do for your local community.


00:21:18.680 --> 00:21:21.000
You know, if you've got skills to help out,


00:21:21.000 --> 00:21:24.400
what can you do locally to help out and help others?


00:21:24.400 --> 00:21:26.000
Yeah, absolutely.


00:21:26.000 --> 00:21:28.680
Also, random side point here,


00:21:28.680 --> 00:21:30.360
looking through this code on Kaggle,


00:21:30.360 --> 00:21:35.400
I never realized that you could unpack a tuple in a nested way.


00:21:35.400 --> 00:21:39.560
Like thing, comma, tuple unpacking thing, right?


00:21:39.560 --> 00:21:42.000
So where you can layer these in deeper and deeper.


00:21:42.000 --> 00:21:43.360
That's pretty awesome, actually.


00:21:43.360 --> 00:21:50.360
Yeah, your data structure is nested, right? Not necessarily. It's going to make your code easy to read, but you can have fun there.


00:21:50.360 --> 00:21:58.660
It can definitely, definitely make it shorter. All right, cool. That's a nice one. Brian, you're getting all philosophical on this with this next one. What's up?


00:21:58.660 --> 00:22:09.260
Okay, so this is totally we're going from serious to definitely not serious. So that I noticed this also. So there's a Reddit thread that's now or


00:22:09.260 --> 00:22:13.180
I don't know if it was Redditor or Stack Overflow,


00:22:13.180 --> 00:22:14.300
but it got taken down.


00:22:14.300 --> 00:22:16.060
But essentially, the question was,


00:22:16.060 --> 00:22:20.700
why does all return true if the iterable is empty?


00:22:20.700 --> 00:22:25.400
There's an all keyword in Python that I guess actually a lot of people don't know about.


00:22:25.400 --> 00:22:26.700
>> Yeah, probably not.


00:22:26.700 --> 00:22:30.660
>> Takes an iterable and it returns true if all of the elements of


00:22:30.660 --> 00:22:35.260
the iterable are true or evaluate to true in a Boolean context.


00:22:35.260 --> 00:22:37.980
It's really helpful for a lot of things.


00:22:37.980 --> 00:22:43.820
The interesting aspect is what should you do if the iterable is empty?


00:22:43.820 --> 00:22:49.820
And because, you know, actually the person asking the question said,


00:22:49.820 --> 00:22:53.820
"Shouldn't it be false? Just like, you know, you can say if list,


00:22:53.820 --> 00:22:55.980
and if it's an empty list, it's false.


00:22:55.980 --> 00:22:58.780
Why would all be true if it's empty?"


00:22:58.780 --> 00:23:03.020
And I enjoyed the conversation and somebody wrote an article called


00:23:03.020 --> 00:23:05.820
"About this, why is all return true?"


00:23:05.820 --> 00:23:12.660
The end lesson is it doesn't matter why because the court team decided it and you just need to know it and work around it.


00:23:12.660 --> 00:23:15.540
Lastly the tree to be true so therefore it is true.


00:23:15.540 --> 00:23:21.480
Yeah and then one of the things i want to point out from this discussion is a the statement all unicorns are blue.


00:23:21.480 --> 00:23:30.860
I just love that you can't tell me it it is definitely true because there are no unicorns so therefore it's true for me to say all the blue yeah.


00:23:30.860 --> 00:23:38.540
And so I like that and I guess I'm glad that my daughter doesn't listen to this to hear me say that there are no unicorns


00:23:38.540 --> 00:23:43.860
Sorry, honey. Don't break her heart. Yeah, you can talk about no Santa or what's going on here like


00:23:43.860 --> 00:23:46.380
The tooth fairy is not real


00:23:46.380 --> 00:23:52.980
But the person writing this article Carl Johnson is actually also a philosopher and a programmer. So he talks about this


00:23:52.980 --> 00:24:00.020
2500 year old debate in philosophy about whether or not all unicorns are blue should be true or false


00:24:00.020 --> 00:24:08.100
false. And also we get talk about predicate logic and Socrates and Aristotle and syllogisms and


00:24:08.100 --> 00:24:14.260
things like that. Actually, we never at the end, I still don't know why the core team chose that


00:24:14.260 --> 00:24:19.540
that is true, but it's a fun thing to look into. That's fun. So looking at it from the outside,


00:24:19.540 --> 00:24:27.220
I envision it working like this. The way all works to be efficient is it says for thing in


00:24:27.220 --> 00:24:32.340
collection, if not thing return false, go all the way and return true.


00:24:32.340 --> 00:24:34.180
And it just never goes into that loop.


00:24:34.180 --> 00:24:34.900
So return true.


00:24:34.900 --> 00:24:35.500
Probably.


00:24:35.500 --> 00:24:35.780
Yeah.


00:24:35.780 --> 00:24:39.980
But I probably got to go and open up the CPython source code to find out.


00:24:39.980 --> 00:24:41.540
Matt, what do you think?


00:24:41.540 --> 00:24:42.500
I don't know.


00:24:42.500 --> 00:24:48.540
I'm looking at the Unicode symbol, the Unicode emoji in my Python


00:24:48.540 --> 00:24:53.900
REPL right now, and that's a hex code point one F nine eight four.


00:24:53.900 --> 00:24:55.020
And it doesn't look blue.


00:24:55.020 --> 00:24:55.860
It looks pink.


00:24:56.020 --> 00:24:58.020
So, someone's got to file a--


00:24:58.020 --> 00:25:01.300
[LAUGHTER]


00:25:01.300 --> 00:25:02.780
We definitely got to put--


00:25:02.780 --> 00:25:05.780
somebody's going to have to put a comment on that blog post.


00:25:05.780 --> 00:25:06.860
Yeah, that's not true.


00:25:06.860 --> 00:25:07.940
All unicorns are pink.


00:25:07.940 --> 00:25:10.340
It's interesting that they did make it true, to your point.


00:25:10.340 --> 00:25:15.100
Like, in a Boolean context, anything empty in Python is false.


00:25:15.100 --> 00:25:15.940
Yeah, yeah.


00:25:15.940 --> 00:25:18.140
Another option would have been to raise an exception,


00:25:18.140 --> 00:25:20.460
say you can't ask for the truthiness of nothing.


00:25:20.460 --> 00:25:22.340
The main reason why I wanted to bring it up,


00:25:22.340 --> 00:25:24.660
and the main reason I enjoy reading this article,


00:25:24.660 --> 00:25:29.300
is now I will never forget that all of nothing is true.


00:25:29.300 --> 00:25:35.300
- I'm also thinking, have I ever used all in an if statement?


00:25:35.300 --> 00:25:38.740
I don't know that I have used all in an if statement.


00:25:38.740 --> 00:25:40.540
- Where do you use it?


00:25:40.540 --> 00:25:42.020
- Yeah, I guess I have.


00:25:42.020 --> 00:25:43.140
- Yeah, I've used it.


00:25:43.140 --> 00:25:44.660
Usually I'll put like a set,


00:25:44.660 --> 00:25:48.740
not a set, some kind of generator expression in there.


00:25:48.740 --> 00:25:49.860
'Cause I don't usually wanna test


00:25:49.860 --> 00:25:51.340
all the things are actually true.


00:25:51.340 --> 00:25:54.300
I wanna test like the dates are greater than today


00:25:54.300 --> 00:25:55.700
for all of them or something, right?


00:25:55.700 --> 00:25:57.640
So put a little comprehension in there


00:25:57.640 --> 00:25:58.780
and then ask all of that.


00:25:58.780 --> 00:26:00.220
But yeah.


00:26:00.220 --> 00:26:01.620
- Yeah, I guess it returns a Boolean


00:26:01.620 --> 00:26:03.620
so you would put it in an if statement.


00:26:03.620 --> 00:26:04.460
(laughing)


00:26:04.460 --> 00:26:05.280
- I guess so.


00:26:05.280 --> 00:26:06.120
I don't use it a ton either,


00:26:06.120 --> 00:26:08.300
but every now and then I'm happy with it.


00:26:08.300 --> 00:26:09.940
- If I put it in an if statement,


00:26:09.940 --> 00:26:13.380
am I going to loop over the contents of all, right?


00:26:13.380 --> 00:26:16.580
And I don't know that I have it in an if statement.


00:26:16.580 --> 00:26:17.420
I loop over--


00:26:17.420 --> 00:26:19.300
- No, no, it would be to avoid a loop, right?


00:26:19.300 --> 00:26:22.020
It would be like one line of loop basically.


00:26:22.020 --> 00:26:23.980
Cool, yeah, I won't forget either now.


00:26:23.980 --> 00:26:26.740
I didn't realize it was so philosophical, but apparently here it is.


00:26:26.740 --> 00:26:29.060
All right, last one.


00:26:29.060 --> 00:26:29.940
This one's really quick.


00:26:29.940 --> 00:26:33.580
This is a project written by Jean-Sebastien Douay.


00:26:33.580 --> 00:26:34.500
Like, are they close?


00:26:34.500 --> 00:26:35.020
Right.


00:26:35.020 --> 00:26:37.220
Called pytest Monitor.


00:26:37.220 --> 00:26:40.180
And the idea of pytest Monitor, Brian, you familiar with this one already?


00:26:40.180 --> 00:26:41.300
I looked it up quickly.


00:26:41.300 --> 00:26:41.580
Yeah.


00:26:41.580 --> 00:26:43.020
But I haven't used it before.


00:26:43.020 --> 00:26:43.180
Yeah.


00:26:43.180 --> 00:26:43.900
But okay, cool.


00:26:43.900 --> 00:26:50.580
Basically you pip install this and then anytime you run a pytest test, it's going


00:26:50.580 --> 00:26:52.740
to automatically collect some data for you.


00:26:52.740 --> 00:26:57.840
it'll analyze memory consumption, timing, CPU usage, stuff like that.


00:26:57.840 --> 00:27:00.880
And it'll put it into a little local SQLite database file,


00:27:00.880 --> 00:27:03.580
and you can look at it over time and whatnot.


00:27:03.580 --> 00:27:05.180
So it's pretty cool, right?


00:27:05.180 --> 00:27:10.700
If you want to say, well, how long does this code take to run on the production machine


00:27:10.700 --> 00:27:13.040
versus on our laptops, right?


00:27:13.040 --> 00:27:15.780
You actually get tracking and whatnot from that.


00:27:15.780 --> 00:27:18.940
So not a huge addition, but it's kind of cool.


00:27:18.940 --> 00:27:20.660
It's built on a couple of libraries.


00:27:20.660 --> 00:27:23.740
PSUtil and MemoryProfiler,


00:27:23.740 --> 00:27:26.420
which let it basically go and ask all these questions


00:27:26.420 --> 00:27:29.220
on a per test basis, which is cool.


00:27:29.220 --> 00:27:31.220
And then obviously it just runs in pytest.


00:27:31.220 --> 00:27:32.060
- That's cool.


00:27:32.060 --> 00:27:34.700
- I could see where you might want to have a report


00:27:34.700 --> 00:27:39.180
where you just want to limit what that's running on.


00:27:39.180 --> 00:27:40.740
I don't know that I would want that necessarily


00:27:40.740 --> 00:27:43.860
on everything, but you might have some hotspots


00:27:43.860 --> 00:27:46.500
or whatever where you want to monitor that


00:27:46.500 --> 00:27:47.940
and report on that.


00:27:47.940 --> 00:27:50.220
Having it on everything seems like--


00:27:50.220 --> 00:27:55.620
I don't know what the performance implications are of all that monitoring.


00:27:55.620 --> 00:28:00.580
I think it'd be cool to see, this is one of the parts where I'd like to actually see the


00:28:00.580 --> 00:28:06.180
reporting of this project, have some reporting that's nicer around it.


00:28:06.180 --> 00:28:09.860
Because that's some really cool information, but I think some reporting would help it.


00:28:09.860 --> 00:28:11.940
Yeah, it's not beautiful, is it?


00:28:11.940 --> 00:28:15.300
It is in the SQLite database, you could grab it and do what you want, but then you've got


00:28:15.300 --> 00:28:16.300
to write that.


00:28:16.300 --> 00:28:18.740
- Like coverage, one of the wonderful things about coverage


00:28:18.740 --> 00:28:20.820
is the reporting part of it.


00:28:20.820 --> 00:28:22.220
- Yeah, absolutely.


00:28:22.220 --> 00:28:24.900
All right, well, if that's something you guys care about,


00:28:24.900 --> 00:28:27.580
go install that and check it out.


00:28:27.580 --> 00:28:29.620
All right, well, that's it for all of our major items.


00:28:29.620 --> 00:28:31.500
Brian, Matt, you guys got anything you want to throw out


00:28:31.500 --> 00:28:33.800
there extra before we get to our joke?


00:28:33.800 --> 00:28:35.320
- Stay safe.


00:28:35.320 --> 00:28:36.160
- Yeah, absolutely.


00:28:36.160 --> 00:28:37.020
- I've got nothing extra.


00:28:37.020 --> 00:28:37.860
How about you, Michael?


00:28:37.860 --> 00:28:39.980
- Well, I took two of my projects that I've been kind of


00:28:39.980 --> 00:28:43.060
fiddling with for either a short time or a long time,


00:28:43.060 --> 00:28:46.140
depending on which one, and put them both up on PyPI


00:28:46.140 --> 00:28:49.680
as things you can now pip install, so that's kind of cool.


00:28:49.680 --> 00:28:51.720
So the switchlang, my little extension


00:28:51.720 --> 00:28:53.440
to add switch to the Python language,


00:28:53.440 --> 00:28:54.720
you can pip install that now.


00:28:54.720 --> 00:28:56.880
I still love that thing, I use it all the time.


00:28:56.880 --> 00:28:59.040
And then my markdown sub-template.


00:28:59.040 --> 00:28:59.860
Oh, what's that, Matt?


00:28:59.860 --> 00:29:01.840
- You use that in production.


00:29:01.840 --> 00:29:03.680
- Oh yeah, all the time.


00:29:03.680 --> 00:29:04.920
- Awesome.


00:29:04.920 --> 00:29:06.840
- Yeah, there's like a couple places


00:29:06.840 --> 00:29:08.680
where it would be like this huge if statement


00:29:08.680 --> 00:29:11.000
or some other weird lookup, and it does cool stuff


00:29:11.000 --> 00:29:13.000
to say like, oh, you already tested for this case,


00:29:13.000 --> 00:29:15.920
or you're like, have the same case in two places,


00:29:15.920 --> 00:29:17.480
and you would miss the second one


00:29:17.480 --> 00:29:19.480
because it'd be caught by the first and so on.


00:29:19.480 --> 00:29:20.320
- Cool.


00:29:20.320 --> 00:29:21.320
- Yep, and then the second one,


00:29:21.320 --> 00:29:22.600
the markdown sub template thing,


00:29:22.600 --> 00:29:23.800
which we talked about before,


00:29:23.800 --> 00:29:26.400
but it was not then pip installable,


00:29:26.400 --> 00:29:27.340
so now it is.


00:29:27.340 --> 00:29:28.180
People can check those out.


00:29:28.180 --> 00:29:29.640
- Do you have tests on these, man?


00:29:29.640 --> 00:29:31.400
- Of course we got tests on those.


00:29:31.400 --> 00:29:33.360
I don't have pytest monitor on,


00:29:33.360 --> 00:29:34.200
but we got tests going.


00:29:34.200 --> 00:29:36.520
- I got tests in there.


00:29:36.520 --> 00:29:37.340
So they do exist.


00:29:37.340 --> 00:29:38.600
The code does exist, it has tests.


00:29:38.600 --> 00:29:41.520
- It does, yes, we can speak of it.


00:29:41.520 --> 00:29:43.480
Are you all ready for a joke?


00:29:43.480 --> 00:29:44.300
- Yes.


00:29:44.300 --> 00:29:49.100
is it's not really that funny. It's more like as opposed to the rest of our jokes.


00:29:49.100 --> 00:29:54.740
Dude, I think I've done that. Well, some of them are like meant to be straight out funny.


00:29:54.740 --> 00:29:59.500
This one's like funny ironic because yeah, I did that too at one point or something like


00:29:59.500 --> 00:30:05.740
that. Right. So this guy on Twitter sent a message, sarcastic pharmacist, sent it over


00:30:05.740 --> 00:30:10.740
and said, I was listening to discussion on talk by the about rebooting a server instead


00:30:10.740 --> 00:30:13.420
that are chasing bugs and thought you should check out


00:30:13.420 --> 00:30:16.660
xkcd.com 1495.


00:30:16.660 --> 00:30:21.900
And there's just a picture and it has like a trade off.


00:30:21.900 --> 00:30:24.700
It says, okay, why is everything broken in my life?


00:30:24.700 --> 00:30:28.940
Here's the deal, like I could spend one to 10 hours


00:30:28.940 --> 00:30:32.020
figuring out why my server keeps running out of swap space


00:30:32.020 --> 00:30:34.260
and crashing, or I could spend five minutes


00:30:34.260 --> 00:30:36.660
plugging it into a light timer that reboots it


00:30:36.660 --> 00:30:37.940
every 24 hours.


00:30:37.940 --> 00:30:40.020
That takes five minutes, let's do that.


00:30:40.020 --> 00:30:42.420
>> Yeah, so true.


00:30:42.420 --> 00:30:43.660
>> Yeah.


00:30:43.660 --> 00:30:46.140
>> That's actually an interesting thing.


00:30:46.140 --> 00:30:51.140
We just ordered a bunch of web programmable power strips.


00:30:51.140 --> 00:30:54.780
Yeah, because one of the things you do when working with


00:30:54.780 --> 00:30:57.700
electronics is sometimes power cycle the things.


00:30:57.700 --> 00:31:00.820
Ain't no way to go and do that when I'm working from home.


00:31:00.820 --> 00:31:04.940
>> How interesting. So you built that into the CI/CD?


00:31:04.940 --> 00:31:08.460
Hey, with the tests, let's do that.


00:31:08.460 --> 00:31:15.740
Most of the time these aren't problematic, but there is the occasional in development instrument where or in development


00:31:15.740 --> 00:31:20.760
operating system portions or something like that where it gets into flaky situations and


00:31:20.760 --> 00:31:25.480
Rebooting is a good is a good thing to do from the start because as a software developer


00:31:25.480 --> 00:31:32.420
I can get things into really wacky states. It doesn't happen a lot, but it happens enough to where it's good to know that


00:31:32.420 --> 00:31:34.540
Yeah that you can buy these webs power switches


00:31:34.540 --> 00:31:40.340
We're getting industrial ones which are kind of expensive because you can stick them in instrument racks.


00:31:40.340 --> 00:31:47.840
But they're just a normal power strip, but they've got a web address and a REST-like API that you can put them in strips.


00:31:47.840 --> 00:31:53.140
And if you want to use them in a CI/CD pipeline, you can call them that way too if you want.


00:31:53.140 --> 00:31:59.340
But normally we just have them as a backup so that we can log in and reboot them if we need to.


00:31:59.340 --> 00:32:01.140
You don't have them connected to Alexa?


00:32:01.140 --> 00:32:04.420
Alexa, reboot my computer.


00:32:04.420 --> 00:32:05.420
Oh, no.


00:32:05.420 --> 00:32:08.060
Yeah, my test won't pass.


00:32:08.060 --> 00:32:10.060
Hell, shall I reboot again?


00:32:10.060 --> 00:32:11.060
Yes, please.


00:32:11.060 --> 00:32:12.060
Awesome.


00:32:12.060 --> 00:32:13.060
All right.


00:32:13.060 --> 00:32:14.060
Well, Brian, thank you as always.


00:32:14.060 --> 00:32:15.060
And Matt, thanks for being here today.


00:32:15.060 --> 00:32:16.060
It was fun to chat with you.


00:32:16.060 --> 00:32:17.060
Yeah, thank you.


00:32:17.060 --> 00:32:18.060
Nice chatting with you.


00:32:18.060 --> 00:32:19.060
Thank you for listening to Python Bytes.


00:32:19.060 --> 00:32:20.060
Follow the show on Twitter via @pythonbytes.


00:32:20.060 --> 00:32:21.060
That's Python Bytes as in B-Y-T-E-S.


00:32:21.060 --> 00:32:22.060
And get the full show notes at pythonbytes.fm.


00:32:22.060 --> 00:32:23.060
If you have a news item you want featured, you can find it on the show notes page.


00:32:23.060 --> 00:32:24.060
And if you want to learn more about Python, you can find it on the show notes page.


00:32:24.060 --> 00:32:30.780
bytes as in b-y-t-e-s. And get the full show notes at pythonbytes.fm. If you have a news item you want


00:32:30.780 --> 00:32:35.660
featured, just visit pythonbytes.fm and send it our way. We're always on the lookout for sharing


00:32:35.660 --> 00:32:40.220
something cool. On behalf of myself and Brian Okken, this is Michael Kennedy. Thank you for


00:32:40.220 --> 00:32:43.020
listening and sharing this podcast with your friends and colleagues.

