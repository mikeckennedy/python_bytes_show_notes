
00:00:00.000 --> 00:00:06.240
Hello and welcome to python bites where we deliver python news and headlines directly to your earbuds. This is episode


00:00:06.240 --> 00:00:09.600
196 recorded august 19th


00:00:09.600 --> 00:00:16.640
2020 and I am brian ochin and i'm michael kennedy and actually we have a sponsor this week data dog. Thank you data dog


00:00:16.640 --> 00:00:20.560
Yeah, no more. Thanks data dog. First off. I want to talk about django a little bit


00:00:20.560 --> 00:00:25.200
I've always heard django super easy and like that's why people choose it because it's really easy to get started


00:00:25.200 --> 00:00:27.600
And it has all these things that make working with django easy


00:00:28.240 --> 00:00:33.200
And so on right? Yeah, I think there's a lot going for it. The community seems pretty awesome.


00:00:33.200 --> 00:00:37.040
There's a lot of tutorials. There's a lot of expertise that they can help you out.


00:00:37.040 --> 00:00:39.860
So there's an interesting article by Dan Verrazzo


00:00:39.860 --> 00:00:44.640
called "Surviving Django if you care about databases". So


00:00:44.640 --> 00:00:51.360
I mean "Surviving Django" right off the start. It's an odd title for an article about Django.


00:00:51.360 --> 00:00:55.200
It's going to be kind of hard to summarize, but basically the take on it is


00:00:55.760 --> 00:01:02.820
a little bit of a he has a different take on how to deal with databases than normally is taught around django


00:01:02.820 --> 00:01:05.540
and it's an interesting perspective, but the


00:01:05.540 --> 00:01:12.820
Gist of it really is that centers around that there's a lot of parts of django that seem to be


00:01:12.820 --> 00:01:17.860
Database agnostic so you could use mysql or postgres or something else


00:01:17.860 --> 00:01:20.740
But he says kind of in reality


00:01:20.740 --> 00:01:24.420
People don't do that. People don't really switch databases that much


00:01:24.980 --> 00:01:30.980
So if you really want to utilize the database and some of the great things about whatever database you pick,


00:01:30.980 --> 00:01:33.720
maybe not being database agnostic is good.


00:01:33.720 --> 00:01:40.220
Also, he talks about how to set up schemas and database migrations


00:01:40.220 --> 00:01:45.220
using the database, not using the built-in Django stuff.


00:01:45.220 --> 00:01:51.620
It seems a little bit more like, "Why would I do that? It seems more technical than I want to do with Django."


00:01:51.620 --> 00:01:58.260
But there is some reasoning around it and then he also shows like how exactly how to do this how to do migrations how to do schemas


00:01:58.260 --> 00:02:00.580
And it really doesn't look that bad


00:02:00.580 --> 00:02:05.940
The interesting take I was curious about what the rest of the django community would would feel about this


00:02:05.940 --> 00:02:10.180
But then after the article there's a there's code comment or there's comments on the article


00:02:10.180 --> 00:02:15.700
There's a really nice civilized discussion between the author and some in paolo


00:02:16.320 --> 00:02:22.960
Melchior, I think and Andrew Godwin definitely I've heard of Andrew before and some others talking about


00:02:22.960 --> 00:02:25.480
basically that take and


00:02:25.480 --> 00:02:27.800
one interesting comment was


00:02:27.800 --> 00:02:30.880
articles like this that point out some of the pitfalls of


00:02:30.880 --> 00:02:34.200
there possibly are pitfalls with Django and


00:02:34.200 --> 00:02:38.840
some well-written articles are a good way to kind of point those out and


00:02:38.840 --> 00:02:44.320
Because there's you know, there's a lot of fans of Django that really aren't going to talk about the bad parts


00:02:44.320 --> 00:02:48.320
And this isn't necessarily the bad part, it's just something to be aware of.


00:02:48.320 --> 00:02:56.320
Another really interesting comment by Andrew was, "I agree that at some point in a project or company's life, when it's big enough,


00:02:56.320 --> 00:03:01.320
SQL migrations are the way to go instead of the Django migrations.


00:03:01.320 --> 00:03:06.320
Migrations in the out-of-box state are mostly there to supplement rapid prototyping.


00:03:06.320 --> 00:03:12.080
typing. Like a lot of Django can be removed or ignored progressively if and when you outgrow


00:03:12.080 --> 00:03:18.640
the single set of design constraints when you chose them. So that kind of take of using


00:03:18.640 --> 00:03:24.400
Django's migrations and all the agnostic stuff might be good early on and then


00:03:24.400 --> 00:03:31.600
maybe slowly going towards using your database more later is an interesting take.


00:03:31.600 --> 00:03:35.440
Yeah, that's cool. A bit of a practicality beats purity on both ends there.


00:03:35.440 --> 00:03:41.920
This article also made me like really appreciate the Django community because this was not a flame war. This was a


00:03:41.920 --> 00:03:46.880
Civilized discussion about a technical topic and what on the internet for real. Yeah


00:03:46.880 --> 00:03:51.200
It's great. Yeah, that's really cool. However, uh


00:03:51.200 --> 00:03:57.200
You know a few comments one i've switched from one database back into another


00:03:57.200 --> 00:04:00.880
Three or four times on major projects as you're like, you know what?


00:04:01.760 --> 00:04:06.240
this is just not doing it or it's outgrown this or whatever. So it happens. But at the same time,


00:04:06.240 --> 00:04:12.240
like that's usually not my SQL to Postgres, it's usually like relational to non relational or


00:04:12.240 --> 00:04:17.040
something massive where it's going to require rewrite anyway. So I do like the idea of saying,


00:04:17.040 --> 00:04:22.320
you have this capability to be completely agnostic, but you're working with the lowest


00:04:22.320 --> 00:04:27.760
common denominator there. And that's usually not the best choice if you're writing an application,


00:04:27.760 --> 00:04:30.960
maybe if you're working with a library, tons of people are going to use it in ways you don't


00:04:30.960 --> 00:04:32.960
anticipate but if it's a


00:04:32.960 --> 00:04:34.240
application


00:04:34.240 --> 00:04:39.440
You know how it's going to be used most often. Yeah. Yeah, also some of those speed and speed improvements


00:04:39.440 --> 00:04:41.120
You can get out of a database


00:04:41.120 --> 00:04:46.160
you really can't do too much of with the agnostic front end you kind of need to


00:04:46.160 --> 00:04:51.680
Know the specifics of that database. So yeah, pretty cool for this next one. I want to talk about


00:04:51.680 --> 00:04:54.160
an interesting


00:04:54.160 --> 00:05:00.400
Pattern that python uses I guess interesting technique. So, you know the id function right? You can say id of a thing


00:05:00.400 --> 00:05:04.540
and it'll give you a number back and it basically tells you what it is like


00:05:04.540 --> 00:05:08.440
where it is in memory. Are you familiar with this? I guess I don't use this. Yes if you


00:05:08.440 --> 00:05:13.360
want to know like if I'm giving two variables are they actually referring to


00:05:13.360 --> 00:05:18.360
the same object or do they just have the same value right like if I had a


00:05:18.360 --> 00:05:22.480
dictionary and I want to know is it the same dictionary or does it just have the


00:05:22.480 --> 00:05:29.720
same keys and the same values for those keys you can say ID of one thing and ID


00:05:29.720 --> 00:05:32.560
the other and in CPython that'll actually give you the memory address but


00:05:32.560 --> 00:05:36.680
in all Python that gives you a unique identifier that is guaranteed to be


00:05:36.680 --> 00:05:40.280
different if they're different objects the same if it's the same object right


00:05:40.280 --> 00:05:44.920
okay okay so one of the things that Python does that's really interesting


00:05:44.920 --> 00:05:49.000
and this is all research I've pulled up from working on my Python for memory


00:05:49.000 --> 00:05:54.400
management course that is probably out by the time that this comes out but you


00:05:54.400 --> 00:05:58.280
don't have to take that to care about this so one of the things that's really


00:05:58.280 --> 00:06:05.000
interesting in Python is everything is a pointer, right? Allocated on the heap, including numbers


00:06:05.000 --> 00:06:10.120
and strings and other small stuff that might be allocated on the stack in like languages like C


00:06:10.120 --> 00:06:18.040
Sharp or C++ or whatever, right? So numbers in Python are way more expensive than they are in


00:06:18.040 --> 00:06:22.760
languages that treat them as value types rather than reference types. So for example, the number


00:06:22.760 --> 00:06:30.320
4 uses 28 bytes of memory in Python, whereas the number 4 could use 1, 2, 4, or 8 in the


00:06:30.320 --> 00:06:33.120
languages that treat them as value types, depending if they're like shorts or longs


00:06:33.120 --> 00:06:34.120
or whatever.


00:06:34.120 --> 00:06:39.720
So there's this cool design pattern called the Flyweight pattern, and I'll just give


00:06:39.720 --> 00:06:41.960
you the quick rundown on that.


00:06:41.960 --> 00:06:44.120
So Flyweight is a software design pattern.


00:06:44.120 --> 00:06:48.440
A Flyweight is an object that minimizes memory usage by sharing as much data as possible


00:06:48.440 --> 00:06:49.440
with similar objects.


00:06:49.440 --> 00:06:50.440
So that's from Wikipedia.


00:06:50.440 --> 00:06:52.360
I'll link over to that.


00:06:52.360 --> 00:06:55.320
In Python, Python does that for numbers.


00:06:55.320 --> 00:07:02.000
So if you compute, like through some mathematical function, if you compute the number 16 and


00:07:02.000 --> 00:07:06.500
then some other way you compute the number 16 and then somewhere else you parse a string


00:07:06.500 --> 00:07:10.720
the number 16, those are all literally the same 16 in memory.


00:07:10.720 --> 00:07:11.720
Okay.


00:07:11.720 --> 00:07:12.720
Okay?


00:07:12.720 --> 00:07:13.920
Because 16 is pretty common.


00:07:13.920 --> 00:07:20.860
But if you computed 423 the three different ways, that would be three copies of 423.


00:07:20.860 --> 00:07:26.380
So Python uses this flyweight pattern for the numbers from negative five to 256.


00:07:26.380 --> 00:07:31.620
And you'll only ever have one of those in the language in the runtime.


00:07:31.620 --> 00:07:37.020
But beyond 256 or below negative five, those are always recreated.


00:07:37.020 --> 00:07:38.020
Isn't that interesting?


00:07:38.020 --> 00:07:39.020
It is very interesting.


00:07:39.020 --> 00:07:40.020
Yeah.


00:07:40.020 --> 00:07:41.580
So yeah, it doesn't matter how they come out.


00:07:41.580 --> 00:07:46.660
Basically, if the runtime is going to generate the number, say, seven, as an integer, it's


00:07:46.660 --> 00:07:49.140
going to use the same seven, which is pretty cool.


00:07:49.140 --> 00:07:51.720
I actually have some example code that people can play with.


00:07:51.720 --> 00:07:54.140
Creates like two lists of a whole bunch of numbers


00:07:54.140 --> 00:07:55.940
separate ways and then says,


00:07:55.940 --> 00:07:58.140
you know, are these the same number or not?


00:07:58.140 --> 00:07:59.540
Which is pretty cool.


00:07:59.540 --> 00:08:00.840
I was just playing with it right now.


00:08:00.840 --> 00:08:03.840
So you can, if you assign x to 1,


00:08:03.840 --> 00:08:06.140
you can do an ID of both x and 1,


00:08:06.140 --> 00:08:07.640
it'll show up as the same number.


00:08:07.640 --> 00:08:10.140
But if you assign x to -10,


00:08:10.140 --> 00:08:13.140
x and -10 are different IDs.


00:08:13.140 --> 00:08:14.140
Isn't that funky?


00:08:14.140 --> 00:08:17.940
Yeah, it's because the numbers in Python are extra expensive.


00:08:17.940 --> 00:08:23.500
So Python takes special care to not recreate these very common numbers.


00:08:23.500 --> 00:08:26.780
And apparently, very common means negative 5 to 256 inclusive.


00:08:26.780 --> 00:08:28.700
[laughter]


00:08:28.700 --> 00:08:30.580
Anyway, I thought that might be interesting to people,


00:08:30.580 --> 00:08:32.780
this flyweight design pattern concept,


00:08:32.780 --> 00:08:34.940
and then applied to the numbers might be interesting.


00:08:34.940 --> 00:08:36.980
And there's a little example code that I included it there.


00:08:36.980 --> 00:08:40.700
So it's not quite an article, but it's like an idea with some code.


00:08:40.700 --> 00:08:42.740
Yeah. So can you, I mean, as a user,


00:08:42.740 --> 00:08:45.220
can I use the flyweight pattern in Python for other stuff?


00:08:45.220 --> 00:08:46.300
You totally should.


00:08:46.300 --> 00:08:46.480
Yeah.


00:08:46.480 --> 00:08:50.440
Like imagine you've got some objects you're creating and.


00:08:50.440 --> 00:08:54.220
Instead of recreating them over and over, they're being used in a lot of places.


00:08:54.220 --> 00:08:59.220
You could totally create some kind of like shared lookup for certain common ones.


00:08:59.220 --> 00:09:02.780
Like maybe you create, you're creating States and the state has a bunch of


00:09:02.780 --> 00:09:07.160
information about it, like US States or countries or something, but then you


00:09:07.160 --> 00:09:08.840
often have to go like, all right, what state is this?


00:09:08.840 --> 00:09:10.120
Give me that information, right?


00:09:10.120 --> 00:09:11.480
You don't need to necessarily recreate that.


00:09:11.480 --> 00:09:14.940
You could just create 50 States, keep them in memory and never allocate them again.


00:09:14.940 --> 00:09:15.420
Okay.


00:09:15.880 --> 00:09:22.640
I guess I'm like caching and memorization are ways to do something similar, but with only one thing at a time.


00:09:22.640 --> 00:09:28.000
Exactly. The big important thing here to make this work correctly is they have to be immutable.


00:09:28.000 --> 00:09:28.860
Right.


00:09:28.860 --> 00:09:44.120
Because if one person gets the state Georgia, it has certain values and another person gets it, oh, it has a new county. Let's add that. And like, wait a minute, that's not, I've now not recreated a different thing or like, you know, so it's got to be immutable, which is why it works for numbers.


00:09:44.120 --> 00:09:46.120
and you could do it for strings and things like that.


00:09:46.120 --> 00:09:47.180
Okay, cool.


00:09:47.180 --> 00:09:47.980
Yeah, pretty cool.


00:09:47.980 --> 00:09:50.240
Something else that's really cool is Datadog.


00:09:50.240 --> 00:09:53.240
So thank you, Datadog, for sponsoring this episode.


00:09:53.240 --> 00:09:54.740
Let me ask you a question.


00:09:54.740 --> 00:09:57.740
Do you have an app in production that's slower than you like?


00:09:57.740 --> 00:10:01.340
It's performance all over the place, sometimes fast, sometimes slow.


00:10:01.340 --> 00:10:03.240
Now here's an important question.


00:10:03.240 --> 00:10:04.720
Do you know why?


00:10:04.720 --> 00:10:06.180
With Datadog, you will.


00:10:06.180 --> 00:10:08.420
You can troubleshoot your app's performance


00:10:08.420 --> 00:10:10.680
with Datadog's end-to-end tracing.


00:10:10.680 --> 00:10:13.640
Use the detailed flame graphs to identify bottlenecks


00:10:13.720 --> 00:10:16.520
and latency in that finicky app of yours.


00:10:16.520 --> 00:10:21.020
Be the hero that got the app back on track with your company.


00:10:21.020 --> 00:10:26.120
Get started today with a free trial at pythonbytes.fm/datadog.


00:10:26.120 --> 00:10:27.220
Awesome. Thanks, Datadog.


00:10:27.220 --> 00:10:28.020
You know what else is awesome?


00:10:28.020 --> 00:10:28.520
What is awesome?


00:10:28.520 --> 00:10:31.720
Pip installing a thing that when I pip install something


00:10:31.720 --> 00:10:33.420
and it happens right away


00:10:33.420 --> 00:10:36.020
and it's not like 30 seconds of compile time


00:10:36.020 --> 00:10:38.220
like say, microWSGI is


00:10:38.220 --> 00:10:40.020
to get the thing installed


00:10:40.020 --> 00:10:44.900
And I don't have to have like MS build or VC vars bat set up right or whatever


00:10:44.900 --> 00:10:49.220
Yeah, so definitely i'm grateful for wheels


00:10:49.220 --> 00:10:55.460
It was still a world that we didn't there was less wheels in it when we started this podcast. I'm pretty sure


00:10:55.460 --> 00:11:00.740
Yep, most of the common packages a lot of them have migrated to distributing wheels


00:11:00.740 --> 00:11:07.060
And package authors have had to care about this a lot. And so I want to talk about this article


00:11:07.060 --> 00:11:12.980
It's on the real python blog from brad solomon called what are python wheels and why should we care?


00:11:12.980 --> 00:11:17.460
One of the things I really love about this is like I said a lot of package authors


00:11:17.460 --> 00:11:20.920
I've already gone through this and understand some of the ramifications


00:11:20.920 --> 00:11:27.300
But as a normal casual user of pip install, we don't really think about it


00:11:27.300 --> 00:11:34.740
But this is the first half of this article talks about kind of what the user's perspective is and it's a kind of a nice look


00:11:35.220 --> 00:11:39.540
when you say PEP install something and it's a cool cuz it has an example.


00:11:39.540 --> 00:11:49.340
I'm glad they listen example and it's a particular version of a micro whiskey because most packages are wheels now but if you install something that is not a wheel.


00:11:49.340 --> 00:11:58.620
It's probably a terrible and i don't know if there's other options other than terrible but anyway the terrible is something that is in target gz so it's a.


00:11:58.800 --> 00:12:03.500
Yeah tard and zipped and that's a whole bunch of unique speak that you don't really have to care about.


00:12:03.500 --> 00:12:08.740
But it downloads this blob of stuff and then unpacks it and then it calls.


00:12:08.740 --> 00:12:16.460
Set up and some other stuff to build the wheel after you download it and then labels it and then it installs it.


00:12:16.460 --> 00:12:23.660
There's a whole bunch of steps in there plus it's calling setup.py so there could be really any code in there and so that's kind of creepy.


00:12:23.780 --> 00:12:28.320
The difference is often with if you actually have a wheel instead of the turbo.


00:12:28.320 --> 00:12:33.340
If install will just pull this down and install it and doesn't call setup.py.


00:12:33.340 --> 00:12:36.140
That's really nice actually because one of the


00:12:36.140 --> 00:12:39.740
things I think a lot of people don't realize until they're like, oh,


00:12:39.740 --> 00:12:41.140
wait, what just happened?


00:12:41.140 --> 00:12:43.840
When you pip install something, you're running


00:12:43.840 --> 00:12:46.640
semi arbitrary code off of the internet.


00:12:46.640 --> 00:12:48.220
That's not ideal.


00:12:48.220 --> 00:12:50.140
With the wheels, you don't have to run


00:12:50.140 --> 00:12:54.540
Because basically that runs the setup.py in the Sdist version, I believe.


00:12:54.540 --> 00:12:59.340
So this is really nice that Wheels can cut out that Python execution bit.


00:12:59.340 --> 00:13:03.040
It cuts that out, plus also, I'm not sure what the technology is here.


00:13:03.040 --> 00:13:08.240
I think it's probably just, it's already pre-compiled and there's operating system specifics.


00:13:08.240 --> 00:13:13.140
But Wheels tend to be smaller than the Tarballs, so they download a lot faster.


00:13:13.140 --> 00:13:15.640
Wheels have a bunch of stuff in the name.


00:13:15.640 --> 00:13:18.840
And it's not just random stuff, it's specific stuff.


00:13:18.840 --> 00:13:25.580
but it talks about what distribution it is. It's got the version number. It's got like maybe a build identifiers


00:13:25.580 --> 00:13:31.340
and which python it's for if it's a python 2 versus python 3 or a specific version


00:13:31.340 --> 00:13:32.940
and then


00:13:32.940 --> 00:13:37.180
The platform is one of the important bits. So if you have compiled code


00:13:37.180 --> 00:13:39.100
then the


00:13:39.100 --> 00:13:43.340
There's kind of a different ci pipeline to try to build all those wheels


00:13:43.340 --> 00:13:46.300
But on the user end we don't have to care about it


00:13:46.380 --> 00:13:51.820
So one of the different things is one of the interesting bits about going moving towards wheels


00:13:51.820 --> 00:13:56.860
Is there's a whole bunch often a whole bunch different whole bunch of packages up there


00:13:56.860 --> 00:14:02.300
And that's something that users will see if they they look at what downloads are available


00:14:02.300 --> 00:14:04.380
There'll be this whole slew of stuff


00:14:04.380 --> 00:14:06.300
And for the most part, you don't have to care about that


00:14:06.300 --> 00:14:09.820
If you do pip install, it'll just pick the right one for your operating system


00:14:09.820 --> 00:14:14.060
however, it's good to be aware of those because if you are


00:14:14.700 --> 00:14:19.180
Creating like a cache of stuff at your if you have your office or something


00:14:19.180 --> 00:14:24.300
You may want to cache more of those depending on what operating systems are being used around


00:14:24.300 --> 00:14:29.180
So that little discussion I think is pretty cool. Absolutely. Anyway, i'm not going to get too much into it


00:14:29.180 --> 00:14:35.820
This is a good article for yeah, I use wheels, but what are they and this is this doesn't get too deep into it


00:14:35.820 --> 00:14:41.900
But it's nice. Yeah. Well wheels are definitely nice and another solid article from real python. So very nice


00:14:41.900 --> 00:14:43.900
You know, what else is good?


00:14:43.900 --> 00:14:46.540
Pandas, I've heard that pandas does a lot of cool stuff.


00:14:46.540 --> 00:14:48.300
Now actually pandas is really, really cool.


00:14:48.300 --> 00:14:50.460
You could do a whole bunch of interesting things with it.


00:14:50.460 --> 00:14:55.100
And Jack McHugh, he's been on fire lately.


00:14:55.100 --> 00:14:57.980
He's created all these different projects that he keeps sending them over and like,


00:14:57.980 --> 00:14:58.780
Oh, this is not what I found.


00:14:58.780 --> 00:15:00.220
I was like, no, this is another one I created.


00:15:00.220 --> 00:15:01.980
And a lot of them are cool.


00:15:01.980 --> 00:15:04.380
One of the things he created was awesome Python bytes.


00:15:04.380 --> 00:15:05.820
So hat tip to Jake on that.


00:15:05.820 --> 00:15:06.180
That's cool.


00:15:06.180 --> 00:15:08.860
Like all the awesome stuff that we happen to have covered periodically.


00:15:08.860 --> 00:15:11.740
But this one is called pandas alive.


00:15:12.020 --> 00:15:15.340
And so, Brian, to give the experience of this one,


00:15:15.340 --> 00:15:17.660
you need to open it up and just scroll through the readme


00:15:17.660 --> 00:15:20.700
on the GitHub page and just look at the animations.


00:15:20.700 --> 00:15:23.700
So you probably have seen these racing histograms


00:15:23.700 --> 00:15:27.320
or racing bar charts that show stuff happening over time.


00:15:27.320 --> 00:15:29.260
Like, here's the popularity of web browsers


00:15:29.260 --> 00:15:31.740
all the way back from 1993.


00:15:31.740 --> 00:15:34.460
What was Mozilla and then Netscape and then IE


00:15:34.460 --> 00:15:35.300
and then, you know, whatever,


00:15:35.300 --> 00:15:38.020
and you see them like growing and moving over time.


00:15:38.020 --> 00:15:41.220
So this is a package that if you have a pandas data frame


00:15:41.220 --> 00:15:48.660
in a really simple format where the columns are basically the different things you want to graph.


00:15:48.660 --> 00:15:53.020
And they're all arranged by a common date and they just have numbers.


00:15:53.020 --> 00:16:02.580
You can turn that into a really cool like bar chart race type of thing or line graph race where it's just this animation of those over time of the dates that you have in there.


00:16:02.580 --> 00:16:03.700
Oh I really like this.


00:16:03.700 --> 00:16:04.460
Isn't this cool?


00:16:04.460 --> 00:16:04.740
Yeah.


00:16:04.740 --> 00:16:07.820
Yeah, and the, I mean, like the race charts and stuff, those are cool.


00:16:07.820 --> 00:16:13.820
But then you can also do the, like the line, the line graphs, the growing, zooming.


00:16:13.820 --> 00:16:17.060
Yeah, you can do like line graphs and you can do other types of things,


00:16:17.060 --> 00:16:19.820
little plot, scatterplot type things.


00:16:19.820 --> 00:16:23.660
You can also do pie charts, but you can even have them together.


00:16:23.660 --> 00:16:25.620
So you can have maps.


00:16:25.620 --> 00:16:29.700
So if you want to have a map evolving over time with like different countries


00:16:29.700 --> 00:16:33.900
or counties fading in and out, you could have like those two graphs


00:16:33.900 --> 00:16:36.260
It's animated side by side at the same time.


00:16:36.260 --> 00:16:38.900
So you could have like the chart of the bars


00:16:38.900 --> 00:16:42.620
as well as the map all animated together in like one graph.


00:16:42.620 --> 00:16:43.540
Seems pretty awesome.


00:16:43.540 --> 00:16:45.340
Well done, Jack.


00:16:45.340 --> 00:16:48.060
It's based on, I believe, matplotlib.


00:16:48.060 --> 00:16:50.700
And basically it'll render a bunch of different


00:16:50.700 --> 00:16:53.860
matplotlib renderings into an animated GIF.


00:16:53.860 --> 00:16:55.460
So all you have to do is just go like


00:16:55.460 --> 00:16:58.280
dataframe.plotanimated, give it a file name,


00:16:58.280 --> 00:16:59.660
and then this happens.


00:16:59.660 --> 00:17:00.500
- Oh, that's cool.


00:17:00.500 --> 00:17:02.060
So then you can just generate this GIF


00:17:02.060 --> 00:17:03.500
and then put it wherever.


00:17:03.500 --> 00:17:04.900
- Exactly, you put it on your website,


00:17:04.900 --> 00:17:05.740
you put it wherever you want,


00:17:05.740 --> 00:17:07.820
you could share it on Twitter, I guess, even.


00:17:07.820 --> 00:17:11.100
Right, but it doesn't require a JavaScript backend


00:17:11.100 --> 00:17:13.740
running something in your Jupyter notebook


00:17:13.740 --> 00:17:15.220
and then all that kind of stuff to wire up.


00:17:15.220 --> 00:17:17.300
Like, nah, it's just an animated GIF that comes out.


00:17:17.300 --> 00:17:18.700
- Neat, this is mesmerizing.


00:17:18.700 --> 00:17:19.860
I could just watch these all day.


00:17:19.860 --> 00:17:21.500
- You could watch it for quite a while.


00:17:21.500 --> 00:17:25.060
So, yeah, anyway, really think that's a cool project


00:17:25.060 --> 00:17:27.740
if you want to visualize data over time,


00:17:27.740 --> 00:17:29.980
which, you know, there's a lot of good reasons to do that.


00:17:29.980 --> 00:17:33.100
- One of the things that it has there is animated maps,


00:17:33.100 --> 00:17:35.560
But maps are something else also.


00:17:35.560 --> 00:17:36.880
There's also a map function,


00:17:36.880 --> 00:17:39.560
which has nothing to do with geographic maps.


00:17:39.560 --> 00:17:41.620
You probably learned Python a long time ago,


00:17:41.620 --> 00:17:44.600
but do you remember being surprised by map at all?


00:17:44.600 --> 00:17:45.900
- Yeah, map and all those things,


00:17:45.900 --> 00:17:46.860
they always confuse me,


00:17:46.860 --> 00:17:48.800
and I've always tried to basically avoid them.


00:17:48.800 --> 00:17:50.200
(laughing)


00:17:50.200 --> 00:17:52.400
And I've successfully mostly done that.


00:17:52.400 --> 00:17:53.560
But I know also-- - Really?


00:17:53.560 --> 00:17:55.320
- Yeah, yeah, I also know how useful they can be.


00:17:55.320 --> 00:17:56.400
So tell us about it.


00:17:56.400 --> 00:17:59.280
- This is an article from Katherine Hancocks,


00:17:59.280 --> 00:18:01.800
how to use the Python map function.


00:18:01.800 --> 00:18:09.480
And I know we sure people have heard of maps and map the map function. It's a extremely useful function a useful thing


00:18:09.480 --> 00:18:14.040
So it's a built-in and what it does if you're not familiar with it


00:18:14.040 --> 00:18:17.960
It takes two or more parameters. The first parameter to map is


00:18:17.960 --> 00:18:20.440
The function that you want to apply


00:18:20.440 --> 00:18:25.800
And then like let's say if you give it as the second argument and iterable like a list or something


00:18:26.280 --> 00:18:31.960
It takes that function that you passed in and applies it to absolutely every element of the iterable that you the other one


00:18:31.960 --> 00:18:34.280
so like if I if I have


00:18:34.280 --> 00:18:40.280
um, and if I have quick like the normal often uses, using a lambda function or something


00:18:40.280 --> 00:18:47.080
To apply some like quick thing like if I want to do x times squared x times squared x times two or x squared


00:18:47.080 --> 00:18:52.680
Or something like that and apply that to every element. you can do that and you can make one list into another


00:18:53.480 --> 00:18:59.080
I think it's good for people to like read about them every once in a while if they're not using them often because


00:18:59.080 --> 00:19:03.880
They do come in handy in places that you all the time for me at least


00:19:03.880 --> 00:19:09.080
So it's not an obvious thing if you're not used to this sort of a function from other languages


00:19:09.080 --> 00:19:14.040
I wasn't coming from c and maybe pearl has something like this, but I never used it


00:19:14.040 --> 00:19:16.760
So that's the normal use of applying it


00:19:16.760 --> 00:19:20.840
One of the the things I like about this tutorial is it goes through a few different things?


00:19:20.840 --> 00:19:24.920
So applying lambdas to a list or an interval,


00:19:24.920 --> 00:19:27.480
and then the function you apply doesn't have to be a lambda.


00:19:27.480 --> 00:19:30.080
It could be your own user-defined function,


00:19:30.080 --> 00:19:32.760
or it could be a built-in function that you map to it.


00:19:32.760 --> 00:19:34.280
I want to warn people,


00:19:34.280 --> 00:19:38.000
the part where she's talking about the user-defined function,


00:19:38.000 --> 00:19:40.640
it's oddly complex for some reason.


00:19:40.640 --> 00:19:43.040
I'm not sure why this was made so complex,


00:19:43.040 --> 00:19:45.920
because a user-defined function just works like anything,


00:19:45.920 --> 00:19:48.640
any other function that's using for map.


00:19:48.640 --> 00:19:53.280
But one of the things that I even got out of it is I had forgotten


00:19:53.280 --> 00:19:57.040
that map applies the function to the iterable


00:19:57.040 --> 00:20:00.640
one element at a time and it doesn't do it ahead of time.


00:20:00.640 --> 00:20:03.440
So like for instance, and I'm like, "Really?"


00:20:03.440 --> 00:20:07.440
And I had to like prove it to myself by putting a print statement or something in a function


00:20:07.440 --> 00:20:10.800
to do it. But what happens is, like, let's say I've got


00:20:10.800 --> 00:20:14.720
iterable hooked up to grab like a huge data chunk out of


00:20:14.720 --> 00:20:20.560
A stream or something I can apply some function to each element as i'm pulling it out


00:20:20.560 --> 00:20:26.560
And using map to do that so I can iterate over map. So map returns a map object which


00:20:26.560 --> 00:20:32.580
Whatever it doesn't matter. It's just every element that you use if you use it as an iteration


00:20:32.580 --> 00:20:37.760
Is the answer after you apply the function like a custom generator type thing?


00:20:37.760 --> 00:20:42.880
yeah, yeah, and then if you want it as something solid you can convert it to a list or


00:20:43.680 --> 00:20:48.080
Or a tuple or something like that if you want to do everything i'm done with generators throw in a list


00:20:48.080 --> 00:20:50.880
There's some honesty here, too


00:20:50.880 --> 00:20:56.960
One of the other thing I often forget about map is that you can map it across if you have a function that takes


00:20:56.960 --> 00:20:58.960
multiple arguments


00:20:58.960 --> 00:21:04.080
You can pass it multiple iterables and it'll take you know element wise each one


00:21:04.080 --> 00:21:07.840
So like the nth element out of each list and and apply


00:21:07.840 --> 00:21:12.560
Pass it to the function and then return the answer to that which is cool


00:21:13.040 --> 00:21:19.680
The other thing a good comment in this because it's a similar problem area is comprehensions kind of do the same thing


00:21:19.680 --> 00:21:28.320
So when would you use map versus comprehension and the advice in this article is comprehensions are very useful for smaller data sets


00:21:28.320 --> 00:21:35.300
But often for large data sets map can be more powerful. So that's reason and sometimes you want to do operations


00:21:35.300 --> 00:21:41.760
That if you had to go over different collections of data would make a really nasty looking comprehension and stuff. So yeah, cool


00:21:41.840 --> 00:21:45.800
You also can do like pandas type of things a little bit like multiplying vectors


00:21:45.800 --> 00:21:46.480
All right


00:21:46.480 --> 00:21:51.360
Like if I've got two lists and I want to have it pieces put together like that power example that's in there


00:21:51.360 --> 00:21:52.120
right


00:21:52.120 --> 00:21:56.520
it'll take the first element of the first one the second elements the first element the second one and then


00:21:56.520 --> 00:21:59.160
Apply the function and generate a new list


00:21:59.160 --> 00:22:07.260
Effectively that has like as if you had sort of done vector multiplication, which is cool or like cross. Yeah cross multiplication


00:22:07.260 --> 00:22:11.380
Yeah, I often use map also when I want to muck with something


00:22:11.380 --> 00:22:17.180
and it seems a little cleaner to me to iterate through something if I know I'm looking for something


00:22:17.180 --> 00:22:20.980
and I'm not going to get the end of the data or I'm using endless data.


00:22:20.980 --> 00:22:26.140
Nice. So we spoke earlier about databases and I've got another one for us.


00:22:26.140 --> 00:22:29.860
This cool thing called Auto Migrate. It's a project called Auto Migrate.


00:22:29.860 --> 00:22:30.380
Okay.


00:22:30.380 --> 00:22:35.860
So what it does is it's kind of like you talked about Django migrations


00:22:35.860 --> 00:22:39.300
and we also have SQLAlchemy migrations with Alembic.


00:22:39.300 --> 00:22:45.940
But some people, either they're not using an ORM at all, in which case, those tools


00:22:45.940 --> 00:22:52.420
are useless, or they want to very carefully write the SQL scripts that control their databases.


00:22:52.420 --> 00:22:57.860
Like some people, there's like a group of DBAs that manage the database, and that's


00:22:57.860 --> 00:22:58.860
that, right?


00:22:58.860 --> 00:23:02.460
We're not going to run just random tooling against the database, we're going to run scripts


00:23:02.460 --> 00:23:04.940
that are very carefully considered.


00:23:04.940 --> 00:23:12.860
So this auto-migrate thing, what it will do is if you have those DDL, data definition


00:23:12.860 --> 00:23:18.780
language scripts that say create table, add column, and so on, all it has to do is have


00:23:18.780 --> 00:23:22.220
the script that will say, here's how we create something from scratch.


00:23:22.220 --> 00:23:25.540
You put that into GitHub, and then you make changes to it.


00:23:25.540 --> 00:23:30.000
Like to add a column, I go and edit the create table thing, and I just type in the new column


00:23:30.000 --> 00:23:31.000
in there.


00:23:31.000 --> 00:23:34.000
what this will do is it'll look at your git history


00:23:34.000 --> 00:23:36.280
and it'll do diffs on the create table statements


00:23:36.280 --> 00:23:39.600
and it will generate the migration scripts from that.


00:23:39.600 --> 00:23:40.640
- Oh, that's really cool.


00:23:40.640 --> 00:23:41.480
- That's neat, right?


00:23:41.480 --> 00:23:43.120
So all you gotta do is like maintain the,


00:23:43.120 --> 00:23:44.360
here's how I create the database


00:23:44.360 --> 00:23:45.180
and it'll actually go,


00:23:45.180 --> 00:23:47.320
well, to go from this version to that version,


00:23:47.320 --> 00:23:48.720
here's the script that would actually do it.


00:23:48.720 --> 00:23:50.200
It'll do all that stuff for you.


00:23:50.200 --> 00:23:51.040
- Nice.


00:23:51.040 --> 00:23:52.480
- Yeah, so if that's your flow,


00:23:52.480 --> 00:23:55.860
if your flow is to work with these DDL files,


00:23:55.860 --> 00:23:58.680
these SQL files, this seems like a great tool.


00:23:58.680 --> 00:24:01.800
Now, they do say, oh, this is way better


00:24:01.800 --> 00:24:03.600
than like an ORM or something,


00:24:03.600 --> 00:24:05.400
because in those, like Alembic,


00:24:05.400 --> 00:24:06.880
what you have to do is you have to go


00:24:06.880 --> 00:24:09.020
and write the migration scripts.


00:24:09.020 --> 00:24:11.780
Here's how you migrate up, here's how you migrate down.


00:24:11.780 --> 00:24:14.400
But they left out a little important thing,


00:24:14.400 --> 00:24:16.280
--auto generate,


00:24:16.280 --> 00:24:18.280
which looks at all of your classes in your database


00:24:18.280 --> 00:24:19.160
and go, here's the difference.


00:24:19.160 --> 00:24:20.800
We automatically wrote that for you,


00:24:20.800 --> 00:24:23.600
which I think is way nicer, even than this project.


00:24:23.600 --> 00:24:25.960
So I think Alembic is better,


00:24:25.960 --> 00:24:27.160
but the big requirement there


00:24:27.160 --> 00:24:29.120
is you are using SQL alchemy.


00:24:29.120 --> 00:24:32.960
If you're not using SQL alchemy to do these migrations,


00:24:32.960 --> 00:24:35.240
then this tool, but you're using these scripts


00:24:35.240 --> 00:24:36.560
instead to define your database,


00:24:36.560 --> 00:24:38.200
like I'm sure a lot of,


00:24:38.200 --> 00:24:40.080
like especially the larger companies


00:24:40.080 --> 00:24:41.720
where there's like a database team


00:24:41.720 --> 00:24:44.120
or like DBAs and so on are doing,


00:24:44.120 --> 00:24:46.400
then this seems like a really cool project for it.


00:24:46.400 --> 00:24:49.680
That said, the Converse is actually pretty cool.


00:24:49.680 --> 00:24:52.760
So what it can do is it can look at a database


00:24:52.760 --> 00:24:55.600
and it will generate your SQL alchemy files for you.


00:24:55.600 --> 00:24:56.440
That's pretty cool.


00:24:56.440 --> 00:24:57.280
- That's nice.


00:24:57.280 --> 00:25:01.560
- Yeah, it'll generate ORM definitions from SQL, right?


00:25:01.560 --> 00:25:04.160
Using the SQLAlchemy generator, which is pretty awesome.


00:25:04.160 --> 00:25:08.380
So you can say, here is my create table scripts,


00:25:08.380 --> 00:25:11.520
generate me the corresponding SQLAlchemy thing


00:25:11.520 --> 00:25:12.360
to match that.


00:25:12.360 --> 00:25:14.920
So in that direction, it's pretty awesome also.


00:25:14.920 --> 00:25:16.000
- So which does that?


00:25:16.000 --> 00:25:17.120
- This one, this auto-migrate.


00:25:17.120 --> 00:25:20.180
It'll look at your DDL, like create these table scripts


00:25:20.180 --> 00:25:23.720
and it'll turn it into Python SQLAlchemy classes.


00:25:23.720 --> 00:25:25.120
But the reverse, it was saying like,


00:25:25.120 --> 00:25:28.120
"Oh, it's painful to use Alembic in the other direction."


00:25:28.120 --> 00:25:30.760
But if you use the auto-generate feature of Alembic,


00:25:30.760 --> 00:25:32.500
then it's also not painful.


00:25:32.500 --> 00:25:36.740
But there's certainly a couple of use cases that are pretty awesome here.


00:25:36.740 --> 00:25:39.100
One, like starting from all the create stuff,


00:25:39.100 --> 00:25:40.540
like given a database,


00:25:40.540 --> 00:25:44.680
just ramp me up to getting a SQLAlchemy set of classes


00:25:44.680 --> 00:25:46.540
that'll talk to it as quick as possible.


00:25:46.540 --> 00:25:47.680
-That's really cool. -Yeah.


00:25:47.680 --> 00:25:49.720
If I've got a schema change,


00:25:49.720 --> 00:25:52.860
is there a version number that's stored in the database somewhere


00:25:52.920 --> 00:25:55.800
to say which version of the schema is being used?


00:25:55.800 --> 00:25:58.640
Yeah, I have no idea about this thing.


00:25:58.640 --> 00:26:00.720
With SQLAlchemy and Alembic,


00:26:00.720 --> 00:26:03.280
there is a version number. It says I'm version


00:26:03.280 --> 00:26:04.440
hash,


00:26:04.440 --> 00:26:06.040
and then all the migrations,


00:26:06.040 --> 00:26:08.520
one of those is the hash and each migration says


00:26:08.520 --> 00:26:11.480
the one that came before me is this and the one that comes after me is that.


00:26:11.480 --> 00:26:15.240
They can look at an existing database and say you're version X.


00:26:15.240 --> 00:26:16.360
Yes, exactly.


00:26:16.360 --> 00:26:18.160
For Alembic, I have no idea about this thing.


00:26:18.160 --> 00:26:20.160
This thing could potentially look at the


00:26:20.160 --> 00:26:22.160
the table


00:26:22.160 --> 00:26:27.600
Basically run it like script this create table stuff for me and then look at that compared to what it has


00:26:27.600 --> 00:26:31.840
Potentially I have no idea if it's that smart though. Okay. Yeah, but it looks like it could be handy for a lot of folks


00:26:31.840 --> 00:26:38.240
Well, I've had a rough week. So I got no extra stuff. No extra stuff. No extra stuff


00:26:38.240 --> 00:26:40.640
I don't have too much either. I have a little bit


00:26:40.640 --> 00:26:45.840
I just want to give a shout out that we have a ton of new courses coming and I want to


00:26:45.840 --> 00:26:51.620
Just encourage people if they're interested in these to go to training.talkbython.fm/getnotified


00:26:51.620 --> 00:26:55.620
and put the email there if they haven't created an account or signed up there before.


00:26:55.620 --> 00:26:59.620
Because we have Excel, moving from Excel to Python with Pandas


00:26:59.620 --> 00:27:03.620
coming out. We have Getting Started with Data Science coming out. We have Python


00:27:03.620 --> 00:27:07.620
Memory Management Tips coming out. Those all three will probably be within


00:27:07.620 --> 00:27:11.620
like a couple of weeks. And then Getting Started with Git and Python Design Patterns


00:27:11.620 --> 00:27:15.620
as well. So there's a bunch of cool stuff if you want to hear about any of those.


00:27:15.620 --> 00:27:19.620
Just be sure to get on the mail list. Oh wow, that's cool. If I didn't talk to you


00:27:19.620 --> 00:27:22.340
every week I would totally get on this mailing list.


00:27:22.340 --> 00:27:23.740
- Awesome.


00:27:23.740 --> 00:27:25.340
- Actually I think I'm already on it.


00:27:25.340 --> 00:27:26.460
- I'm sure you are.


00:27:26.460 --> 00:27:28.580
Because you do talk to me though, you get jokes.


00:27:28.580 --> 00:27:30.980
- Definitely, but everybody listens, gets them also.


00:27:30.980 --> 00:27:31.800
- That's right.


00:27:31.800 --> 00:27:34.440
This is a fun game to play.


00:27:34.440 --> 00:27:37.580
The idea is you take some actual,


00:27:37.580 --> 00:27:41.280
legitimate, classical painting,


00:27:41.280 --> 00:27:44.240
and you, you know, like if you go to an art gallery,


00:27:44.240 --> 00:27:47.820
it'll say like, you know, flowers in bloom,


00:27:47.820 --> 00:27:52.820
oil canvas, Monet 1722, or something like that,


00:27:52.820 --> 00:27:55.620
like in a little placard underneath.


00:27:55.620 --> 00:27:59.200
So the game is to reinterpret these paintings


00:27:59.200 --> 00:28:02.400
in modern tech speak, okay?


00:28:02.400 --> 00:28:03.960
So here, I'll do the first one.


00:28:03.960 --> 00:28:07.920
I put three in the show notes that people can check out.


00:28:07.920 --> 00:28:08.760
I'll describe this to you,


00:28:08.760 --> 00:28:10.080
then I'll read the little thing.


00:28:10.080 --> 00:28:13.520
So there's like a ship that seems to be on fire


00:28:13.520 --> 00:28:16.240
with some extremely strong guys


00:28:16.240 --> 00:28:19.240
trying to drag the ship out of the water.


00:28:19.240 --> 00:28:21.640
Maybe, no, they're pushing it into the water


00:28:21.640 --> 00:28:24.200
and a bunch of folks on the edge sitting off.


00:28:24.200 --> 00:28:25.480
It's like a Viking ship.


00:28:25.480 --> 00:28:27.940
I think they're actually cremating somebody sitting out.


00:28:27.940 --> 00:28:31.320
Anyway, it's this historical picture


00:28:31.320 --> 00:28:33.920
and it says, the placard says,


00:28:33.920 --> 00:28:38.000
engineers remove dead code after dropping a feature flag.


00:28:38.000 --> 00:28:43.000
Sir Frank Bernard Dixie, 1893, oil on canvas.


00:28:43.000 --> 00:28:44.640
(laughing)


00:28:44.640 --> 00:28:45.560
You wanna do the next one?


00:28:45.560 --> 00:28:48.000
- Oh, sure, pull it up.


00:28:48.000 --> 00:28:50.420
Oh, okay, how do I describe this?


00:28:50.420 --> 00:28:54.880
This is like a picture, it's a Picasso picture of--


00:28:54.880 --> 00:28:58.360
- It's like an abstract violin that exploded or something.


00:28:58.360 --> 00:29:00.920
- Yeah, it's hard to tell really what's going on.


00:29:00.920 --> 00:29:03.100
You kind of looks like a violin,


00:29:03.100 --> 00:29:06.620
and the title is CSS without comments, that's good.


00:29:06.620 --> 00:29:10.640
- Pablo Picasso, 1912.


00:29:10.640 --> 00:29:13.200
All right, the last one, the last one we'll do.


00:29:13.200 --> 00:29:14.900
By the way, there's hundreds of these,


00:29:14.900 --> 00:29:16.100
they're all really good.


00:29:16.100 --> 00:29:19.020
So this one is a little disturbing.


00:29:19.020 --> 00:29:21.100
There's a person who looks deathly ill


00:29:21.100 --> 00:29:23.860
with a bunch of gargoyles over them.


00:29:23.860 --> 00:29:28.320
A priest with a crucifix kind of glowing,


00:29:28.320 --> 00:29:31.020
apparently trying to ward off the gargoyles.


00:29:31.020 --> 00:29:32.540
And the placard says,


00:29:32.540 --> 00:29:35.780
"Experienced developer deploys hotfix on production."


00:29:35.780 --> 00:29:39.660
Francisco Goya, oil on canvas, circa 1788.


00:29:39.660 --> 00:29:40.500
- That's good.


00:29:40.500 --> 00:29:41.940
- Yeah, so there's just so many of these,


00:29:41.940 --> 00:29:43.100
you can go through them all day.


00:29:43.100 --> 00:29:44.100
It's really fun.


00:29:44.100 --> 00:29:46.900
- Didn't PyCon do that once at one of the PyCons?


00:29:46.900 --> 00:29:47.940
- I think you might have been with us.


00:29:47.940 --> 00:29:51.420
I know Chris Medina, Kelsey Hightower,


00:29:51.420 --> 00:29:54.300
and I were walking around the Portland Art Museum,


00:29:54.300 --> 00:29:56.060
like basically playing this game.


00:29:56.060 --> 00:29:57.460
We were like coming up with the placards.


00:29:57.460 --> 00:29:58.280
It was fun.


00:29:58.280 --> 00:29:59.120
And were you there for that?


00:29:59.120 --> 00:29:59.960
You might have been.


00:29:59.960 --> 00:30:00.780
- No, I wasn't.


00:30:00.780 --> 00:30:01.620
I missed that one, but.


00:30:01.620 --> 00:30:03.140
- (laughs) That was good.


00:30:03.140 --> 00:30:05.300
Remember that one where you could go to conferences?


00:30:05.300 --> 00:30:08.340
If there were people around you, other people close?


00:30:08.340 --> 00:30:09.180
It was weird.


00:30:09.180 --> 00:30:11.060
- Actually, we don't need anybody to contact us


00:30:11.060 --> 00:30:12.620
and tell us that we have no idea


00:30:12.620 --> 00:30:14.580
when different painters were alive.


00:30:14.580 --> 00:30:18.660
So, but thanks, and cool, good for you if you know it.


00:30:18.660 --> 00:30:20.180
- Awesome, yeah, these are really good.


00:30:20.180 --> 00:30:21.420
If you enjoy this kind of stuff,


00:30:21.420 --> 00:30:23.900
there's hundreds of fun pictures to go through.


00:30:23.900 --> 00:30:26.500
- And I think it's also amusing that we often pick


00:30:26.500 --> 00:30:29.060
visual jokes for an audio format.


00:30:29.060 --> 00:30:30.800
So, sure, why not?


00:30:30.800 --> 00:30:32.660
Do it hard, that's what burgers do.


00:30:32.660 --> 00:30:34.140
- That's right, let's do it with abstract art.


00:30:34.140 --> 00:30:36.700
- Yeah. (laughs)


00:30:36.700 --> 00:30:38.060
Yeah, it's funny.


00:30:38.060 --> 00:30:39.080
Anyway. - Awesome.


00:30:39.080 --> 00:30:39.920
All right, well, thanks, Brian.


00:30:39.920 --> 00:30:40.760
- Thank you. - Yep, bye.


00:30:40.760 --> 00:30:45.000
Thank you for listening to Python Bytes. Follow the show on Twitter @PythonBytes.


00:30:45.000 --> 00:30:51.000
That's Python Bytes as in B-Y-T-E-S. And get the full show notes at PythonBytes.fm.


00:30:51.000 --> 00:30:55.880
If you have a news item you want featured, just visit PythonBytes.fm and send it our way.


00:30:55.880 --> 00:30:59.160
We're always on the lookout for sharing something cool. This is Brian Okken,


00:30:59.160 --> 00:31:01.240
and on behalf of myself and Michael Kennedy,


00:31:01.240 --> 00:31:04.840
thank you for listening and sharing this podcast with your friends and colleagues.

