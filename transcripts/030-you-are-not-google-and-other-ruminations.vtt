
00:00:00.000 --> 00:00:06.000
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:06.000 --> 00:00:11.000
This is episode 30 recorded on June 13, 2017. I'm Michael Kennedy.


00:00:11.000 --> 00:00:12.000
And I'm Brian Okken.


00:00:12.000 --> 00:00:17.000
And we have tons of good stuff to share with you today. I'm very excited about all of our items.


00:00:17.000 --> 00:00:20.000
But first, we have a brand new sponsor. I want to say thank you.


00:00:20.000 --> 00:00:21.000
That's exciting.


00:00:21.000 --> 00:00:26.000
It's super exciting. So I want to welcome Datadog to Python Bytes as a sponsor.


00:00:26.000 --> 00:00:31.880
And Datadog has this cool thing where if you do a little test integration with them,


00:00:31.880 --> 00:00:34.480
you actually get a free shirt. So I'll tell people how to get a free shirt later.


00:00:34.480 --> 00:00:35.360
Wonderful. Cool.


00:00:35.360 --> 00:00:38.520
I heard that not everybody writes software like at the scale of Google.


00:00:38.520 --> 00:00:44.000
Yeah, I think that's probably true, especially of me. But there's a there's a couple articles


00:00:44.000 --> 00:00:51.240
that I want to talk about today. Actually, mostly one. There's an article by I think


00:00:51.240 --> 00:00:57.080
it's a Ozan Oneh, which is a pretty cool name, called "You are not Google" and also


00:00:57.080 --> 00:01:01.240
he goes on to say that you're also not Amazon and you're also not LinkedIn. But


00:01:01.240 --> 00:01:07.740
it's a, it isn't to say that the Google, Amazon, LinkedIn all have applications


00:01:07.740 --> 00:01:12.700
that might look similar to normal folks applications, but the scale is definitely


00:01:12.700 --> 00:01:17.160
different. So just be aware of that. And I guess it's a reaction to people chasing


00:01:17.160 --> 00:01:22.160
a lot of the shiny new technologies like asynchronous IO


00:01:22.160 --> 00:01:24.560
and other things.


00:01:24.560 --> 00:01:26.160
And I'm guilty of that as well.


00:01:26.160 --> 00:01:29.780
But he presents, when looking at solutions,


00:01:29.780 --> 00:01:33.160
he presents a model called UNPAT, I think,


00:01:33.160 --> 00:01:35.260
or maybe it's UNFAT, I'm not sure.


00:01:35.260 --> 00:01:39.180
U-N-P-H-A-T, which is try to understand


00:01:39.180 --> 00:01:41.800
the problem that you're first.


00:01:41.800 --> 00:01:45.080
Enumerate multiple possible candidate solutions.


00:01:45.080 --> 00:01:48.820
read papers or articles about the solution


00:01:48.820 --> 00:01:50.780
that you're gonna try.


00:01:50.780 --> 00:01:52.660
Look at the historical context


00:01:52.660 --> 00:01:55.780
of why the solution came to be in the first place.


00:01:55.780 --> 00:01:58.060
List out the advantages and disadvantages


00:01:58.060 --> 00:02:00.120
and don't forget to think.


00:02:00.120 --> 00:02:03.420
Make sure that that solution really fits your problem.


00:02:03.420 --> 00:02:05.280
And anyway, I think it's a good discussion


00:02:05.280 --> 00:02:08.380
about how a lot of the architectures and stuff


00:02:08.380 --> 00:02:12.300
that people write about and how Google and others do things


00:02:12.300 --> 00:02:13.300
might not apply to you.


00:02:13.300 --> 00:02:15.020
So, just a heads up.


00:02:15.020 --> 00:02:18.760
I think it's a super interesting article and it's really it's a good reminder.


00:02:18.760 --> 00:02:25.640
I mean, on one hand, it's really interesting to think about computation at like a massive,


00:02:25.640 --> 00:02:31.760
massive scale, like some of these data center things and the incredible failover and possibly


00:02:31.760 --> 00:02:38.400
like global redundancy that some of these companies like Google operate at.


00:02:38.400 --> 00:02:41.900
And people read these things are like, oh, we're gonna do our startup and it's gonna


00:02:41.900 --> 00:02:45.900
to have like if we're lucky we'll have 1000 users after like three months.


00:02:45.900 --> 00:02:51.660
Well maybe you don't need to architect around the same things that say Google or LinkedIn


00:02:51.660 --> 00:02:53.520
or Amazon are architecting around.


00:02:53.520 --> 00:02:55.700
Maybe you need to link architect around.


00:02:55.700 --> 00:03:00.100
Let's get this thing working as fast as possible and then we'll deal with the scale later.


00:03:00.100 --> 00:03:03.380
So there's a quote that says and here this pretty nice says the thing is there's like


00:03:03.380 --> 00:03:08.500
five companies in the world that run jobs as big as Google for everybody else.


00:03:08.500 --> 00:03:10.740
between all this IO and fault tolerance


00:03:10.740 --> 00:03:12.060
and things you don't really need.


00:03:12.060 --> 00:03:14.660
It's really just this idea of like,


00:03:14.660 --> 00:03:16.100
it's cool to study these patterns,


00:03:16.100 --> 00:03:19.500
but these patterns were created within a context


00:03:19.500 --> 00:03:20.440
of a problem.


00:03:20.440 --> 00:03:21.580
Do you have that same problem?


00:03:21.580 --> 00:03:22.660
It's like the recurring theme.


00:03:22.660 --> 00:03:23.500
I really like it.


00:03:23.500 --> 00:03:25.820
- Yeah, there's also, even if you are huge,


00:03:25.820 --> 00:03:27.720
even if your problems are big,


00:03:27.720 --> 00:03:29.100
they still might not be the same.


00:03:29.100 --> 00:03:31.220
And one of the things he talks about is


00:03:31.220 --> 00:03:33.200
maybe the, like your data store,


00:03:33.200 --> 00:03:36.380
maybe the number of writes is more important


00:03:36.380 --> 00:03:40.060
than how often it's read or vice versa.


00:03:40.060 --> 00:03:41.620
So even at large scales,


00:03:41.620 --> 00:03:44.420
the problem might be different than somebody else's.


00:03:44.420 --> 00:03:45.700
- Yeah, yeah, for example,


00:03:45.700 --> 00:03:50.480
Amazon optimized for write tolerance


00:03:50.480 --> 00:03:53.280
on the database that backs their shopping cart.


00:03:53.280 --> 00:03:56.320
But is that your primary concern?


00:03:56.320 --> 00:03:57.700
If it is, maybe do what they're doing.


00:03:57.700 --> 00:04:00.460
If it's not, then maybe that's not the best database


00:04:00.460 --> 00:04:02.260
for a general database, right, for example.


00:04:02.260 --> 00:04:04.180
- Yeah, yeah, anyway, it's Goodread.


00:04:04.180 --> 00:04:05.540
- Speaking of databases,


00:04:05.540 --> 00:04:07.580
Oh, let's talk about your microservice one as well


00:04:07.580 --> 00:04:08.460
that ties into this.


00:04:08.460 --> 00:04:10.340
- Oh, just along the same line,


00:04:10.340 --> 00:04:14.620
I ran across another article that just is called


00:04:14.620 --> 00:04:16.260
Enough with Microservices,


00:04:16.260 --> 00:04:18.640
and it's a similar type of article.


00:04:18.640 --> 00:04:19.540
It's also well-written.


00:04:19.540 --> 00:04:22.180
It's by Adam Drake, and we'll have a link up.


00:04:22.180 --> 00:04:25.220
Mostly it's similar sort of discussion


00:04:25.220 --> 00:04:27.500
about microservices and dependencies


00:04:27.500 --> 00:04:32.500
and how that's a complexity that it adds to your cost,


00:04:32.500 --> 00:04:34.980
so make sure that you're aware of that


00:04:34.980 --> 00:04:36.900
before you try to jump into it.


00:04:36.900 --> 00:04:41.220
- Yeah, I recently had Miguel Grinberg on Talk Python.


00:04:41.220 --> 00:04:42.340
I haven't released that episode yet


00:04:42.340 --> 00:04:44.620
because I have like three months of backlog


00:04:44.620 --> 00:04:45.940
of stuff recorded that's gotta get out,


00:04:45.940 --> 00:04:48.420
but it's on its way and it's a really good episode


00:04:48.420 --> 00:04:50.740
around microservices.


00:04:50.740 --> 00:04:52.940
So if you're really thinking about microservices,


00:04:52.940 --> 00:04:54.860
check that out, it's really enlightening.


00:04:54.860 --> 00:04:57.180
Actually, I learned a lot from talking to him.


00:04:57.180 --> 00:04:59.300
But I think one of the takeaways is


00:04:59.300 --> 00:05:01.060
that switching to microservices


00:05:01.060 --> 00:05:04.340
makes your application simpler than it otherwise would be.


00:05:04.340 --> 00:05:08.740
Instead of having one complex application, you know, have like, say, six, very simple


00:05:08.740 --> 00:05:13.060
applications, but your DevOps and deployment and coordination and your infrastructure story


00:05:13.060 --> 00:05:15.460
gets way more complicated.


00:05:15.460 --> 00:05:20.580
And so you're kind of pushing the complexity of your application around and does it make


00:05:20.580 --> 00:05:27.020
sense to push programming complexity into infrastructure DevOps complexity, I think


00:05:27.020 --> 00:05:30.260
it depends on your organization, how many people are on your team, how complex is your


00:05:30.260 --> 00:05:34.600
app, but certainly a lot of small apps probably shouldn't be microservices.


00:05:34.600 --> 00:05:39.040
It's interesting you bring that up with what your organization looks like because there's


00:05:39.040 --> 00:05:44.520
a lot of small startups and small organizations and sometimes just individual people that


00:05:44.520 --> 00:05:48.160
you really pay attention to what you like to spend your time on and what your skills


00:05:48.160 --> 00:05:54.160
are because like when you just said that I was like wow I better be very careful about


00:05:54.160 --> 00:05:57.360
that because DevOps is not my strong suit.


00:05:57.360 --> 00:06:01.880
Exactly, I'd rather have the complexity in my app and carefully factor that thing, rather


00:06:01.880 --> 00:06:04.040
than push it to a bunch of servers that coordinate.


00:06:04.040 --> 00:06:05.040
Right?


00:06:05.040 --> 00:06:06.040
Yeah.


00:06:06.040 --> 00:06:07.040
Yeah.


00:06:07.040 --> 00:06:08.040
Yep.


00:06:08.040 --> 00:06:09.040
Pretty, pretty interesting.


00:06:09.040 --> 00:06:11.200
So speaking of databases and things that are complex and things that scale super high,


00:06:11.200 --> 00:06:14.160
let's actually not talk about a database with this thing called no DB.


00:06:14.160 --> 00:06:15.920
Okay, I haven't heard of this at all.


00:06:15.920 --> 00:06:17.120
So tell me about no DB.


00:06:17.120 --> 00:06:25.560
So no, no DB is a Pythonic object store that uses Amazon s3 as the back end.


00:06:25.560 --> 00:06:32.040
So it as a programming interface, it looks like a simple NoSQL database.


00:06:32.040 --> 00:06:37.240
But what is actually doing instead of running a server or something is it's talking to s3


00:06:37.240 --> 00:06:40.560
and storing your objects there.


00:06:40.560 --> 00:06:44.560
So you can like insert into the database and you configure the year like your connection


00:06:44.560 --> 00:06:50.140
string if you will for the database is here's my s3 account and here's the bucket I want


00:06:50.140 --> 00:06:52.460
to store it into a folder, think folder.


00:06:52.460 --> 00:06:58.520
And then you just like insert, query, update and delete from this database.


00:06:58.520 --> 00:07:01.760
But what actually happens is it stores it over there.


00:07:01.760 --> 00:07:05.660
And I believe the default is actually to pickle the Python object.


00:07:05.660 --> 00:07:10.680
So you even get like type preservation, like you could insert a customer, and then boom,


00:07:10.680 --> 00:07:13.520
outcomes a customer with its like functions and everything.


00:07:13.520 --> 00:07:14.520
Okay.


00:07:14.520 --> 00:07:15.520
Interesting.


00:07:15.520 --> 00:07:16.520
Yeah.


00:07:16.520 --> 00:07:17.520
Interesting, right?


00:07:17.520 --> 00:07:19.280
So this was done by Rich Jones.


00:07:19.280 --> 00:07:25.520
released it in April and it sort of ties in with some of the serverless architecture,


00:07:25.520 --> 00:07:26.520
right?


00:07:26.520 --> 00:07:28.920
Like this is the guy that works on Zappa.


00:07:28.920 --> 00:07:35.320
We talked about Zappa last time, which lets you run web applications on Amazon Lambda,


00:07:35.320 --> 00:07:36.920
which is already pretty interesting.


00:07:36.920 --> 00:07:40.240
So this is like another, it's like you don't have a web server, so maybe you get away with


00:07:40.240 --> 00:07:42.000
not having a database.


00:07:42.000 --> 00:07:46.000
And it can handle a decent amount of load, but it's not like a full on super database.


00:07:46.000 --> 00:07:48.760
It's more like for prototyping and things like that.


00:07:48.760 --> 00:07:53.480
Cool. Yeah. So some of the examples of he said it might be good for us prototyping,


00:07:53.480 --> 00:08:00.600
like I said, but also storing API event responses for like replay. So if you're doing microservices,


00:08:00.600 --> 00:08:04.200
you want to store all the traffic that goes back and forth, you could just do that here


00:08:04.200 --> 00:08:09.620
really easily capturing logs, simple data like here, Phil, add me your email to this


00:08:09.620 --> 00:08:16.600
thing. One of the more interesting things is if you're doing lambda AWS lambda, you


00:08:16.600 --> 00:08:24.080
can have triggers that call the function based on s3 events. This file was changed, this


00:08:24.080 --> 00:08:29.380
bucket had a new thing added. And what that means is you could insert into the database


00:08:29.380 --> 00:08:34.480
and it would call an AWS lambda function as a result of that. So you could like insert


00:08:34.480 --> 00:08:38.160
this thing and the act of storing it also kicks off some action.


00:08:38.160 --> 00:08:39.920
Oh, neat. That's actually pretty cool.


00:08:39.920 --> 00:08:40.920
Yes, it's pretty neat. So


00:08:40.920 --> 00:08:45.080
So plus the article has a nice picture of a fish skeleton.


00:08:45.080 --> 00:08:47.080
I like it.


00:08:47.080 --> 00:08:48.080
Yes.


00:08:48.080 --> 00:08:49.080
Yeah.


00:08:49.080 --> 00:08:50.080
Pictures are important.


00:08:50.080 --> 00:08:52.720
The one that you're talking about next also has a cool picture.


00:08:52.720 --> 00:08:53.720
Cool logo.


00:08:53.720 --> 00:08:54.720
Yeah.


00:08:54.720 --> 00:08:55.720
I've heard of Elizabeth a few times.


00:08:55.720 --> 00:08:56.720
Yeah.


00:08:56.720 --> 00:09:01.560
I do have to admit that the logo did bring me into this a little bit.


00:09:01.560 --> 00:09:07.480
So yeah, we talked about Faker before, which would let you create like test data that looked


00:09:07.480 --> 00:09:08.480
real.


00:09:08.480 --> 00:09:10.120
Like give me an address, give me an email, things like that.


00:09:10.120 --> 00:09:12.120
So this is like a competitor to Faker, huh?


00:09:12.120 --> 00:09:15.240
Yes, and it's-- so if you haven't listened to Faker,


00:09:15.240 --> 00:09:16.960
that was on Epsode 25.


00:09:16.960 --> 00:09:18.880
I looked it up this time.


00:09:18.880 --> 00:09:20.980
It's definitely a competitor to Faker.


00:09:20.980 --> 00:09:24.280
They even have some comparisons.


00:09:24.280 --> 00:09:28.040
And it looks like on their project page,


00:09:28.040 --> 00:09:31.160
one of the main features that they're going for for Elizabeth


00:09:31.160 --> 00:09:32.960
is performance.


00:09:32.960 --> 00:09:34.560
Apparently, it's faster than Faker.


00:09:34.560 --> 00:09:35.760
Yeah, Faker's kind of slow.


00:09:35.760 --> 00:09:37.520
I mean, Faker's really nice, but it is--


00:09:37.520 --> 00:09:39.100
I tried to generate a database that


00:09:39.100 --> 00:09:43.500
had like a couple million entries with Faker and it was a little, it took a while, let's just say.


00:09:43.500 --> 00:09:48.860
Yeah, yeah, I haven't tried anything huge. I wonder, I'm curious to how Elizabeth compares.


00:09:48.860 --> 00:09:55.180
But it definitely is a similar space, but I think it's just another project. Maybe it fits better


00:09:55.180 --> 00:10:02.460
for your project. And there's, the articles were really well written. So there's, we're linking up


00:10:02.460 --> 00:10:09.100
two part medium articles. And there's also a, it looks like the same person wrote a pytest plugin


00:10:09.100 --> 00:10:15.340
so that you can, and the pytest plugin is actually pretty darn cool. It allows you to within a test


00:10:15.340 --> 00:10:21.580
be able to, as a fixture, you can bring in different parts of the fake data. So yeah,


00:10:21.580 --> 00:10:27.420
that's really cool. Yeah, definitely looks nice. I'm, I feel like it's in some ways complimentary


00:10:27.420 --> 00:10:31.660
to Faker. I'm not sure you would use both in the same thing, but you can get kind of get slightly


00:10:31.660 --> 00:10:34.780
different data so depending on what you're after one or the other may be better.


00:10:34.780 --> 00:10:38.640
It's a slightly different model of how to pull the data out so I think it's good for


00:10:38.640 --> 00:10:42.060
people to try both and see which style works best for them.


00:10:42.060 --> 00:10:45.140
It also does different localization as well.


00:10:45.140 --> 00:10:48.660
Yeah, the localization of all these is pretty impressive to me actually.


00:10:48.660 --> 00:10:53.260
Yeah, I wouldn't want to try to do that project myself but I'm glad it's around.


00:10:53.260 --> 00:10:54.740
I'm glad it exists.


00:10:54.740 --> 00:10:55.740
Yes.


00:10:55.740 --> 00:10:57.580
Are you ready to hear about how to get a free t-shirt?


00:10:57.580 --> 00:11:00.140
I really want a free t-shirt actually.


00:11:00.140 --> 00:11:04.820
So yeah, so data dog, those guys came along said, Hey, we'd love to sponsor and support


00:11:04.820 --> 00:11:09.180
the show and get the word out about out about our, our project that we got here.


00:11:09.180 --> 00:11:13.220
So data dog is we've talked about roll bar before, right?


00:11:13.220 --> 00:11:15.940
And roll bar monitors your application for errors.


00:11:15.940 --> 00:11:22.340
Well, data dog kind of does something a little bit similar on a grand scale.


00:11:22.340 --> 00:11:29.740
So data dog will look at your application, and all the layers of infrastructure on it.


00:11:29.740 --> 00:11:33.900
Let's suppose we have, say, a flask app, we could integrate Datadog and it will give us


00:11:33.900 --> 00:11:36.260
metrics about that flask app.


00:11:36.260 --> 00:11:42.220
But it'll also tell you about like the NGINX web server, and your database and the Linux


00:11:42.220 --> 00:11:48.740
machine that is running on and basically the entire stack of your application from the


00:11:48.740 --> 00:11:53.940
servers, the database servers, the web server, all those things and put all that stuff together.


00:11:53.940 --> 00:11:58.380
So you can have a really holistic view of what you're doing.


00:11:58.380 --> 00:12:00.300
And you can even integrate it with all these different things.


00:12:00.300 --> 00:12:03.260
It'll integrate with things like AWS.


00:12:03.260 --> 00:12:05.500
It integrates with Rollbar if you use those guys.


00:12:05.500 --> 00:12:08.940
It integrates with many, many different things that you might already be using.


00:12:08.940 --> 00:12:09.940
So it's super powerful.


00:12:09.940 --> 00:12:13.540
It integrates with Postgres, with MongoDB, and so on.


00:12:13.540 --> 00:12:14.700
So very, very cool.


00:12:14.700 --> 00:12:18.920
Companies like Zendesk and Salesforce and even PagerDuty use it.


00:12:18.920 --> 00:12:25.260
If you haven't heard of Datadog, if you haven't tried it, go to pythonbytes.fm/datadog and


00:12:25.260 --> 00:12:28.460
And they've got this little thing you try it out and you get a free t-shirt.


00:12:28.460 --> 00:12:31.840
So pythonvice.fm/datadog support the show and get a shirt.


00:12:31.840 --> 00:12:33.620
I think this shirt's cute also.


00:12:33.620 --> 00:12:34.900
Yeah, that's nice.


00:12:34.900 --> 00:12:36.020
So thanks Datadog.


00:12:36.020 --> 00:12:39.380
And you know what, let's talk about what's coming in Python.


00:12:39.380 --> 00:12:46.940
I feel like my next two items actually are both sort of future looking Python things.


00:12:46.940 --> 00:12:49.460
So I feel like we just talked about Python 3.6, didn't we?


00:12:49.460 --> 00:12:51.060
We've been talking about it since the beginning.


00:12:51.060 --> 00:12:52.060
Yeah.


00:12:52.060 --> 00:12:54.700
Yeah, it's been out for, I guess it's been out for a while now.


00:12:54.700 --> 00:12:57.820
And so they're starting to talk about what's coming in Python 3.7.


00:12:57.820 --> 00:13:00.340
Okay, I haven't looked at all.


00:13:00.340 --> 00:13:04.140
So I'm kind of wanted to highlight that there's, there's a whole bunch of things that I put


00:13:04.140 --> 00:13:09.380
here that are interesting to that I think are really worth like super interesting.


00:13:09.380 --> 00:13:11.660
And I'll just touch on the other ones.


00:13:11.660 --> 00:13:13.620
The first one is an optimization.


00:13:13.620 --> 00:13:19.700
Okay, so Python works by having a bunch of op codes and then interpreting those op codes


00:13:19.700 --> 00:13:26.100
in this like giant switch method in this file called cval.c.


00:13:26.100 --> 00:13:29.940
And it basically is a loop in a switch method and it looks the opcodes and it figures out


00:13:29.940 --> 00:13:31.020
what to do.


00:13:31.020 --> 00:13:35.920
So they've added two new opcodes, load method and call method.


00:13:35.920 --> 00:13:40.420
And it allows them to skip some instantiation of a few objects.


00:13:40.420 --> 00:13:46.780
And it results in potentially methods in Python 3.7 being 20% faster than Python 3.6.


00:13:46.780 --> 00:13:47.780
Oh, cool.


00:13:47.780 --> 00:13:54.180
So one of the big sort of trade-offs that you make in Python is function calls are relatively


00:13:54.180 --> 00:13:57.940
expensive compared to other operations.


00:13:57.940 --> 00:14:03.260
And we obviously want to write smaller functions and break our code apart for usability and


00:14:03.260 --> 00:14:06.580
readability, but that can make things slow.


00:14:06.580 --> 00:14:10.060
So having faster functions can actually make a really big difference in Python.


00:14:10.060 --> 00:14:11.440
Okay, neat.


00:14:11.440 --> 00:14:16.460
So 3.6 to optimize dictionaries a lot and we might optimize function calls in 3.7.


00:14:16.460 --> 00:14:17.460
>> Yeah, absolutely.


00:14:17.460 --> 00:14:18.460
Absolutely.


00:14:18.460 --> 00:14:22.720
So there's some new modules, like there's a new remainder function in math, the dis


00:14:22.720 --> 00:14:25.480
function, which is a disassembly function.


00:14:25.480 --> 00:14:27.800
If you've ever, if you haven't done this, it's pretty cool.


00:14:27.800 --> 00:14:29.600
You can say import dis.


00:14:29.600 --> 00:14:33.680
I think it's dis.dis, module.disassemble.


00:14:33.680 --> 00:14:37.520
And you give it like a function or a class or something and it'll show you the opcodes,


00:14:37.520 --> 00:14:40.720
kind of like that load method, call method I was talking about.


00:14:40.720 --> 00:14:46.360
Another really interesting thing that's coming in 3.7 is Async Context Manager.


00:14:46.360 --> 00:14:52.160
So a context manager is a thing you can use in a with block, right, like a file handle,


00:14:52.160 --> 00:14:55.000
database transaction, those types of things.


00:14:55.000 --> 00:15:02.360
Well you can have asynchronous context blocks and this async context manager lets you basically


00:15:02.360 --> 00:15:07.560
make the instantiation step in those context managers asynchronous, which is pretty cool.


00:15:07.560 --> 00:15:08.560
Oh, that's cool.


00:15:08.560 --> 00:15:15.440
Yeah, one more that's kind of for the crazy book is now functions can have more than 255


00:15:15.440 --> 00:15:21.960
Apparently that was a limit that was bothering someone and they said, well, let's make it


00:15:21.960 --> 00:15:27.480
possible for functions have more than, you know, like 300 arguments because 250 wasn't


00:15:27.480 --> 00:15:28.480
enough.


00:15:28.480 --> 00:15:29.800
Yeah, I run into that all the time.


00:15:29.800 --> 00:15:30.800
I do too.


00:15:30.800 --> 00:15:33.120
It's really frustrating.


00:15:33.120 --> 00:15:34.120
Why would you need that?


00:15:34.120 --> 00:15:38.640
I have no idea, especially when you got star args and star star Kadobe args.


00:15:38.640 --> 00:15:43.640
So anyway, it's now a thing or it's going to be a thing in 3.7.


00:15:43.640 --> 00:15:44.640
Yeah.


00:15:44.640 --> 00:15:50.160
It looks like you wrote down bytes from hex and byte array from hex.


00:15:50.160 --> 00:15:58.920
Yeah, so those are conversion functions that'll parse hexadecimal strings into bytes.


00:15:58.920 --> 00:16:04.100
And the change is that it used to have an error if there was like white space on the


00:16:04.100 --> 00:16:08.600
beginning or end, which really didn't affect what the thing was, but it wouldn't accept


00:16:08.600 --> 00:16:09.600
them.


00:16:09.600 --> 00:16:12.280
So now they basically strip off all the white space for you.


00:16:12.280 --> 00:16:14.520
And so it's a little more tolerant of inputs.


00:16:14.520 --> 00:16:16.820
- Okay, cool, that'll matter for some people.


00:16:16.820 --> 00:16:20.520
- More tolerance is always good in my opinion.


00:16:20.520 --> 00:16:22.040
- Yeah.


00:16:22.040 --> 00:16:24.900
- I would love it if there was like an army of people


00:16:24.900 --> 00:16:26.520
or things could go test my code


00:16:26.520 --> 00:16:27.600
and find out what errors for me.


00:16:27.600 --> 00:16:30.640
- Yeah, well, I was really glad.


00:16:30.640 --> 00:16:34.060
So there's an article called "Unleash the Test Army."


00:16:34.060 --> 00:16:38.960
It is about a hypothesis and I'm glad this came around


00:16:38.960 --> 00:16:41.800
because since I talk about testing a lot,


00:16:41.800 --> 00:16:44.860
I get questions about hypothesis a lot,


00:16:44.860 --> 00:16:47.160
and I have never used it.


00:16:47.160 --> 00:16:48.040
I know that you've had--


00:16:48.040 --> 00:16:48.880
- Dave McKeever?


00:16:48.880 --> 00:16:51.560
- Yeah, I think you've had him on the show.


00:16:51.560 --> 00:16:52.600
- Yep, I have.


00:16:52.600 --> 00:16:55.000
On DocPython episode 67.


00:16:55.000 --> 00:16:56.120
- Oh, you're ready too.


00:16:56.120 --> 00:16:57.360
Did you look that up?


00:16:57.360 --> 00:16:58.840
- No, I was talking about it last night, actually.


00:16:58.840 --> 00:17:02.920
- It's somebody's experience with working with hypothesis.


00:17:02.920 --> 00:17:04.720
It's a good introductory article


00:17:04.720 --> 00:17:06.120
to kind of tell you what it is.


00:17:06.120 --> 00:17:08.880
So hypothesis is a testing framework


00:17:08.880 --> 00:17:11.100
that will really just come up


00:17:11.100 --> 00:17:13.820
with a lot of different ways to throw,


00:17:13.820 --> 00:17:16.380
you set it up so that it throws different data


00:17:16.380 --> 00:17:20.980
at your code and it's more of a unit test type thing,


00:17:20.980 --> 00:17:21.820
I think.


00:17:21.820 --> 00:17:23.860
You have to define the input and output


00:17:23.860 --> 00:17:26.740
of your functions and whatnot to make it work.


00:17:26.740 --> 00:17:29.580
It's really pretty quick about being abusive


00:17:29.580 --> 00:17:33.060
and getting at where the problem areas might be.


00:17:33.060 --> 00:17:34.620
This is the first article that I've read


00:17:34.620 --> 00:17:36.660
that kind of explained how to get into it quickly


00:17:36.660 --> 00:17:38.340
because it doesn't look,


00:17:38.340 --> 00:17:40.100
hypothesis doesn't look like something


00:17:40.100 --> 00:17:41.940
you can really just pick up right off the bat,


00:17:41.940 --> 00:17:44.720
but this is a short introduction.


00:17:44.720 --> 00:17:46.380
One of the things I like is at the end,


00:17:46.380 --> 00:17:50.060
he talks about his conclusions with working with it.


00:17:50.060 --> 00:17:52.380
And one of the conclusions he came up with


00:17:52.380 --> 00:17:54.280
is that it forced him to pin down


00:17:54.280 --> 00:17:56.540
his function specifications


00:17:56.540 --> 00:17:58.620
and really to consider special cases.


00:17:58.620 --> 00:18:00.600
So really think about the interface


00:18:00.600 --> 00:18:02.300
to the function you're gonna test.


00:18:02.300 --> 00:18:03.580
What are the good parameters?


00:18:03.580 --> 00:18:05.260
What is the expected behavior?


00:18:05.260 --> 00:18:07.340
And what are the bad outputs?


00:18:07.340 --> 00:18:09.080
And what do those look like?


00:18:09.080 --> 00:18:11.440
Making you think about your interfaces is a good thing.


00:18:11.440 --> 00:18:14.960
So if hypothesis helps people think about interfaces, great.


00:18:14.960 --> 00:18:17.720
- Yeah, I think it's really, hypothesis is interesting.


00:18:17.720 --> 00:18:19.520
I haven't had a chance to do a ton with it,


00:18:19.520 --> 00:18:22.280
but basically, instead of choosing examples,


00:18:22.280 --> 00:18:24.240
like, well, let's see what's an edge case


00:18:24.240 --> 00:18:26.720
if the register value is false


00:18:26.720 --> 00:18:29.000
and the email address looks like this


00:18:29.000 --> 00:18:31.080
and the price looks like that.


00:18:31.080 --> 00:18:32.200
That seems like a good example.


00:18:32.200 --> 00:18:35.180
Let's pass that to my test and see what happens, right?


00:18:35.180 --> 00:18:37.920
So instead of doing that, you can go to hypothesis,


00:18:37.920 --> 00:18:42.360
just write a regular test, but then add on to it this decorator that says, okay, that


00:18:42.360 --> 00:18:45.960
thing is like an email address, that thing is a Boolean.


00:18:45.960 --> 00:18:51.000
And these are some numbers here's their range, go after it, and it'll just do a bunch of


00:18:51.000 --> 00:18:55.240
different examples, and record which examples worked and which ones failed and things like


00:18:55.240 --> 00:18:57.660
that and store that in a file.


00:18:57.660 --> 00:18:58.660
And it's pretty cool.


00:18:58.660 --> 00:19:01.760
It can find those edge cases and other things you might forget about.


00:19:01.760 --> 00:19:06.960
And this example of kind of do it in an interactive way, like you're not really sure how you should


00:19:06.960 --> 00:19:10.640
test your, I mean you've written some tests but you're not really sure how, what


00:19:10.640 --> 00:19:15.120
inputs to throw at it, which test cases, and making you think about where the


00:19:15.120 --> 00:19:19.320
edges are and the different corner cases. I think that's a good thing.


00:19:19.320 --> 00:19:22.720
That is a good thing. The edges and corner cases are a super important part


00:19:22.720 --> 00:19:26.280
of unit testing I think. Yeah I'm still trying to figure out where exactly what


00:19:26.280 --> 00:19:31.360
level of the development process and and what level of testing this makes the


00:19:31.360 --> 00:19:36.400
most sense at, but there's definitely algorithmic pieces that in your code


00:19:36.400 --> 00:19:40.560
that might be a little confusing. I don't think this would make sense to throw at every unit test


00:19:40.560 --> 00:19:45.120
in your system. But there's definitely places where this would make sense. Yeah, well, it's


00:19:45.120 --> 00:19:50.080
cool. People should check it out. And it's an approachable article for sure. The last thing


00:19:50.080 --> 00:19:55.760
is one of these Python versus legacy Python things and chalk up one more win for Python.


00:19:55.760 --> 00:20:02.240
So most people have heard of Heroku. Heroku is a platform as a service cloud provider.


00:20:02.240 --> 00:20:04.240
Kenneth writes works there, for example.


00:20:04.240 --> 00:20:10.440
So he's his unofficial title is something to the effect of like Python overlord at Heroku.


00:20:10.440 --> 00:20:13.320
That's like on his business card or something.


00:20:13.320 --> 00:20:20.160
And so anyway, he and the crew there basically make it so you can say here's my app.


00:20:20.160 --> 00:20:22.760
And here's my requirements dot txt.


00:20:22.760 --> 00:20:24.360
Run this, please.


00:20:24.360 --> 00:20:29.440
And until recently, the default has been when you say run this Python app.


00:20:29.440 --> 00:20:31.920
It's like, cool, you mean to seven, right?


00:20:31.920 --> 00:20:36.640
You could run it on Python 3 but you had to like configure it explicitly.


00:20:36.640 --> 00:20:39.240
If you said nothing it ran on Python 2.


00:20:39.240 --> 00:20:46.960
The big news is on what's that June 20th, 2017, Heroku is switching the default to Python


00:20:46.960 --> 00:20:47.960
3.6.1.


00:20:47.960 --> 00:20:48.960
Wow.


00:20:48.960 --> 00:20:50.920
So hooray for Python 3.


00:20:50.920 --> 00:20:54.640
So now if you go to Heroku and you say run this, it's going to be like awesome Python


00:20:54.640 --> 00:20:55.640
3, right?


00:20:55.640 --> 00:20:56.800
That's what you wanted.


00:20:56.800 --> 00:21:02.120
And so this thing and I'm linking to basically links over or displays their blog post and


00:21:02.120 --> 00:21:06.320
their blog post is super short that talks about it just says, basically what I said,


00:21:06.320 --> 00:21:10.800
effective Tuesday, the default runtime is now Python 361.


00:21:10.800 --> 00:21:11.800
Yes.


00:21:11.800 --> 00:21:14.600
If you've already got job running there, it won't switch, right?


00:21:14.600 --> 00:21:15.600
Exactly.


00:21:15.600 --> 00:21:17.440
No, it is only for new projects.


00:21:17.440 --> 00:21:20.280
So in the Reddit thing, there's a few interesting quotes.


00:21:20.280 --> 00:21:23.400
Somebody said lots of new projects start out on Heroku all the time.


00:21:23.400 --> 00:21:26.200
So this is really great news for Python three adoption.


00:21:26.200 --> 00:21:27.840
- Yeah, and someone else said Python 3 is really happening.


00:21:27.840 --> 00:21:28.960
Yay!


00:21:28.960 --> 00:21:30.400
I was actually a little worried


00:21:30.400 --> 00:21:31.640
about the future of Python for a while,


00:21:31.640 --> 00:21:34.040
but I feel like it's all downhill from here.


00:21:34.040 --> 00:21:36.560
- Yeah, apparently people that don't listen to our podcast.


00:21:36.560 --> 00:21:37.400
- That's right.


00:21:37.400 --> 00:21:38.460
Our listeners know better.


00:21:38.460 --> 00:21:40.380
I mean, there's a lot of these examples, right?


00:21:40.380 --> 00:21:42.520
We've got all the new frameworks that are exciting,


00:21:42.520 --> 00:21:47.200
but we also have like Django 2 dropping support for Python 2


00:21:47.200 --> 00:21:49.100
and ironically those numbers match up,


00:21:49.100 --> 00:21:52.280
but the newest version of Django is only gonna be Python,


00:21:52.280 --> 00:21:53.880
is Python 3 only and things like that.


00:21:53.880 --> 00:21:56.000
It's really starting to pick up speed.


00:21:56.000 --> 00:21:58.680
- Yeah, one of the, that comment there was interesting


00:21:58.680 --> 00:22:01.160
is that a lot of new projects start on Heroku.


00:22:01.160 --> 00:22:03.700
So must be people starting out a project


00:22:03.700 --> 00:22:07.200
and then later grabbing different server solutions


00:22:07.200 --> 00:22:08.040
or something.


00:22:08.040 --> 00:22:10.000
- I haven't done a lot with Heroku to be honest,


00:22:10.000 --> 00:22:13.600
but I think it's really simple to basically


00:22:13.600 --> 00:22:16.600
just wire up a Git repository, do a push to it,


00:22:16.600 --> 00:22:19.160
and it'll just start running your app magically.


00:22:19.160 --> 00:22:21.120
So it's really, really easy to get started.


00:22:21.120 --> 00:22:22.400
And then maybe as you grow,


00:22:22.400 --> 00:22:24.520
maybe like costs become a concern


00:22:24.520 --> 00:22:26.000
or you just want more control or whatever,


00:22:26.000 --> 00:22:28.160
but it's super easy to get started.


00:22:28.160 --> 00:22:31.720
And however you get started on whichever version of Python


00:22:31.720 --> 00:22:32.880
is probably where you're gonna stay.


00:22:32.880 --> 00:22:34.780
So that's good news.


00:22:34.780 --> 00:22:35.760
- Yeah, great.


00:22:35.760 --> 00:22:36.600
Well, cool.


00:22:36.600 --> 00:22:37.420
- Yeah, very cool.


00:22:37.420 --> 00:22:38.420
And that's it for the news, Brian.


00:22:38.420 --> 00:22:39.580
You got anything else you wanna share?


00:22:39.580 --> 00:22:40.420
- No, no.


00:22:40.420 --> 00:22:43.300
So, wow, number 30 in the can almost.


00:22:43.300 --> 00:22:44.440
So. - 30, yeah.


00:22:44.440 --> 00:22:45.280
That's awesome.


00:22:45.280 --> 00:22:48.040
- I'm finishing up the last chapter this week,


00:22:48.040 --> 00:22:50.600
chapter seven for Python testing.


00:22:50.600 --> 00:22:52.960
So that's gonna be done soon.


00:22:52.960 --> 00:22:54.040
- Yeah, yeah, very, very cool.


00:22:54.040 --> 00:22:59.380
You're one of these days, the book will be a thing that you've done in the past


00:22:59.380 --> 00:23:01.420
instead of a constant job of yours.


00:23:01.420 --> 00:23:01.960
Yeah.


00:23:01.960 --> 00:23:02.380
Yeah.


00:23:02.380 --> 00:23:05.140
And hopefully, I can't wait till it's an actual physical copy.


00:23:05.140 --> 00:23:08.620
So it'll be good to have some, a stack of copies with, with that.


00:23:08.620 --> 00:23:08.860
Yeah.


00:23:08.860 --> 00:23:10.340
That's awesome to hear you're making progress.


00:23:10.340 --> 00:23:12.980
And so thanks for covering snooze with me.


00:23:12.980 --> 00:23:13.660
Uh, how about you?


00:23:13.660 --> 00:23:16.980
Do you have like now four months of a podcast ready?


00:23:16.980 --> 00:23:20.500
I have, I have about three months of podcasts that I've recorded.


00:23:20.500 --> 00:23:23.780
I'm going to go on vacation for a while in the later half of the summer.


00:23:23.780 --> 00:23:28.300
So I'm trying to make sure that everything is going to be smooth, no interruptions.


00:23:28.300 --> 00:23:33.340
And so I have, I think, 13 or 14 episodes of Talk Python already recorded.


00:23:33.340 --> 00:23:34.660
There's tons of interesting stuff.


00:23:34.660 --> 00:23:36.100
I'm really looking forward to sharing.


00:23:36.100 --> 00:23:40.100
I don't want to hold it back, but I got to dull them out week over week or it'll,


00:23:40.100 --> 00:23:41.540
it won't solve the problem.


00:23:41.540 --> 00:23:42.420
How about this?


00:23:42.420 --> 00:23:47.980
And as for this podcast, if we, we haven't really decided yet, but if we do a break,


00:23:47.980 --> 00:23:51.900
we'll definitely let people know before that happens so that they're not just


00:23:51.900 --> 00:23:52.820
hanging out there waiting.


00:23:53.020 --> 00:23:58.500
Yeah, absolutely. We'll try to keep it rolling, but we might miss a week or two with some


00:23:58.500 --> 00:24:03.900
trips there in the summer. All right. Well, thanks for sharing your news with everyone.


00:24:03.900 --> 00:24:09.820
And thank you to Datadog. Get your t-shirt, pythonbytes.fm/datadog. Thanks, Brian. See


00:24:09.820 --> 00:24:10.820
you next week.


00:24:10.820 --> 00:24:13.300
Thank you. Yep. See you.


00:24:13.300 --> 00:24:17.660
Thank you for listening to Python Bytes. Follow the show on Twitter via @pythonbytes. That's


00:24:17.660 --> 00:24:24.540
Python Bytes as in B-Y-T-E-S. And get the full show notes at pythonbytes.fm. If you have a news


00:24:24.540 --> 00:24:29.260
item you want featured, just visit pythonbytes.fm and send it our way. We're always on the lookout


00:24:29.260 --> 00:24:34.620
for sharing something cool. On behalf of myself and Brian Aukin, this is Michael Kennedy. Thank


00:24:34.620 --> 00:24:37.740
you for listening and sharing this podcast with your friends and colleagues.

