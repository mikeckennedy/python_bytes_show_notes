
00:00:00.000 --> 00:00:07.160
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode 299


00:00:07.160 --> 00:00:11.480
Recorded August 31st, and I'm Brian Okken. Hey, I'm Michael Kennedy


00:00:11.480 --> 00:00:17.400
And I'm Will Mubygin. Will's also known as usually the topic of Python Bytes


00:00:17.400 --> 00:00:21.560
Time to time you mentioned me


00:00:21.560 --> 00:00:24.880
so it's awesome to have you here, but you're


00:00:25.520 --> 00:00:27.200
You're part of Textualize, right?


00:00:27.200 --> 00:00:28.920
Or you are Textualize?


00:00:28.920 --> 00:00:31.440
- That's right, I guess I'm part of Textualize.


00:00:31.440 --> 00:00:33.640
And we are a company, a very small company,


00:00:33.640 --> 00:00:35.840
but we're a tech startup.


00:00:35.840 --> 00:00:37.480
We have three employees,


00:00:37.480 --> 00:00:39.920
and we'll have five in a few months.


00:00:39.920 --> 00:00:40.760
- Nice.


00:00:40.760 --> 00:00:41.600
- Yeah, tell us a bit about it.


00:00:41.600 --> 00:00:43.280
You know, people know, that's amazing.


00:00:43.280 --> 00:00:44.320
Tell people about it.


00:00:44.320 --> 00:00:48.200
They know about Rich, and Textual perhaps,


00:00:48.200 --> 00:00:51.240
'cause we talk about all the things that are adopting Rich,


00:00:51.240 --> 00:00:53.440
but you actually have a company around that,


00:00:53.440 --> 00:00:55.400
which is super fantastic, right?


00:00:55.400 --> 00:00:59.620
So the model is we're building textual, which is going to be like a free, an open source


00:00:59.620 --> 00:01:02.460
project distributed through PyPy.


00:01:02.460 --> 00:01:06.300
And then somewhere down the line, we're going to make this web service, which takes those


00:01:06.300 --> 00:01:09.860
applications and then serves them on the web.


00:01:09.860 --> 00:01:14.860
And it'll be like a nice free tier, but we'll be able to add services on top of that, which


00:01:14.860 --> 00:01:18.180
we can charge a subscription for.


00:01:18.180 --> 00:01:19.180
That's fantastic.


00:01:19.180 --> 00:01:20.180
Like Tui's as a service.


00:01:20.180 --> 00:01:21.180
Tui's as a service, yes.


00:01:21.180 --> 00:01:22.180
There you go.


00:01:22.180 --> 00:01:23.180
A TAS.


00:01:23.180 --> 00:01:24.180
A TAS platform.


00:01:24.180 --> 00:01:25.180
All right.


00:01:25.180 --> 00:01:28.500
>> All right. Cool. Well, it's great to see all the progress there.


00:01:28.500 --> 00:01:29.340
>> It is.


00:01:29.340 --> 00:01:30.940
>> Brian, am I up on the first one?


00:01:30.940 --> 00:01:32.100
>> You are.


00:01:32.100 --> 00:01:35.900
>> This one comes to us from John Hagan.


00:01:35.900 --> 00:01:37.740
Thank you, John, for sending this in.


00:01:37.740 --> 00:01:41.940
IPI, the warning is gone,


00:01:41.940 --> 00:01:45.460
but they were under a pretty heavy phishing attack,


00:01:45.460 --> 00:01:49.580
and they wanted everyone to know they had this big banner that was letting,


00:01:49.580 --> 00:01:53.220
anyone who maintains a package is really where the problem lies.


00:01:53.220 --> 00:01:56.220
If you maintained a package like say, Rich,


00:01:56.220 --> 00:01:59.720
the goal of this phishing attempt was to


00:01:59.720 --> 00:02:02.220
get your credentials so that you could then,


00:02:02.220 --> 00:02:04.720
so that they could sign in and put malware


00:02:04.720 --> 00:02:06.220
into that package.


00:02:06.220 --> 00:02:08.220
The more popular, the better, I presume.


00:02:08.220 --> 00:02:11.220
So this was a couple days ago,


00:02:11.220 --> 00:02:13.720
August 24th, so like a week or so.


00:02:13.720 --> 00:02:15.720
It says, "Today we received reports of,"


00:02:15.720 --> 00:02:17.220
this is from PyPI,


00:02:17.220 --> 00:02:18.520
the Python Package Index.


00:02:18.520 --> 00:02:21.220
"Today we received reports of a phishing campaign


00:02:21.220 --> 00:02:26.500
targeting PyPI users. This is the first known phishing attack against PyPI. We're publishing


00:02:26.500 --> 00:02:32.300
the details here to raise awareness of what is likely going to be an ongoing threat. There


00:02:32.300 --> 00:02:39.140
was many comments and quote tweets and so on. It said the background of phishing message


00:02:39.140 --> 00:02:44.800
claims to be there's a mandatory validation process being implemented and they invite


00:02:44.800 --> 00:02:49.900
users to follow a link to validate their package, like a so, otherwise their package will be


00:02:49.900 --> 00:02:56.700
removed. Importantly, they say, note, we will never remove a valid project from


00:02:56.700 --> 00:03:01.300
the index. IPI only removes projects which violate their terms of service or


00:03:01.300 --> 00:03:05.020
in some way determined to be harmful, for example, malware. This takes you over


00:03:05.020 --> 00:03:08.900
to this site if you were to click the link to if you look carefully here,


00:03:08.900 --> 00:03:16.100
sites.google.com/view/ipivalidate/validate-ipi-package for some


00:03:16.100 --> 00:03:19.420
kind of redirect. And it does bad things when you fill this out. It just


00:03:19.420 --> 00:03:21.260
post the forum to somewhere else.


00:03:21.260 --> 00:03:24.180
So I guess they were hosting it on google.com,


00:03:24.180 --> 00:03:27.500
you know, sites.google.com in an attempt to avoid


00:03:27.500 --> 00:03:29.180
like the domain getting blocked,


00:03:29.180 --> 00:03:30.280
something like that, right?


00:03:30.280 --> 00:03:35.280
But it posts over to like linkedopports.com


00:03:35.280 --> 00:03:37.300
or some, I don't even know how you pronounce that domain,


00:03:37.300 --> 00:03:39.300
but don't go there, it's not good.


00:03:39.300 --> 00:03:42.300
And it says the malicious releases follow a pattern,


00:03:42.300 --> 00:03:45.140
exotel, and I kind of laughed,


00:03:45.140 --> 00:03:46.060
even though it's not really funny.


00:03:46.060 --> 00:03:52.260
One of the packages that got phished through this email is called spam.


00:03:52.260 --> 00:04:00.220
I don't know what spam does, but if you were phished by spam and your package is called


00:04:00.220 --> 00:04:04.460
spam, it's just too much meta.


00:04:04.460 --> 00:04:05.460
Will did you hear about this?


00:04:05.460 --> 00:04:07.460
Did you get any notifications for your packages?


00:04:07.460 --> 00:04:12.940
I didn't, but I could see how if I got that early in the morning, I could fall for it.


00:04:12.940 --> 00:04:13.940
Yeah, exactly.


00:04:13.940 --> 00:04:14.940
You're just waking up.


00:04:14.940 --> 00:04:17.060
Not another thing I got to do.


00:04:17.060 --> 00:04:19.020
I feel like they're taking a little bit advantage


00:04:19.020 --> 00:04:22.260
of the notifications coming from


00:04:22.260 --> 00:04:24.160
the Python Packaging Authority,


00:04:24.160 --> 00:04:26.460
where they've been sending out messages


00:04:26.460 --> 00:04:28.660
about security and about packages,


00:04:28.660 --> 00:04:30.220
and there's the critical packages.


00:04:30.220 --> 00:04:32.180
Will, I saw you tweet, and Brian was like,


00:04:32.180 --> 00:04:33.540
"Wait, what is this?"


00:04:33.540 --> 00:04:35.500
About what is a critical package


00:04:35.500 --> 00:04:36.860
the day that stuff came out.


00:04:36.860 --> 00:04:39.820
And so, you know, it kind of, I think,


00:04:39.820 --> 00:04:42.900
is trying to hide under that noise


00:04:42.900 --> 00:04:44.580
and slip through the cracks there a bit.


00:04:44.580 --> 00:04:48.420
I think I don't get very many notifications from PyPy.


00:04:48.420 --> 00:04:51.140
I think the fact that I don't get very many,


00:04:51.140 --> 00:04:53.360
I might just take them at their word.


00:04:53.360 --> 00:04:55.340
If you get a lot of notifications,


00:04:55.340 --> 00:04:58.580
you might learn to recognize what is a legit notification


00:04:58.580 --> 00:05:01.760
and what is some kind of phishing attempt.


00:05:01.760 --> 00:05:04.980
- So you're asking PyPI to send us more email?


00:05:04.980 --> 00:05:05.820
- No, not really.


00:05:05.820 --> 00:05:09.020
(both laughing)


00:05:09.020 --> 00:05:11.600
- Funny, so you can actually look at what the code does


00:05:11.600 --> 00:05:14.060
that is the malicious versions.


00:05:14.060 --> 00:05:16.720
They said they've taken down and they've taken down several hundred


00:05:16.720 --> 00:05:19.220
typo squatting ones that also do a pattern.


00:05:19.220 --> 00:05:21.020
The code is a setup.


00:05:21.020 --> 00:05:26.500
No, it's just hijacking the most used function or feature.


00:05:26.500 --> 00:05:33.780
Try, get the computer name and then request to install the thing.


00:05:33.780 --> 00:05:37.120
If the, off of this malicious place,


00:05:37.120 --> 00:05:39.740
if the platform is Win32,


00:05:39.740 --> 00:05:42.420
we're going to get this script,


00:05:42.420 --> 00:05:45.980
download this malicious exe,


00:05:45.980 --> 00:05:47.580
download it with requests,


00:05:47.580 --> 00:05:51.660
and then write it to a file and then just execute some executable.


00:05:51.660 --> 00:05:56.180
That's pretty much what it was attempting to do to all these packages.


00:05:56.180 --> 00:06:01.180
>> It's kind of lazy this malware is not cross-platform when he works on Windows.


00:06:01.180 --> 00:06:05.740
>> I agree. Well, I mean,


00:06:05.740 --> 00:06:10.860
also they're looking for investors so that they can expand to other platforms.


00:06:10.860 --> 00:06:13.980
maybe they'll get a Mac OS and a Linux one coming at some point.


00:06:13.980 --> 00:06:16.540
>> Just hope that Avizi is listening.


00:06:16.540 --> 00:06:19.500
>> Exactly. Here's an opportunity to,


00:06:19.500 --> 00:06:20.900
I don't know what it does when it runs,


00:06:20.900 --> 00:06:23.340
but it can't be good, whatever it does.


00:06:23.340 --> 00:06:27.860
Can't be good. Now, I remember I got an e-mail from someone,


00:06:27.860 --> 00:06:30.060
and I'm sorry I didn't pull


00:06:30.060 --> 00:06:32.840
the details together as part of the write up here,


00:06:32.840 --> 00:06:34.820
saying, I think it was on Twitter,


00:06:34.820 --> 00:06:36.660
a DM that said,


00:06:36.660 --> 00:06:39.080
"You're probably going to talk about this.


00:06:39.080 --> 00:06:44.920
The 2FA wouldn't necessarily help you because if they asked for the 2FA,


00:06:44.920 --> 00:06:51.680
you're going to enter it in maybe there and it might pass it through as part of the process as well.


00:06:51.680 --> 00:06:56.560
It could maybe get a software-based 2FA and use it.


00:06:56.560 --> 00:06:59.040
But you know what does help with this really,


00:06:59.040 --> 00:07:00.740
really well? Password managers.


00:07:00.740 --> 00:07:03.740
One password, last pass, and so on.


00:07:03.740 --> 00:07:05.900
If you go there and it says, "Enter your password,"


00:07:05.900 --> 00:07:11.900
and you hit the hotkey to like fill out the site or you click in there like with one password,


00:07:11.900 --> 00:07:15.260
if you just access it with the latest version, it'll automatically drop down


00:07:15.260 --> 00:07:20.380
or suggest the drop down for the site. If you do that, it will not come up with anything because


00:07:20.380 --> 00:07:25.340
you don't have an account at sites.google.com, presumably for this login, right?


00:07:25.340 --> 00:07:25.820
>> Yeah.


00:07:25.820 --> 00:07:31.820
>> And so some combination thereof, I think, you know, is at least I always,


00:07:31.820 --> 00:07:35.260
If I go to a site, the less sure I am, I like double check,


00:07:35.260 --> 00:07:39.020
does the password manager think it should fill this account into this website?


00:07:39.020 --> 00:07:41.620
If it says no, then I triple check it.


00:07:41.620 --> 00:07:43.520
It's not just like, oh, the password manager is not working.


00:07:43.520 --> 00:07:45.020
Let me just copy it over, you know.


00:07:45.020 --> 00:07:48.020
Anyway, there's some more details in here.


00:07:48.020 --> 00:07:51.820
You can read about what they're doing and what you should do.


00:07:51.820 --> 00:07:55.460
Some ideas on how to verify the signed certificate.


00:07:55.460 --> 00:07:57.060
I would prefer to just use a one,


00:07:57.060 --> 00:08:00.700
just a password manager right away instead of trying to follow


00:08:00.700 --> 00:08:05.500
the chain of the cert, but you can do that as well. Anyway, it says it's got a lot more


00:08:05.500 --> 00:08:08.500
details there if you want to check that out. What do you all think?


00:08:08.500 --> 00:08:13.860
Yeah, it's interesting. And Sam, it's an ongoing threat. I think if you're an internet user,


00:08:13.860 --> 00:08:20.300
you're getting bombarded with this. With PyPy, if they get a hold of your, it seemed like


00:08:20.300 --> 00:08:26.620
it was more like attacking individuals. Were they trying to get your credentials to like,


00:08:26.620 --> 00:08:28.860
install malware in your package?


00:08:28.860 --> 00:08:33.900
I'm pretty sure what they were doing is they were publishing a new version of your package.


00:08:33.900 --> 00:08:34.900
Ah, okay.


00:08:34.900 --> 00:08:38.460
And the new version had malware in it.


00:08:38.460 --> 00:08:39.460
Yeah.


00:08:39.460 --> 00:08:40.460
So, yeah.


00:08:40.460 --> 00:08:41.460
That would be a huge concern.


00:08:41.460 --> 00:08:42.460
Yeah, yeah.


00:08:42.460 --> 00:08:47.340
It says, yeah, we've additionally determined that some maintainers of legitimate projects


00:08:47.340 --> 00:08:52.100
have been compromised and malware published as their latest release for those projects.


00:08:52.100 --> 00:08:55.260
Their accounts have temporarily been frozen and the bad versions removed.


00:08:55.260 --> 00:08:56.700
But that's what they were trying to do.


00:08:56.700 --> 00:08:57.700
Okay.


00:08:57.700 --> 00:08:59.280
>> Good on them for catching it.


00:08:59.280 --> 00:09:01.860
>> Yeah, for sure. I love how Seth out the audience says,


00:09:01.860 --> 00:09:05.380
another win, WMIN for Linux on the desktop.


00:09:05.380 --> 00:09:06.260
Yeah, how about that?


00:09:06.260 --> 00:09:07.540
>> Yeah, or Mac.


00:09:07.540 --> 00:09:09.740
I'm like, well, that wouldn't hit me at all.


00:09:09.740 --> 00:09:15.300
>> Yeah. However, any package that you publish,


00:09:15.300 --> 00:09:19.180
it would affect your Windows users if you were the maintainer.


00:09:19.180 --> 00:09:21.780
>> Which is half the users as we know,


00:09:21.780 --> 00:09:25.900
about at least half the operating systems are Windows.


00:09:25.900 --> 00:09:28.380
- Yeah, yeah, yeah, not so good.


00:09:28.380 --> 00:09:33.380
So Seth also points out that the timing of this phishing


00:09:33.380 --> 00:09:35.260
combined with Dustin mentioning


00:09:35.260 --> 00:09:37.100
there hadn't been any phishing attacks


00:09:37.100 --> 00:09:39.180
or something like that is,


00:09:39.180 --> 00:09:41.220
what's in Dustin Ingram?


00:09:41.220 --> 00:09:43.340
Don't give people ideas.


00:09:43.340 --> 00:09:45.380
By the way, you wanna hear more about this.


00:09:45.380 --> 00:09:50.380
I did interview Dustin on this like three weeks ago or so


00:09:50.380 --> 00:09:53.500
on Talk Python, talking about Python packages


00:09:53.500 --> 00:09:55.300
and security and supply chain stuff.


00:09:55.300 --> 00:09:58.160
but all that predated the phishing side,


00:09:58.160 --> 00:09:59.560
but not the malware side.


00:09:59.560 --> 00:10:01.200
So people can check that out if they want.


00:10:01.200 --> 00:10:02.040
- Okay.


00:10:02.040 --> 00:10:04.340
- All right, anyway, make sure that you don't put


00:10:04.340 --> 00:10:07.200
your password for PyPI in the wrong place.


00:10:07.200 --> 00:10:08.400
- Yeah.


00:10:08.400 --> 00:10:09.560
All right.


00:10:09.560 --> 00:10:12.340
How about we talk about something nice?


00:10:12.340 --> 00:10:13.460
- Yes, friendly.


00:10:13.460 --> 00:10:15.080
We can have nice things, not--


00:10:15.080 --> 00:10:16.440
- If we can have nice things.


00:10:16.440 --> 00:10:21.440
Like Python being on top of the IEEE spectrum languages.


00:10:21.440 --> 00:10:24.020
So it has been for a while.


00:10:24.020 --> 00:10:29.020
So this is, we're just reviewing this to say, yay us, partly.


00:10:29.020 --> 00:10:31.120
But there's some interesting information here.


00:10:31.120 --> 00:10:33.900
So if we go through the review stuff,


00:10:33.900 --> 00:10:35.220
there's a cool chart.


00:10:35.220 --> 00:10:37.740
So the top programming languages of 2022.


00:10:37.740 --> 00:10:42.740
Python's at the top, it's both the spectrum survey,


00:10:42.740 --> 00:10:45.140
actually, I don't know where the spectrum number comes from.


00:10:45.140 --> 00:10:47.020
I assume it's a survey thing.


00:10:47.020 --> 00:10:51.180
And then trending, it's on top also, a little different,


00:10:51.180 --> 00:10:53.440
and cool animation graphics on there.


00:10:53.440 --> 00:10:56.000
But one of the interesting bits is in jobs.


00:10:56.000 --> 00:10:57.840
If you look at job listings,


00:10:57.840 --> 00:11:00.840
I think they were looking at job listings and requirements.


00:11:00.840 --> 00:11:02.460
SQL is at the top.


00:11:02.460 --> 00:11:07.460
And this is a comment because it's not just SQL.


00:11:07.460 --> 00:11:10.120
They're not gonna just say,


00:11:10.120 --> 00:11:12.280
we need somebody that knows SQL.


00:11:12.280 --> 00:11:15.000
But it's like Python and SQL or Java and SQL


00:11:15.000 --> 00:11:16.880
or JavaScript and SQL.


00:11:16.880 --> 00:11:20.480
The end SQL part is coming in a lot now


00:11:20.480 --> 00:11:22.760
and actually more than it used to,


00:11:22.760 --> 00:11:23.640
which is interesting.


00:11:23.640 --> 00:11:26.600
There's also a related article on the same,


00:11:26.600 --> 00:11:30.760
on IEEE as well called "The Rise of SQL."


00:11:30.760 --> 00:11:33.560
And it's really talking about that,


00:11:33.560 --> 00:11:36.200
that it's not just because,


00:11:36.200 --> 00:11:40.560
I mean, I do remember SQL's always been a part of programming


00:11:40.560 --> 00:11:43.460
or it has been for my career,


00:11:43.460 --> 00:11:46.060
but it's often been a larger thing.


00:11:46.060 --> 00:11:47.980
It's not something you do in a small application,


00:11:47.980 --> 00:11:51.200
it's something in the server or large applications,


00:11:51.200 --> 00:11:55.640
but it's growing in using it for even little small things.


00:11:55.640 --> 00:11:58.320
And a lot of applications,


00:11:58.320 --> 00:12:00.920
you don't have a specialist doing the database stuff.


00:12:00.920 --> 00:12:05.040
You've got the developers doing the database, everything.


00:12:05.040 --> 00:12:07.360
So anyway, I thought that was interesting


00:12:07.360 --> 00:12:11.280
that just the highlighting that SQL is


00:12:11.280 --> 00:12:12.640
and always will be important


00:12:12.640 --> 00:12:14.660
and it's even growing in popularity.


00:12:14.660 --> 00:12:18.400
- It's interesting that Orms haven't made a dent in that.


00:12:18.400 --> 00:12:20.480
You know, I used to use Django Orms back in the day


00:12:20.480 --> 00:12:28.400
didn't have to touch SQL. But clearly people are not using ORMs that much if SQL is like


00:12:28.400 --> 00:12:31.220
top of the charts there.


00:12:31.220 --> 00:12:36.560
My first thought when I looked at this was there's probably a lot of data warehouse,


00:12:36.560 --> 00:12:42.160
data lake, semi-structured data that people are exploring with SQLs and queries before


00:12:42.160 --> 00:12:48.120
they lock it down and productionize it with an ORM or something along those lines, right?


00:12:48.120 --> 00:12:51.660
like the data science side, if a lot of that data


00:12:51.660 --> 00:12:54.120
is dropped into a database by an API


00:12:54.120 --> 00:12:55.380
or some web scraping or something,


00:12:55.380 --> 00:12:57.040
and then you have to ask it questions.


00:12:57.040 --> 00:12:59.040
And like knowing the SQL is the asking


00:12:59.040 --> 00:13:00.520
arbitrary questions of the data


00:13:00.520 --> 00:13:02.560
before you really know what questions to ask


00:13:02.560 --> 00:13:04.800
is my first thought, but yeah,


00:13:04.800 --> 00:13:06.840
ORM's all the way for the win for me.


00:13:06.840 --> 00:13:10.160
I don't want to do straight SQL.


00:13:10.160 --> 00:13:13.380
- There's also a growing thing of just doing a small,


00:13:13.380 --> 00:13:15.720
like a SQLite, just the knowledge


00:13:15.720 --> 00:13:17.500
that SQLite is everywhere.


00:13:17.500 --> 00:13:20.900
And I don't know if SQLite has any effect on this


00:13:20.900 --> 00:13:23.500
or if Simon Willison does,


00:13:23.500 --> 00:13:27.980
because he's with Dataset taking like CSVs and stuff


00:13:27.980 --> 00:13:32.180
and turning them into a little SQLite websites.


00:13:32.180 --> 00:13:34.120
But things like that have just even,


00:13:34.120 --> 00:13:40.060
services and smaller applications collecting data.


00:13:40.060 --> 00:13:44.760
- Isn't there a JavaScript API to SQLite?


00:13:44.760 --> 00:13:49.760
I think all languages have, I think, APIs into SQLite.


00:13:49.760 --> 00:13:52.520
I think something built into the browser is local storage.


00:13:52.520 --> 00:13:55.400
Does that not use SQLite or am I mistaken?


00:13:55.400 --> 00:13:57.340
- Don't think that that does,


00:13:57.340 --> 00:14:00.320
but it's very similar if it's not the same.


00:14:00.320 --> 00:14:03.160
It's like, yeah, what is it called?


00:14:03.160 --> 00:14:05.480
Local SQL or local DB, something like that.


00:14:05.480 --> 00:14:08.400
- I wonder if that's contributing to--


00:14:08.400 --> 00:14:09.840
- Yeah, yeah.


00:14:09.840 --> 00:14:10.680
Dave out in the audience says,


00:14:10.680 --> 00:14:12.760
"I wonder how the jobs one was measured, though.


00:14:12.760 --> 00:14:16.240
SQL can be one of those not really considered must-have items


00:14:16.240 --> 00:14:18.800
that often goes into the list of requirements.


00:14:18.800 --> 00:14:21.920
You really could just use an ORM.


00:14:21.920 --> 00:14:25.440
- Yeah, and that might be the case.


00:14:25.440 --> 00:14:29.200
But even with ORMs, sometimes you gotta get in there


00:14:29.200 --> 00:14:32.920
and find out what's wrong, like do optimizations and things.


00:14:32.920 --> 00:14:34.520
- Yeah, Kim out in the audience says,


00:14:34.520 --> 00:14:36.200
"Is it becoming less common for developers


00:14:36.200 --> 00:14:38.080
"to know at least enough SQL to be dangerous?"


00:14:38.080 --> 00:14:40.800
I think that that's the minimum bar


00:14:40.800 --> 00:14:42.800
for what you should know to use an ORM.


00:14:42.800 --> 00:14:45.120
You should know kind of what's happening.


00:14:45.120 --> 00:14:46.280
You should know what a join is


00:14:46.280 --> 00:14:47.600
and that you might wanna do it


00:14:47.600 --> 00:14:49.560
so it doesn't do 50 queries.


00:14:49.560 --> 00:14:51.560
You do only one and things like that.


00:14:51.560 --> 00:14:52.400
- Yeah.


00:14:52.400 --> 00:14:54.520
- But yeah, very, very cool, Brian.


00:14:54.520 --> 00:14:57.120
- Well, where are we at next?


00:14:57.120 --> 00:14:59.360
- Well, I think Will is up.


00:14:59.360 --> 00:15:01.280
What have you got for our first one, Will?


00:15:01.280 --> 00:15:02.520
- Oh, I'm on the wrong page.


00:15:02.520 --> 00:15:04.020
So I came across this article.


00:15:04.020 --> 00:15:08.000
It's by Charlie Marsh,


00:15:08.000 --> 00:15:10.760
using mypy in production at Spring.


00:15:10.760 --> 00:15:15.360
And I looked at Spring and it's some kind of interface


00:15:15.360 --> 00:15:19.320
for researching medicine.


00:15:19.320 --> 00:15:22.720
But he was saying that they have a big project,


00:15:22.720 --> 00:15:25.640
300,000 lines of Python.


00:15:25.640 --> 00:15:29.120
And they started typing it and that was a few years ago.


00:15:29.120 --> 00:15:32.880
And they've since typed the entire code base.


00:15:32.880 --> 00:15:34.880
And they were very impressed.


00:15:34.880 --> 00:15:38.680
It's reduced bugs and made things more maintainable.


00:15:38.680 --> 00:15:42.920
and even have all the strictness settings on to max.


00:15:42.920 --> 00:15:44.960
I'm a big fan of typing,


00:15:44.960 --> 00:15:48.560
but I don't have everything on max.


00:15:48.560 --> 00:15:50.600
I relax it just a tiny bit,


00:15:50.600 --> 00:15:54.480
but they've got all the settings on there.


00:15:54.480 --> 00:15:57.880
So he covers the basics of typing


00:15:57.880 --> 00:16:01.300
and some interesting stuff about the history of typing.


00:16:01.300 --> 00:16:05.280
It's interesting how typing started.


00:16:05.280 --> 00:16:08.800
it didn't spring out of nowhere with the same goals.


00:16:08.800 --> 00:16:12.240
It did actually evolve through various other projects.


00:16:12.240 --> 00:16:13.960
Originally when mypy started,


00:16:13.960 --> 00:16:15.480
I think they were building something


00:16:15.480 --> 00:16:18.440
that was essentially more like mypy C.


00:16:18.440 --> 00:16:21.600
It was to run Python with typing.


00:16:21.600 --> 00:16:24.000
- To use the typing to actually sort of transpile


00:16:24.000 --> 00:16:25.520
to another language almost, right?


00:16:25.520 --> 00:16:28.880
- Yeah, yeah, and that turned into a type checker


00:16:28.880 --> 00:16:30.160
which didn't actually run your code,


00:16:30.160 --> 00:16:32.360
it just analyzed your code.


00:16:32.360 --> 00:16:34.720
So it's quite an interesting article


00:16:34.720 --> 00:16:41.440
They cover how it started and go through a bunch of their experiences.


00:16:41.440 --> 00:16:47.200
With typing and mypy in general, they cover improved readability.


00:16:47.200 --> 00:16:48.800
That's a big one for me.


00:16:48.800 --> 00:16:50.520
I love typing.


00:16:50.520 --> 00:16:53.200
And I find it makes code more readable.


00:16:53.200 --> 00:16:57.720
Some people would disagree because you add lots of these annotations and some people


00:16:57.720 --> 00:17:00.240
find that clutters your code.


00:17:00.240 --> 00:17:08.160
I find it super helpful to understand other people's code and to understand my code because


00:17:08.160 --> 00:17:12.680
I don't have to remember the types of everything when I can just see them written down.


00:17:12.680 --> 00:17:14.360
- I'm totally with you on that.


00:17:14.360 --> 00:17:20.920
I think there's a fear that, oh, look, Python is becoming like C++ or something.


00:17:20.920 --> 00:17:26.640
But it's nice and clean and it's simple until you're focused on some area, some function


00:17:26.640 --> 00:17:27.640
or a class or something.


00:17:27.640 --> 00:17:29.800
You're like, well, what happens here?


00:17:29.800 --> 00:17:32.000
you can either go read the documentation,


00:17:32.000 --> 00:17:33.340
try to put it together,


00:17:33.340 --> 00:17:35.060
or you can go find all the places


00:17:35.060 --> 00:17:36.400
that's used and try to put it together.


00:17:36.400 --> 00:17:39.640
Or if it has types, you don't have to go do that exploration.


00:17:39.640 --> 00:17:41.120
You're just like, "Okay, this is an integer and


00:17:41.120 --> 00:17:42.900
this is a list of users.


00:17:42.900 --> 00:17:44.040
I know what's happening now.


00:17:44.040 --> 00:17:46.960
I don't need to hold more information in my brain."


00:17:46.960 --> 00:17:48.480
I think that makes it great.


00:17:48.480 --> 00:17:51.480
>> The shape of data is what really helps me.


00:17:51.480 --> 00:17:54.700
You mentioned a number or a list or something.


00:17:54.700 --> 00:17:57.800
But sometimes things can either conceptually,


00:17:57.800 --> 00:18:01.960
an argument to a function could be one thing or could be a set of things.


00:18:01.960 --> 00:18:04.200
Is it expecting if it's just one thing,


00:18:04.200 --> 00:18:09.000
can I do that or is it expect and types can give you that.


00:18:09.000 --> 00:18:13.120
One of the things you mentioned which perfectly sums up


00:18:13.120 --> 00:18:17.120
my philosophy for typing is I don't want to do it,


00:18:17.120 --> 00:18:21.080
but I want everybody else to put types in there.


00:18:21.080 --> 00:18:25.320
Because it's readability counts.


00:18:25.320 --> 00:18:31.700
>> Also, Mr. Wilson in the audience points out typing greatly assists with code completion


00:18:31.700 --> 00:18:32.700
for the editors.


00:18:32.700 --> 00:18:39.260
>> Yeah, it's got a bunch of tangential benefits. It's not just the one benefit. I mean, it


00:18:39.260 --> 00:18:46.020
catches bugs. But even if it didn't, I think typing would be an excellent addition to Python.


00:18:46.020 --> 00:18:49.380
>> If I can hit dot and it gives me more help, I'm already happy.


00:18:49.380 --> 00:18:50.720
- Yeah, bingo, yeah.


00:18:50.720 --> 00:18:52.320
I love typing.


00:18:52.320 --> 00:18:54.640
This is a very nice article.


00:18:54.640 --> 00:18:56.480
I'll let people read it.


00:18:56.480 --> 00:18:57.320
- Yeah.


00:18:57.320 --> 00:18:58.640
They also talk about the pain points


00:18:58.640 --> 00:19:00.400
of how that was painful for them.


00:19:00.400 --> 00:19:02.960
I think using, trying to get mypy


00:19:02.960 --> 00:19:05.640
to completely analyze everything


00:19:05.640 --> 00:19:08.200
is a different level of I want my public interface


00:19:08.200 --> 00:19:10.040
to say what it returns.


00:19:10.040 --> 00:19:12.000
You know, there's like, you gotta decide


00:19:12.000 --> 00:19:13.640
where do you live on this spectrum


00:19:13.640 --> 00:19:15.440
and what are some of the goals?


00:19:15.440 --> 00:19:17.000
Like, catching bugs, it's more important


00:19:17.000 --> 00:19:18.280
to have everything covered.


00:19:18.280 --> 00:19:21.560
of documentation, you know, a little bit less, I think.


00:19:21.560 --> 00:19:28.960
Yeah, I found it's changed my programming style. The code I write is, is less dynamic,


00:19:28.960 --> 00:19:35.680
I'm more likely to fix types quite early on. And I don't do any well, I don't do too much


00:19:35.680 --> 00:19:41.720
get outer and set outer. And I don't use all the dynamic capabilities of Python, I prefer


00:19:41.720 --> 00:19:46.360
to write static code that looks a bit more like C. So I can understand why people have


00:19:46.360 --> 00:19:51.520
that they feel like it's taken away a bit of freedom from them. But I do think it's


00:19:51.520 --> 00:19:57.800
given you the freedom to write solid code that doesn't have, you know, no attributes


00:19:57.800 --> 00:19:59.000
on none type errors.


00:19:59.000 --> 00:20:04.680
Yeah, I agree. I think you can compare it to things like TypeScript. TypeScript has


00:20:04.680 --> 00:20:09.600
a similar idea, but TypeScript is very particular. And if you don't get it just right, it'll


00:20:09.600 --> 00:20:14.080
give you compiler errors and it won't, it won't do the steps it needs to do to make


00:20:14.080 --> 00:20:17.880
JavaScript, whereas Python, maybe your editor will give you a warning or some tool like


00:20:17.880 --> 00:20:23.040
my pile give you a warning, but it doesn't really get in the way of it still functioning,


00:20:23.040 --> 00:20:27.620
you know, which unless you're doing something where it depends upon it, like pedantic or


00:20:27.620 --> 00:20:32.220
fast API where it's actually using that. But most of the time it's, it's there when you


00:20:32.220 --> 00:20:37.560
want it and you can kind of ignore it if you don't. Yeah. Yeah. So rich has a lot of,


00:20:37.560 --> 00:20:47.080
Yeah, it's fully typed. Yeah. So textual. It's not passing my pie. Currently, there


00:20:47.080 --> 00:20:52.080
are some like little dynamic corners and little typing errors, which we're gradually improving.


00:20:52.080 --> 00:20:58.960
But all new code is typed and, and changes are typed. So yeah, we're really big on on


00:20:58.960 --> 00:21:00.280
typing and textualize.


00:21:00.280 --> 00:21:05.280
- Brian, how about with your pytest extensions, plugins?


00:21:05.280 --> 00:21:08.960
- You know, it doesn't really come up much,


00:21:08.960 --> 00:21:12.640
but I don't really think about it a lot, actually.


00:21:12.640 --> 00:21:16.040
So I would like, but I have other applications


00:21:16.040 --> 00:21:19.280
that I'm working on that I definitely involve typing.


00:21:19.280 --> 00:21:23.000
And I started out with just the, like you were saying,


00:21:23.000 --> 00:21:24.360
trying to help with documentation.


00:21:24.360 --> 00:21:27.080
So making sure the API is typed.


00:21:27.080 --> 00:21:28.200
I think that's essential.


00:21:28.200 --> 00:21:30.860
I think it's just a good idea.


00:21:30.860 --> 00:21:32.720
Especially now with the improvements


00:21:32.720 --> 00:21:33.700
of some of the typing.


00:21:33.700 --> 00:21:36.420
So you can do, you don't have to say union anymore.


00:21:36.420 --> 00:21:41.020
I like the bar for or, like it's a non, you know,


00:21:41.020 --> 00:21:43.860
it's this, it's an int or a non or something like that.


00:21:43.860 --> 00:21:45.460
That's way cleaner than it used to be.


00:21:45.460 --> 00:21:48.960
And you don't have to import typing as much as you used to.


00:21:48.960 --> 00:21:51.620
I don't want to import typing just so that I can type some,


00:21:51.620 --> 00:21:54.180
type in something that seems wrong.


00:21:54.180 --> 00:21:58.300
But, and I'm on the phase of trying to integrate it more


00:21:58.300 --> 00:22:01.460
in the rest of my code, just because I'm,


00:22:01.460 --> 00:22:03.260
you know, even in a solo project,


00:22:03.260 --> 00:22:04.860
sometimes you're also a user,


00:22:04.860 --> 00:22:07.140
'cause you come back to something six months from now


00:22:07.140 --> 00:22:09.640
and try to figure out what you're doing.


00:22:09.640 --> 00:22:11.860
And it's nice to be able to not have to look at the code.


00:22:11.860 --> 00:22:12.780
So I like it.


00:22:12.780 --> 00:22:14.620
- Yeah, absolutely, absolutely.


00:22:14.620 --> 00:22:16.380
Well, we could find Will.


00:22:16.380 --> 00:22:18.980
- Yeah, so I wanna say something nice


00:22:18.980 --> 00:22:20.860
about the AI in real life,


00:22:20.860 --> 00:22:24.600
and actually the podcast IRL from Mozilla.


00:22:24.600 --> 00:22:26.900
So this episode of Python Bytes is brought to you


00:22:26.900 --> 00:22:31.900
by the IRL podcast, an original podcast from Mozilla.


00:22:31.900 --> 00:22:33.860
And I'm really enjoying it.


00:22:33.860 --> 00:22:35.520
I'm listening to a whole bunch of it.


00:22:35.520 --> 00:22:37.700
If you care about ideas behind technology,


00:22:37.700 --> 00:22:40.640
not just the tech itself, you'll enjoy IRL.


00:22:40.640 --> 00:22:43.640
Tech has an enormous influence on our society.


00:22:43.640 --> 00:22:45.620
Many effects are beneficial.


00:22:45.620 --> 00:22:47.480
The influences, like for instance,


00:22:47.480 --> 00:22:48.960
the information and assistance we get


00:22:48.960 --> 00:22:50.440
through cell phones is amazing.


00:22:50.440 --> 00:22:53.240
I love being able to look up the closest coffee shop


00:22:53.240 --> 00:22:55.200
wherever I'm dropped on the earth


00:22:55.200 --> 00:22:57.040
or knowing where my kids are.


00:22:57.040 --> 00:22:58.920
But some are not so great because like,


00:22:58.920 --> 00:23:00.680
I don't want somebody else to know


00:23:00.680 --> 00:23:02.240
how often I hit the coffee shop


00:23:02.240 --> 00:23:05.280
and I definitely don't want somebody else tracking my kids.


00:23:05.280 --> 00:23:08.000
So Mozilla has always been on the lookout


00:23:08.000 --> 00:23:10.640
for possible downsides to technology


00:23:10.640 --> 00:23:13.720
and works to mitigate negative influences of tech


00:23:13.720 --> 00:23:16.900
on the negative influences on all of us.


00:23:16.900 --> 00:23:19.360
If ideas like that and concerns about technology


00:23:19.360 --> 00:23:21.640
resonate with you, you should definitely check out


00:23:21.640 --> 00:23:23.360
the IRL podcast.


00:23:23.360 --> 00:23:25.460
This season is hosted by Bridget Todd


00:23:25.460 --> 00:23:28.020
and is looking at AI in real life.


00:23:28.020 --> 00:23:29.040
Who can AI help?


00:23:29.040 --> 00:23:30.840
And also, who can it harm?


00:23:30.840 --> 00:23:32.980
The show features fascinating conversations


00:23:32.980 --> 00:23:37.040
with people who are working to build a more trustworthy AI


00:23:37.040 --> 00:23:39.640
and also using AI to help us.


00:23:39.640 --> 00:23:42.620
So I really enjoyed a few episodes so far.


00:23:42.620 --> 00:23:46.360
There's an episode on how our world is mapped with AI.


00:23:46.360 --> 00:23:49.520
So data and maps is being used to make decisions


00:23:49.520 --> 00:23:50.720
that affect real people,


00:23:50.720 --> 00:23:54.640
even like by districts and by governments.


00:23:54.640 --> 00:23:56.640
But how can people reclaim the power


00:23:56.640 --> 00:23:59.400
over their own maps and stories using AI?


00:23:59.400 --> 00:24:01.840
This is fascinating episode.


00:24:01.840 --> 00:24:03.660
Another episode is about gig workers


00:24:03.660 --> 00:24:06.160
who depend on apps for their livelihood.


00:24:06.160 --> 00:24:09.100
It looks at how they're pushing back against algorithms


00:24:09.100 --> 00:24:11.480
to control how much they get paid


00:24:11.480 --> 00:24:14.280
and seeking new ways to gain power over the data


00:24:14.280 --> 00:24:16.340
to create better working conditions.


00:24:16.340 --> 00:24:18.960
And how about elections?


00:24:18.960 --> 00:24:22.440
So episode four of this season addresses the role


00:24:22.440 --> 00:24:24.880
that AI plays when it comes to both spreading


00:24:24.880 --> 00:24:27.040
dense information around elections,


00:24:27.040 --> 00:24:31.640
but also how to combat disinformation.


00:24:31.640 --> 00:24:34.400
This is a huge concern for democracies around the world


00:24:34.400 --> 00:24:36.800
and for me, especially in the US,


00:24:36.800 --> 00:24:38.680
but I know it affects everybody.


00:24:38.680 --> 00:24:40.660
If this sounds interesting to you,


00:24:40.660 --> 00:24:43.120
you should try it because it is interesting.


00:24:43.120 --> 00:24:44.280
Try an episode for yourself.


00:24:44.280 --> 00:24:46.900
Just search for IRL in your podcast player


00:24:46.900 --> 00:24:50.680
or visit pythonbytes.fm/irl.


00:24:50.680 --> 00:24:53.040
I think the best way is to select,


00:24:53.040 --> 00:24:56.840
go to pythonbytes.fm/irl so they know you came from us.


00:24:56.840 --> 00:25:00.560
And the link is in your show notes.


00:25:00.560 --> 00:25:03.600
Thank you IRL and Mozilla for supporting our show.


00:25:03.600 --> 00:25:04.600
- Yeah, cool podcast.


00:25:04.600 --> 00:25:05.440
Thank you.


00:25:05.440 --> 00:25:06.400
Thank you, Mozilla.


00:25:06.400 --> 00:25:08.760
All right, on to the next one.


00:25:08.760 --> 00:25:10.000
Well, we already touched a little bit


00:25:10.000 --> 00:25:11.800
on the whole ORM thing.


00:25:11.800 --> 00:25:14.160
And I hear some people use Django.


00:25:14.160 --> 00:25:15.640
It's a web framework.


00:25:15.640 --> 00:25:17.600
- Yeah, a few people use it.


00:25:17.600 --> 00:25:18.440
Proud of it.


00:25:18.440 --> 00:25:20.120
- Yeah.


00:25:20.120 --> 00:25:23.120
So really popular and they're picking up the speed,


00:25:23.120 --> 00:25:24.780
of course, for their releases, right?


00:25:24.780 --> 00:25:27.560
For a long time it was one, then we had two, three, four.


00:25:27.560 --> 00:25:30.220
Going really quickly over a couple years there.


00:25:30.220 --> 00:25:34.360
Well, one of the big moves with many of the web frameworks


00:25:34.360 --> 00:25:37.280
ever since Python 3.6 or so has been


00:25:37.280 --> 00:25:39.440
how are you going to participate


00:25:39.440 --> 00:25:42.800
and facilitate using async and await, right?


00:25:42.800 --> 00:25:44.800
If you're doing a long database query


00:25:44.800 --> 00:25:47.920
and you block with an ORM request, for example,


00:25:47.920 --> 00:25:51.360
what are you, you know, how do you parallelize that


00:25:51.360 --> 00:25:53.880
or scale that without much effort?


00:25:53.880 --> 00:25:55.880
Well, the async IO is perfect for it,


00:25:55.880 --> 00:26:00.160
but if your APIs don't support it, you can't use it.


00:26:00.160 --> 00:26:01.680
And Django has been making its way


00:26:01.680 --> 00:26:04.520
towards having async capabilities,


00:26:04.520 --> 00:26:06.200
but what is the one thing


00:26:06.200 --> 00:26:08.520
that websites wait on the most?


00:26:08.520 --> 00:26:09.360
Databases.


00:26:09.360 --> 00:26:12.520
What is the one thing Django did not have async support for?


00:26:12.520 --> 00:26:13.600
Databases.


00:26:13.600 --> 00:26:17.440
So, it's a little bit late here on the announcement.


00:26:17.440 --> 00:26:21.560
So, in beginning of August, Django 4.1 came out


00:26:21.560 --> 00:26:25.080
and this means 3.8 and above.


00:26:25.080 --> 00:26:27.600
But the big deal is the second one actually


00:26:27.600 --> 00:26:31.320
is an asynchronous ORM interface for doing queries.


00:26:31.320 --> 00:26:34.320
So, you can do anything that's a query set.


00:26:34.320 --> 00:26:36.700
So, you can say, like if you have a class,


00:26:36.700 --> 00:26:38.020
a model class called authors,


00:26:38.020 --> 00:26:40.160
you would say author.objects.filter,


00:26:40.160 --> 00:26:41.960
and then you do a thing and so on.


00:26:41.960 --> 00:26:46.120
So now you can say async for and do your query,


00:26:46.120 --> 00:26:48.040
and now it's all happening async.


00:26:48.040 --> 00:26:51.360
And if you want to do like a join author.books,


00:26:51.360 --> 00:26:55.460
you can await getting access to that thing.


00:26:55.460 --> 00:26:59.180
Books normally has a .first in this example,


00:26:59.180 --> 00:27:02.720
but they've now added also an a first.


00:27:02.720 --> 00:27:04.200
So if you want the async version,


00:27:04.200 --> 00:27:06.840
you put the a as a prefix.


00:27:06.840 --> 00:27:08.160
I'm not sure how I feel about that.


00:27:08.160 --> 00:27:10.240
I'm not sure I would have gone this path,


00:27:10.240 --> 00:27:12.400
but you know, it doesn't really matter.


00:27:12.400 --> 00:27:15.400
It's awesome that there's some kind of async support


00:27:15.400 --> 00:27:17.880
in the Django ORM, so that's really, really cool.


00:27:17.880 --> 00:27:19.720
I think, I just wanted to highlight that,


00:27:19.720 --> 00:27:21.240
that this has been a major blocker


00:27:21.240 --> 00:27:24.080
to like real async programming in Django.


00:27:24.080 --> 00:27:28.280
It's like, well, you can make the web view method async,


00:27:28.280 --> 00:27:29.500
but then you can't do async stuff


00:27:29.500 --> 00:27:31.600
that you really want to do, so, you know, where are you?


00:27:31.600 --> 00:27:35.080
Right, this is like, this unlocks the final keys, right?


00:27:35.080 --> 00:27:40.720
could call APIs previously with say HTTPS asynchronously, but then block on the database.


00:27:40.720 --> 00:27:43.880
Now just use the A version and off you go.


00:27:43.880 --> 00:27:49.120
I guess they couldn't make the one without A, they couldn't make first awaitable because


00:27:49.120 --> 00:27:52.080
that would break old code, I imagine.


00:27:52.080 --> 00:27:57.360
Yes, but here's my thought, right? So what I'm getting back, so when I say async for


00:27:57.360 --> 00:28:03.480
author in query, you're now switching into an async mode. So I think the thing that returns


00:28:03.480 --> 00:28:07.720
would be really great if it like now everything must be async on it.


00:28:07.720 --> 00:28:10.160
If you just said for author in query,


00:28:10.160 --> 00:28:13.320
now it returns a synchronous and everything on it must be synchronous.


00:28:13.320 --> 00:28:16.260
This is how I would have maybe done instead of trying to


00:28:16.260 --> 00:28:19.260
prefix everything with A and double down on it,


00:28:19.260 --> 00:28:21.360
but maybe it was just a bridge too far.


00:28:21.360 --> 00:28:23.800
I don't know. But this is what I had in mind.


00:28:23.800 --> 00:28:25.360
I said I'm not sure what it is.


00:28:25.360 --> 00:28:27.760
You can go in async mode or synchronous mode,


00:28:27.760 --> 00:28:30.000
and then you're there is what I had in mind.


00:28:30.000 --> 00:28:32.780
>> Yeah, that makes sense. The async for


00:28:32.780 --> 00:28:38.700
would return a special version of the object, which had different first methods, the same


00:28:38.700 --> 00:28:39.700
API, but awaitable.


00:28:39.700 --> 00:28:44.820
- Right, but awaitable, exactly, exactly. You know, that doesn't mean they can't do


00:28:44.820 --> 00:28:46.900
that in the future, potentially, but yeah.


00:28:46.900 --> 00:28:47.900
- Yeah.


00:28:47.900 --> 00:28:51.660
- Okay, a few other updates, just for, while I'm already here, the thing I really wanted


00:28:51.660 --> 00:28:58.460
to call it is async ORM in Django, good to go. Also, you can have class-based views,


00:28:58.460 --> 00:29:02.460
where you have a class and then methods like get, post, put, and so on.


00:29:02.460 --> 00:29:04.660
Or you can have just method-based ones.


00:29:04.660 --> 00:29:07.560
I prefer the method-based stuff with a decorator,


00:29:07.560 --> 00:29:10.560
but if you have the class-based ones,


00:29:10.560 --> 00:29:13.260
they now can also be async, right? So that's cool.


00:29:13.260 --> 00:29:16.260
And there's also some validation of constraints


00:29:16.260 --> 00:29:17.760
is one of the other big changes.


00:29:17.760 --> 00:29:20.260
So check unique and exclusion constraints


00:29:20.260 --> 00:29:23.060
defined in meta constraints are options


00:29:23.060 --> 00:29:25.260
are now checked during model validation.


00:29:25.260 --> 00:29:26.360
Apparently they weren't before.


00:29:26.360 --> 00:29:28.160
So that seems pretty valuable too,


00:29:28.160 --> 00:29:30.880
but the ORM is the big news, I think.


00:29:30.880 --> 00:29:32.240
- Yeah. - Yep.


00:29:32.240 --> 00:29:33.080
- That must mean-- - Cool, all right.


00:29:33.080 --> 00:29:35.520
So yeah, it's great to see Django coming along.


00:29:35.520 --> 00:29:39.200
It's been around for so long as a stalwart


00:29:39.200 --> 00:29:42.500
of the Python web world, and now it's much closer


00:29:42.500 --> 00:29:45.280
to the most modern features, which is great.


00:29:45.280 --> 00:29:46.320
- Yeah, very cool.


00:29:46.320 --> 00:29:48.760
- Yep, all right, Brian, what you got next for us?


00:29:48.760 --> 00:29:54.680
- I have walrus operators. (laughs)


00:29:54.680 --> 00:29:57.120
So I really--


00:29:57.120 --> 00:29:58.400
Walrus is on the brain.


00:29:58.400 --> 00:30:03.360
I do. I like Walrus operators, the Walrus operator, but I don't think I've been using it enough.


00:30:03.360 --> 00:30:08.080
And especially because this article is telling me all sorts of places that I should use it more.


00:30:08.080 --> 00:30:16.000
So I've got a an article from Martin Hines titled, You should be using Python's Walrus operator,


00:30:16.000 --> 00:30:21.840
operator, and here's why. And there's some just some stuff that I never even really thought about


00:30:21.840 --> 00:30:25.280
before like it just starts right off the bat.


00:30:25.280 --> 00:30:30.120
I'm talking about the as as a basics in the basic section.


00:30:30.120 --> 00:30:31.640
I never would have thought about that.


00:30:31.640 --> 00:30:35.720
So there's a there's a list that happens to call a function to


00:30:35.720 --> 00:30:38.680
create the data in a list and it calls it three times.


00:30:38.680 --> 00:30:40.920
Now really, I probably wouldn't have done this in code.


00:30:40.920 --> 00:30:43.280
I probably would have called the function once and then named


00:30:43.280 --> 00:30:46.440
the variable and stuck it in there, but you can do that.


00:30:46.440 --> 00:30:47.240
It's still easier.


00:30:47.240 --> 00:30:51.780
You can do the all the function in the first element and save


00:30:51.780 --> 00:30:56.540
the value and then use the value in future operations just to create a list.


00:30:56.540 --> 00:30:58.580
Right off the bat, that's pretty cool.


00:30:58.580 --> 00:31:01.260
I wouldn't have thought to do that. It's nice.


00:31:01.260 --> 00:31:03.740
I didn't actually quite follow this.


00:31:03.740 --> 00:31:04.940
We get to save.


00:31:04.940 --> 00:31:11.660
Here's a comprehension where a function is called twice.


00:31:11.660 --> 00:31:17.900
You put in the value of a function if something around the function,


00:31:17.900 --> 00:31:22.420
like if it's true or if it evaluates Boolean true.


00:31:22.420 --> 00:31:26.980
You can do that with the walrus operator and only call it once.


00:31:26.980 --> 00:31:32.340
That's cool. One of the things I really liked around was,


00:31:32.340 --> 00:31:33.840
I didn't think about before,


00:31:33.840 --> 00:31:35.340
but I'm definitely going to use it now,


00:31:35.340 --> 00:31:38.600
is the regular expression match function.


00:31:38.600 --> 00:31:40.580
You often had to call match,


00:31:40.580 --> 00:31:43.540
and then if something was found,


00:31:43.540 --> 00:31:45.700
then you do something with the match object.


00:31:45.700 --> 00:31:49.740
you get the groups or some other thing on the match object.


00:31:49.740 --> 00:31:52.500
It is cleaner to just go ahead and do


00:31:52.500 --> 00:31:58.740
the query of whether or not the match returns something,


00:31:58.740 --> 00:32:00.740
right with a walrus operator,


00:32:00.740 --> 00:32:04.220
way cleaner code. I like this.


00:32:04.220 --> 00:32:06.840
Actually, it's just a fairly big article


00:32:06.840 --> 00:32:08.380
talking about a whole bunch of places.


00:32:08.380 --> 00:32:12.220
Now, here's the place where I like while true loops.


00:32:12.220 --> 00:32:15.380
That always drives me nuts or having to flag something.


00:32:15.380 --> 00:32:19.000
This is definitely a place where I started using


00:32:19.000 --> 00:32:22.520
whileRest operator right away of instead of saying like


00:32:22.520 --> 00:32:25.860
while true or while flag or something,


00:32:25.860 --> 00:32:30.420
do something and then break out if necessary


00:32:30.420 --> 00:32:32.820
or set the stop bit or something.


00:32:32.820 --> 00:32:35.500
You can do that right within the while loop.


00:32:35.500 --> 00:32:38.820
Actually, I don't know if it's,


00:32:38.820 --> 00:32:40.720
it is cleaner, it's less code.


00:32:40.720 --> 00:32:43.660
I don't know if this is easier to read though.


00:32:43.660 --> 00:32:45.740
Any thoughts from you guys?


00:32:45.740 --> 00:32:46.940
- Yeah.


00:32:46.940 --> 00:32:50.740
- I think once you know it, it's not too bad.


00:32:50.740 --> 00:32:52.860
It is quite different from Python


00:32:52.860 --> 00:32:54.760
prior to the Walrus operator.


00:32:54.760 --> 00:32:58.620
Even for me, I barely use the Walrus operator


00:32:58.620 --> 00:33:00.180
because I'm working on libraries


00:33:00.180 --> 00:33:02.780
and the minimum version is 3.7.


00:33:02.780 --> 00:33:03.620
- Yeah, right.


00:33:03.620 --> 00:33:07.100
- So I haven't trained myself to read Walrus operator,


00:33:07.100 --> 00:33:08.860
but to me, that doesn't look too bad.


00:33:08.860 --> 00:33:10.380
That looks really clear.


00:33:10.380 --> 00:33:11.220
- Okay.


00:33:11.220 --> 00:33:12.940
- Yeah, this is nice.


00:33:12.940 --> 00:33:16.560
especially if you do one of those things where like,


00:33:16.560 --> 00:33:18.980
the example here is getting input from the user,


00:33:18.980 --> 00:33:20.620
where you might get input from the user


00:33:20.620 --> 00:33:23.360
and then say, "Wow, let's not exit," or whatever.


00:33:23.360 --> 00:33:25.280
Then in your loop, you get the same input


00:33:25.280 --> 00:33:27.600
with the same basic question again,


00:33:27.600 --> 00:33:30.080
but you've got to ask it before to see if they ever enter.


00:33:30.080 --> 00:33:32.480
You know, there's like this weird sort of do it two times,


00:33:32.480 --> 00:33:34.280
and you could skip that with the Walsh operator,


00:33:34.280 --> 00:33:36.120
which is very cool.


00:33:36.120 --> 00:33:37.880
- Oh yeah, yeah, I used to do that,


00:33:37.880 --> 00:33:40.360
like on the top example of just putting


00:33:40.360 --> 00:33:42.480
the command equals input and doing that above.


00:33:42.480 --> 00:33:44.800
>> Exactly. Yeah, and then do the same test. Exactly.


00:33:44.800 --> 00:33:45.280
>> Yeah.


00:33:45.280 --> 00:33:46.000
>> Exactly.


00:33:46.000 --> 00:33:49.280
>> Because I really don't like while true loops.


00:33:49.280 --> 00:33:51.720
>> Only if you mean really do it forever,


00:33:51.720 --> 00:33:54.800
or until, yeah, exactly.


00:33:54.800 --> 00:33:58.160
Until it really is some case where you need to break out of it.


00:33:58.160 --> 00:34:01.120
>> Anyway, so the rest of the article is great too,


00:34:01.120 --> 00:34:02.480
accumulating in place,


00:34:02.480 --> 00:34:04.200
there's a whole bunch of cool places.


00:34:04.200 --> 00:34:05.940
Oh, this is one I really liked,


00:34:05.940 --> 00:34:07.120
I wanted to highlight.


00:34:07.120 --> 00:34:08.280
>> String as well.


00:34:08.280 --> 00:34:10.880
>> Naming values inside of an F-string.


00:34:10.880 --> 00:34:15.200
So there's an example of an F-string where you take the date time,


00:34:15.200 --> 00:34:17.080
and you're using, for instance,


00:34:17.080 --> 00:34:21.280
you might use the date time value in two different formats.


00:34:21.280 --> 00:34:23.400
It formatted in two different ways,


00:34:23.400 --> 00:34:25.240
once with what year, month,


00:34:25.240 --> 00:34:27.440
day, and once with A,


00:34:27.440 --> 00:34:28.920
which I don't know what A is,


00:34:28.920 --> 00:34:33.240
but which is the day spelled out for Friday.


00:34:33.240 --> 00:34:39.640
Now, it's assigning the date time today value


00:34:39.640 --> 00:34:43.320
to a today variable and then using it,


00:34:43.320 --> 00:34:45.920
using the value in a format string and then using


00:34:45.920 --> 00:34:49.620
the today variable later in the same format string.


00:34:49.620 --> 00:34:52.160
This is a pretty cool trick.


00:34:52.160 --> 00:34:54.760
There's multiple times where I'm using


00:34:54.760 --> 00:34:57.440
the same value in a couple of places


00:34:57.440 --> 00:34:59.720
because I'm formatting it differently with an F-string.


00:34:59.720 --> 00:35:01.160
This is pretty cool.


00:35:01.160 --> 00:35:02.720
>> Yeah, that is pretty cool.


00:35:02.720 --> 00:35:05.680
The one that I really like is the list comprehension,


00:35:05.680 --> 00:35:07.880
because that always drives me crazy.


00:35:07.880 --> 00:35:11.400
if you're going to do an if section, right?


00:35:11.400 --> 00:35:14.480
You know, if you're going to say x for x in collection,


00:35:14.480 --> 00:35:15.800
if something.


00:35:15.800 --> 00:35:16.280
Yeah.


00:35:16.280 --> 00:35:19.800
And that the thing you want in the list is some kind of


00:35:19.800 --> 00:35:23.400
like a database call or some other thing that has to be computed.


00:35:23.400 --> 00:35:25.960
Then you need to test that computer value


00:35:25.960 --> 00:35:28.800
before the walrus operator, you had to call that function twice


00:35:28.800 --> 00:35:29.840
no matter what.


00:35:29.840 --> 00:35:31.160
Like if that was a


00:35:31.160 --> 00:35:32.640
go get me the user from the data,


00:35:32.640 --> 00:35:34.480
like I want to go through all the emails


00:35:34.480 --> 00:35:36.680
and then get a list of users that correspond to them.


00:35:36.680 --> 00:35:39.640
but maybe some of the emails don't actually exist in the database.


00:35:39.640 --> 00:35:43.100
Every if statement has to be, get me the user if it exists.


00:35:43.100 --> 00:35:47.340
And then the list result, the values select out is also get me the user, right?


00:35:47.340 --> 00:35:50.700
And this way, when it's really expensive like that, it's super nice.


00:35:50.700 --> 00:35:54.420
It also is really useful in this situation when you're doing data science


00:35:54.420 --> 00:35:57.500
stuff that expects one line of a thing.


00:35:57.500 --> 00:36:01.580
You know, you're like, I want to do, I want to pass this expression to like a


00:36:01.580 --> 00:36:03.600
panda's data frame or some other thing.


00:36:03.600 --> 00:36:06.180
And you can kind of get a little bit more done this way.


00:36:06.180 --> 00:36:07.180
It's really nice.


00:36:07.180 --> 00:36:08.660
>> Yeah. This is pretty cool.


00:36:08.660 --> 00:36:11.140
Actually, I hadn't thought about doing it within


00:36:11.140 --> 00:36:16.820
the if clause within a comprehension or something.


00:36:16.820 --> 00:36:20.440
>> Yeah. This is the one where there was no other way.


00:36:20.440 --> 00:36:25.960
There is no way in 3.7 to do this without calling the function twice.


00:36:25.960 --> 00:36:28.140
In a comprehension, you could do a totally different structure,


00:36:28.140 --> 00:36:30.220
like a loop or something, but in a comprehension,


00:36:30.220 --> 00:36:33.500
where you have to have one line like a data science scenario,


00:36:33.500 --> 00:36:36.780
you had to call it twice until the walrus came around.


00:36:36.780 --> 00:36:37.860
So I think that's fantastic.


00:36:37.860 --> 00:36:43.980
>> Yeah, I suppose you could create a list expression of


00:36:43.980 --> 00:36:48.100
the return value of bunk and then use a zip or something,


00:36:48.100 --> 00:36:49.580
but it's super awkward.


00:36:49.580 --> 00:36:51.620
>> Right, exactly. Yeah.


00:36:51.620 --> 00:36:51.940
>> All right.


00:36:51.940 --> 00:36:53.660
>> Very cool. It's nice to see a bunch of


00:36:53.660 --> 00:36:55.660
different use cases because then you can see,


00:36:55.660 --> 00:36:58.100
"Oh, I will never do that. That's horrible."


00:36:58.100 --> 00:36:59.980
But this is really great and I didn't do that.


00:36:59.980 --> 00:37:01.340
You could even see in the audience,


00:37:01.340 --> 00:37:02.780
people are reacting like, "This is amazing,


00:37:02.780 --> 00:37:04.660
But this one is, I don't know about this one.


00:37:04.660 --> 00:37:05.660
This is, yeah.


00:37:05.660 --> 00:37:06.660
Yeah, yeah.


00:37:06.660 --> 00:37:07.660
So, cool.


00:37:07.660 --> 00:37:11.220
What do we got next from you, Will?


00:37:11.220 --> 00:37:12.740
Ah, yeah.


00:37:12.740 --> 00:37:15.740
Oh, we're right on the right page.


00:37:15.740 --> 00:37:19.380
So I'm sure we all love regular expressions.


00:37:19.380 --> 00:37:21.380
We have a love-hate relationship with them.


00:37:21.380 --> 00:37:28.820
Yeah, those, I don't like regular expressions, but I use them a lot because they're powerful.


00:37:28.820 --> 00:37:33.500
There is no alternative a lot of the time.


00:37:33.500 --> 00:37:35.300
But they are very difficult to read.


00:37:35.300 --> 00:37:38.020
You tend to get long strings of gibberish,


00:37:38.020 --> 00:37:42.700
which even if you're very well versed in regular expressions,


00:37:42.700 --> 00:37:44.580
you might find it quite hard to parse


00:37:44.580 --> 00:37:46.340
and figure out what's actually doing


00:37:46.340 --> 00:37:51.340
when you've come back to your code in the afternoon.


00:37:51.340 --> 00:37:55.100
But this is a library written by Al Swigert,


00:37:55.100 --> 00:37:57.260
and I think that's how you pronounce his name.


00:37:57.260 --> 00:37:58.260
rhymes with wider.


00:37:58.260 --> 00:38:03.180
He's an author and he's written this Python library,


00:38:03.180 --> 00:38:06.220
which gives you kind of like a nicer way


00:38:06.220 --> 00:38:08.660
of expressing regular expressions.


00:38:08.660 --> 00:38:11.260
It compiles regular expressions


00:38:11.260 --> 00:38:14.020
from a bunch of function calls.


00:38:14.020 --> 00:38:17.180
And these function calls are much more descriptive


00:38:17.180 --> 00:38:19.380
and they read quite well.


00:38:19.380 --> 00:38:24.220
So you can essentially read a regular expression


00:38:24.220 --> 00:38:27.060
in the future and find it quite legible.


00:38:27.060 --> 00:38:32.460
I like the either option. It's either this or it's that.


00:38:32.460 --> 00:38:37.280
For example, it's very readable. Like here we've got exactly exactly five digits plus


00:38:37.280 --> 00:38:41.620
optional whitespace plus one or more non whitespace. That's very readable. If you read that a second


00:38:41.620 --> 00:38:46.420
time you'd know exactly what that did. But if you saw this, this is a very short regular


00:38:46.420 --> 00:38:47.420
expression.


00:38:47.420 --> 00:38:48.420
Yeah, exactly.


00:38:48.420 --> 00:38:49.420
Yeah, exactly.


00:38:49.420 --> 00:38:54.260
Even if you're good at regular expressions, I've been using them for 15 years, I'd have


00:38:54.260 --> 00:38:59.020
to like analyze that. And it might take me several minutes to figure out what that does.


00:38:59.020 --> 00:39:03.020
So you know, if it's quite powerful, just for such a short regular expression, but you


00:39:03.020 --> 00:39:07.740
can make much larger ones. You know, here's something that's more complicated, but it's


00:39:07.740 --> 00:39:13.100
still quite readable. Either non captioning group, non captioning group, either this or


00:39:13.100 --> 00:39:20.300
that, one or more of this, plus non-captioning group, it's readable. And you can, you know,


00:39:20.300 --> 00:39:25.740
come back to it and other developers see it. They can understand what's going on. And in


00:39:25.740 --> 00:39:33.340
the end, it compiles it to a regular expression. So it's just as fast and powerful. But now


00:39:33.340 --> 00:39:35.420
it's just easier to work with.


00:39:35.420 --> 00:39:42.300
>> Yeah, it's really nice because the output of this little library is just the text pattern


00:39:42.300 --> 00:39:46.300
of the regular expression, which then you can do it. It's not like you've got to adopt


00:39:46.300 --> 00:39:47.820
this entire library for everything.


00:39:47.820 --> 00:39:52.780
Yeah, yeah, you can, you know, just anywhere that you need to write a complex regular expression,


00:39:52.780 --> 00:39:59.180
you could use this. I guess if you wanted to develop the reg x, you could use this.


00:39:59.180 --> 00:40:03.020
And then once you've done, you could compile it and then put the actual reg x back in your


00:40:03.020 --> 00:40:07.860
code. Or you could just leave it like that. It's probably not, it's not slow.


00:40:07.860 --> 00:40:12.200
No, no, I would probably leave it like this. But I'm thinking if you're using another


00:40:12.200 --> 00:40:18.520
library where it expects a regular expression string, right? It's still totally compatible


00:40:18.520 --> 00:40:21.320
with that because you just say, "Give me the string," and off it goes.


00:40:21.320 --> 00:40:26.040
Yeah, yeah. So it's not going to break anything. It's not like you're switching or you don't


00:40:26.040 --> 00:40:31.560
have to port anything per se. It's a nice drop-in thing where you need it. So yeah,


00:40:31.560 --> 00:40:32.560
it's pretty cool.


00:40:32.560 --> 00:40:34.760
Yeah, very cool. Excellent find.


00:40:34.760 --> 00:40:39.760
- So that thing's library's called H-U-M-R-E,


00:40:39.760 --> 00:40:40.600
is that humor-y?


00:40:40.600 --> 00:40:43.040
- Human readable regular expressions, I think.


00:40:43.040 --> 00:40:47.280
- I just like, I'm gonna call it humor,


00:40:47.280 --> 00:40:51.800
because then the regular expressions are humorous.


00:40:51.800 --> 00:40:52.640
- Yeah.


00:40:52.640 --> 00:40:54.760
Very nice.


00:40:54.760 --> 00:40:56.480
- Okay.


00:40:56.480 --> 00:40:57.300
- I love it.


00:40:57.300 --> 00:40:59.100
All right, Brian, is that all of our things?


00:40:59.100 --> 00:41:00.360
All of our main topics?


00:41:00.360 --> 00:41:01.400
- I think that is.


00:41:01.400 --> 00:41:03.640
Do we have any extras?


00:41:03.640 --> 00:41:05.880
I didn't, but now I do.


00:41:05.880 --> 00:41:07.160
- Okay, let's have it.


00:41:07.160 --> 00:41:09.560
- Out in the audience, Dean pointed out


00:41:09.560 --> 00:41:13.320
that the very first PyData Tel Aviv


00:41:13.320 --> 00:41:17.800
is happening in December, December 13th, 2022.


00:41:17.800 --> 00:41:19.320
So if you're in Tel Aviv


00:41:19.320 --> 00:41:22.220
and you care about Python data stuff, check that out.


00:41:22.220 --> 00:41:25.040
The call for proposals, I think it's open


00:41:25.040 --> 00:41:28.120
for two weeks or something like that.


00:41:28.120 --> 00:41:31.600
So yeah, if you wanna submit a talk or attend,


00:41:31.600 --> 00:41:32.760
then there you go.


00:41:32.760 --> 00:41:33.600
>> Nice.


00:41:33.600 --> 00:41:35.940
>> Cool. But that's my only extra.


00:41:35.940 --> 00:41:38.620
>> Okay. Well, you know what?


00:41:38.620 --> 00:41:41.700
I'm not going to let Will off the hook because the reason


00:41:41.700 --> 00:41:46.420
why I wanted you on here is so that you could promote Rich CLI.


00:41:46.420 --> 00:41:48.020
>> Okay.


00:41:48.020 --> 00:41:52.960
>> Why do you want more people to use


00:41:52.960 --> 00:41:55.800
Rich CLI or why do you think more people should use it?


00:41:55.800 --> 00:42:00.400
>> I just think it's a cool project. I use it.


00:42:00.400 --> 00:42:06.780
You've got all the power of rich, but it's on the command prompt so you can syntax highlight files


00:42:06.780 --> 00:42:08.780
You can also just generate


00:42:08.780 --> 00:42:13.020
Colorful rich style content you can put those in your bash scripts


00:42:13.020 --> 00:42:15.780
It's just a very useful thing


00:42:15.780 --> 00:42:24.780
Yeah, it's you can get it from homebrew if you do homebrew install rich and then you'll have


00:42:24.780 --> 00:42:29.540
rich at the the command prompt and you can use a peck and


00:42:29.540 --> 00:42:32.140
And yeah, it's got a lot of cool stuff.


00:42:32.140 --> 00:42:35.340
>> So do you have some workflow that you're using it for


00:42:35.340 --> 00:42:38.140
on a regular basis or do you use all of these workflows?


00:42:38.140 --> 00:42:40.820
>> It's more just a general tool.


00:42:40.820 --> 00:42:41.740
>> Okay.


00:42:41.740 --> 00:42:44.380
>> When I'm navigating the command prompts,


00:42:44.380 --> 00:42:45.660
I want to look at file.


00:42:45.660 --> 00:42:47.940
If it's a large file, I can use pager,


00:42:47.940 --> 00:42:49.780
and I can page up and down.


00:42:49.780 --> 00:42:52.980
Yeah, people check it out.


00:42:52.980 --> 00:42:55.140
It can display nice tables.


00:42:55.140 --> 00:43:00.720
You can take a CSV and turn it into a nicely formatted rich table and you can generate


00:43:00.720 --> 00:43:05.680
simple things like rules and oh, it can display markdown as well.


00:43:05.680 --> 00:43:11.880
So it's kind of like a general toolbox of like rich related stuff in the command prompt.


00:43:11.880 --> 00:43:16.280
I think I'm going to use it for, I didn't know it did CSV so easily.


00:43:16.280 --> 00:43:19.280
So I think I'll use it.


00:43:19.280 --> 00:43:25.120
So maybe anytime you might type more or cat or something like that to see the contents


00:43:25.120 --> 00:43:28.960
of a file you're proposing now I could type rich and get you know syntax highlighting


00:43:28.960 --> 00:43:29.960
and better.


00:43:29.960 --> 00:43:35.480
Yeah yeah so you do rich and name the file then hyphen hyphen pager and it'll give you


00:43:35.480 --> 00:43:39.800
a nice textual style pager.


00:43:39.800 --> 00:43:43.680
This came together in I think two weekends.


00:43:43.680 --> 00:43:48.800
At some point I'll go back and polish it a bit more because there's a few issues people


00:43:48.800 --> 00:43:51.080
asking for new features.


00:43:51.080 --> 00:43:52.320
- Okay. - Yeah, cool.


00:43:52.320 --> 00:43:53.720
- Two weekends. - Yeah, Kim in the audience says,


00:43:53.720 --> 00:43:56.960
"Rich CLI has replaced Cat, JQ, and Markdown tooling


00:43:56.960 --> 00:43:58.280
"for me with one tool."


00:43:58.280 --> 00:43:59.120
- Cool.


00:43:59.120 --> 00:44:00.800
- Yeah, very nice, Kim.


00:44:00.800 --> 00:44:03.840
- Well, how about a, oh, yeah, a joke,


00:44:03.840 --> 00:44:05.440
and then I've got one more thing.


00:44:05.440 --> 00:44:08.720
- Okay, well, I do have a joke, as you can imagine.


00:44:08.720 --> 00:44:13.720
So here's an example of where somebody is using open source


00:44:13.720 --> 00:44:16.920
to help keep their account secure.


00:44:16.920 --> 00:44:21.240
And this is some kind of list of like common passwords


00:44:21.240 --> 00:44:24.740
or really reused passwords that people want to,


00:44:24.740 --> 00:44:26.560
you know, somebody has posted these says,


00:44:26.560 --> 00:44:28.680
here's a list of passwords that people seem to use a lot


00:44:28.680 --> 00:44:29.500
and get reused a lot.


00:44:29.500 --> 00:44:31.600
So please don't use this as a password


00:44:31.600 --> 00:44:34.440
or check and don't let people use these passwords


00:44:34.440 --> 00:44:35.860
for their accounts, right?


00:44:35.860 --> 00:44:40.120
So someone comes along to this, to this repo


00:44:40.120 --> 00:44:43.840
and they remove the word dolphins as a PR.


00:44:43.840 --> 00:44:47.400
And the message is remove my password from list


00:44:47.400 --> 00:44:49.200
so hackers won't be able to hack me.


00:44:49.200 --> 00:44:55.020
The list of 10 million password top 1000 list.


00:44:55.020 --> 00:44:58.860
I mean, this is proactive business right here.


00:44:58.860 --> 00:45:02.920
- That might actually work if the hackers are very lazy


00:45:02.920 --> 00:45:04.520
and don't look at the get history.


00:45:04.520 --> 00:45:07.480
- It might actually, there may be a very small percentage


00:45:07.480 --> 00:45:09.360
of effectiveness to this.


00:45:09.360 --> 00:45:11.320
You're also saying my email address is this


00:45:11.320 --> 00:45:12.500
and my password is that.


00:45:12.500 --> 00:45:14.300
so please don't put them together.


00:45:14.300 --> 00:45:17.620
- By the way, this is my credit card number,


00:45:17.620 --> 00:45:19.900
so don't paste it anywhere.


00:45:19.900 --> 00:45:23.660
- Anyway, that's my joke.


00:45:23.660 --> 00:45:25.660
- Okay, well the last thing I just wanted to say


00:45:25.660 --> 00:45:26.900
is I got a new hat recently,


00:45:26.900 --> 00:45:28.580
so I wanted to show off my new hat.


00:45:28.580 --> 00:45:30.020
- Oh yeah, let's see it.


00:45:30.020 --> 00:45:32.540
- It's a top hat. - I love it.


00:45:32.540 --> 00:45:35.500
It's a top hat with a five inch butterfly.


00:45:35.500 --> 00:45:37.860
- Oh, it's got lots of butterflies.


00:45:37.860 --> 00:45:39.060
And they're all leather,


00:45:39.060 --> 00:45:41.460
and it's custom made from a guy in Oakland.


00:45:41.460 --> 00:45:42.820
So it's my new hat.


00:45:42.820 --> 00:45:44.300
- It's fantastic.


00:45:44.300 --> 00:45:46.200
And it perfectly matches both your shirt


00:45:46.200 --> 00:45:47.740
and your background.


00:45:47.740 --> 00:45:49.260
- Did that on purpose, yeah.


00:45:49.260 --> 00:45:53.760
Or on purpose, or on dolphin, no.


00:45:53.760 --> 00:45:58.020
- Fantastic.


00:45:58.020 --> 00:46:01.380
- Well, thanks Will for joining us today.


00:46:01.380 --> 00:46:02.220
- Yeah, pleasure.


00:46:02.220 --> 00:46:03.040
- Yeah, thanks Will.


00:46:03.040 --> 00:46:03.880
- Thanks Michael.


00:46:03.880 --> 00:46:05.060
- Yeah, you bet.


00:46:05.060 --> 00:46:06.420
We'll talk to you all later.

