
00:00:00.000 --> 00:00:04.880
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.


00:00:04.880 --> 00:00:09.680
This is episode 270, recorded February 9th, 2022.


00:00:09.680 --> 00:00:10.680
I'm Michael Kennedy.


00:00:10.680 --> 00:00:12.080
And I'm Brian Okken.


00:00:12.080 --> 00:00:13.580
And I'm Dean Langsam.


00:00:13.580 --> 00:00:15.880
Dean, so great to have you on the show.


00:00:15.880 --> 00:00:16.380
Thank you.


00:00:16.380 --> 00:00:19.280
So often you help me with that start in the live chat.


00:00:19.280 --> 00:00:25.580
I know you're a big participant in the show, so we pulled you in and now here you are.


00:00:25.580 --> 00:00:26.180
Welcome.


00:00:26.180 --> 00:00:27.380
Thank you.


00:00:27.380 --> 00:00:31.460
I've been a fan actually since episode one. I've been hearing this weekly.


00:00:31.460 --> 00:00:34.260
That goes back years, like five years.


00:00:34.260 --> 00:00:38.660
Yeah, it's about five years. I remember I moved apartments back then and


00:00:38.660 --> 00:00:42.060
I listened to Python. I didn't know Python as well back then.


00:00:42.060 --> 00:00:44.860
And I actually grow with the show. So that's very nice.


00:00:44.860 --> 00:00:45.660
That's fantastic.


00:00:45.660 --> 00:00:48.660
That's incredible. We've heard that from other people and that's just


00:00:48.660 --> 00:00:52.460
like mind-blowing to me. But yeah, it's cool.


00:00:52.460 --> 00:00:56.060
I was taking like intro to data science classes in Coursera


00:00:56.060 --> 00:01:02.140
while listening to the show and now other people call me a senior Python. So that's that was very


00:01:02.140 --> 00:01:09.260
nice. That's fantastic. And it does go fast. Yeah. So awesome. Thank you so much for joining


00:01:09.260 --> 00:01:13.820
us on the show. It's awesome. Before we get into it. I also want to say this episode is brought to


00:01:13.820 --> 00:01:18.620
you by data dog. Check out their awesome stuff at Python by set of them slash data dog. I'll tell


00:01:18.620 --> 00:01:20.940
tell you more about that later.


00:01:20.940 --> 00:01:24.100
Right now, Python, I want to hear about a better


00:01:24.100 --> 00:01:25.780
PyGame loop.


00:01:25.780 --> 00:01:26.940
Brian, tell us about it.


00:01:26.940 --> 00:01:30.060
- Yeah, so this is a article from Glyph,


00:01:30.060 --> 00:01:35.060
and this is, PyGame is a package that's used


00:01:35.060 --> 00:01:37.480
for game programming a lot.


00:01:37.480 --> 00:01:39.780
And it's, I mean, a lot.


00:01:39.780 --> 00:01:42.140
And programming games is definitely,


00:01:42.140 --> 00:01:45.060
I think it's one of the things I tried to do early on


00:01:45.060 --> 00:01:45.900
when I was a developer,


00:01:45.900 --> 00:01:48.140
and I think it's something that I think


00:01:48.140 --> 00:01:50.260
I encourage a lot of new developers


00:01:50.260 --> 00:01:52.660
to try out things like simple games


00:01:52.660 --> 00:01:55.540
because it's fun to learn coding that way.


00:01:55.540 --> 00:02:00.260
And it's a, anyway, it's a big part of learning programming


00:02:00.260 --> 00:02:02.380
and the programming space.


00:02:02.380 --> 00:02:04.780
And with Python, it's pretty easy with Pygame.


00:02:04.780 --> 00:02:07.300
And there's a lot of tutorials out there,


00:02:07.300 --> 00:02:09.060
but one of the things that Glyph points out


00:02:09.060 --> 00:02:11.780
is a lot of the tutorials have this


00:02:11.780 --> 00:02:14.340
sort of simple while one loop,


00:02:14.340 --> 00:02:16.620
where you, the main loop of a game,


00:02:16.620 --> 00:02:19.100
where you just spin and wait for events


00:02:19.100 --> 00:02:22.140
and then handle the event or draw things or whatever


00:02:22.140 --> 00:02:23.120
and then go back.


00:02:23.120 --> 00:02:25.940
And draw, you know, keep going.


00:02:25.940 --> 00:02:27.760
And this just happens forever.


00:02:27.760 --> 00:02:30.420
Well, while one loop in programming is a busy loop


00:02:30.420 --> 00:02:34.260
and it's generally something that kind of has some issues.


00:02:34.260 --> 00:02:37.140
So Cliff is pointing out that some of the issues with this


00:02:37.140 --> 00:02:42.140
are that it's a waste power for one,


00:02:42.140 --> 00:02:44.020
your CPU is just spinning all the time


00:02:44.020 --> 00:02:47.580
and you're really not gonna get events that fast.


00:02:47.580 --> 00:02:51.500
And then also there's a thing that I didn't know about


00:02:51.500 --> 00:02:54.700
called screen tearing, which is when you're drawing


00:02:54.700 --> 00:02:56.520
the screen at the same time you're writing


00:02:56.520 --> 00:02:58.660
to the screen buffer.


00:02:58.660 --> 00:03:01.260
- Right, you're not waiting for the Vsync


00:03:01.260 --> 00:03:03.580
60, 100 frames a second, whatever it is, right?


00:03:03.580 --> 00:03:07.140
- Yeah, and that can cause glitches in the game


00:03:07.140 --> 00:03:09.860
and it doesn't look as good.


00:03:09.860 --> 00:03:12.260
Pygame does allow a Vsync option,


00:03:12.260 --> 00:03:15.640
but apparently there's some problem with that.


00:03:15.640 --> 00:03:20.640
So really, the article walks through both of these problems


00:03:20.640 --> 00:03:26.200
and the VSync fix and the problems with that.


00:03:26.200 --> 00:03:29.960
But the end result really is he's got,


00:03:29.960 --> 00:03:32.600
it's actually an interesting discussion


00:03:32.600 --> 00:03:35.000
about really what's going on in PyGame.


00:03:35.000 --> 00:03:38.920
And he talks about that there's really three jobs going on,


00:03:38.920 --> 00:03:40.480
the drawing and the game logic


00:03:40.480 --> 00:03:42.820
and the input handling all at once.


00:03:42.820 --> 00:03:44.480
And so this is a three thing.


00:03:44.480 --> 00:03:47.120
It's probably a good idea to do maybe async stuff


00:03:47.120 --> 00:03:49.640
so things can work together.


00:03:49.640 --> 00:03:54.640
And the solution he came up with is still,


00:03:54.640 --> 00:03:57.180
I mean, it's definitely a larger loop,


00:03:57.180 --> 00:04:01.440
but it's not that big of a loop, more complicated.


00:04:01.440 --> 00:04:05.400
And it's an async version to have some sleeps in there


00:04:05.400 --> 00:04:07.720
with some delays possibly,


00:04:07.720 --> 00:04:10.440
but a better loop for gaming.


00:04:10.440 --> 00:04:12.120
And it's not that complicated.


00:04:12.120 --> 00:04:15.400
And actually, if you're learning gaming while programming,


00:04:15.400 --> 00:04:17.560
hearing about these sorts of issues


00:04:17.560 --> 00:04:20.800
and learning how to solve it,


00:04:20.800 --> 00:04:23.200
it's probably just gonna make you a better developer faster.


00:04:23.200 --> 00:04:26.520
So I think it's a good thing to look at this.


00:04:26.520 --> 00:04:28.560
- Yeah, this looks really interesting.


00:04:28.560 --> 00:04:32.780
This gaming loop stuff, it's so often very much the same


00:04:32.780 --> 00:04:35.920
and there's like these core elements like process input,


00:04:35.920 --> 00:04:38.860
if the key's down or if there's a joystick attached,


00:04:38.860 --> 00:04:43.920
draw the scene, do the hit detection and AI game logic.


00:04:43.920 --> 00:04:45.720
It's almost always the same.


00:04:45.720 --> 00:04:50.040
This looks great as a way to tell me what I should be doing.


00:04:50.040 --> 00:04:53.800
Maybe the next step would be create a class that I just override,


00:04:53.800 --> 00:04:55.760
do the AI logic, draw the screen,


00:04:55.760 --> 00:04:58.920
and just let that not even be something I ever see.


00:04:58.920 --> 00:05:03.360
This is ripe for a little bit of hiding away even this cool stuff.


00:05:03.360 --> 00:05:08.360
That's true. Maybe Pygame can extend a better built-in loop


00:05:08.360 --> 00:05:10.360
to hook into or something.


00:05:10.360 --> 00:05:11.360
Yeah.


00:05:11.360 --> 00:05:16.560
I always think about... I'm not actually used to a lot of gaming on Python,


00:05:16.560 --> 00:05:21.560
but I always think about browsers, which are also kind of a loop that runs forever


00:05:21.560 --> 00:05:23.860
and renders stuff on your screen.


00:05:23.860 --> 00:05:26.660
And I think, well, the front-end guys got it so easy.


00:05:26.660 --> 00:05:30.560
They just write the code and the browser does it for them.


00:05:30.560 --> 00:05:38.400
And I'm not sure if it works exactly the same, but maybe if someone manages to implement something that's like,


00:05:38.400 --> 00:05:48.120
just write your game and put it in this thing, maybe this could attract more people into writing small games in Python.


00:05:48.120 --> 00:05:56.680
Yeah, absolutely. And my thought is if you just sort of abstract that away, it's just 2D stuff, right, which it's pretty easy to get into.


00:05:56.680 --> 00:06:01.840
I just listened to or watched a Netflix series called High Score,


00:06:01.840 --> 00:06:08.360
which is the history of video games going way back to the Atari 2600 and Asteroid and whatnot.


00:06:08.360 --> 00:06:13.040
There's this woman in here talks about how she got so inspired about just text-based games.


00:06:13.040 --> 00:06:14.680
If you're learning to program,


00:06:14.680 --> 00:06:18.720
I definitely think games are a fun way and often I think people


00:06:18.720 --> 00:06:20.680
might perceive that as like, "Well,


00:06:20.680 --> 00:06:23.160
I've got to write Angry Birds or something."


00:06:23.160 --> 00:06:24.880
Which is fine, you can write that and that's super fun,


00:06:24.880 --> 00:06:28.480
but you can do a lot of stuff with just sort of text-based


00:06:28.480 --> 00:06:32.320
little fun story adventure type stuff as well.


00:06:32.320 --> 00:06:35.680
I gotta check out that Netflix series. That sounds great.


00:06:35.680 --> 00:06:36.480
Yeah.


00:06:36.480 --> 00:06:39.360
I was just helping a friend writing this small game


00:06:39.360 --> 00:06:42.560
and he's written this with one thread and everything


00:06:42.560 --> 00:06:44.560
for this school project.


00:06:44.560 --> 00:06:48.080
And then he told me, "Well, but how do I show a score


00:06:48.080 --> 00:06:50.320
that updates with the game?"


00:06:50.320 --> 00:06:52.640
And then I thought, "No, for that you'll need


00:06:52.640 --> 00:06:58.000
multiple threads, a Pygame loop, maybe and stuff like that. So if that could have been easier and


00:06:58.000 --> 00:07:01.040
on him while learning Python, this could have been awesome.


00:07:01.040 --> 00:07:08.320
Yeah, absolutely. There's a lot of nice comments out in the live stream. Anthony says, I teach


00:07:08.320 --> 00:07:13.840
Pygame in my code club after school class. Smart kids, Pygame is great. So is Arcade,


00:07:13.840 --> 00:07:17.680
which is an alternative and OpenGL based alternative to Pygame. That's very cool.


00:07:18.240 --> 00:07:21.740
I do think having something visual for people when they're learning,


00:07:21.740 --> 00:07:25.340
it just, it reinforces things so much, right?


00:07:25.340 --> 00:07:29.000
Like writing that API back in the Toxin database is great when


00:07:29.000 --> 00:07:32.440
you see the next three steps down the line, how it's going to enable something.


00:07:32.440 --> 00:07:35.840
But when you're getting started, you need quick feedback.


00:07:35.840 --> 00:07:36.740
Absolutely.


00:07:36.740 --> 00:07:37.940
All right.


00:07:37.940 --> 00:07:40.640
Well, let's talk about something else that's awesome here.


00:07:40.640 --> 00:07:42.340
I want to talk about SQLAlchemy.


00:07:42.340 --> 00:07:47.040
SQLAlchemy has been getting a lot of attention lately and that's super cool.


00:07:47.040 --> 00:07:50.240
Mike Bayer released SQLAlchemy 2,


00:07:50.240 --> 00:07:53.480
which was the first async API version.


00:07:53.480 --> 00:07:55.540
So now you can use async and await with SQLAlchemy,


00:07:55.540 --> 00:07:57.760
which opens up lots of possibilities.


00:07:57.760 --> 00:08:00.800
Sebastian Ramirez released SQLModel,


00:08:00.800 --> 00:08:03.960
which is like a marriage of Pydantic and SQLAlchemy,


00:08:03.960 --> 00:08:05.720
which is also super neat.


00:08:05.720 --> 00:08:07.920
But there are many other things that you can do


00:08:07.920 --> 00:08:10.060
with SQLAlchemy that are really handy.


00:08:10.060 --> 00:08:12.920
So as all the awesome lists go,


00:08:12.920 --> 00:08:16.960
here's one for a curated list of SQLAlchemy.


00:08:16.960 --> 00:08:19.680
Now, first, just a word of warning.


00:08:19.680 --> 00:08:21.200
From what I can tell,


00:08:21.200 --> 00:08:23.800
including the PR that I added yesterday,


00:08:23.800 --> 00:08:26.040
all the way back to the one in June, 2020,


00:08:26.040 --> 00:08:29.600
it doesn't seem to be getting a whole lot of love,


00:08:29.600 --> 00:08:31.360
which is unfortunate.


00:08:31.360 --> 00:08:34.040
So it seems like it might be sort of stalled out,


00:08:34.040 --> 00:08:36.080
but that said, it's still a really good list of things.


00:08:36.080 --> 00:08:39.200
So I'll pull out a couple that I think are nice here.


00:08:39.200 --> 00:08:40.940
Which ones did I want to highlight?


00:08:40.940 --> 00:08:43.580
The first one is called Continuum,


00:08:43.580 --> 00:08:46.280
SQLAlchemy Continuum, and this is versioning.


00:08:46.280 --> 00:08:49.800
So imagine you would like to have a history


00:08:49.800 --> 00:08:52.320
or a record of changes to your database.


00:08:52.320 --> 00:08:54.360
Like maybe this is some sort of financial thing.


00:08:54.360 --> 00:08:57.280
And if you see changes, you want to be able to say,


00:08:57.280 --> 00:08:59.920
this person made this change on this date


00:08:59.920 --> 00:09:02.520
when they said, you know, update,


00:09:02.520 --> 00:09:05.000
get the record, make a change,


00:09:05.000 --> 00:09:07.840
and call commit on the SQLAlchemy session.


00:09:07.840 --> 00:09:10.480
So what this does is it will create versions


00:09:10.480 --> 00:09:12.360
of inserts, updates, and deletes.


00:09:12.360 --> 00:09:16.840
It won't store those if there's not actually a change.


00:09:16.840 --> 00:09:18.420
It supports Olympic migrations,


00:09:18.420 --> 00:09:21.520
you can revert data objects and so on.


00:09:21.520 --> 00:09:23.920
So if you want that, SQLAlchemy Continuum,


00:09:23.920 --> 00:09:27.120
it's just like one of the many, many, many things in here,


00:09:27.120 --> 00:09:28.320
which is pretty awesome.


00:09:28.320 --> 00:09:31.040
Another one I wanted to highlight is UTC.


00:09:31.040 --> 00:09:34.240
So one of the challenges that people often run into


00:09:34.240 --> 00:09:36.960
is when you're storing stuff in the database,


00:09:36.960 --> 00:09:39.240
a date in particular, what time is that?


00:09:39.240 --> 00:09:41.640
Is that the time of the user


00:09:41.640 --> 00:09:43.160
who might be in a different time zone


00:09:43.160 --> 00:09:45.920
than the API endpoint that it was running at, right?


00:09:45.920 --> 00:09:47.920
So it might be nice to be able to store


00:09:47.920 --> 00:09:51.260
zone, like time zone aware things


00:09:51.260 --> 00:09:54.000
and store them as UTC values.


00:09:54.000 --> 00:09:55.580
So they're always the same.


00:09:55.580 --> 00:09:57.840
And then you can convert them back to like the time zone,


00:09:57.840 --> 00:09:58.920
which is pretty cool.


00:09:58.920 --> 00:10:01.660
Another one is a SQLAlchemy utils is pretty cool.


00:10:01.660 --> 00:10:04.120
So it's got things like a choice type,


00:10:04.120 --> 00:10:06.280
which I'm guessing is basically a new,


00:10:06.280 --> 00:10:10.400
but country, JSON, URL, UUID,


00:10:10.400 --> 00:10:13.740
all of these different data types, data ranges,


00:10:13.740 --> 00:10:17.480
all kinds of stuff, your RMHelpers, utility classes,


00:10:17.480 --> 00:10:19.300
and different things like that.


00:10:19.300 --> 00:10:21.760
So that's kind of a grab bag of them.


00:10:21.760 --> 00:10:25.120
Let's see, one also is called File Depot.


00:10:25.120 --> 00:10:27.740
There's cool stuff for processing images.


00:10:27.740 --> 00:10:29.880
You've got File Depot, which is a framework


00:10:29.880 --> 00:10:33.320
for easily storing and serving files out of your database


00:10:33.320 --> 00:10:35.760
on the web, as well as SQLAlchemy Image Attach,


00:10:35.760 --> 00:10:39.040
which is specifically about storing images in your database,


00:10:39.040 --> 00:10:41.960
which by the way, we do right in on Python Bytes.


00:10:41.960 --> 00:10:42.800
- Cool.


00:10:42.800 --> 00:10:45.440
- You know, if you go to any page, any episode page,


00:10:45.440 --> 00:10:47.960
and you see like that, that watch it on YouTube,


00:10:47.960 --> 00:10:48.800
that little thumbnail,


00:10:48.800 --> 00:10:50.520
we go get that dynamically from YouTube


00:10:50.520 --> 00:10:53.680
and then serve it up so we don't have to depend on YouTube.


00:10:53.680 --> 00:10:55.640
So anyway, that's pretty cool.


00:10:55.640 --> 00:10:58.520
Let's see, maybe two more.


00:10:58.520 --> 00:11:01.000
There's searchable.


00:11:01.000 --> 00:11:04.840
So if you wanna add full text search to your model,


00:11:04.840 --> 00:11:06.580
you can add, use this,


00:11:06.580 --> 00:11:08.280
and then only supports Postgres


00:11:08.280 --> 00:11:11.640
'cause I'm sure it depends upon some core element there,


00:11:11.640 --> 00:11:14.600
but you can also do another one from iSQL as well,


00:11:14.600 --> 00:11:15.440
which is pretty cool.


00:11:15.440 --> 00:11:19.040
And then the last one is schema display,


00:11:19.040 --> 00:11:23.160
which generates basically graphs of your models


00:11:23.160 --> 00:11:25.080
and how they relate to each other, stuff like that,


00:11:25.080 --> 00:11:25.920
which is kind of neat.


00:11:25.920 --> 00:11:26.760
- Nice.


00:11:26.760 --> 00:11:27.680
- What do y'all think?


00:11:27.680 --> 00:11:28.520
Cool stuff, right?


00:11:28.520 --> 00:11:29.580
- Yeah, very cool.


00:11:29.580 --> 00:11:31.400
- Yeah.


00:11:31.400 --> 00:11:35.160
So if you're really bought into SQLAlchemy,


00:11:35.160 --> 00:11:37.320
you owe it to yourself to just flip through this list


00:11:37.320 --> 00:11:39.720
to just go like, wait, it can do that?


00:11:39.720 --> 00:11:41.600
I had no idea that it could do that, right?


00:11:41.600 --> 00:11:43.740
And just sort of see what are the other things


00:11:43.740 --> 00:11:45.280
that people built on top of here


00:11:45.280 --> 00:11:48.240
that I think would be super, super helpful.


00:11:48.240 --> 00:11:53.240
And by the way, my PR was really to say,


00:11:53.240 --> 00:11:56.040
there's a layer called thin abstractions.


00:11:56.040 --> 00:11:58.960
And it says, you know, under the thin abstractions,


00:11:58.960 --> 00:12:01.400
we really should have us some SQL model


00:12:01.400 --> 00:12:03.340
because that thing is super popular


00:12:03.340 --> 00:12:04.860
straight out of the gate, right?


00:12:04.860 --> 00:12:06.400
So people should check this out.


00:12:06.400 --> 00:12:12.240
already got almost 7000 stars and it's what a month old or something. That's crazy. Yeah.


00:12:12.240 --> 00:12:21.200
Maybe maybe six weeks but really really new. Yeah. And but the author I mean. Yeah. Exactly.


00:12:21.200 --> 00:12:26.320
I know. Brandon on the audience says there should be a meta awesome list like an awesome


00:12:26.320 --> 00:12:35.440
list of awesome lists. I'm sure there is. There is. I'm sure. And yeah quite quite fun.


00:12:35.440 --> 00:12:37.880
I definitely recommend people check that out.


00:12:37.880 --> 00:12:40.200
All right, Dean, that brings us to your first item.


00:12:40.200 --> 00:12:41.080
Tell us about it.


00:12:41.080 --> 00:12:44.280
- Yeah, so at work, I needed to write something


00:12:44.280 --> 00:12:45.680
that required threading,


00:12:45.680 --> 00:12:49.240
and I was very afraid of threading at the beginning.


00:12:49.240 --> 00:12:51.920
Basically what we needed to do, we have some mechanism.


00:12:51.920 --> 00:12:53.120
I'm a data scientist,


00:12:53.120 --> 00:12:56.500
and we need to take many queries at once


00:12:56.500 --> 00:12:59.620
and get them as pandas data frames and save them to disk,


00:12:59.620 --> 00:13:02.620
and later take all of them and work with them.


00:13:02.620 --> 00:13:05.400
And instead of writing, like sending them sequentially,


00:13:05.400 --> 00:13:08.300
I wanted to send a bunch of them together.


00:13:08.300 --> 00:13:12.200
And the bonus thing I found is that when you release them to a threading,


00:13:12.200 --> 00:13:15.900
if you don't lock the threads or you don't wait for the threads,


00:13:15.900 --> 00:13:18.400
you can actually still work with the Jupyter notebook


00:13:18.400 --> 00:13:20.260
while waiting for the queries.


00:13:20.260 --> 00:13:21.960
So that was my main reasoning.


00:13:21.960 --> 00:13:25.400
And eventually, after I've written most of the code,


00:13:25.400 --> 00:13:27.800
I got this blog post called


00:13:27.800 --> 00:13:30.500
"The Threadpool Executor in Python, the Complete Guide."


00:13:30.500 --> 00:13:33.100
So this is basically Jason Brownlee.


00:13:33.160 --> 00:13:36.360
He's also the guy from Machine Learning Mastery,


00:13:36.360 --> 00:13:38.360
so I'm very familiar with him.


00:13:38.360 --> 00:13:42.260
It's a very long blog post,


00:13:42.260 --> 00:13:46.720
so you could read it as an e-book or just access the stuff you need,


00:13:46.720 --> 00:13:50.000
because it's a two-hour read, maybe.


00:13:50.000 --> 00:13:53.700
And he explains everything from the beginning.


00:13:53.700 --> 00:13:57.500
He explains what are Python threads, how to work with them.


00:13:57.500 --> 00:14:00.260
Then he introduces the ThreadPool executor,


00:14:00.260 --> 00:14:03.120
which is a more convenient way to use threads.


00:14:03.120 --> 00:14:06.160
He explains about the life cycle of theâ€¦


00:14:06.160 --> 00:14:11.280
What does it do? How to do it then with a context manager and stuff like that.


00:14:11.280 --> 00:14:15.120
And eventually, what he talks about that other people do not,


00:14:15.120 --> 00:14:18.800
when you search for a threading tutorial,


00:14:18.800 --> 00:14:22.880
is actually about the complete life cycle and then the usage patterns.


00:14:22.880 --> 00:14:26.720
And then he explains about I/O bound versus CPU bound and everything.


00:14:26.720 --> 00:14:29.840
And he finishes off with the common questions.


00:14:29.920 --> 00:14:33.920
So this is like the link I've saved because I will forget it in a week,


00:14:33.920 --> 00:14:37.720
but the next time I need to, I just know I can come back to this


00:14:37.720 --> 00:14:40.020
and like read the common questions part.


00:14:40.020 --> 00:14:43.120
And yes, there's a question, the question is like,


00:14:43.120 --> 00:14:46.120
- "How do you stop running?" - There's a lot there, yeah.


00:14:46.120 --> 00:14:49.320
- There is a lot there in this article, isn't there? - Yeah, it's a lot.


00:14:49.320 --> 00:14:52.920
But the thing is you can come back later and just take the stuff you need.


00:14:52.920 --> 00:14:56.220
Like I remember, I know I'm working, then I can ask myself,


00:14:56.220 --> 00:14:57.820
"How do you set a chunk size in map?"


00:14:57.820 --> 00:15:01.020
Well, it says there that you don't because that's for the process pool.


00:15:01.020 --> 00:15:03.980
But then I have another question, maybe, "How do you cancel a running test?"


00:15:03.980 --> 00:15:05.260
And the answer is that.


00:15:05.260 --> 00:15:09.660
So I think that's a good thing to have, like,


00:15:09.660 --> 00:15:11.820
to quickly access when you need to.


00:15:11.820 --> 00:15:15.100
And it finishes off with, like, "What's the difference from


00:15:15.100 --> 00:15:20.140
async.io, from threading.thread, from process pool executor?"


00:15:20.140 --> 00:15:24.380
So that is a very helpful guide, very complete.


00:15:24.380 --> 00:15:28.020
And the entire blog actually explains,


00:15:28.020 --> 00:15:32.180
like, it's an entire blog dedicated to the threading pool executor and


00:15:32.180 --> 00:15:33.980
the process pool executor.


00:15:33.980 --> 00:15:37.180
I love that it's covering the


00:15:37.180 --> 00:15:39.180
thread pool and process pools


00:15:39.180 --> 00:15:40.180
because


00:15:40.180 --> 00:15:43.980
it's easy for things to just completely get out of control.


00:15:43.980 --> 00:15:48.060
You know, as you throw more work at it, stuff can completely back up. So if you just say,


00:15:48.060 --> 00:15:52.980
create me a new thread and run that and then another place, create me more threads, and I got a bunch more, oh look, now I have


00:15:52.980 --> 00:15:55.340
a thousand items of process, create a thousand threads.


00:15:55.340 --> 00:15:56.060
- Yep.


00:15:56.060 --> 00:15:58.540
- Each thread takes a lot of context switching


00:15:58.540 --> 00:16:00.820
to switch between and they take a decent amount of memory


00:16:00.820 --> 00:16:02.500
and all sorts of stuff, right?


00:16:02.500 --> 00:16:03.860
Through the thread pool, you can say,


00:16:03.860 --> 00:16:06.180
queue up the work and run 10 at a time.


00:16:06.180 --> 00:16:09.380
Same for processes, which sort of sets an upper bound


00:16:09.380 --> 00:16:12.740
on how much concurrency you can deal with, right?


00:16:12.740 --> 00:16:13.980
- Yep.


00:16:13.980 --> 00:16:15.700
- Yeah, this is cool.


00:16:15.700 --> 00:16:17.540
So you talked about solving some problems


00:16:17.540 --> 00:16:19.100
in Jupyter Notebook using this.


00:16:19.100 --> 00:16:21.300
What in particular were you trying to do?


00:16:21.300 --> 00:16:26.180
So basically, I can send, I know, a thousand queries.


00:16:26.180 --> 00:16:28.500
And once they get, like, we have big data,


00:16:28.500 --> 00:16:32.500
and then I have a query that takes a part of it,


00:16:32.500 --> 00:16:35.940
like, after maybe some group buys and limitations and stuff like that,


00:16:35.940 --> 00:16:38.340
and I want to take the data frame and save it.


00:16:38.340 --> 00:16:41.780
- Right. - And then, once I have the entire data


00:16:41.780 --> 00:16:44.100
from all the queries, I want to join them,


00:16:44.100 --> 00:16:49.380
or maybe do some, I don't know, some processing and then join everything.


00:16:49.380 --> 00:16:57.060
The thing is, after 10 of those came back, I have a sample of my data that I can work with and try to manage


00:16:57.060 --> 00:17:03.860
and then have a code written while the other stuff are still written. I want to have that. I can play with it.


00:17:03.860 --> 00:17:10.720
So if I release the other things to the threads and they work in the background,


00:17:10.720 --> 00:17:13.860
the main thread of the Jupyter notebook is open.


00:17:13.860 --> 00:17:16.320
And you can start working on the same notebook.


00:17:16.380 --> 00:17:20.980
Before then, I used to open a notebook that's querying stuff,


00:17:20.980 --> 00:17:23.480
open a notebook that I'm playing with, and


00:17:23.480 --> 00:17:27.680
see that the file paths are the same,


00:17:27.680 --> 00:17:32.480
so I'm not confused with some other directory of the other versioning of this data.


00:17:32.480 --> 00:17:34.480
And now it just works.


00:17:34.480 --> 00:17:38.280
- Oh, that's really cool. - And you can also add a thread for,


00:17:38.280 --> 00:17:43.680
I know with some visualizations of what's finished, what's error, what's everything.


00:17:43.680 --> 00:17:44.680
Fantastic.


00:17:44.680 --> 00:17:46.560
>> That sounds really good. I'm sure there's a lot of


00:17:46.560 --> 00:17:49.360
concurrency and parallelism in the data back-end.


00:17:49.360 --> 00:17:52.280
It's just how do you access that from Python,


00:17:52.280 --> 00:17:54.280
so how do you issue all those commands?


00:17:54.280 --> 00:17:57.240
Excellent. All right. Let's see.


00:17:57.240 --> 00:18:00.320
Brian, anything you want to add before I talk about Datadog?


00:18:00.320 --> 00:18:04.400
>> No. Some comments like Sam,


00:18:04.400 --> 00:18:06.680
morally concurrent futures is


00:18:06.680 --> 00:18:09.840
a much less painful way to work with them at a higher level.


00:18:09.840 --> 00:18:11.760
So maybe we could get


00:18:11.760 --> 00:18:14.960
an article on concurrent futures on the opposite sometimes.


00:18:14.960 --> 00:18:15.960
Yeah, for sure.


00:18:15.960 --> 00:18:21.160
So that the ThreadPool executor gets you back futures.


00:18:21.160 --> 00:18:25.860
And then part of what's explained in the blog post is how to work with futures


00:18:25.860 --> 00:18:30.860
like as completed or sequentially or like you decide your strategy,


00:18:30.860 --> 00:18:32.660
but you work with the futures.


00:18:32.660 --> 00:18:34.660
Nice. Okay, cool.


00:18:34.660 --> 00:18:35.660
Yeah, nice.


00:18:35.660 --> 00:18:39.260
And of course, requisite shout out to Unsync,


00:18:39.260 --> 00:18:41.980
which is all sorts of awesome for this stuff.


00:18:41.980 --> 00:18:45.180
Unifies the API for direct threads,


00:18:45.180 --> 00:18:49.460
for processes and async I/O.


00:18:49.460 --> 00:18:52.980
But what I want to tell you all about now is Datadog.


00:18:52.980 --> 00:18:54.060
Datadog is really awesome.


00:18:54.060 --> 00:18:55.540
You should really have insight into


00:18:55.540 --> 00:18:58.860
your applications and that's what Datadog brings you.


00:18:58.860 --> 00:19:02.780
So Datadog is real-time monitoring that unifies metrics,


00:19:02.780 --> 00:19:06.020
traces logs into one tightly integrated platform.


00:19:06.020 --> 00:19:11.020
Their APM empowers developers to identify anomalies


00:19:11.020 --> 00:19:13.520
and resolve issues, especially around performance.


00:19:13.520 --> 00:19:16.780
You can begin collecting stack traces,


00:19:16.780 --> 00:19:18.440
visualize them as flame graphs


00:19:18.440 --> 00:19:20.080
and organizing them into profile types


00:19:20.080 --> 00:19:22.780
such as CPU bound, IO bound, and so on.


00:19:22.780 --> 00:19:25.360
And teams can even search specific profiles


00:19:25.360 --> 00:19:27.120
and correlate them to distributed traces


00:19:27.120 --> 00:19:30.780
to find things across different parts of your infrastructure


00:19:30.780 --> 00:19:34.160
and microservices and identify slow or underperforming code


00:19:34.160 --> 00:19:35.700
and then make it faster.


00:19:35.700 --> 00:19:37.980
Plus you can use their APM live search


00:19:37.980 --> 00:19:39.420
and you can search across the full stream


00:19:39.420 --> 00:19:42.100
of all the traces over the last 15 minutes.


00:19:42.100 --> 00:19:47.100
So try Datadog APM for free with a 14 day trial.


00:19:47.100 --> 00:19:49.140
And then Datadog will send you one of these


00:19:49.140 --> 00:19:51.100
very cute doggy t-shirts,


00:19:51.100 --> 00:19:52.940
which who wouldn't want one of those, right?


00:19:52.940 --> 00:19:55.340
So visit pythonbystud.fm/datadog


00:19:55.340 --> 00:19:57.460
or just click the link in your podcast player


00:19:57.460 --> 00:19:58.560
show notes to get started.


00:19:58.560 --> 00:19:59.580
Thanks Datadog.


00:19:59.580 --> 00:20:01.780
And Brian, back to you.


00:20:01.780 --> 00:20:02.620
- Back to me.


00:20:04.700 --> 00:20:10.220
I was a I'm going to apologize whoever tweeted this, but it's somebody who's tweeted this out.


00:20:10.220 --> 00:20:15.220
A link to this article and talking about chaining operators.


00:20:15.220 --> 00:20:21.260
So this is an article by Rodrigo Sarau.


00:20:21.260 --> 00:20:22.260
Pie don'ts.


00:20:22.260 --> 00:20:28.500
Yeah, so so I don't know what the pie don'ts are about.


00:20:28.500 --> 00:20:29.740
Just I don't know.


00:20:29.740 --> 00:20:34.460
Maybe he started blogging about things you shouldn't do in Python, but anyway, this article


00:20:34.460 --> 00:20:38.340
is called chaining comparison operators and I use chaining all the time.


00:20:38.340 --> 00:20:41.940
Mostly I use it for simple things like,


00:20:41.940 --> 00:20:45.780
let me find one, A is less than B equal less than C.


00:20:45.780 --> 00:20:48.120
So ranges like min,


00:20:48.120 --> 00:20:50.440
my X value is between min and max.


00:20:50.440 --> 00:20:51.600
>> Yeah, that's really nice.


00:20:51.600 --> 00:20:53.700
>> Yeah. My hint on that,


00:20:53.700 --> 00:20:55.740
just tip for anybody doing that,


00:20:55.740 --> 00:20:58.820
always do them less than,


00:20:58.820 --> 00:21:02.140
don't do greater than because it's hard to do that.


00:21:02.140 --> 00:21:04.500
Anyway, so keep them like that.


00:21:04.500 --> 00:21:06.500
But this article is talking about other stuff.


00:21:06.500 --> 00:21:09.140
So this is pretty easy to think about,


00:21:09.140 --> 00:21:10.380
like the less than operator.


00:21:10.380 --> 00:21:12.860
So A is less than B, less than C,


00:21:12.860 --> 00:21:16.320
is really the same as A is less than B,


00:21:16.320 --> 00:21:18.340
and B is less than C.


00:21:18.340 --> 00:21:19.580
It is that combination.


00:21:19.580 --> 00:21:21.940
That's what chained operators are.


00:21:21.940 --> 00:21:26.900
And the importance there is it doesn't really work


00:21:26.900 --> 00:21:28.860
for some operations.


00:21:28.860 --> 00:21:31.800
And it gets into like the equal operator.


00:21:31.800 --> 00:21:34.960
So you can do A equals B or equals C,


00:21:34.960 --> 00:21:36.600
which means they're all equal.


00:21:36.600 --> 00:21:37.440
Great.


00:21:37.440 --> 00:21:38.400
What about not equal?


00:21:38.400 --> 00:21:39.800
Does that work the same way?


00:21:39.800 --> 00:21:43.080
And it doesn't, because if you've got like,


00:21:43.080 --> 00:21:46.920
A is not equal to B is not equal to C,


00:21:46.920 --> 00:21:48.760
it doesn't mean they're all different


00:21:48.760 --> 00:21:53.040
because A and C still could be the same and have that pass.


00:21:53.040 --> 00:21:55.120
So this, this article,


00:21:55.120 --> 00:21:57.120
if you're working with chained expressions,


00:21:57.120 --> 00:21:58.640
which I think you should,


00:21:58.640 --> 00:22:01.000
if you're doing complicated things, it's way,


00:22:01.000 --> 00:22:04.200
I like it better than having a bunch of ands in there,


00:22:04.200 --> 00:22:07.380
as long as you can keep it readable.


00:22:07.380 --> 00:22:12.440
But this article talks through some of the gotchas


00:22:12.440 --> 00:22:14.720
and things to watch out for,


00:22:14.720 --> 00:22:17.900
like side effects and non-constants and things like that.


00:22:17.900 --> 00:22:21.280
So, great discussion of chained operators.


00:22:21.280 --> 00:22:22.520
- I hadn't even thought of doing this,


00:22:22.520 --> 00:22:24.440
not equal to, this seems wrong.


00:22:24.440 --> 00:22:25.280
(laughing)


00:22:25.280 --> 00:22:26.120
It just looks wrong.


00:22:27.480 --> 00:22:31.560
>> Yeah, but don't do chain not equal.


00:22:31.560 --> 00:22:34.920
That's just, even if that's what you meant,


00:22:34.920 --> 00:22:37.960
that A is not equal to B and B is not equal to C,


00:22:37.960 --> 00:22:39.740
but it's okay for A and C to be equal.


00:22:39.740 --> 00:22:42.840
That would be a terrible expression because it's confusing. So don't do that.


00:22:42.840 --> 00:22:43.360
>> It is.


00:22:43.360 --> 00:22:43.920
>> Yeah.


00:22:43.920 --> 00:22:47.920
>> My favorite one of these chainings like X,


00:22:47.920 --> 00:22:50.800
seven less than X less than 10,


00:22:50.800 --> 00:22:52.200
something like that, that's nice.


00:22:52.200 --> 00:22:55.360
My favorite is converting X,


00:22:55.360 --> 00:22:59.360
if x is not none else y to just x or y.


00:22:59.360 --> 00:23:01.860
Boom. That's so clean and so nice.


00:23:01.860 --> 00:23:05.260
And coming from a C++ background and C#,


00:23:05.260 --> 00:23:07.260
I never thought that was possible.


00:23:07.260 --> 00:23:08.160
And that's great.


00:23:08.160 --> 00:23:09.260
Yeah.


00:23:09.260 --> 00:23:10.660
Dean, what do you think about this?


00:23:10.660 --> 00:23:12.260
I love it.


00:23:12.260 --> 00:23:13.560
I use it a lot.


00:23:13.560 --> 00:23:15.260
It didn't always work.


00:23:15.260 --> 00:23:18.360
I think it's still not working with Pandas data frames


00:23:18.360 --> 00:23:20.660
or Pandas series and arrays.


00:23:20.660 --> 00:23:24.660
And I do wait for this to finally work.


00:23:24.660 --> 00:23:28.620
Arrays, when you do an array, like in NumPy or Pandas,


00:23:28.620 --> 00:23:31.200
when you do an array that's less than some number,


00:23:31.200 --> 00:23:35.660
it returns a new array, like a Boolean array, which is true and false.


00:23:35.660 --> 00:23:38.820
And last time I checked, a few months ago,


00:23:38.820 --> 00:23:40.560
but the last time I checked, it didn't work.


00:23:40.560 --> 00:23:45.200
I couldn't do one is less than the series, is less than two,


00:23:45.200 --> 00:23:46.860
and get the Boolean array.


00:23:46.920 --> 00:23:50.920
So I'm waiting for this, but I love the concept a lot.


00:23:50.920 --> 00:23:51.920
Okay, that's good.


00:23:51.920 --> 00:23:54.920
Yeah, I hadn't really considered the integration into pandas.


00:23:54.920 --> 00:23:55.920
Yeah, but of course.


00:23:55.920 --> 00:23:59.920
I'm not sure how would you implement that with the regular data model of like


00:23:59.920 --> 00:24:03.920
dunder dunder EQ or is this something else?


00:24:03.920 --> 00:24:06.920
LTE, yeah, possibly. I'm not sure either.


00:24:06.920 --> 00:24:11.920
Yeah, there's probably some magic method and it might just expand out to less than


00:24:11.920 --> 00:24:14.920
and then and, you know, like the two tests basically.


00:24:14.920 --> 00:24:15.920
Probably does.


00:24:15.920 --> 00:24:16.760
- Cool, cool.


00:24:16.760 --> 00:24:17.580
- We could ask,


00:24:17.580 --> 00:24:21.620
we should ask Brett Cannon to do a deep dive


00:24:21.620 --> 00:24:23.700
into what trained off-sitters.


00:24:23.700 --> 00:24:25.640
- He's pulling apart all the different parts


00:24:25.640 --> 00:24:26.820
of Python syntax, right?


00:24:26.820 --> 00:24:27.660
- Yeah.


00:24:27.660 --> 00:24:30.360
- All right, I wanna give a quick shout out to Rich


00:24:30.360 --> 00:24:34.640
because it's one of our episodes, so we talk about Rich.


00:24:34.640 --> 00:24:36.160
I was gonna talk about Anthony Shaw,


00:24:36.160 --> 00:24:37.480
but I didn't have enough information,


00:24:37.480 --> 00:24:39.320
so I mean, he's the other person


00:24:39.320 --> 00:24:41.280
who needs a shout out in every show.


00:24:41.280 --> 00:24:43.120
So I wanna talk about this article,


00:24:43.120 --> 00:24:48.120
highlighting some tools by Martin Hines.


00:24:48.120 --> 00:24:49.560
Yeah, Martin Hines.


00:24:49.560 --> 00:24:50.820
Well, creating beautiful tracebacks


00:24:50.820 --> 00:24:53.420
with Python's exception hooks.


00:24:53.420 --> 00:24:55.720
So two things that I wanna point out here.


00:24:55.720 --> 00:24:58.900
One, Python has an exception hook mechanism,


00:24:58.900 --> 00:24:59.720
which is pretty cool.


00:24:59.720 --> 00:25:01.820
So what you can do is you can create a function


00:25:01.820 --> 00:25:06.540
that has this signature of exception type,


00:25:06.540 --> 00:25:08.860
the actual exception and the traceback.


00:25:08.860 --> 00:25:10.140
So three arguments.


00:25:10.140 --> 00:25:11.620
And if you have a function like that,


00:25:11.620 --> 00:25:15.180
you can just go to the sys and say sys.except hook


00:25:15.180 --> 00:25:17.700
equals that function, not calling it, of course,


00:25:17.700 --> 00:25:20.000
just passing the function as the value.


00:25:20.000 --> 00:25:21.500
And then whenever there's an exception,


00:25:21.500 --> 00:25:22.700
this will be called by Python.


00:25:22.700 --> 00:25:23.980
That's pretty cool, right?


00:25:23.980 --> 00:25:24.820
- Yeah.


00:25:24.820 --> 00:25:26.300
- So depending on what you wanna do,


00:25:26.300 --> 00:25:29.220
like you could say, well, we're gonna store all the errors.


00:25:29.220 --> 00:25:31.160
Like let's imagine here's a scenario


00:25:31.160 --> 00:25:33.160
where you might make use of this.


00:25:33.160 --> 00:25:36.060
I'm gonna create an app and I'm gonna send it out.


00:25:36.060 --> 00:25:38.120
I'm gonna use py2app or py2xe,


00:25:38.120 --> 00:25:41.180
or just let people install it somehow.


00:25:41.180 --> 00:25:42.700
And then when it runs, I want it,


00:25:42.700 --> 00:25:43.780
it's gonna run on their computers,


00:25:43.780 --> 00:25:45.580
but I want to gather up all the exceptions


00:25:45.580 --> 00:25:48.220
of all the users across the company


00:25:48.220 --> 00:25:50.160
or the research team or whatever.


00:25:50.160 --> 00:25:52.060
You could have this, submit this error


00:25:52.060 --> 00:25:53.700
along with other details right back


00:25:53.700 --> 00:25:56.140
to a database over an API, right?


00:25:56.140 --> 00:25:57.500
And then you could do like analytics,


00:25:57.500 --> 00:25:59.820
like well here's the most common error and so on.


00:25:59.820 --> 00:26:02.020
Of course you could use Sentry or something like that,


00:26:02.020 --> 00:26:03.540
but maybe you're trying to gather


00:26:03.540 --> 00:26:05.740
some specific information that's different, right?


00:26:05.740 --> 00:26:07.220
So that's one of the types of things


00:26:07.220 --> 00:26:08.060
you could do with this.


00:26:08.060 --> 00:26:10.340
- So I got a question before I go on.


00:26:10.340 --> 00:26:11.180
- Yeah.


00:26:11.180 --> 00:26:13.780
- So this doesn't catch the exception,


00:26:13.780 --> 00:26:16.740
it just, it doesn't interrupt the flow,


00:26:16.740 --> 00:26:19.480
it just gets called when it happens?


00:26:19.480 --> 00:26:22.900
- It doesn't catch the exception,


00:26:22.900 --> 00:26:26.960
it lets you basically change what kind of output


00:26:26.960 --> 00:26:27.800
comes from Python.


00:26:27.800 --> 00:26:29.900
So if you just wanted to print out like,


00:26:29.900 --> 00:26:31.520
here's a file where there was an error


00:26:31.520 --> 00:26:32.940
and here's the error message.


00:26:32.940 --> 00:26:33.780
- Okay.


00:26:33.780 --> 00:26:34.600
- Like you could do that, right?


00:26:34.600 --> 00:26:36.540
Or the type and then the message.


00:26:36.540 --> 00:26:39.440
- I'm just noticing the example doesn't rethrow it,


00:26:39.440 --> 00:26:41.980
So you don't have to do that then.


00:26:41.980 --> 00:26:42.920
- No, I don't believe so.


00:26:42.920 --> 00:26:44.160
And I'm not 100% sure.


00:26:44.160 --> 00:26:47.640
I think the app, I think the process still ends


00:26:47.640 --> 00:26:52.080
if it's just a regular running script rather than a web app.


00:26:52.080 --> 00:26:54.480
I think it still ends, but--


00:26:54.480 --> 00:26:55.320
- Anyway, sorry.


00:26:55.320 --> 00:26:56.140
- You get a different kind of output.


00:26:56.140 --> 00:26:58.720
Yeah, yeah, no, you just don't get the standard print output


00:26:58.720 --> 00:26:59.960
that Python gives you, right?


00:26:59.960 --> 00:27:02.280
So you could say, avoid printing the trace back


00:27:02.280 --> 00:27:03.100
if you wanted.


00:27:03.100 --> 00:27:05.160
You could just say this file on this line had this error.


00:27:05.160 --> 00:27:07.120
- Oh, right, okay, nice.


00:27:07.120 --> 00:27:10.200
Okay, so it's easy enough to do.


00:27:10.200 --> 00:27:12.520
Like for example, they have this function


00:27:12.520 --> 00:27:14.000
that they call that cause an error


00:27:14.000 --> 00:27:18.160
and all you see when this crashes is there's a trace back.


00:27:18.160 --> 00:27:21.520
You know, this file, this line and this module,


00:27:21.520 --> 00:27:22.600
here's the error message, right?


00:27:22.600 --> 00:27:25.640
Instead of the huge stack trace that might scare people.


00:27:25.640 --> 00:27:28.440
Okay, so I mean, obviously you can use try and accept


00:27:28.440 --> 00:27:29.680
but this is global, right?


00:27:29.680 --> 00:27:32.000
So even if some library's calling something


00:27:32.000 --> 00:27:33.840
and you're not catching it and like, right,


00:27:33.840 --> 00:27:35.620
it's catching everywhere.


00:27:35.620 --> 00:27:38.500
Okay, so then you could do more work about breaking that apart,


00:27:38.500 --> 00:27:42.260
and they talk about doing that, but the real interesting part is


00:27:42.260 --> 00:27:44.260
if you go and look at some options.


00:27:44.260 --> 00:27:47.420
So there are five, I believe there are five libraries mentioned in here


00:27:47.420 --> 00:27:49.460
that do really cool stuff for solving this.


00:27:49.460 --> 00:27:54.100
The first one is by Will McGugan's Rich Library.


00:27:54.100 --> 00:27:57.820
So you can just go from rich.traceback import install,


00:27:57.820 --> 00:28:00.140
and then say install show_locals is true,


00:28:00.140 --> 00:28:05.180
and then this also basically installs one of those global exception hooks.


00:28:05.180 --> 00:28:08.860
But with the benefit being, when you get the errors,


00:28:08.860 --> 00:28:11.140
what you get is a nice rich output.


00:28:11.140 --> 00:28:12.700
- It's super pretty.


00:28:12.700 --> 00:28:14.340
- It's pretty and it's useful.


00:28:14.340 --> 00:28:15.700
I mean, it's color highlighted


00:28:15.700 --> 00:28:17.700
so you can see where the error happened,


00:28:17.700 --> 00:28:20.260
but it also will print out in a really nice way


00:28:20.260 --> 00:28:23.660
with formatting and highlighting the locals, right?


00:28:23.660 --> 00:28:26.380
So, well, what values were passed to that function


00:28:26.380 --> 00:28:27.200
when it's crashed?


00:28:27.200 --> 00:28:29.540
Well, here's a little table of those and so on.


00:28:29.540 --> 00:28:32.580
So this is really easy to identify


00:28:32.580 --> 00:28:34.700
and at the very bottom, like a nice clear way to like,


00:28:34.700 --> 00:28:35.540
Okay, what happened?


00:28:35.540 --> 00:28:38.660
So you can do this super simple version here.


00:28:38.660 --> 00:28:40.820
There's also some manual ways to make rich print


00:28:40.820 --> 00:28:42.560
this type of stuff.


00:28:42.560 --> 00:28:47.220
Number two is better exceptions, which does similar stuff.


00:28:47.220 --> 00:28:49.540
You can see that it doesn't quite take over


00:28:49.540 --> 00:28:50.940
how the look and feel is so much,


00:28:50.940 --> 00:28:54.300
but it basically colorizes the standard


00:28:54.300 --> 00:28:55.620
look and feel of errors.


00:28:55.620 --> 00:28:58.020
So you can see, you know, which function,


00:28:58.020 --> 00:28:59.100
which error and so on.


00:28:59.100 --> 00:28:59.940
So that's pretty good.


00:28:59.940 --> 00:29:01.580
And there's pretty errors.


00:29:01.580 --> 00:29:02.560
Check out pretty errors.


00:29:02.560 --> 00:29:04.580
This looks pretty good, right?


00:29:04.580 --> 00:29:07.080
It's got a lot of like bold and highlights.


00:29:07.080 --> 00:29:09.340
You can really call out the error messages


00:29:09.340 --> 00:29:12.180
and the functions involved and the modules involved.


00:29:12.180 --> 00:29:15.640
Here's one for you, Dean, the built-in one to IPython.


00:29:15.640 --> 00:29:20.420
It has Ultra TV for Ultra Traceback.


00:29:20.420 --> 00:29:21.480
And this is pretty nice, right?


00:29:21.480 --> 00:29:23.760
Actually, the IPython one's pretty good.


00:29:23.760 --> 00:29:26.160
- Yeah, the Python one is really nice.


00:29:26.160 --> 00:29:28.980
And also I was planning to talk about it in the extras,


00:29:28.980 --> 00:29:31.700
but on IPython 8, which is pretty new,


00:29:31.700 --> 00:29:34.840
They even have this improved with some color coloring


00:29:34.840 --> 00:29:38.380
of exactly where the error happened.


00:29:38.380 --> 00:29:42.380
I think this uses the 310 part or something like that.


00:29:42.380 --> 00:29:43.220
- Oh, awesome.


00:29:43.220 --> 00:29:44.040
Yeah, that's cool.


00:29:44.040 --> 00:29:44.980
We'll hear more about it


00:29:44.980 --> 00:29:47.380
when we talk about IPython 8 as well.


00:29:47.380 --> 00:29:48.220
Cool.


00:29:48.220 --> 00:29:49.660
Yeah, so that's built in,


00:29:49.660 --> 00:29:52.060
kind of if you're already on the data science stack.


00:29:52.060 --> 00:29:54.620
And then finally, stack printer,


00:29:54.620 --> 00:29:56.260
which you can give it a trace back


00:29:56.260 --> 00:29:57.340
and it will print that out.


00:29:57.340 --> 00:29:58.660
So you can sort of do like rich,


00:29:58.660 --> 00:30:00.500
you can say set exception hook


00:30:00.500 --> 00:30:03.380
and give it a theme like dark or whatever.


00:30:03.380 --> 00:30:06.100
And then it does this pretty nice printout as well.


00:30:06.100 --> 00:30:07.340
So these are all great.


00:30:07.340 --> 00:30:11.580
I'm personally liking the rich tracebacks version best,


00:30:11.580 --> 00:30:13.020
but this is really nice.


00:30:13.020 --> 00:30:15.580
Yeah, Connor out there in the audience says,


00:30:15.580 --> 00:30:17.660
wow, using show local SQL tree


00:30:17.660 --> 00:30:19.540
would have saved me hours and hours of time.


00:30:19.540 --> 00:30:20.540
And you and me both.


00:30:20.540 --> 00:30:21.920
- Yeah, I feel the pain.


00:30:21.920 --> 00:30:23.700
- I do too.


00:30:23.700 --> 00:30:24.900
So because a lot of times you're like,


00:30:24.900 --> 00:30:26.900
I know it crashed and it says,


00:30:26.900 --> 00:30:29.340
none type does not have attribute whatever,


00:30:29.340 --> 00:30:34.380
but like, why is it none? I need to go back three levels, right? Like, yes, so good.


00:30:34.380 --> 00:30:38.460
- And then you find out you just forgot to return from the function.


00:30:38.460 --> 00:30:40.460
- Yes, exactly.


00:30:40.460 --> 00:30:46.780
- I was just debugging a test failure the other day, and pytest has an option to


00:30:46.780 --> 00:30:55.740
throw a local, you can show locals with a crash, or with every failure. And the,


00:30:57.820 --> 00:31:01.060
>> I forgot that the particular thing I was testing had


00:31:01.060 --> 00:31:06.560
like variables that were storing 1,000 element arrays.


00:31:06.560 --> 00:31:08.940
It just went on for.


00:31:08.940 --> 00:31:15.200
>> I believe Rich has a truncate variables,


00:31:15.200 --> 00:31:17.340
where it'll do an ellipsis or something like that.


00:31:17.340 --> 00:31:17.660
>> That's nice.


00:31:17.660 --> 00:31:19.140
>> I think. I mean, yeah,


00:31:19.140 --> 00:31:20.420
I'm not a 100 percent sure because I've


00:31:20.420 --> 00:31:21.580
been looking at all five of these today.


00:31:21.580 --> 00:31:22.980
>> Will's in the chat. We'll have to ask him.


00:31:22.980 --> 00:31:25.220
>> Will's in the chat. You'll have to give us a shout out, Will.


00:31:25.220 --> 00:31:27.300
I think truncate is out there, right?


00:31:27.300 --> 00:31:28.700
I'm not 100% sure.


00:31:28.700 --> 00:31:31.100
- I think of how can I actually,


00:31:31.100 --> 00:31:33.780
so I talk with databases and sometimes the errors


00:31:33.780 --> 00:31:38.780
from the databases are like this big Java trace


00:31:38.780 --> 00:31:44.020
and then you need to like, a lot of go, a lot of apps,


00:31:44.020 --> 00:31:47.180
sorry, something, some noise here, sorry.


00:31:47.180 --> 00:31:50.220
You need to get a lot up in the browser


00:31:50.220 --> 00:31:51.820
to actually see the error.


00:31:51.820 --> 00:31:53.900
And if I could just shut it down


00:31:53.900 --> 00:31:55.940
and just give me the Python stuff.


00:31:57.020 --> 00:32:00.900
- Yeah, I don't know what setting you set for that,


00:32:00.900 --> 00:32:02.160
but certainly with this mechanism,


00:32:02.160 --> 00:32:05.420
you could set it up so that if the word Java appears,


00:32:05.420 --> 00:32:06.260
you just stop.


00:32:06.260 --> 00:32:07.080
(laughing)


00:32:07.080 --> 00:32:09.020
You just stop going back.


00:32:09.020 --> 00:32:10.820
And Will says, yes, that's right.


00:32:10.820 --> 00:32:12.180
Thank you, Brian, for pulling that up.


00:32:12.180 --> 00:32:13.600
Yeah, you can truncate it


00:32:13.600 --> 00:32:16.020
so the printing won't go completely insane.


00:32:16.020 --> 00:32:17.180
Because it could be gigabytes.


00:32:17.180 --> 00:32:19.320
I mean, it could be out of control, right?


00:32:19.320 --> 00:32:23.560
- Yeah, but even if they have a reasonably large limit,


00:32:23.560 --> 00:32:24.640
sometimes it's just like,


00:32:24.640 --> 00:32:26.960
oh, I forgot that huge array was there,


00:32:26.960 --> 00:32:28.880
and it's hard to see stuff.


00:32:28.880 --> 00:32:30.320
- Yeah, absolutely.


00:32:30.320 --> 00:32:31.280
- Yeah.


00:32:31.280 --> 00:32:33.280
- All right, over to you Dean.


00:32:33.280 --> 00:32:35.680
Speaking of testing, Brian was talking about testing stuff


00:32:35.680 --> 00:32:37.320
and looking at the color and so on.


00:32:37.320 --> 00:32:40.880
- Yeah, so I thought Brian, this would be up your alley.


00:32:40.880 --> 00:32:44.480
So it's called "Ways I Use Testing as a Data Scientist."


00:32:44.480 --> 00:32:47.000
It's by Peter Baumgartner.


00:32:47.000 --> 00:32:51.440
And I'm a data scientist, but I also love testing.


00:32:51.440 --> 00:32:53.700
The thing about testing with data science


00:32:53.700 --> 00:32:55.920
is sometimes it's not that clear


00:32:55.920 --> 00:32:58.320
what you should test for, right?


00:32:58.320 --> 00:33:02.120
Because some things we do are stochastic,


00:33:02.120 --> 00:33:06.080
and then you could not actually test for stuff or stuff like that.


00:33:06.080 --> 00:33:10.860
So this blog talks about the art of testing,


00:33:10.860 --> 00:33:14.760
because sometimes it's not clear what you should test,


00:33:14.760 --> 00:33:19.120
and the more experience you get, you can actually see what's coming your way.


00:33:19.120 --> 00:33:22.320
And it talks about data validation,


00:33:22.380 --> 00:33:27.380
and he is throwing many packages that could help you,


00:33:27.380 --> 00:33:30.180
packages like Pandera and Great Expectations


00:33:30.180 --> 00:33:34.040
that I think we've talked about before in the podcast.


00:33:34.040 --> 00:33:38.120
And also, like, the NumPy has some stuff,


00:33:38.120 --> 00:33:42.720
like isClosed, checks for two numbers that are close to each other,


00:33:42.720 --> 00:33:47.040
or array equal, assert data frame equals in Pandas data frame.


00:33:47.040 --> 00:33:49.120
So he talks a lot about that.


00:33:49.180 --> 00:33:52.480
He also talks about using assert in your code.


00:33:52.480 --> 00:33:56.620
Like, even if you had some ad hoc stuff of analysis,


00:33:56.620 --> 00:33:58.280
use assert within the code.


00:33:58.280 --> 00:34:00.180
Don't think about the tests later.


00:34:00.180 --> 00:34:03.380
Just think, like, where does this thing could hurt me?


00:34:03.380 --> 00:34:05.320
He gives an example.


00:34:05.320 --> 00:34:07.520
Maybe if I'm trying to join two data frames


00:34:07.520 --> 00:34:09.380
and they think they have the same shape,


00:34:09.380 --> 00:34:12.980
I want to check if they have the same IDs,


00:34:12.980 --> 00:34:16.080
so that way I know that the join works correctly.


00:34:16.140 --> 00:34:22.220
So he asserts that the length of the IDs is the same within the two data frames.


00:34:22.220 --> 00:34:25.520
And this is not even like real testing, we would say.


00:34:25.520 --> 00:34:30.380
He doesn't use some testing framework. He just says, "Write it within your code."


00:34:30.380 --> 00:34:37.280
And then continues to Hypothesis, which basically bombards the functions


00:34:37.280 --> 00:34:41.020
with a lot of ways to actually try to fail it.


00:34:41.080 --> 00:34:46.440
It continues with some other packages, and it eventually goes into pytest


00:34:46.440 --> 00:34:55.880
and shows how it would work with pytest and with an approach that I haven't heard of, but it sounds good.


00:34:55.880 --> 00:34:58.280
Arrange, act, assert.


00:34:58.280 --> 00:35:05.000
Arrange the data, then act on the thing you want to check, and then just assert if they are


00:35:05.000 --> 00:35:09.160
equal or almost equal in the thing you want it to check for.


00:35:09.160 --> 00:35:13.420
- Yeah, it's such a easy mistake to make,


00:35:13.420 --> 00:35:15.820
like this number equal, equal that number.


00:35:15.820 --> 00:35:16.660
- Yep.


00:35:16.660 --> 00:35:19.860
- And it's, but when you're doing science or data science.


00:35:19.860 --> 00:35:21.140
- I'm glad he talks about structure


00:35:21.140 --> 00:35:23.460
because a lot of people that get into testing


00:35:23.460 --> 00:35:26.900
get these giant tests that do a little work,


00:35:26.900 --> 00:35:29.180
test something, do a little more work, test something.


00:35:29.180 --> 00:35:30.980
And then if it breaks,


00:35:30.980 --> 00:35:33.620
you're not sure where the failure is.


00:35:33.620 --> 00:35:36.700
So this looks, sounds fascinating.


00:35:36.700 --> 00:35:38.660
And actually I'm not sure how I missed it,


00:35:38.660 --> 00:35:42.480
but I really want a way to compare an array for almost equal.


00:35:42.480 --> 00:35:45.760
So I'm gonna have to go read that.


00:35:45.760 --> 00:35:49.960
- Yeah, so NumPy and Pandas both have mechanisms for that.


00:35:49.960 --> 00:35:50.800
It's pretty great.


00:35:50.800 --> 00:35:52.460
- Nice, cool.


00:35:52.460 --> 00:35:54.280
- Yeah, very nice.


00:35:54.280 --> 00:35:55.720
I know this will be helpful to people.


00:35:55.720 --> 00:35:58.920
It's really, I always wonder about testing data science stuff


00:35:58.920 --> 00:36:00.720
and machine learning things and so on,


00:36:00.720 --> 00:36:03.160
where you get small perturbations,


00:36:03.160 --> 00:36:04.360
but they're fine, right?


00:36:04.360 --> 00:36:08.920
it's off by one millionth of some unit,


00:36:08.920 --> 00:36:10.280
but like, that's totally good.


00:36:10.280 --> 00:36:11.680
Those are equal, but it's,


00:36:11.680 --> 00:36:14.520
it takes, I think, an extra level of thinking about it.


00:36:14.520 --> 00:36:16.200
So much people focus on,


00:36:16.200 --> 00:36:17.680
but how do you get rid of your dependencies?


00:36:17.680 --> 00:36:18.960
And how do you make sure that you don't talk


00:36:18.960 --> 00:36:20.480
to the real database when you do this?


00:36:20.480 --> 00:36:21.520
So it's, right.


00:36:21.520 --> 00:36:23.600
And that's one aspect that people focus on,


00:36:23.600 --> 00:36:26.820
but this working with like sciency type stuff


00:36:26.820 --> 00:36:28.360
is its own specialty.


00:36:28.360 --> 00:36:31.080
- Yeah, I think that the entire community is,


00:36:31.080 --> 00:36:32.600
it's a fairly new community,


00:36:32.600 --> 00:36:35.320
although it's not as new as it was.


00:36:35.320 --> 00:36:37.920
And I'm not sure like we're on top


00:36:37.920 --> 00:36:40.200
of how to do tests in machine learning.


00:36:40.200 --> 00:36:43.640
Like many, we have many packages for that.


00:36:43.640 --> 00:36:46.080
We have many theories for that,


00:36:46.080 --> 00:36:48.600
but I'm not sure like that we have


00:36:48.600 --> 00:36:51.880
like actually one solid good way


00:36:51.880 --> 00:36:54.880
and maybe we shouldn't have, but it's a debate.


00:36:54.880 --> 00:36:56.740
- Yeah, for sure.


00:36:56.740 --> 00:36:58.720
- Same with the rest of the software world.


00:36:58.720 --> 00:36:59.680
So welcome.


00:36:59.680 --> 00:37:02.120
(all laughing)


00:37:02.120 --> 00:37:02.960
- Thanks.


00:37:02.960 --> 00:37:04.100
- Yeah, and Sam out in the live stream says,


00:37:04.100 --> 00:37:06.620
"Numpy has an assert array almost equal


00:37:06.620 --> 00:37:08.260
in numpy.testing."


00:37:08.260 --> 00:37:09.100
- Nice.


00:37:09.100 --> 00:37:11.500
- I just learned there's a numpy.testing, that's cool.


00:37:11.500 --> 00:37:12.340
- Yeah.


00:37:12.340 --> 00:37:16.220
- Awesome, all right, Dean, while you have your screen up,


00:37:16.220 --> 00:37:18.260
do you have any extras you wanna talk about?


00:37:18.260 --> 00:37:20.100
I know IPython 8 was a thing.


00:37:20.100 --> 00:37:22.220
- Yeah, so IPython 8 was released


00:37:22.220 --> 00:37:25.580
like last month after three years


00:37:25.580 --> 00:37:27.520
of waiting for a major version.


00:37:27.520 --> 00:37:31.560
It has a lot of new features, but this is the extra part,


00:37:31.560 --> 00:37:35.560
So it won't go over them. Just two and a half things I wanted to mention.


00:37:35.560 --> 00:37:38.960
It says that it's less code, and I love that.


00:37:38.960 --> 00:37:41.920
Once you get better in a programming language,


00:37:41.920 --> 00:37:45.720
you understand that you shouldn't write more code, you should delete code.


00:37:45.720 --> 00:37:48.160
And that's what those guys do.


00:37:48.160 --> 00:37:51.260
And the way they could have done that


00:37:51.260 --> 00:37:56.620
is by hiring a person through the NumFocus Small Development Grants.


00:37:56.620 --> 00:37:57.760
And I think this is important.


00:37:57.820 --> 00:38:02.660
It's actually been talked a lot about after the Log4j stuff.


00:38:02.660 --> 00:38:03.780
It's been talked about like,


00:38:03.780 --> 00:38:06.300
well, those are three guys who worked tirelessly.


00:38:06.300 --> 00:38:08.160
They have their full-time jobs


00:38:08.160 --> 00:38:10.060
and they couldn't fix the Log4j stuff


00:38:10.060 --> 00:38:13.660
maybe as quickly as some other people wanted.


00:38:13.660 --> 00:38:16.100
But then you realize that they got donations


00:38:16.100 --> 00:38:19.200
of like a few hundred dollars within 10 years.


00:38:19.200 --> 00:38:22.740
And then after the Log4j, suddenly they got thousand.


00:38:22.740 --> 00:38:26.460
So this, I think it shows you how the like


00:38:26.460 --> 00:38:28.160
Money could help open source stuff.


00:38:28.160 --> 00:38:33.060
And maybe if you use some package in a company, in some corporate,


00:38:33.060 --> 00:38:36.560
maybe try and think how you can give back money.


00:38:36.560 --> 00:38:41.560
Or even if you give back code, if you free up your developers to actually contribute.


00:38:41.560 --> 00:38:43.760
This is awesome.


00:38:43.760 --> 00:38:49.460
And the half thing just mentioned, because it talks about the tracebacks,


00:38:49.460 --> 00:38:53.560
it shows that you can now see it's colored.


00:38:53.560 --> 00:38:54.860
You can see on the screen.


00:38:54.860 --> 00:38:59.140
It's called the part where the actually the arrow was,


00:38:59.140 --> 00:39:00.360
it's colored now.


00:39:00.360 --> 00:39:04.360
So it's very nice to see like the example shows you,


00:39:04.360 --> 00:39:08.300
you add the function three times,


00:39:08.300 --> 00:39:10.660
but only it fails on just one input of them.


00:39:10.660 --> 00:39:12.760
So it shows you which of the three times


00:39:12.760 --> 00:39:14.060
the function failed.


00:39:14.060 --> 00:39:17.220
- Right, you call it the same thing like foo of zero


00:39:17.220 --> 00:39:19.260
plus foo of one plus foo of two.


00:39:19.260 --> 00:39:22.340
And it's the middle one that failed, not just line seven,


00:39:22.340 --> 00:39:25.180
but the second invocation with the value one


00:39:25.180 --> 00:39:26.580
where it failed, which that's awesome.


00:39:26.580 --> 00:39:27.660
- Yeah, exactly.


00:39:27.660 --> 00:39:30.100
And, well, sorry.


00:39:30.100 --> 00:39:32.100
- I was gonna say, the same thing for indexing


00:39:32.100 --> 00:39:34.980
into, what is that, a data frame or something like that.


00:39:34.980 --> 00:39:37.620
Like, you're chaining together like bracket zero,


00:39:37.620 --> 00:39:40.300
bracket one, bracket zero, it's the second one.


00:39:40.300 --> 00:39:42.420
Trying to get to the one of zero,


00:39:42.420 --> 00:39:43.620
that was the one that failed there.


00:39:43.620 --> 00:39:47.340
That's really, those are hard to come back and find


00:39:47.340 --> 00:39:48.420
if you're not in a debugger.


00:39:48.420 --> 00:39:49.700
Like, well, which one of these failed?


00:39:49.700 --> 00:39:53.500
like great array index out of bounds on line three.


00:39:53.500 --> 00:39:56.540
Well, there's three of those happening, which one?


00:39:56.540 --> 00:39:57.580
- Yeah. - Yeah, that's cool.


00:39:57.580 --> 00:40:01.140
- And another thing is a tweet by Victor Stinner


00:40:01.140 --> 00:40:02.820
is a core dev.


00:40:02.820 --> 00:40:05.980
And he says, I mean, it's now time to deprecate


00:40:05.980 --> 00:40:08.860
the standard lib URL lib module.


00:40:08.860 --> 00:40:13.860
And this is brought a lot of haters and fans.


00:40:13.860 --> 00:40:15.980
And I'm not sure what's my opinion yet.


00:40:15.980 --> 00:40:18.460
I'm not a heavy user of your lib.


00:40:19.460 --> 00:40:22.820
But it opened up a debate, like we know how to do.


00:40:22.820 --> 00:40:26.580
- Yeah, that's really interesting.


00:40:26.580 --> 00:40:28.540
There are certain things in the standard library


00:40:28.540 --> 00:40:29.940
you're like, yeah, yeah, I know what that's there


00:40:29.940 --> 00:40:31.480
and you could use it, but you probably shouldn't use it.


00:40:31.480 --> 00:40:34.140
There's like so many better external choices


00:40:34.140 --> 00:40:36.540
that are so good that it would be kind of silly


00:40:36.540 --> 00:40:37.540
to bite them, right?


00:40:37.540 --> 00:40:39.180
That's sort of the recommendation here.


00:40:39.180 --> 00:40:42.260
- Yeah, but also some people don't like it.


00:40:42.260 --> 00:40:44.940
They have people there that say,


00:40:44.940 --> 00:40:47.740
they hate dependencies and sometimes you can do


00:40:47.740 --> 00:40:51.140
most of the work with the standard lib.


00:40:51.140 --> 00:40:55.340
And some of the tweets said, like, maybe deprecate


00:40:55.340 --> 00:40:57.620
the major parts that requests can do,


00:40:57.620 --> 00:40:59.340
but there are some other parts


00:40:59.340 --> 00:41:01.540
that are actually really needed.


00:41:01.540 --> 00:41:03.240
So maybe deprecate half of it.


00:41:03.240 --> 00:41:07.900
- Yeah, I'm not sure if I'm about deprecating it,


00:41:07.900 --> 00:41:10.620
but, you know, it's one thing to say


00:41:10.620 --> 00:41:12.580
there are better choices and we as a community


00:41:12.580 --> 00:41:15.420
recommend you probably just don't use this,


00:41:15.420 --> 00:41:17.020
but to deprecate it means to people


00:41:17.020 --> 00:41:19.740
who would rather go with a dependence,


00:41:19.740 --> 00:41:21.820
a lower level of dependencies,


00:41:21.820 --> 00:41:22.940
you're giving them warnings


00:41:22.940 --> 00:41:23.860
that they shouldn't be doing this


00:41:23.860 --> 00:41:27.580
when maybe it's unlikely it's gonna actually vanish, right?


00:41:27.580 --> 00:41:29.300
- There's like a fallacy though


00:41:29.300 --> 00:41:30.620
that I think some people have


00:41:30.620 --> 00:41:33.860
that if they don't have dependency


00:41:33.860 --> 00:41:34.740
and it's in the standard,


00:41:34.740 --> 00:41:36.440
they're using something in the standard library,


00:41:36.440 --> 00:41:38.300
it's more solid.


00:41:38.300 --> 00:41:41.060
But I don't know if there's that many people


00:41:41.060 --> 00:41:43.860
working on URL lib right now.


00:41:43.860 --> 00:41:45.540
And some of the other parts


00:41:45.540 --> 00:41:50.040
that maybe people want to stop supporting.


00:41:50.040 --> 00:41:51.540
There's a, that's something very valid.


00:41:51.540 --> 00:41:53.780
Python still is an open source project


00:41:53.780 --> 00:41:56.140
and we can make those decisions.


00:41:56.140 --> 00:41:57.660
- Yeah, Victor actually says


00:41:57.660 --> 00:42:01.060
there are four year old security issues in your relic.


00:42:01.060 --> 00:42:05.100
So maybe it's better to use something outside of it.


00:42:05.100 --> 00:42:06.100
- Yeah.


00:42:06.100 --> 00:42:10.220
- Yeah, people want it to stay, but there's these issues.


00:42:10.220 --> 00:42:11.660
Yeah, I wonder if there's a way to go,


00:42:11.660 --> 00:42:13.940
well, let's look at some of the libraries that are out there


00:42:13.940 --> 00:42:17.460
try to bring them in and just use their core


00:42:17.460 --> 00:42:19.380
to replicate that functionality.


00:42:19.380 --> 00:42:20.860
Not to say, you know, like, you could,


00:42:20.860 --> 00:42:21.740
let's just pick on requests.


00:42:21.740 --> 00:42:23.260
Like, bring a request in, like,


00:42:23.260 --> 00:42:24.900
vendor a little bit of it in


00:42:24.900 --> 00:42:27.460
so it does what URLlib does.


00:42:27.460 --> 00:42:28.300
And just go look, okay,


00:42:28.300 --> 00:42:30.100
this is the latest, greatest that we got


00:42:30.100 --> 00:42:32.580
and everyone's been looking at requests already.


00:42:32.580 --> 00:42:35.060
I don't know, could be interesting.


00:42:35.060 --> 00:42:35.900
Yeah.


00:42:35.900 --> 00:42:37.760
And then Brandon out in the audience points out,


00:42:37.760 --> 00:42:39.340
there are also maybe environments


00:42:39.340 --> 00:42:41.820
where you can't install dependencies for security reasons.


00:42:41.820 --> 00:42:43.640
And so having things like URLlib


00:42:43.640 --> 00:42:46.720
allows you to do more with Python in those situations.


00:42:46.720 --> 00:42:49.520
- But if there's security problems with the URL lib,


00:42:49.520 --> 00:42:50.360
yeah, anyway.


00:42:50.360 --> 00:42:51.180
(Brian laughs)


00:42:51.180 --> 00:42:52.280
- Yeah, just in some of the functions,


00:42:52.280 --> 00:42:55.120
you don't call those, no, I'm just kidding.


00:42:55.120 --> 00:42:57.200
All right, Brian, how about you, extras?


00:42:57.200 --> 00:43:00.640
- Just one extra, I brought this up last week.


00:43:00.640 --> 00:43:02.840
I'm currently not writing a book.


00:43:02.840 --> 00:43:04.040
So-- - Yay!


00:43:04.040 --> 00:43:06.880
- So I want to write more blog posts.


00:43:06.880 --> 00:43:10.440
So one of the things I wanted to make sure that my blog,


00:43:10.440 --> 00:43:13.520
I migrated to pythontest.com


00:43:13.520 --> 00:43:16.320
and now it has a blog setting.


00:43:16.320 --> 00:43:18.880
And I-- - I like it,


00:43:18.880 --> 00:43:19.720
looks pretty too.


00:43:19.720 --> 00:43:21.520
- Instead of just pulling everything over


00:43:21.520 --> 00:43:25.840
from my old WordPress blog, I'm trying to edit it.


00:43:25.840 --> 00:43:29.160
So I'm up through 2012.


00:43:29.160 --> 00:43:32.720
I'm gonna go oldest to newest


00:43:32.720 --> 00:43:35.040
and gradually do things, bring things in.


00:43:35.040 --> 00:43:38.600
So that's one of my side projects I'm working on.


00:43:38.600 --> 00:43:40.400
- Yeah, that's a great side project.


00:43:40.400 --> 00:43:41.340
Nice.


00:43:41.340 --> 00:43:42.180
What's that running on?


00:43:42.180 --> 00:43:45.460
like some static site generator or other hosted thing.


00:43:45.460 --> 00:43:49.460
- It's Hugo hosted by a free Netlify account.


00:43:49.460 --> 00:43:51.540
- Yeah, Netlify's pretty awesome.


00:43:51.540 --> 00:43:52.860
All right, I got a couple things.


00:43:52.860 --> 00:43:54.760
I wanna give a quick shout out to,


00:43:54.760 --> 00:43:58.500
yeah, Brandon has the same question, but we got it.


00:43:58.500 --> 00:44:01.580
All right, first of all, I have two new, my Python shorts,


00:44:01.580 --> 00:44:03.340
two new versions, two videos from there.


00:44:03.340 --> 00:44:04.660
I got beyond the list comprehension,


00:44:04.660 --> 00:44:07.940
so basically set and dictionary comprehensions, fun stuff.


00:44:07.940 --> 00:44:09.160
- Nice picture. - There.


00:44:09.160 --> 00:44:10.000
Thank you.


00:44:10.000 --> 00:44:13.840
and it's like just a screenshot out of an animation.


00:44:13.840 --> 00:44:15.720
And then combining dictionaries,


00:44:15.720 --> 00:44:17.520
the Python 310 way is the title of the article.


00:44:17.520 --> 00:44:19.040
It really should be 3.9,


00:44:19.040 --> 00:44:20.260
but I kind of want to communicate like


00:44:20.260 --> 00:44:21.640
if you're on the latest Python,


00:44:21.640 --> 00:44:23.120
how should you be doing it?


00:44:23.120 --> 00:44:26.140
It came out in 3.9, the features that are actually in there.


00:44:26.140 --> 00:44:28.240
Anyway, the pipe stuff,


00:44:28.240 --> 00:44:30.160
dictionary one, pipe, dictionary two,


00:44:30.160 --> 00:44:32.740
pipe, dictionary three, which is all fun.


00:44:32.740 --> 00:44:34.600
And then I wanted to talk about a feature


00:44:34.600 --> 00:44:35.920
over on pypi.org.


00:44:35.920 --> 00:44:37.040
I don't even know how I found this.


00:44:37.040 --> 00:44:38.320
Probably just like an accident,


00:44:38.320 --> 00:44:39.760
like bump the keyboard or something.


00:44:39.760 --> 00:44:43.600
But if I'm over here and you just want to search for something forward slash.


00:44:43.600 --> 00:44:44.660
Now you can search.


00:44:44.660 --> 00:44:45.280
What?


00:44:45.280 --> 00:44:47.540
So the now I have a beam in the browser.


00:44:47.540 --> 00:44:49.540
Exactly.


00:44:49.540 --> 00:44:53.380
So if you were on pipe, bi.org and you want to search forward slash.


00:44:53.380 --> 00:44:54.080
Yes.


00:44:54.080 --> 00:44:55.620
So that's pretty cool.


00:44:55.620 --> 00:44:56.320
Yep.


00:44:56.320 --> 00:44:56.780
All right.


00:44:56.780 --> 00:44:58.100
That's it for the extras.


00:44:58.100 --> 00:44:59.100
Nice.


00:44:59.100 --> 00:45:01.580
I don't even remember what my joke is, so that's good.


00:45:01.580 --> 00:45:02.560
That'd be fine.


00:45:02.560 --> 00:45:06.060
You're ready?


00:45:06.060 --> 00:45:06.620
Yeah.


00:45:06.620 --> 00:45:07.380
All right.


00:45:07.900 --> 00:45:09.100
Yeah, here we go.


00:45:09.100 --> 00:45:11.100
Oh yeah, this is another one of these sort of like


00:45:11.100 --> 00:45:14.120
frustration type of things, that's great.


00:45:14.120 --> 00:45:17.020
This comes from the Programming Humor,


00:45:17.020 --> 00:45:19.800
Twitter account, you know, twitter.com/programminghumor,


00:45:19.800 --> 00:45:21.720
which is, there's a lot of good stuff in there.


00:45:21.720 --> 00:45:22.960
Some that I really liked,


00:45:22.960 --> 00:45:24.680
I didn't want to necessarily put on the show,


00:45:24.680 --> 00:45:28.200
but this one is developers really frustrated


00:45:28.200 --> 00:45:30.320
that they're sucking in on their lips,


00:45:30.320 --> 00:45:31.160
they're pulling on their cheeks,


00:45:31.160 --> 00:45:32.720
they're going, "Oh, I hate this job.


00:45:32.720 --> 00:45:33.760
"I hate my life.


00:45:33.760 --> 00:45:36.000
"Why is this happening to me?


00:45:36.000 --> 00:45:38.000
Never mind, I misspelled a variable.


00:45:38.000 --> 00:45:40.000
[laughter]


00:45:40.000 --> 00:45:42.000
Good to go.


00:45:42.000 --> 00:45:44.000
Yeah, linting is good.


00:45:44.000 --> 00:45:46.000
Indeed, indeed.


00:45:46.000 --> 00:45:48.000
If you just flip through


00:45:48.000 --> 00:45:50.000
the programming humor one,


00:45:50.000 --> 00:45:52.000
it's pretty good.


00:45:52.000 --> 00:45:54.000
This 8-year-old is learning Python after dealing


00:45:54.000 --> 00:45:56.000
with the syntax bug, she asks,


00:45:56.000 --> 00:45:58.000
"If the computer knows it's missing a semicolon here,


00:45:58.000 --> 00:46:00.000
why won't it add it itself?"


00:46:00.000 --> 00:46:02.000
I don't know. I really don't know.


00:46:02.000 --> 00:46:04.000
Yeah.


00:46:04.000 --> 00:46:07.920
>> Yeah, and so he follows up and says what he meant,


00:46:07.920 --> 00:46:10.200
he meant colon, not semicolon.


00:46:10.200 --> 00:46:11.460
But so many people are like,


00:46:11.460 --> 00:46:14.920
"Semicolon? We're using semicolon for Python."


00:46:14.920 --> 00:46:18.000
>> Exactly. There are uses.


00:46:18.000 --> 00:46:19.800
They're rare though. All right.


00:46:19.800 --> 00:46:22.880
Well, fantastic.


00:46:22.880 --> 00:46:25.560
>> That last one.


00:46:25.560 --> 00:46:27.280
>> See?


00:46:27.280 --> 00:46:28.000
>> Yeah.


00:46:28.000 --> 00:46:29.920
>> It shall not be spoken, but it's good, right?


00:46:29.920 --> 00:46:29.960
>> Yeah.


00:46:29.960 --> 00:46:31.480
>> Okay. There's a lot of good stuff.


00:46:31.480 --> 00:46:34.140
I recommend people go flip through that Twitter account.


00:46:34.140 --> 00:46:35.040
- Nice.


00:46:35.040 --> 00:46:36.640
- Brian, thank you as always.


00:46:36.640 --> 00:46:37.840
It's good to be back with you.


00:46:37.840 --> 00:46:39.240
- It's good to be back.


00:46:39.240 --> 00:46:42.440
- And Dean, thanks for coming on this side of


00:46:42.440 --> 00:46:44.480
the presentation and joining us for the show.


00:46:44.480 --> 00:46:46.440
- Thanks for having me.


00:46:46.440 --> 00:46:48.240
- Thanks for listening to Python Bytes.


00:46:48.240 --> 00:46:51.160
Follow the show on Twitter via @PythonBytes.


00:46:51.160 --> 00:46:54.600
That's Python Bytes as in B-Y-T-E-S.


00:46:54.600 --> 00:46:57.760
Get the full show notes over at PythonBytes.fm.


00:46:57.760 --> 00:46:59.680
If you have a news item we should cover,


00:46:59.680 --> 00:47:03.440
just visit Python by set of them and click Submit in the nav bar. We're always on the


00:47:03.440 --> 00:47:07.720
lookout for sharing something cool. If you want to join us for the live recording, just


00:47:07.720 --> 00:47:12.200
visit the website and click live stream to get notified of when our next episode goes


00:47:12.200 --> 00:47:18.640
live. That's usually happening at noon Pacific on Wednesdays over at YouTube. On behalf of


00:47:18.640 --> 00:47:23.660
myself and Brian Okken. This is Michael Kennedy. Thank you for listening and sharing this podcast


00:47:23.660 --> 00:47:24.960
with your friends and colleagues.

