
00:00:00.000 --> 00:00:04.400
This is Python Bytes, Python headlines and news delivered directly to your earbuds.


00:00:04.400 --> 00:00:09.600
It's episode 9, recorded Tuesday, January 17th, 2016.


00:00:09.600 --> 00:00:11.900
This is one of your co-hosts, Michael Kennedy.


00:00:11.900 --> 00:00:14.200
I'm here with my other co-host, Brian Okken.


00:00:14.200 --> 00:00:15.300
Hey Brian, how's it going, man?


00:00:15.300 --> 00:00:16.900
It's going very good. How are you?


00:00:16.900 --> 00:00:23.000
I'm doing well. I always look forward to our weekly chat about cool stuff going on in the Python ecosystem.


00:00:23.000 --> 00:00:27.500
And I see that you found something quite cool for our first item.


00:00:27.500 --> 00:00:29.200
Actually, it's a series of things.


00:00:29.200 --> 00:00:35.120
The link that we have is to Python asynchronous I/O walkthrough.


00:00:35.120 --> 00:00:36.120
And here's the story.


00:00:36.120 --> 00:00:41.520
So in July, there was an open source book published called 500 Lines or Less.


00:00:41.520 --> 00:00:45.240
The architecture of open source applications is the website.


00:00:45.240 --> 00:00:50.680
But they do various open source free books, which is pretty cool.


00:00:50.680 --> 00:00:59.000
Anyway, the 500 Lines or Less had one chapter in it from Jesse Giro Davis and Guido Van


00:00:59.000 --> 00:01:06.320
Rossum called a web crawler with asyncio coroutines. And it's a pretty cool chapter


00:01:06.320 --> 00:01:11.160
about explaining asynchronous networking, showing how non blocking sockets work and


00:01:11.160 --> 00:01:15.840
how Python three coroutines improve asynchronous network programs.


00:01:15.840 --> 00:01:20.800
Yeah, that's really cool. I think that that book is amazing. There. It's not just this


00:01:20.800 --> 00:01:25.000
particular chapter. There's many chapters there. It's also not just Python, but it has


00:01:25.000 --> 00:01:29.080
that's a heavy, a lot of pieces which are Python.


00:01:29.080 --> 00:01:32.960
And basically it's, can you show me something amazing


00:01:32.960 --> 00:01:35.380
that really, I thought was really hard,


00:01:35.380 --> 00:01:38.400
but can be explained or written in 500 lines or less


00:01:38.400 --> 00:01:40.400
and then discuss the architecture.


00:01:40.400 --> 00:01:43.640
And there's like 20 different projects or something.


00:01:43.640 --> 00:01:45.160
It was very cool.


00:01:45.160 --> 00:01:47.600
- Yeah, and the series is pretty neat.


00:01:47.600 --> 00:01:49.520
So this is 500 lines or less.


00:01:49.520 --> 00:01:53.760
There's previous books that are like about architecture


00:01:53.760 --> 00:01:55.920
and about performance issues,


00:01:55.920 --> 00:01:59.120
and it's a neat thing they're doing.


00:01:59.120 --> 00:02:02.440
But this particular chapter for me,


00:02:02.440 --> 00:02:05.480
since I'm kind of new to the asynchronous world,


00:02:05.480 --> 00:02:08.160
it still was a little bit heavy to get into.


00:02:08.160 --> 00:02:12.080
And so Philip Guo, who I think he interviewed you once.


00:02:12.080 --> 00:02:14.080
- Yeah, he's been on my show,


00:02:14.080 --> 00:02:17.360
on Talk Python to Me, on episode 22.


00:02:17.360 --> 00:02:19.820
And I also was on his show.


00:02:19.820 --> 00:02:21.320
He started a podcast recently.


00:02:21.320 --> 00:02:23.760
It's got like 25 episodes or something.


00:02:23.760 --> 00:02:25.720
And yeah, I'll be sure to link to that.


00:02:25.720 --> 00:02:27.240
That's a really cool one as well.


00:02:27.240 --> 00:02:29.840
He interviews people just kind of generally


00:02:29.840 --> 00:02:31.120
in the programming space.


00:02:31.120 --> 00:02:33.080
- So what he did was it's pretty cool.


00:02:33.080 --> 00:02:36.360
He just is walking through this article


00:02:36.360 --> 00:02:38.680
and talking about it and then also,


00:02:38.680 --> 00:02:40.480
and showing it on video,


00:02:40.480 --> 00:02:43.720
and then also going through and doing some code examples.


00:02:43.720 --> 00:02:46.720
And he split, it's about 90 minutes total


00:02:46.720 --> 00:02:49.280
to get through this, but he split it up into eight parts.


00:02:49.280 --> 00:02:53.080
So each one is really not that hard to get through.


00:02:53.080 --> 00:02:57.380
And it's a pretty cool idea and I really appreciate it.


00:02:57.380 --> 00:02:59.680
I think it's a good way to learn,


00:02:59.680 --> 00:03:02.880
to see somebody doing it, to hear them,


00:03:02.880 --> 00:03:04.960
to use all your senses.


00:03:04.960 --> 00:03:05.800
- Really like that.


00:03:05.800 --> 00:03:07.200
I think this is great work.


00:03:07.200 --> 00:03:08.140
Nice work, Philip.


00:03:08.140 --> 00:03:08.980
Way to go.


00:03:08.980 --> 00:03:10.360
He's done stuff like that before.


00:03:10.360 --> 00:03:11.680
Like I had him on,


00:03:11.680 --> 00:03:14.240
the reason I had him on episode 22 of Talk Python


00:03:14.240 --> 00:03:16.600
was he did this thing called


00:03:16.600 --> 00:03:22.920
CPython a 10 hour code walk, which was like an exploration through the CPython internals,


00:03:22.920 --> 00:03:25.200
which I found really enlightening.


00:03:25.200 --> 00:03:30.080
And we actually I talked to Jesse about his article on episode 69 as well.


00:03:30.080 --> 00:03:34.440
When we talked about writing as a developer, he's got some really cool thinking around


00:03:34.440 --> 00:03:38.120
like design patterns on technical writing and stuff.


00:03:38.120 --> 00:03:40.080
So this is this is really cool.


00:03:40.080 --> 00:03:45.360
I think I think seeing a problem unfold before your eyes in code is much different than seeing


00:03:45.360 --> 00:03:50.360
the finished product discussed. And I find I learn really well that way. So I'm happy


00:03:50.360 --> 00:03:53.720
this is here. I haven't had a chance to go through it, but I'm looking forward to it.


00:03:53.720 --> 00:03:58.680
And also both Jesse and Philip are doing some cool things to help the entire community,


00:03:58.680 --> 00:04:03.080
which I appreciate. Jesse's been supportive of a lot of people, including me.


00:04:03.080 --> 00:04:06.720
Yeah, absolutely. Jesse's doing great stuff. Do you want to think about the future of Python


00:04:06.720 --> 00:04:08.440
a little bit?


00:04:08.440 --> 00:04:12.760
I thought I was thinking about the future of Python with switching to 3.6 recently.


00:04:12.760 --> 00:04:16.000
But what do you think the future has in store?


00:04:16.000 --> 00:04:21.520
We were living like right on the edge of the front wave, but there's an article I thought


00:04:21.520 --> 00:04:22.560
was pretty interesting.


00:04:22.560 --> 00:04:27.760
I don't necessarily agree with everything, but I felt that it was certainly, you know,


00:04:27.760 --> 00:04:28.760
thought provoking.


00:04:28.760 --> 00:04:35.000
A guy named Sardar Yagulap, I'm sorry, I'm sorry I messed up your name, wrote an article


00:04:35.000 --> 00:04:39.080
and it's called "Four Likely Future Twists for Python."


00:04:39.080 --> 00:04:41.360
And I thought that was pretty cool.


00:04:41.360 --> 00:04:43.280
So let's go through the four twists.


00:04:43.280 --> 00:04:49.640
The first one does not make me happy, but is certainly something that I can see coming


00:04:49.640 --> 00:04:51.900
into existence as a thing.


00:04:51.900 --> 00:04:53.080
So we'll see.


00:04:53.080 --> 00:04:57.200
But the first one that they put out there is that Python 2x may live on.


00:04:57.200 --> 00:05:00.240
Yeah, I actually can see that this might happen.


00:05:00.240 --> 00:05:04.040
I mean, it's an open source project, so there's nobody stopping you from doing it.


00:05:04.040 --> 00:05:08.360
The thing that's going to make the difference is what do the core developers do, right?


00:05:08.360 --> 00:05:13.320
So right now the core developers are all focused on making sure that we make Python 3 as great


00:05:13.320 --> 00:05:15.680
as possible and they're putting their energy into it and so on.


00:05:15.680 --> 00:05:19.440
So I think Python 3 is certainly the right place for people to be.


00:05:19.440 --> 00:05:23.360
But I can see like large banks, you know, you think of places like Bank of America,


00:05:23.360 --> 00:05:28.640
they've got gosh, I don't remember the exact stats, but I was talking to Mahmoud Houshemi


00:05:28.640 --> 00:05:31.360
from one of the enterprise Python episodes I did.


00:05:31.360 --> 00:05:36.360
And it's something like the number of lines of Python 2, I don't even think it's 27.


00:05:36.360 --> 00:05:39.860
like 2.6 or 2.5 code is in the millions.


00:05:39.860 --> 00:05:42.780
Like five million lines of codes or something crazy like that.


00:05:42.780 --> 00:05:49.260
I can see a company like that forking Python and just making some kind of ongoing effort.


00:05:49.260 --> 00:05:52.340
Supporting your own Python, that just doesn't sound fun.


00:05:52.340 --> 00:05:53.660
It sounds like a really bad idea.


00:05:53.660 --> 00:05:58.340
I would much rather people just upgrade and we can all work together and live together


00:05:58.340 --> 00:06:00.300
and do great stuff.


00:06:00.300 --> 00:06:04.700
Here's one of the predictions that there'll probably be somebody that forks Python 2 and


00:06:04.700 --> 00:06:09.220
tries to keep it going. Whether that turns out to be beneficial or you know, trading


00:06:09.220 --> 00:06:15.020
one set of problems for a worse set of problems, we'll see. Yeah. The other one was this one


00:06:15.020 --> 00:06:20.260
I had no visibility into this I didn't see this coming and I read the title and I said


00:06:20.260 --> 00:06:27.380
requirements.txt may be replaced with something better. What? Okay, well, maybe it turns out


00:06:27.380 --> 00:06:34.660
the guys over at the Python Packaging Authority, that's the PyPI and pip and all those, but


00:06:34.660 --> 00:06:38.420
projects, so there's a organization, a group of people that actually work on that.


00:06:38.420 --> 00:06:41.020
They're working on this thing called pip file.


00:06:41.020 --> 00:06:47.620
And it's like a proposed new file format that's supposed to replace requirements.txt.


00:06:47.620 --> 00:06:48.620
That's interesting.


00:06:48.620 --> 00:06:49.620
Isn't it?


00:06:49.620 --> 00:06:50.620
Yeah.


00:06:50.620 --> 00:06:54.900
And so the idea is that pip file is going to be better or superior to requirements and


00:06:54.900 --> 00:07:00.700
that has a toml syntax, which is, if I recall correctly, it's a little like YAML.


00:07:00.700 --> 00:07:04.300
There's one pip file that can have multiple configurations in it, so you don't have like


00:07:04.300 --> 00:07:08.380
a dev requirements, a test requirements, a prod requirements, and so on.


00:07:08.380 --> 00:07:09.880
Yeah, it's, it's cool.


00:07:09.880 --> 00:07:15.780
You can do, you can do like a pip file freeze on it, it'll generate something that is a


00:07:15.780 --> 00:07:21.220
much richer document instead of just a txt file with a package name, like a version.


00:07:21.220 --> 00:07:22.900
So there's a lot of configuration and stuff in there.


00:07:22.900 --> 00:07:27.720
Like for example, one of the things you can do in these pip files is you can actually


00:07:27.720 --> 00:07:32.920
set the source of the packages, like right in your requirements file.


00:07:32.920 --> 00:07:37.760
So you can say I want to use this version of Python, I want to use it against this source


00:07:37.760 --> 00:07:43.940
like PyPI.org, or you could create your own DevPy server thing and run it internally and


00:07:43.940 --> 00:07:45.700
that would be part of your requirements file.


00:07:45.700 --> 00:07:48.120
So lots of cool enhancements there.


00:07:48.120 --> 00:07:50.940
I'm interested to see where it goes, but it's out there on GitHub, you can actually check


00:07:50.940 --> 00:07:51.940
it out.


00:07:51.940 --> 00:07:57.380
Yeah, I'd like to make sure it like sort of goes along the lines with with other packaging


00:07:57.380 --> 00:08:00.420
issues like the setup file and stuff.


00:08:00.420 --> 00:08:03.420
Hopefully we have one thing that replaces everything.


00:08:03.420 --> 00:08:04.420
Yeah, definitely.


00:08:04.420 --> 00:08:09.380
Okay, so number three is Python could get more enterprise editions.


00:08:09.380 --> 00:08:16.700
So we've got things like Anaconda and in thought, and Intel actually has their own Python implementation


00:08:16.700 --> 00:08:21.860
that is sort of a repackaging and tweaking of the Anaconda distribution, but just talking


00:08:21.860 --> 00:08:29.060
about how there may be more variations of Python distributions focused on enterprise


00:08:29.060 --> 00:08:34.500
needs. Maybe. I certainly see it happening in data science. I could see it happening elsewhere.


00:08:34.500 --> 00:08:39.860
I could see it, especially since we have to, I mean, everybody that's relying on Anaconda or


00:08:39.860 --> 00:08:45.060
something kind of has to wait for them to release something when they're waiting for a new version.


00:08:45.060 --> 00:08:52.180
And the last one is Python's software repository. So PyPI basically could get enterprise-friendly


00:08:52.180 --> 00:08:58.900
package management. So Christian Medina wrote a really interesting article as a follow-up to


00:08:58.900 --> 00:09:05.780
my episode 84 on the problems with PyPI and open source infrastructure funding and stuff


00:09:05.780 --> 00:09:10.700
and put together a pretty interesting article talking about something called the Python


00:09:10.700 --> 00:09:17.060
Trusted Registry or Trusted Index or something like that as a way to both fund PyPI and make


00:09:17.060 --> 00:09:18.380
it more enterprise friendly.


00:09:18.380 --> 00:09:23.500
I'm actually thinking about this problem as well and I'm probably going to release something


00:09:23.500 --> 00:09:27.620
like an article and a proof of concept, but I'm not ready to talk about it yet.


00:09:27.620 --> 00:09:29.040
- Okay, sounds interesting.


00:09:29.040 --> 00:09:30.240
Well, so that was four predictions.


00:09:30.240 --> 00:09:31.680
Are we done with the future?


00:09:31.680 --> 00:09:32.520
- That's the future.


00:09:32.520 --> 00:09:34.240
Let's go back to the present.


00:09:34.240 --> 00:09:36.400
- Okay, so in the present, NumPy is used


00:09:36.400 --> 00:09:38.180
for a lot of data science,


00:09:38.180 --> 00:09:40.080
and really just science and engineering.


00:09:40.080 --> 00:09:41.680
A lot of people use NumPy.


00:09:41.680 --> 00:09:45.040
There's a new book, an open source book,


00:09:45.040 --> 00:09:47.160
called From Python to NumPy,


00:09:47.160 --> 00:09:50.560
and it's from, I think this is a French person,


00:09:50.560 --> 00:09:52.180
Nicolas Rogier.


00:09:52.180 --> 00:09:53.400
The book is pretty interesting.


00:09:53.400 --> 00:09:56.320
It takes the assumption that you already know Python,


00:09:56.320 --> 00:09:58.220
you're an intermediate developer,


00:09:58.220 --> 00:10:01.880
and you just need to get your understanding of NumPy


00:10:01.880 --> 00:10:05.280
to apply it to whatever problem you're on.


00:10:05.280 --> 00:10:07.560
And it looks well, I haven't read a ton of it,


00:10:07.560 --> 00:10:09.160
but it looks really well formatted.


00:10:09.160 --> 00:10:11.680
I like the topics that are in there.


00:10:11.680 --> 00:10:13.180
Just sounds interesting.


00:10:13.180 --> 00:10:14.120
- Yeah, it sounds really cool.


00:10:14.120 --> 00:10:17.160
And if you're looking for scientific computation


00:10:17.160 --> 00:10:18.660
and you're thinking of like,


00:10:18.660 --> 00:10:21.200
am I gonna shell out $2,000 for MATLAB?


00:10:21.200 --> 00:10:23.800
Well, maybe look at some of the Python tools, right?


00:10:23.800 --> 00:10:24.760
It's definitely growing.


00:10:24.760 --> 00:10:25.600
- Yeah.


00:10:25.600 --> 00:10:28.220
- So it's cool for us to think about the future,


00:10:28.220 --> 00:10:31.020
but what if like machines could think about the future?


00:10:31.020 --> 00:10:32.100
(laughing)


00:10:32.100 --> 00:10:32.940
- Machines, yeah.


00:10:32.940 --> 00:10:36.120
- I really feel like 2016 and 2017 is the year


00:10:36.120 --> 00:10:39.860
where AI became not something that's always five years


00:10:39.860 --> 00:10:42.400
in the future, but actually something that's starting


00:10:42.400 --> 00:10:43.940
to take shape in the present.


00:10:43.940 --> 00:10:45.980
- Yeah, and it affects, now affects everybody


00:10:45.980 --> 00:10:48.220
with all of their speaking devices.


00:10:48.220 --> 00:10:50.700
- Yeah, and I, you know, we could be mean


00:10:50.700 --> 00:10:55.380
and we could say, hey, Amazon thing, order us a,


00:10:55.380 --> 00:10:56.380
But we won't do that.


00:10:56.380 --> 00:11:01.540
The thing, the item I want to talk about for number four here is something called Universe.


00:11:01.540 --> 00:11:07.640
And it's a way to take games basically, all sorts of games, and make them available as


00:11:07.640 --> 00:11:11.200
ways for AIs to experience the world.


00:11:11.200 --> 00:11:12.200
So here's the deal.


00:11:12.200 --> 00:11:17.080
The thing they put together where you can build an AI, put it into a Docker image, give


00:11:17.080 --> 00:11:23.480
it to their environment, and then they will let it play literally thousands of video games.


00:11:23.480 --> 00:11:25.700
And it can learn from playing the games.


00:11:25.700 --> 00:11:30.240
So you can play like flash-based browser games, other types of games, a whole bunch, like


00:11:30.240 --> 00:11:31.640
I said, over a thousand environments.


00:11:31.640 --> 00:11:36.960
And the way it plays it is the, so you don't have to integrate with like all these different


00:11:36.960 --> 00:11:37.960
games.


00:11:37.960 --> 00:11:42.640
Your Docker image just is presented the visual screen that the humans look at, and then they


00:11:42.640 --> 00:11:47.480
send mouse and keyboard events to the games.


00:11:47.480 --> 00:11:48.480
Yeah.


00:11:48.480 --> 00:11:52.240
So they basically just play as if they were a person playing the game.


00:11:52.240 --> 00:11:54.840
so they have the same experience of the game as you,


00:11:54.840 --> 00:11:56.800
but here's all these environments


00:11:56.800 --> 00:11:59.160
in which you can train and test AIs.


00:11:59.160 --> 00:12:00.460
What do you think?


00:12:00.460 --> 00:12:02.120
- It sounds like tic-tac-toe


00:12:02.120 --> 00:12:05.760
in global thermonuclear war to me.


00:12:05.760 --> 00:12:08.560
- Hello, Dr. Falcon, would you like to play a game?


00:12:08.560 --> 00:12:12.400
- So what's the, so if you have an AI


00:12:12.400 --> 00:12:16.280
that has learned a whole bunch of stuff about games,


00:12:16.280 --> 00:12:17.240
like why?


00:12:17.240 --> 00:12:18.400
- Why would you care about this, right?


00:12:18.400 --> 00:12:21.060
Like, well, maybe you're working on a robot


00:12:21.060 --> 00:12:22.980
and you wanna teach the robot to walk around


00:12:22.980 --> 00:12:24.140
to interact with the world,


00:12:24.140 --> 00:12:26.820
but you don't have the robot finished,


00:12:26.820 --> 00:12:28.580
you could take the smarts of the robot


00:12:28.580 --> 00:12:32.700
and let it play Counter-Strike or something


00:12:32.700 --> 00:12:36.000
for until it gets really good at not bumping into stuff,


00:12:36.000 --> 00:12:37.240
like making it through paths,


00:12:37.240 --> 00:12:39.180
and then you could just plug that into your robot.


00:12:39.180 --> 00:12:40.020
I don't know, something like,


00:12:40.020 --> 00:12:42.340
I mean, this is me totally speculating on the spot.


00:12:42.340 --> 00:12:43.180
I don't know.


00:12:43.180 --> 00:12:44.900
- Yeah, just don't give your robot a gun.


00:12:44.900 --> 00:12:46.740
- Yes, exactly, 'cause it's gonna be really good


00:12:46.740 --> 00:12:48.020
at it at that point.


00:12:48.020 --> 00:12:48.860
- Yeah.


00:12:48.860 --> 00:12:50.080
- All right, so another thing


00:12:50.080 --> 00:12:52.320
that I've been doing a lot with lately


00:12:52.320 --> 00:12:55.540
is working with APIs and HTTP services and stuff.


00:12:55.540 --> 00:12:58.660
And your next item is a pretty interesting deep dive


00:12:58.660 --> 00:13:02.680
into literally the most popular Python package request,


00:13:02.680 --> 00:13:04.200
which for those of you who don't know,


00:13:04.200 --> 00:13:06.700
it's downloaded 7 million times a month.


00:13:06.700 --> 00:13:10.580
- Yeah, and it's titled Python Request Deep Dive.


00:13:10.580 --> 00:13:14.900
And it came from Anthony Shaw, and he put it on Medium.


00:13:14.900 --> 00:13:18.040
And Anthony's been, I don't even know why I know Anthony.


00:13:18.040 --> 00:13:20.700
I've just known about him for a long time.


00:13:20.700 --> 00:13:24.920
But he's, my first thought was it's going to be


00:13:24.920 --> 00:13:27.560
just teaching people how to use requests, but it's not.


00:13:27.560 --> 00:13:29.920
It's a really cool article.


00:13:29.920 --> 00:13:32.760
He took, what happened was he had,


00:13:32.760 --> 00:13:36.840
he was on a project to convert a large project


00:13:36.840 --> 00:13:41.800
from HTTBlib, so he wasn't even using URL lib two


00:13:41.800 --> 00:13:45.880
or anything, HTTPlib into requests.


00:13:45.880 --> 00:13:49.520
And this project was Apache Lib Cloud


00:13:49.520 --> 00:13:54.520
and with, I was handling stuff like HTTP, HTTPS,


00:13:54.520 --> 00:13:59.100
REST, JSON, XML, whole bunch of bizarre APIs


00:13:59.100 --> 00:14:03.360
with over, he lists over 80 client libraries


00:14:03.360 --> 00:14:05.820
to handle different cloud services


00:14:05.820 --> 00:14:09.080
and had one connection class that did the encoding


00:14:09.080 --> 00:14:12.960
and decoding of everything and converted this all.


00:14:12.960 --> 00:14:15.540
And this article's about all the stuff he had to deal with,


00:14:15.540 --> 00:14:19.480
like dealing with sessions, dealing with authentication,


00:14:19.480 --> 00:14:23.020
how we test it, doing prepared requests, streams.


00:14:23.020 --> 00:14:25.220
It's just a chock full of stuff


00:14:25.220 --> 00:14:26.840
and it's not even that long of an article,


00:14:26.840 --> 00:14:28.260
so I think he did a good job.


00:14:28.260 --> 00:14:29.340
- Yeah, that sounds really cool.


00:14:29.340 --> 00:14:30.300
I haven't had a chance to read it,


00:14:30.300 --> 00:14:31.900
but I definitely bookmarked it.


00:14:31.900 --> 00:14:33.260
You know, Anthony Shaw is a great guy.


00:14:33.260 --> 00:14:34.620
He's doing cool stuff.


00:14:34.620 --> 00:14:37.820
He talked about LibCloud on PodcastInit.


00:14:37.820 --> 00:14:38.980
I'm afraid I don't remember the number,


00:14:38.980 --> 00:14:41.780
but you can listen to him there and that's really cool.


00:14:41.780 --> 00:14:44.460
It's a cool project and this sounds like


00:14:44.460 --> 00:14:49.380
pretty serious real world upgrade from one library to another sort of example.


00:14:49.380 --> 00:14:52.180
And I think there's probably a lot of lessons people can get from this.


00:14:52.180 --> 00:14:57.380
And one of the one of the neat things he has in here is he uses a tool called


00:14:57.380 --> 00:14:59.420
requests mock.


00:14:59.420 --> 00:15:02.880
And I looked through this, the API for this,


00:15:02.880 --> 00:15:05.860
and it really is pretty cool.


00:15:05.860 --> 00:15:08.580
So my my philosophy on mocks is to


00:15:08.580 --> 00:15:12.280
to really only mark what you absolutely have to have to do.


00:15:12.660 --> 00:15:18.220
Not everything, but some of your testing should be using mocks when you're dealing with outside


00:15:18.220 --> 00:15:24.360
resources and you know, an HTTP request clearly is dealing with an outside resource.


00:15:24.360 --> 00:15:30.660
But the API for this is very, very simple and very powerful and I got to try it out.


00:15:30.660 --> 00:15:35.460
Yeah, I hadn't heard of request mock requests mock and that sounds like super useful because


00:15:35.460 --> 00:15:38.620
you're right, that's one of the places if you're doing testing, you really don't want


00:15:38.620 --> 00:15:42.500
to have to set up the service and configure it in test mode or whatever.


00:15:42.500 --> 00:15:46.200
Now that was dealing with APIs on the internet.


00:15:46.200 --> 00:15:48.200
How about desktop applications?


00:15:48.200 --> 00:15:52.760
Yeah, so let's talk about Python and desktop applications.


00:15:52.760 --> 00:15:56.440
Certainly you can build interesting desktop applications.


00:15:56.440 --> 00:16:01.640
You know, Dropbox is a real world example of, you know, probably the most widely deployed


00:16:01.640 --> 00:16:05.960
Python desktop app in the world because that client thing that I see spinning right now


00:16:05.960 --> 00:16:10.480
in my little notification bar, that is all Python.


00:16:10.480 --> 00:16:14.360
Okay, Python 2.7, I believe they're working on upgrading to Python 3.


00:16:14.360 --> 00:16:15.540
But right now it's 2.7.


00:16:15.540 --> 00:16:18.720
And that's interesting, you can use a lot of different technologies.


00:16:18.720 --> 00:16:25.680
But I kind of feel like there's just something missing to make Python a first class environment


00:16:25.680 --> 00:16:28.240
for building desktop applications.


00:16:28.240 --> 00:16:31.180
So we've had TKender for a long time.


00:16:31.180 --> 00:16:32.180
And that's sort of built in.


00:16:32.180 --> 00:16:36.320
But I always feel like that looks, I don't know, super out of place, especially on like


00:16:36.320 --> 00:16:37.320
Mac or Windows.


00:16:37.320 --> 00:16:42.760
It looks much more like it belongs in sort of a Unix/Linux space, but even there it doesn't


00:16:42.760 --> 00:16:44.080
look super fabulous.


00:16:44.080 --> 00:16:49.840
It looks like the TK stuff that I was using with TCL when I was in college a long time


00:16:49.840 --> 00:16:50.840
ago.


00:16:50.840 --> 00:16:51.840
Yes, exactly.


00:16:51.840 --> 00:16:53.400
And it totally works and you can do it and so on.


00:16:53.400 --> 00:16:57.200
So the thing I want to highlight is a Reddit conversation.


00:16:57.200 --> 00:17:00.240
It's not a link, it's just a back and forth on Reddit.


00:17:00.240 --> 00:17:05.000
What's the community's favorite for developing OS X applications with Python?


00:17:05.000 --> 00:17:06.680
So there's a couple people that weighed in.


00:17:06.680 --> 00:17:14.560
By far, I think PyQt came in as the most highly voted up.


00:17:14.560 --> 00:17:16.560
And have you done anything with Qt?


00:17:16.560 --> 00:17:18.800
I did a small project with it a long time ago.


00:17:18.800 --> 00:17:19.800
Yeah.


00:17:19.800 --> 00:17:25.160
The thing I like about Qt is the stuff that comes out of it looks native.


00:17:25.160 --> 00:17:28.040
It's based on C++, so it starts super fast.


00:17:28.040 --> 00:17:31.400
It feels like an app that belongs wherever it's running.


00:17:31.400 --> 00:17:32.600
And I think that's cool.


00:17:32.600 --> 00:17:37.680
The challenge with this is you've got PyQt, the package, and you've got PySide.


00:17:37.680 --> 00:17:43.400
And these have been sort of competing, not entirely compatible ways of writing this code.


00:17:43.400 --> 00:17:49.720
I think PySide is the better licensing model, but it's, if I recall correctly, it only supports


00:17:49.720 --> 00:17:52.520
Qt4 and Qt is on Qt5.


00:17:52.520 --> 00:17:54.960
And so there's just all this sort of like, it almost works.


00:17:54.960 --> 00:17:58.640
It's kind of hard to deploy Qt, like on the various machines.


00:17:58.640 --> 00:18:00.660
It's sort of a heavyweight install and so on.


00:18:00.660 --> 00:18:01.660
This should be getting better.


00:18:01.660 --> 00:18:05.620
I think Qt, the company that runs Qt


00:18:05.620 --> 00:18:08.820
is bringing PySide back in and gonna modernize it,


00:18:08.820 --> 00:18:11.180
but that's not coming out until the end of this year,


00:18:11.180 --> 00:18:12.020
probably.


00:18:12.020 --> 00:18:14.780
So one vote was for Qt, that was cool.


00:18:14.780 --> 00:18:18.340
Another one was for TK, simple voice dependencies,


00:18:18.340 --> 00:18:19.940
but like we already talked about that.


00:18:19.940 --> 00:18:21.900
Kivi, Kivi definitely got a vote,


00:18:21.900 --> 00:18:25.660
but Kivi is much more, it's not sort of desktop app feeling,


00:18:25.660 --> 00:18:28.340
it's more like, like almost like games.


00:18:28.340 --> 00:18:30.220
I think its origins were in games.


00:18:30.220 --> 00:18:34.100
So what you get is it doesn't really have a native feel, right?


00:18:34.100 --> 00:18:35.900
So that's not that great.


00:18:35.900 --> 00:18:39.100
I think some people are using it for kiosks and stuff.


00:18:39.100 --> 00:18:40.100
Yeah, yeah.


00:18:40.100 --> 00:18:42.460
And that's not bad. I know it does a great thing,


00:18:42.460 --> 00:18:44.740
great stuff on mobile as well.


00:18:44.740 --> 00:18:46.540
There's some debate whether that was the right choice.


00:18:46.540 --> 00:18:49.260
There's Toga, which is really cool, Toga from the B-Ware guys.


00:18:49.260 --> 00:18:51.580
But it's also Toga is like real early,


00:18:51.580 --> 00:18:54.140
doesn't have support for all the APIs and stuff.


00:18:54.140 --> 00:18:56.940
So I kind of want to point this out to just say like,


00:18:56.940 --> 00:18:59.420
you know, to keep raising the issue like,


00:18:59.420 --> 00:19:02.500
"Hey, Python community, it would be awesome


00:19:02.500 --> 00:19:07.280
"if there was something that was really clearly fantastic


00:19:07.280 --> 00:19:09.720
"for building apps where people say,


00:19:09.720 --> 00:19:10.980
"of course you should use this.


00:19:10.980 --> 00:19:13.880
"It's as good as Swift for OS 10 apps.


00:19:13.880 --> 00:19:17.220
"It's as good as WPF for Windows apps."


00:19:17.220 --> 00:19:18.580
Or whatever, it just feels native.


00:19:18.580 --> 00:19:20.660
It's really all coherent.


00:19:20.660 --> 00:19:22.740
And I just don't see that existing yet.


00:19:22.740 --> 00:19:25.640
I think the B-Ware guys are the closest to it.


00:19:25.640 --> 00:19:27.220
It was an interesting conversation.


00:19:27.220 --> 00:19:29.020
- And you've brought it up before that it would,


00:19:29.020 --> 00:19:30.120
I think you brought it up on Twitter,


00:19:30.120 --> 00:19:32.920
that it'd be cool if we had something kind of like Electron.


00:19:32.920 --> 00:19:34.760
- Yeah, for those of you who don't know what Electron is,


00:19:34.760 --> 00:19:39.320
Electron.js is a way to write apps


00:19:39.320 --> 00:19:41.520
that ship entirely bundled.


00:19:41.520 --> 00:19:43.740
There's just a single thing you run.


00:19:43.740 --> 00:19:47.800
It's an exe or a binary on Linux or a .app on Mac.


00:19:47.800 --> 00:19:49.000
There's zero dependencies,


00:19:49.000 --> 00:19:52.320
and it runs Node.js as the sort of smarts,


00:19:52.320 --> 00:19:56.400
and it embeds its own copy of Chromium, the UI.


00:19:56.400 --> 00:20:00.700
So it's basically you use HTML, JavaScript, and CSS to build your UI,


00:20:00.700 --> 00:20:02.700
and you can use frameworks that make it look native.


00:20:02.700 --> 00:20:06.100
And then you've got Node as the backend to keep this all going.


00:20:06.100 --> 00:20:08.400
There's a few projects that almost do this in Python.


00:20:08.400 --> 00:20:14.000
Like there's one about Django that will let you like ship Django sort of backends


00:20:14.000 --> 00:20:20.400
that will create GUI-looking things where you're doing it with basically Django running locally.


00:20:20.400 --> 00:20:24.840
you know, I don't really want my app to say, to you know, do you want this app to act as


00:20:24.840 --> 00:20:25.840
a server?


00:20:25.840 --> 00:20:30.120
When I try to run it, and they'd be like, this is not supposed to be a server app, like,


00:20:30.120 --> 00:20:32.720
what kind of weird thing have I got a hold of here, right?


00:20:32.720 --> 00:20:36.760
I want something that feels like it drops in, and it's basically indistinguishable from


00:20:36.760 --> 00:20:37.760
a native app.


00:20:37.760 --> 00:20:40.200
And we can dream one, one step.


00:20:40.200 --> 00:20:45.680
And that's a good good step in that direction is CX freeze, which lets you take Python code


00:20:45.680 --> 00:20:50.380
plus its dependencies and the Python implementation, and everything and package it into a real


00:20:50.380 --> 00:20:55.140
distributable and that just released version 501 in January. So that's cool to see that


00:20:55.140 --> 00:20:57.780
coming along. So that's one of the important building blocks at least.


00:20:57.780 --> 00:20:59.140
Okay, that's cool.


00:20:59.140 --> 00:21:03.580
Someday I dream of a future where, I don't know, there's some whizzy UI framework with


00:21:03.580 --> 00:21:06.660
a visual designer for Python.


00:21:06.660 --> 00:21:11.700
It's interesting that I don't really think about that that much. But the, I mean, I spent,


00:21:11.700 --> 00:21:16.620
you spend so much time in interacting with elements on a desktop, even, even though we


00:21:16.620 --> 00:21:19.260
don't develop them very often.


00:21:19.260 --> 00:21:22.860
Not to say it can't be done, I just think it could go up a couple levels and it would


00:21:22.860 --> 00:21:26.220
make a really big difference in the adoption of Python.


00:21:26.220 --> 00:21:30.340
It's already growing super well, but if you could take over the desktop market with it


00:21:30.340 --> 00:21:32.860
as well, then who knows where it would go.


00:21:32.860 --> 00:21:33.860
Maybe you should do that, Michael.


00:21:33.860 --> 00:21:34.860
You could take it on.


00:21:34.860 --> 00:21:36.020
Yeah, I have so much time.


00:21:36.020 --> 00:21:37.500
It seems like a great idea.


00:21:37.500 --> 00:21:38.500
Yeah, okay.


00:21:38.500 --> 00:21:41.740
So, if you don't have time for that, what are you doing?


00:21:41.740 --> 00:21:43.380
I'm working on my classes.


00:21:43.380 --> 00:21:48.060
I'm actually working on some stuff that has these things we were talking about in mind.


00:21:48.060 --> 00:21:49.820
sort of at the top of my mind,


00:21:49.820 --> 00:21:51.540
but I'm not ready to announce anything yet.


00:21:51.540 --> 00:21:54.700
But cool projects that I'm working on,


00:21:54.700 --> 00:21:58.300
and I'm working on a special episode of Talk Python to Me.


00:21:58.300 --> 00:22:00.220
We've got episode 100 coming up,


00:22:00.220 --> 00:22:01.300
so I have a special guest.


00:22:01.300 --> 00:22:03.140
I'm not going to announce it until I release it,


00:22:03.140 --> 00:22:04.660
but that one's gonna be big.


00:22:04.660 --> 00:22:06.340
- I can't believe it's been 100 already.


00:22:06.340 --> 00:22:08.580
- I know, two years, amazing.


00:22:08.580 --> 00:22:11.100
- Yeah, speaking of podcasts,


00:22:11.100 --> 00:22:14.660
I've got a couple coming up, hopefully pretty soon.


00:22:14.660 --> 00:22:16.100
They just need edited.


00:22:16.100 --> 00:22:17.740
Talk to some really great people.


00:22:17.740 --> 00:22:21.300
And then I was interviewed on a podcast called


00:22:21.300 --> 00:22:23.260
Reflection as a Service.


00:22:23.260 --> 00:22:26.980
And that was really fun to talk with somebody else


00:22:26.980 --> 00:22:28.860
about test-driven development.


00:22:28.860 --> 00:22:32.900
And I think I talked about the testing column


00:22:32.900 --> 00:22:35.580
that I think I made up on the fly


00:22:35.580 --> 00:22:37.300
while I was talking with you one day.


00:22:37.300 --> 00:22:38.900
- We're gonna make that a thing.


00:22:38.900 --> 00:22:40.020
(laughing)


00:22:40.020 --> 00:22:42.420
- So yeah, and then I'm still writing,


00:22:42.420 --> 00:22:43.700
so that's what I'm up to.


00:22:43.700 --> 00:22:45.460
- Awesome, yeah, you got some good reviewers


00:22:45.460 --> 00:22:46.340
for your book, right?


00:22:46.340 --> 00:22:50.500
- Yeah, definitely, a big chunk of the pytest core team


00:22:50.500 --> 00:22:53.380
has agreed to help out and make sure


00:22:53.380 --> 00:22:56.220
I don't say something stupid, so I appreciate that.


00:22:56.220 --> 00:22:57.860
- Yeah, that's really excellent.


00:22:57.860 --> 00:22:59.500
I feel like we've definitely given people


00:22:59.500 --> 00:23:01.260
a lot of information this week.


00:23:01.260 --> 00:23:02.940
- Definitely, it's good.


00:23:02.940 --> 00:23:05.740
- And pretty drama-free, so that's always nice.


00:23:05.740 --> 00:23:06.580
- Yeah.


00:23:06.580 --> 00:23:09.620
Well, thanks a lot for talking to me today.


00:23:09.620 --> 00:23:11.540
- You bet, it was great to share this with you, Brian,


00:23:11.540 --> 00:23:13.380
and I'll catch up with you next week.


00:23:13.380 --> 00:23:16.140
Thank you for listening to Python Bytes.


00:23:16.140 --> 00:23:21.980
Follow the show on Twitter via @pythonbytes, that's Python Bytes as in B-Y-T-E-S.


00:23:21.980 --> 00:23:25.260
And get the full show notes at PythonBytes.fm.


00:23:25.260 --> 00:23:28.940
If you have a news item you want featured, just visit PythonBytes.fm and send it our


00:23:28.940 --> 00:23:29.940
way.


00:23:29.940 --> 00:23:32.460
We're always on the lookout for sharing something cool.


00:23:32.460 --> 00:23:35.700
On behalf of myself and Brian Auchin, this is Michael Kennedy.


00:23:35.700 --> 00:23:38.980
Thank you for listening and sharing this podcast with your friends and colleagues.

