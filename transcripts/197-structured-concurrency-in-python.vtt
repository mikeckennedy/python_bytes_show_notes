
00:00:00.000 --> 00:00:05.520
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode


00:00:05.520 --> 00:00:07.740
197


00:00:07.740 --> 00:00:09.740
recorded August


00:00:09.740 --> 00:00:11.020
26th


00:00:11.020 --> 00:00:15.660
2020 Brian, can you believe it's the end of August even if I can't say it it still is true


00:00:15.660 --> 00:00:17.580
No, I can't I don't know where August went


00:00:17.580 --> 00:00:23.740
I just I thought this whole pandemic thing would make the summer seem long and slow. It seems like it just went faster


00:00:23.740 --> 00:00:28.900
Yeah, I've got like a Lego kit that I was planning on doing like the first week week of summer vacation


00:00:28.900 --> 00:00:30.900
and it's still sitting here.


00:00:30.900 --> 00:00:32.060
- Yeah, for sure.


00:00:32.060 --> 00:00:33.380
Yeah, there's a lot of things I want to get done


00:00:33.380 --> 00:00:34.780
before the sun goes away


00:00:34.780 --> 00:00:37.100
and rain starts for six months straight.


00:00:37.100 --> 00:00:39.640
That's a Pacific Northwest problem, but it's our problem.


00:00:39.640 --> 00:00:42.380
All right, now this episode is brought to you by us as well.


00:00:42.380 --> 00:00:44.000
We'll tell you more about the things that we're doing


00:00:44.000 --> 00:00:46.500
that we think you will appreciate later.


00:00:46.500 --> 00:00:48.260
Right now, I want to talk about something


00:00:48.260 --> 00:00:50.100
that I think we might've covered before,


00:00:50.100 --> 00:00:52.740
but I don't know if we've ever satisfactorily covered it.


00:00:52.740 --> 00:00:54.260
Maybe this time we'll get a little closer


00:00:54.260 --> 00:00:55.340
and that's asyncio.


00:00:55.340 --> 00:00:57.180
- Oh yeah, I think that's a new topic.


00:00:57.180 --> 00:00:58.820
- It's a totally new topic.


00:00:58.820 --> 00:01:01.420
Covered only less than GUIs now.


00:01:01.420 --> 00:01:05.220
So there's a new, how should I put it?


00:01:05.220 --> 00:01:10.020
A new compatibility-like layer library


00:01:10.020 --> 00:01:13.420
that allows you to work a little bit better


00:01:13.420 --> 00:01:16.900
with AsyncIO and some of the other Async libraries


00:01:16.900 --> 00:01:19.900
that are not directly, immediately the same


00:01:19.900 --> 00:01:23.100
as or built right on top of AsyncIO.


00:01:23.100 --> 00:01:28.100
Curio from David Beasley and Trio from Nathaniel Smith.


00:01:28.580 --> 00:01:30.860
So there's an article that talks about this.


00:01:30.860 --> 00:01:33.580
I'm gonna mention as part of this conversation.


00:01:33.580 --> 00:01:35.180
And then say, "Hey, Python has three well-known


00:01:35.180 --> 00:01:37.280
"concurrency libraries built around async


00:01:37.280 --> 00:01:41.380
"and await syntax, asyncIO, curio, and trio."


00:01:41.380 --> 00:01:43.340
True, but where's unsync, people?


00:01:43.340 --> 00:01:44.980
Unsync is the best of all four of those.


00:01:44.980 --> 00:01:46.060
I don't know where unsync is.


00:01:46.060 --> 00:01:48.580
Anyway, unsync is not part of this conversation,


00:01:48.580 --> 00:01:51.220
but unsync plays a role a little bit like this thing


00:01:51.220 --> 00:01:55.680
I'm gonna mention today is anyIO.


00:01:55.680 --> 00:01:57.780
And it's a pretty clever name


00:01:57.780 --> 00:01:59.580
because the idea is that it provides


00:01:59.580 --> 00:02:04.140
structured concurrency primitives built on top of AsyncIO.


00:02:04.140 --> 00:02:04.980
- Okay.


00:02:04.980 --> 00:02:07.180
- Right, so one of the challenges with AsyncIO


00:02:07.180 --> 00:02:09.120
is you can kick off a bunch of tasks


00:02:09.120 --> 00:02:10.740
and then not wait for them,


00:02:10.740 --> 00:02:11.860
and your program can exit,


00:02:11.860 --> 00:02:12.940
or you can do other things,


00:02:12.940 --> 00:02:15.220
and maybe you've seen runtime warnings


00:02:15.220 --> 00:02:17.920
like task such and such was never awaited.


00:02:17.920 --> 00:02:20.020
You're like, hmm, I wonder what that means.


00:02:20.020 --> 00:02:21.740
Well, that probably means your program exited


00:02:21.740 --> 00:02:23.220
while it was halfway done,


00:02:23.220 --> 00:02:24.900
or something like that, right?


00:02:24.900 --> 00:02:26.900
Or your thing returned a value


00:02:26.900 --> 00:02:28.540
before it waited for it to finish, right?


00:02:28.540 --> 00:02:30.300
And at the low level,


00:02:30.300 --> 00:02:32.060
something that's a little bit frustrating


00:02:32.060 --> 00:02:33.460
or annoying that you gotta deal with


00:02:33.460 --> 00:02:34.460
is that you've got to make sure


00:02:34.460 --> 00:02:37.020
that all the stuff you started on the async event loop,


00:02:37.020 --> 00:02:39.620
that you wait for that event loop to finish


00:02:39.620 --> 00:02:42.180
before your program completely shuts down


00:02:42.180 --> 00:02:43.820
or completely carries on.


00:02:43.820 --> 00:02:47.380
And so that's basically the idea of this library.


00:02:47.380 --> 00:02:50.220
It's a compatibility layer across those three types,


00:02:50.220 --> 00:02:52.840
those three different well-known concurrency libraries


00:02:52.840 --> 00:02:56.420
that provides this structured concurrency.


00:02:56.420 --> 00:03:02.020
So you look at Wikipedia, they say structured concurrency is a programming paradigm aimed


00:03:02.020 --> 00:03:06.820
at improving the clarity, quality, and development time of a computer program by using a structured


00:03:06.820 --> 00:03:09.120
approach to concurrent programming.


00:03:09.120 --> 00:03:14.860
The core concept is the encapsulations of threads of execution by way of control flow


00:03:14.860 --> 00:03:18.540
constructs that have a clear entry and exit points.


00:03:18.540 --> 00:03:26.860
In Python, this mostly manifests itself through this library as async with blocks or async


00:03:26.860 --> 00:03:27.860
context managers.


00:03:27.860 --> 00:03:32.340
You're like, "I'm going to do some async work, so let's create a with block, do all the work


00:03:32.340 --> 00:03:33.340
in there."


00:03:33.340 --> 00:03:37.500
And then by the way, when you leave the with block, it's going to have made sure all the


00:03:37.500 --> 00:03:41.740
tasks that were started and the tasks started by those tasks and so on, all finished.


00:03:41.740 --> 00:03:42.740
Oh, that's nice.


00:03:42.740 --> 00:03:44.220
Yeah, that's pretty cool.


00:03:44.220 --> 00:03:46.120
So the way it works is you basically go


00:03:46.120 --> 00:03:50.400
anyio.createTaskGroup, and then from the task group


00:03:50.400 --> 00:03:53.340
you can spawn other subtasks,


00:03:53.340 --> 00:03:55.480
and it will keep track of those.


00:03:55.480 --> 00:03:57.720
If there's an exception, I believe it will cancel


00:03:57.720 --> 00:04:00.840
the other undone ones, the unfinished ones, and so on.


00:04:00.840 --> 00:04:03.120
So it's about, say, we're just gonna go through this thing


00:04:03.120 --> 00:04:06.640
and it's all gonna run here, and it enters at the top


00:04:06.640 --> 00:04:09.560
and it exits at the bottom of the with block.


00:04:09.560 --> 00:04:10.400
That's pretty cool, right?


00:04:10.400 --> 00:04:11.220
- Yeah.


00:04:11.220 --> 00:04:12.520
- Yeah, so I think that that's pretty neat.


00:04:12.520 --> 00:04:13.760
Also, it has other primitives,


00:04:13.760 --> 00:04:15.760
that's like a real simple example.


00:04:15.760 --> 00:04:17.480
Other example or other things it does


00:04:17.480 --> 00:04:21.200
include synchronization primitives, locks.


00:04:21.200 --> 00:04:25.960
So if you create a re-entrant lock in Python,


00:04:25.960 --> 00:04:27.340
often called a critical section


00:04:27.340 --> 00:04:29.360
and things like C++ and whatnot,


00:04:29.360 --> 00:04:31.080
it's never ever gonna help you.


00:04:31.080 --> 00:04:32.720
Well, maybe that's a little bit strong.


00:04:32.720 --> 00:04:34.600
It's likely not gonna help you


00:04:34.600 --> 00:04:37.480
because those mechanisms come


00:04:37.480 --> 00:04:39.560
from the operating system process level.


00:04:39.560 --> 00:04:41.040
And what they do is they make sure two threads


00:04:41.040 --> 00:04:42.640
don't run at the same time.


00:04:42.640 --> 00:04:45.120
Well, with async I/O, it's all a bunch of stuff


00:04:45.120 --> 00:04:49.360
that's being broken apart on a single thread, right?


00:04:49.360 --> 00:04:53.060
It's all on the one, wherever the event loop.run is,


00:04:53.060 --> 00:04:54.640
run till complete or whatever,


00:04:54.640 --> 00:04:56.200
like wherever that's happening, that's the thread.


00:04:56.200 --> 00:04:57.920
So like the thread locks don't matter.


00:04:57.920 --> 00:04:59.160
It's all the same thread.


00:04:59.160 --> 00:05:00.560
Like you're not gonna block anything.


00:05:00.560 --> 00:05:03.780
So having primitives that will kind of function


00:05:03.780 --> 00:05:06.920
like threads to protect data while stuff is happening,


00:05:06.920 --> 00:05:08.980
while it's in temporarily invalid states,


00:05:08.980 --> 00:05:10.400
that's pretty cool for async I/O.


00:05:10.400 --> 00:05:12.940
- Okay, so you need it or you don't need it?


00:05:12.940 --> 00:05:13.780
- You probably need it.


00:05:13.780 --> 00:05:16.200
I think people often don't really think too much


00:05:16.200 --> 00:05:19.700
about these invalid states or programs get into


00:05:19.700 --> 00:05:21.640
and you think, well, asyncio, it's gonna be fine.


00:05:21.640 --> 00:05:24.660
And a lot of times what you're doing with asyncio


00:05:24.660 --> 00:05:28.140
is kind of standalone, like I'm gonna kick off this thing


00:05:28.140 --> 00:05:29.660
and when it comes back, I'm gonna take the data


00:05:29.660 --> 00:05:30.500
and do something.


00:05:30.500 --> 00:05:33.660
But if you're modifying shared data structures,


00:05:33.660 --> 00:05:36.140
you can still end up in some kind of event loop


00:05:36.140 --> 00:05:36.980
erase condition.


00:05:36.980 --> 00:05:38.660
It's not as bad as like true threading


00:05:38.660 --> 00:05:40.460
because you're not going to,


00:05:40.460 --> 00:05:43.700
I don't believe it's like a plus equals, right?


00:05:43.700 --> 00:05:46.380
Of something that actually might be multiple steps


00:05:46.380 --> 00:05:47.740
at the lower level runtime.


00:05:47.740 --> 00:05:49.220
I don't think that it would get broken up


00:05:49.220 --> 00:05:52.280
to that fine grained, but if you say like,


00:05:52.280 --> 00:05:54.660
debit this account, this amount of money,


00:05:54.660 --> 00:05:57.300
or a weight, debit this account, this amount of money,


00:05:57.300 --> 00:05:59.700
a weight, put that amount into the other one,


00:05:59.700 --> 00:06:02.100
and some other one is like reading in some kind of loop,


00:06:02.100 --> 00:06:04.180
like that level of higher order,


00:06:04.180 --> 00:06:05.780
like temporarily invalid state,


00:06:05.780 --> 00:06:08.340
that could be a problem for asyncio


00:06:08.340 --> 00:06:09.940
and you want some kind of lock.


00:06:09.940 --> 00:06:10.900
So this comes with that.


00:06:10.900 --> 00:06:13.200
It comes with streams, which are similar to queues,


00:06:13.200 --> 00:06:15.540
timeouts through things like move on after


00:06:15.540 --> 00:06:18.020
or fail after a certain amount of time and so on.


00:06:18.020 --> 00:06:19.420
So it's a pretty cool little library.


00:06:19.420 --> 00:06:20.580
- Yeah, that's nice.


00:06:20.580 --> 00:06:23.500
- My vote still for Unsync is the best of the four,


00:06:23.500 --> 00:06:24.660
even though it was unmentioned.


00:06:24.660 --> 00:06:26.340
(laughing)


00:06:26.340 --> 00:06:28.100
- Isn't Unsync built on those also?


00:06:28.100 --> 00:06:31.180
- It's a compatibility layer that takes asyncio,


00:06:31.180 --> 00:06:32.700
threading and multiprocessing


00:06:32.700 --> 00:06:35.700
and turns them all into things that you can await.


00:06:35.700 --> 00:06:37.180
- Oh yeah.


00:06:37.180 --> 00:06:39.180
So don't you think there should be like a standard,


00:06:39.180 --> 00:06:41.540
like a, they should get together like some consortium


00:06:41.540 --> 00:06:43.060
and have a standard about this.


00:06:43.060 --> 00:06:45.300
- Yeah, well they probably should,


00:06:45.300 --> 00:06:47.100
but we're still in the early stages


00:06:47.100 --> 00:06:49.420
of figuring out what the right API is.


00:06:49.420 --> 00:06:51.140
- That's right, that's why they haven't done it.


00:06:51.140 --> 00:06:53.140
- There's something else that has,


00:06:53.140 --> 00:06:54.700
that could use some standards,


00:06:54.700 --> 00:06:58.000
and that's in a lot of data science libraries.


00:06:58.000 --> 00:07:01.240
There's an announcement that there's a new consortium


00:07:01.240 --> 00:07:03.620
for Python data API standards.


00:07:03.620 --> 00:07:05.180
So there is one happening,


00:07:05.180 --> 00:07:07.280
and it's happening actually quite fast.


00:07:07.280 --> 00:07:09.400
They're getting started right away


00:07:09.400 --> 00:07:13.480
and there's activities to the announcements right away.


00:07:13.480 --> 00:07:16.100
Then in September, I believe,


00:07:16.100 --> 00:07:19.000
they're going to kick off some work on data frames


00:07:19.000 --> 00:07:21.520
or on, no, starting with arrays


00:07:21.520 --> 00:07:23.120
and then move on to data frames.


00:07:23.120 --> 00:07:25.880
And so, okay, I'm getting ahead of myself.


00:07:25.880 --> 00:07:27.600
There are little blurbs says,


00:07:27.600 --> 00:07:30.920
one of the unintended consequences of the advances


00:07:30.920 --> 00:07:32.960
in multiple frameworks for data science,


00:07:32.960 --> 00:07:37.160
machine learning, deep learning and numerical computing is that there is


00:07:37.160 --> 00:07:42.320
fragmentation and in using the tools and there are differences in common


00:07:42.320 --> 00:07:48.600
function signatures. They have one example that shows what the generally


00:07:48.600 --> 00:07:53.960
mean function to get the average or mean. People are going to like flame me for


00:07:53.960 --> 00:07:58.160
calling average mean, but as a commoner I kind of think of those the same thing.


00:07:58.160 --> 00:08:08.060
They show a different frameworks than and some of them are common with other ones and so there's five different interfaces for over the eight frameworks for just


00:08:08.060 --> 00:08:18.480
the mean function for an array. Yeah and what's crazy is like they all are basically the same they're so so similar but they're not the same not code wise the same but they might as well be.


00:08:18.480 --> 00:08:27.160
Yeah and so one of the issues is there's people are using more than one framework for different parts of their maybe different parts of their data flow


00:08:27.280 --> 00:08:34.620
And sometimes you can kind of forget which one you're using and having a lot of these things common.


00:08:34.620 --> 00:08:49.640
Actually, we just make life easier, I think. So I think I don't know how far they'll get with this, but I think it's a really, so they're trying to make all of these, these frameworks look exactly the same, but with commonalities in arrays and data frames.


00:08:49.920 --> 00:08:55.560
Or and they said note that a razor also called tensors so those are.


00:08:55.560 --> 00:09:06.800
Trying to make some of those comments are i think a really good idea for some of the easy simple stuff why not seems like a great idea it seems like a huge challenge though like who's gonna give


00:09:06.800 --> 00:09:19.900
whose functions gonna be the one that's like yeah we're dropping this part of our API to make it look like everyone else's great and that's why i think that they've been through a lot of thought on how to go about with this process and try to convince people so


00:09:19.900 --> 00:09:24.900
So they're working with, they're trying to kind of be in between the framework authors


00:09:24.900 --> 00:09:32.540
and maintainers and the community and try to do some review process for different APIs,


00:09:32.540 --> 00:09:39.260
put a proposal out, have feedback from both from the different projects and from the community


00:09:39.260 --> 00:09:43.500
to have more input to try to make it.


00:09:43.500 --> 00:09:47.740
It isn't just like one set of people saying, "Hey, I think this should be this way."


00:09:47.740 --> 00:09:49.100
Yeah, it's a good idea.


00:09:49.100 --> 00:09:53.740
It would be great if a lot of these applications or these frameworks may be renamed.


00:09:53.740 --> 00:09:58.420
If it's the same function, if it's like for instance, mean in this example, if it's spelled


00:09:58.420 --> 00:10:01.460
exactly the same, maybe it should be the same API.


00:10:01.460 --> 00:10:07.300
And if you want a special version of it, maybe have a underscore with an extra, you know,


00:10:07.300 --> 00:10:08.980
some reason why it's different.


00:10:08.980 --> 00:10:10.700
You can have extra different functions.


00:10:10.700 --> 00:10:13.900
Yeah, it seems like you could find some pretty good common ground here.


00:10:13.900 --> 00:10:14.900
It's a good idea.


00:10:14.900 --> 00:10:18.860
make it happen, you know, it'd just be easier to mix and match frameworks and


00:10:18.860 --> 00:10:23.180
use the best for different situations. Because I can certainly see you're like,


00:10:23.180 --> 00:10:26.660
"I'm working with Pandas here. It would be great if I could do this on CUDA cores


00:10:26.660 --> 00:10:31.820
with CuePy, but I don't really know that. It's close, but it's not the same. So I'm


00:10:31.820 --> 00:10:35.580
just gonna keep stroking along here." As opposed to change the import statement,


00:10:35.580 --> 00:10:39.340
now it runs there. Yep. I don't know if it's ever really gonna be like you can


00:10:39.340 --> 00:10:42.740
just swap out a different framework, but for some of the common stuff it'd really


00:10:42.740 --> 00:10:45.540
be great. And that's why one of the reasons we're bringing it up is so that


00:10:45.540 --> 00:10:49.740
people can get on board and start being part of this review process if they care


00:10:49.740 --> 00:10:52.860
about it. Yeah, also seems like there might be some room for like adaptive


00:10:52.860 --> 00:10:58.620
layers like from Coupa import pandas layer or something like that where


00:10:58.620 --> 00:11:03.660
basically you talk to the in terms of say a pandas API and it converts it to


00:11:03.660 --> 00:11:07.580
its internal. It's like oh these these arguments are switched in order or this


00:11:07.580 --> 00:11:10.500
keyword is named differently or whatever. And there's even things like


00:11:10.500 --> 00:11:17.300
differences and even if the API looks the same or it's very similar, the default might be like in


00:11:17.300 --> 00:11:23.380
some cases the default might be none versus false or versus no value or things. I don't know what


00:11:23.380 --> 00:11:31.300
no value means but anyway. Yeah cool, that's a good one. Now also good is the things that we're


00:11:31.300 --> 00:11:35.780
working on. Brian, you want to tell folks about our Patreon? Actually we've kind of silently


00:11:35.780 --> 00:11:43.020
announced it a while ago, but we have 47 patrons now and it's set up for a monthly contribution


00:11:43.020 --> 00:11:48.540
and we really appreciate people helping out because there are some expenses with the show.


00:11:48.540 --> 00:11:50.380
So that's really cool.


00:11:50.380 --> 00:11:52.100
We'd love to see that grow.


00:11:52.100 --> 00:11:56.320
We'd also like to hear from people about how we'd like to come up with some special thank


00:11:56.320 --> 00:11:57.780
you benefits for patrons.


00:11:57.780 --> 00:12:00.820
And so I'd like to have ideas come from the community.


00:12:00.820 --> 00:12:04.140
If you can come up with some ideas, we'll think about it.


00:12:04.140 --> 00:12:06.580
And I'm trying to figure out how to get to it.


00:12:06.580 --> 00:12:08.700
So on our Python Bytes--


00:12:08.700 --> 00:12:11.540
- If you're on any episode page, it's there on the right.


00:12:11.540 --> 00:12:13.620
- Okay, if you go to an episode page, got it.


00:12:13.620 --> 00:12:17.200
- Yep, and it says on the right, I believe somewhere,


00:12:17.200 --> 00:12:18.860
it says Sponsor Sun.


00:12:18.860 --> 00:12:20.380
I'll have to double check, but I believe it does.


00:12:20.380 --> 00:12:21.540
- Okay, we'll double check.


00:12:21.540 --> 00:12:24.640
- It can for sure, if it doesn't already.


00:12:24.640 --> 00:12:26.220
(laughing)


00:12:26.220 --> 00:12:28.420
And also I wanna just tell folks about a couple things


00:12:28.420 --> 00:12:30.260
going on over at Talk Python Training.


00:12:30.260 --> 00:12:33.140
We're doing a webcast on helping people move


00:12:33.140 --> 00:12:36.640
from using Excel for all their data analysis to Pandas,


00:12:36.640 --> 00:12:40.480
basically moving from Excel to the Python data science stack,


00:12:40.480 --> 00:12:41.780
which has all sorts of cool benefits


00:12:41.780 --> 00:12:43.800
and really neat things you can do there.


00:12:43.800 --> 00:12:45.540
So Chris Moffett is gonna come on


00:12:45.540 --> 00:12:46.780
and write a course with us,


00:12:46.780 --> 00:12:48.860
and he's gonna do a webcast,


00:12:48.860 --> 00:12:52.460
which I announced it like 12, 15 hours ago,


00:12:52.460 --> 00:12:54.660
and it already has like 600 people signed up for it.


00:12:54.660 --> 00:12:56.700
So it's free, people can just come sign up.


00:12:56.700 --> 00:12:59.540
It happens late September 29th.


00:12:59.540 --> 00:13:02.140
I'll put the link at the extras section of the show notes


00:13:02.140 --> 00:13:03.700
so people can find it there.


00:13:03.700 --> 00:13:05.660
And also the Python Memory Management course


00:13:05.660 --> 00:13:07.220
is out for early access.


00:13:07.220 --> 00:13:08.820
A bunch of people are signing up and enjoying it.


00:13:08.820 --> 00:13:12.680
So if you wanna get to it soon, get to it early,


00:13:12.680 --> 00:13:13.940
people can check that out as well.


00:13:13.940 --> 00:13:14.780
- Very exciting.


00:13:14.780 --> 00:13:16.380
- So this next one I wanna talk about


00:13:16.380 --> 00:13:17.820
has to do with manners.


00:13:17.820 --> 00:13:19.580
What kind of developer are you?


00:13:19.580 --> 00:13:21.060
Are you a polite developer?


00:13:21.060 --> 00:13:22.360
Are you talking to the framework?


00:13:22.360 --> 00:13:25.020
Are you, do you always check it in with it


00:13:25.020 --> 00:13:27.180
to see how it feels, what you're allowed to do?


00:13:27.180 --> 00:13:28.260
Are you kind of a rebel?


00:13:28.260 --> 00:13:29.660
You're just gonna do what you like,


00:13:29.660 --> 00:13:31.840
but every now and then you're gonna get smacked down


00:13:31.840 --> 00:13:33.880
by the framework with an exception.


00:13:33.880 --> 00:13:35.900
- I don't want to describe how a developer I am


00:13:35.900 --> 00:13:39.140
because I don't want the explicit tag on this episode.


00:13:39.140 --> 00:13:40.520
(laughing)


00:13:40.520 --> 00:13:43.280
- So there's an article that talks about something


00:13:43.280 --> 00:13:46.560
I think is pretty fun and interesting to consider


00:13:46.560 --> 00:13:51.320
and it talks about the two types of error handling patterns


00:13:51.320 --> 00:13:55.760
or mechanisms that you might use when you're writing code.


00:13:55.760 --> 00:13:58.520
And Python naturally leans towards one,


00:13:58.520 --> 00:14:01.020
but there might be times you don't want to use it.


00:14:01.020 --> 00:14:03.380
And that is, the two patterns are,


00:14:03.380 --> 00:14:06.940
it's easier to ask for forgiveness than permission.


00:14:06.940 --> 00:14:07.780
That's one.


00:14:07.780 --> 00:14:09.200
And the other one is look before you leap,


00:14:09.200 --> 00:14:12.060
or please may I, right?


00:14:12.060 --> 00:14:14.420
And with the look before you leap,


00:14:14.420 --> 00:14:16.740
it's a lot of checks,


00:14:16.740 --> 00:14:19.260
like something you might do in C code.


00:14:19.260 --> 00:14:21.820
So you would say, I'm gonna create a file.


00:14:21.820 --> 00:14:24.820
Oh, does the folder exist?


00:14:24.820 --> 00:14:25.980
If the folder doesn't exist,


00:14:25.980 --> 00:14:27.540
I'm gonna need to create the folder,


00:14:27.540 --> 00:14:29.580
and then I can put the file there.


00:14:29.580 --> 00:14:30.900
Do I have permission to write the file?


00:14:30.900 --> 00:14:32.980
Yes, okay, then I'll go ahead and write the file.


00:14:32.980 --> 00:14:35.340
Right, you're always checking if I can do this,


00:14:35.340 --> 00:14:37.540
if this is in the right state and so on.


00:14:37.540 --> 00:14:40.100
That's the look before you leap style.


00:14:40.100 --> 00:14:44.880
The ask for forgiveness style is just try


00:14:44.880 --> 00:14:47.220
with open this thing, oh, that didn't work,


00:14:47.220 --> 00:14:48.860
catch exception, right,


00:14:48.860 --> 00:14:51.620
accept some IO error or something like that.


00:14:51.620 --> 00:14:54.340
So there's reasons you might wanna use both.


00:14:54.340 --> 00:14:59.300
Python leans or nudges you towards the ask for forgiveness,


00:14:59.300 --> 00:15:00.900
try except version.


00:15:00.900 --> 00:15:03.440
The reason is, let's say you're opening a file


00:15:03.440 --> 00:15:04.780
and it's a JSON file.


00:15:04.780 --> 00:15:07.500
You might check first, does the file exist?


00:15:07.500 --> 00:15:08.760
Yes, do I have permission to read it?


00:15:08.760 --> 00:15:10.820
Yes, okay, open the file.


00:15:10.820 --> 00:15:11.700
Well, guess what?


00:15:11.700 --> 00:15:14.540
What if the file's malformed and you try to feed it over


00:15:14.540 --> 00:15:18.180
to like JSON load and you give it the file pointer,


00:15:18.180 --> 00:15:20.340
it's not gonna say, sorry, it's malformed,


00:15:20.340 --> 00:15:21.700
it's gonna raise an exception.


00:15:21.700 --> 00:15:22.940
Not gonna return it like a value,


00:15:22.940 --> 00:15:25.660
like malformed constant weird thing.


00:15:25.660 --> 00:15:27.180
It's just gonna throw an exception and say,


00:15:27.180 --> 00:15:30.340
you know, invalid thing on line seven or whatever, right?


00:15:30.340 --> 00:15:31.940
And so what that means is,


00:15:31.940 --> 00:15:34.900
even if you wanted to do the look before you leap,


00:15:34.900 --> 00:15:36.620
you probably can't test everything


00:15:36.620 --> 00:15:38.060
and you're gonna end up in a situation


00:15:38.060 --> 00:15:39.760
where you're still gonna have to have


00:15:39.760 --> 00:15:41.800
the try except block anyway.


00:15:41.800 --> 00:15:45.180
So maybe you should just always do that, right?


00:15:45.180 --> 00:15:46.020
Maybe you should just go,


00:15:46.020 --> 00:15:48.300
well, if we're gonna have to have exception handling anyway,


00:15:48.300 --> 00:15:50.860
that's just, we're gonna do exception handling


00:15:50.860 --> 00:15:53.580
as much as possible and not do these tests.


00:15:53.580 --> 00:15:56.060
So that's the, this article over here,


00:15:56.060 --> 00:15:59.120
It's on switwoski.com.


00:15:59.120 --> 00:16:00.160
- Mike Wazowski.


00:16:00.160 --> 00:16:03.320
- Oh yeah, it's on Sebastian Witowoski.


00:16:03.320 --> 00:16:06.960
So yeah, it's his, I didn't realize that it was his article.


00:16:06.960 --> 00:16:09.000
So it's his article.


00:16:09.000 --> 00:16:11.360
Anyway, he talks about like,


00:16:11.360 --> 00:16:15.120
what is the relative performance of these things


00:16:15.120 --> 00:16:17.880
and tries to talk about it from a well,


00:16:17.880 --> 00:16:19.860
sure, it's cool to think of how it looks in code,


00:16:19.860 --> 00:16:22.880
but is one faster or one slower than the other?


00:16:22.880 --> 00:16:25.540
And this actually came up on Talk Python as well.


00:16:25.540 --> 00:16:28.060
And so I said, look, if we're going to come up


00:16:28.060 --> 00:16:31.540
with an example, let's have a class and a base class,


00:16:31.540 --> 00:16:34.380
and let's have the base class define an attribute.


00:16:34.380 --> 00:16:37.320
And sometimes let's try to access the attribute.


00:16:37.320 --> 00:16:39.660
And when you don't have the base class,


00:16:39.660 --> 00:16:41.660
or when you only have the base class, it'll crash, right?


00:16:41.660 --> 00:16:42.700
'Cause it's in the derived class.


00:16:42.700 --> 00:16:45.140
So let's say we have two ways to test.


00:16:45.140 --> 00:16:48.100
We could either ask, does it have the attribute,


00:16:48.100 --> 00:16:49.820
and then try to access it,


00:16:49.820 --> 00:16:52.620
or we could just write or access it.


00:16:52.620 --> 00:16:55.820
And it says, well look, if it works all the time,


00:16:55.820 --> 00:16:57.340
and you're not actually getting errors,


00:16:57.340 --> 00:16:59.540
and you're doing this, it's 30% slower


00:16:59.540 --> 00:17:01.060
to do the look before you leap.


00:17:01.060 --> 00:17:02.860
'Cause you're doing an extra test,


00:17:02.860 --> 00:17:06.700
and basically the try-except block is more or less free,


00:17:06.700 --> 00:17:08.840
like it doesn't cost anything,


00:17:08.840 --> 00:17:10.860
if there's not actually an error.


00:17:10.860 --> 00:17:13.500
But if you turn it around, and you say,


00:17:13.500 --> 00:17:16.060
no it's not there, all of a sudden,


00:17:16.060 --> 00:17:19.260
it turns out the ask, the try-except block


00:17:19.260 --> 00:17:21.120
is four times slower.


00:17:21.120 --> 00:17:21.960
That's a lot slower.


00:17:21.960 --> 00:17:22.800
- Oh, really?


00:17:22.800 --> 00:17:25.200
- Because the raising of the exception,


00:17:25.200 --> 00:17:27.140
figuring out this call stack,


00:17:27.140 --> 00:17:28.660
all that kind of stuff is expensive.


00:17:28.660 --> 00:17:30.560
So instead of just going, does it have the attribute?


00:17:30.560 --> 00:17:33.380
You're going, well, let's do the whole call stack thing,


00:17:33.380 --> 00:17:34.440
every error, right?


00:17:34.440 --> 00:17:36.160
And create an object and throw it


00:17:36.160 --> 00:17:37.620
and all that kind of stuff.


00:17:37.620 --> 00:17:39.680
So it's a lot slower when there are errors.


00:17:39.680 --> 00:17:43.560
And anyway, it's an interesting thing to consider


00:17:43.560 --> 00:17:45.600
if you care about performance


00:17:45.600 --> 00:17:47.480
and things like parsing integers


00:17:47.480 --> 00:17:50.200
or parsing data that might sometimes fail,


00:17:50.200 --> 00:17:52.200
might not, you know, sometimes it doesn't fail.


00:17:52.200 --> 00:17:53.200
Yeah, okay.


00:17:53.200 --> 00:17:54.700
Devil's advocate here.


00:17:54.700 --> 00:17:58.100
His example doesn't have any activity


00:17:58.100 --> 00:18:01.200
in the ask for forgiveness if it isn't there.


00:18:01.200 --> 00:18:03.060
That's the way I saw it when I first read it as well.


00:18:03.060 --> 00:18:04.260
There's two sections.


00:18:04.260 --> 00:18:06.240
There's like one part where he says,


00:18:06.240 --> 00:18:08.560
let's do it with the attribute on the derived class


00:18:08.560 --> 00:18:10.780
and let's do it again a second time


00:18:10.780 --> 00:18:13.440
by taking away the attribute and seeing what it's like.


00:18:13.440 --> 00:18:16.460
Right, but I mean, the code, if it doesn't exist,


00:18:16.460 --> 00:18:17.440
it just doesn't do anything.


00:18:17.440 --> 00:18:18.280
Right, right, right.


00:18:18.280 --> 00:18:20.280
In reality, you're still going to have to do something.


00:18:20.280 --> 00:18:22.880
Notify the user it's wrong, whatever.


00:18:22.880 --> 00:18:24.380
Yeah, for sure. That's a good point.


00:18:24.380 --> 00:18:26.580
Like it's just basically a try, except pass.


00:18:26.580 --> 00:18:28.380
Yeah. So what do you think about this?


00:18:28.380 --> 00:18:34.680
So what I think is you're going to have to write the try, except anyway,


00:18:34.680 --> 00:18:36.880
almost all the time.


00:18:36.880 --> 00:18:38.880
And you don't want both.


00:18:38.880 --> 00:18:40.580
Like that doesn't seem good.


00:18:40.580 --> 00:18:43.080
That seems like just extra complexity.


00:18:43.080 --> 00:18:46.680
So when it makes sense, just go with ask for forgiveness.


00:18:46.680 --> 00:18:48.680
Just embrace exceptions, right?


00:18:48.680 --> 00:18:50.000
Remember you have a finally block


00:18:50.000 --> 00:18:53.120
that often can like get rid of a test as well.


00:18:53.120 --> 00:18:55.280
You have multiple types of error,


00:18:55.280 --> 00:18:58.440
except clauses are based on error type.


00:18:58.440 --> 00:19:00.400
I think people should do a lot with that.


00:19:00.400 --> 00:19:04.400
That said, if your goal is to like parse specific data,


00:19:04.400 --> 00:19:07.040
right, like I'm gonna read this number I got off by,


00:19:07.040 --> 00:19:09.560
off of the internet by web scraping,


00:19:09.560 --> 00:19:12.080
and there's a million records here, I'm gonna parse it.


00:19:12.080 --> 00:19:14.120
If you wanna do that a lot, lot faster,


00:19:14.120 --> 00:19:15.360
that might make a lot of sense.


00:19:15.360 --> 00:19:19.420
I actually have a gist example that I put up


00:19:19.420 --> 00:19:22.260
trying to compare the speed of these things in a mixed case.


00:19:22.260 --> 00:19:24.060
So like the cases we're looking at here


00:19:24.060 --> 00:19:26.520
are kind of strange because it's like,


00:19:26.520 --> 00:19:29.960
well, there's, it's all errors or it's zero errors, right?


00:19:29.960 --> 00:19:31.240
And then it doesn't really do anything,


00:19:31.240 --> 00:19:32.440
which are both weird.


00:19:32.440 --> 00:19:33.720
So I have this one where it comes up


00:19:33.720 --> 00:19:35.560
with like a million records, strings,


00:19:35.560 --> 00:19:39.120
and most of the time they're legitimate numbers,


00:19:39.120 --> 00:19:42.480
like 4.2 as a string, and then you can parse it.


00:19:42.480 --> 00:19:46.640
And what I found was if you have more than 4% errors,


00:19:46.640 --> 00:19:49.900
I think it was four, like 4.5% or something errors,


00:19:49.900 --> 00:19:54.320
erroneous data, it's slower to use exceptions.


00:19:54.320 --> 00:19:55.480
The cutoff is 4% errors.


00:19:55.480 --> 00:19:57.280
And I think if you have more than 4% errors,


00:19:57.280 --> 00:19:58.960
then the exceptions become more expensive.


00:19:58.960 --> 00:19:59.800
That's right.


00:19:59.800 --> 00:20:01.320
So anyway, it's something that people can run


00:20:01.320 --> 00:20:02.920
and get real numbers out of and play with it


00:20:02.920 --> 00:20:04.800
in a slightly more concrete way.


00:20:04.800 --> 00:20:06.520
But I don't know, what do you think?


00:20:06.520 --> 00:20:10.120
I think you start out by focusing on the code,


00:20:10.120 --> 00:20:12.160
making it easy and clear to understand,


00:20:12.160 --> 00:20:13.320
and then worry about this stuff.


00:20:13.320 --> 00:20:15.560
- Yeah, so I don't actually put either.


00:20:15.560 --> 00:20:18.800
I don't usually do the checking stuff.


00:20:18.800 --> 00:20:20.720
And that is one of the things that's good


00:20:20.720 --> 00:20:23.400
about bringing this up is that is more common


00:20:23.400 --> 00:20:25.960
in Python code is to not check stuff,


00:20:25.960 --> 00:20:29.220
just to just go ahead and do it.


00:20:29.220 --> 00:20:30.920
And then I write a lot of tests.


00:20:30.920 --> 00:20:32.880
So I write a lot of tests around things.


00:20:32.880 --> 00:20:33.720
- Yeah, that's cool.


00:20:33.720 --> 00:20:36.080
- And so either case, checking for things,


00:20:36.080 --> 00:20:39.360
or like for instance, if it is input,


00:20:39.360 --> 00:20:41.280
if I've got user input, I'm checking for things.


00:20:41.280 --> 00:20:43.680
I'm going to do it checks ahead of time because I want,


00:20:43.680 --> 00:20:48.800
because the behavior of what happens when it isn't there or when there's a problem,


00:20:48.800 --> 00:20:53.440
it isn't really a problem. It needs to be designed into the system as to what behavior to do


00:20:53.440 --> 00:20:58.000
when something unexpected happens. But the in normal code, like,


00:20:58.000 --> 00:21:01.440
well, what happens if there's not an attribute? Well,


00:21:01.440 --> 00:21:03.040
You shouldn't be in that situation, right?


00:21:03.040 --> 00:21:05.840
You shouldn't be in that situation. And I usually push it up higher.


00:21:05.840 --> 00:21:09.840
I don't have try except blocks all over the place. I have them around


00:21:10.400 --> 00:21:14.720
APIs that might not be trustworthy or around


00:21:14.720 --> 00:21:20.200
external systems or something. I don't put try accept locks around code that I'm calling on my own code.


00:21:20.200 --> 00:21:23.600
Things like that. Yeah, I'm with you on that. That makes a lot of sense.


00:21:23.600 --> 00:21:28.320
The one time that I'll do the test, the look before you leave style, is if I think I can fix it.


00:21:28.320 --> 00:21:30.320
Right? Does this directory not exist?


00:21:30.320 --> 00:21:32.960
I'm going to write a file to it. Well, I'm just going to make the directory.


00:21:32.960 --> 00:21:35.600
Then I'm going to write to it, you know.


00:21:35.600 --> 00:21:40.000
Those kinds of tests can get you out of trouble, but if you're just going to say this didn't work,


00:21:40.000 --> 00:21:46.960
Chances are you know, you still need the error handling and exception format anyway. Yeah, and you're probably gonna throw an exception. So yeah, anyway


00:21:46.960 --> 00:21:49.520
So you probably should uh


00:21:49.520 --> 00:21:52.800
Get your code right test it and then just stick it in github


00:21:52.800 --> 00:21:58.480
Get in your repository make sure it's all up to date, right? Oh, I was wondering how you're gonna do that transition


00:21:58.480 --> 00:22:02.160
So yeah, that's good was following a discussion on twitter


00:22:02.160 --> 00:22:05.920
And I think actually I think anthony shah may have started it


00:22:05.920 --> 00:22:17.200
but I can't remember. But dealing with different, if you've got a lot of repositories, just sometimes you have a lot of maintenance to do or a little, you know, some common things you're doing for a whole bunch of repos.


00:22:17.200 --> 00:22:33.240
And there's lots of different reasons why that might be the case or related tools or maybe just your work. You've got a lot of repos, but there's a project that came up in this discussion that I hadn't really played with before. And it's a project called My Repos.


00:22:33.800 --> 00:22:43.580
And on the site it says you've got a lot of version control repositories sometimes you want to update them all at once or push out all the local your local changes.


00:22:43.580 --> 00:22:55.480
You may use special command lines in summer repose to implement specific workflows well the my repose project provides an mr command which is a tool to manage all your version control repositories.


00:22:55.880 --> 00:22:59.160
And the way it works is it's on directory structures.


00:22:59.160 --> 00:23:03.400
So it's a, and I usually have all of my repos I'm working with under,


00:23:03.400 --> 00:23:08.600
under a common, like, projects directory or something so that I know where to look.


00:23:08.600 --> 00:23:12.280
And so I'm already set up for something like this might work.


00:23:12.280 --> 00:23:18.600
And you go into, into one of your repos and you type, if you have this installed, you type mr register,


00:23:18.600 --> 00:23:24.840
and it registers this under, registers that repo for common commands.


00:23:24.840 --> 00:23:30.440
And then whether you're in a parent tree, parent directory, or one of the specific directories,


00:23:30.440 --> 00:23:34.520
and type a command, like for instance, if you say mr status,


00:23:34.520 --> 00:23:37.840
it'll do status on all of the repos that you care about,


00:23:37.840 --> 00:23:40.920
or update, or diff, or something like that.


00:23:40.920 --> 00:23:47.560
And then you can build up even more complex commands yourself to do more complicated things.


00:23:47.560 --> 00:23:52.160
But I would, I mean, I'm probably going to use it right away just for just checking the status or doing


00:23:52.160 --> 00:23:57.640
Polls or updates or something like that on on lots of repos. So this looks neat. Yeah, it looks neat


00:23:57.640 --> 00:23:59.240
I like the idea a lot


00:23:59.240 --> 00:24:04.420
So basically I'm the same as you I've got a directory maybe a couple levels


00:24:04.420 --> 00:24:07.680
But all of my github repos go in there


00:24:07.680 --> 00:24:10.280
I group them by like personal stuff or work stuff


00:24:10.280 --> 00:24:16.960
But other than that, they're just all next to each other and this would just let you say go do a get pull on all of


00:24:16.960 --> 00:24:19.760
Them that's great. Yeah, or like for instance at work. I've got often


00:24:20.320 --> 00:24:26.720
Like three or four different related repos that if I switch to another project that I'm working on I need to go through and make


00:24:26.720 --> 00:24:31.500
Sure, I'm not sure what branch I'm using or if everything's up-to-date


00:24:31.500 --> 00:24:35.680
So being able to just go through all like even two or three


00:24:35.680 --> 00:24:41.520
Being able to go and update them all at once or just even check the status of all it'll save time


00:24:41.520 --> 00:24:48.060
And then friend of the show at least somebody that interviewed for a testing code at least Adam Johnson


00:24:48.420 --> 00:24:53.420
wrote an article called "Maintaining Multiple Python Projects with MyRepos"


00:24:53.420 --> 00:24:55.920
and we'll link to his article in the show notes.


00:24:55.920 --> 00:24:56.920
Yeah, perfect.


00:24:56.920 --> 00:24:59.420
I like this idea enough that I wrote something like that already.


00:24:59.420 --> 00:24:59.920
You did.


00:24:59.920 --> 00:25:01.920
Well, what I wrote is something that will...


00:25:01.920 --> 00:25:05.920
it'll go and actually synchronize my GitHub account


00:25:05.920 --> 00:25:09.920
with a folder structure on my computer.


00:25:09.920 --> 00:25:12.920
So I'll go and just say, like,


00:25:12.920 --> 00:25:15.420
"repo-sync" or whatever I called it,


00:25:15.420 --> 00:25:20.860
And it'll use the GitHub API to go and figure out all the repos that I've cloned


00:25:20.860 --> 00:25:25.980
or created in the different organizations like Talk Python organization versus my personal one.


00:25:25.980 --> 00:25:29.340
And then it'll create folders based on the organization or where I forked it from and


00:25:29.340 --> 00:25:33.500
then clone it. And if it's already there, it'll update it within it'll like basically pull all


00:25:33.500 --> 00:25:35.820
this down. That's cool. I need that.


00:25:35.820 --> 00:25:40.780
It was a lot of work. This seems like it's pre-built and pretty close. So it looks pretty


00:25:40.780 --> 00:25:44.540
nice. The one thing it doesn't do is it doesn't look like, doesn't go to GitHub and say, oh,


00:25:44.540 --> 00:25:46.040
"Oh, what other repos have you created


00:25:46.040 --> 00:25:47.900
"that you maybe don't have here?"


00:25:47.900 --> 00:25:49.100
You know, maybe you want that, maybe you don't.


00:25:49.100 --> 00:25:51.500
If you've like forked Windows source code


00:25:51.500 --> 00:25:54.300
and it's like 50 gigs, you don't want this tool


00:25:54.300 --> 00:25:55.140
that I'm talking about.


00:25:55.140 --> 00:25:57.120
But if you have reasonable sized things,


00:25:57.120 --> 00:25:58.980
like I forked a Linux, okay, great,


00:25:58.980 --> 00:26:00.380
that's gonna take a while.


00:26:00.380 --> 00:26:03.540
But normally it would be, I think it would be pretty neat.


00:26:03.540 --> 00:26:04.940
Another thing that's neat around managing


00:26:04.940 --> 00:26:06.540
these types of things is Docker.


00:26:06.540 --> 00:26:10.540
And did you know that Python has an official Docker image?


00:26:10.540 --> 00:26:11.740
- I did not. - I didn't either.


00:26:11.740 --> 00:26:13.100
Well, I recently heard that,


00:26:13.100 --> 00:26:15.520
but it's fairly new news to me


00:26:15.520 --> 00:26:18.360
that there's an official Docker Python image.


00:26:18.360 --> 00:26:21.440
So theoretically, if you wanna work with


00:26:21.440 --> 00:26:25.560
some kind of Linux Docker machine that uses Python,


00:26:25.560 --> 00:26:30.560
you can go and Docker run or to create the Python one, right?


00:26:30.560 --> 00:26:35.400
So it's not super surprising, it's just called Python, right?


00:26:35.400 --> 00:26:37.520
But it's, yeah, it's just called Python.


00:26:37.520 --> 00:26:38.360
That's it, I believe.


00:26:38.360 --> 00:26:40.960
So pretty straightforward working with it.


00:26:40.960 --> 00:26:45.880
But I'm gonna talk about basically looking through


00:26:45.880 --> 00:26:48.900
that official Docker image.


00:26:48.900 --> 00:26:50.980
So Itamar Turner-Trowering,


00:26:50.980 --> 00:26:52.840
he was on Talk Python not long ago,


00:26:52.840 --> 00:26:53.800
talking about Phil.


00:26:53.800 --> 00:26:55.400
We also talked about Phil on Python Bytes,


00:26:55.400 --> 00:26:58.600
the data science focused memory tool.


00:26:58.600 --> 00:26:59.720
He wrote an article called


00:26:59.720 --> 00:27:03.680
"A Deep Dive into the Official Docker Image for Python."


00:27:03.680 --> 00:27:05.480
So basically it's like,


00:27:05.480 --> 00:27:08.840
well, if there's an official Docker image for Python,


00:27:08.840 --> 00:27:09.680
what is it?


00:27:09.680 --> 00:27:10.500
How do you set it up?


00:27:10.500 --> 00:27:18.500
understanding how it's set up is basically how do you take a machine that has no Python whatsoever and configure it in a Python way.


00:27:18.500 --> 00:27:29.500
So this is using Debian. That's just what it's based on. And it's using the Buster version because apparently Debian names all their releases after characters from Toy Story.


00:27:29.500 --> 00:27:36.500
I didn't know that, but yep, Buster. Buster is the current one. So it's going to create a Docker image.


00:27:36.500 --> 00:27:39.820
you create the Docker file, you say this Docker image


00:27:39.820 --> 00:27:42.380
is based on some other foundational one,


00:27:42.380 --> 00:27:46.020
so Debian buster, and then it sets up


00:27:46.020 --> 00:27:51.020
slash user slash local slash bin for the environmental path


00:27:51.020 --> 00:27:52.540
'cause that is the first thing in the path


00:27:52.540 --> 00:27:55.300
'cause that's where it's going to put Python.


00:27:55.300 --> 00:27:59.620
It sets the locale explicitly to the ENV language


00:27:59.620 --> 00:28:01.420
is to UTF-8.


00:28:01.420 --> 00:28:03.660
There's some debate about whether this is actually necessary


00:28:03.660 --> 00:28:06.620
'cause current Python also defaults to UTF-8,


00:28:06.620 --> 00:28:08.860
but here it is.


00:28:08.860 --> 00:28:11.500
And then it also sets an environment variable,


00:28:11.500 --> 00:28:14.660
Python_version, to whatever the Python version is.


00:28:14.660 --> 00:28:16.980
Right now it's 385, but whatever it is.


00:28:16.980 --> 00:28:18.220
That's kinda cool, so you can ask,


00:28:18.220 --> 00:28:20.580
"Hey, what version is in this system


00:28:20.580 --> 00:28:22.780
"without actually touching Python?"


00:28:22.780 --> 00:28:23.820
That's cool.


00:28:23.820 --> 00:28:25.260
And then it has to do a few things


00:28:25.260 --> 00:28:28.740
like register the CA certificates.


00:28:28.740 --> 00:28:31.540
I've had people sending me messages,


00:28:31.540 --> 00:28:34.420
are taking courses and they're trying to run the code


00:28:34.420 --> 00:28:36.740
from something that talks to requests,


00:28:36.740 --> 00:28:41.740
whether it's SSL certificate endpoint, HTTPS endpoint,


00:28:41.740 --> 00:28:43.860
and they'll say, this thing says


00:28:43.860 --> 00:28:46.340
the certificate is invalid.


00:28:46.340 --> 00:28:48.420
The certificate's not valid, what's going on here?


00:28:48.420 --> 00:28:51.340
Right, and almost always, something about the way


00:28:51.340 --> 00:28:52.980
that Python got set up on their machine


00:28:52.980 --> 00:28:56.260
didn't run the create certificate command.


00:28:56.260 --> 00:28:59.660
So there's like this step where Python will go download


00:28:59.660 --> 00:29:01.300
all the major certificate authorities


00:29:01.300 --> 00:29:02.720
and like trust them in the system.


00:29:02.720 --> 00:29:04.180
So that happens next.


00:29:04.180 --> 00:29:08.760
And then it actually will set up things like GCC and whatnot


00:29:08.760 --> 00:29:11.660
so it can compile it, which is interesting.


00:29:11.660 --> 00:29:13.700
Downloads the source code, compiles it,


00:29:13.700 --> 00:29:16.280
but then what's interesting is it uninstalls


00:29:16.280 --> 00:29:18.260
the compiler tools.


00:29:18.260 --> 00:29:20.340
It's like, okay, we're gonna download Python


00:29:20.340 --> 00:29:21.420
and we're gonna compile it,


00:29:21.420 --> 00:29:24.020
but you didn't explicitly ask for GCC.


00:29:24.020 --> 00:29:26.600
We just needed it, so those are gone, right?


00:29:26.600 --> 00:29:29.760
Cleans up the PYC files and all those kinds of things.


00:29:29.760 --> 00:29:32.920
And then it gives an alias to say that Python 3


00:29:32.920 --> 00:29:35.060
is the same as Python, like the command,


00:29:35.060 --> 00:29:37.520
you could do it without the 3.


00:29:37.520 --> 00:29:39.860
Another thing that we've gone on about that's annoying


00:29:39.860 --> 00:29:41.920
is like, I created a virtual environment.


00:29:41.920 --> 00:29:43.320
Oh, it has the wrong version of pip.


00:29:43.320 --> 00:29:44.480
Is my pip out of date?


00:29:44.480 --> 00:29:45.760
Your pip's probably out of date.


00:29:45.760 --> 00:29:47.680
Everyone's pip is out of date.


00:29:47.680 --> 00:29:50.400
Unless you're like a rare, like two week window


00:29:50.400 --> 00:29:52.620
where Python has been released at the same time


00:29:52.620 --> 00:29:54.880
like the modern pip has been released.


00:29:54.880 --> 00:29:56.240
So guess what?


00:29:56.240 --> 00:29:59.520
They upgrade pip to the new version, which is cool.


00:29:59.520 --> 00:30:03.240
And then finally it sets the entry point


00:30:03.240 --> 00:30:06.340
of the Docker container, which is the default command


00:30:06.340 --> 00:30:08.840
to do if you just say Docker run this image,


00:30:08.840 --> 00:30:12.700
like Docker run Python 3.8-slim-buster.


00:30:12.700 --> 00:30:14.640
If you just say that by itself,


00:30:14.640 --> 00:30:16.520
what program is it gonna run?


00:30:16.520 --> 00:30:18.680
'Cause the way it works is it basically starts Linux


00:30:18.680 --> 00:30:20.040
and then runs one program.


00:30:20.040 --> 00:30:23.160
When that program exits, the Docker container goes away.


00:30:23.160 --> 00:30:25.600
And so it sets that to be the Python three command.


00:30:25.600 --> 00:30:30.600
So basically, if you Docker run the Python Docker image,


00:30:30.600 --> 00:30:33.400
you're going to get just the REPL.


00:30:33.400 --> 00:30:34.240
- Interesting.


00:30:34.240 --> 00:30:35.480
- Yeah, you can always run it with different endpoints


00:30:35.480 --> 00:30:37.640
like bash and then go in and like do stuff to it


00:30:37.640 --> 00:30:40.480
or run it with micro-WSGI or Nginx or whatever.


00:30:40.480 --> 00:30:45.120
But if you don't, you're just going to get Python 3 REPL.


00:30:45.120 --> 00:30:49.360
Anyway, that's the way the official Python Docker image


00:30:49.360 --> 00:30:52.700
configures itself from a bare Debian buster


00:30:52.700 --> 00:30:54.080
over to Python 3.


00:30:54.080 --> 00:30:54.920
- Neat.


00:30:54.920 --> 00:30:58.200
I thought it might be worth just thinking about like, what are all the steps?


00:30:58.200 --> 00:31:00.160
And you know, how does that happen on your computer?


00:31:00.160 --> 00:31:01.160
If you can.


00:31:01.160 --> 00:31:02.600
No, that's good.


00:31:02.600 --> 00:31:04.880
Because yeah, I have been curious about that.


00:31:04.880 --> 00:31:07.980
I was gonna throw Python on a Docker image.


00:31:07.980 --> 00:31:08.980
What does that get me?


00:31:08.980 --> 00:31:09.980
And yeah, exactly.


00:31:09.980 --> 00:31:10.980
That's what it is.


00:31:10.980 --> 00:31:16.040
Oh, you could also apt install Python 3 dash dev.


00:31:16.040 --> 00:31:19.200
Yeah, that might be cheating.


00:31:19.200 --> 00:31:20.200
All right.


00:31:20.200 --> 00:31:21.200
What's this final one?


00:31:21.200 --> 00:31:24.320
It was recommended by, we covered some craziness


00:31:24.320 --> 00:31:28.080
that Anthony did, episode or two ago,


00:31:28.080 --> 00:31:30.560
and somebody commented that maybe we need


00:31:30.560 --> 00:31:32.720
only in a pandemic section.


00:31:32.720 --> 00:31:34.040
- Oh yeah, that sounds fun.


00:31:34.040 --> 00:31:39.040
- So I selected Nanormost, no, sorry, Nanornest.


00:31:39.040 --> 00:31:42.960
It's optimal peanut butter and banana sandwich placement.


00:31:42.960 --> 00:31:45.700
So this is kind of an awesome article


00:31:45.700 --> 00:31:48.960
by Ethan Rosenthal, talks about during the pandemic,


00:31:48.960 --> 00:31:52.680
He's been sort of having trouble doing anything.


00:31:52.680 --> 00:31:55.220
And so he really liked peanut butter sandwich,


00:31:55.220 --> 00:31:58.160
peanut butter and banana sandwiches when he was just still,


00:31:58.160 --> 00:32:01.000
even he got picked this habit up from his grandfather,


00:32:01.000 --> 00:32:01.960
I think.


00:32:01.960 --> 00:32:05.400
Anyway, this is using Python and computer vision


00:32:05.400 --> 00:32:07.380
and deep learning and machine learning


00:32:07.380 --> 00:32:09.120
and a whole bunch of cool libraries


00:32:09.120 --> 00:32:12.340
to come up with the best packing algorithm


00:32:12.340 --> 00:32:14.000
for a particular banana


00:32:14.000 --> 00:32:16.640
and the particular bread that you have.


00:32:16.640 --> 00:32:19.720
So you take a picture that includes both the bread


00:32:19.720 --> 00:32:22.780
and the bananas, or the banana you have,


00:32:22.780 --> 00:32:25.280
and it will come up with the optimal slicing


00:32:25.280 --> 00:32:29.200
and placement of the banana for your banana sandwich.


00:32:29.200 --> 00:32:32.260
- Wow, this is like a banana maximization


00:32:32.260 --> 00:32:33.680
optimization problem.


00:32:33.680 --> 00:32:36.400
So if you want, you gotta see the pictures to get this.


00:32:36.400 --> 00:32:39.840
So like, if you're gonna cut your banana into slices,


00:32:39.840 --> 00:32:43.440
and obviously the radius of the banana slice varies


00:32:43.440 --> 00:32:45.200
at where you cut it in the banana, right?


00:32:45.200 --> 00:32:46.200
Is it near the top?


00:32:46.200 --> 00:32:47.200
Is it in the middle?


00:32:47.200 --> 00:32:49.160
It's going to result in different size slices.


00:32:49.160 --> 00:32:56.640
On where do you place the banana circles on your bread to have maximum surface area of


00:32:56.640 --> 00:32:59.320
bananas relative to what's left of the bread, right?


00:32:59.320 --> 00:33:00.320
Something like that?


00:33:00.320 --> 00:33:01.320
Yes.


00:33:01.320 --> 00:33:05.960
He's trying to make it so that you have almost all of the bites of the sandwich have an equal


00:33:05.960 --> 00:33:08.600
ratio of banana, peanut butter, and bread.


00:33:08.600 --> 00:33:09.600
Oh yeah, okay.


00:33:09.600 --> 00:33:10.600
It's all about the flavor.


00:33:10.600 --> 00:33:13.660
I didn't understand the real motivation,


00:33:13.660 --> 00:33:16.820
but yeah, you wanna have an equal layer, right?


00:33:16.820 --> 00:33:19.180
So you don't want that spot where you just get bread.


00:33:19.180 --> 00:33:20.620
- You actually learn quite a bit


00:33:20.620 --> 00:33:22.780
about all these different processes,


00:33:22.780 --> 00:33:25.120
and there's quite a bit of math here.


00:33:25.120 --> 00:33:29.200
Talking about coming up with arcs for,


00:33:29.200 --> 00:33:31.200
you have to estimate the banana shape


00:33:31.200 --> 00:33:33.460
as part of an ellipse,


00:33:33.460 --> 00:33:38.460
and using the radius of that to determine banana slices,


00:33:38.580 --> 00:33:43.060
and estimates for, because you're looking at a banana sideways, you have to estimate


00:33:43.060 --> 00:33:48.580
what the shape of the banana circle will be, and it's not really a circle, it's more of


00:33:48.580 --> 00:33:49.580
an ellipse also.


00:33:49.580 --> 00:33:52.820
Yeah, there's a lot going on here.


00:33:52.820 --> 00:33:57.620
Some advanced stuff to deliver your bananas perfectly.


00:33:57.620 --> 00:33:58.620
I love it.


00:33:58.620 --> 00:33:59.620
Actually, this is really interesting.


00:33:59.620 --> 00:34:00.620
This is cool.


00:34:00.620 --> 00:34:03.860
And it's, I mean, it's a silly application, but it's also a neat example.


00:34:03.860 --> 00:34:19.620
Yeah, actually, and this would be, I think, a cool thing for to talk about difficult problems and packing for like a teaching, like in a school setting. I think this would be a great example to talk about some of these different complex problems. Yeah, totally.


00:34:20.380 --> 00:34:22.180
Well, that's it for our main items.


00:34:22.180 --> 00:34:26.820
For the extras, I just want to say I'll put the links for the Excel and Python webcasts


00:34:26.820 --> 00:34:30.180
in the memory management course down there, and we'll put the Patreon link as well.


00:34:30.180 --> 00:34:32.100
Let's see, do you have anything else you want to share?


00:34:32.100 --> 00:34:33.100
No, that's good.


00:34:33.100 --> 00:34:34.100
Yeah, cool.


00:34:34.100 --> 00:34:35.100
How about sharing a joke?


00:34:35.100 --> 00:34:36.100
A joke would be great.


00:34:36.100 --> 00:34:41.660
So I'm going to describe the situation, and you can be the interviewer/boss who has the


00:34:41.660 --> 00:34:42.660
caption, okay?


00:34:42.660 --> 00:34:43.660
Okay.


00:34:43.660 --> 00:34:45.420
So the first, there's two scenarios.


00:34:45.420 --> 00:34:47.500
The title is "Job Requirements."


00:34:47.500 --> 00:34:49.180
This comes to us from Eduardo Orochenas.


00:34:49.180 --> 00:34:51.180
Thanks for that.


00:34:51.180 --> 00:34:57.240
And the first scenario is the job interview, where you're getting hired.


00:34:57.240 --> 00:35:02.140
And then there's the reality, which is later, which is the actual on-the-job day-to-day.


00:35:02.140 --> 00:35:06.980
So on the job interview, I come in, I'm an applicant here, and Brian, the boss, says,


00:35:06.980 --> 00:35:09.380
"Invert a binary tree on this whiteboard."


00:35:09.380 --> 00:35:14.940
Or some other random data structure, like quicksort this, but using some other weird


00:35:14.940 --> 00:35:15.940
thing, right?


00:35:15.940 --> 00:35:19.940
kind of really computer science-y way out there.


00:35:19.940 --> 00:35:22.940
Probably not going to do, but maybe it makes sense, right?


00:35:22.940 --> 00:35:25.940
Alright, now I'm at the job and I've got like my computer,


00:35:25.940 --> 00:35:28.940
I have a huge purple buy button on my website that I'm working on.


00:35:28.940 --> 00:35:31.940
And the bot says, "Make the button bigger!"


00:35:31.940 --> 00:35:33.940
Yep, that's the job.


00:35:33.940 --> 00:35:35.940
[laughter]


00:35:35.940 --> 00:35:38.940
Yeah. Very nice.


00:35:38.940 --> 00:35:41.940
Good, good. Alright, well, I love the jokes and all the tech we're covering.


00:35:41.940 --> 00:35:42.940
Thanks, Brian.


00:35:42.940 --> 00:35:43.940
Yeah, thank you.


00:35:43.940 --> 00:35:48.660
Bye. Thank you for listening to Python Bytes. Follow the show on Twitter via @pythonbytes.


00:35:48.660 --> 00:35:54.900
That's Python Bytes as in B-Y-T-E-S. And get the full show notes at pythonbytes.fm.


00:35:54.900 --> 00:35:58.980
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.


00:35:58.980 --> 00:36:03.780
We're always on the lookout for sharing something cool. On behalf of myself and Brian Okken,


00:36:03.780 --> 00:36:07.780
this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and

