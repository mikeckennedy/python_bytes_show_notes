
00:00:00.000 --> 00:00:05.360
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.


00:00:05.360 --> 00:00:11.760
This is episode 273, recorded March 1st, 2022. And I'm Brian Okken.


00:00:11.760 --> 00:00:13.040
I'm Michael Kennedy.


00:00:13.040 --> 00:00:16.240
Well, welcome, Michael. It's good to have us here.


00:00:16.240 --> 00:00:22.240
So it's great to see you, as always. It feels like spring is almost here. It's March. I can't


00:00:22.240 --> 00:00:26.080
believe it. So pretty awesome. Yeah. Fun to be talking Python with you.


00:00:26.080 --> 00:00:29.440
Yeah. So should we kick it off with your first item?


00:00:29.440 --> 00:00:30.440
Let's do it.


00:00:30.440 --> 00:00:35.440
I'm a big fan of science, math, and all those things.


00:00:35.440 --> 00:00:39.200
And I came across this article because I was reading about science, not because I was reading


00:00:39.200 --> 00:00:40.360
about Python.


00:00:40.360 --> 00:00:43.280
But then I thought, "Oh, there has to be a Python story here.


00:00:43.280 --> 00:00:45.240
Let's get into it and see if I can track it down."


00:00:45.240 --> 00:00:47.160
And wow, was it not easy to find.


00:00:47.160 --> 00:00:48.160
So here's the deal.


00:00:48.160 --> 00:00:54.400
I saw an article over on sciencealert.com called "Physics Breakthrough as AI Successfully


00:00:54.400 --> 00:00:58.320
Controls Plasma in a Nuclear Fusion Experiment."


00:00:58.320 --> 00:00:59.320
That's so cool.


00:00:59.320 --> 00:01:00.560
- That's amazing, right?


00:01:00.560 --> 00:01:01.840
So let me put a few things together here.


00:01:01.840 --> 00:01:04.000
Nuclear fusion, not fission,


00:01:04.000 --> 00:01:05.880
that's the kind of nuclear we want.


00:01:05.880 --> 00:01:09.880
That is harnessing the sun with no negative effects


00:01:09.880 --> 00:01:13.440
to turn hydrogen into helium and so on, right?


00:01:13.440 --> 00:01:15.040
If we could harness that,


00:01:15.040 --> 00:01:18.520
that's like free, super easy energy forever.


00:01:18.520 --> 00:01:19.760
It's incredible, right?


00:01:19.760 --> 00:01:22.040
So people have been working on this for a long time.


00:01:22.040 --> 00:01:24.240
The way that I understand,


00:01:24.240 --> 00:01:28.560
which is probably pretty piecemeal that it works


00:01:28.560 --> 00:01:33.100
is you put some kind of thing, some kind of material


00:01:33.100 --> 00:01:35.020
like hydrogen or something in the middle,


00:01:35.020 --> 00:01:38.040
and then you blast it with tons of energy,


00:01:38.040 --> 00:01:39.420
but then it creates this plasma.


00:01:39.420 --> 00:01:42.220
You've got to control with lasers and magnets


00:01:42.220 --> 00:01:45.940
on how you basically keep the pressure high enough


00:01:45.940 --> 00:01:47.520
in addition to just the heat


00:01:47.520 --> 00:01:50.140
to actually make the fusion work, right?


00:01:50.140 --> 00:01:53.300
So there's been some success like,


00:01:53.300 --> 00:01:55.640
hey, we got fusion to work for a while.


00:01:55.640 --> 00:01:57.340
It just took more energy than it put out.


00:01:57.340 --> 00:01:59.980
So, you know, it's not a super great power plant,


00:01:59.980 --> 00:02:02.580
but it did do the science thing, right?


00:02:02.580 --> 00:02:03.420
- Yeah.


00:02:03.420 --> 00:02:04.520
- So, here's the deal.


00:02:04.520 --> 00:02:07.980
This article says they've used artificial intelligence


00:02:07.980 --> 00:02:10.380
to teach it how to make instantaneous


00:02:10.380 --> 00:02:13.180
or near instantaneous adjustments to the magnetic field


00:02:13.180 --> 00:02:17.840
and the lasers in order to actually get better results


00:02:17.840 --> 00:02:19.220
with fusion, right?


00:02:19.220 --> 00:02:20.940
So, take it farther along.


00:02:20.940 --> 00:02:23.500
And it says, "In a joint effort,


00:02:23.500 --> 00:02:25.700
"the Swiss Plasma Center


00:02:25.700 --> 00:02:28.700
and artificial intelligence research company, DeepMind,


00:02:28.700 --> 00:02:31.340
they used deep reinforcement learning


00:02:31.340 --> 00:02:34.660
to study the nuances of plasma behavior and control


00:02:34.660 --> 00:02:38.740
inside a fusion tokamak, that's the donut shaped thing


00:02:38.740 --> 00:02:41.340
where the reaction happens.


00:02:41.340 --> 00:02:44.300
And they're able to make a bunch of small adjustments


00:02:44.300 --> 00:02:48.580
really quickly in order to get better results.


00:02:48.580 --> 00:02:51.860
And it's pretty wild that they did that with AI, isn't it?


00:02:51.860 --> 00:02:54.100
- Yeah, there's definitely Python in there somewhere,


00:02:54.100 --> 00:02:55.100
you just know it.


00:02:55.100 --> 00:02:55.580
Exactly.


00:02:55.580 --> 00:02:56.620
So I'm like, all right, where is this?


00:02:56.620 --> 00:03:00.780
So I went through and they talk about the findings being in nature, some of


00:03:00.780 --> 00:03:02.100
the articles that they're referencing.


00:03:02.100 --> 00:03:06.660
So there's some like deep as in not super engaging sort of scientific


00:03:06.660 --> 00:03:09.860
articles, like the traditional academic style of writing that you've got to


00:03:09.860 --> 00:03:13.980
dive into and then like follow a bunch of links, but eventually in there, you


00:03:13.980 --> 00:03:20.980
will find that there is some cool science stuff going on and Python is at the heart


00:03:20.980 --> 00:03:26.500
of it. So, it's probably not worth going into too much of the details of how it it's


00:03:26.500 --> 00:03:30.740
actually happening, but it's the, the Python side of things, but I just thought it was


00:03:30.740 --> 00:03:35.300
super cool that, look, here's one of the most exciting things happening in energy and for


00:03:35.300 --> 00:03:40.780
the climate and for all sorts of things. And AI and Python are pushing it forward. That's


00:03:40.780 --> 00:03:46.540
crazy. And that's what we need for a Mr. Fusion so that we can make flying cars and, and,


00:03:46.540 --> 00:03:47.700
time traveling cars too.


00:03:47.700 --> 00:03:48.620
Exactly.


00:03:48.620 --> 00:03:52.820
I mean, Marty McFly and doc, they go and they throw their, their banana peel


00:03:52.820 --> 00:03:54.240
on the back of the DeLorean, right?


00:03:54.240 --> 00:03:57.260
You've got to have one of these token mugs to make it roll and got to have Python.


00:03:57.260 --> 00:03:57.460
Yeah.


00:03:57.460 --> 00:03:57.860
Car.


00:03:57.860 --> 00:03:58.340
Come on.


00:03:58.340 --> 00:03:59.300
Obviously.


00:03:59.300 --> 00:04:00.420
So cool.


00:04:00.420 --> 00:04:02.220
All right.


00:04:02.220 --> 00:04:04.460
Well, take us back to something more concrete.


00:04:04.460 --> 00:04:05.520
Well, okay.


00:04:05.520 --> 00:04:06.780
So I'm pretty excited about this.


00:04:06.780 --> 00:04:10.140
It's a minor thing, but maybe not too minor.


00:04:10.140 --> 00:04:15.980
Uh, pep six 80 has been, accepted standards track for Python 3 11.


00:04:15.980 --> 00:04:19.700
PEP 680 is TOMLib support.


00:04:19.700 --> 00:04:23.020
So support for parsing TOML in the standard library.


00:04:23.020 --> 00:04:24.420
We haven't had it yet.


00:04:24.420 --> 00:04:27.180
>> That's awesome. We've got JSON,


00:04:27.180 --> 00:04:28.500
we've got CSV, why not?


00:04:28.500 --> 00:04:28.780
>> Right.


00:04:28.780 --> 00:04:29.460
>> We've got XML.


00:04:29.460 --> 00:04:38.180
>> Well, and now that PEP uses TOML for pyproject.toml.


00:04:38.180 --> 00:04:43.020
Anyway, I think it'd be cool to have in the standard library.


00:04:43.020 --> 00:04:45.700
I think it's fine to have other outside supports.


00:04:45.700 --> 00:04:51.700
So what they're doing is, and if people don't, there's some rationale here, but


00:04:51.700 --> 00:04:54.220
you know, just think it's easier than normal.


00:04:54.220 --> 00:05:00.720
So Toml is I like Toml for, because it's just, I don't know, it's an easy format


00:05:00.720 --> 00:05:03.580
to read, it's better than any and some other stuff.


00:05:03.580 --> 00:05:04.540
And


00:05:04.540 --> 00:05:09.400
for people who don't know, it feels any like, like the dot I and I file style


00:05:09.400 --> 00:05:12.640
where you've kind of got like section headers and then key value bits.


00:05:12.640 --> 00:05:13.140
Yeah.


00:05:13.160 --> 00:05:17.200
And it doesn't, and often it doesn't, like you can use,


00:05:17.200 --> 00:05:20.600
you can use black and write a pyproject.toml file


00:05:20.600 --> 00:05:22.840
without even really knowing anything about toml.


00:05:22.840 --> 00:05:24.880
So it's pretty straightforward,


00:05:24.880 --> 00:05:27.400
but we didn't have a way built into standard library


00:05:27.400 --> 00:05:28.220
to just use it.


00:05:28.220 --> 00:05:31.280
So this is this pep.


00:05:31.280 --> 00:05:32.520
One of the things there,


00:05:32.520 --> 00:05:36.040
interesting bits about it is it's only reading.


00:05:36.040 --> 00:05:40.120
So it's only adding support for reading toml.


00:05:40.120 --> 00:05:43.320
So there's a load and a load s.


00:05:43.320 --> 00:05:47.600
So you can load a Toml file or you can load a string


00:05:47.600 --> 00:05:48.700
and that's it.


00:05:48.700 --> 00:05:51.960
And it outputs a dictionary.


00:05:51.960 --> 00:05:55.160
So that makes sense.


00:05:55.160 --> 00:05:58.000
You're just getting a Toml object


00:05:58.000 --> 00:06:01.440
and turning it into a dictionary so you can use it.


00:06:01.440 --> 00:06:06.380
But this is built on top of Tomly.


00:06:06.380 --> 00:06:11.380
So Tomly is being used as the library to basically,


00:06:11.380 --> 00:06:14.500
there's an open source project called Tomly,


00:06:14.500 --> 00:06:17.300
which a lot of projects are using.


00:06:17.300 --> 00:06:19.480
I think this is the one that pytest is using


00:06:19.480 --> 00:06:22.140
and quite a few projects have switched to this.


00:06:22.140 --> 00:06:23.780
It's really fast, it's nice,


00:06:23.780 --> 00:06:26.660
but it supports like writing as well, but--


00:06:26.660 --> 00:06:28.740
- Yeah, writing and code and dump ass


00:06:28.740 --> 00:06:30.860
and all those things. - Yeah, right.


00:06:30.860 --> 00:06:33.380
But that's not the part that's gonna get supported.


00:06:33.380 --> 00:06:38.380
And I think that's fine to just have reading built into.


00:06:38.380 --> 00:06:43.660
- Sure, some file formats like text and CSV and whatnot,


00:06:43.660 --> 00:06:46.700
like reading and writing is super common, right?


00:06:46.700 --> 00:06:49.420
But these are way more likely to be used


00:06:49.420 --> 00:06:52.380
as configuration files that drive app startup


00:06:52.380 --> 00:06:53.860
and like hide secrets.


00:06:53.860 --> 00:06:55.020
You know, you put your secrets in there


00:06:55.020 --> 00:06:57.660
and don't put in Git or something like that, whatever, right?


00:06:57.660 --> 00:07:00.180
Those are the kind of use cases I would see.


00:07:00.180 --> 00:07:02.380
And so in that case, reading seems fine.


00:07:02.380 --> 00:07:03.560
You could always add writing later.


00:07:03.560 --> 00:07:05.740
You just can't take it away if you add it too soon.


00:07:05.740 --> 00:07:07.700
- Right, right.


00:07:07.700 --> 00:07:10.860
But also like, I don't,


00:07:10.860 --> 00:07:14.060
and I'm sure there are reasons to need to write it,


00:07:14.060 --> 00:07:16.500
but I don't.


00:07:16.500 --> 00:07:19.420
You know, it's mostly people write it


00:07:19.420 --> 00:07:21.100
and computers read it sort of thing.


00:07:21.100 --> 00:07:22.420
- Yeah, exactly.


00:07:22.420 --> 00:07:24.540
Some kind of editor writes it and then you read it.


00:07:24.540 --> 00:07:25.820
- Yeah, so.


00:07:25.820 --> 00:07:26.940
- Fantastic.


00:07:26.940 --> 00:07:27.780
All right, well, cool.


00:07:27.780 --> 00:07:29.980
Very nice to see that one coming along.


00:07:31.100 --> 00:07:32.780
Elvaro out in the audience.


00:07:32.780 --> 00:07:33.620
Hello there.


00:07:33.620 --> 00:07:37.320
It says, "TOML just reached version 1.0, not so long ago."


00:07:37.320 --> 00:07:40.220
So maybe that also has some kind of impact


00:07:40.220 --> 00:07:41.780
on the willingness, like, all right,


00:07:41.780 --> 00:07:43.360
the file format is stable.


00:07:43.360 --> 00:07:45.760
Now we can actually start to support it in the library.


00:07:45.760 --> 00:07:46.600
- That's true.


00:07:46.600 --> 00:07:50.380
And we do support Python releases for a long time.


00:07:50.380 --> 00:07:53.820
So it probably needed to be V1 at least.


00:07:53.820 --> 00:07:55.460
So yeah.


00:07:55.460 --> 00:07:58.180
- And Sam also says, "There's a lot of stylistic choices


00:07:58.180 --> 00:08:00.020
for how you write TOML files."


00:08:00.020 --> 00:08:05.400
like we need a black for Tomo, not, not to drive Tom, not to configure black,


00:08:05.400 --> 00:08:10.020
but something that then goes against Tomo files and, you know, makes them consistent.


00:08:10.020 --> 00:08:12.440
Yeah, maybe.


00:08:12.440 --> 00:08:13.040
Yeah.


00:08:13.040 --> 00:08:13.200
Yeah.


00:08:13.200 --> 00:08:14.960
But you could, yeah, you can, you could bake that in.


00:08:14.960 --> 00:08:16.040
All right.


00:08:16.040 --> 00:08:17.360
What have I got next here?


00:08:17.360 --> 00:08:20.980
I've got, sticking on the internals here.


00:08:20.980 --> 00:08:23.460
I want to talk about thread locals in Python.


00:08:23.460 --> 00:08:24.020
Okay.


00:08:24.020 --> 00:08:30.380
So last time we had Calvin on and I spoke about this crazy async


00:08:30.380 --> 00:08:31.820
running thing that I had built.


00:08:31.820 --> 00:08:33.220
And boy, is it working?


00:08:33.220 --> 00:08:36.580
Well, I, like I said, it is truly horrifying to think about what it's doing,


00:08:36.580 --> 00:08:38.740
but it actually works perfectly.


00:08:38.740 --> 00:08:39.600
So there it is.


00:08:39.600 --> 00:08:44.740
But one of the challenges that it has is it, it doesn't like it.


00:08:44.740 --> 00:08:47.060
If you call back into it again.


00:08:47.060 --> 00:08:51.900
And I talked about the, the nest async IO project last time,


00:08:51.900 --> 00:08:53.660
which maybe we'll solve it.


00:08:53.740 --> 00:08:55.780
I tried those and it wasn't working,


00:08:55.780 --> 00:08:57.940
but it could have been like at a different iteration


00:08:57.940 --> 00:08:59.240
before I finally realized like,


00:08:59.240 --> 00:09:02.140
no, I have to go all in on this threading,


00:09:02.140 --> 00:09:03.880
like isolate all that execution


00:09:03.880 --> 00:09:05.780
into one place where we can control it.


00:09:05.780 --> 00:09:06.860
So maybe it would work,


00:09:06.860 --> 00:09:10.340
but I just wanted to talk about thread locals in Python,


00:09:10.340 --> 00:09:13.380
which I thought were pretty easy and pretty interesting.


00:09:13.380 --> 00:09:15.900
So I've got this stuff running over there.


00:09:15.900 --> 00:09:18.100
And one thing that would be nice is each,


00:09:18.100 --> 00:09:20.220
there's different threads calling into the system


00:09:20.220 --> 00:09:22.400
to say schedule some work for me, basically.


00:09:22.400 --> 00:09:24.160
puts it on a queue, the queue runs it on this


00:09:24.160 --> 00:09:27.200
like controlled loop and then it sends back the result.


00:09:27.200 --> 00:09:30.720
The problem is if one function calls that to put in work


00:09:30.720 --> 00:09:32.160
and then as part of doing that work,


00:09:32.160 --> 00:09:34.680
the function itself somewhere deep down,


00:09:34.680 --> 00:09:36.320
like wraps that around,


00:09:36.320 --> 00:09:39.040
it doesn't really like the recursion aspect very much.


00:09:39.040 --> 00:09:40.840
So what I thought is, well, how do I figure out,


00:09:40.840 --> 00:09:43.640
well, this thread has running work.


00:09:43.640 --> 00:09:45.320
And if it calls again, you know,


00:09:45.320 --> 00:09:46.760
raise an exception and say,


00:09:46.760 --> 00:09:48.720
like you need to adjust the way you're calling this library,


00:09:48.720 --> 00:09:49.560
it's not working right.


00:09:49.560 --> 00:09:51.560
Instead of just like doing some weird thing.


00:09:51.560 --> 00:09:54.100
So what I think I might do,


00:09:54.100 --> 00:09:56.360
and I'm not totally sure it will work perfectly,


00:09:56.360 --> 00:10:00.140
but the idea is certainly useful for all sorts of things,


00:10:00.140 --> 00:10:02.700
is to use a thread local variable.


00:10:02.700 --> 00:10:04.500
Now, when I thought about thread local variables,


00:10:04.500 --> 00:10:06.160
I've used them in other languages,


00:10:06.160 --> 00:10:08.140
and I had no idea how to do them in Python.


00:10:08.140 --> 00:10:10.960
It turns out to be incredibly easy.


00:10:10.960 --> 00:10:13.020
You just say, go to threading, the threading module,


00:10:13.020 --> 00:10:14.120
and you say local.


00:10:14.120 --> 00:10:16.380
That becomes like a dynamic class


00:10:16.380 --> 00:10:18.020
that you can just start assigning values to.


00:10:18.020 --> 00:10:19.820
So in the example that I'm linking to,


00:10:19.820 --> 00:10:24.820
It says you get a my data thing, which is a thread local data blob, whatever.


00:10:24.820 --> 00:10:29.840
So you could say like, my data dot X equals one, my data dot list equals.


00:10:29.840 --> 00:10:30.720
Whatever.


00:10:30.720 --> 00:10:35.480
And then that will store that data, but it will store it on a per thread basis.


00:10:35.480 --> 00:10:37.600
So each thread has, sees a different value.


00:10:37.600 --> 00:10:41.960
So for example, what I could do is say, the red, you know, at the beginning of


00:10:41.960 --> 00:10:44.000
the call, like I have running work.


00:10:44.000 --> 00:10:44.880
Yes.


00:10:44.880 --> 00:10:47.120
At the end, you know, roll that back.


00:10:47.120 --> 00:10:53.220
And if I ever call into schedule some work and the thread local says, I'm doing, I have active work running.


00:10:53.220 --> 00:10:54.920
Well, there's that error case that I talked about.


00:10:54.920 --> 00:11:02.280
And I don't have to do weird things like put different IDs of threads into database, into like a dictionary and then like check that and then lock it.


00:11:02.280 --> 00:11:07.880
And like, I'll search, I can just say this thread has like a running state for my little scenario.


00:11:07.880 --> 00:11:08.440
What do you think?


00:11:08.440 --> 00:11:09.720
I think that's great.


00:11:09.720 --> 00:11:10.680
I think it's interesting.


00:11:10.680 --> 00:11:11.520
Yeah, it is.


00:11:11.520 --> 00:11:11.800
Right?


00:11:11.800 --> 00:11:12.280
Yeah.


00:11:12.280 --> 00:11:14.000
And it's right.


00:11:14.000 --> 00:11:14.680
Not too hard.


00:11:14.680 --> 00:11:16.200
just create one of these little local things,


00:11:16.200 --> 00:11:17.540
interact with it in a thread,


00:11:17.540 --> 00:11:20.680
and each thread will have basically its own view into that data,


00:11:20.680 --> 00:11:23.040
which I think is pretty fantastic.


00:11:23.040 --> 00:11:27.080
>> Like a thread version namespace thing.


00:11:27.080 --> 00:11:28.800
>> Yes, exactly.


00:11:28.800 --> 00:11:31.240
It's a cool little isolation without doing


00:11:31.240 --> 00:11:33.920
locks and all weird stuff that can end up in


00:11:33.920 --> 00:11:36.680
deadlocks or slowdowns or other stuff.


00:11:36.680 --> 00:11:40.320
Anyway, if you've got scenarios where you're doing threading,


00:11:40.320 --> 00:11:42.160
and you're like, "Oh, it would be really great if I could dedicate


00:11:42.160 --> 00:11:46.380
some data just to this particular run and not like a global thing.


00:11:46.380 --> 00:11:49.980
Check this out, it's incredibly nice.


00:11:49.980 --> 00:11:50.580
>> Nice.


00:11:50.580 --> 00:11:54.460
>> Let me pull up one more thing before we move on, Brian.


00:11:54.460 --> 00:11:55.820
>> Okay.


00:11:55.820 --> 00:11:57.820
>> How about Datadog?


00:11:57.820 --> 00:12:02.300
>> Yes. That's also something else that's extremely easy to use.


00:12:02.300 --> 00:12:05.380
Yeah. Thank you Datadog for sponsoring this episode.


00:12:05.380 --> 00:12:10.200
Datadog is a real-time monitoring platform that unifies metrics,


00:12:10.200 --> 00:12:13.740
traces and logs into one tightly integrated platform.


00:12:13.740 --> 00:12:18.180
Datadog APM empowers developer teams to identify anomalies,


00:12:18.180 --> 00:12:21.560
resolve issues, and improve application performance.


00:12:21.560 --> 00:12:23.220
Begin collecting stack traces,


00:12:23.220 --> 00:12:25.400
visualize them as flame graphs,


00:12:25.400 --> 00:12:29.980
and organize them into profile types such as CPU, IO, and more.


00:12:29.980 --> 00:12:32.140
Teams can search for specific profiles,


00:12:32.140 --> 00:12:34.120
correlate them with distributed traces,


00:12:34.120 --> 00:12:39.040
and identify slow or underperforming code for analysis and optimization.


00:12:39.040 --> 00:12:42.040
Plus with Datadog's APM live search,


00:12:42.040 --> 00:12:46.080
you can perform searches across the full stream of


00:12:46.080 --> 00:12:48.200
integrated traces generated by


00:12:48.200 --> 00:12:51.640
your application over the last 15 minutes. That's cool.


00:12:51.640 --> 00:12:56.300
Try Datadog APM with a 14-day free trial,


00:12:56.300 --> 00:12:58.340
and Datadog will send you a free t-shirt.


00:12:58.340 --> 00:13:03.280
Visit pythonbytes.fm/datadog, or just click


00:13:03.280 --> 00:13:06.760
the link in your podcast player show notes to get started.


00:13:06.760 --> 00:13:08.360
>> Yes. Thank you, Datadog.


00:13:08.360 --> 00:13:10.520
I love all the visibility into what's going on.


00:13:10.520 --> 00:13:13.520
I was just dealing with some crashes and other issues on my,


00:13:13.520 --> 00:13:15.520
on something I was trying to roll out.


00:13:15.520 --> 00:13:18.400
Some libraries conflicting with some other library, they were fighting.


00:13:18.400 --> 00:13:22.320
And yeah, it's great to be able to just log in and see what's going on.


00:13:22.320 --> 00:13:24.320
Now, before we move off this ThreadLocals,


00:13:24.320 --> 00:13:26.320
quick audience question.


00:13:26.320 --> 00:13:28.720
Sam out there says, "It might be better to use context vars


00:13:28.720 --> 00:13:30.920
if you're also working with an invent loop.


00:13:30.920 --> 00:13:34.840
As far as I know, context vars are the evolved version of ThreadLocals


00:13:34.840 --> 00:13:36.840
that are aware of async too."


00:13:36.840 --> 00:13:38.020
That's very interesting.


00:13:38.020 --> 00:13:39.800
I haven't done anything with context bars,


00:13:39.800 --> 00:13:43.000
but the way async IO works is,


00:13:43.000 --> 00:13:45.480
even though there's a bunch of stuff running from different locations,


00:13:45.480 --> 00:13:48.180
there's one thread. So thread local is useless for that.


00:13:48.180 --> 00:13:50.940
So that's why Sam is suggesting context bars.


00:13:50.940 --> 00:13:55.820
The side that schedules the work has nothing to do with async IO in my world.


00:13:55.820 --> 00:13:57.760
So that's why I was thinking thread local.


00:13:57.760 --> 00:14:01.800
>> It's a good highlight to say if you're using async,


00:14:01.800 --> 00:14:03.980
you may need something different.


00:14:03.980 --> 00:14:06.620
>> Absolutely. Yeah. Thanks, Dan, for that.


00:14:06.620 --> 00:14:09.380
>> Yeah. I'm not sure if we've really talked about it much,


00:14:09.380 --> 00:14:15.380
but I came across that article from Trey Hunter called,


00:14:15.380 --> 00:14:17.900
"What is a generator function?"


00:14:17.900 --> 00:14:22.420
Like Python, especially the two to three switch,


00:14:22.420 --> 00:14:28.640
even like the items keyword function to get all the dictionary elements out,


00:14:28.640 --> 00:14:30.500
it doesn't return a list anymore,


00:14:30.500 --> 00:14:32.540
it returns a generator.


00:14:32.540 --> 00:14:34.740
And maybe it always did, I don't know.


00:14:34.740 --> 00:14:39.040
But there's a whole bunch of stuff that used to return lists that now return generators.


00:14:39.040 --> 00:14:43.340
And it kind of, they look, they work great. You stick them in a for loop,


00:14:43.340 --> 00:14:45.340
and you're off to the races.


00:14:45.340 --> 00:14:52.740
But a lot of people are a little timid at first to try to write their own because it's a yield statement instead of a,


00:14:52.740 --> 00:14:55.940
instead of a return, and what do you, how do you do it?


00:14:55.940 --> 00:15:00.340
And so this is a great article by Trey to just say,


00:15:00.340 --> 00:15:01.940
here's what's going on.


00:15:01.940 --> 00:15:04.040
It's not that complicated.


00:15:04.040 --> 00:15:08.660
Generally, you often might have a for loop within your code.


00:15:08.660 --> 00:15:10.640
Instead of returning all the items,


00:15:10.640 --> 00:15:14.300
you one by one yield the items.


00:15:14.300 --> 00:15:19.300
Trade goes through some of the details of how this all works.


00:15:19.300 --> 00:15:21.300
It's pretty interesting.


00:15:21.300 --> 00:15:23.560
It's interesting for people to read through it and


00:15:23.560 --> 00:15:26.300
understand what's going on behind the scenes.


00:15:26.300 --> 00:15:30.000
What happens is your function that has a yield in it,


00:15:30.000 --> 00:15:33.120
it will not return the item right away.


00:15:33.120 --> 00:15:36.960
When somebody calls it, it returns a generator object.


00:15:36.960 --> 00:15:40.720
And that generator object has things like next,


00:15:40.720 --> 00:15:42.720
and mostly that's what we care about,


00:15:42.720 --> 00:15:47.020
and next returns the next item that you've returned.


00:15:47.020 --> 00:15:49.820
And then once you run out of items,


00:15:49.820 --> 00:15:52.820
it raises a stop iteration exception,


00:15:52.820 --> 00:15:54.420
and that's how it works.


00:15:54.420 --> 00:15:57.120
But generally, we just don't care about that stuff.


00:15:57.120 --> 00:15:58.620
We just throw them in a for loop.


00:15:58.620 --> 00:16:02.300
But it is interesting to learn some of the details around it.


00:16:02.300 --> 00:16:05.020
>> Yeah, they do seem mysterious and tricky,


00:16:05.020 --> 00:16:06.860
but they're super powerful.


00:16:06.860 --> 00:16:08.440
The more data that you have,


00:16:08.440 --> 00:16:12.140
the way better idea it is to not load it all into memory at once.


00:16:12.140 --> 00:16:16.820
>> Yeah, and you can do some fun things like chunking.


00:16:16.820 --> 00:16:21.180
Like if you're returning your caller,


00:16:21.180 --> 00:16:23.420
like let's say, and these are fun things to do with this.


00:16:23.420 --> 00:16:27.460
So let's say you're reading from an API or from a file or


00:16:27.460 --> 00:16:30.120
from a device or something.


00:16:30.120 --> 00:16:34.040
It has, you read like a big chunk of things,


00:16:34.040 --> 00:16:37.020
like 20 of them or 256 or something like that,


00:16:37.020 --> 00:16:38.740
a whole bunch of data at once.


00:16:38.740 --> 00:16:43.380
But then your caller really only wants one at a time.


00:16:43.380 --> 00:16:46.140
Within your function, your generator function,


00:16:46.140 --> 00:16:48.700
you can do fancy stuff like read a whole bunch and then


00:16:48.700 --> 00:16:51.940
just meter those out and when then that's empty,


00:16:51.940 --> 00:16:55.540
you go and read some more and have intermittent reads.


00:16:55.540 --> 00:16:58.880
and this will save time for, especially when you're not,


00:16:58.880 --> 00:17:00.320
you're not reading everything often.


00:17:00.320 --> 00:17:02.980
Sometimes the caller will break and not utilize everything.


00:17:02.980 --> 00:17:05.220
So that's definitely where,


00:17:05.220 --> 00:17:08.260
and they're very, they're a lot more efficient on memory too.


00:17:08.260 --> 00:17:09.340
So if you're, like you said,


00:17:09.340 --> 00:17:11.260
if it's huge amounts of things,


00:17:11.260 --> 00:17:14.100
it might be either for memory reasons or for speed reasons.


00:17:14.100 --> 00:17:14.920
These are great.


00:17:14.920 --> 00:17:15.760
- Yeah.


00:17:15.760 --> 00:17:16.580
Even computational, like,


00:17:16.580 --> 00:17:20.260
suppose you want a list of pedantic objects back


00:17:20.260 --> 00:17:22.340
and you're like reading some massive CSV


00:17:22.340 --> 00:17:26.300
and picking each row and star star value in there somehow.


00:17:26.300 --> 00:17:31.680
That's the actual creation of the Pydantic object


00:17:31.680 --> 00:17:33.300
if there was like a million of them.


00:17:33.300 --> 00:17:35.980
Forget memory, like even just the computation is expensive.


00:17:35.980 --> 00:17:37.700
So if you only want the first 20,


00:17:37.700 --> 00:17:40.300
like you can only pay the price of initializing


00:17:40.300 --> 00:17:41.140
the first 20.


00:17:41.140 --> 00:17:43.100
So there's all sorts of good reasons, yeah.


00:17:43.100 --> 00:17:43.940
- Okay.


00:17:43.940 --> 00:17:47.820
- I do want to just say one thing about generators


00:17:47.820 --> 00:17:50.080
that I wish there was like a slightly,


00:17:50.080 --> 00:17:52.880
Maybe some kind of behavior could be added,


00:17:52.880 --> 00:17:53.840
which would be fantastic.


00:17:53.840 --> 00:17:56.960
So generators can't be reused.


00:17:56.960 --> 00:17:57.800
- Yeah.


00:17:57.800 --> 00:17:59.080
- Right, so if I get a result back from a function,


00:17:59.080 --> 00:18:01.560
I try to, and I wanna ask a question like,


00:18:01.560 --> 00:18:03.520
were there any items resolved in here?


00:18:03.520 --> 00:18:05.480
And then loop over them if there were.


00:18:05.480 --> 00:18:06.960
Like you kind of broke it, right?


00:18:06.960 --> 00:18:08.020
You pulled the first one off,


00:18:08.020 --> 00:18:10.120
and then the next thing you work with is like,


00:18:10.120 --> 00:18:13.320
index one through n rather than zero through n,


00:18:13.320 --> 00:18:14.940
which is a problem.


00:18:14.940 --> 00:18:16.800
So sometimes you need to turn them to a list.


00:18:16.800 --> 00:18:19.560
It'd be cool if there was like a dot to list


00:18:19.560 --> 00:18:22.840
on a generator instead of having to call this on it, right?


00:18:22.840 --> 00:18:24.920
Just like a way as an expression to kind of like,


00:18:24.920 --> 00:18:27.680
I'm calling this and it's sort of a data science flow.


00:18:27.680 --> 00:18:30.200
I want all one expression and turn this generator


00:18:30.200 --> 00:18:31.940
into this other thing that I need to pass along.


00:18:31.940 --> 00:18:33.700
That would be fun.


00:18:33.700 --> 00:18:37.880
- Yeah, so a question out in the audience


00:18:37.880 --> 00:18:42.220
that maybe the returns, that the dictionary items


00:18:42.220 --> 00:18:43.920
and keys return something different,


00:18:43.920 --> 00:18:48.920
but Sam Morley says they return special generators,


00:18:49.240 --> 00:18:52.120
There's special kinds of generators, so yeah, thanks Sam.


00:18:52.120 --> 00:18:53.120
Well, indeed.


00:18:53.120 --> 00:18:57.200
Alright, well, what if I got next?


00:18:57.200 --> 00:18:59.080
I think it's closed it now.


00:18:59.080 --> 00:19:01.560
Would it really be an episode if we didn't talk about Wilma


00:19:01.560 --> 00:19:02.880
Coogan in some way or another?


00:19:02.880 --> 00:19:05.600
So we got him on deck twice, but we're going to start with just


00:19:05.600 --> 00:19:07.360
something he recommended to us.


00:19:07.360 --> 00:19:12.560
That's actually by Sam Colvin, who is the creator of pedantic.


00:19:12.560 --> 00:19:17.480
And I'm not sure if you're ready for this, Brian, but this is a little bit dirty.


00:19:18.560 --> 00:19:20.600
It's called dirty equals.


00:19:20.600 --> 00:19:25.600
And the idea is to abuse the dunder EQ method,


00:19:25.600 --> 00:19:27.800
mostly around unit testing,


00:19:27.800 --> 00:19:30.780
to make test cases and assertions


00:19:30.780 --> 00:19:32.960
and other things you might want to test


00:19:32.960 --> 00:19:36.560
more declarative and less imperative.


00:19:36.560 --> 00:19:39.400
So, that all sounds like fun, but how about an example?


00:19:39.400 --> 00:19:41.320
So, it starts out with a trivial example.


00:19:41.320 --> 00:19:43.440
It says, okay, from this library,


00:19:43.440 --> 00:19:46.240
you can import something called is positive.


00:19:46.240 --> 00:19:51.820
So then you could assert one or like some number and whatever one equal, equal is


00:19:51.820 --> 00:19:52.400
positive.


00:19:52.400 --> 00:19:53.280
That's true.


00:19:53.280 --> 00:19:57.640
That assert passes negative two equal, equal is positive fails.


00:19:57.640 --> 00:19:58.360
Okay.


00:19:58.360 --> 00:19:58.780
Okay.


00:19:58.780 --> 00:20:00.600
How does that strike you, Brian?


00:20:00.600 --> 00:20:03.040
They were building, these are building blocks.


00:20:03.040 --> 00:20:07.000
This is like a Lego piece, not the whole X wing fighter.


00:20:07.000 --> 00:20:07.400
Okay.


00:20:07.400 --> 00:20:09.220
But anyway, so that's the building block, right?


00:20:09.220 --> 00:20:13.700
Like take something and instead of saying, yes, it's exactly equal, implement


00:20:13.700 --> 00:20:16.580
the dunder equal method in the is positive class


00:20:16.580 --> 00:20:19.260
to like take the value, make sure it's a number,


00:20:19.260 --> 00:20:21.100
then check whether it's greater than zero, right?


00:20:21.100 --> 00:20:22.020
That kind of thing.


00:20:22.020 --> 00:20:24.340
I don't know if that includes zero, but anyway.


00:20:24.340 --> 00:20:26.160
But then you can get more interesting things.


00:20:26.160 --> 00:20:28.080
Like, so you could go to a database,


00:20:28.080 --> 00:20:30.740
and if you do a query against the database,


00:20:30.740 --> 00:20:33.600
you get, I think in the case that's up there,


00:20:33.600 --> 00:20:34.860
I think you get a tuple back.


00:20:34.860 --> 00:20:37.180
It depends on what you set the row factory to be,


00:20:37.180 --> 00:20:42.020
I suppose, but anyway, you get a tuple back of results.


00:20:42.020 --> 00:20:43.420
It looks like maybe this is a dictionary.


00:20:43.420 --> 00:20:46.960
Anyway, so then you can create a dictionary


00:20:46.960 --> 00:20:50.880
that has attributes that are like the result you want.


00:20:50.880 --> 00:20:51.760
They can either be equal


00:20:51.760 --> 00:20:54.300
or they can be things like this is positive.


00:20:54.300 --> 00:20:59.220
So in this case, we're doing a query against the database


00:20:59.220 --> 00:21:02.960
and then we're, looks like there's maybe needs to be


00:21:02.960 --> 00:21:05.420
like a first one, anyway, says, all right,


00:21:05.420 --> 00:21:08.780
what we're gonna do is we're gonna do equal equal that,


00:21:08.780 --> 00:21:10.700
the ID, so we'll create a dictionary,


00:21:10.700 --> 00:21:13.320
ID colon is positive int.


00:21:13.320 --> 00:21:15.480
Username colon, Sam Colvin.


00:21:15.480 --> 00:21:17.100
So that's an actual equality.


00:21:17.100 --> 00:21:19.100
Like the username has to be Samuel here.


00:21:19.100 --> 00:21:19.940
- Okay.


00:21:19.940 --> 00:21:20.760
- Yeah.


00:21:20.760 --> 00:21:22.580
And then the avatar is a string


00:21:22.580 --> 00:21:24.220
that matches a regular expression.


00:21:24.220 --> 00:21:27.300
That's like a thumb number slash PNG.


00:21:27.300 --> 00:21:29.380
The settings has to be a JSON thing


00:21:29.380 --> 00:21:30.880
where inside the settings,


00:21:30.880 --> 00:21:34.000
it's got some JSON values that you might test for.


00:21:34.000 --> 00:21:39.000
And is created now, is now with some level of variation,


00:21:39.000 --> 00:21:41.000
like some level of precision


00:21:41.000 --> 00:21:42.260
that you're willing to work with, right?


00:21:42.260 --> 00:21:44.700
because obviously you run the database query


00:21:44.700 --> 00:21:45.940
and then you get the result.


00:21:45.940 --> 00:21:49.540
But it's like very near, nearly now, right?


00:21:49.540 --> 00:21:52.700
It's like the almost equals and float type of stuff.


00:21:52.700 --> 00:21:54.100
That's pretty cool, right?


00:21:54.100 --> 00:21:56.620
(laughing)


00:21:56.620 --> 00:21:58.020
- Do I need to answer?


00:21:58.020 --> 00:21:59.980
I mean, I could see the utility.


00:21:59.980 --> 00:22:00.900
- Tell me, share your thoughts.


00:22:00.900 --> 00:22:01.740
Yeah.


00:22:01.740 --> 00:22:06.260
- But I don't know, the API is a little odd to me.


00:22:06.260 --> 00:22:10.340
- Okay, yeah, I think it's definitely an interesting idea.


00:22:10.340 --> 00:22:11.640
It's definitely different.


00:22:11.640 --> 00:22:17.120
You know, pedantic is often about, I know it's not pedantic, but it's by the creator.


00:22:17.120 --> 00:22:23.440
Pedantic is often about given some data that kind of matches, can it be made into that thing?


00:22:23.440 --> 00:22:30.720
And I feel like this kind of testing is in the same vein as what you might get working with pedantic and data.


00:22:30.720 --> 00:22:31.220
Yeah.


00:22:31.220 --> 00:22:31.720
Right?


00:22:31.720 --> 00:22:35.440
Well, it's definitely, it's definitely terse and useful.


00:22:35.440 --> 00:22:40.440
Um, so, and, and I, I could totally get used to it if this is a, this is a


00:22:40.440 --> 00:22:45.880
pretty, pretty, condensed way to, to compare, to see if everything.


00:22:45.880 --> 00:22:48.520
Uh, matches this protocol.


00:22:48.520 --> 00:22:49.000
Yeah.


00:22:49.000 --> 00:22:49.600
Yeah.


00:22:49.600 --> 00:22:55.000
So Sergey on the audience has like sort of the alternative perspective could be, you


00:22:55.000 --> 00:22:58.080
could just write multiple assert statements instead of creating a dictionary that


00:22:58.080 --> 00:23:04.240
represents everything you could say, like, get the record back and assert that


00:23:04.320 --> 00:23:06.200
you'll get the first value out and assert on it,


00:23:06.200 --> 00:23:07.880
then get the username out and assert,


00:23:07.880 --> 00:23:10.680
and get the avatar and assert on it and so on.


00:23:10.680 --> 00:23:15.800
It's an intermediate view story where you use the testing libraries,


00:23:15.800 --> 00:23:19.680
the testing classes, but more explicit.


00:23:19.680 --> 00:23:26.280
>> Right. There's a couple of reasons why to not use more than one assert.


00:23:26.280 --> 00:23:29.040
Because if you were to have multiple asserts,


00:23:29.040 --> 00:23:31.200
the first one to fail stops the check.


00:23:31.200 --> 00:23:34.840
It's possible that this will tell you everything that's wrong,


00:23:34.840 --> 00:23:36.580
not just the first thing that's wrong.


00:23:36.580 --> 00:23:38.480
>> Yes, exactly.


00:23:38.480 --> 00:23:43.960
>> Then some people are just opposed to multiple asserts per test.


00:23:43.960 --> 00:23:45.240
>> Yeah.


00:23:45.240 --> 00:23:48.040
>> I don't know. A similar thing,


00:23:48.040 --> 00:23:51.800
so I have a plugin called pytestCheck,


00:23:51.800 --> 00:23:57.280
which is just it uses checks instead of asserts,


00:23:57.280 --> 00:24:00.440
so that you can have multiple checks for test.


00:24:00.440 --> 00:24:02.960
but it does come up.


00:24:02.960 --> 00:24:04.820
So this is interesting.


00:24:04.820 --> 00:24:06.880
I'll definitely check it out and play with it.


00:24:06.880 --> 00:24:10.240
>> Yeah. Another benefit of being able to construct one of


00:24:10.240 --> 00:24:14.560
these prototypical documents or dictionaries that then


00:24:14.560 --> 00:24:17.120
represents the declarative behavior


00:24:17.120 --> 00:24:18.880
or state that you're supposed to be testing for,


00:24:18.880 --> 00:24:20.420
is you could create one of


00:24:20.420 --> 00:24:22.160
these and then use it different locations.


00:24:22.160 --> 00:24:24.480
Like, okay, when I insert a record and then I get it back out,


00:24:24.480 --> 00:24:28.560
it should be like this. But also if I call the API,


00:24:28.560 --> 00:24:29.800
and it gives me something back,


00:24:29.800 --> 00:24:32.120
it should also still pass the same test.


00:24:32.120 --> 00:24:34.280
Like you could have a different parts of my app.


00:24:34.280 --> 00:24:35.760
They all need to look like this.


00:24:35.760 --> 00:24:36.580
- Yeah.


00:24:36.580 --> 00:24:38.360
- As opposed to having a bunch of tests over and over


00:24:38.360 --> 00:24:40.000
that are effectively the same.


00:24:40.000 --> 00:24:43.840
And Will is here who recommended this,


00:24:43.840 --> 00:24:45.940
suggests one of the benefits of dirty equals


00:24:45.940 --> 00:24:49.600
is that pytest will generate useful diffs from it.


00:24:49.600 --> 00:24:52.540
- Yeah, definitely.


00:24:52.540 --> 00:24:55.160
Reasons, pytest being a reason to use something,


00:24:55.160 --> 00:24:56.800
I'm on board then, yeah, sure.


00:24:56.800 --> 00:24:59.060
- Yeah, check it out.


00:24:59.060 --> 00:25:01.660
If you do play with it, give us a report how you feel about it.


00:25:01.660 --> 00:25:05.760
>> One more question from Sam, said Sam Morley.


00:25:05.760 --> 00:25:08.740
pytest already has something a bit like this with


00:25:08.740 --> 00:25:12.500
a prox except for it's for floats, etc.


00:25:12.500 --> 00:25:14.940
Except for a prox is not etc,


00:25:14.940 --> 00:25:16.180
it's just for floats.


00:25:16.180 --> 00:25:18.420
You can only use a prox with floats.


00:25:18.420 --> 00:25:23.300
>> We have approximate now and stuff like that.


00:25:23.300 --> 00:25:27.260
>> I'll try it, especially if Will likes it,


00:25:27.260 --> 00:25:28.340
It's gotta be good.


00:25:28.340 --> 00:25:30.620
>> Exactly.


00:25:30.620 --> 00:25:34.060
>> Awesome. All right. What's the final one you got for us here?


00:25:34.060 --> 00:25:38.300
>> Okay. This is more of a question than I'm not saying this is awesome,


00:25:38.300 --> 00:25:39.980
but I ran across this.


00:25:39.980 --> 00:25:45.260
Actually, I clicked on a listicle.


00:25:45.260 --> 00:25:48.100
Mike, I think there's a self-help group for that.


00:25:48.100 --> 00:25:54.060
>> Yeah. Well, we're definitely prone to clicking on the top listicles.


00:25:54.060 --> 00:25:55.500
>> Yeah. So my name is Brian.


00:25:55.500 --> 00:25:56.100
>> Awesome. That's awesome.


00:25:56.100 --> 00:25:58.300
>> I clicked on a listicle.


00:25:58.300 --> 00:26:01.580
The listicle was a top 10, where we at?


00:26:01.580 --> 00:26:06.180
It was 10 tools I wish I knew when I started working with Python.


00:26:06.180 --> 00:26:08.580
Actually, it's a good list.


00:26:08.580 --> 00:26:10.820
I just knew about most of them as all.


00:26:10.820 --> 00:26:12.340
We'll link to it anyway.


00:26:12.340 --> 00:26:13.900
>> It's got the sound of music,


00:26:13.900 --> 00:26:15.820
it's got Jackie Chan, it's got Office Space.


00:26:15.820 --> 00:26:17.940
Come on, this is a pretty solid listicle.


00:26:17.940 --> 00:26:20.180
>> Well, then I got down to number 7 and 8,


00:26:20.180 --> 00:26:21.740
and I'm like, what are these things?


00:26:21.740 --> 00:26:26.060
I've never heard of them. Commitison and semantic release.


00:26:26.060 --> 00:26:32.820
The idea, I tried to commit with this.


00:26:32.820 --> 00:26:35.580
Commitizen is a thing that you can say,


00:26:35.580 --> 00:26:38.180
if you install it, you can either brew install it for


00:26:38.180 --> 00:26:41.380
everything or you can put it in a virtual environment. That's cool.


00:26:41.380 --> 00:26:44.960
But instead of just committing,


00:26:44.960 --> 00:26:48.420
you use this to commit and it asks you questions.


00:26:48.420 --> 00:26:50.520
>> Right. Instead of typing git space commit,


00:26:50.520 --> 00:26:52.260
you type cz space commit.


00:26:52.260 --> 00:26:55.780
>> Yeah. Then it asks you a whole bunch of stuff.


00:26:55.780 --> 00:26:57.420
Was this a bug fix?


00:26:57.420 --> 00:26:58.580
Was it a feature?


00:26:58.580 --> 00:27:02.180
Did you? Then it follows on depending on what you answered.


00:27:02.180 --> 00:27:05.780
If you had a bug fix or a feature,


00:27:05.780 --> 00:27:07.060
is it a breaking feature?


00:27:07.060 --> 00:27:10.820
Did you? Basically, it's doing a whole bunch of stuff,


00:27:10.820 --> 00:27:15.780
but it's trying to do these conventional commits.


00:27:15.780 --> 00:27:18.060
We've got a link to this too.


00:27:18.060 --> 00:27:20.540
Then if you've got all this formatting,


00:27:20.540 --> 00:27:25.140
so it ends up formatting your commit message to a consistent format,


00:27:25.140 --> 00:27:27.140
so that when you're reading the history and stuff,


00:27:27.140 --> 00:27:31.280
you can do a whole bunch of... it's easier, I guess.


00:27:31.280 --> 00:27:37.580
And then this tool also, this listicle also commented that you've got


00:27:37.580 --> 00:27:41.020
semantic release, which is a Python package


00:27:41.020 --> 00:27:45.320
that I haven't got through this much, but it can take this,


00:27:45.320 --> 00:27:48.300
all this information from these and do some


00:27:48.300 --> 00:27:52.100
better control your semantic release notes or release...


00:27:52.100 --> 00:27:54.460
I don't know if it's release notes or just the release version.


00:27:54.460 --> 00:27:56.780
I haven't got that far into it, but yeah,


00:27:56.780 --> 00:27:57.860
the commit is an ass.


00:27:57.860 --> 00:28:01.980
Is this like a change corresponding to semantic versions such that it should be


00:28:01.980 --> 00:28:06.300
a major change so it'll like it looks like it'll increment the version and stuff like that as well?


00:28:06.300 --> 00:28:12.620
Yeah, yeah, but so the in the about for committance and says


00:28:12.620 --> 00:28:17.500
command line utility to create commits with your rules and apparently you can.


00:28:17.500 --> 00:28:21.260
You can specify some special rules, which is good.


00:28:21.260 --> 00:28:23.860
display information about your commits,


00:28:23.860 --> 00:28:26.020
bump the version automatically,


00:28:26.020 --> 00:28:28.560
and generate a change log.


00:28:28.560 --> 00:28:31.500
That's cool. That might be helpful.


00:28:31.500 --> 00:28:35.240
My questions out to the audience and everybody listening,


00:28:35.240 --> 00:28:37.460
have you used something like this?


00:28:37.460 --> 00:28:38.700
Is it useful?


00:28:38.700 --> 00:28:41.380
Is there something different than this that you recommend?


00:28:41.380 --> 00:28:43.180
Also, what size of a project would this


00:28:43.180 --> 00:28:45.380
make sense for a small or medium project?


00:28:45.380 --> 00:28:47.300
>> That's cool. Yeah, let us know on Twitter or at


00:28:47.300 --> 00:28:49.780
the bottom of the YouTube live stream is the best place.


00:28:49.780 --> 00:28:51.020
- Yep, so.


00:28:51.020 --> 00:28:52.320
- Yeah, very cool.


00:28:52.320 --> 00:28:55.420
Now, before you go on, I also have a question out to you.


00:28:55.420 --> 00:28:57.460
You can be the proxy for the audience here.


00:28:57.460 --> 00:28:58.300
- Okay.


00:28:58.300 --> 00:29:01.020
- Notice at the bottom it says requirements 3.6 and above.


00:29:01.020 --> 00:29:01.860
- Yeah.


00:29:01.860 --> 00:29:03.700
- Python, that's not, I don't feel like


00:29:03.700 --> 00:29:06.020
that's very controversial as 3.6


00:29:06.020 --> 00:29:07.340
is not even supported anymore, right?


00:29:07.340 --> 00:29:08.160
- Right.


00:29:08.160 --> 00:29:10.740
- So this is like every possibly supported version


00:29:10.740 --> 00:29:13.260
of Python 3 this works for.


00:29:13.260 --> 00:29:16.860
What would you think if I said the requirement is


00:29:16.860 --> 00:29:19.140
this is Python 3, not Python 3,


00:29:19.140 --> 00:29:24.420
just, it requires Python three, knowing that like that means or implying that


00:29:24.420 --> 00:29:29.880
that means supported shipping real versions of Python, not Python three, one.


00:29:29.880 --> 00:29:30.460
Right.


00:29:30.460 --> 00:29:33.900
Cause obviously Python three, one is no longer supported, but neither is three,


00:29:33.900 --> 00:29:37.420
five, even like, could you say f-strings are just in Python three now without


00:29:37.420 --> 00:29:41.060
worrying about the version or do you need, you still need to say three, six,


00:29:41.060 --> 00:29:44.000
plus three, six, three, seven, like, should this be updated to be three, seven?


00:29:44.000 --> 00:29:44.540
You know what I mean?


00:29:44.540 --> 00:29:47.260
You kind of have to, you think so?


00:29:47.260 --> 00:29:48.180
I, I don't know.


00:29:48.180 --> 00:29:53.960
>> I know when I say something is on Python 3,


00:29:53.960 --> 00:29:56.440
actually I don't even say that anymore.


00:29:56.440 --> 00:29:58.080
What do you think?


00:29:58.080 --> 00:30:00.760
>> Okay. Well, I used it in the sense like,


00:30:00.760 --> 00:30:02.820
yeah, you need Python 3 for this thinking, well,


00:30:02.820 --> 00:30:05.560
any version that's supported these days.


00:30:05.560 --> 00:30:06.840
People are like, well, there's older versions


00:30:06.840 --> 00:30:07.840
that don't support this thing.


00:30:07.840 --> 00:30:09.660
Like, well, obviously,


00:30:09.660 --> 00:30:11.080
I'm not talking about the one that was not


00:30:11.080 --> 00:30:12.800
supported five years ago.


00:30:12.800 --> 00:30:15.760
At some point, Python 3


00:30:15.760 --> 00:30:18.560
is the supported version of Python.


00:30:18.560 --> 00:30:19.200
I don't know.


00:30:19.200 --> 00:30:19.880
Oh, that's true.


00:30:19.880 --> 00:30:20.600
Yeah.


00:30:20.600 --> 00:30:21.440
Okay.


00:30:21.440 --> 00:30:24.200
So that's a bit of a diversion there, but I went down that route.


00:30:24.200 --> 00:30:24.400
Hold on.


00:30:24.400 --> 00:30:26.920
It's like, I really don't know which way I should go, but I feel like there's,


00:30:26.920 --> 00:30:30.440
there's a case to be made that just like, when you talk about Python three, you're


00:30:30.440 --> 00:30:32.520
not talking about old unsupported versions.


00:30:32.520 --> 00:30:37.240
You're everything that's like modern three, seven and above should be like an S


00:30:37.240 --> 00:30:39.320
and an, an alias for Python.


00:30:39.320 --> 00:30:39.960
I don't know.


00:30:39.960 --> 00:30:43.120
When we were just saying Python three, what we meant was like three, one.


00:30:43.120 --> 00:30:45.720
So I know we got to get used to that.


00:30:45.720 --> 00:30:49.240
that there's no Python 2 really to worry about.


00:30:49.240 --> 00:30:51.600
All right, well, that will definitely bring us


00:30:51.600 --> 00:30:53.160
to our extras, won't it?


00:30:53.160 --> 00:30:54.320
- Yeah, yeah.


00:30:54.320 --> 00:30:56.520
- All right, you want me to kick it off


00:30:56.520 --> 00:30:57.440
since I got my screen up?


00:30:57.440 --> 00:30:58.520
- Yeah, go ahead.


00:30:58.520 --> 00:30:59.640
- All right, so Will, like I said,


00:30:59.640 --> 00:31:02.680
he gets two appearances and also his comments.


00:31:02.680 --> 00:31:03.880
So thank you for that.


00:31:03.880 --> 00:31:05.480
And this is like in the same vein


00:31:05.480 --> 00:31:06.320
of what I was just talking about.


00:31:06.320 --> 00:31:08.680
Like what is this convention that we want to have, right?


00:31:08.680 --> 00:31:11.520
So the Walrus operator came out in 3.8


00:31:11.520 --> 00:31:15.240
and it was kind of an interesting big deal, right?


00:31:15.240 --> 00:31:18.080
there's a lot of debate around whether or not


00:31:18.080 --> 00:31:19.020
that should be in the language.


00:31:19.020 --> 00:31:20.840
Honestly, I think it's a pretty minor thing


00:31:20.840 --> 00:31:22.280
that it's not a huge deal.


00:31:22.280 --> 00:31:27.280
But the idea is you can both test for a variable as well,


00:31:27.280 --> 00:31:30.140
or you can use the test or use the value of the variable


00:31:30.140 --> 00:31:32.820
in the same place that you create it.


00:31:32.820 --> 00:31:35.120
So instead of saying x equals get user,


00:31:35.120 --> 00:31:38.120
or like u equals get user, if user is not none,


00:31:38.120 --> 00:31:43.080
or if user, you could just say if u colon equals get user,


00:31:43.080 --> 00:31:43.920
do the true thing.


00:31:43.920 --> 00:31:46.400
Otherwise then it's not set right.


00:31:46.400 --> 00:31:50.500
And so Will is suggesting that we pronounce


00:31:50.500 --> 00:31:55.040
the walrus operator as u becomes the value.


00:31:55.040 --> 00:31:58.580
So like x colon equals seven is like x becomes seven.


00:31:58.580 --> 00:31:59.420
What do you think?


00:31:59.420 --> 00:32:00.360
Are you behind this?


00:32:00.360 --> 00:32:02.840
- Okay, so you'd be like when you're reading your code


00:32:02.840 --> 00:32:03.800
to yourself I guess.


00:32:03.800 --> 00:32:04.640
- How do you say it?


00:32:04.640 --> 00:32:06.900
Like if you say like the lambda expression,


00:32:06.900 --> 00:32:10.280
like how do you define like the variables of the lambda?


00:32:10.280 --> 00:32:12.440
Like there's terms around there


00:32:12.440 --> 00:32:15.320
I make it a little bit hard to say without just saying syntax.


00:32:15.320 --> 00:32:22.960
He's proposing like becomes is the way we verbalize while we're separate.


00:32:22.960 --> 00:32:25.000
I like it. I'm going to give it a thumbs up.


00:32:25.000 --> 00:32:28.440
>> It's interesting, but how is that different from assignment though?


00:32:28.440 --> 00:32:30.080
What do you say with assignment?


00:32:30.080 --> 00:32:32.000
I don't say like x.


00:32:32.000 --> 00:32:33.640
>> Equals? I don't know.


00:32:33.640 --> 00:32:37.760
>> Equals, assign, becomes works.


00:32:37.760 --> 00:32:40.320
>> I will put it out there if people can think about it.


00:32:40.320 --> 00:32:43.500
And there's a, there's a nice Twitter thread here with lots of comments.


00:32:43.500 --> 00:32:46.120
Uh, so folks can jump in.


00:32:46.120 --> 00:32:50.540
Or you can just walrus, just talk X walrus five.


00:32:50.540 --> 00:32:51.800
Um, oh yeah.


00:32:51.800 --> 00:32:53.820
Well, what do walruses do?


00:32:53.820 --> 00:32:58.320
I mean, is there like a cool action that would, is like particular to walruses?


00:32:58.320 --> 00:33:01.100
Well, there probably is, but it's not, it doesn't apply to this.


00:33:01.100 --> 00:33:03.020
It's not a very colloquial, is it?


00:33:03.020 --> 00:33:05.140
Is X.


00:33:05.140 --> 00:33:05.660
Yeah.


00:33:05.660 --> 00:33:09.860
And John, then John Sheehan out in the audience says in my brain, I use a


00:33:09.860 --> 00:33:14.700
assigned to, and he must know what's coming because he's up next.


00:33:14.700 --> 00:33:16.900
[LAUGH]


00:33:16.900 --> 00:33:17.900
Hey, John.


00:33:17.900 --> 00:33:21.900
So the other thing I want to talk about is, did you know, I learned through John,


00:33:21.900 --> 00:33:27.980
that string starts with will take an iterable, it says tuple, but I suspect


00:33:27.980 --> 00:33:31.540
it might even be an iterable of substrings.


00:33:31.540 --> 00:33:35.420
And if any of them match, it will test out to be true.


00:33:35.420 --> 00:33:42.740
to like ABCDEF, you say starts with a tuple, AB or CD or EF.


00:33:42.740 --> 00:33:44.000
I've never used this.


00:33:44.000 --> 00:33:45.140
>>I didn't know that that was a thing.


00:33:45.140 --> 00:33:49.940
>>I would always just do that as like X starts with AB or X starts with CD


00:33:49.940 --> 00:33:51.260
or X starts with EF.


00:33:51.260 --> 00:33:53.380
No, you apparently can do that all in one go.


00:33:53.380 --> 00:33:55.300
>>What's the two for?


00:33:55.300 --> 00:33:56.300
>>I have no idea.


00:33:56.300 --> 00:33:57.220
I was just thinking that as well.


00:33:57.220 --> 00:33:59.020
There's a two and I don't know what it's for.


00:34:02.820 --> 00:34:06.420
Yeah, anyway, that's a super quick one, but I thought pretty interesting there.


00:34:06.420 --> 00:34:08.120
So that's all I got.


00:34:08.120 --> 00:34:09.120
How about you?


00:34:09.120 --> 00:34:15.820
I just have one thing that we don't need to put it up, but my extra is this book.


00:34:15.820 --> 00:34:20.220
You have your physical 2.0 book in hand.


00:34:20.220 --> 00:34:21.220
Yes, I've got.


00:34:21.220 --> 00:34:22.120
Oh, yeah.


00:34:22.120 --> 00:34:28.720
And for the people not not watching my I've got a stack of it's funny.


00:34:28.720 --> 00:34:31.220
My daughter uses my Amazon account too.


00:34:31.420 --> 00:34:34.580
So UPS said, hey, there's a package arriving yesterday.


00:34:34.580 --> 00:34:37.460
And I said, I didn't order anything.


00:34:37.460 --> 00:34:41.820
So I said, I told my daughter, hey, you probably have a package showing up.


00:34:41.820 --> 00:34:43.980
She's like, I didn't order anything.


00:34:43.980 --> 00:34:49.480
And then this box arrives with five copies of my book, which is great.


00:34:49.480 --> 00:34:53.280
That's awesome. Yeah. Yeah. Congratulations. Thanks. Very cool.


00:34:53.280 --> 00:34:56.380
We abuse our Amazon account badly.


00:34:56.380 --> 00:34:58.460
Like there's a lot of people that log into Amazon.


00:34:59.080 --> 00:35:00.920
We end up getting stuff shipped wrong places


00:35:00.920 --> 00:35:02.960
because somebody shipped it to their house last time,


00:35:02.960 --> 00:35:04.380
and then we just hit reorder again.


00:35:04.380 --> 00:35:06.260
And like, why do you have our shampoo?


00:35:06.260 --> 00:35:07.180
I don't know.


00:35:07.180 --> 00:35:08.320
Yeah.


00:35:08.320 --> 00:35:09.080
Yeah.


00:35:09.080 --> 00:35:12.880
So John adds that the two is the starting position


00:35:12.880 --> 00:35:14.960
of the starting position.


00:35:14.960 --> 00:35:15.480
Yeah.


00:35:15.480 --> 00:35:16.560
I figure it had something to do with it.


00:35:16.560 --> 00:35:18.380
I wasn't sure how many characters to compare on.


00:35:18.380 --> 00:35:22.020
But well, I also didn't know if the that you could pass


00:35:22.020 --> 00:35:23.860
a starting position for starts with.


00:35:23.860 --> 00:35:25.760
That's cool.


00:35:25.760 --> 00:35:27.520
Yeah, there's a lot going on here.


00:35:27.520 --> 00:35:29.520
- Almost starts with.


00:35:29.520 --> 00:35:30.800
- Yeah, nearly starts with.


00:35:30.800 --> 00:35:33.880
Yeah, what's the right way?


00:35:33.880 --> 00:35:37.560
So I want to close this out with a joke as always,


00:35:37.560 --> 00:35:41.800
but there's the joke we talked about a while ago,


00:35:41.800 --> 00:35:45.400
where Sebastian Ramirez, creator of FastAPI,


00:35:45.400 --> 00:35:48.840
saw an ad hiring a FastAPI developer,


00:35:48.840 --> 00:35:51.960
and he said, "Oh, it looks like I can't apply for this job.


00:35:51.960 --> 00:35:54.600
"It requires four years of experience with FastAPI,


00:35:54.600 --> 00:35:56.220
"but I can't possibly have that


00:35:56.220 --> 00:35:57.740
Cause they only created it two years ago.


00:35:57.740 --> 00:35:58.020
Right.


00:35:58.020 --> 00:35:58.260
Yeah.


00:35:58.260 --> 00:36:00.680
So it's a little bit in that vein.


00:36:00.680 --> 00:36:03.580
So here we have, somebody.


00:36:03.580 --> 00:36:07.060
Uh, tweeting and says, here's a conversation with the recruiter and them.


00:36:07.060 --> 00:36:10.300
It says, recruiter, do you have a CS background?


00:36:10.300 --> 00:36:11.820
Yes, absolutely.


00:36:11.820 --> 00:36:13.180
My CS background.


00:36:13.180 --> 00:36:16.220
And this is a screenshot from the game counter-strike, which is


00:36:16.220 --> 00:36:17.660
often referred to as just CS.


00:36:17.660 --> 00:36:19.180
Yeah, of course I got a CS background.


00:36:19.180 --> 00:36:19.700
Are you kidding me?


00:36:19.700 --> 00:36:23.740
That's pretty good.


00:36:23.740 --> 00:36:24.220
I love it.


00:36:24.220 --> 00:36:24.900
Yeah.


00:36:25.300 --> 00:36:26.320
>> Yeah, that's a good one.


00:36:26.320 --> 00:36:28.120
>> Well, just a question though.


00:36:28.120 --> 00:36:32.200
If you did FastAPI instead of eight hours a day,


00:36:32.200 --> 00:36:35.720
if you did it 16 hours a day for two years,


00:36:35.720 --> 00:36:38.680
would that constitute four years of experience?


00:36:38.680 --> 00:36:41.260
>> That probably is about the same amount of experience.


00:36:41.260 --> 00:36:41.560
>> Yeah.


00:36:41.560 --> 00:36:44.720
>> So what a slacker that Sebastian is.


00:36:44.720 --> 00:36:46.600
>> Does he have to eat or something?


00:36:46.600 --> 00:36:48.280
Does he have family? What's going on?


00:36:48.280 --> 00:36:49.560
>> Come on.


00:36:49.560 --> 00:36:53.960
>> Well, always fun with hanging out with you and talking Python.


00:36:53.960 --> 00:36:54.640
>> You bet.


00:36:54.640 --> 00:36:59.800
Thanks to everybody that listens to it on their podcast player


00:36:59.800 --> 00:37:02.240
or watches us on YouTube.


00:37:02.240 --> 00:37:03.720
Yeah, absolutely.

