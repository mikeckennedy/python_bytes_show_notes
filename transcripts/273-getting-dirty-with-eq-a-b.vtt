WEBVTT

00:00:00.001 --> 00:00:05.100
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:05.100 --> 00:00:09.880
This is episode 273, recorded March 1st, 2022.

00:00:09.880 --> 00:00:11.480
And I'm Brian Okken.

00:00:11.480 --> 00:00:12.640
I'm Michael Kennedy.

00:00:12.640 --> 00:00:16.060
Well, welcome, Michael. It's good to have us here.

00:00:16.060 --> 00:00:18.860
It's great to see you as always.

00:00:18.860 --> 00:00:22.780
It feels like spring is almost here. It's March. I can't believe it.

00:00:22.780 --> 00:00:23.960
So pretty awesome.

00:00:23.960 --> 00:00:24.460
Yeah.

00:00:24.460 --> 00:00:26.180
Fun to be talking Python with you.

00:00:26.180 --> 00:00:29.480
Yeah. So should we kick it off with your first item?

00:00:30.060 --> 00:00:34.840
Let's do it. I'm a big fan of science, math and all those things.

00:00:34.840 --> 00:00:40.100
And I came across this article because I was reading about science, not because I was reading about Python.

00:00:40.100 --> 00:00:43.080
But then I thought, oh, there has to be a Python story here.

00:00:43.080 --> 00:00:45.180
Let's get into it and see if I can track it down.

00:00:45.180 --> 00:00:47.080
And wow, is it not easy to find.

00:00:47.080 --> 00:00:47.960
So here's the deal.

00:00:47.960 --> 00:00:58.060
I saw an article over on sciencealert.com called Physics Breakthrough as AI Successfully Controls Plasma in a Nuclear Fusion Experiment.

00:00:58.060 --> 00:00:58.900
That's so cool.

00:00:59.060 --> 00:01:00.500
Let me, that's amazing, right?

00:01:00.500 --> 00:01:01.700
So let me put a few things together here.

00:01:01.700 --> 00:01:03.380
Nuclear fusion, not fission.

00:01:03.380 --> 00:01:05.720
That's the kind of nuclear we want.

00:01:05.720 --> 00:01:12.740
That is harnessing the sun with no negative effects to like turn hydrogen into helium and so on.

00:01:12.740 --> 00:01:13.320
Right?

00:01:13.320 --> 00:01:18.260
If we could harness that, that's like free, super easy energy forever.

00:01:18.260 --> 00:01:19.400
It's incredible, right?

00:01:19.400 --> 00:01:21.520
So people have been working on this for a long time.

00:01:21.640 --> 00:01:37.900
The way that I understand, which is probably pretty piecemeal that it works is you put some kind of thing, some kind of material like hydrogen or something in the middle, and then you blast it with tons of energy.

00:01:37.900 --> 00:01:39.320
But then it creates this plasma.

00:01:39.320 --> 00:01:49.700
And you've got to control with lasers and magnets on how you basically keep the pressure high enough in addition to just the heat to actually make the fusion work.

00:01:49.700 --> 00:01:50.060
Right?

00:01:50.140 --> 00:01:55.500
So there's been some success like, hey, we got fusion to work for a while.

00:01:55.500 --> 00:01:57.280
It just took more energy than it put out.

00:01:57.280 --> 00:02:02.480
So, you know, it's not a super great power plant, but it did do the science thing, right?

00:02:02.480 --> 00:02:02.720
Yeah.

00:02:02.720 --> 00:02:04.040
So here's the deal.

00:02:04.040 --> 00:02:19.100
This article says they've used artificial intelligence to teach it how to make instantaneous or near instantaneous adjustments to the magnetic field and the lasers in order to actually get better results with fusion, right?

00:02:19.100 --> 00:02:20.340
So take it farther along.

00:02:20.340 --> 00:02:36.620
And it says, in a joint effort, the Swiss Plasma Center and artificial intelligence research company DeepMind, they used deep reinforcement learning to study the nuances of plasma behavior and control inside a fusion tokamak.

00:02:36.620 --> 00:02:40.920
That's the donut-shaped thing where the reaction happens.

00:02:40.920 --> 00:02:48.340
And they're able to make a bunch of small adjustments really quickly in order to get better results.

00:02:48.660 --> 00:02:51.480
And it's pretty wild that they did that with AI, isn't it?

00:02:51.480 --> 00:02:51.760
Yeah.

00:02:51.760 --> 00:02:52.240
Yeah.

00:02:52.240 --> 00:02:54.020
There's definitely Python in there somewhere.

00:02:54.020 --> 00:02:54.780
You just know it.

00:02:54.780 --> 00:02:55.500
Exactly.

00:02:55.500 --> 00:02:56.620
So I'm like, all right, where is this?

00:02:56.620 --> 00:03:01.960
So I went through and they talk about the findings being in nature, some of the articles that they're referencing.

00:03:01.960 --> 00:03:11.840
So there's some like deep, as in not super engaging sort of scientific articles, like the traditional academic style of writing that you've got to dive into and then like follow a bunch of links.

00:03:11.840 --> 00:03:18.520
But eventually in there, you will find that there is some cool science stuff going on.

00:03:18.520 --> 00:03:21.220
And Python is at the heart of it.

00:03:21.220 --> 00:03:27.300
So it's probably not worth going into too much of the details of how it's actually happening.

00:03:27.300 --> 00:03:30.120
But it's the Python side of things.

00:03:30.120 --> 00:03:37.000
But I just thought it was super cool that, look, here's one of the most exciting things happening in energy and for the climate and for all sorts of things.

00:03:37.000 --> 00:03:40.640
And AI and Python are pushing it forward.

00:03:40.640 --> 00:03:41.160
That's crazy.

00:03:41.480 --> 00:03:47.620
And that's what we need for a Mr. Fusion so that we can make flying cars and time traveling cars too.

00:03:47.620 --> 00:03:48.420
Exactly.

00:03:48.420 --> 00:03:54.220
I mean, Marty McFly and Doc, they go and they throw their banana peel on the back of the DeLorean, right?

00:03:54.220 --> 00:03:56.500
You've got to have one of these token mucks to make it roll.

00:03:56.500 --> 00:03:57.780
You've got to have Python in the car.

00:03:57.780 --> 00:03:58.340
Come on.

00:03:58.340 --> 00:03:59.140
Obviously.

00:03:59.140 --> 00:04:00.340
So, cool.

00:04:00.340 --> 00:04:01.120
Obviously.

00:04:01.120 --> 00:04:02.200
All right.

00:04:02.200 --> 00:04:04.340
Well, take us back to something more concrete.

00:04:04.700 --> 00:04:05.520
Well, okay.

00:04:05.520 --> 00:04:06.760
So I'm pretty excited about this.

00:04:06.760 --> 00:04:10.040
It's a minor thing, but maybe not too minor.

00:04:10.040 --> 00:04:13.320
PEP 680 has been accepted.

00:04:13.320 --> 00:04:15.840
Standards track for Python 311.

00:04:15.840 --> 00:04:19.520
PEP 680 is TomlLib support.

00:04:19.520 --> 00:04:22.700
So support for parsing Toml in the standard library.

00:04:22.700 --> 00:04:24.380
We haven't had it yet.

00:04:24.380 --> 00:04:24.940
That's awesome.

00:04:24.940 --> 00:04:26.980
So we've got JSON.

00:04:26.980 --> 00:04:27.760
We've got CSV.

00:04:27.760 --> 00:04:28.480
Why not?

00:04:28.480 --> 00:04:28.780
Right.

00:04:28.780 --> 00:04:29.220
We've got XML.

00:04:29.560 --> 00:04:39.720
Well, and one of the, and now that we've, PEP uses Toml for PyProject.Toml, but anyway,

00:04:39.720 --> 00:04:42.800
so we kind of need, I think it'd be cool to have it in the standard library.

00:04:42.800 --> 00:04:45.380
I think it's fine to have other outside supports.

00:04:45.380 --> 00:04:52.380
So what they're doing is, and if people don't, there's some rationale here, but, you know,

00:04:52.380 --> 00:04:54.140
just think it's easier than normal.

00:04:54.680 --> 00:05:00.880
So Toml is, I like Toml for, because it's just, I don't know, it's an easy format to

00:05:00.880 --> 00:05:01.120
read.

00:05:01.120 --> 00:05:03.560
It's better than any and some other stuff.

00:05:03.560 --> 00:05:09.640
And for people who don't know, it feels any like, like the .ini file style where you've

00:05:09.640 --> 00:05:12.600
kind of got like section headers and then key value bits.

00:05:12.600 --> 00:05:13.020
Yeah.

00:05:13.020 --> 00:05:20.260
And it doesn't, and often it doesn't like, you can use, you can use black and write a PyProject.Toml

00:05:20.260 --> 00:05:22.780
file without even really knowing anything about Toml.

00:05:22.780 --> 00:05:27.500
So it's pretty straightforward, but we didn't have a way built into standard library to

00:05:27.500 --> 00:05:28.120
just use it.

00:05:28.120 --> 00:05:30.520
So that's, this is this PEP.

00:05:30.520 --> 00:05:35.940
One of the things there, interesting bits about it is it's only reading.

00:05:35.940 --> 00:05:40.020
So it's only adding support for reading Toml.

00:05:40.020 --> 00:05:43.140
So there's a load and a load, load S.

00:05:43.140 --> 00:05:48.500
So you can load a Toml file or you can load a string and that's it.

00:05:49.500 --> 00:05:50.940
And it outputs a dictionary.

00:05:50.940 --> 00:05:54.940
So, and that, that, that makes sense.

00:05:54.940 --> 00:06:01.060
You're just getting a Toml object and getting, turning it into, to a dictionary so you can use

00:06:01.060 --> 00:06:01.320
it.

00:06:02.320 --> 00:06:05.920
But this is built on top of Toml.ly.

00:06:05.920 --> 00:06:13.100
So Toml.ly is being used as a, as, as the, as the library to basically there's an open source

00:06:13.100 --> 00:06:16.320
project called Toml.ly, which a lot of projects are using.

00:06:16.320 --> 00:06:21.820
I think this is the one that pytest is using and quite a few projects are, have switched to this.

00:06:21.820 --> 00:06:22.840
It's really fast.

00:06:22.840 --> 00:06:25.980
It's nice, but it supports like writing as well.

00:06:26.160 --> 00:06:27.480
But yeah, right.

00:06:27.480 --> 00:06:29.180
And then code and dump S and all those things.

00:06:29.180 --> 00:06:29.580
Yeah.

00:06:29.580 --> 00:06:30.000
Right.

00:06:30.000 --> 00:06:33.120
So, so, but that's, that's not the part that's going to get supported.

00:06:33.120 --> 00:06:39.300
And I think that's, I think that's fine to just have reading built into, to, into.

00:06:39.300 --> 00:06:39.680
Sure.

00:06:39.680 --> 00:06:45.860
Some file formats like text and, and CSV and whatnot, like reading and writing is super common.

00:06:45.860 --> 00:06:46.580
Right.

00:06:46.620 --> 00:06:52.120
But these are way more likely to be used as configuration files that drive app startup

00:06:52.120 --> 00:06:53.580
and like hide secrets.

00:06:53.580 --> 00:06:56.980
You know, you put your secrets in there and don't put in Git or something like that, whatever.

00:06:56.980 --> 00:06:57.360
Right.

00:06:57.360 --> 00:07:00.120
Those are the kinds of UK use cases I would see.

00:07:00.120 --> 00:07:02.280
And so in that case, reading, reading seems fine.

00:07:02.280 --> 00:07:03.480
You could always add writing later.

00:07:03.480 --> 00:07:05.280
You just can't take it away if you add it too soon.

00:07:05.280 --> 00:07:06.080
Right.

00:07:06.080 --> 00:07:06.860
Right.

00:07:06.860 --> 00:07:13.380
But, but also like, I don't, I don't, and I'm sure there are reasons to, to need to write

00:07:13.380 --> 00:07:20.380
it, but I don't, you know, it's, it's mostly people write it and computers read it

00:07:20.380 --> 00:07:20.920
sort of thing.

00:07:20.920 --> 00:07:21.740
Yeah, exactly.

00:07:21.740 --> 00:07:24.500
Some kind of editor writes it and then you read it.

00:07:24.500 --> 00:07:24.680
Yeah.

00:07:24.680 --> 00:07:25.580
So.

00:07:25.580 --> 00:07:26.220
Fantastic.

00:07:26.220 --> 00:07:27.100
All right.

00:07:27.100 --> 00:07:27.500
Well, cool.

00:07:27.500 --> 00:07:29.740
Very nice to see that one coming along.

00:07:29.740 --> 00:07:32.340
Alvaro out in the audience.

00:07:32.340 --> 00:07:33.200
Hello there.

00:07:33.200 --> 00:07:37.260
It says, Hummel just reached version 1.0, not so long ago.

00:07:37.260 --> 00:07:42.360
So maybe that also has some kind of impact on the willingness, like, all right, the file

00:07:42.360 --> 00:07:43.160
format is stable.

00:07:43.160 --> 00:07:45.360
Now we can actually start to support it in the library.

00:07:45.360 --> 00:07:46.380
That's true.

00:07:46.380 --> 00:07:50.320
And, and we, we do support Python releases for a long time.

00:07:50.320 --> 00:07:53.580
So that it probably needed to be V1 at least.

00:07:53.580 --> 00:07:54.020
So.

00:07:54.020 --> 00:07:55.280
Yeah.

00:07:55.280 --> 00:07:59.920
And Sam also says there's a lot of stylistic choices for how you write Toml files.

00:07:59.920 --> 00:08:05.820
Like we need a black for Toml, not, not to drive Tom, not to configure black, but something

00:08:05.820 --> 00:08:09.980
that then goes against Toml files and, you know, makes them consistent.

00:08:09.980 --> 00:08:11.420
Yeah.

00:08:11.420 --> 00:08:12.320
Maybe.

00:08:12.320 --> 00:08:13.040
Yeah.

00:08:13.040 --> 00:08:13.220
Yeah.

00:08:13.220 --> 00:08:14.980
But you could, yeah, you could, you could bake that in.

00:08:14.980 --> 00:08:16.000
All right.

00:08:16.000 --> 00:08:17.340
What have I got next here?

00:08:17.340 --> 00:08:20.960
I've got sticking on the internals here.

00:08:20.960 --> 00:08:23.340
I want to talk about thread locals in Python.

00:08:23.340 --> 00:08:24.020
Okay.

00:08:24.020 --> 00:08:31.760
So last time we had Calvin on and I spoke about this crazy async running thing that I had built

00:08:31.760 --> 00:08:33.500
and boy, is it working well.

00:08:33.500 --> 00:08:37.520
I, like I said, it is truly horrifying to think about what it's doing, but it actually works

00:08:37.520 --> 00:08:38.540
perfectly.

00:08:38.540 --> 00:08:39.620
So there it is.

00:08:39.760 --> 00:08:46.360
But one of the challenges that it has is it, it doesn't like it if you call back into it

00:08:46.360 --> 00:08:46.980
again.

00:08:46.980 --> 00:08:53.440
And I talked about the nest asyncio project last time, which maybe we'll solve

00:08:53.440 --> 00:08:53.640
it.

00:08:53.640 --> 00:08:57.800
I tried those and it wasn't working, but it could have been like at a different iteration

00:08:57.800 --> 00:09:02.840
before I finally realized like, no, I have to go all in on this threading, like isolate

00:09:02.840 --> 00:09:05.520
all that execution into one place where we can control it.

00:09:05.520 --> 00:09:10.600
So maybe it would work, but I just wanted to talk about thread locals in Python, which I

00:09:10.600 --> 00:09:12.780
thought were pretty easy, and pretty interesting.

00:09:12.780 --> 00:09:15.860
So I've got this stuff running over there.

00:09:15.860 --> 00:09:20.300
And one thing that would be nice is each there's different threads calling into the system to

00:09:20.300 --> 00:09:21.880
say, schedule some work for me.

00:09:21.880 --> 00:09:23.100
Basically puts it on a queue.

00:09:23.100 --> 00:09:26.900
The queue runs it on this like controlled loop, and then it sends back the result.

00:09:26.900 --> 00:09:31.760
The problem is if, if one function calls that to put in work, and then as part of doing

00:09:31.760 --> 00:09:36.900
that work, the function itself somewhere deep down, like wraps that around, it doesn't really

00:09:36.900 --> 00:09:38.640
like the recursion aspect very much.

00:09:38.640 --> 00:09:42.960
So what I thought is, well, how do I figure out, well, this thread has running work.

00:09:42.960 --> 00:09:47.580
And if it calls again, you know, raise an exception and say, like, you need to adjust

00:09:47.580 --> 00:09:48.680
the way you're calling this library.

00:09:48.680 --> 00:09:49.400
It's not working right.

00:09:49.400 --> 00:09:51.060
Instead of just like doing some weird thing.

00:09:51.060 --> 00:09:57.800
So what I think I might do, and I'm not totally sure it will work perfectly, but the idea

00:09:57.800 --> 00:10:02.420
is certainly useful for all sorts of things is to use a thread local variable.

00:10:02.420 --> 00:10:06.580
Now, when I thought about thread local variables, I've used them in other languages, and I had

00:10:06.580 --> 00:10:07.880
no idea how to do them in Python.

00:10:07.880 --> 00:10:10.780
It turns out to be incredibly easy.

00:10:10.780 --> 00:10:13.660
You just say, go to threading, the threading module, and you say local.

00:10:13.660 --> 00:10:17.960
That becomes like a dynamic class that you can just start assigning values to.

00:10:17.960 --> 00:10:22.220
So in the example that I'm linking to, it says you get a my data thing, which is a thread

00:10:22.220 --> 00:10:24.700
local data blob, whatever.

00:10:25.140 --> 00:10:30.520
So you could say like, my data dot x equals one, my data dot list equals whatever.

00:10:30.520 --> 00:10:35.360
And then that will store that data, but it will store it on a per thread basis.

00:10:35.360 --> 00:10:37.580
So each thread sees a different value.

00:10:37.580 --> 00:10:42.560
So for example, what I could do is say thread, you know, at the beginning of the call, like

00:10:42.560 --> 00:10:43.920
I have running work.

00:10:43.920 --> 00:10:44.840
Yes.

00:10:44.840 --> 00:10:47.100
At the end, you know, roll that back.

00:10:47.100 --> 00:10:52.540
And if I ever call in to schedule some work and the thread local says, I'm doing, I have

00:10:52.540 --> 00:10:53.160
active work running.

00:10:53.280 --> 00:10:56.180
Well, there's that error case that I talked about and I don't have to do weird things

00:10:56.180 --> 00:11:01.580
like put different IDs of threads into database into like a dictionary and then like check that

00:11:01.580 --> 00:11:02.280
and then lock it.

00:11:02.280 --> 00:11:02.780
Like all sorts.

00:11:02.780 --> 00:11:07.780
I can just say this thread has like a running state for my little scenario.

00:11:07.780 --> 00:11:08.420
What do you think?

00:11:08.420 --> 00:11:09.680
I think that's great.

00:11:09.680 --> 00:11:10.580
I think it's interesting.

00:11:10.580 --> 00:11:11.560
Yeah, it is.

00:11:11.560 --> 00:11:11.760
Right.

00:11:11.760 --> 00:11:12.260
Yeah.

00:11:12.600 --> 00:11:13.960
And it's right.

00:11:13.960 --> 00:11:14.620
Not too hard.

00:11:14.620 --> 00:11:18.320
Just create one of these little local things, interact with it in a thread and each thread

00:11:18.320 --> 00:11:22.140
will have basically its own view into that data, which I think is pretty fantastic.

00:11:22.140 --> 00:11:22.500
So.

00:11:22.500 --> 00:11:26.840
Like a thread version namespace thing.

00:11:26.840 --> 00:11:27.220
Yeah.

00:11:27.220 --> 00:11:28.260
Yes, exactly.

00:11:28.260 --> 00:11:28.800
Exactly.

00:11:28.800 --> 00:11:33.280
It's a cool little isolation without doing like locks and all sorts of weird stuff that

00:11:33.280 --> 00:11:36.140
can end up in deadlocks or slowdowns or other stuff.

00:11:36.200 --> 00:11:40.900
So anyway, if you're got scenarios where you're doing threading and you're like, oh, it would

00:11:40.900 --> 00:11:45.520
be really great if I could dedicate some data just to this particular run and not like a

00:11:45.520 --> 00:11:46.060
global thing.

00:11:46.060 --> 00:11:47.180
Check this out.

00:11:47.180 --> 00:11:48.480
It's it's incredibly.

00:11:48.480 --> 00:11:49.440
Nice.

00:11:49.440 --> 00:11:49.980
Yeah.

00:11:49.980 --> 00:11:54.320
Oh, let me pull up one more thing before we move on, Brian.

00:11:54.320 --> 00:11:54.860
Okay.

00:11:54.860 --> 00:11:57.500
How about Datadog?

00:11:57.500 --> 00:11:58.640
Yes.

00:11:58.640 --> 00:12:01.900
That's also something else that's extremely easy to use.

00:12:01.900 --> 00:12:02.820
Yep.

00:12:02.820 --> 00:12:05.200
Thank you, Datadog, for sponsoring this episode.

00:12:05.560 --> 00:12:11.960
Datadog is a real time monitoring platform that unifies metrics, traces and logs into one

00:12:11.960 --> 00:12:13.520
tightly integrated platform.

00:12:13.520 --> 00:12:20.760
Datadog APM empowers developer teams to identify anomalies, resolve issues and improve application

00:12:20.760 --> 00:12:21.320
performance.

00:12:21.320 --> 00:12:27.060
Begin collecting stack traces, visualize them as flame graphs and organize them into profile

00:12:27.060 --> 00:12:29.600
types such as CPU, IO and more.

00:12:29.600 --> 00:12:35.240
Teams can search for specific profiles, correlate them with distributed traces and identify slow,

00:12:35.420 --> 00:12:38.700
or underperforming code for analysis and optimization.

00:12:38.700 --> 00:12:45.420
Plus, with Datadog's APM live search, you can perform searches across all across the full

00:12:45.420 --> 00:12:50.500
stream of integrated traces generated by your application over the last 15 minutes.

00:12:50.500 --> 00:12:51.160
That's cool.

00:12:51.820 --> 00:12:58.040
Try Datadog APM free with a 14 day free trial and Datadog will send you a free t-shirt.

00:12:58.040 --> 00:13:06.060
Visit pythonbytes.fm/Datadog or just click the link in your podcast player show notes to get

00:13:06.060 --> 00:13:06.500
started.

00:13:07.100 --> 00:13:07.300
Yes.

00:13:07.300 --> 00:13:07.980
Thank you, Datadog.

00:13:07.980 --> 00:13:10.480
I love all the visibility into what's going on.

00:13:10.480 --> 00:13:15.360
I was just dealing with some crashes and other issues on something I was trying to roll out.

00:13:15.360 --> 00:13:17.620
Some library was conflicting with some other library.

00:13:17.620 --> 00:13:18.160
They were fighting.

00:13:18.160 --> 00:13:21.880
And yeah, it's great to be able to just log in and see what's going on.

00:13:22.380 --> 00:13:26.120
Now, before we move off to Threadlocals, quick audience question.

00:13:26.120 --> 00:13:30.780
Sam out there says, it might be better to use context vars if you're also working with an invent loop.

00:13:30.780 --> 00:13:36.480
As far as I know, context vars are the evolved version of Threadlocals that are aware of async too.

00:13:36.480 --> 00:13:37.920
That's very interesting.

00:13:38.020 --> 00:13:46.360
I haven't done anything with context vars, but the way I think asyncio works is even though there's a bunch of stuff running from different locations, there's one thread.

00:13:46.360 --> 00:13:48.120
So Threadlocal is useless for that.

00:13:48.120 --> 00:13:50.560
So that's why Sam is suggesting context vars.

00:13:50.560 --> 00:13:55.720
The side that schedules the work has nothing to do with asyncio in my world.

00:13:55.720 --> 00:13:57.040
So that's why I was thinking Threadlocal.

00:13:57.040 --> 00:14:03.700
It's a good highlight to say if you're using async, you may need something different.

00:14:03.700 --> 00:14:04.580
Absolutely.

00:14:04.580 --> 00:14:04.900
Yeah.

00:14:04.900 --> 00:14:06.380
So thanks, Sam, for that.

00:14:06.900 --> 00:14:16.980
Yeah, so I'm not sure if we've really talked about it much, but I came across that article from Trey Hunter called, What is a Generator Function?

00:14:16.980 --> 00:14:28.360
And like Python, especially, you know, the two to three switch, even like dictionary, the items keyword, you know, function to get all the dictionary elements out.

00:14:28.360 --> 00:14:30.440
It doesn't return a list anymore.

00:14:30.440 --> 00:14:31.460
It returns a generator.

00:14:31.460 --> 00:14:34.180
And maybe it always did.

00:14:34.180 --> 00:14:34.640
I don't know.

00:14:34.640 --> 00:14:38.660
But there's a whole bunch of stuff that used to return lists that now return generators.

00:14:38.660 --> 00:14:41.860
And it kind of, they work great.

00:14:41.860 --> 00:14:45.000
You stick them in a for loop and you're off to the races.

00:14:45.500 --> 00:14:53.960
But a lot of people are a little timid at first to try to write their own because it's a yield statement instead of a return.

00:14:53.960 --> 00:14:55.700
And how do you do it?

00:14:56.180 --> 00:15:01.800
And so this is a great article by Trey to just say, here's what's going on.

00:15:01.800 --> 00:15:03.260
It's not that complicated.

00:15:03.260 --> 00:15:08.440
Generally, you just have a, you often might have a for loop within your code.

00:15:08.520 --> 00:15:17.860
And instead of returning all the items, you're going to try to write your own.

00:15:17.860 --> 00:15:21.080
And it's pretty interesting.

00:15:21.300 --> 00:15:26.140
It's interesting for people to read through it and understand what kind of what's going on behind the scenes.

00:15:26.140 --> 00:15:32.920
So what happens is your function that has a yield in it, it will not return the item right away.

00:15:32.920 --> 00:15:36.780
When somebody calls it, it returns a generator object.

00:15:36.780 --> 00:15:40.500
And that generator object has things like next.

00:15:40.500 --> 00:15:42.560
And mostly that's what we care about.

00:15:43.000 --> 00:15:46.900
And next returns the next item that you've returned.

00:15:46.900 --> 00:15:52.400
And then once you run out of items, it raises a stop iteration exception.

00:15:52.400 --> 00:15:54.320
And that's how it works.

00:15:54.320 --> 00:15:57.080
But generally, we just don't care about that stuff.

00:15:57.080 --> 00:15:58.460
We just throw them in a for loop.

00:15:58.460 --> 00:16:01.980
But it is interesting to learn some of the details around it.

00:16:01.980 --> 00:16:06.540
Yeah, they do seem mysterious and tricky, but they're super powerful.

00:16:06.540 --> 00:16:11.900
The more data that you have, the way better idea it is to not load it all into memory at once.

00:16:12.340 --> 00:16:16.440
Yeah, and you can do some fun things like chunking.

00:16:16.440 --> 00:16:23.360
You can, like if you're returning, like your caller, like let's say, and these are fun things to do with this.

00:16:23.360 --> 00:16:29.040
So let's say you're reading from an API or from a file or from a device or something.

00:16:29.040 --> 00:16:37.000
And it has, you read like a big chunk of things, like 20 of them or 256 or something like that.

00:16:37.000 --> 00:16:38.480
A whole bunch of data at once.

00:16:38.680 --> 00:16:43.060
But then your caller item, your caller really only wants one at a time.

00:16:43.060 --> 00:16:50.620
Within your function, your generator function, you can do fancy stuff like read a whole bunch and then just meter those out.

00:16:50.620 --> 00:16:55.420
And when then that's empty, you go and read some more and have intermittent reads.

00:16:55.420 --> 00:17:00.120
And this will save time for, especially when you're not reading everything often.

00:17:00.120 --> 00:17:02.840
Sometimes the caller will break and not utilize everything.

00:17:02.840 --> 00:17:08.160
So that's definitely where, and they're very, they're a lot more efficient on memory too.

00:17:08.160 --> 00:17:13.840
So if you're, like you said, if it's huge amounts of things, it might be either for memory reasons or for speed reasons.

00:17:14.040 --> 00:17:14.660
These are great.

00:17:14.660 --> 00:17:14.960
Yeah.

00:17:14.960 --> 00:17:26.020
Even computational, like, so suppose you want a list of Pydantic objects back and you're like reading some massive CSV and picking each row and star star value in there somehow.

00:17:26.020 --> 00:17:31.380
That's the actual creation of the Pydantic object.

00:17:31.380 --> 00:17:33.880
If there was like a million of them, forget memory.

00:17:33.880 --> 00:17:35.840
Like even just the computation is expensive.

00:17:35.840 --> 00:17:40.740
So if you only want the first 20, like you can only pay the price of initializing the first 20.

00:17:40.820 --> 00:17:42.140
So there's, there's all sorts of good reasons.

00:17:42.140 --> 00:17:42.640
Yeah.

00:17:42.640 --> 00:17:43.300
Okay.

00:17:43.300 --> 00:17:53.640
I do want, I do want to just say one thing about generators that I wish there was like a slightly, maybe some kind of behavior could be added, which would be fantastic.

00:17:53.640 --> 00:17:56.700
So generators can't be reused.

00:17:56.700 --> 00:17:57.200
Yeah.

00:17:57.200 --> 00:17:57.480
Right.

00:17:57.480 --> 00:18:03.460
So if I get a result back from a function, I try to, and I want to ask you a question, like, were there any items resolved in here?

00:18:03.460 --> 00:18:06.940
And then loop over them if there were like you, you kind of broke it, right?

00:18:06.940 --> 00:18:14.320
You pulled the first one off and then the next thing you work with is like index one through N rather than zero through N, which is a problem.

00:18:14.320 --> 00:18:16.600
So sometimes you need to turn them to a list.

00:18:16.600 --> 00:18:22.760
It'd be cool if there was like a dot two list on a generator instead of having to call list on it, right?

00:18:22.760 --> 00:18:27.520
Just like a way as an expression to kind of like, I'm calling this and it's sort of a data science flow.

00:18:27.520 --> 00:18:31.660
I want all one expression and turn this generator into this other thing that I need to pass along.

00:18:32.000 --> 00:18:32.060
Yeah.

00:18:32.060 --> 00:18:33.440
It would be fun.

00:18:33.440 --> 00:18:34.800
Yeah.

00:18:34.800 --> 00:18:43.760
So a question out in the audience that maybe they, they returns that the dictionary items and keys return something different.

00:18:43.760 --> 00:18:50.640
But Sam Morley says they, they return special generators, special kinds of generators.

00:18:50.640 --> 00:18:51.640
So yeah.

00:18:51.640 --> 00:18:52.100
Thanks Sam.

00:18:52.100 --> 00:18:52.580
Cool.

00:18:52.580 --> 00:18:53.000
Indeed.

00:18:53.940 --> 00:18:54.540
All right.

00:18:54.540 --> 00:18:57.140
Well, what have I got next?

00:18:57.140 --> 00:18:58.380
I think I just closed it.

00:18:58.380 --> 00:19:02.780
Now, would it really be an episode if we didn't talk about Will McGugan in some way or another?

00:19:02.780 --> 00:19:07.340
So we got him on deck twice, but we're going to start with just something he recommended to us.

00:19:07.340 --> 00:19:12.300
That's actually by Sam Colvin, who is the creator of Pedantic.

00:19:13.060 --> 00:19:17.380
And I'm not sure if you're ready for this, Brian, but this is a little bit dirty.

00:19:17.380 --> 00:19:19.920
It's called dirty equals.

00:19:19.920 --> 00:19:35.520
And the idea is to abuse the Dunder EQ method, mostly around unit testing, to make test cases and assertions and other things you might want to test more declarative and less imperative.

00:19:36.860 --> 00:19:39.300
So it all sounds like fun, but how about an example?

00:19:39.300 --> 00:19:41.260
So it starts out with a trivial example.

00:19:41.260 --> 00:19:45.660
It says, okay, from this library, you can import something called is positive.

00:19:45.660 --> 00:19:50.180
So then you could assert one or like some number and whatever.

00:19:50.180 --> 00:19:52.280
One equal equal is positive.

00:19:52.280 --> 00:19:53.200
That's true.

00:19:53.200 --> 00:19:54.320
That assert passes.

00:19:54.320 --> 00:19:57.540
Negative two equal equal is positive fails.

00:19:57.540 --> 00:19:58.360
Okay.

00:19:58.360 --> 00:20:00.460
How does that strike you, Brian?

00:20:00.460 --> 00:20:01.880
We're building.

00:20:01.880 --> 00:20:03.000
These are building blocks.

00:20:03.000 --> 00:20:06.860
This is like a Lego piece, not the whole X wing fighter.

00:20:06.860 --> 00:20:09.220
But anyway, so that's the building block, right?

00:20:09.220 --> 00:20:20.720
Like take something and instead of saying, yes, it's exactly equal, implement the Dunder equal method in the is positive class to like take the value, make sure it's a number, then check whether it's greater than zero.

00:20:20.720 --> 00:20:20.940
Right.

00:20:20.940 --> 00:20:21.680
That kind of thing.

00:20:21.680 --> 00:20:23.940
I don't know if that includes zero, but anyway.

00:20:23.940 --> 00:20:26.100
But then you can get more interesting things.

00:20:26.100 --> 00:20:34.800
So you could go to a database and if you do a query against the database, you get, I think in the case that's up there, I think you get a tuple back.

00:20:34.800 --> 00:20:37.560
It depends on what you set the row factory to be, I suppose.

00:20:37.560 --> 00:20:41.300
But anyway, you get a tuple back of results.

00:20:41.300 --> 00:20:43.240
It looks like maybe this is a dictionary.

00:20:43.460 --> 00:20:50.820
Anyway, so then you can create a dictionary that has attributes that are like the result you want.

00:20:50.820 --> 00:20:53.660
They can either be equal or they can be things like this is positive.

00:20:53.660 --> 00:20:58.540
So in this case, we're doing a query against the database.

00:20:58.540 --> 00:21:04.120
And then we're, looks like there's maybe needs to be like a first one.

00:21:04.180 --> 00:21:15.400
Anyway, it says, all right, what we're going to do is we're going to do equal, equal that the ID, we'll create a dictionary, ID colon is positive int, username colon, Sam Colvin.

00:21:15.400 --> 00:21:17.040
So that's an actual equality.

00:21:17.040 --> 00:21:18.900
Like the username has to be Samuel here.

00:21:18.900 --> 00:21:19.360
Okay.

00:21:19.360 --> 00:21:20.060
Yeah.

00:21:20.060 --> 00:21:23.940
And then the avatar is a string that matches a regular expression.

00:21:23.940 --> 00:21:26.740
That's like a number slash PNG.

00:21:26.740 --> 00:21:33.420
The settings has to be a JSON thing where inside the settings, it's got some JSON values that you might test for.

00:21:33.740 --> 00:21:41.980
And that is created now, is now with some level of variation, like some level of precision that you're willing to work with.

00:21:41.980 --> 00:21:42.200
Right.

00:21:42.200 --> 00:21:49.240
Because obviously you run the database query and then you get the result, but it's like very near, nearly now.

00:21:49.240 --> 00:21:49.500
Right.

00:21:49.500 --> 00:21:52.480
It's like the almost equals and float type of stuff.

00:21:52.480 --> 00:21:53.180
That's pretty cool.

00:21:53.180 --> 00:21:53.380
Right.

00:21:53.380 --> 00:21:57.740
Do I need to answer?

00:21:57.740 --> 00:21:59.800
I mean, I could see the utility.

00:21:59.800 --> 00:22:00.520
I'm sure your thoughts.

00:22:00.520 --> 00:22:01.060
Yeah.

00:22:01.060 --> 00:22:03.720
But the, I don't know.

00:22:03.720 --> 00:22:06.580
It's the API is a little odd to me, but.

00:22:06.580 --> 00:22:07.680
Okay.

00:22:07.680 --> 00:22:08.220
Yeah.

00:22:08.220 --> 00:22:10.300
I think it's, it's definitely an interesting idea.

00:22:10.300 --> 00:22:11.320
It's definitely different.

00:22:11.320 --> 00:22:16.900
you know, Pydantic is often about, I know it's not Pydantic, but it's by the creator.

00:22:16.900 --> 00:22:23.180
Pydantic is often about, given some data that kind of matches, can it be made into that thing?

00:22:23.180 --> 00:22:30.640
And I feel like this kind of testing is in the same vein as what you might get working with Pydantic and data.

00:22:30.640 --> 00:22:31.040
Yeah.

00:22:31.040 --> 00:22:31.440
Right.

00:22:31.440 --> 00:22:35.140
Well, it's definitely, it's definitely terse and, and, and useful.

00:22:35.140 --> 00:22:39.160
so, and, and I could totally get used to it.

00:22:39.160 --> 00:22:48.440
If this is a, this is a pretty, pretty, condensed way to, to compare, to see if everything, matches this protocol.

00:22:48.440 --> 00:22:48.960
Yeah.

00:22:48.960 --> 00:22:49.560
Yeah.

00:22:49.640 --> 00:22:56.700
So Sergey on the audience has like sort of the alternative perspective could be, you could just write multiple assert statements.

00:22:56.700 --> 00:23:06.180
Instead of creating a dictionary that represents everything, you could say like, get the record back and assert that, you know, get the first value out and assert on it.

00:23:06.180 --> 00:23:10.460
Then get the username out and assert and get the avatar and assert on it and so on.

00:23:10.460 --> 00:23:19.160
And it's sort of an intermediate view, a story where you use the testing libraries, the testing classes, but sort of more explosive.

00:23:19.460 --> 00:23:20.180
So, right.

00:23:20.180 --> 00:23:25.780
And one of the reasons why a lot of people, there's, there's a couple of reasons why to not use more than one assert.

00:23:25.780 --> 00:23:31.000
because if you were to have multiple asserts, the first one to fail stops the check.

00:23:31.000 --> 00:23:34.780
It's possible that this will tell you everything that's, that's wrong.

00:23:34.780 --> 00:23:36.360
Not just the first thing that's wrong.

00:23:36.360 --> 00:23:37.440
Yes, exactly.

00:23:37.440 --> 00:23:42.920
and, and then, you know, some people are just opposed to multiple asserts per test.

00:23:42.920 --> 00:23:45.840
It's just for, you know, I don't know.

00:23:45.840 --> 00:23:47.980
I mean, a similar thing.

00:23:48.080 --> 00:23:56.180
So I have a, a plugin called py test check, which is, is just, it uses checks

00:23:56.180 --> 00:24:02.940
instead of asserts so that you can have multiple checks per test, but, it does come up.

00:24:02.940 --> 00:24:04.240
So this is interesting.

00:24:04.240 --> 00:24:06.700
I'll definitely check it out and play with it.

00:24:06.860 --> 00:24:07.220
Yeah.

00:24:07.220 --> 00:24:14.240
Another benefit of being able to construct one of these like prototypical documents or, dictionaries

00:24:14.240 --> 00:24:18.380
that then represents the declarative behavior or state that you're supposed to be testing

00:24:18.380 --> 00:24:22.020
for is you could create one of these and then use it different locations.

00:24:22.020 --> 00:24:25.240
Like, okay, when I insert a record and then I get it back out, it should be like this.

00:24:25.460 --> 00:24:32.080
But also if I call the API and it gives me something back, it should also still pass the same test.

00:24:32.080 --> 00:24:34.220
Like you could have a different parts of my app.

00:24:34.220 --> 00:24:35.480
They all need to look like this.

00:24:35.480 --> 00:24:35.960
Yeah.

00:24:36.260 --> 00:24:39.940
As opposed to having a bunch of tests over and over that are effectively the same.

00:24:39.940 --> 00:24:46.240
And Will is here who recommended this suggests, one of the benefits of dirty equals is that

00:24:46.240 --> 00:24:49.200
py test will generate, generate useful diffs from it.

00:24:49.200 --> 00:24:49.840
Yeah.

00:24:49.840 --> 00:24:54.980
and definitely, reasons, py test being a reason to use something.

00:24:54.980 --> 00:24:56.140
I'm on board then.

00:24:56.140 --> 00:24:56.560
Yeah, sure.

00:24:57.940 --> 00:24:58.340
Yeah.

00:24:58.340 --> 00:24:59.000
Check it out.

00:24:59.000 --> 00:25:01.720
If you do play with it, give us a report how you feel about it.

00:25:01.720 --> 00:25:07.760
One more question from, Sam, said, Sam Morley, py test already has something

00:25:07.760 --> 00:25:13.820
a bit like this with a prox, except for it's for floats, et cetera, except for a prox

00:25:13.820 --> 00:25:14.860
is not, et cetera.

00:25:14.860 --> 00:25:15.920
It's just for floats.

00:25:15.920 --> 00:25:18.060
So you can only use approximate floats.

00:25:18.060 --> 00:25:18.820
So yeah.

00:25:18.820 --> 00:25:22.320
So we have like approximate now and stuff like that.

00:25:22.320 --> 00:25:25.180
So I'll, I'll try it.

00:25:25.180 --> 00:25:27.880
Especially, you know, if Will likes it, it's gotta be.

00:25:27.880 --> 00:25:28.200
Good.

00:25:28.200 --> 00:25:29.780
Exactly.

00:25:29.780 --> 00:25:31.840
So awesome.

00:25:31.840 --> 00:25:32.280
All right.

00:25:32.280 --> 00:25:34.000
What's the final one you got for us here?

00:25:34.000 --> 00:25:34.380
Okay.

00:25:34.380 --> 00:25:39.280
This is more of a question than a, I'm not like saying this is awesome, but I ran across

00:25:39.280 --> 00:25:39.680
this.

00:25:39.680 --> 00:25:46.960
actually this, I, I went, I clicked on a listicle, Mike, I think there's a self

00:25:46.960 --> 00:25:47.800
help group for that.

00:25:47.800 --> 00:25:48.580
yeah.

00:25:48.580 --> 00:25:53.900
well, we're definitely prone to clicking on the top listicles.

00:25:53.900 --> 00:25:57.560
So my name is Brian and I clicked on a listicle.

00:25:57.720 --> 00:26:03.680
so the listicle was a top 10 where we at, it was, 10 tools.

00:26:03.680 --> 00:26:08.540
I wish I knew when I started working with Python and actually it's a good list.

00:26:08.540 --> 00:26:10.240
I just knew about most of them as all.

00:26:10.240 --> 00:26:12.300
So it's, it's, it's a little link to it anyway.

00:26:12.300 --> 00:26:13.840
It's, it's got the sound of music.

00:26:13.840 --> 00:26:14.900
It's got Jackie Chan.

00:26:14.900 --> 00:26:15.820
It's got office space.

00:26:15.820 --> 00:26:16.220
Come on.

00:26:16.220 --> 00:26:17.920
This is a pretty solid listicle.

00:26:18.020 --> 00:26:21.740
Then I got down to number seven and eight and I'm like, what are these things?

00:26:21.740 --> 00:26:22.540
I've never heard of them.

00:26:22.540 --> 00:26:25.480
So, committison and semantic release.

00:26:25.480 --> 00:26:29.240
So, the idea.

00:26:29.240 --> 00:26:32.540
So I tried to do a commit with this.

00:26:32.540 --> 00:26:37.680
So committison is a thing that you can say, if you install it, you can either brew, install

00:26:37.680 --> 00:26:40.340
it for your everything, or you can put it in a virtual environment.

00:26:40.340 --> 00:26:41.180
So that's cool.

00:26:41.180 --> 00:26:48.240
But it's, you, you, instead of just committing, you use this to commit and it asks you questions.

00:26:48.240 --> 00:26:48.760
Right.

00:26:48.760 --> 00:26:52.180
Instead of typing get space commit, you type CZ space commit.

00:26:52.180 --> 00:26:52.560
Yeah.

00:26:52.560 --> 00:26:55.740
And then instead of like, it, and it asks you a whole bunch of stuff.

00:26:55.740 --> 00:26:56.820
It was this a bug fix.

00:26:56.820 --> 00:26:57.340
Fix.

00:26:57.340 --> 00:26:58.220
Was it a feature?

00:26:58.220 --> 00:27:03.620
Did you, and then it follows on what, depending on what you answered, if you had a, if you had

00:27:03.620 --> 00:27:06.960
a, a bug fix or a feature, is it a breaking feature?

00:27:06.960 --> 00:27:10.320
Did you basically it's trying to, it's, it's doing a whole bunch of things.

00:27:10.320 --> 00:27:15.420
But it's trying to do these, conventional, conventional commits.

00:27:15.420 --> 00:27:17.220
And we've got a link to this too.

00:27:17.220 --> 00:27:23.040
And, and then if you've got all this formatting, so it ends up formatting your commit message

00:27:23.040 --> 00:27:28.880
to a consistent format so that when you're reading the history and stuff, you can do a whole

00:27:28.880 --> 00:27:30.980
bunch of, it's easier, I guess.

00:27:30.980 --> 00:27:38.180
and then, this tool also, this listicle also commented that you've got,

00:27:38.180 --> 00:27:43.600
semantic release, which is a Python package that I haven't got through this much, but

00:27:43.600 --> 00:27:50.400
it, it can take this, all this information from these and do some better control your semantic

00:27:50.400 --> 00:27:51.940
release notes or release.

00:27:51.940 --> 00:27:54.260
I don't know if it's the release notes or just the release version.

00:27:54.260 --> 00:27:56.060
I haven't got that far into it, but.

00:27:56.560 --> 00:27:56.680
Yeah.

00:27:56.680 --> 00:27:57.820
The commit is an ass.

00:27:57.820 --> 00:28:03.080
Is this a, like a change corresponding to semantic versions such that it should be a major change.

00:28:03.080 --> 00:28:06.220
So it'll like, it looks like it'll increment the version and stuff like that as well.

00:28:06.220 --> 00:28:06.620
Yeah.

00:28:06.620 --> 00:28:07.240
Yeah.

00:28:07.420 --> 00:28:14.620
but so, the, in the about, for commitment says command line utility to create

00:28:14.620 --> 00:28:16.380
commits with your rules.

00:28:16.380 --> 00:28:20.920
And apparently you can, you can specify some special rules, which is good.

00:28:20.920 --> 00:28:26.840
display information about your commits, bump the version automatically and, generate

00:28:26.840 --> 00:28:28.420
a change log.

00:28:28.500 --> 00:28:29.240
That's cool.

00:28:29.240 --> 00:28:30.900
I want, that might be helpful.

00:28:30.900 --> 00:28:36.860
so my questions out to the audience and everybody listening, have you used something

00:28:36.860 --> 00:28:37.420
like this?

00:28:37.420 --> 00:28:38.080
Is it useful?

00:28:38.080 --> 00:28:41.200
is there something different than this that you recommend?

00:28:41.200 --> 00:28:45.080
And also what size of a project would this make sense for a small or medium project?

00:28:45.080 --> 00:28:45.920
That's cool.

00:28:45.920 --> 00:28:46.140
Yeah.

00:28:46.140 --> 00:28:48.640
Let us know on Twitter or at the bottom of the YouTube live stream.

00:28:48.640 --> 00:28:49.480
It's probably the best place.

00:28:49.480 --> 00:28:50.120
Yep.

00:28:50.120 --> 00:28:50.620
So.

00:28:50.620 --> 00:28:51.200
Yeah.

00:28:51.200 --> 00:28:52.020
Very cool.

00:28:52.020 --> 00:28:55.100
Now, before you go on, I also have a question out to you.

00:28:55.100 --> 00:28:57.260
You can be the proxy for the audience here.

00:28:57.260 --> 00:28:57.560
Okay.

00:28:57.560 --> 00:28:59.980
Notice at the bottom it says requirements three, six and above.

00:28:59.980 --> 00:29:01.200
yeah.

00:29:01.200 --> 00:29:06.400
And Python, that's not, I don't feel like that's very controversial as three, six is not even

00:29:06.400 --> 00:29:07.040
supported anymore.

00:29:07.040 --> 00:29:07.240
Right.

00:29:07.240 --> 00:29:07.500
Right.

00:29:07.500 --> 00:29:12.820
So this is like every possibly supported version of Python three, this works for.

00:29:12.820 --> 00:29:18.800
Would, what would you think if I said the requirement is this is Python three, not Python

00:29:18.800 --> 00:29:20.360
three, just, it requires Python three.

00:29:20.360 --> 00:29:27.540
Knowing that like that means, or implying that that means supported shipping, real,

00:29:27.540 --> 00:29:29.800
versions of Python, not Python three, one.

00:29:29.800 --> 00:29:30.440
Right.

00:29:30.440 --> 00:29:34.380
Cause obviously Python three, one is no longer supported, but neither is three, five even

00:29:34.380 --> 00:29:38.500
like, could you say f-strings are just in Python three now without worrying about the version?

00:29:38.500 --> 00:29:40.220
Or do you need to, you still need to say.

00:29:40.220 --> 00:29:42.340
Three, six, three, six, three, seven.

00:29:42.340 --> 00:29:43.220
Like, should this be updated?

00:29:43.220 --> 00:29:43.900
It'd be three, seven.

00:29:43.900 --> 00:29:44.480
You know what I mean?

00:29:44.560 --> 00:29:45.820
Kind of have to.

00:29:45.820 --> 00:29:47.240
You think so?

00:29:47.240 --> 00:29:48.160
I, I don't know.

00:29:48.160 --> 00:29:54.660
I, I know I, when I say, something is on three Python three, actually, I don't even

00:29:54.660 --> 00:29:55.420
say that anymore.

00:29:55.420 --> 00:29:56.440
So yeah.

00:29:56.440 --> 00:29:57.920
What do you think?

00:29:57.920 --> 00:29:58.420
Okay.

00:29:58.600 --> 00:30:02.400
well, I used it in the sense like, yeah, you need Python three for this thinking,

00:30:02.400 --> 00:30:06.780
well, any version that's supported these days and people are like, well, there's older versions

00:30:06.780 --> 00:30:07.800
that don't support this thing.

00:30:07.800 --> 00:30:12.280
Like, well, you know, obviously I'm not talking about the one that was not supported five years

00:30:12.280 --> 00:30:12.500
ago.

00:30:12.500 --> 00:30:18.440
Like at some point, Python three is the supported version of Python.

00:30:18.440 --> 00:30:19.240
I don't know.

00:30:19.240 --> 00:30:19.880
Oh, that's true.

00:30:19.880 --> 00:30:20.580
Yeah.

00:30:20.580 --> 00:30:21.360
Okay.

00:30:21.360 --> 00:30:24.220
So that's a bit of a diversion there, but I went down that route.

00:30:24.220 --> 00:30:24.420
Hold on.

00:30:24.420 --> 00:30:27.460
It's like, I really don't know which way I should go, but I feel like there's, there's a case

00:30:27.460 --> 00:30:31.500
to be made that just like, when you talk about Python three, you're not talking about old

00:30:31.500 --> 00:30:32.420
unsupported versions.

00:30:32.420 --> 00:30:38.700
You're everything that's like modern three, seven and above should be like an, an, an, an alias

00:30:38.700 --> 00:30:39.440
for Python three.

00:30:39.440 --> 00:30:39.940
I don't know.

00:30:39.940 --> 00:30:43.060
When we were just saying Python three, what we meant was like three, one.

00:30:43.060 --> 00:30:45.740
So I know we got to get used to that.

00:30:45.740 --> 00:30:48.600
There's no Python two really to worry about.

00:30:48.600 --> 00:30:49.480
All right.

00:30:49.480 --> 00:30:52.580
Well, that will definitely bring us to our extras in a moment.

00:30:52.580 --> 00:30:53.440
Yeah.

00:30:53.440 --> 00:30:54.240
Yeah.

00:30:54.240 --> 00:30:54.580
All right.

00:30:54.580 --> 00:30:57.340
You want me to kick it off since I got my screen up?

00:30:57.340 --> 00:30:58.080
Yeah, go ahead.

00:30:58.080 --> 00:30:58.760
All right.

00:30:58.760 --> 00:31:02.600
So we'll, like I said, he gets two appearances and also it's comments.

00:31:02.600 --> 00:31:03.280
So thank you for that.

00:31:03.280 --> 00:31:06.240
And this is like in the same vein of what I was just talking about.

00:31:06.240 --> 00:31:08.420
Like what is this convention that we want to have?

00:31:08.420 --> 00:31:08.580
Right.

00:31:08.660 --> 00:31:14.960
So the Walrus operator came out in three eight and it was kind of an interesting big deal,

00:31:14.960 --> 00:31:15.160
right?

00:31:15.160 --> 00:31:18.880
There's a lot of debate around whether or not that should be in the language.

00:31:18.880 --> 00:31:22.520
Honestly, I think it's a pretty minor thing that that's not a, not a huge deal, but the

00:31:22.520 --> 00:31:29.560
idea is you can both test for a variable as well, or you can use the test or use the value

00:31:29.560 --> 00:31:32.400
of the variable in the same place that you create it.

00:31:32.400 --> 00:31:38.200
So instead of saying X equals get user or like you equals get user, if user is not none or

00:31:38.200 --> 00:31:43.800
if user, you could just say, if you colon equals get user do the true thing.

00:31:43.800 --> 00:31:45.520
Otherwise then it's, it's not set.

00:31:45.520 --> 00:31:45.760
Right.

00:31:46.260 --> 00:31:54.920
And so Will is suggesting that we pronounce the Walrus operator as you becomes the value.

00:31:54.920 --> 00:31:58.180
So like X colon equals seven is like X becomes seven.

00:31:58.180 --> 00:31:59.060
What do you think?

00:31:59.060 --> 00:32:00.200
Are you behind this?

00:32:00.200 --> 00:32:00.540
Okay.

00:32:00.540 --> 00:32:03.700
So you'd be like when you're reading your code to yourself, I guess.

00:32:03.780 --> 00:32:04.340
How do you say it?

00:32:04.340 --> 00:32:09.520
Like if you say like the Lambda expression, like how do you like define like the variables

00:32:09.520 --> 00:32:10.060
of the land?

00:32:10.060 --> 00:32:14.360
Like there's, there's terms around there that make it a little bit hard to say without just

00:32:14.360 --> 00:32:14.980
saying syntax.

00:32:14.980 --> 00:32:15.340
Right.

00:32:15.340 --> 00:32:21.920
So he's proposing like becomes is the saying, the verbal, the way we verbalize Walrus

00:32:21.920 --> 00:32:22.240
operator.

00:32:22.240 --> 00:32:24.120
I like it.

00:32:24.120 --> 00:32:24.980
I'm going to give it a thumbs up.

00:32:24.980 --> 00:32:25.680
It's interesting.

00:32:25.680 --> 00:32:27.740
But what, how is that different from assignment though?

00:32:27.740 --> 00:32:29.960
Do we, do you say, what do you say with assignment?

00:32:29.960 --> 00:32:33.380
I don't say like X equals, I don't know.

00:32:33.740 --> 00:32:33.860
Yeah.

00:32:33.860 --> 00:32:36.960
Equals, the same become, becomes works.

00:32:36.960 --> 00:32:38.560
all right.

00:32:38.560 --> 00:32:39.120
Well, I'll put it out there.

00:32:39.120 --> 00:32:40.040
People can think about it.

00:32:40.040 --> 00:32:43.420
And there's a, there's a nice Twitter thread here with a, lots of comments.

00:32:43.420 --> 00:32:46.160
so folks can jump in.

00:32:46.160 --> 00:32:50.480
Or you just, walrus, just talk X walrus five.

00:32:50.480 --> 00:32:51.680
oh yeah.

00:32:51.680 --> 00:32:53.780
Well, what do walruses do?

00:32:53.780 --> 00:32:57.900
I mean, is there like a cool action that would, is like particular to walruses?

00:32:57.900 --> 00:33:01.060
Well, there probably is, but it's not, it doesn't apply to this.

00:33:01.060 --> 00:33:03.040
It's not a very colloquial, is it?

00:33:03.700 --> 00:33:05.040
is X.

00:33:05.040 --> 00:33:05.620
Yeah.

00:33:05.620 --> 00:33:11.580
And John, then John Sheehan out of the audience says, in my brain, I use assigned to, and he

00:33:11.580 --> 00:33:14.460
must know what's coming because he's up next.

00:33:14.460 --> 00:33:17.380
Hey John.

00:33:17.580 --> 00:33:22.180
so the other thing I want to talk about is, did you know, I learned through John that

00:33:22.180 --> 00:33:28.500
string starts with, we'll take a, an iterable, it says tuple, but I suspect it might even be

00:33:28.500 --> 00:33:30.980
an iterable of sub strings.

00:33:31.340 --> 00:33:35.400
And if any of them match, it will, it'll test out to be true.

00:33:35.400 --> 00:33:41.600
So like ABCDEF, you say starts with a tuple AB or CD or EF.

00:33:41.600 --> 00:33:42.300
Huh?

00:33:42.580 --> 00:33:43.740
I've never used this.

00:33:43.740 --> 00:33:48.700
I didn't know that that was, I would always just do that as like X starts with AB or X starts

00:33:48.700 --> 00:33:51.200
with CD or X starts with EF.

00:33:51.200 --> 00:33:53.100
No, you can apparently can do that all in one go.

00:33:53.100 --> 00:33:54.340
What's the two for?

00:33:54.340 --> 00:33:55.880
I have no idea.

00:33:55.960 --> 00:33:57.180
I was just thinking that as well.

00:33:57.180 --> 00:33:58.960
There's a two and I don't know where, what is four.

00:33:58.960 --> 00:34:02.480
So yeah.

00:34:02.480 --> 00:34:02.980
Yeah.

00:34:02.980 --> 00:34:06.400
Anyway, that's a super quick one, but I thought, pretty interesting there.

00:34:06.400 --> 00:34:08.040
That's all I got.

00:34:08.040 --> 00:34:09.040
How about you?

00:34:09.040 --> 00:34:15.820
I just have one thing that I, we don't need to put it up, but my extra is this book.

00:34:15.820 --> 00:34:20.220
You have your physical 2.0 book in hand.

00:34:20.220 --> 00:34:20.600
Yes.

00:34:20.600 --> 00:34:22.060
I've got, I've, Oh yeah.

00:34:22.100 --> 00:34:28.740
And for the people not, not watching, my, I've got a stack of, it's funny.

00:34:28.740 --> 00:34:31.100
My, my, my daughter uses my Amazon account too.

00:34:31.100 --> 00:34:34.380
So UPS said, Hey, there's a package arriving yesterday.

00:34:34.380 --> 00:34:37.340
And I said, I didn't, and I didn't order anything.

00:34:37.340 --> 00:34:41.880
So I said, I told my daughter, Hey, you probably have a package showing up.

00:34:41.880 --> 00:34:43.960
She's like, I didn't order anything.

00:34:43.960 --> 00:34:49.520
and then this box arrives with five copies of my book, which is great.

00:34:49.520 --> 00:34:50.860
That's awesome.

00:34:50.860 --> 00:34:51.220
Yeah.

00:34:51.640 --> 00:34:51.840
Yeah.

00:34:51.840 --> 00:34:52.300
Congratulations.

00:34:52.300 --> 00:34:52.740
Thanks.

00:34:52.740 --> 00:34:53.260
Very cool.

00:34:53.260 --> 00:34:53.920
Yeah.

00:34:53.920 --> 00:34:56.320
We abuse our Amazon account badly.

00:34:56.320 --> 00:34:58.420
Like there's a lot of people that log into Amazon.

00:34:58.420 --> 00:35:00.880
We end up getting stuff shipped wrong places.

00:35:00.880 --> 00:35:02.980
Cause somebody shipped it to their house last time.

00:35:02.980 --> 00:35:04.380
And then we just hit reorder again.

00:35:04.380 --> 00:35:06.140
And they're like, why do you have our shampoo?

00:35:06.140 --> 00:35:06.760
I don't know.

00:35:06.760 --> 00:35:07.580
Yeah.

00:35:07.580 --> 00:35:08.640
yeah.

00:35:08.640 --> 00:35:12.880
So John adds that the, two is the starting position.

00:35:12.880 --> 00:35:14.600
Oh, the starting position.

00:35:14.600 --> 00:35:15.200
Yeah.

00:35:15.200 --> 00:35:15.500
Right.

00:35:15.500 --> 00:35:16.600
I figured it had something to do with that.

00:35:16.600 --> 00:35:18.620
I wasn't sure how many characters to compare out, whatever.

00:35:18.620 --> 00:35:21.620
Well, I also didn't know if the, that you could do that.

00:35:21.620 --> 00:35:22.060
It's a good pass.

00:35:22.060 --> 00:35:23.840
The starting position for starts with.

00:35:23.840 --> 00:35:25.040
That's cool.

00:35:25.040 --> 00:35:26.000
Yeah.

00:35:26.000 --> 00:35:27.100
There's a lot going on here.

00:35:27.100 --> 00:35:28.500
Almost starts with.

00:35:28.500 --> 00:35:29.700
all yeah.

00:35:29.700 --> 00:35:30.740
Nearly starts with.

00:35:30.740 --> 00:35:31.000
Yeah.

00:35:31.000 --> 00:35:33.780
What's the, what's the, what's the, what's the right way.

00:35:33.780 --> 00:35:40.680
So I want to close this out with a, a joke as always, but there's the joke we talked about

00:35:40.680 --> 00:35:48.640
a while ago, where, Sebastian Ramirez creator of FastAPI saw an ad hiring a FastAPI developer.

00:35:48.640 --> 00:35:51.780
And he said, Oh, it looks like I can't apply for this job.

00:35:51.880 --> 00:35:56.300
It requires four years of experience with FastAPI, but I can't possibly have that.

00:35:56.300 --> 00:35:57.760
Cause I only created it two years ago.

00:35:57.760 --> 00:35:58.000
Right.

00:35:58.000 --> 00:35:58.260
Yeah.

00:35:58.260 --> 00:36:00.660
So it's a little bit in that vein.

00:36:00.660 --> 00:36:06.620
So here we have, somebody, tweeting and says, here's a conversation with the recruiter

00:36:06.620 --> 00:36:07.060
and them.

00:36:07.060 --> 00:36:10.120
It says, recruiter, do you have a CS background?

00:36:10.120 --> 00:36:11.620
Yes, absolutely.

00:36:11.620 --> 00:36:13.060
My CS background.

00:36:13.060 --> 00:36:17.620
And this is the screenshot from the game counter strike, which is often referred to as just CS.

00:36:17.620 --> 00:36:19.140
Yeah, of course I got a CS background.

00:36:19.140 --> 00:36:19.780
Are you kidding me?

00:36:19.780 --> 00:36:23.740
That's pretty good.

00:36:23.740 --> 00:36:24.240
I love it.

00:36:24.240 --> 00:36:24.840
Yeah.

00:36:24.840 --> 00:36:26.260
yeah, that's a good one.

00:36:26.260 --> 00:36:28.060
Well, just a question though.

00:36:28.060 --> 00:36:34.680
If you, if you did FastAPI instead of eight hours a day, if you did it 16 hours a day for

00:36:34.680 --> 00:36:36.640
two years, would that constitute?

00:36:36.900 --> 00:36:41.200
You know, that probably, that probably is about the same amount of experience.

00:36:41.200 --> 00:36:41.420
Yeah.

00:36:41.420 --> 00:36:44.340
So what a slacker that Sebastian is.

00:36:44.340 --> 00:36:46.500
Does he have to eat or something?

00:36:46.500 --> 00:36:47.340
Does he have family?

00:36:47.340 --> 00:36:48.020
What's going on?

00:36:48.020 --> 00:36:48.960
Come on.

00:36:48.960 --> 00:36:53.440
Well, always fun with, hanging out with you and talking Python.

00:36:53.440 --> 00:36:54.540
So you bet.

00:36:54.540 --> 00:37:00.820
And thanks to everybody on the, that listens to it on, on their podcast player or watches

00:37:00.820 --> 00:37:01.440
us on YouTube.

00:37:01.440 --> 00:37:02.920
Yeah, absolutely.

