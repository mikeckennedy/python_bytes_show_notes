00:00:00 I am pulling off a very, very cool trick I just want to point out before we get started, okay, on the talk Python channel, I'm doing a podcast with Anthony Shaw and Shane from Microsoft, about Azure and Python and some CLI stuff they built and fast API at the exact same time. I'm doing this one here. They're both streaming live.

00:00:20 I don't know how that how that's happening. The other one was

00:00:23 recorded two months ago, and we couldn't release it because some of the things weren't finished yet. So I just I hit go on that the real one if you're if you're bouncing around, the real one is here. Okay. So join us here. Anyway, with that you're ready to start a podcast? Yeah, definitely. Hello, and welcome to python bytes, where we deliver Python news and headlines directly to your earbuds. This is episode 294. Recorded July 12 2022. I'm Michael Kennedy.

00:00:48 And I am Brian knockin. That's just us this weekend, or this is just us.

00:00:52 Yeah, yeah, it's I don't know D. Now the audience asked, Is this a daily podcast show now? I'm a little bit torn about I feel like we almost could do a daily show. But then I think what it might take to do a daily show, knowing how much work a weekly show is. And I know it's not a date. It's not a daily puck.

00:01:10 I know what would be fun to do sometime. Just do like a full week or something just

00:01:14 right. Exactly. Just super this. There's so much news we're seeing every day for the week,

00:01:20 just like the same topics like six days.

00:01:24 Yeah. Exactly. All right. Am I first this week? You are? Yes. Right on? Well, let me tell you about something special specialist. Okay. Just last week, I believe it was I interviewed Alex waygood, who did the write up for the Python language Summit. And as part of the topics we were discovering, you know, the Python language summit and Python this year is focusing a lot on performance, and what's called the Shannon plan. So this is Mark Shannon's plan to make Python five times faster over five releases. It's got a ton of support at Microsoft, Guido van Rossum is they're working on it, but they've hired like five or six other people who are full time working on making Python faster now. So awesome, awesome. Thank you for that. However, one of the things that made Python 311 fast is some of the early work they did. And it's, it comes down to PEP 5659. I specialize in adaptive interpreter. So let me tell you about the this feature this performance improvement first, and then we'll see what specialist is about because it's about understanding of visualizing behavior. Okay. So one of the things that is a problem with Python, because it's dynamic, and its types can change. And what can be passed could vary. I mean, you could have type hints, but you can violate the type hints all day long, and it's fine. So what the interpreter has to do is say, Well, we're going to do all of our operations, Super General. So if I have a function, and it's called Add, and it takes x and y and returns x plus y, seems easy. But is that string addition? Is that numerical addition, is that some custom operator overloading with a Dunder add, or whatever it is, in some type, it fails in one way, you kind of got to reverse it. Like there's all this unknown, right? What if you knew what if you knew those were integers and not classes or not strings, you could run different code, you wouldn't have to first figure out what they are. Are they compatible? Do you do the ad in the low level C Python internals? Or do you go to like some Python class and do it right, you could be much more focused. Yeah. Additionally, if it was adding for list, you could say, well, if I know their list, what we just do is go List dot extend, and we give it the other list, right? We don't hunt around and figure out all this other stuff, too. That's the general idea of the specialising interpreter is it goes through and it says, Look, we don't know for sure what could be passed here. But if it looks like over and over, we're running the same code, and it's always the same types. Is there a way we could specialize those types? Right, is there a way that we could put specific code for adding numbers or specific code for combining lists? And this is called adaptive and speculative specialization? Okay. Okay. And my favorite part of it when it's performed, it's called the quickening. quickening is the process of replacing slow instructions with faster variants. So kind of like I said, it has some advantages over immutable bytecode. It can be changed at runtime, like you see, we're always adding integers, it can use super instructions that span lines or take multiple operands and it does not need to handle tracing as it can fall back to the original bytecode for that, okay. Okay. So there's a whole bunch of stuff going on here. Like the example they give is, you might want to specialize load adder. So load adder is a way to say, give me the value that this thing contains And but what is the thing, one of the things you might do is you might realize it's an instance class. And then you would call load attr instance value. Okay, you might realize it's a module. And you might call load adder module or slot or so on, right. But if you knew you don't have to go through first the abstract step and then figure out which of these it is you just do the thing that it is. Okay. So that's the idea of this PEP. This is one of the things that's making Python 311 faster. Awesome. So to the main topic,

00:05:30 okay, I'll just just as a note, I'm saying, okay, as if I understand what you just said, but most of us,

00:05:36 so it's alright, I think, well, let's, let's look at pictures. Okay. All right. So this thing by Brant Bucha. It's called specialist and it's about visualizing this specializing adaptive interpreter. Okay, good. Okay. So it's a specialist uses fine grained location information to create visual representations of exactly where and how see Python, three elevens, new specializing adaptive interpreter optimizes your code. And it's not just interesting, it has actionable information. Okay. So for example, see here, and if you gotta pull up this website, if you're just listening, if you see in that website, you'll see some colors, you'll see green, less green, yellow, orange, all the way to red. So there's two aspects are sort of a darkness as well as a color. So the most, like where Python can take advantage of this feature, you see green, where it can't you see red, and imagine the spectrum it goes like, green, yellow, orange, red, so it's not on or off. It's how much could it specialize. Okay. Okay. So what you see here, for example, is it's able to take some numbers, and index, an integer and a string, and then use the fact that it knows what those are to make certain things like appending, an output and doing some character operations on it. Yeah, right, it was able to replace that with a different runtime behavior, because of this quickly. Alright, so let's skip down here, give you the bit of the background. So it says let's look at this example. We have F to C, which converts Fahrenheit to Celsius. And what it does is okay, we're going to take an F, and it has type int to say, float, float. Okay, so, but those don't matter. So it says we take an F and subtract 32 from it. And then we're going to do simple math, we're going to take that result that range that size of temperature there based on zero and then multiply it by five divided by nine, we all learn this in chemistry class or somewhere or we talked about diverting different measurement. Yeah, of course. Yeah. Right. So these are straightforward. But there's actually problems in here that make it slower, and prohibit Python from quickening it as much as it can be quickened. Okay? So if we take this code, it just runs F to C, and C to F. And that gives us some test values and says, Just do it and tell us what happened. We can run specialist on it, and it says, Okay, this x here, the green areas indicate regions of code that were successfully specialized, where red areas are unsuccessful, like it tried and it failed. So it says one of the problems is start out the X equals F minus 32. It says, well, we can Quicken operations on numerical types that are the same. But for now, there's not a float int and float variant of this. It's got to be float, float. All right, it says, right, you, you could have gotten a faster operation there. But because the types didn't match, you won't. But then what it did get out as an X. And that was great. An X, which is a float, and it's going to do some stuff. And it could sort of make it better. But it said, look, here's some multiplication, again, by an integer and a float. So that's not quickened. And this division division is apparently never quickened. The what can we do? Well, with that information, is it well, what's the problem was subtracting 32? Well, it wasn't a float. Well, what if I said 32.00? Yes. All right, that gets replaced by faster code.

00:09:03 Oh, nice right now.

00:09:04 So that's pretty nice. And if you want to return, it was adding like x plus 32 For the other direction. And now it's 32.0. That's faster. Okay. Well, what else? What if we, now you can see, when we did that part of the conversion, X times five divided by nine, if we put a 5.0, that gets faster still, but the divide is never quickened, okay? Well, what if we put the divide in parentheses, doesn't really matter if it's X times five divided by nine, or X times five divided by nine, right? It's these are mathematically equivalent, but they're not equivalent to Python, because that that operation results in it leverages constant folding, right? Five divided by nine is pre computed in Python to be a float. Right at parse time, right? That's just how it works with constants. If it says it can do math with constants ahead of time it doesn't do that becomes a float and then float times float is now quickened, right? Isn't this cool? The way you can apply this and actually make your code faster, not just go oh, it's interest. See, that must be quick. And if there are, but it Yeah,

00:10:02 it is really pretty cool. And I'd really like to see this incorporated into an editor or something to say, your code will be faster if you just add a point zero here or something like that.

00:10:13 And it's gonna become a float anyway, it doesn't matter, it just, why would you write 32.0? When you just meant 32? seems more precise to say 32?

00:10:22 Cuz I'm used to doing that to thinking if it's okay, me personally, I, if I know it's going to be a float math, I usually do point zero. But maybe, maybe that's not a normal thing,

00:10:32 if you're such a C programmer. So all right, well, I think this is really cool. This is pretty fabulous. And, you know, I don't know if I have any code that does math at that final grade level that I really care. But maybe, you know, if you're in charge of a library, where you've got a tight loop, or you do a lot of math, science stuff where it matters, this can be really useful. And what's cool is it's not like and switch to rust, or switch to C or switch to scythe on and it'll take effect like no, this this is like straight Python code. This is just how do I take most advantage of what is already happening for performance boosts in 311, that we haven't had before. I think

00:11:13 and I think it's going to be just one more workflow step. So you've got your profile or your code, your whole thing is a little bit slower than you'd like it to be. You throw a profiler on it, you see the bottleneck areas that you could improve, and you think, should I like rewrite some of this in rust? Or C? or, you know, what should I do? Well, first off, let's try doing this like, throw through, throw this at it. And, and, and have the optimizer from 311 help you out. And and yeah, so I think that's, I can definitely see that this is going to be part of people's workflow. But yeah,

00:11:51 agree that you want to. Yes, exactly. Because while it's fun to do this, yeah, yeah, only focus where it's gonna matter. Don't don't optimize bunch of stuff that doesn't. So Brian, on the audience says, different brain, is there a plan to do lossless type conversion? Or maybe flake eight can make this kind of suggestion? Yeah, exactly. I'm not really sure. If you don't want to write the code where you get different outputs, probably. Right. But everything that was happening in here, you were you ended up with the same outcome. Anyway, it's just like, well, do I do the division first or the multiplication? Or do I start with an ant that results after some addition subtraction with a float? Or is I just make them all floats? Right? I feel like it's, in most cases, it shouldn't be changing the outcome. So okay. Yeah, yep. Cool. Anyway, that's, that's what I got. For the first one. How about you?

00:12:44 Well, we'll kind of sticking with a 311 theme so far. Well, we can use Tom well now. But the in 311 we are going to have a Tom will that be part of part of Python 311 with PEP 680 And we covered that in episode 273. But I one of the things we didn't mention was that was the the the tamo lib is is and I think we did mention it is based on Tom Lee but Tom Lee you can use right now. So a lot of projects are switching to use Tom Lee as a as their Tom, Tom will parser to read, read, like pipe project atomic or read their own config file. And, um, and so I just wanted to highlight it, it's a Tom Lee is the little tomo parser. So cute little thing, and the project is cute. But, but I was reminded of it because real the real Python people put out actually looks like gear, Arne. Sorry, I'm not going to try to pronounce that name. Real Python, wrote an article called Python and tamo new, new best friends. And I really love it's it's a very comprehensive article. But I really love at least the first three parts of it. Using Tom was a config format, getting to know key value pairs, and load Tama with Python, because this is kind of what you're gonna do with it, you're gonna write config files for something. And I just kind of it's, this is a great introduction of Tommo for Python. And that's kind of what we care about. Right? So it goes through, like just getting getting used to what Tama looks like what a config file looks like talking about how all the keys even if you it's like key value stuff. And even if you put a number there or something, it's going to be a string. All the keys get converted to strings, even if they don't look like and they are there. They're UTF eight, so you can use Unicode in there as well. Which is kind of neat.

00:14:51 Put your emojis in there. Yeah,

00:14:53 well, can you is are emojis UTF eight,

00:14:57 I think mostly. Many of them are

00:15:00 Interesting. That'd be fun to put put emojis in your.

00:15:04 I don't know what Marta, we were in a cow mode or lizard mode. Lizard. Yeah. Okay, well, if you run into Alicia

00:15:12 Okay, I gotta try that to see. Should have done that for

00:15:16 my gosh, I think almost it's both horrible and amazing. Imagine writing like config files to like, put it in, put it in lizard mode, do it?

00:15:23 Yeah. What are the things that I didn't before reading this article, one of the things I didn't know you could do in Tommo, because I just sort of cursory I use it with pipe project at Tom and that's about it. But you can do. So talks about normal how to read stuff, but one of the things is Jose gonna talk about arrays. And you can do arrays of things which are neat, and tables and arrays of tables, which is like, so you have arrays of tables where these bracket bracket things. And, and then you can do dot stuff. So if you have like, was a user and user dot player, these will show up as as like, you know, sub dictionary key things. And so one of the things that I and I played with it this morning, and it really should have something to show, but the thing I like to do is to just read it, just like this article talks about reading it, just read the Tamil file into Python and print it. And then you can, it'll print out as a dictionary, and then you can create whatever format you want for your tomo file, and then you could just see what it's gonna look like and then you know how to access it. Because it's one of the best ways to do that.

00:16:41 That's awesome. Yeah, what an interesting format. That's pretty, it's pretty in depth. And a blast from last week passed. Ashley? Hey, Ashley says UTF eight can encode any Unicode character emoji your heart emoji?

00:16:54 I heard out? Oh, yeah, you could do like, you know, is it in hard mode and hard equals true hurt equals false for that? Oh, for optimizer optimizer, you could do a flame emoji equals true

00:17:07 Bakley. So I love it. I think look, we have not leveraged the configuration as emoji sufficiently. Oh,

00:17:13 yeah, I think I think pi test should rewrite all of its configs as emoji items. So let's

00:17:19 do a PR I'm sure we'll take it bigger. All right. Yeah. All right. Let me tell you about our sponsor this week before we move on. So this week is brought to you by Microsoft founders hub. In fact, they are supporting a whole bunch of upcoming episodes. So thank you a whole bunch to Microsoft for startups here. starting businesses hard by some estimates, over 90% of startups go out of business within their first year. With that in mind, Microsoft for startups set out to understand what startups need to be successful. And to create a digital platform to help overcome those challenges. Microsoft are startups founders hub, their hub provides all founders at any stage with a bunch of free resources to help solve challenges. And you get technology benefits, but also really importantly, access to experts guidance and skilled resources, mentorship and networking connections and a bunch more. So unlike a bunch of other similar projects in the industry, Microsoft for startup founders hub does not require startups to be investor backed or third party validated to participate, it's free to apply. And if you apply, get in, then it's going to open to all so what do you get if you join or apply and then get accepted to you can speed up your development with access to GitHub, Microsoft Cloud with the ability to unlock credits over time as in, it gets over $100,000 worth of credits over time over the first year if you meet a bunch of milestones, which is fantastic. But help your startup innovate vendor hubs is partnering with companies like open AI, a global leader in AI research and development to provide benefits and discounts to neat Yeah, through Microsoft startup founders hub becoming a founder is no longer about who you know, you'll have access to the mentorship network, giving up access to a pool of hundreds of mentors across a range of disciplines. Areas like idea validation, fundraising, management, coaching, sales, marketing, as well as specific technical technical stress points. To me that that's actually the the biggest value is the networking. Mentor side. So book A, you'll be able to book a one on one meeting with these mentors, many of whom are founders themselves. Make your idea a reality today with the critical support you'll get from Microsoft for startups to under sub join the program at Python bytes.fm/founders. Hub link will be in your players show notes. Nice. Yeah. Cool. Indeed. All right. I guess I'm up next with this order we got and oh my goodness, Samuel Colvin take a bow. Because he put out a plan for what's happening with Pydantic version two. But the reason I say take a bow is this is one detailed plan that is really, really thought through, bought out backed up with a bunch of GitHub discussions and so on. Wow. So the idea is Pydantic started out as an interesting idea and surprise, surprise a bunch of people go glommed on to it, probably more than it was originally envisioned to be so. So for example, SQL model from Sebastian Ramirez is like Pydantic models are now our ORM to the database with all the interesting stuff that RMS have. And Roman right said, Guess what we could do that for MongoDB as well. Same with the Pydantic thing We recently spoke about. And then Sebastian Ramirez is like, also, like, hey, fast API, this can be both our data exchange, as well as our documentation. Cersei was like, Oh, my goodness, what's going on here? So there's a bunch of stuff on the insides, that could be better, let's say are your maybe time to rethink this? So in this plan, it talks about what they'll add what the remove what will change some of the ideas for how long it will take, and so on. Interesting. Yeah, here's, here's a pretty significant thing. I'm currently taking a kind of sabbatical after leaving my last job to work on this, which goes until October. So that's a big commitment to I'm gonna help make Pydantic better. So it sounds familiar. It sounds a bit like rich, and textural, and those types of things as well. But this is a big, big commitment from Samuel. And he's really doing a ton of work, says people seem to care about my project. It's downloaded 26 million times a month. Wow, insane. Yeah, that's awesome.

00:21:20 That's kind of incredible. It is.

00:21:22 And so it says, here's the basic roadmap, implement a few features in what's now called the Pydantic. Core. We just had Ashley, who, as we saw is out in the audience, Hey, Ashley, who give a bit of a shout out to this feature. And also, I do want to also credit a couple other people's because Douglas Nichols and John Fagan, also let me know that this was big news coming. So thank you all for for that the Pydantic core is being rewritten in Rust, which doesn't mean you have to know or do anything, it just means you have to pip install something, you get a binary compiled thing that runs a lot faster. Okay, so more on that in a second. First of all, working to get 110 out and basically merge every open PR that makes sense and close every PR that doesn't make sense. And then profusely apologize to why your PR that you spent a long time making was closed without merging some other bookkeeping things, start tearing the Pydantic code apart and see how many existing tests can still be made to pass and then release eventually Pydantic. The goal is to have this done by October, probably by the end of year, for sure. Couple of things were painted into, there are a bunch of breaking changes in here, a lot of things are being cleaned up, reorganize, renamed, some removed, like from ORM, people might be using that with SQL alchemy that's been removed, for example, and so on. So there's, if you depend heavily on Pydantic, especially if you build a project like beanie that depends heavily on Pydantic, you are going to need to look at this because some of the stuff won't work anymore. But let's highlight a couple things here performance. This one is really important, because this is the data exchange level at professed API. This is the data base transformation level, when I do a query from the database, what comes back comes back in some raw form and then just turned into a Pydantic model. And those are computationally expensive things that happen often. And in general Pydantic. Version two is about 17 times 1,700% Faster than v1 when validate models, in a standard scenario says between four to 50 times faster than Pydantic. One. Wow, that's cool, right? Yeah, that alone should make your ears perk up and go, excuse me, my REM just gotten 17 times faster. Wait a minute, I'm liking this. I know that this is not the only thing that happens at Arlin level. But the ones that the ones I called out that depend heavily on it like that's in the transformation path. So this is important.

00:23:42 Yeah, this is actually I'm super impressed. I have not I normally don't even see this sort of advanced planning in commercial projects.

00:23:51 Yeah. Oh, yeah. You could do a whole business startup that doesn't have the amount of thought that went into like, what's happening. The next version of Pydantic is regrettable. Yeah. It's incredible. I was serious. When I said take a bow. It really lays out open to discussion about certain things, and so on. So like, another one is strict mode. I think I even saw a comment in the chat about it. So one of the things I actually like about Pydantic, but under certain circumstances, I can see why you would not want it is if you have something, say it's an integer field. And then you pass 123 The number. Great. But if you also pass, quote, 123 Pydantic will magically parse that for you like this happens all the time on the internet, like a query string has a number, but query strings are always strings. There's no way to have anything but strings. So you got to convert them, right. So this automatically does that. But if you don't want that to happen, you say you gave me a string, it's invalid. You can turn on strict mode, which is off by default, I believe. So a bunch of plan

00:24:49 God. So strict mode, does the conversion or strict.

00:24:53 Won't do the conversion. It says, You said isn't it you gave me a string? Nope. Rather than could it be an integer Yeah, let's try that first. Yeah, you know, maybe one of the things you do is in the ORM level one of those things, you might put it in strict mode. So it doesn't do as much work trying to convert stuff. I don't know if it actually would matter. But normalize is a bunch of conversions it has built in JSON support and different things. Another big thing is this Pydantic core will be able to be used outside of Pydantic classes now. So you can do a significant performance improve to improve stuff like adding validation to data classes, or validating arguments and query strings, or a type Dec or a function argument or whatever. Yeah, yeah. Let's see. Next up. And let's see, this one strict mode, we talked about strict mode. Another one is required versus nullable, I was a little bit of ambiguity of, you know, if you said something to string, that means it's required, and it can't be done. If you say it's a string, type none, or it's an optional string or something like that, then the basically the behaviors were a little bit different. So originally, I think this is when typing was pretty new, said Pydantic. Previously at a confused idea of required versus nullable is mostly resulted from Sam's misgivings about marking a field is optional, but requiring a value to be provided to it, but allowing it to be set to note or something, something along those lines, like, anyway, there's minor changes around that. Let's see, final one that I want to cover is namespace stuff. And this is like, a whole bunch of things are now getting renamed. So for example, if you override, if you implemented or overrode validate JSON, it's now model underscore, validate JSON, if you had is instance it's now model is essence. Okay, there's a bunch of these changes all over the place. Yeah, that looks like they're gonna cause breaking changes, they're easy to fix, just change the name, but you know, it's not nothing. Also parse file. So love his handler here. Parse file, this was a mistake, it should have never been in Pydantic. We're removing it occurs raw, partial, partially replaced by this other thing, anything else he did was a mistake from RM, this has been moved somewhere else, schema and so on. So you just like there's a lot of stuff that people were using here. So just have a look, try it out. Don't just go Oh, then a version two is out is this gonna work like this is going to have some significant changes. But and

00:27:22 another reason why it's really awesome that he goes through so much detail is because there's gonna be stuff that breaks. So it's a breaking interface change. And so yeah, it's, it's cool that it's this detailed, and a couple of things to notice. Let's see somebody else in the chat mentioned, Richard mentioned. And he has emojis in the headers. Yeah, there's emojis in the headers. And I gotta say, like, the, the diet, the navigation and the table of contents. Very cool it like, it goes to like, light gray for areas you've already seen. And then

00:27:59 that's interesting. That's a cool thing. So yeah, it's quite cool. I think it went on and on. But two real quick things. One, there'll be no pure pirate Python implementation of the core, it's always rust, but they list out the platforms where it'll be compiled to including WebAssembly. Oh, nice. They previously had some scythe on and what was supposed to be pure pythons. Pydantic. And so now, a kind of bonus is the Pydantic model, the Pydantic package becomes a pure Python package. Whereas previously, it wasn't. So they've taken like all of that behavior and put it into this core thing that ships as a rust binary. And now, instead of doing some Python middle ground, it's pure Python again. So that's interesting refactoring, I think, yeah, yeah. And finally, documentation. When you get a validation error, it gives you a link to the documentation in the JSON error message.

00:28:52 That's pretty cool. That's nice.

00:28:55 All right. Yeah. Anyway, that's quite a plan isn't a brain. Yeah. Quite a plan. All right. Well, I'm excited for it.

00:29:02 Okay. Well, next topic is a little more lighthearted. It's about fish. Pike, to be specific. Now, it's about PDFs. So there's, it's just a cool project I saw, I noticed. Pike PDF. It's a Python library for reading and writing PDF files. What's the big deal we've had these before. But this is it's based on CutePDF, which is a C++ based library. And it's, it's presently keep continued being maintained. So it's kind of pretty fast. Well, actually, I'm assuming it's fast if is C++ in the background, but the it's it's also pretty just nice and elegant to do things. And the documentation has this nice fish, which is good. I was like, Cool diagram Cool, cool logos Uh, but some of the neat things that you can do with it. So it's recommending that you not use it if you're just writing PDF files, so that there's, there's, there's other things that you can use, what was it like report lab to write PDFs. But if you're having to read or modify PDFs, then this is where it shines. You can do things like copy pages from one PDF to another, split and merge PDFs, extract content out of PDFs, like if if, like, if you're using it for data stuff, you get a report in PDF, and you're trying to pull it pull the information out, you can use you can use it for that, or images, you can pull all the images out of a PDF file, or this is kind of cool. You can replace images in a PDF file and generate a new one without changing anything else about the file. It's kind of neat. So just kind of a neat if people are working with reading or modifying PDF files, maybe check this one out. Yeah,

00:30:57 this looks great. The fact that it's in C++, I'm guessing it's probably standalone. I remember I've done some PDF things before. And I felt like I had to install some OS level thing that it shelled out to. So this is cool.

00:31:09 Yeah. And the some nice on the readme, it has a comparison of some of the different PDF doc or PDF libraries that you could use. And some of the reasons why you might want this one like it supports more versions, I didn't realize that, like, one of these libraries I've heard of before PDF RW doesn't support the newer versions. So bummer. And then also password protected files. It supports that except for but not public key ones, but just normal passwords.

00:31:42 Straight passwords. Yeah, yeah, that's great. So it's kind of so like the measure of actively maintained a commit activity per year over the years. Oh, right. That's kind of interesting. Yeah. It's an interesting metric. It seems good. I haven't really thought about it lately. But yeah. Nice. All right. Yeah. This is a great one.

00:32:01 Well, so that's it. For our main it is items.

00:32:05 Yeah. What else you got? any extras?

00:32:07 Well, last week, last week, we talked about the the critical packages, curriculum, or at some recent. Yeah, last week, we talked about

00:32:19 critical packages yesterday or last week, depending on how you consume this.

00:32:23 Yeah. So we I was surprised to find out that pi test check with the plugin I wrote was part was one of those I'm like, really, because it's like the top 1%. So I, if anybody's curious, I wanted to just highlight that a little bit. So pi test check is a plugin that allows multiple failures per test. And in one of the best ways I it's a secondary way that one of the contributors added is you can use it as a context manager, you can say like with check, and then do an assert and then get a multiple of those within a

00:32:56 I like the one liner. Yeah, that's yeah, nice.

00:32:58 And this is totally like Black will totally reformat this for you ran it through black, but it's nice. You'd have to block it out. Anyway. I was like, how could it be? What? Well, I'm curious what, what on the list it was. So there's, there's a place called what? You go BK has a top pipe bi packages list. And it's updated. I think it's just updated once a month or something. But you can do the top five. You can do the top 5000. Yes, the top 5000 or 1000 or 100. And so I'm curious was curious about what on the list were in the list. I was. I'm number 1677. So kind of far down the list. But

00:33:43 hey, just talk. It's still it's still in the top third of the top 1%. That's pretty awesome.

00:33:49 The pie test is number 72. That was pretty neat. And Pydantic, which we covered was was I just checked 117. But there are there are 57 pi test plugins that show up in the top 3500. So that's pretty well. Pretty neat. Anyway, that's all I got for extras.

00:34:08 All right. Well, I have zero extras. So minor finishes. Well, how about a joke? Yeah. Great. All right. I told you, we're coming back to it. So this one comes from meta meta coder, code girl at meta, and eta.mk. And let me just pull this one up here. Right. So this one is there's this colleague here. Can I make this there we go, Miko burger. There's the two women who are developers net to end her unnamed brand who always has gotten in trouble with the elevator last time basically. And there's this sort of weird manager looking guy that comes in says I tested your chatbot but some of his replies are really messed up. Well, that's that's what testing is all about. I'll go through the logs later says one of the girls. No, no, no, no, no, no, no, no, no need to check out the faces. There's like excuse me, I might even Sure I want to open the logs now.

00:35:02 Oh yeah, don't look at that.

00:35:04 That's what testing is for.

00:35:07 Oh, good yeah, she's she's got some good ones in her list there. So, love it. Yeah,

00:35:15 I like the art too. Nice or added to this to.

00:35:19 Also nice was our podcast. Thanks for being here.

00:35:22 Thank you. Yeah, you bet. See you next week. See you next time.

