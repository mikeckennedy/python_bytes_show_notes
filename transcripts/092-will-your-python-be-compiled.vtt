WEBVTT

00:00:00.001 --> 00:00:05.240
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:05.240 --> 00:00:11.220
This is episode 92, recorded August 23rd, 2018. I'm Michael Kennedy.

00:00:11.220 --> 00:00:12.100
And I'm Brian Okken.

00:00:12.100 --> 00:00:13.000
Hey, Brian. How are you doing?

00:00:13.000 --> 00:00:13.840
I'm doing great.

00:00:13.840 --> 00:00:18.140
Yeah, same here. I'm excited to be back together. And I can't wait to talk about some of these things.

00:00:18.140 --> 00:00:23.900
We have some like amazing drop the mic sort of stuff coming up. So pretty excited to get into that.

00:00:23.900 --> 00:00:28.960
And also pretty excited that DigitalOcean is sponsoring this episode. So thank you, DigitalOcean.

00:00:28.960 --> 00:00:34.480
Check them out at pythonbytes.fm/digitalocean. Get $100 credit for new users.

00:00:34.480 --> 00:00:37.560
Right now, have we covered the fact that Python is popular?

00:00:37.560 --> 00:00:40.020
Yeah, but I wanted to cover it again.

00:00:40.020 --> 00:00:40.700
Why not?

00:00:40.700 --> 00:00:52.120
So Python is pretty popular. And for the second year in a row, it came out as the number one popular programming language in the IEEE survey.

00:00:52.520 --> 00:01:01.500
So there's a every year IEEE puts out a popular programming survey and that it's at the top isn't really news.

00:01:01.720 --> 00:01:09.380
What's really kind of cool about it, though, and we'll have a link to the results. It's an interactive results thing. I think we covered it last year.

00:01:09.540 --> 00:01:16.480
But this time, Python is number one, even in embedded. And that's the thing that stands out this year.

00:01:16.480 --> 00:01:25.480
Yeah. And it's worth pointing out that this survey is for electrical engineers. It's not like the same as, say, the Stack Overflow survey, which is maybe more developer focused.

00:01:25.480 --> 00:01:31.380
So it's like you saw another area where Python is sort of taking over, which is awesome. Embedded, like you say.

00:01:31.380 --> 00:01:37.180
The article that we're going to link to actually talks about whether or not this is real.

00:01:37.180 --> 00:01:46.300
And some people are doubting that Python really is that popular in embedded because, I mean, there's a lot of day-to-day job are embedded.

00:01:46.300 --> 00:01:48.360
The embedded work I do is in C++.

00:01:48.880 --> 00:01:54.940
There's a big range of what it means to be embedded. So they don't really define that. You have to kind of define that yourself.

00:01:54.940 --> 00:02:01.060
I define it mostly as you're developing software on a platform that's not the target platform.

00:02:01.060 --> 00:02:04.360
And the target platform doesn't really look like a computer.

00:02:04.360 --> 00:02:09.200
Like a Raspberry Pi or maybe like something embedded in your car or something like that?

00:02:09.200 --> 00:02:12.460
Yeah, definitely. But even it's a broad definition.

00:02:12.460 --> 00:02:18.540
So the embedded software I do actually runs on a Windows machine, but it doesn't look like a Windows machine.

00:02:18.620 --> 00:02:21.140
It looks like a, it's a testing equipment.

00:02:21.140 --> 00:02:23.860
It looks like a stereo component with dials and stuff.

00:02:23.860 --> 00:02:25.960
We don't run Python. We run C++.

00:02:25.960 --> 00:02:31.500
However, like you said, like Raspberry Pi, I think there's been a big push lately.

00:02:31.500 --> 00:02:33.560
I think that's where this is coming from.

00:02:33.560 --> 00:02:47.680
There's been a big push lately of trying to get people involved in more circuits and more real interactive programming with electronics through the use of MicroPython and CircuitPython on like Raspberry Pis and Arduinos.

00:02:48.360 --> 00:02:50.320
MicroBits and all that sort of stuff.

00:02:50.320 --> 00:02:55.580
And including the Mew editor that really tries to teach people right out of the get-go.

00:02:55.580 --> 00:03:00.640
So there is some doubt of whether or not really Python's the top for embedded, but I don't doubt it at all.

00:03:00.640 --> 00:03:02.200
I think it's going to stay.

00:03:02.200 --> 00:03:02.940
Yeah, I think it's cool.

00:03:02.940 --> 00:03:17.980
I mean, you could have the debate of, well, it's on professional shipping embedded devices that are for sale versus embedded in general, which like you say, could include $5 Adafruit type things that people play with or they're using in school, but it's not for sale per se.

00:03:18.120 --> 00:03:18.300
Right.

00:03:18.300 --> 00:03:25.900
There's a lot of people taking those Adafruit things and turning them into kits for people or products for people to like wear.

00:03:25.900 --> 00:03:33.460
And then the people that are learning on that are going to go into, it might go into other embedded jobs.

00:03:33.460 --> 00:03:43.560
And I think since Python is faster to develop in, there's a big incentive, I think, for people to use a higher level language and embedded if they can, even in a production level.

00:03:43.740 --> 00:03:45.500
Yeah, and if they are, it's got to be Python, right?

00:03:45.500 --> 00:03:46.380
Like what else would it be?

00:03:46.380 --> 00:03:46.740
Right.

00:03:46.740 --> 00:03:47.080
Yeah.

00:03:47.080 --> 00:03:47.340
Yeah.

00:03:47.340 --> 00:03:49.960
Maybe JavaScript, but that's a little shaky.

00:03:49.960 --> 00:03:50.940
Very interesting.

00:03:50.940 --> 00:03:51.320
All right.

00:03:51.320 --> 00:03:53.420
So are you ready for something incredible?

00:03:53.420 --> 00:03:54.060
Yeah.

00:03:54.060 --> 00:03:56.320
Is this drop the mic thing you're talking about?

00:03:56.320 --> 00:03:56.760
Yeah.

00:03:56.760 --> 00:03:58.980
Unfortunately, it's the second one, so I'll have to pick it back up.

00:03:58.980 --> 00:04:03.060
But let me work my way into this the way that it develops.

00:04:03.060 --> 00:04:06.840
So we have the mailing list, Python dev, okay?

00:04:06.840 --> 00:04:08.680
And that's where a lot of the core developers talk.

00:04:08.680 --> 00:04:09.300
Okay.

00:04:09.300 --> 00:04:19.080
On this list, someone was talking about finding a better way to test the C APIs instead of writing some C tests, some Python tests, and those kinds of things, right?

00:04:19.080 --> 00:04:21.080
You can be sympathetic with this, I'm sure.

00:04:21.080 --> 00:04:25.320
And they were saying, look, we need to test the C code inside CPython.

00:04:25.320 --> 00:04:29.560
And one way to do this would maybe we could use something like Cython.

00:04:29.560 --> 00:04:37.700
And we talked previously about how Cython lets you pretty easily integrate with C and Python at the same time.

00:04:38.100 --> 00:04:40.620
So there was some debate saying, you know, it might be a good idea.

00:04:40.620 --> 00:04:41.780
It might not be a good idea.

00:04:41.780 --> 00:04:44.700
Like on one hand, Ccython is changing a lot.

00:04:44.700 --> 00:04:51.360
It's a pretty big dependency to take as part of the core development component of Python itself.

00:04:51.360 --> 00:04:52.480
Things like that.

00:04:52.480 --> 00:04:57.000
But then something pretty incredible came along here.

00:04:57.000 --> 00:04:59.480
And I don't know how far along this is or whatever.

00:04:59.480 --> 00:05:03.140
But this guy named Yuri steps in and drops a bit of a bombshell.

00:05:03.140 --> 00:05:06.140
And he says, hey, you guys, this Cython thing is kind of cool.

00:05:06.140 --> 00:05:07.460
And I don't know if you want to do it.

00:05:07.460 --> 00:05:12.380
But over at Dropbox, we're working on a new compiler for Python called mypyC.

00:05:12.380 --> 00:05:23.300
And it just says, well, this mypyC will compile type annotated Python to an optimized C code, which ultimately compiles to machine instructions.

00:05:23.300 --> 00:05:24.320
That's pretty cool.

00:05:24.320 --> 00:05:25.040
How about that?

00:05:25.140 --> 00:05:27.660
So it's like Cython, right?

00:05:27.660 --> 00:05:33.620
And we've seen that where Cython can make things like 20 or 50 times faster in certain circumstances because it's compiled.

00:05:33.620 --> 00:05:35.340
Really interesting stuff there.

00:05:35.340 --> 00:05:39.320
But the problem with Cython is it's a superset of Python.

00:05:39.320 --> 00:05:40.640
You have like the C def.

00:05:40.640 --> 00:05:46.080
Like you basically write in a separate language that if you squint, you're like, wait a minute, is that Python?

00:05:46.080 --> 00:05:46.780
No, no, no.

00:05:46.820 --> 00:05:49.440
There's a lot of weird other stuff going on around here.

00:05:49.440 --> 00:05:51.100
This is not Python, but it's Python-like.

00:05:51.100 --> 00:05:55.220
And it doesn't even use the same type annotations because it sort of predated that.

00:05:55.220 --> 00:05:59.980
So Cython is good, but it has like this, you got to write in Cython, not Python.

00:05:59.980 --> 00:06:05.380
This mypyC thing they're talking about, this is straight Python 3.6 code.

00:06:05.380 --> 00:06:10.360
It runs on CPython, but you can compile it to machine instructions like Cython.

00:06:10.500 --> 00:06:11.980
It's not all of Python.

00:06:11.980 --> 00:06:13.620
It's a subset, right?

00:06:13.620 --> 00:06:15.080
It's a subset, exactly.

00:06:15.080 --> 00:06:21.240
And so I think, you know, the main thing is you have to type annotate everything so it can actually compile it.

00:06:21.240 --> 00:06:24.460
Like that's more or less the difference with Cython is you type annotate everything.

00:06:24.460 --> 00:06:26.800
But it's a different type.

00:06:26.800 --> 00:06:27.940
It's using Cython types.

00:06:27.940 --> 00:06:28.400
Right.

00:06:28.400 --> 00:06:31.300
But this is using just normal type annotations.

00:06:31.300 --> 00:06:33.640
It's pretty incredible.

00:06:33.640 --> 00:06:35.340
It says, look, this is standard Python.

00:06:35.340 --> 00:06:36.600
It's a subset of Python.

00:06:36.880 --> 00:06:40.180
And you can easily integrate with C libraries because of CFFI.

00:06:40.180 --> 00:06:44.720
You can even run it on PyPy because it's a subset of Python.

00:06:44.720 --> 00:06:47.220
So it's pretty cool.

00:06:47.220 --> 00:06:52.920
And if Dropbox releases a full-on compiler for Python, that would shock the world, I think.

00:06:52.920 --> 00:06:55.040
Yeah, definitely.

00:06:55.040 --> 00:07:06.400
Like even with this, with a subset, to be able to develop it in Python and then do some little extra work to go to the, to make sure you're able to compile it within this, this would be great.

00:07:06.400 --> 00:07:07.860
And the extra work is not much.

00:07:07.860 --> 00:07:09.880
It's like put type annotations on it.

00:07:09.880 --> 00:07:17.340
So maybe you have like three or four functions that you call that are like really called frequently or really a major portion of your time is spent there.

00:07:17.340 --> 00:07:19.240
And if you wrote it in like C, it would be way faster.

00:07:19.240 --> 00:07:23.540
Well, if you just put type annotations on it, you know, you could probably hit it with this thing.

00:07:23.540 --> 00:07:28.620
So pretty interesting little thread that got picked up there.

00:07:28.620 --> 00:07:33.460
We'll probably have to watch this and make, update people if we see any more progress.

00:07:33.460 --> 00:07:38.540
Yeah, what I did not see is here's a link to the Git repo or here's the announcement or anything like that.

00:07:38.740 --> 00:07:40.920
So we'll have to see if anything comes from it.

00:07:40.920 --> 00:07:46.240
But I think it's really interesting, you know, that, that we've sort of gotten to this place.

00:07:46.240 --> 00:07:52.100
Because from my understanding is Gito is not a huge fan of compiling Python code.

00:07:52.100 --> 00:07:57.420
It didn't see a need for this, but he must be involved in this because it's from Dropbox.

00:07:57.520 --> 00:08:00.120
And the main work he's doing at Dropbox is on my Pi.

00:08:00.120 --> 00:08:01.840
And it's all about this.

00:08:01.840 --> 00:08:05.080
So I suspect he's involved somehow, but I have no confirmation of that.

00:08:05.080 --> 00:08:05.340
Yeah.

00:08:05.340 --> 00:08:06.460
Okay, cool.

00:08:06.460 --> 00:08:06.780
Boom.

00:08:06.780 --> 00:08:07.340
Mic drop.

00:08:07.340 --> 00:08:08.720
Okay, I'll piggyback on that.

00:08:08.720 --> 00:08:11.340
Let's, let's talk about Netflix.

00:08:11.340 --> 00:08:13.040
They are doing such cool stuff with Python.

00:08:13.040 --> 00:08:13.600
Yeah.

00:08:13.600 --> 00:08:14.700
So it's Python and more.

00:08:14.880 --> 00:08:21.760
There's a kind of a really cool article called Beyond Interactive Notebook Innovation at Netflix.

00:08:21.760 --> 00:08:39.100
And as we've all known, Jupyter Notebooks have, and using the Jupyter system has kind of revolutionized a lot of data analysis and machine learning and, and quite a bit of that interactive, interacting with data environment.

00:08:39.300 --> 00:08:41.560
And that's true at Netflix as well.

00:08:41.560 --> 00:08:46.360
And that's what kind of this article is talking about is a lot of the cool things that they've done.

00:08:46.360 --> 00:08:51.120
And it's, it's over the last few years, they've seen a larger and larger growth.

00:08:51.120 --> 00:08:55.580
And they've also said, basically, this is our supplied data chain.

00:08:55.580 --> 00:09:02.800
So there's, I never really thought about all the different types of people that interact with data, but they, they listed, they have a little like diagram.

00:09:02.800 --> 00:09:12.140
They listed like eight, nine or 10 different job roles that interact with data a little bit differently, but they're all interacting with it.

00:09:12.140 --> 00:09:18.260
Like, you know, data experts or data analysts or algorithm engineers or data scientists.

00:09:18.260 --> 00:09:24.840
There's all these different things that I'm not quite sure what they all do different, but they're all interacting with these huge data sets.

00:09:24.840 --> 00:09:39.820
And in their effort to use notebooks and Jupyter to kind of streamline and make things easier for people in the process, they've came up with some really cool extra projects that they've open sourced or developing in the open.

00:09:39.820 --> 00:09:42.360
And one of them is, I'm going to run through a few of them.

00:09:42.360 --> 00:09:43.880
One of them is called Interact.

00:09:43.880 --> 00:09:51.660
And it's an alternative user interface that has some cool things like inline cell toolbars and drag and drop cells.

00:09:51.660 --> 00:09:55.580
I didn't know that you couldn't do that in Jupyter, but that's neat.

00:09:55.580 --> 00:09:58.460
And a built-in data explorer.

00:09:58.460 --> 00:10:11.260
And then if you've got a Jupyter notebook all set up with some data, well, it wouldn't be cool if you could have some of your states parameterized so you can run the whole notebook with different parameters.

00:10:11.260 --> 00:10:16.320
This is almost like making a notebook like a function you can call and pass it inputs and get outputs.

00:10:16.320 --> 00:10:17.040
Exactly.

00:10:17.040 --> 00:10:19.780
And that's what Papermill is partly.

00:10:19.780 --> 00:10:22.620
So there's a project called Papermill that parameterizes notebooks.

00:10:22.620 --> 00:10:32.120
And then it also does things like if you've parameterized a bunch, you can analyze the different set of parameterized runs and do some analysis on the set.

00:10:32.120 --> 00:10:37.300
And then there's, yeah, it's kind of making a notebook kind of, like you said, like a function that you can call.

00:10:37.520 --> 00:10:48.940
And then if you want to, if you're using that and you want to share it with other people with the data and with the results, they've put together a thing called commuter that lets people share them together, share them with each other.

00:10:48.940 --> 00:10:50.440
And then also scheduling.

00:10:50.440 --> 00:11:00.380
So there's a separate article that's attached at the end about how if you've got this function with different parameters and stuff, maybe you want to, it's, you want to test different live data.

00:11:00.380 --> 00:11:03.140
So you want to schedule it regularly or different times.

00:11:03.140 --> 00:11:07.380
They've got a notebook scheduling system in place.

00:11:07.380 --> 00:11:14.080
So all of this is, it's not like a super easy thing to jump into, but they're trying to make it easier for people.

00:11:14.080 --> 00:11:17.140
And this is actually some pretty neat things that they've shared with everybody.

00:11:17.140 --> 00:11:18.180
This is incredible.

00:11:18.180 --> 00:11:30.140
And if you look at this big infrastructure diagram they have, it's like, it's just this entire architecture and cloud platform for running their style of executable notebooks.

00:11:30.500 --> 00:11:35.540
Using this new UI on containers you can configure and schedule.

00:11:35.540 --> 00:11:37.140
It's really crazy.

00:11:37.140 --> 00:11:43.400
And you can even come down and say, I'd like to run on some container with four CPUs and 30 gigs of RAM.

00:11:43.400 --> 00:11:44.640
Go.

00:11:44.640 --> 00:11:45.640
Right?

00:11:45.640 --> 00:11:46.360
That's crazy.

00:11:46.360 --> 00:11:48.600
It's kind of amazing.

00:11:48.820 --> 00:12:01.320
And I'm trying to start exploring a little bit more of what people are doing with Jupyter notebooks and other parts of the Jupyter system because it's, it is sort of opening up a lot of different data analysis into the open, which is neat.

00:12:01.320 --> 00:12:01.720
Yeah.

00:12:01.720 --> 00:12:02.960
That is really cool.

00:12:02.960 --> 00:12:17.580
Something else I just see in here, and I don't know quite where this shows up, but in that same organization that released all of these projects on GitHub, you know, they're grouped into a bunch of projects under an org and the GitHub org style.

00:12:18.100 --> 00:12:21.400
There's a thing called VDOM for Python.

00:12:21.400 --> 00:12:22.040
What does it say?

00:12:22.040 --> 00:12:31.500
It says a virtual HTML DOM for Python, which is pretty interesting for creating basically HTML and whatnot, like divs and paragraphs and stuff.

00:12:31.500 --> 00:12:35.280
So that's also in here somewhere for whatever people want to do with that.

00:12:35.280 --> 00:12:35.760
Interesting.

00:12:35.760 --> 00:12:36.080
Yeah.

00:12:36.080 --> 00:12:38.780
So I feel like this one is massive too.

00:12:38.780 --> 00:12:40.440
Like this is a really major thing.

00:12:40.440 --> 00:12:45.820
And, you know, organizations that depend on this notebook style, like this could really be a big deal.

00:12:45.820 --> 00:12:48.400
And I like that they split it out into different projects.

00:12:48.400 --> 00:12:52.100
Like the parameterization idea is, is powerful.

00:12:52.100 --> 00:12:53.860
And maybe you can use that by itself.

00:12:54.340 --> 00:13:01.080
And if you don't quite like the user interface, and so they've got the interact there that you can use that instead.

00:13:01.080 --> 00:13:03.820
These are cool that they've split them out a bit.

00:13:03.820 --> 00:13:05.780
I don't know how much they're tied together.

00:13:05.780 --> 00:13:12.220
I expect things like Titus and commuter might depend on other pieces more than others.

00:13:12.220 --> 00:13:13.280
But it's neat.

00:13:13.280 --> 00:13:13.960
It's really neat.

00:13:14.080 --> 00:13:19.200
So another thing that is pretty cool that I want to talk about is DigitalOcean.

00:13:19.200 --> 00:13:22.120
And I've told you a bunch of things about it last time we talked about projects.

00:13:22.120 --> 00:13:22.760
And that's pretty awesome.

00:13:22.760 --> 00:13:25.100
Brian, you've heard of Heroku, right?

00:13:25.100 --> 00:13:25.580
Yeah.

00:13:25.580 --> 00:13:26.940
Do you know what Doku is?

00:13:26.940 --> 00:13:27.460
Doku?

00:13:27.460 --> 00:13:28.700
I think it's Doku, actually.

00:13:28.700 --> 00:13:29.380
No, I don't.

00:13:29.480 --> 00:13:34.420
So Doku is apparently a miniature Heroku powered by Docker.

00:13:34.420 --> 00:13:41.640
So if you want to have your own Heroku, you can spin up a Linux machine or machines and install this thing called Doku.

00:13:41.640 --> 00:13:45.020
And then treat it like Heroku for deploying and managing your code.

00:13:45.020 --> 00:13:45.660
Oh, that's neat.

00:13:45.660 --> 00:13:46.180
That's neat.

00:13:46.180 --> 00:13:51.780
So over at DigitalOcean, they have a one-click deploy for creating Doku servers.

00:13:51.780 --> 00:13:56.120
So you should go over there, create a new droplet, and you just choose, I want a Doku thing all set up.

00:13:56.120 --> 00:13:56.480
Click.

00:13:56.480 --> 00:13:57.420
Boom.

00:13:57.540 --> 00:13:59.760
You're ready to make your own little version of Heroku.

00:13:59.760 --> 00:14:00.260
Wow.

00:14:00.260 --> 00:14:01.220
That's really cool.

00:14:01.220 --> 00:14:01.960
Yeah, it's really cool.

00:14:01.960 --> 00:14:05.960
So they have all these cool one-click things to create different types of environments.

00:14:05.960 --> 00:14:09.280
And I just thought I'd highlight this Doku one because I know people use Heroku a lot.

00:14:09.280 --> 00:14:13.680
And if you want some flexibility, this is a really awesome way to do it.

00:14:13.680 --> 00:14:18.180
So anyway, check them out at pythonbytes.fm/DigitalOcean.

00:14:18.180 --> 00:14:22.700
Get $100 credit if you're a new user to play with Doku or whatever else you want to play with.

00:14:22.700 --> 00:14:23.740
All right.

00:14:23.840 --> 00:14:30.160
So remember a while ago, we talked about running a Python script as a systemd service.

00:14:30.160 --> 00:14:30.620
Yes.

00:14:30.620 --> 00:14:31.600
That was a while ago.

00:14:31.600 --> 00:14:32.080
It was.

00:14:32.080 --> 00:14:32.840
It was quite a while ago.

00:14:32.840 --> 00:14:35.600
I'll link to that when we talked about that as well, that episode.

00:14:35.600 --> 00:14:42.180
But the idea was I would like to take some Python code and make it, you know, turn on when I boot my Linux system.

00:14:42.480 --> 00:14:49.560
The idea was to take a Python script and make it just boot win Linux boots and run in the background.

00:14:49.560 --> 00:14:52.420
It's kind of like if you did a cron job, but you have more control, right?

00:14:52.420 --> 00:14:55.160
Like your app, your Python code is constantly running.

00:14:55.160 --> 00:14:58.020
If it crashes, it'll restart if you configure it that way and stuff.

00:14:58.020 --> 00:15:00.900
Well, that's great for Linux.

00:15:00.900 --> 00:15:02.720
But what about for Windows, right?

00:15:02.720 --> 00:15:06.020
So the equivalent infrastructure in Windows is called a Windows service.

00:15:06.020 --> 00:15:08.640
It starts when Windows starts.

00:15:08.640 --> 00:15:13.900
If you want it that way, it can run when you're logged out or it can run as a different user.

00:15:13.900 --> 00:15:16.380
It can run as a restricted account, all these things.

00:15:16.380 --> 00:15:23.920
So if you want your app to run basically as Windows runs, right, then you have to create this Windows service.

00:15:24.460 --> 00:15:29.380
Well, it turns out it's quite easy to do this in Python if you use the right libraries.

00:15:29.380 --> 00:15:32.960
So there's a cool article that just says how to create a Windows service in Python.

00:15:32.960 --> 00:15:38.660
And it's based on this project called PyWin32, which seems to have no documentation.

00:15:38.660 --> 00:15:41.960
Maybe I just missed it, but it doesn't seem at all obvious out of use.

00:15:41.960 --> 00:15:44.100
But it is on GitHub and pretty popular.

00:15:44.100 --> 00:15:47.100
But this article talks about how to create a Windows service.

00:15:47.100 --> 00:15:53.180
And the idea is you just derive from a certain class and you override a stop, a start, and a main method.

00:15:53.700 --> 00:15:57.220
And boom, you have Python code that runs as if it were part of Windows.

00:15:57.220 --> 00:15:58.720
Actually, this is awesome.

00:15:58.720 --> 00:15:59.760
I'll use this right away.

00:15:59.760 --> 00:16:01.180
Yeah, yeah, it's really cool.

00:16:01.180 --> 00:16:04.360
I don't have a good â€“ I've written a couple of Windows services back in the day.

00:16:04.360 --> 00:16:07.560
I haven't had a chance or reason to do so recently.

00:16:07.560 --> 00:16:12.600
I did take that SystemD idea and do some really cool stuff around my courses for automation there.

00:16:12.600 --> 00:16:17.600
But if people are on Windows or they have to deploy to Windows, I think this is a great little example.

00:16:17.600 --> 00:16:23.260
So if that appeals to you, if that sounds like something you want to try to do, this is a really accessible way to do it.

00:16:23.260 --> 00:16:23.820
That's cool.

00:16:23.820 --> 00:16:24.440
Yeah, indeed.

00:16:24.440 --> 00:16:27.500
I'm glad that this came out because I thought about doing this before.

00:16:27.500 --> 00:16:28.760
I'm like, oh, man, I'm a smart guy.

00:16:28.760 --> 00:16:29.520
I can figure this out.

00:16:29.520 --> 00:16:31.520
I don't even know where to start looking.

00:16:31.520 --> 00:16:34.180
There's like weird registration stuff you have to do.

00:16:34.180 --> 00:16:34.820
But it's cool.

00:16:34.820 --> 00:16:41.440
You just say like the name of the service is this, the description of the service is this, the way it starts is like on system start or delayed or whatever.

00:16:41.440 --> 00:16:43.780
And then you just like run a command to install it.

00:16:43.780 --> 00:16:44.100
It's great.

00:16:44.100 --> 00:16:44.400
Nice.

00:16:44.400 --> 00:16:44.740
Yeah.

00:16:44.740 --> 00:16:47.560
You probably want to package it up though when you send it out.

00:16:47.940 --> 00:16:49.260
Yeah, you should package it.

00:16:49.260 --> 00:16:51.260
Have we talked about packaging before?

00:16:51.260 --> 00:16:52.020
I think so.

00:16:52.020 --> 00:16:52.840
Not enough.

00:16:52.840 --> 00:16:55.780
It's one of the things that should be more accessible.

00:16:55.780 --> 00:16:56.360
Okay.

00:16:56.360 --> 00:16:58.060
Well, let's talk about it again.

00:16:58.400 --> 00:17:03.200
So the Mamu Deshemi, I don't remember how long ago this was.

00:17:03.200 --> 00:17:04.520
I don't know if we covered it or not.

00:17:04.520 --> 00:17:11.060
But anyway, he wrote an article about different ways to package different levels of Python projects.

00:17:11.060 --> 00:17:13.160
And then he did a talk on it.

00:17:13.160 --> 00:17:17.720
And then now it's been all this information has been shared with others and edited.

00:17:17.720 --> 00:17:22.680
And it's part of the PyPA, the Python Package Authority documentation.

00:17:23.400 --> 00:17:26.300
And it's called an overview of packaging for Python.

00:17:26.300 --> 00:17:29.520
And it's kind of like how it's broken out.

00:17:29.520 --> 00:17:32.580
Because when you want to share Python code, there's different levels.

00:17:32.580 --> 00:17:35.620
So if you just want to share a module with somebody, there's that.

00:17:35.620 --> 00:17:41.660
And then so, I mean, it starts there and talks about how to just share a simple module with somebody else.

00:17:42.080 --> 00:17:50.360
But then you quickly get into packages with source distributions and wheels and possibly binary distributions and how to do that.

00:17:50.360 --> 00:17:55.500
And then, but that's complete packages are different than if you want to share an application.

00:17:55.500 --> 00:17:58.760
So I do, that's the part where I get fuzzy.

00:17:58.760 --> 00:18:02.820
But actually, this is a good starting point that hopefully they'll keep current.

00:18:02.980 --> 00:18:07.500
That talks about some of the different ways that you can share applications.

00:18:07.500 --> 00:18:10.260
Because, you know, sharing a web application is going to be different.

00:18:10.260 --> 00:18:17.340
And if you share it on Heroku, it's going to be different than sharing a desktop application or a command line application or something.

00:18:17.340 --> 00:18:24.280
And then also whether or not you want to assume people have Python or whether you want to package Python with it.

00:18:24.280 --> 00:18:27.660
And what do you do with the dependencies and all that.

00:18:27.860 --> 00:18:32.420
So we've talked about all this before and there's a lot of different solutions.

00:18:32.420 --> 00:18:38.320
And so this is a good starting point to take a look at if you want to share some code with somebody else.

00:18:38.320 --> 00:18:40.620
Start here and then get lost.

00:18:40.620 --> 00:18:41.500
There you go.

00:18:41.500 --> 00:18:42.000
I like it.

00:18:42.000 --> 00:18:43.880
It brings a lot of the stuff we talked about together.

00:18:43.880 --> 00:18:48.380
Like, for example, in the bring your own Python executable section.

00:18:48.380 --> 00:18:51.100
It's like, here's a whole bunch of ways to do this.

00:18:51.100 --> 00:18:55.280
You could use PyInstaller, CXFreeze, Constructor, which apparently I'd never heard of.

00:18:55.280 --> 00:18:56.600
OS Snap.

00:18:56.600 --> 00:18:57.220
OSnap.

00:18:57.580 --> 00:18:58.260
Another one.

00:18:58.260 --> 00:18:59.400
Like, there's a bunch of things in here.

00:18:59.400 --> 00:19:01.160
And I actually have only heard about half of them.

00:19:01.160 --> 00:19:02.200
So it's pretty cool.

00:19:02.200 --> 00:19:05.980
And since applications kind of range, everything else is fairly consistent.

00:19:05.980 --> 00:19:09.380
There's like one obvious right way to do it up through packages.

00:19:09.380 --> 00:19:15.800
And then it's with applications where it starts going off and feathering out into different solutions.

00:19:15.800 --> 00:19:19.300
I think it's because there's a lot of different requirements for applications.

00:19:19.300 --> 00:19:21.460
Different than just sharing source code.

00:19:21.460 --> 00:19:26.220
So I don't think it's a bad thing that we have a lot of different solutions right now.

00:19:26.300 --> 00:19:30.280
We've talked about how it'd be really nice if there was one obvious way.

00:19:30.280 --> 00:19:31.640
We're just not there yet.

00:19:31.640 --> 00:19:33.460
So here's a good list of some of them.

00:19:33.460 --> 00:19:33.720
Yep.

00:19:33.720 --> 00:19:34.560
That's really cool.

00:19:34.560 --> 00:19:35.520
Well done, Mahmood.

00:19:35.520 --> 00:19:44.640
So there was a little bit of drama a few weeks ago around PEP 572 about changing the Python language for an assignment in place assignment operator.

00:19:44.640 --> 00:19:45.020
Yeah.

00:19:45.020 --> 00:19:45.300
Remember that?

00:19:45.300 --> 00:19:52.240
And that was actually, that was part of the, one of the sort of straws that caused Guido to say, all right, I've had it with this.

00:19:52.240 --> 00:19:53.520
Tired of fighting over these things.

00:19:53.520 --> 00:19:53.860
I'm out.

00:19:53.860 --> 00:19:59.760
Well, here's a new PEP that I think proposes a bigger change to the Python language.

00:19:59.760 --> 00:20:00.980
This one is not accepted.

00:20:00.980 --> 00:20:01.980
It's in draft mode.

00:20:02.040 --> 00:20:03.220
So people can respond to it.

00:20:03.220 --> 00:20:08.140
However, I actually think the value this one brings is massive.

00:20:08.140 --> 00:20:09.320
It's a big deal though.

00:20:09.320 --> 00:20:10.200
It's a really big deal.

00:20:10.200 --> 00:20:15.760
So the idea is there's PEP 505 now, which is for none aware operators.

00:20:15.880 --> 00:20:18.560
And the idea is there are several languages that are proven.

00:20:18.560 --> 00:20:28.580
There's some nice design patterns or language patterns that short circuit working with none or null or whatever it is in the Swift.

00:20:28.580 --> 00:20:31.360
I forgot about what they call it there, but nothing, right?

00:20:31.360 --> 00:20:34.320
So there's basically two ways in which you work with this.

00:20:34.320 --> 00:20:40.920
One of these are called null coalescing operators, which lets you substitute a value if you have a none object.

00:20:40.920 --> 00:20:47.280
And null aware operators, which lets you chain operations regardless of whether with their null.

00:20:47.280 --> 00:20:52.080
So the two languages that are most popular that come to mind have to be C# and Swift.

00:20:52.080 --> 00:20:55.580
And both of these have deep support for this concept.

00:20:55.580 --> 00:21:06.500
Swift takes it to a whole other level to say you can't even assign the equivalent of none to a variable unless you mark it as nullable explicitly, which is way far out there.

00:21:06.500 --> 00:21:10.160
So the idea is like Python could benefit from this.

00:21:10.160 --> 00:21:13.440
So there's these two cases, the null coalescing and the null aware.

00:21:13.440 --> 00:21:15.280
So I'll give you the null coalescing, right?

00:21:15.280 --> 00:21:23.420
It's if you're going to do some kind of weird test, like you'd say something like value, if value is not none else missing, right?

00:21:23.420 --> 00:21:27.860
Like this big complicated thing could just be value, question mark, question mark, missing.

00:21:27.860 --> 00:21:31.700
It's either going to be the value, but if value is none, then it's the other value missing.

00:21:31.700 --> 00:21:32.920
What do you think of that, Brian?

00:21:32.920 --> 00:21:34.360
I'm still on the fence.

00:21:34.360 --> 00:21:34.720
Okay.

00:21:34.720 --> 00:21:38.160
This one to me actually doesn't offer a huge amount of value.

00:21:38.160 --> 00:21:39.000
It's okay.

00:21:39.400 --> 00:21:45.480
The next one to me is like pretty killer and more with the fluent style of calling functions chained together.

00:21:45.720 --> 00:21:53.220
So the null aware member access operator, it's the same basic PEP and the same basic structure, but it's used in a different case.

00:21:53.220 --> 00:21:56.740
It lets you chain these fluent interfaces together without testing for none.

00:21:56.740 --> 00:21:58.680
So suppose I have a user.

00:21:58.680 --> 00:21:59.920
The user has orders.

00:21:59.920 --> 00:22:04.360
The orders you can call a first operation, but if it's there's no orders, then it returns none.

00:22:04.360 --> 00:22:06.680
But if it does return one, the order has a name, right?

00:22:06.680 --> 00:22:09.300
So you would say like if user is none, return none.

00:22:09.300 --> 00:22:11.280
User.orders.first.

00:22:11.280 --> 00:22:14.160
If the first order is none, then we kind of bail out.

00:22:14.160 --> 00:22:18.700
But if you make it through all those tests, you can get first order.name.

00:22:18.940 --> 00:22:22.280
So that's a lot of code to be spoken over the air.

00:22:22.280 --> 00:22:28.820
But you would now with this new proposal say user?orders.first?name.name.

00:22:28.820 --> 00:22:30.320
And it would mean exactly the same thing.

00:22:30.320 --> 00:22:30.760
Okay.

00:22:30.840 --> 00:22:37.160
If you look at those two lines of code on digital paper, the amount of space on one and the other is ridiculous, right?

00:22:37.160 --> 00:22:37.500
Yeah.

00:22:37.500 --> 00:22:38.580
Sorry, I didn't mean to cut you off.

00:22:38.580 --> 00:22:48.520
First reading of the null aware operators, I was thinking it's just going to make the language more complicated to teach because when you're reading it, it isn't obvious what these things are doing.

00:22:48.520 --> 00:22:56.180
However, it does make the language smaller in that you can be more expressive in less code.

00:22:56.180 --> 00:22:57.880
And that's a good thing.

00:22:57.880 --> 00:23:05.880
I think it would make people more willing to effectively test for none when it could be none without cluttering the code, right?

00:23:05.880 --> 00:23:09.540
Like these two examples I gave you, it's like eight lines versus one line.

00:23:09.540 --> 00:23:11.620
You're willing to just go, oh, I just think it's there.

00:23:11.620 --> 00:23:12.360
I'll just go through it.

00:23:12.360 --> 00:23:16.320
And then you'll get none type does not have attributes such and such, right?

00:23:16.320 --> 00:23:17.560
Whatever the attribute is, right?

00:23:17.560 --> 00:23:18.640
You get that error all the time.

00:23:18.640 --> 00:23:20.060
It's one of the most common errors in Python.

00:23:20.060 --> 00:23:23.280
But if you just put the question marks in there, that totally goes away.

00:23:23.280 --> 00:23:28.460
That's the thing where if you don't think you need that problem, just think about how many times you see that.

00:23:28.460 --> 00:23:31.480
Like, you know, none does not have the index operator.

00:23:31.480 --> 00:23:32.100
Yes, exactly.

00:23:32.100 --> 00:23:32.700
Exactly.

00:23:32.700 --> 00:23:36.660
And this basically provides a much nicer way to deal with it.

00:23:37.100 --> 00:23:43.000
So my vote is for this feature, especially the null aware member access.

00:23:43.000 --> 00:23:43.380
Yeah.

00:23:43.380 --> 00:23:45.480
But I would be okay if Python never had it.

00:23:45.480 --> 00:23:49.380
But I do think the languages that do have it really make pretty good use of it.

00:23:49.380 --> 00:23:50.580
So it's in draft mode.

00:23:50.580 --> 00:23:53.740
People can give feedback before some sort of battle erupts over it.

00:23:53.740 --> 00:23:53.980
Yeah.

00:23:53.980 --> 00:23:54.920
I think it's good.

00:23:54.920 --> 00:23:55.160
Yeah.

00:23:55.160 --> 00:23:55.960
I do too.

00:23:55.960 --> 00:23:56.280
Cool.

00:23:56.280 --> 00:23:59.480
It'll let you have a second edition or third edition of your testing book, right?

00:23:59.480 --> 00:24:02.020
Because there's probably somewhere you got to put a question mark in there.

00:24:05.460 --> 00:24:06.860
You're just adding work for me.

00:24:06.860 --> 00:24:07.200
Thanks.

00:24:07.200 --> 00:24:08.800
Anyway, it's something for people to check out.

00:24:08.800 --> 00:24:09.580
Quite, quite good.

00:24:09.580 --> 00:24:11.800
I don't have anything extra to share with the folks.

00:24:11.800 --> 00:24:12.380
You, Brian?

00:24:12.380 --> 00:24:13.860
I've got a couple of things.

00:24:13.860 --> 00:24:22.420
I just noticed the other day that the PyCascades, it's going to be in February, February 23rd and 24th of 2019.

00:24:22.420 --> 00:24:24.560
And it's going to be in Seattle this time.

00:24:24.560 --> 00:24:27.440
It's the call for proposals is now open.

00:24:27.440 --> 00:24:28.300
Oh, that's sweet.

00:24:28.300 --> 00:24:29.260
You got a long time too.

00:24:29.260 --> 00:24:32.920
You got it now through October 21st to get in your proposal.

00:24:32.920 --> 00:24:34.460
Oh, I'm super excited about that.

00:24:34.460 --> 00:24:39.420
The opening, the inaugural PyCascades in Vancouver, BC last year was excellent.

00:24:39.420 --> 00:24:40.560
And I'm really glad I went.

00:24:40.560 --> 00:24:43.440
It was much smaller and it was a really intimate event.

00:24:43.440 --> 00:24:44.980
You got to meet a lot of the people who were there.

00:24:44.980 --> 00:24:47.320
And I'm looking forward to have it in Seattle.

00:24:47.320 --> 00:24:48.780
And it's coming to Portland next year.

00:24:48.780 --> 00:24:50.360
So that'll be even better.

00:24:50.360 --> 00:24:52.900
I'll try to go and I'll also try to submit something.

00:24:52.900 --> 00:24:53.640
That'll be good.

00:24:54.000 --> 00:25:05.040
The other thing I wanted to highlight is I just wanted to brag because I got a Test and Code episode out a week or so ago that was with David Heinemeyer Hansen.

00:25:05.040 --> 00:25:06.380
And it really went well.

00:25:06.380 --> 00:25:10.500
And he's not a Python person, but it's interesting information.

00:25:10.500 --> 00:25:12.040
So that was fun.

00:25:12.160 --> 00:25:12.300
All right.

00:25:12.300 --> 00:25:17.440
So for people who don't know who David Heinemeyer Hansen is, what's his claim to fame?

00:25:17.440 --> 00:25:18.540
Well, he's got lots.

00:25:18.540 --> 00:25:21.120
But he's the guy that made up Ruby on Rails.

00:25:21.120 --> 00:25:23.700
And he's one of the co-founders of Basecamp.

00:25:23.700 --> 00:25:24.120
Yeah.

00:25:24.120 --> 00:25:24.700
Just that.

00:25:24.700 --> 00:25:26.060
So that's pretty awesome.

00:25:26.060 --> 00:25:27.280
Yeah.

00:25:27.280 --> 00:25:28.620
It's really cool that he was on your show.

00:25:28.620 --> 00:25:31.300
And I'm looking forward to checking that out myself.

00:25:31.300 --> 00:25:39.900
It's definitely applicable to Python people as well because we talk about language agnostic things like just testing and stuff like that.

00:25:39.900 --> 00:25:40.340
Very cool.

00:25:40.340 --> 00:25:42.420
Well, thanks for the call out on PyCascades.

00:25:42.420 --> 00:25:42.960
Sure.

00:25:42.960 --> 00:25:44.660
PyCascades.

00:25:44.800 --> 00:25:49.580
But I also was catching up on your podcast, Talk Python.

00:25:49.580 --> 00:26:00.560
And they had a couple episodes that were people that learned Python after they didn't get CS degrees and learned Python later, programming later.

00:26:00.560 --> 00:26:05.360
And just the whole concept of that and listening to everybody's stories was very interesting.

00:26:05.360 --> 00:26:06.060
I like those.

00:26:06.060 --> 00:26:06.440
Yeah.

00:26:06.440 --> 00:26:06.820
Thank you.

00:26:06.820 --> 00:26:08.360
I did a two-part series on that.

00:26:08.480 --> 00:26:19.620
And I think it really connected to a lot of people because so many people find their way into our world of programming in Python without going through the traditional CS degree path.

00:26:19.620 --> 00:26:24.940
And I think it's just an example of a lot of people doing really great in alternate ways in.

00:26:24.940 --> 00:26:25.920
So, yeah, very cool.

00:26:25.920 --> 00:26:26.940
Well, good talking to you.

00:26:26.940 --> 00:26:27.980
And we'll talk next week.

00:26:27.980 --> 00:26:28.320
Yep.

00:26:28.320 --> 00:26:29.020
You as well.

00:26:29.020 --> 00:26:29.820
Catch you later.

00:26:29.820 --> 00:26:30.400
Bye, everyone.

00:26:32.880 --> 00:26:34.620
Thank you for listening to Python Bytes.

00:26:34.620 --> 00:26:37.180
Follow the show on Twitter via at Python Bytes.

00:26:37.180 --> 00:26:40.060
That's Python Bytes as in B-Y-T-E-S.

00:26:40.060 --> 00:26:43.480
And get the full show notes at pythonbytes.fm.

00:26:43.480 --> 00:26:47.840
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:26:47.840 --> 00:26:50.540
We're always on the lookout for sharing something cool.

00:26:50.540 --> 00:26:53.920
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:26:53.920 --> 00:26:57.560
Thank you for listening and sharing this podcast with your friends and colleagues.

