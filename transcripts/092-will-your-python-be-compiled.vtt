
00:00:00.000 --> 00:00:07.040
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode 92


00:00:07.040 --> 00:00:13.760
recorded August 23rd, 2018. I'm Michael Kennedy. And I'm Brian Eichen. Hey Brian, how you doing? I'm doing great.


00:00:13.760 --> 00:00:19.120
Yeah, same here. I'm excited to be back together and I can't wait to talk about some of these things. We have some like


00:00:19.120 --> 00:00:23.760
amazing drop the mic sort of stuff coming up. So pretty excited to get into that


00:00:23.760 --> 00:00:27.680
and also pretty excited that DigitalOcean is sponsoring this episode.


00:00:27.760 --> 00:00:29.080
So thank you, DigitalOcean.


00:00:29.080 --> 00:00:32.000
Check them out at pythonbytes.fm/digitalocean.


00:00:32.000 --> 00:00:35.120
Get $100 credit for new users.


00:00:35.120 --> 00:00:38.320
Right now, have we covered the fact that Python is popular?


00:00:38.320 --> 00:00:40.240
- Yeah, but I wanted to cover it again.


00:00:40.240 --> 00:00:41.080
- Why not?


00:00:41.080 --> 00:00:42.280
- So Python is pretty popular.


00:00:42.280 --> 00:00:44.760
And for the second year in a row,


00:00:44.760 --> 00:00:49.760
it came out as the number one popular programming language


00:00:49.760 --> 00:00:52.920
in the IEEE survey.


00:00:52.920 --> 00:00:55.960
So there's a, every year, IEEE puts out


00:00:55.960 --> 00:01:01.640
a popular programming survey and that it's at the top isn't really news.


00:01:01.640 --> 00:01:06.000
What's really kind of cool about it, though, and we'll have a link to the results.


00:01:06.000 --> 00:01:07.960
It's an interactive results thing.


00:01:07.960 --> 00:01:10.000
I think we covered it last year.


00:01:10.000 --> 00:01:14.720
But this time, Python is number one, even in embedded.


00:01:14.720 --> 00:01:16.480
And that's the thing that stands out this year.


00:01:16.480 --> 00:01:20.460
Yeah, and it's worth pointing out that this survey is for electrical engineers.


00:01:20.460 --> 00:01:25.660
It's not like the same as say, the Stack Overflow survey, which is maybe more developer focused.


00:01:25.660 --> 00:01:30.340
So it's like you saw another area where Python is sort of taken over, which is awesome.


00:01:30.340 --> 00:01:31.340
Embedded, like you say.


00:01:31.340 --> 00:01:37.380
The article that we're going to link to actually talks about whether or not this is real.


00:01:37.380 --> 00:01:43.020
And some people are doubting that Python really is that popular in embedded.


00:01:43.020 --> 00:01:46.420
Because I mean, there's a lot of day to day job are embedded.


00:01:46.420 --> 00:01:49.240
The embedded work I do is in C++.


00:01:49.240 --> 00:01:52.080
There's a big range of what it means to be embedded.


00:01:52.080 --> 00:01:53.860
So there's not, they don't really define that.


00:01:53.860 --> 00:01:55.060
You have to kind of define that yourself.


00:01:55.060 --> 00:01:58.820
I define it mostly as you're developing software


00:01:58.820 --> 00:02:01.700
on a platform that's not the target platform.


00:02:01.700 --> 00:02:04.540
And the target platform doesn't really look like a computer.


00:02:04.540 --> 00:02:08.020
- Like a Raspberry Pi or maybe like something embedded


00:02:08.020 --> 00:02:09.420
in your car or something like that?


00:02:09.420 --> 00:02:10.660
- Yeah, definitely.


00:02:10.660 --> 00:02:12.700
But even, it's a broad definition.


00:02:12.700 --> 00:02:15.540
So the embedded software I do actually runs


00:02:15.540 --> 00:02:17.820
on a Windows machine, but it doesn't look


00:02:17.820 --> 00:02:18.660
like a Windows machine.


00:02:18.660 --> 00:02:21.360
It looks like a, it's a testing equipment.


00:02:21.360 --> 00:02:24.440
It looks like a stereo component with dials and stuff.


00:02:24.440 --> 00:02:26.640
We don't run Python, we run C++.


00:02:26.640 --> 00:02:29.360
However, like you said, like Raspberry Pi,


00:02:29.360 --> 00:02:32.100
I think there's been a big push lately.


00:02:32.100 --> 00:02:33.680
I think that's where this is coming from.


00:02:33.680 --> 00:02:35.880
There's been a big push lately of trying to get people


00:02:35.880 --> 00:02:40.080
involved in more circuits and more real interactive


00:02:40.080 --> 00:02:43.840
programming with electronics through the use of


00:02:43.840 --> 00:02:47.200
MicroPython and CircuitPython on like Raspberry Pis


00:02:47.200 --> 00:02:50.920
and Arduinos and MicroBits and all that sort of stuff.


00:02:50.920 --> 00:02:54.360
And including the Mew editor that really tries to teach


00:02:54.360 --> 00:02:55.700
people right out of the get go.


00:02:55.700 --> 00:02:58.380
So there is some doubt of whether or not really


00:02:58.380 --> 00:03:00.720
Python's the top for embedded, but I don't doubt it at all.


00:03:00.720 --> 00:03:02.360
I think it's gonna stay.


00:03:02.360 --> 00:03:03.180
- Yeah, I think it's cool.


00:03:03.180 --> 00:03:05.020
I mean, you could have the debate of,


00:03:05.020 --> 00:03:07.760
well, it's on professional shipping embedded devices


00:03:07.760 --> 00:03:10.200
that are for sale versus embedded in general,


00:03:10.200 --> 00:03:13.920
which like you say, could include $5 Adafruit type things


00:03:13.920 --> 00:03:16.280
that people play with or they're using in school,


00:03:16.280 --> 00:03:18.160
but it's not for sale per se.


00:03:18.160 --> 00:03:20.360
- Right, there's a lot of people taking those


00:03:20.360 --> 00:03:23.640
Adafruit things and turning them into kits for people


00:03:23.640 --> 00:03:26.080
for products for people to like wear.


00:03:26.080 --> 00:03:29.000
And then the people that are learning on that


00:03:29.000 --> 00:03:30.940
are gonna go into,


00:03:30.940 --> 00:03:33.560
it might go into other embedded jobs.


00:03:33.560 --> 00:03:36.920
And I think since Python is faster to develop in,


00:03:36.920 --> 00:03:38.820
there's a big incentive, I think,


00:03:38.820 --> 00:03:40.840
for people to use a higher level language


00:03:40.840 --> 00:03:43.720
and embedded if they can, even in a production level.


00:03:43.720 --> 00:03:45.580
- Yeah, and if they are, it's gotta be Python, right?


00:03:45.580 --> 00:03:46.560
Like what else would it be?


00:03:46.560 --> 00:03:47.400
- Right.


00:03:47.400 --> 00:03:50.540
- Yeah, maybe JavaScript, but that's a little shaky.


00:03:50.540 --> 00:03:51.380
Very interesting.


00:03:51.380 --> 00:03:53.700
So you ready for something incredible?


00:03:53.700 --> 00:03:56.500
- Yeah, is this drop the mic thing you're talking about?


00:03:56.500 --> 00:03:58.100
- Yeah, unfortunately it's the second one,


00:03:58.100 --> 00:03:59.060
so I have to pick it back up.


00:03:59.060 --> 00:04:03.180
But let me work my way into this the way that it developed.


00:04:03.180 --> 00:04:06.940
So we have the mailing list, Python dev, okay?


00:04:06.940 --> 00:04:08.780
And that's where a lot of the core developers talk.


00:04:08.780 --> 00:04:09.620
- Okay.


00:04:09.620 --> 00:04:11.900
- Okay, on this list, someone was talking about


00:04:11.900 --> 00:04:15.020
finding a better way to test the C APIs


00:04:15.020 --> 00:04:17.860
instead of writing some C tests, some Python tests,


00:04:17.860 --> 00:04:19.140
and those kinds of things, right?


00:04:19.140 --> 00:04:21.700
You can be sympathetic with this, I'm sure.


00:04:21.700 --> 00:04:26.740
They were saying, "Look, we need to test the C code inside CPython.


00:04:26.740 --> 00:04:29.940
One way to do this would, maybe we could use something like Cython."


00:04:29.940 --> 00:04:36.820
We talked previously about how Cython lets you pretty easily integrate with C and Python


00:04:36.820 --> 00:04:37.820
at the same time.


00:04:37.820 --> 00:04:40.700
There was some debate saying, "It might be a good idea.


00:04:40.700 --> 00:04:42.100
It might not be a good idea."


00:04:42.100 --> 00:04:44.980
On one hand, Cython is changing a lot.


00:04:44.980 --> 00:04:51.940
a pretty big dependency to take as part of the core development component of Python itself,


00:04:51.940 --> 00:04:52.940
things like that.


00:04:52.940 --> 00:04:57.380
But then something pretty incredible came along here.


00:04:57.380 --> 00:05:00.040
And I don't know how far along this is or whatever.


00:05:00.040 --> 00:05:03.020
But this guy named Yuri steps in and drops a bit of a bombshell.


00:05:03.020 --> 00:05:06.220
And he says, Hey, you guys, this Cython thing is kind of cool.


00:05:06.220 --> 00:05:07.700
And I don't know if you want to do it.


00:05:07.700 --> 00:05:13.340
But over at Dropbox, we're working on a new, new compiler for Python called mypyc.


00:05:13.340 --> 00:05:21.340
And it just says, well, this mypyc will compile type annotated Python to optimized C code,


00:05:21.340 --> 00:05:23.740
which ultimately compiles to machine instructions.


00:05:23.740 --> 00:05:24.740
That's pretty cool.


00:05:24.740 --> 00:05:25.740
How about that?


00:05:25.740 --> 00:05:27.820
So it's like Cython, right?


00:05:27.820 --> 00:05:32.900
We've seen that where Cython can make things like 20 or 50 times faster in certain circumstances,


00:05:32.900 --> 00:05:35.980
because it's compiled really interesting stuff there.


00:05:35.980 --> 00:05:41.060
But the problem with Cython is it's a superset of Python, you have like the C def, and like


00:05:41.060 --> 00:05:45.460
You basically write in a separate language that if you squint, you're like, "Wait a minute,


00:05:45.460 --> 00:05:46.460
is that Python?


00:05:46.460 --> 00:05:49.500
No, no, no, there's a lot of weird other stuff going on around here.


00:05:49.500 --> 00:05:51.540
This is not Python, but it's Python-like."


00:05:51.540 --> 00:05:56.020
It doesn't even use the same type annotations because it sort of predated that.


00:05:56.020 --> 00:06:00.720
Cython is good, but it has this, "You got to write in Cython, not Python."


00:06:00.720 --> 00:06:06.140
This mypyc thing they're talking about, this is straight Python 3.6 code.


00:06:06.140 --> 00:06:10.660
It runs on CPython, but you can compile it to machine instructions like Cython.


00:06:10.660 --> 00:06:13.660
It's not all of Python, it's a subset, right?


00:06:13.660 --> 00:06:15.660
It's a subset, exactly.


00:06:15.660 --> 00:06:20.660
I think the main thing is you have to type annotate everything so it can actually compile.


00:06:20.660 --> 00:06:24.660
That's more or less the difference with Cython, is you type annotate everything.


00:06:24.660 --> 00:06:27.660
But it's a different type. It's using Cython types.


00:06:27.660 --> 00:06:32.660
Right, but this is using just normal type annotations.


00:06:32.660 --> 00:06:36.660
It's pretty incredible. It says, "Look, this is standard Python. It's a subset of Python."


00:06:36.660 --> 00:06:40.660
And you can easily integrate with C libraries because of CFFI.


00:06:40.660 --> 00:06:45.220
You can even run it on PyPy because it's a subset of Python.


00:06:45.220 --> 00:06:47.260
So it's pretty cool.


00:06:47.260 --> 00:06:52.540
And if Dropbox releases a full-on compiler for Python, that would shock the world, I


00:06:52.540 --> 00:06:53.540
think.


00:06:53.540 --> 00:06:55.460
Yeah, definitely.


00:06:55.460 --> 00:07:00.620
Like even with this, with a subset, to be able to develop it in Python and then do some


00:07:00.620 --> 00:07:05.820
little extra work to go to the, to make sure you're able to compile it within this, this


00:07:05.820 --> 00:07:06.820
This would be great.


00:07:06.820 --> 00:07:08.020
And the extra work is not much.


00:07:08.020 --> 00:07:10.400
It's like put type annotations on it.


00:07:10.400 --> 00:07:13.980
So maybe you have like three or four functions that you call that are like really called


00:07:13.980 --> 00:07:17.460
frequently or really a minor portion of your time is spent there.


00:07:17.460 --> 00:07:19.540
And if you wrote it in like C, it would be way faster.


00:07:19.540 --> 00:07:23.140
Well, if you just put type annotations on it, you know, you could probably hit it with


00:07:23.140 --> 00:07:24.140
this thing.


00:07:24.140 --> 00:07:28.820
So pretty interesting little thread that got picked up there.


00:07:28.820 --> 00:07:33.540
We'll have to watch this and make update people if we see any more progress.


00:07:33.540 --> 00:07:37.660
Yeah, what I did not see is here's a link to the Git repo or here's the announcement


00:07:37.660 --> 00:07:38.940
or anything like that.


00:07:38.940 --> 00:07:41.440
So we'll have to see if anything comes from it.


00:07:41.440 --> 00:07:47.360
But I think it's really interesting, you know, that, that we've sort of gotten to this place.


00:07:47.360 --> 00:07:52.220
Because from my understanding is Guido is not a huge fan of compiling Python code and


00:07:52.220 --> 00:07:57.700
didn't see a need for this, but he must be involved in this because it's from Dropbox.


00:07:57.700 --> 00:08:00.740
And the main work he's doing that Dropbox is on my pi.


00:08:00.740 --> 00:08:01.980
And it's all about this.


00:08:01.980 --> 00:08:05.500
So I suspect he's involved somehow, but I have no confirmation that.


00:08:05.500 --> 00:08:06.500
Yeah.


00:08:06.500 --> 00:08:07.500
Okay, cool.


00:08:07.500 --> 00:08:08.500
Boom, mic drop.


00:08:08.500 --> 00:08:09.500
Okay, I'll pick it up.


00:08:09.500 --> 00:08:11.540
Well, let's, let's talk about Netflix.


00:08:11.540 --> 00:08:13.340
They are doing such cool stuff with Python.


00:08:13.340 --> 00:08:14.860
Yeah, so it's Python and more.


00:08:14.860 --> 00:08:22.620
So there's a really cool article called beyond interactive notebook innovation at Netflix.


00:08:22.620 --> 00:08:30.060
And as we've all known, Jupyter notebooks have and using the Jupyter system is kind


00:08:30.060 --> 00:08:38.000
of revolutionized a lot of data analysis and machine learning and quite a bit of that interacting


00:08:38.000 --> 00:08:39.820
with data environment.


00:08:39.820 --> 00:08:45.100
And that's true at Netflix as well, and that's what this article is talking about, is a lot


00:08:45.100 --> 00:08:46.500
of the cool things that they've done.


00:08:46.500 --> 00:08:51.700
And over the last few years, they've seen a larger and larger growth, and they've also


00:08:51.700 --> 00:08:56.540
said basically this is our supplied data chain.


00:08:56.540 --> 00:09:00.020
I never really thought about all the different types of people that interact with data, but


00:09:00.020 --> 00:09:02.940
They listed, they have a little diagram,


00:09:02.940 --> 00:09:07.620
they listed like nine or 10 different job roles


00:09:07.620 --> 00:09:10.060
that interact with data a little bit differently,


00:09:10.060 --> 00:09:12.460
but they're all interacting with it.


00:09:12.460 --> 00:09:15.340
Like data experts or data analysts


00:09:15.340 --> 00:09:18.700
or algorithm engineers or data scientists.


00:09:18.700 --> 00:09:19.900
There's all these different things


00:09:19.900 --> 00:09:21.780
and I'm not quite sure what they all do different,


00:09:21.780 --> 00:09:24.980
but they're all interacting with these huge data sets.


00:09:24.980 --> 00:09:28.680
And in their effort to use notebooks and Jupyter


00:09:28.680 --> 00:09:32.440
to streamline and make things easier for people.


00:09:32.440 --> 00:09:34.200
In the process, they've came up with


00:09:34.200 --> 00:09:36.080
some really cool extra projects that they've


00:09:36.080 --> 00:09:40.320
open-sourced or developing in the open.


00:09:40.320 --> 00:09:42.440
I'm going to run through a few of them.


00:09:42.440 --> 00:09:44.000
One of them is called Interact,


00:09:44.000 --> 00:09:46.720
and it's an alternative user interface


00:09:46.720 --> 00:09:48.480
that has some cool things like


00:09:48.480 --> 00:09:51.780
inline cell toolbars and drag and drop cells.


00:09:51.780 --> 00:09:54.760
I didn't know that you couldn't do that in Jupyter,


00:09:54.760 --> 00:09:56.720
but that's neat, and


00:09:56.720 --> 00:09:58.720
and a built-in data explorer.


00:09:58.720 --> 00:10:03.120
And then, if you've got a Jupyter Notebook all set up with some data,


00:10:03.120 --> 00:10:05.420
well, wouldn't it be cool if you could have some of your


00:10:05.420 --> 00:10:08.920
states parameterized so you can run the whole notebook


00:10:08.920 --> 00:10:11.420
with different parameters?


00:10:11.420 --> 00:10:14.820
This is almost like making a notebook like a function you can call


00:10:14.820 --> 00:10:16.420
and pass it inputs and get outputs.


00:10:16.420 --> 00:10:19.920
Exactly, and that's what Paper Mill is partly.


00:10:19.920 --> 00:10:22.920
So there's a project called Paper Mill that parameterizes notebooks.


00:10:22.920 --> 00:10:24.720
And then it also does things like,


00:10:24.720 --> 00:10:26.360
If you parameterize the bunch,


00:10:26.360 --> 00:10:28.560
you can analyze the different set of


00:10:28.560 --> 00:10:32.280
parameterized runs and do some analysis on the set.


00:10:32.280 --> 00:10:35.400
Then there's, yeah, it's making a notebook,


00:10:35.400 --> 00:10:37.660
like you said, a function that you can call.


00:10:37.660 --> 00:10:40.400
Then if you're using that and you want to share it with


00:10:40.400 --> 00:10:43.600
other people with the data and with the results,


00:10:43.600 --> 00:10:46.360
they've put together a thing called commuter that lets


00:10:46.360 --> 00:10:50.600
people share them with each other, and then also scheduling.


00:10:50.600 --> 00:10:53.440
There's a separate article that's attached at the end


00:10:53.440 --> 00:11:03.340
about how if you got this function with different parameters and stuff maybe you wanna it's your you wanna test different live data so you wanna schedule it regularly or different times


00:11:03.340 --> 00:11:21.440
they've got a notebook schedule scheduling system in place so all of this is it's not like a super easy thing to jump into but the train to make it easier for people and this is actually some pretty neat things that they shared with everybody this is incredible if you look at this big infrastructure diagram they have it's like


00:11:21.380 --> 00:11:35.840
It's just this entire architecture and cloud platform for running their style of executable notebooks using this new UI on containers you can configure and schedule.


00:11:35.840 --> 00:11:43.620
It's really crazy and you can even come down and say I'd like to run on some container with four CPUs and 30 gigs of ram.


00:11:44.140 --> 00:11:56.580
go right it's crazy it's kind of amazing i'm trying to start exploring a little bit more of what people are doing with jupiter netbooks and other parts of the jupiter system because it's a


00:11:56.580 --> 00:12:03.200
it is sort of opening up a lot of different data analysis into the open just need yeah that is really cool


00:12:03.160 --> 00:12:08.840
Something else I just see in here, and I don't know quite where this shows up, but in that same


00:12:08.840 --> 00:12:14.440
organization that released all of these projects on GitHub, you know, they're grouped into a bunch


00:12:14.440 --> 00:12:21.640
of projects under an org in the GitHub org style. There's a thing called VDOM for Python, what does


00:12:21.640 --> 00:12:27.320
it say? It says a virtual HTML DOM for Python, which is pretty interesting for creating basically


00:12:27.320 --> 00:12:31.860
HTML and whatnot like divs and paragraphs and stuff.


00:12:31.860 --> 00:12:35.900
So that's also in here somewhere for whatever people want to do with that.


00:12:35.900 --> 00:12:36.900
Interesting.


00:12:36.900 --> 00:12:37.900
Yeah.


00:12:37.900 --> 00:12:38.900
So I feel like this one is massive too.


00:12:38.900 --> 00:12:43.620
Like this is a really major thing and you know organizations that depend on this notebook


00:12:43.620 --> 00:12:45.980
style like this could really be a big deal.


00:12:45.980 --> 00:12:51.500
And I like that they split it out into different projects like the parameterization idea is


00:12:51.500 --> 00:12:54.740
powerful and maybe you can use that by itself.


00:12:54.740 --> 00:13:00.340
And if you don't quite like the user interface, so they've got the interact there that you


00:13:00.340 --> 00:13:01.340
can use that instead.


00:13:01.340 --> 00:13:03.860
These are cool that they've split them out a bit.


00:13:03.860 --> 00:13:06.300
I don't know how much they're tied together.


00:13:06.300 --> 00:13:12.420
I expect things like Titus and Commuter might depend on other pieces more than others, but


00:13:12.420 --> 00:13:13.420
it's neat.


00:13:13.420 --> 00:13:14.420
It's really neat.


00:13:14.420 --> 00:13:19.460
So another thing that is pretty cool that I want to talk about is DigitalOcean.


00:13:19.460 --> 00:13:22.300
And I've told you a bunch of things about it last time we talked about projects, and


00:13:22.300 --> 00:13:23.300
that's pretty awesome.


00:13:23.300 --> 00:13:25.440
- So, Darren, you've heard of Heroku, right?


00:13:25.440 --> 00:13:26.280
- Yeah.


00:13:26.280 --> 00:13:27.180
- Do you know what Doku is?


00:13:27.180 --> 00:13:28.020
Doku?


00:13:28.020 --> 00:13:28.860
I think it's Doku, actually.


00:13:28.860 --> 00:13:29.700
- No, I don't.


00:13:29.700 --> 00:13:33.500
- So, Doku is apparently a miniature Heroku


00:13:33.500 --> 00:13:35.060
powered by Docker.


00:13:35.060 --> 00:13:37.060
So, if you want to have your own Heroku,


00:13:37.060 --> 00:13:39.980
you can spin up a Linux machine or machines


00:13:39.980 --> 00:13:42.180
and install this thing called Doku


00:13:42.180 --> 00:13:43.580
and then treat it like Heroku


00:13:43.580 --> 00:13:45.140
for deploying and managing your code.


00:13:45.140 --> 00:13:45.980
- Oh, that's neat.


00:13:45.980 --> 00:13:46.800
- That's neat.


00:13:46.800 --> 00:13:49.580
So, over at DigitalOcean, they have a one-click deploy


00:13:49.580 --> 00:13:52.060
for creating Doku servers.


00:13:52.060 --> 00:13:53.700
So you just go over there, create a new droplet,


00:13:53.700 --> 00:13:56.160
and you just choose, I want a Doku thing all set up.


00:13:56.160 --> 00:13:58.500
Click, boom, you're ready to make


00:13:58.500 --> 00:14:00.020
your own little version of Heroku.


00:14:00.020 --> 00:14:01.300
- Wow, that's really cool.


00:14:01.300 --> 00:14:02.180
- Yeah, it's really cool.


00:14:02.180 --> 00:14:04.500
So they have all these cool one-click things


00:14:04.500 --> 00:14:06.120
to create different types of environments.


00:14:06.120 --> 00:14:07.860
And I just thought I'd highlight this Doku one


00:14:07.860 --> 00:14:09.340
'cause I know people use Heroku a lot,


00:14:09.340 --> 00:14:11.000
and if you want some flexibility,


00:14:11.000 --> 00:14:14.060
this is a really awesome way to do it.


00:14:14.060 --> 00:14:18.380
So anyway, check them out at pythonbytes.fm/digitalocean.


00:14:18.380 --> 00:14:20.740
Get $100 credit if you're a new user


00:14:20.740 --> 00:14:23.500
to play with Doku or whatever else you want to play with.


00:14:23.500 --> 00:14:26.420
All right, so remember a while ago,


00:14:26.420 --> 00:14:28.740
we talked about running a Python script


00:14:28.740 --> 00:14:30.380
as a system D service.


00:14:30.380 --> 00:14:31.700
- Yes, that was a while ago.


00:14:31.700 --> 00:14:32.980
- It was, it was quite a while ago.


00:14:32.980 --> 00:14:35.100
I'll link to that when we talked about that as well,


00:14:35.100 --> 00:14:36.220
that episode.


00:14:36.220 --> 00:14:38.860
But the idea was I would like to take some Python code


00:14:38.860 --> 00:14:42.700
and make it, you know, turn on when I boot my Linux system.


00:14:42.700 --> 00:14:45.440
The idea was to take a Python script


00:14:45.440 --> 00:14:48.780
and make it just boot when Linux boots


00:14:48.780 --> 00:14:49.740
and run in the background.


00:14:49.740 --> 00:14:51.240
It's kind of like if you did a cron job,


00:14:51.240 --> 00:14:52.500
but you have more control, right?


00:14:52.500 --> 00:14:55.260
Like your app, your Python code is constantly running.


00:14:55.260 --> 00:14:56.660
If it crashes, it'll restart


00:14:56.660 --> 00:14:58.500
if you configure it that way and stuff.


00:14:58.500 --> 00:15:01.120
Well, that's great for Linux,


00:15:01.120 --> 00:15:03.040
but what about for Windows, right?


00:15:03.040 --> 00:15:04.940
So the equivalent infrastructure in Windows


00:15:04.940 --> 00:15:06.820
is called a Windows Service.


00:15:06.820 --> 00:15:09.700
It starts when Windows starts, if you want it that way,


00:15:09.700 --> 00:15:12.420
it can run when you're logged out,


00:15:12.420 --> 00:15:14.340
or it can run as a different user,


00:15:14.340 --> 00:15:16.460
it can run as a restricted account, all these things.


00:15:16.460 --> 00:15:21.460
So if you want your app to run basically as Windows runs,


00:15:21.460 --> 00:15:24.660
then you have to create this Windows service.


00:15:24.660 --> 00:15:28.460
Well, it turns out it's quite easy to do this in Python


00:15:28.460 --> 00:15:29.500
if you use the right libraries.


00:15:29.500 --> 00:15:31.380
So there's a cool article that just says


00:15:31.380 --> 00:15:33.580
how to create a Windows service in Python.


00:15:33.580 --> 00:15:36.300
And it's based on this project called pywin32,


00:15:36.300 --> 00:15:38.980
which seems to have no documentation.


00:15:38.980 --> 00:15:39.880
Maybe I just missed it,


00:15:39.880 --> 00:15:42.500
but it doesn't seem at all obvious how to use.


00:15:42.500 --> 00:15:44.780
But it is on GitHub and pretty popular.


00:15:44.780 --> 00:15:47.180
But this article talks about how to create a Windows service.


00:15:47.180 --> 00:15:50.460
And the idea is you just derive from a certain class,


00:15:50.460 --> 00:15:53.980
and you override a stop, a start, and a main method.


00:15:53.980 --> 00:15:56.140
And boom, you have Python code that runs


00:15:56.140 --> 00:15:57.740
as if it were part of Windows.


00:15:57.740 --> 00:15:58.940
Actually, this is awesome.


00:15:58.940 --> 00:15:59.980
I'll use this right away.


00:15:59.980 --> 00:16:01.220
Yeah, yeah, it's really cool.


00:16:01.220 --> 00:16:02.140
I don't have a good--


00:16:02.140 --> 00:16:04.600
I've written a couple of Windows services back in the day.


00:16:04.600 --> 00:16:07.700
I haven't had a chance or reason to do so recently.


00:16:07.700 --> 00:16:10.780
I did take that systemd idea and do some really cool stuff


00:16:10.780 --> 00:16:12.660
around my courses for automation there.


00:16:12.660 --> 00:16:15.740
But if people are on Windows or they have to deploy to Windows,


00:16:15.740 --> 00:16:17.740
I think this is a great little example.


00:16:17.740 --> 00:16:19.460
So if that appeals to you,


00:16:19.460 --> 00:16:21.140
if that sounds like something you want to try to do,


00:16:21.140 --> 00:16:23.340
this is a really accessible way to do it.


00:16:23.340 --> 00:16:23.900
>> That's cool.


00:16:23.900 --> 00:16:24.580
>> Yeah, indeed.


00:16:24.580 --> 00:16:27.580
>> I'm glad that this came out because I thought about doing this before.


00:16:27.580 --> 00:16:28.780
I'm like, "Oh man, I'm a smart guy.


00:16:28.780 --> 00:16:31.580
I can figure this out." I don't even know where to start looking.


00:16:31.580 --> 00:16:34.860
>> There's weird registration stuff you have to do, but it's cool.


00:16:34.860 --> 00:16:36.620
You just say the name of the service is this,


00:16:36.620 --> 00:16:38.060
the description of the service is this,


00:16:38.060 --> 00:16:41.780
the way it starts is on system start or delayed or whatever.


00:16:41.780 --> 00:16:44.740
Then you just like run a command to install it. It's great. Nice. Yeah.


00:16:44.740 --> 00:16:49.060
I probably want to package it up though when you send it out. Yeah, you should package it.


00:16:49.060 --> 00:16:54.340
Have we talked about packaging before? I think so. Not enough. It's one of the things that should


00:16:54.340 --> 00:17:00.260
be more, more accessible. Okay. Well, let's talk about it again. So the Mahmoud Shemi,


00:17:00.260 --> 00:17:05.300
while I don't remember how long this was, I don't know if we covered it or not. But anyway,


00:17:05.300 --> 00:17:10.980
he wrote an article about different ways to package different levels of Python projects.


00:17:10.980 --> 00:17:13.180
And then you did a talk on it.


00:17:13.180 --> 00:17:18.340
And then that now it's been all this information has been shared with others and edited.


00:17:18.340 --> 00:17:23.900
And it's part of the PyPA, the Python Package Authority documentation.


00:17:23.900 --> 00:17:27.260
And it's called an overview of packaging for Python.


00:17:27.260 --> 00:17:29.880
And it's kind of like how it's broken out.


00:17:29.880 --> 00:17:32.740
Because when you want to share Python code, there's different levels.


00:17:32.740 --> 00:17:36.020
So if you just want to share a module with somebody, there's that.


00:17:36.020 --> 00:17:41.460
And then so it starts there and talks about how to just share a simple module with somebody


00:17:41.460 --> 00:17:42.460
else.


00:17:42.460 --> 00:17:47.380
But then you quickly get into packages with source distributions and wheels and possibly


00:17:47.380 --> 00:17:51.560
binary distributions and how to do that.


00:17:51.560 --> 00:17:52.940
But that's complete.


00:17:52.940 --> 00:17:56.140
Packages are different than if you want to share an application.


00:17:56.140 --> 00:17:59.040
So that's the part where I get fuzzy.


00:17:59.040 --> 00:18:03.700
But actually, this is a good starting point that hopefully they'll keep current that talks


00:18:03.700 --> 00:18:07.620
about some of the different ways that you can share applications,


00:18:07.620 --> 00:18:10.540
because sharing a web application is going to be different.


00:18:10.540 --> 00:18:12.220
And if you share it on Heroku,


00:18:12.220 --> 00:18:15.700
it's going to be different than sharing a desktop application


00:18:15.700 --> 00:18:17.380
or a command line application or something.


00:18:17.380 --> 00:18:21.860
So and then also whether or not you want to assume people have Python


00:18:21.860 --> 00:18:24.660
or whether you want to package Python with it


00:18:24.660 --> 00:18:27.660
and what do you do with the dependencies and all that.


00:18:27.660 --> 00:18:30.700
So we've talked about all this before,


00:18:30.700 --> 00:18:32.540
and there's a lot of different solutions.


00:18:32.540 --> 00:18:38.420
And so this is a good a good starting point to take a look at if you want to share some code with somebody else.


00:18:38.420 --> 00:18:40.940
Start here and then get lost.


00:18:40.940 --> 00:18:44.140
There you go. I like it. It brings a lot of the stuff we talked about together.


00:18:44.140 --> 00:18:48.620
Like for example, in the bring your own Python executable section,


00:18:48.620 --> 00:18:51.220
it's like here's a whole bunch of ways to do this.


00:18:51.220 --> 00:18:55.380
You could use pyinstaller, cxfreeze, constructor, which apparently I'd never heard of.


00:18:55.380 --> 00:18:58.260
OS snap, OSnap, another one.


00:18:58.260 --> 00:19:01.180
Like there's a bunch of things in here and I actually have only heard about half of them.


00:19:01.180 --> 00:19:02.220
So it's pretty cool.


00:19:02.220 --> 00:19:06.140
And since applications kind of range, everything else is fairly consistent.


00:19:06.140 --> 00:19:09.540
There's like one obvious right way to do it up through packages.


00:19:09.540 --> 00:19:14.100
And then it's, it's with applications where it starts going off in


00:19:14.100 --> 00:19:15.900
feathering out into different solutions.


00:19:15.900 --> 00:19:19.440
I think it's because there's a lot of different requirements for applications,


00:19:19.440 --> 00:19:21.420
uh, different than just sharing source code.


00:19:21.420 --> 00:19:25.120
So I think it's, I don't think it's a bad thing that, that we have a lot


00:19:25.120 --> 00:19:26.220
of different solutions right now.


00:19:26.220 --> 00:19:30.340
We've, we've talked about how it's, it'd be really nice if there was one obvious way.


00:19:30.340 --> 00:19:31.660
We're just not there yet.


00:19:31.660 --> 00:19:33.660
So here's a good list of some of them.


00:19:33.660 --> 00:19:35.660
Yep, that's really cool. Well done, Mahmoud.


00:19:35.660 --> 00:19:39.660
So there was a little bit of drama a few weeks ago around PEP 572


00:19:39.660 --> 00:19:44.660
about changing the Python language for an assignment in place assignment operator.


00:19:44.660 --> 00:19:45.660
Yeah.


00:19:45.660 --> 00:19:50.660
And that was actually part of one of the sort of straws that caused Guido to say,


00:19:50.660 --> 00:19:53.660
"All right, I've had it with this. I'm tired of fighting over these things. I'm out."


00:19:53.660 --> 00:19:59.660
Well, here's a new PEP that I think proposes a bigger change to the Python language.


00:19:59.660 --> 00:20:03.160
this one is not accepted, it's in draft mode, so people can respond to it.


00:20:03.160 --> 00:20:08.160
However, I actually think the value this one brings is massive.


00:20:08.160 --> 00:20:10.160
It's a big deal though, it's a really big deal.


00:20:10.160 --> 00:20:15.660
So the idea is there's PEP 505 now, which is for none-aware operators.


00:20:15.660 --> 00:20:18.660
And the idea is there are several languages that have proven


00:20:18.660 --> 00:20:21.660
there's some nice design patterns or language patterns


00:20:21.660 --> 00:20:28.660
that short-circuit working with none or null or whatever it is in Swift.


00:20:28.660 --> 00:20:31.540
I forgot about what they call it there, but nothing, right?


00:20:31.540 --> 00:20:34.300
So there's basically two ways in which you work with this.


00:20:34.300 --> 00:20:37.460
One of these are called null coalescing operators,


00:20:37.460 --> 00:20:41.300
which lets you substitute a value if you have a none object.


00:20:41.300 --> 00:20:45.540
And null aware operators, which lets you chain operations


00:20:45.540 --> 00:20:47.300
regardless of whether with or null.


00:20:47.300 --> 00:20:49.140
So the two languages that are most popular


00:20:49.140 --> 00:20:52.580
that come to mind have to be C# and Swift.


00:20:52.580 --> 00:20:55.900
And both of these have deep support for this concept.


00:20:55.900 --> 00:20:57.860
Swift takes it to a whole nother level


00:20:57.860 --> 00:21:03.780
to say you can't even assign the equivalent of none to a variable unless you mark it as


00:21:03.780 --> 00:21:07.060
nullable explicitly, which is way far out there.


00:21:07.060 --> 00:21:10.460
So the idea is like Python could benefit from this.


00:21:10.460 --> 00:21:13.660
So there's these two cases, the null coalescing and the null aware.


00:21:13.660 --> 00:21:15.420
So I'll give you the null coalescing, right?


00:21:15.420 --> 00:21:20.060
It's if you're going to do some kind of weird test, like you'd say something like value,


00:21:20.060 --> 00:21:23.540
if value is not none else missing, right?


00:21:23.540 --> 00:21:28.540
this big complicated thing could just be value question mark question mark missing.


00:21:28.540 --> 00:21:31.540
It's either going to be the value, but if value is none, then it's the other value missing.


00:21:31.540 --> 00:21:33.040
What do you think of that Brian?


00:21:33.040 --> 00:21:34.540
I'm still on the fence.


00:21:34.540 --> 00:21:38.540
Okay, this one to me actually doesn't offer a huge amount of value.


00:21:38.540 --> 00:21:39.540
It's okay.


00:21:39.540 --> 00:21:42.540
The next one to me is like pretty killer.


00:21:42.540 --> 00:21:45.540
More with the fluent style of calling functions chain together.


00:21:45.540 --> 00:21:51.540
So the null aware member access operator, it's the same basic PEP and the same basic


00:21:51.540 --> 00:21:53.540
but it's used in a different case.


00:21:53.540 --> 00:21:55.540
It lets you chain these fluent interfaces together


00:21:55.540 --> 00:21:57.540
without testing for none.


00:21:57.540 --> 00:21:59.540
Suppose I have a user, the user has orders,


00:21:59.540 --> 00:22:01.540
the orders you can call a first operation,


00:22:01.540 --> 00:22:04.540
but if there's no orders, then it returns none.


00:22:04.540 --> 00:22:06.540
But if it does return one, the order has a name.


00:22:06.540 --> 00:22:09.540
You would say, if user is none, return none.


00:22:09.540 --> 00:22:11.540
User.orders.first.


00:22:11.540 --> 00:22:14.540
If the first order is none, then we bail out.


00:22:14.540 --> 00:22:16.540
But if you make it through all those tests,


00:22:16.540 --> 00:22:19.540
you can get firstOrder.name.


00:22:19.540 --> 00:22:24.860
That's a lot of code to be spoken over the air, but you would now, with this new proposal,


00:22:24.860 --> 00:22:30.900
say user?orders?first?name, and it would mean exactly the same thing.


00:22:30.900 --> 00:22:35.600
If you look at those two lines of code on digital paper, the amount of space on one


00:22:35.600 --> 00:22:37.100
and the other is ridiculous, right?


00:22:37.100 --> 00:22:38.100
Yeah.


00:22:38.100 --> 00:22:39.100
Sorry, I didn't mean to cut you off.


00:22:39.100 --> 00:22:42.500
First reading of the non-aware operators, I was thinking it's just going to make the


00:22:42.500 --> 00:22:47.380
language more complicated to teach because when you're reading it, it isn't obvious what


00:22:47.380 --> 00:22:49.060
these things are doing.


00:22:49.060 --> 00:22:56.260
However, it does make the language smaller in that you can be more expressive in less code.


00:22:56.260 --> 00:22:57.860
And that's a good thing.


00:22:57.860 --> 00:23:05.700
I think it would make people more willing to effectively test for none when it could be none without cluttering the code.


00:23:05.700 --> 00:23:05.900
Right.


00:23:05.900 --> 00:23:09.580
Like these two examples I gave you, it's like eight lines versus one line.


00:23:09.580 --> 00:23:11.660
You're willing to just go, Oh, I just think it's there.


00:23:11.660 --> 00:23:12.340
And we'll just go through it.


00:23:12.340 --> 00:23:15.940
And then you'll get none type does not have attributes such and such.


00:23:15.940 --> 00:23:16.380
You're right.


00:23:16.380 --> 00:23:17.580
Whatever the attribute is, right.


00:23:17.580 --> 00:23:18.140
You get that error.


00:23:18.180 --> 00:23:20.180
all that it's one of the most common errors in Python.


00:23:20.180 --> 00:23:22.180
But if you just put the question marks in there,


00:23:22.180 --> 00:23:23.180
that totally goes away.


00:23:23.180 --> 00:23:26.180
That's the thing where if you don't think you need that problem,


00:23:26.180 --> 00:23:28.180
just think about how many times you see that.


00:23:28.180 --> 00:23:31.180
Like, you know, none. None does not have the index operator.


00:23:31.180 --> 00:23:33.180
Yes, exactly. Exactly.


00:23:33.180 --> 00:23:37.180
And this basically provides a much nicer way to deal with it.


00:23:37.180 --> 00:23:40.180
So my vote is for this feature,


00:23:40.180 --> 00:23:43.180
especially the null aware member access.


00:23:43.180 --> 00:23:45.180
But I would be okay if Python never had it.


00:23:45.180 --> 00:23:49.340
had it, but I do think the languages that do have it really make pretty good use of


00:23:49.340 --> 00:23:50.340
it.


00:23:50.340 --> 00:23:51.340
So it's in draft mode.


00:23:51.340 --> 00:23:53.860
People can give feedback before some sort of battle erupts over it.


00:23:53.860 --> 00:23:55.100
Yeah, I think it's good.


00:23:55.100 --> 00:23:56.100
Yeah, I do too.


00:23:56.100 --> 00:23:57.100
Cool.


00:23:57.100 --> 00:23:59.700
It'll let you have a second edition or third edition of your testing book, right?


00:23:59.700 --> 00:24:05.740
Because there's probably somewhere you got to put a question mark in there.


00:24:05.740 --> 00:24:07.140
You're just adding work for me.


00:24:07.140 --> 00:24:08.140
Thanks.


00:24:08.140 --> 00:24:09.140
Anyway, it's something for people to check out.


00:24:09.140 --> 00:24:10.140
Quite, quite good.


00:24:10.140 --> 00:24:12.060
I don't have anything extra to share with the folks.


00:24:12.060 --> 00:24:13.060
You, Brian?


00:24:13.060 --> 00:24:14.060
I've got a couple of things.


00:24:14.060 --> 00:24:17.420
I just noticed the other day that the Pi Cascades,


00:24:17.420 --> 00:24:19.940
that's going to be in February,


00:24:19.940 --> 00:24:23.020
February 23rd and 24th of 2019,


00:24:23.020 --> 00:24:24.700
and it's gonna be in Seattle this time.


00:24:24.700 --> 00:24:27.620
It's the call for proposals is now open.


00:24:27.620 --> 00:24:28.460
- Oh, that's sweet.


00:24:28.460 --> 00:24:29.300
- You got a long time too.


00:24:29.300 --> 00:24:33.100
You got it now through October 21st to get in your proposal.


00:24:33.100 --> 00:24:34.540
- Oh, I'm super excited about that.


00:24:34.540 --> 00:24:37.300
The opening, the inaugural Pi Cascades


00:24:37.300 --> 00:24:39.540
in Vancouver, BC last year was excellent.


00:24:39.540 --> 00:24:40.640
And I'm really glad I went.


00:24:40.640 --> 00:24:43.500
It was much smaller and it was a really intimate event.


00:24:43.500 --> 00:24:46.860
You got to meet a lot of the people who are there, and I'm looking forward to have it


00:24:46.860 --> 00:24:47.860
in Seattle.


00:24:47.860 --> 00:24:50.540
And it's coming to Portland next year, so that'll be even better.


00:24:50.540 --> 00:24:52.940
I'll try to go, and I'll also try to submit something.


00:24:52.940 --> 00:24:53.940
That'll be good.


00:24:53.940 --> 00:24:59.620
The other thing I wanted to highlight is I just wanted to brag because I got a Test and


00:24:59.620 --> 00:25:05.800
Code episode out a week or so ago that was with David Heinemeier Hansen, and it really


00:25:05.800 --> 00:25:07.540
went well.


00:25:07.540 --> 00:25:11.340
He's not a Python person, but it's interesting information.


00:25:11.340 --> 00:25:12.340
So that was fun.


00:25:12.340 --> 00:25:16.480
- So for people who don't know who David Hennemeyer Hanson is,


00:25:16.480 --> 00:25:17.700
what's his claim to fame?


00:25:17.700 --> 00:25:19.500
- Well, he's got lots, but he's the guy


00:25:19.500 --> 00:25:21.380
that made up Ruby on Rails,


00:25:21.380 --> 00:25:23.980
and he's one of the co-founders of Basecamp.


00:25:23.980 --> 00:25:27.120
- Yeah, just that, so that's pretty awesome.


00:25:27.120 --> 00:25:28.760
Yeah, it's really cool that he was on your show,


00:25:28.760 --> 00:25:31.620
and I'm looking forward to checking that out myself.


00:25:31.620 --> 00:25:34.900
- It's definitely applicable to Python people as well,


00:25:34.900 --> 00:25:37.300
because we talk about language agnostic things


00:25:37.300 --> 00:25:40.020
like just testing and stuff like that.


00:25:40.020 --> 00:25:41.780
- Very cool, well, thanks for the callout


00:25:41.780 --> 00:25:49.140
>> Sure, I'll call it PyCascades, but I also was trying to, I was catching up on your podcast,


00:25:49.140 --> 00:25:55.620
Talk Python, and it was, they had a couple episodes that were people that learned Python


00:25:55.620 --> 00:26:01.300
after the, didn't get degree, like CS degrees and learned Python later, programming later.


00:26:01.300 --> 00:26:05.300
And just the whole concept of that and listening to everybody's stories was very interesting.


00:26:05.300 --> 00:26:06.300
I liked those.


00:26:06.300 --> 00:26:07.300
>> Yeah, thank you.


00:26:07.300 --> 00:26:11.140
I did a two-part series on that, and that's, I think it really connected to a lot of people


00:26:11.140 --> 00:26:16.860
because so many people find their way into our world of programming in Python without


00:26:16.860 --> 00:26:20.380
going through the traditional CS degree path.


00:26:20.380 --> 00:26:24.500
And I think it's just an example a lot of people doing really great in alternate ways


00:26:24.500 --> 00:26:25.500
in.


00:26:25.500 --> 00:26:26.500
So yeah, very cool.


00:26:26.500 --> 00:26:27.500
Well, good talking to you.


00:26:27.500 --> 00:26:28.500
And we'll talk next week.


00:26:28.500 --> 00:26:29.500
Yep.


00:26:29.500 --> 00:26:30.500
You as well.


00:26:30.500 --> 00:26:31.500
Catch you later.


00:26:31.500 --> 00:26:32.500
Bye everyone.


00:26:32.500 --> 00:26:34.740
Thank you for listening to Python Bytes.


00:26:34.740 --> 00:26:37.500
Follow the show on Twitter via @PythonBytes.


00:26:37.500 --> 00:26:40.620
That's Python Bytes as in B-Y-T-E-S.


00:26:40.620 --> 00:26:43.940
get the full show notes at PythonBytes.fm.


00:26:43.940 --> 00:26:47.620
If you have a news item you want featured, just visit PythonBytes.fm and send it our


00:26:47.620 --> 00:26:48.620
way.


00:26:48.620 --> 00:26:51.140
We're always on the lookout for sharing something cool.


00:26:51.140 --> 00:26:54.580
On behalf of myself and Brian Okken, this is Michael Kennedy.


00:26:54.580 --> 00:26:57.620
Thank you for listening and sharing this podcast with your friends and colleagues.

