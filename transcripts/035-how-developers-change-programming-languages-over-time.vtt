WEBVTT

00:00:00.001 --> 00:00:05.800
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:05.800 --> 00:00:11.340
This is episode 35, recorded July 18th, 2017. I'm Michael Kennedy.

00:00:11.340 --> 00:00:12.540
And I'm Brian Okken.

00:00:12.540 --> 00:00:17.320
And we've got some really cool stuff to start out with. Do you have any comments maybe to kick us off, Brian?

00:00:17.320 --> 00:00:20.100
Well, I like to comment about just about everything.

00:00:20.100 --> 00:00:28.100
But to kick off, we've got an article from, I think it's Philip Troner, and it's called Python Quirks Comments.

00:00:28.100 --> 00:00:37.680
I kind of like this article. When you're looking at source code, there's definitely comments that start with pound that are obviously just comments to other coders.

00:00:37.680 --> 00:00:46.640
But then also sometimes, since we have doc strings in there, some people have learned that you can just put strings or other objects in your code.

00:00:46.640 --> 00:00:50.820
And as long as they're not referenced by anything else, it just acts like a comment.

00:00:51.040 --> 00:00:57.420
But this is an article taking a look at the abstract syntax tree and also taking a look at timing them.

00:00:57.420 --> 00:00:59.000
And obviously...

00:00:59.000 --> 00:01:03.580
Yeah. The fundamental question was, is there a reason to prefer one over the other?

00:01:03.580 --> 00:01:06.600
Is there a performance difference between them? Things like that, right?

00:01:06.600 --> 00:01:07.580
Yeah, definitely.

00:01:07.840 --> 00:01:17.040
And I have seen it even... I haven't seen it in a lot of big open source projects, but I've seen it in just random, like, Python code that I look at from coworkers or whatever.

00:01:17.040 --> 00:01:18.740
People will comment out...

00:01:18.740 --> 00:01:23.260
Even commenting out a chunk of code with the three quotes just to block it out.

00:01:23.260 --> 00:01:24.420
It's not good.

00:01:24.680 --> 00:01:29.540
It actually leaves that object in your code and can slow things down a bit.

00:01:29.540 --> 00:01:38.080
Yeah. So he did a bunch of testing and the hash or pound comments that actually get grayed out, like, those literally do not appear in the abstract syntax tree.

00:01:38.080 --> 00:01:41.260
So once the PYC file is generated, they're gone, right?

00:01:41.260 --> 00:01:44.620
Like, they literally don't appear in the resulted executed code.

00:01:44.620 --> 00:01:51.580
However, if you have, like, triple quote for doc strings, that actually gets set to the dunder doc property, I think.

00:01:52.100 --> 00:01:59.060
But those appear, if you have other ones, those just execute, they get allocated, and then they immediately get dereferenced and garbage collected.

00:01:59.060 --> 00:02:00.460
But those steps happen, right?

00:02:00.460 --> 00:02:00.820
Yeah.

00:02:00.820 --> 00:02:08.720
Yeah, one of the things that made me think about, because I've been adding, for the code examples for the book, I've been adding doc strings.

00:02:08.720 --> 00:02:11.300
And I'm curious.

00:02:11.300 --> 00:02:12.900
I'd like to do a similar test.

00:02:12.900 --> 00:02:17.300
I think I might take his code example and do a similar test on, like, size of doc strings.

00:02:17.520 --> 00:02:28.500
If you do, like, a, I don't know, a 10-character one-liner versus 100, 200 characters of a huge doc string, does it make a difference for performance at all?

00:02:28.500 --> 00:02:28.960
Yeah, yeah.

00:02:28.960 --> 00:02:29.460
Pretty interesting.

00:02:29.460 --> 00:02:34.780
I'm definitely a fan of the hash comment unless, you know, it's literally for doc strings.

00:02:34.920 --> 00:02:50.040
Yeah, and one of the things that, this is outside of the article, but I, in a comment recently, I can't remember where, a discussion about this was that doc strings are information for your user or for the user of a function or something.

00:02:50.040 --> 00:02:57.420
But the compound or hash comments are information for a future developer, and I like that.

00:02:57.420 --> 00:03:06.420
Yeah, that's the, imagine a psychopath who's having a bad day 10 years from now is inheriting your code, and they know where you live.

00:03:06.420 --> 00:03:08.640
You want to leave them some comments to help them feel happy.

00:03:08.640 --> 00:03:09.220
Yeah.

00:03:11.620 --> 00:03:17.020
All right, so, you know what I get if I open up my terminal, I type python3-V.

00:03:17.020 --> 00:03:18.060
I don't know, what do you get?

00:03:18.060 --> 00:03:22.520
I get 362, because python362 is out, I think today even.

00:03:22.520 --> 00:03:22.960
Awesome.

00:03:22.960 --> 00:03:24.300
Yeah, very, very cool.

00:03:24.300 --> 00:03:28.380
And I was blown away at how much stuff is in here.

00:03:28.380 --> 00:03:30.480
And I think these are mostly fixes.

00:03:30.480 --> 00:03:33.460
I didn't see, I don't think there were any new features.

00:03:33.460 --> 00:03:34.820
I think that's coming in 37.

00:03:35.620 --> 00:03:39.500
But holy moly, there are a lot of changes, and it's pretty interesting.

00:03:39.500 --> 00:03:45.380
So I pulled out a few just to highlight, and I'm highlighting for a variety of reasons.

00:03:45.380 --> 00:03:50.940
So I broke them in, well, they broke them in, too, and I grabbed them from four categories here.

00:03:50.940 --> 00:03:54.820
There's a few others that I decided not to touch on, like changes to idle, don't care.

00:03:54.820 --> 00:03:59.260
But security, that I very much care about.

00:03:59.260 --> 00:04:03.380
So the security ones, we have these changes, and they've got a bunch of numbers.

00:04:03.380 --> 00:04:09.460
You guys can look them up, but prevent environment variable injection into subprocesses on Windows.

00:04:09.460 --> 00:04:16.720
So prevent other things from freaking out or taking over what the system looks like for Python.

00:04:16.720 --> 00:04:19.200
Or this one is kind of scary.

00:04:19.200 --> 00:04:24.820
Upgrade expat copy from 220 to 221 gets fixed.

00:04:24.820 --> 00:04:29.980
You have multiple security vulnerabilities, and all these loops, integer overflow,

00:04:30.420 --> 00:04:35.660
regressions of other bugs, counter hash flooding, all these things that are like, you know,

00:04:35.660 --> 00:04:39.600
probably someone where in there, there's a really bad vulnerability.

00:04:39.600 --> 00:04:44.620
Also parsing the host, URL lib, and things like that.

00:04:44.620 --> 00:04:49.660
So there's a bunch of security fixes, not just, you know, features or whatever.

00:04:49.660 --> 00:04:52.220
So if you can, you should probably install this.

00:04:52.320 --> 00:05:02.800
Yeah, just definitely from my first glance at it this morning, it just seemed like it's just better for security and other changes to definitely install it.

00:05:02.800 --> 00:05:06.580
But I didn't see anything that jumped out of like, oh, I was waiting for this.

00:05:06.580 --> 00:05:08.320
Now I can use it or anything like that.

00:05:08.320 --> 00:05:09.060
Yeah, yeah, yeah.

00:05:09.060 --> 00:05:12.800
I don't think that I think this is only bug fixes and security fixes.

00:05:13.140 --> 00:05:15.320
No features until 3.7.

00:05:15.320 --> 00:05:15.700
Okay.

00:05:15.700 --> 00:05:17.420
And maybe you run a Mac, right?

00:05:17.420 --> 00:05:18.860
So maybe I'm just dense.

00:05:18.860 --> 00:05:22.400
But to upgrade, you just download the new one and install it.

00:05:22.400 --> 00:05:24.220
There isn't a way to just upgrade, is there?

00:05:24.220 --> 00:05:25.320
Well, you can use brew.

00:05:25.320 --> 00:05:28.220
I actually installed it off of python.org.

00:05:28.220 --> 00:05:31.600
So to upgrade that version, I think you got to keep rolling.

00:05:31.600 --> 00:05:33.040
You just get the next one and run it.

00:05:33.040 --> 00:05:33.520
That's fine.

00:05:34.020 --> 00:05:40.120
But if you brew install Python 3, then you can brew upgrade Python 3, which is kind of maybe what I'll do in my next Mac.

00:05:40.120 --> 00:05:40.820
Or I don't know.

00:05:40.820 --> 00:05:41.920
I'm happy with what I got now.

00:05:41.920 --> 00:05:43.860
But I'm going to try to use a homebrew more.

00:05:43.860 --> 00:05:44.580
I'm starting to love it.

00:05:44.580 --> 00:05:50.400
I actually, so if you do, if you have 361 and you install 362, you just have both of them there, right?

00:05:50.400 --> 00:05:52.400
Yes, I think so.

00:05:52.400 --> 00:05:55.040
But certainly if I type Python 3, now that's 362.

00:05:55.040 --> 00:05:55.520
Okay.

00:05:55.520 --> 00:05:59.220
Well, I like having both around anyway for testing multiple versions, but.

00:05:59.220 --> 00:05:59.940
Yeah, sure.

00:06:00.040 --> 00:06:04.380
And then there's some things, some tools like virtual environment wrapper, but slightly different.

00:06:04.380 --> 00:06:05.760
I'm forgetting the name right now.

00:06:05.760 --> 00:06:08.740
That'll let you like get all the versions and flip between them and whatnot.

00:06:08.740 --> 00:06:09.220
It's pretty cool.

00:06:09.220 --> 00:06:09.620
All right.

00:06:09.620 --> 00:06:09.900
All right.

00:06:09.900 --> 00:06:16.220
So some other ones, core and built-in stuff like the parsing of f-strings with backslashes apparently is broken.

00:06:16.220 --> 00:06:19.540
Segmentation faults when you are working with dictionaries.

00:06:19.540 --> 00:06:21.340
Those are never used in Python anywhere.

00:06:21.340 --> 00:06:28.480
When you're like changing them while searching, you know, if your Python just goes away, your web app keeps crashing, like all sorts of bad stuff.

00:06:28.480 --> 00:06:29.580
Control C.

00:06:29.580 --> 00:06:35.320
When you're inside of a yield from or a wait call gets fixed and all these different things.

00:06:35.320 --> 00:06:36.940
So tons of fixes there.

00:06:36.940 --> 00:06:44.120
The library gets race condition fixes for some signal delivery and wake up for file stuff.

00:06:44.120 --> 00:06:49.400
The lib two to three now understands f-strings, race conditions, windows.

00:06:49.400 --> 00:06:50.280
Oh my God.

00:06:50.280 --> 00:06:51.040
This one is awesome.

00:06:51.040 --> 00:06:55.800
If you work on windows or you teach people Python who work on windows, you can cheer for this.

00:06:55.800 --> 00:06:56.960
This is amazing.

00:06:57.660 --> 00:07:03.400
Windows now will locate msbuild.exe instead of vcvarsallbat.

00:07:03.400 --> 00:07:14.040
It is so much more reliable to find msbuild on windows than it is that stupid old vcvarsallbat thing for like all the C compilations.

00:07:14.040 --> 00:07:17.860
So that means pip install a thing on windows should get more reliable.

00:07:17.860 --> 00:07:21.560
So there's about 40 more of these types of fixes.

00:07:22.140 --> 00:07:24.780
So one, I wanted to share the news.

00:07:24.780 --> 00:07:25.640
How awesome is this?

00:07:25.640 --> 00:07:34.100
I also wanted to hit on some of those things, especially the security stuff, because we're coming up quickly on the end of legacy Python, right?

00:07:34.100 --> 00:07:34.600
Yes.

00:07:34.600 --> 00:07:34.900
Yeah.

00:07:34.900 --> 00:07:37.760
Legacy Python has to have some of these in there.

00:07:37.760 --> 00:07:40.620
Like people discovered these and now here are these problems that are uncovered.

00:07:41.380 --> 00:07:44.680
In 2020, these problems are going to stay in Python 2.

00:07:44.680 --> 00:07:50.540
So the sooner you can get to Python 3 so these changes keep coming to you rather than become just, oh, that's a security vulnerability.

00:07:50.540 --> 00:07:51.940
Sorry, you have to live with that.

00:07:51.940 --> 00:07:56.260
Just one more reason to upgrade to Python 3 for those holdouts out there.

00:07:56.260 --> 00:07:57.120
Yeah, definitely.

00:07:57.120 --> 00:08:05.580
And one of the things looking at this list, I just have to say, give a big thank you to everybody that worked on all this so that I don't have to work on things like this.

00:08:05.900 --> 00:08:06.600
Yes, thank you.

00:08:06.600 --> 00:08:07.000
That's awesome.

00:08:07.000 --> 00:08:07.820
It's all getting better.

00:08:07.820 --> 00:08:08.420
Yeah.

00:08:08.420 --> 00:08:08.880
Cool.

00:08:08.880 --> 00:08:09.300
All right.

00:08:09.300 --> 00:08:19.200
Speaking of contributing to open source projects, a lot of us feel like we're not good enough or maybe we don't know enough or our experience isn't rich enough or whatever, right?

00:08:19.200 --> 00:08:20.240
That's a huge problem.

00:08:20.240 --> 00:08:20.520
Yeah.

00:08:20.520 --> 00:08:23.260
I think everybody has gone through that.

00:08:23.260 --> 00:08:31.360
I mean, definitely everybody that's now contributing to open source has had an initial time where they felt like whether they knew enough about something.

00:08:31.360 --> 00:08:34.600
And so make sure I get her name right.

00:08:34.780 --> 00:08:41.560
Adrienne Lowe, who does coding with knives and has spoken at a couple of PyCons and other places.

00:08:41.560 --> 00:08:42.840
Yeah, she's great.

00:08:42.840 --> 00:08:46.000
She wrote a contributing to open source projects.

00:08:46.000 --> 00:08:50.320
Well, she wrote a thing on GitHub called Imposter Syndrome Disclaimer.

00:08:50.320 --> 00:08:55.340
Essentially, it's in places where you have how to contribute to your project.

00:08:55.560 --> 00:09:03.860
She'd like you to add this or think about adding this little disclaimer to people that maybe don't think that they're ready to do it.

00:09:04.300 --> 00:09:06.220
And it's kind of great wording.

00:09:06.220 --> 00:09:09.780
It has things including saying, I want your help.

00:09:09.780 --> 00:09:10.780
No, really, I do.

00:09:10.780 --> 00:09:12.700
There might be a little voice.

00:09:12.700 --> 00:09:14.160
I'm just quoting right out of this.

00:09:14.160 --> 00:09:24.200
There might be a little voice inside you that tells you that you're not ready, that you need to do one more tutorial or learn another framework or read a few more blog posts before you're ready.

00:09:24.580 --> 00:09:34.420
But I assure you that's not the case and goes on to, like, tell you to point to your contributing guidelines and then also to comment about other stuff.

00:09:34.420 --> 00:09:35.940
And here's another quote.

00:09:35.940 --> 00:09:37.380
And you don't just have to write code.

00:09:37.380 --> 00:09:42.360
You can help out by writing documentation tests or even giving feedback about this.

00:09:42.620 --> 00:09:48.260
And we talked about this in one of our previous episodes of many ways you can contribute to open source projects.

00:09:48.260 --> 00:09:54.140
But I think that this is a great idea to put it right in your contributing guidelines for your project.

00:09:54.140 --> 00:09:55.420
Yeah, really nice work, Adrian.

00:09:55.420 --> 00:09:59.540
If you guys were at PyCon, she was the host of the art museum dinner.

00:09:59.540 --> 00:10:01.040
And this is really great.

00:10:01.040 --> 00:10:04.020
She does a bunch for the community and contributes to many projects.

00:10:04.020 --> 00:10:07.020
So I know she's been on both sides of this.

00:10:07.020 --> 00:10:09.700
And I do think having this on your projects will help.

00:10:09.700 --> 00:10:11.100
She'd like to collect examples.

00:10:11.100 --> 00:10:12.000
So I've got a link.

00:10:12.160 --> 00:10:14.200
We've got a link in the show notes for where she's.

00:10:14.200 --> 00:10:19.180
And just or just get a hold of her and say you're taking this and contributing.

00:10:19.180 --> 00:10:20.920
So, yeah.

00:10:20.920 --> 00:10:21.780
Yeah, sounds good.

00:10:21.780 --> 00:10:23.760
Yeah, nicely done.

00:10:23.760 --> 00:10:26.240
And you just grab that and you can drop it into your project.

00:10:26.240 --> 00:10:28.280
It's just like a markdown file or something like that.

00:10:28.280 --> 00:10:28.560
Yeah.

00:10:28.560 --> 00:10:31.260
So, Michael, do you have any dark secrets that you want to share?

00:10:31.260 --> 00:10:34.740
I think we all have dark secrets and I don't really want to talk about it.

00:10:34.740 --> 00:10:36.700
But it's time to get it out in the open.

00:10:36.700 --> 00:10:41.700
And so the next thing I want to talk about is an article, a pretty deep article from MIT Technology

00:10:41.700 --> 00:10:45.080
Review called The Dark Secret at the Heart of AI.

00:10:45.080 --> 00:10:47.700
So we've touched on this a few times.

00:10:47.700 --> 00:10:49.620
It's kind of a nice follow-up from last week.

00:10:50.100 --> 00:10:51.660
There's a huge problem with AI.

00:10:51.660 --> 00:10:55.360
And we've had statistical models and we can look at the model.

00:10:55.360 --> 00:10:57.160
We can see things that it's predicting.

00:10:57.160 --> 00:11:02.520
But as we move farther and farther into things like deep learning, the machine doesn't know

00:11:02.520 --> 00:11:03.320
why it knows a thing.

00:11:03.320 --> 00:11:05.040
We don't know why it knows a thing.

00:11:05.040 --> 00:11:07.320
But we can teach it a thing and then it does that thing.

00:11:07.320 --> 00:11:07.500
Right?

00:11:08.080 --> 00:11:13.000
Even the creators of these deep learning models can't explain why it makes a decision.

00:11:13.000 --> 00:11:16.280
You can't like set a break point and step through and go, oh, this is the if case.

00:11:16.280 --> 00:11:17.220
Yes, of course, here.

00:11:17.220 --> 00:11:18.680
There's none of that.

00:11:18.680 --> 00:11:23.400
It's like I've taught it a bunch of stuff and now it somehow knows and then I ask it a question.

00:11:23.400 --> 00:11:26.620
So they gave a really interesting example to kick off this article.

00:11:26.620 --> 00:11:31.500
They said, last year, an experimental vehicle made by NVIDIA was just like any other automated

00:11:31.500 --> 00:11:34.380
car was released somewhere in New Jersey, I think it was.

00:11:34.380 --> 00:11:39.860
And they said, but it was unlike anything demonstrated by Google, Tesla, or GM.

00:11:39.860 --> 00:11:42.600
And it shows the rising power of AI.

00:11:42.600 --> 00:11:46.400
The car didn't follow instructions by being programmed or engineered.

00:11:46.400 --> 00:11:52.600
They basically taught this car how to drive by having it watch humans drive.

00:11:52.600 --> 00:11:54.740
and then they put it out on the road.

00:11:54.740 --> 00:11:55.440
Oh, wow.

00:11:55.440 --> 00:11:55.760
Yeah.

00:11:55.760 --> 00:11:59.360
And so it was really weird.

00:11:59.360 --> 00:12:02.260
Like the results seemed to do what human drivers did.

00:12:02.260 --> 00:12:07.980
But if it did something different, how do you understand or debug it or even change it to make

00:12:07.980 --> 00:12:09.140
those decisions differently?

00:12:09.140 --> 00:12:12.300
Like if it crashes into a tree, it sits at a light.

00:12:12.300 --> 00:12:17.380
Or there's always the hilarious joke that people seem to play on these cars is like draw like

00:12:17.380 --> 00:12:20.640
what looks like painted white lines in a circle around it.

00:12:20.640 --> 00:12:22.240
It can't get out.

00:12:22.540 --> 00:12:27.120
You know, like, but if it does an unexpected thing, how do you debug it or change it?

00:12:27.120 --> 00:12:32.780
That's really the secret is we, even the developers of AI and AI itself, they don't know how they

00:12:32.780 --> 00:12:33.000
work.

00:12:33.000 --> 00:12:33.360
Yeah.

00:12:33.360 --> 00:12:38.200
And there's also things that when I think about this stuff, I don't, I'm fairly optimistic

00:12:38.200 --> 00:12:42.720
about the self-driving cars and I'll be one of the first to grab one if I can afford one.

00:12:42.980 --> 00:12:58.360
But the, there's always the question of like, okay, so if, if a car comes up to say, decide whether or not to crash you and your family into a tree or take out a whole glob of school children, what does it do?

00:12:58.360 --> 00:12:58.620
Yeah.

00:12:59.060 --> 00:13:03.140
And yeah, I don't, that's the sort of moral questions.

00:13:03.140 --> 00:13:05.580
I don't know how to deal with how people are going to debug that.

00:13:05.580 --> 00:13:06.340
So for sure.

00:13:06.340 --> 00:13:10.520
And if you get the AI to do that, maybe like, how do you know it's always going to make the right choice?

00:13:10.520 --> 00:13:11.240
You don't.

00:13:11.300 --> 00:13:15.000
It's probably statistically better than humans, but still it's, it's an interesting question.

00:13:15.000 --> 00:13:19.740
So they basically say like, you know, how do you understand what the system does?

00:13:19.740 --> 00:13:21.700
Like, why does it make the decision that does it?

00:13:21.700 --> 00:13:22.880
You can't really ask it right now.

00:13:22.880 --> 00:13:26.560
It's difficult to design a system so that it could explain what it does.

00:13:26.560 --> 00:13:30.220
Like people don't, can't explain always why they do what they do precisely.

00:13:30.220 --> 00:13:32.940
And so it's interesting.

00:13:32.940 --> 00:13:39.820
One of the consequences that might be coming really soon, this is in the EU is there's an argument being made

00:13:39.820 --> 00:13:47.940
that you have to be able to get machines and AIs to tell you why it reached a conclusion as a fundamental legal right.

00:13:47.940 --> 00:13:48.720
Oh, wow.

00:13:48.720 --> 00:13:49.440
Okay.

00:13:49.440 --> 00:13:55.920
So if I'm told I have cancer and I go crazy and I burn all my life savings, oh, sorry, glitch in the whopper core.

00:13:55.920 --> 00:13:56.840
You're fine.

00:13:56.840 --> 00:13:59.980
You know, you want to, you know, want to know why.

00:13:59.980 --> 00:14:05.920
If I'm denied a loan, if I'm denied the ability to buy a house, if I'm denied a job, right?

00:14:05.920 --> 00:14:08.200
These are like serious, serious questions.

00:14:08.200 --> 00:14:12.120
So basically they kind of round out that it didn't go all the way.

00:14:12.120 --> 00:14:20.540
There's a lot to cover in this article, but last thing for us is he said, we've never before built machines that operate in ways their creators don't understand.

00:14:20.540 --> 00:14:27.260
How well can we expect to communicate and get along with intelligent machines that could be unpredictable and inscrutable?

00:14:27.260 --> 00:14:28.340
Crazy, huh?

00:14:28.340 --> 00:14:28.840
Yeah.

00:14:29.660 --> 00:14:30.700
Yeah, definitely.

00:14:30.700 --> 00:14:36.980
I'm optimistic with you as well, but it's just a very, it's interesting that philosophy and morality is starting to become part of programming.

00:14:36.980 --> 00:14:37.280
Yep.

00:14:37.280 --> 00:14:42.380
We definitely have machines now that I think of more that one person doesn't understand.

00:14:42.380 --> 00:14:46.140
But yeah, I think the biggest consequence for us is that we're going to have programs.

00:14:46.140 --> 00:14:48.200
We can't debug or understand why they do things.

00:14:48.200 --> 00:14:50.100
That's going to be a bizarre program in the future.

00:14:50.220 --> 00:14:53.380
Before we move on, did you say the Whopper Corps?

00:14:53.380 --> 00:14:55.020
I did say the Whopper Corps.

00:14:55.020 --> 00:14:57.140
Is there a computer based on a hamburger?

00:14:57.140 --> 00:14:58.180
No, no.

00:14:58.180 --> 00:15:00.740
That's from the war games.

00:15:00.740 --> 00:15:01.580
Oh, okay.

00:15:01.580 --> 00:15:08.320
Remember they had to hack into the Whopper Corps because that machine, they had to teach it to play tic-tac-toe against itself or something.

00:15:08.320 --> 00:15:09.240
Nice reference.

00:15:09.240 --> 00:15:10.160
Thank you.

00:15:10.160 --> 00:15:19.000
Yeah, I always think it's great that in that movie you can get from Colorado Springs to Bainbridge Island in a helicopter.

00:15:19.000 --> 00:15:22.000
Like on one take of gas.

00:15:22.000 --> 00:15:23.360
Not possible.

00:15:23.360 --> 00:15:24.420
Anyway.

00:15:24.420 --> 00:15:25.040
Awesome.

00:15:25.040 --> 00:15:26.080
All right.

00:15:26.080 --> 00:15:30.520
So let's proceed safely back to the three A's of testing patterns and away from this philosophy stuff.

00:15:30.520 --> 00:15:30.820
Yeah.

00:15:30.820 --> 00:15:33.300
So actually, I loved seeing this.

00:15:33.300 --> 00:15:34.840
So this is an article.

00:15:34.840 --> 00:15:36.040
I didn't write his name down.

00:15:36.040 --> 00:15:36.480
Sorry.

00:15:36.820 --> 00:15:40.400
Called Arrange Act Assert Patterns for Python Developers.

00:15:40.400 --> 00:15:49.580
And I am a, you know, I'm a big, and this is a, the Arrange Act Assert Pattern is a structure for how to set up test cases.

00:15:49.580 --> 00:15:58.920
And this is, you know, a fairly gentle, easy introduction, basically just telling people to not have big, long, spaghetti test code.

00:15:58.920 --> 00:16:01.680
Your test code should be something structured.

00:16:01.680 --> 00:16:03.080
And this is a decent structure.

00:16:03.260 --> 00:16:08.220
And the Arrange Part is get yourself ready to do whatever you're going to do is the setup part.

00:16:08.220 --> 00:16:11.120
Act is whatever thing you're testing.

00:16:11.120 --> 00:16:13.700
And the Asserts Part is where you check.

00:16:13.700 --> 00:16:21.880
So the important thing is don't go back and do a whole bunch of, try to do as many test cases as you can that all of the Asserts are at the end.

00:16:21.940 --> 00:16:24.900
And you don't do more actions and do more Asserts.

00:16:24.900 --> 00:16:26.320
I wrote a list.

00:16:26.320 --> 00:16:29.900
There's other names that people might know it by, like given, when, then.

00:16:29.900 --> 00:16:34.400
That's often attributed to behavior-driven development, but it's essentially the same pattern.

00:16:34.400 --> 00:16:40.060
And I did cover it in a couple places on pythontesting.net and also in testing code.

00:16:40.440 --> 00:16:44.480
Yeah, the links are both in the show notes there, yeah, for the episode and the article.

00:16:44.480 --> 00:16:57.080
But more, I'm pleased with more people, more people being like one so far, more other Python developers writing for targeting developers and teaching people how to, how they should set up their tests.

00:16:57.080 --> 00:16:58.080
So that's...

00:16:58.080 --> 00:16:59.620
Yeah, and it's such a simple pattern.

00:16:59.900 --> 00:17:06.060
But I find when I follow up my code, my tests are more focused and they're not less rambly.

00:17:06.060 --> 00:17:06.860
So I think it's good.

00:17:06.860 --> 00:17:15.540
Yeah, and also you have less chance of something going, like a test failing, you pretty much know what's wrong instead of a test failing.

00:17:15.540 --> 00:17:17.680
And it might be one of 15 different things.

00:17:17.680 --> 00:17:18.460
Yep, for sure.

00:17:18.460 --> 00:17:25.280
All right, so last thing I want to cover is to shine a bit of a bright light on the future of Python.

00:17:25.280 --> 00:17:29.780
So everyone out there listening, you are in a good place, let me tell you.

00:17:29.780 --> 00:17:33.780
In terms of being interested and working in Python right now.

00:17:33.780 --> 00:17:40.960
So there's another really deep article by this company called SourceD, Sourced, not entirely sure.

00:17:40.960 --> 00:17:44.200
But their mission, they're not super Python focused.

00:17:44.200 --> 00:17:45.820
I think they're doing mostly Go stuff.

00:17:45.820 --> 00:17:49.800
But their mission is to build the first AI that understands code.

00:17:49.800 --> 00:17:52.180
Speaking of AI, pretty interesting.

00:17:52.180 --> 00:17:55.100
So they wrote this really long blog post.

00:17:55.100 --> 00:17:57.600
There's a decent amount of data science and math in there.

00:17:57.600 --> 00:18:02.340
And it's called Analyzing GitHub, How Developers Change Programming Languages Over Time.

00:18:02.340 --> 00:18:11.120
So we've talked before, Brian, how Python is the number one most active language on GitHub, right?

00:18:11.120 --> 00:18:14.140
For active, non-trivial projects, things like that.

00:18:14.140 --> 00:18:18.520
And I think JavaScript was number one because everybody has JavaScript in their web apps, right?

00:18:18.520 --> 00:18:18.720
Yeah.

00:18:18.800 --> 00:18:22.160
So this is a different question, but kind of similar.

00:18:22.160 --> 00:18:26.040
Not what is just most popular, but how is it changing over time?

00:18:26.040 --> 00:18:27.840
Where are those trends going to?

00:18:27.840 --> 00:18:30.420
If people are changing languages, where do they change from?

00:18:30.420 --> 00:18:36.100
And so they have these cool Gantt charts that they've studied 4.5 million GitHub users,

00:18:36.100 --> 00:18:39.520
over 393 different languages, and 10 terabytes of code.

00:18:39.620 --> 00:18:43.760
And they said, given one of those 4.5 million users, how do we visualize them?

00:18:43.760 --> 00:18:44.640
How do we think about them?

00:18:44.640 --> 00:18:49.620
And they've got a Gantt chart of like, as they transition from one language to another over time.

00:18:49.620 --> 00:18:55.440
And this is based on an original article by Eric Bernhardsen.

00:18:55.440 --> 00:18:56.800
He's at Google.

00:18:56.800 --> 00:18:59.220
And the name of his article is pretty interesting as well.

00:18:59.220 --> 00:19:03.040
The Eigen Vector of Why We Move from Language X to Language Y.

00:19:03.860 --> 00:19:04.460
All right.

00:19:04.460 --> 00:19:06.500
So this takes us-

00:19:06.500 --> 00:19:07.600
I love me a good Eigen Vector.

00:19:07.600 --> 00:19:09.680
I do love me a good Eigen Vector as well.

00:19:09.680 --> 00:19:10.500
It tells you where you're going.

00:19:10.500 --> 00:19:16.600
So this is a slightly different approach, more of a data science, less of a statistical approach,

00:19:16.600 --> 00:19:16.980
I believe.

00:19:16.980 --> 00:19:20.900
And they said, look, first of all, we're going to not include JavaScript because JavaScript

00:19:20.900 --> 00:19:24.220
is like spread amongst all these projects, right?

00:19:24.220 --> 00:19:26.560
Hey, my Pyramid project has JavaScript.

00:19:26.560 --> 00:19:28.620
That Ruby on Rails project, it's got JavaScript.

00:19:28.620 --> 00:19:29.640
Everything is JavaScript.

00:19:29.640 --> 00:19:34.740
So it's super hard to make reasonable claims about JavaScript because it's such a complementary

00:19:34.740 --> 00:19:35.220
language.

00:19:35.220 --> 00:19:38.000
So they said, like, we can't reason about this, so put it to the side.

00:19:38.000 --> 00:19:39.460
Take that for what it's worth.

00:19:39.460 --> 00:19:44.960
And they said, we're going to look at the most popular languages on GitHub.

00:19:44.960 --> 00:19:46.340
And they do a whole bunch of work.

00:19:46.340 --> 00:19:50.540
And they come up with this stationary distribution of a Markov chain.

00:19:50.540 --> 00:19:51.180
How about that?

00:19:51.720 --> 00:19:59.020
And what they find out is the number one most stable language at GitHub is Python.

00:19:59.020 --> 00:20:06.540
And interestingly, its stability level is higher by almost 50% than the amount of code as a

00:20:06.540 --> 00:20:07.880
percentage of it on GitHub.

00:20:07.880 --> 00:20:09.620
So it's really, really stable.

00:20:09.620 --> 00:20:11.320
And then behind that...

00:20:11.320 --> 00:20:12.340
So what do you mean by stable?

00:20:12.340 --> 00:20:16.040
People, once they get to Python, are least likely to move away from Python.

00:20:16.040 --> 00:20:16.480
Okay.

00:20:16.480 --> 00:20:16.780
Yeah.

00:20:17.680 --> 00:20:18.660
I believe that's right.

00:20:18.660 --> 00:20:19.240
Interpretation.

00:20:19.240 --> 00:20:21.500
Then there's Java, which is also very stable.

00:20:21.500 --> 00:20:25.300
There's C, then C++, then PHP, then Ruby, then C#.

00:20:25.300 --> 00:20:26.400
And then it goes on and on and on.

00:20:26.400 --> 00:20:29.020
So they make some claims based on this.

00:20:29.020 --> 00:20:34.420
They say, Python, at 16.1%, appears to be the most attractive language followed closely

00:20:34.420 --> 00:20:35.040
by Java.

00:20:35.040 --> 00:20:40.440
It's especially interesting since 11.3% of all code on GitHub is written in Python.

00:20:40.440 --> 00:20:43.940
So it's more attractive than its level of code would imply.

00:20:43.940 --> 00:20:47.060
They said, there are some languages that are repulsive.

00:20:47.060 --> 00:20:49.180
That's my wording, not theirs.

00:20:49.180 --> 00:20:54.680
But they said, although there are 10 times more lines of code on GitHub and PHP rather than Ruby,

00:20:54.680 --> 00:20:57.940
they have the same level of stationary attractiveness.

00:20:57.940 --> 00:21:01.220
So much less reason to be attracted to Ruby.

00:21:01.220 --> 00:21:03.060
But if you're there, you're more likely to stick.

00:21:03.060 --> 00:21:05.320
And so they said, what about sticking to a language?

00:21:05.580 --> 00:21:10.820
Developers coding in one of the five most popular languages, Java, C, C++, PHP, and Ruby,

00:21:10.820 --> 00:21:15.420
are most likely to switch to Python with a 22% chance on average.

00:21:15.420 --> 00:21:16.100
How about that?

00:21:16.100 --> 00:21:16.380
Yeah.

00:21:16.380 --> 00:21:19.300
So people who like Python are most likely to stay there.

00:21:19.300 --> 00:21:22.740
And people who are one of the five most popular languages are most likely to move there as well.

00:21:22.740 --> 00:21:27.380
I think it also didn't, I don't know, I haven't read this article, but I think it also goes to

00:21:27.380 --> 00:21:32.620
the fact how easy it is to think of something that you could solve that you could share with

00:21:32.620 --> 00:21:35.060
somebody else on a project with Python.

00:21:35.060 --> 00:21:41.680
For instance, I've programmed C++ all my career, but I've never contributed any C++ code to GitHub.

00:21:41.680 --> 00:21:42.820
Yeah, that's for sure.

00:21:42.820 --> 00:21:45.000
It's definitely a more open source friendly language as well.

00:21:45.000 --> 00:21:46.740
A few more random stats.

00:21:46.740 --> 00:21:53.300
They say visual basic developers are very likely to move to C# with a 92% chance of that.

00:21:53.300 --> 00:21:58.960
And people using numerical and statistical environments such as Fortran, MATLAB, or R are most likely

00:21:58.960 --> 00:22:06.500
to switch to Python using this measure of analysis, whereas Eric, the base blog, the original blog,

00:22:06.500 --> 00:22:08.320
was suggesting they might move to C.

00:22:08.320 --> 00:22:14.360
So pretty interesting little article there about stability and attractiveness of projects.

00:22:14.360 --> 00:22:20.960
That correlates with other, I guess, anecdotal things that we've heard of more people migrating,

00:22:20.960 --> 00:22:23.020
especially in data science, to Python.

00:22:23.020 --> 00:22:27.280
Yeah, it seems totally believable to me, given all the other pieces of information and studies

00:22:27.280 --> 00:22:28.820
we've seen and talked about.

00:22:28.820 --> 00:22:29.120
Yeah.

00:22:29.120 --> 00:22:29.720
Nice.

00:22:29.720 --> 00:22:30.080
Nice.

00:22:30.080 --> 00:22:34.260
So I think I would say, you know, if you're thinking about where do I bet my career, that's

00:22:34.260 --> 00:22:37.760
another positive sign that Python's probably a good spot to hang on to for a while.

00:22:37.760 --> 00:22:38.660
Long while.

00:22:38.660 --> 00:22:39.640
All right.

00:22:39.700 --> 00:22:40.740
Well, that's the news.

00:22:40.740 --> 00:22:42.260
Anything else going on, Brian?

00:22:42.260 --> 00:22:46.140
I wasn't there, but EuroPython got wrapped up last week.

00:22:46.140 --> 00:22:50.940
But I did have some stickers, some rocket stickers, Hits a Ride.

00:22:50.940 --> 00:22:51.560
Nice.

00:22:51.560 --> 00:22:54.520
They blasted all the way over to, what was that, Spain?

00:22:54.520 --> 00:22:56.400
Yeah, Italy, I think.

00:22:56.400 --> 00:22:56.840
Oh, Italy.

00:22:56.840 --> 00:22:57.540
Yeah, yeah, that's right.

00:22:57.540 --> 00:23:00.840
And had a bunch of stickers handed out to promote the book.

00:23:00.840 --> 00:23:02.300
So that's fun.

00:23:02.300 --> 00:23:06.620
So I got one more week to finish it, and then it'll be done.

00:23:06.620 --> 00:23:08.460
You must be looking forward to that.

00:23:08.460 --> 00:23:08.900
Yeah.

00:23:09.460 --> 00:23:10.380
So how about you?

00:23:10.380 --> 00:23:10.980
What's going on?

00:23:10.980 --> 00:23:11.240
Awesome.

00:23:11.240 --> 00:23:12.360
Not too much.

00:23:12.360 --> 00:23:13.360
I'm really enjoying summer.

00:23:13.360 --> 00:23:18.520
I'm actually working on some apps, some very interesting apps from my training courses.

00:23:18.520 --> 00:23:21.180
Not that I'm going to teach, but to like deliver stuff.

00:23:21.180 --> 00:23:23.460
So more to come on that right now.

00:23:23.460 --> 00:23:23.960
I'm just writing.

00:23:23.960 --> 00:23:24.480
Okay.

00:23:24.480 --> 00:23:25.320
See how it comes out in the end.

00:23:25.320 --> 00:23:25.520
Yeah.

00:23:25.520 --> 00:23:26.200
Very fun.

00:23:26.200 --> 00:23:31.980
Hey, one of the things that you brushed by fairly, I know you talked about it a lot somewhere

00:23:31.980 --> 00:23:35.620
else, maybe, but you were Python for entrepreneurs course.

00:23:35.620 --> 00:23:37.200
It's freaking awesome.

00:23:37.200 --> 00:23:38.220
Thank you, man.

00:23:38.220 --> 00:23:38.940
Thank you very much.

00:23:39.220 --> 00:23:40.640
I think more people should check it out.

00:23:40.640 --> 00:23:42.440
And I don't think it's just for entrepreneurs.

00:23:42.440 --> 00:23:48.620
I think it's a good top to bottom Python for web plus front end and back end.

00:23:48.620 --> 00:23:51.100
It's a nice thing for people to look at.

00:23:51.100 --> 00:23:52.000
Thank you so much.

00:23:52.000 --> 00:23:52.180
Yeah.

00:23:52.180 --> 00:23:54.600
And it's officially, officially done as of last week.

00:23:54.600 --> 00:23:56.600
So it's finally ready for the world.

00:23:56.600 --> 00:23:58.280
Thanks a bunch for the shout out.

00:23:58.280 --> 00:23:58.560
Yeah.

00:23:58.560 --> 00:24:00.980
And Matt McKay helped you with that, I believe.

00:24:00.980 --> 00:24:01.420
Yep.

00:24:01.420 --> 00:24:02.800
Matt McKay from Full Stack Python.

00:24:03.000 --> 00:24:04.120
We are happy to be done.

00:24:04.120 --> 00:24:06.660
And we're planning our next thing that we're going to do.

00:24:06.660 --> 00:24:07.100
Yeah.

00:24:07.100 --> 00:24:08.680
You guys did a good job on that.

00:24:08.680 --> 00:24:09.440
So cool.

00:24:09.440 --> 00:24:10.100
Thanks a bunch.

00:24:10.100 --> 00:24:12.420
And yeah, it's super good to see your book coming out as well.

00:24:12.420 --> 00:24:13.580
It's very fun, isn't it?

00:24:13.580 --> 00:24:13.980
Yeah.

00:24:13.980 --> 00:24:14.320
Awesome.

00:24:14.320 --> 00:24:14.660
All right.

00:24:14.660 --> 00:24:15.500
Catch up next week.

00:24:15.500 --> 00:24:15.880
You bet.

00:24:15.880 --> 00:24:16.580
Catch you next week.

00:24:16.680 --> 00:24:17.500
Thanks for being here, Brian.

00:24:17.500 --> 00:24:18.520
Thanks everyone for listening.

00:24:18.520 --> 00:24:21.540
Thank you for listening to Python Bytes.

00:24:21.540 --> 00:24:24.100
Follow the show on Twitter via at Python Bytes.

00:24:24.100 --> 00:24:27.000
That's Python Bytes as in B-Y-T-E-S.

00:24:27.000 --> 00:24:30.400
And get the full show notes at pythonbytes.fm.

00:24:30.400 --> 00:24:34.760
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:24:34.760 --> 00:24:37.460
We're always on the lookout for sharing something cool.

00:24:37.460 --> 00:24:40.840
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:24:40.840 --> 00:24:44.480
Thank you for listening and sharing this podcast with your friends and colleagues.

