
00:00:00.000 --> 00:00:05.360
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.


00:00:05.360 --> 00:00:11.600
This is episode 259, recorded November 17, 2021. And I'm Brian Okken.


00:00:11.600 --> 00:00:12.720
I'm Michael Kennedy.


00:00:12.720 --> 00:00:13.920
And I'm Renee Teat.


00:00:13.920 --> 00:00:18.000
Well, thanks, Renee, for joining us today. Can you tell us a little bit about who you are?


00:00:18.000 --> 00:00:22.800
I'm the Director of Data Science at Helio Campus. And a lot of people know me as


00:00:22.800 --> 00:00:29.200
Data Science Renee or becoming Data Sci on Twitter. So that's where a lot of people follow


00:00:29.200 --> 00:00:32.460
and then I started with, I had a podcast


00:00:32.460 --> 00:00:33.780
that's not actively recording,


00:00:33.780 --> 00:00:36.160
but it's called Becoming a Data Scientist Podcast.


00:00:36.160 --> 00:00:40.280
So some people listening probably know me from that as well.


00:00:40.280 --> 00:00:41.120
- Cool.


00:00:41.120 --> 00:00:41.940
- Yeah, awesome.


00:00:41.940 --> 00:00:42.780
You were doing a bunch of cool stuff there.


00:00:42.780 --> 00:00:45.780
And any chances of maybe going back to podcasting?


00:00:45.780 --> 00:00:47.180
- It's definitely still open.


00:00:47.180 --> 00:00:49.780
I've never, I've always told myself this is a pause,


00:00:49.780 --> 00:00:51.780
not a stop, it's just an extended pause.


00:00:51.780 --> 00:00:53.420
So yes, hopefully I will get back to it.


00:00:53.420 --> 00:00:54.900
- It's hard to keep going, isn't it?


00:00:54.900 --> 00:00:58.580
I mean, life gets in the way and then you get busy and.


00:00:58.580 --> 00:01:00.040
- I'm always so impressed with those of you


00:01:00.040 --> 00:01:03.240
that have hundreds of episodes very consistently recorded.


00:01:03.240 --> 00:01:05.420
- Brian makes me show up every week.


00:01:05.420 --> 00:01:07.760
- Well, yeah, it definitely helps having a partner


00:01:07.760 --> 00:01:09.880
so that you can coerce each other in.


00:01:09.880 --> 00:01:11.020
- That's right.


00:01:11.020 --> 00:01:13.300
- Well, Michael, speaking of partners,


00:01:13.300 --> 00:01:15.020
wanna tell us about something?


00:01:15.020 --> 00:01:18.040
- Let's talk about some changes, some Pi PI changes.


00:01:18.040 --> 00:01:20.300
These come to us from Brian Skin.


00:01:20.300 --> 00:01:22.540
Thank you, Brian, for shooting this over.


00:01:22.540 --> 00:01:26.240
And it's a project by Bernay Gabor here.


00:01:26.240 --> 00:01:28.020
And if we pull this up, it says,


00:01:28.020 --> 00:01:31.300
Have you ever wondered when did your Python packages,


00:01:31.300 --> 00:01:33.500
the packages in your environment that you have active


00:01:33.500 --> 00:01:36.500
or any given environment, how old are they?


00:01:36.500 --> 00:01:38.260
When were they last updated?


00:01:38.260 --> 00:01:40.420
Is there a version of them that's out of date?


00:01:40.420 --> 00:01:44.260
So I've been solving this by just forcing them to update


00:01:44.260 --> 00:01:47.540
using pip compile and the pip tools stuff


00:01:47.540 --> 00:01:51.860
to just regenerate and reinstall the requirements files.


00:01:51.860 --> 00:01:54.860
But this is a way to just ask the question,


00:01:54.860 --> 00:01:55.860
hey, what's the status?


00:01:55.860 --> 00:02:00.660
And it wouldn't be an episode if we didn't somehow feature Will McGugan.


00:02:00.660 --> 00:02:04.260
So this is based on Rich, of course.


00:02:04.260 --> 00:02:06.020
So let's go check this thing out.


00:02:06.020 --> 00:02:11.860
So over here, if we go to the home page, we get, as all projects should, a nice animation here.


00:02:11.860 --> 00:02:18.900
And if you look at it, you can see type "ipi-changes" and you specify the path to a Python in a virtual environment.


00:02:18.900 --> 00:02:23.540
So in this example, it's like "ipi-changes vnv/bin/python".


00:02:23.540 --> 00:02:25.620
It does some thinking on the internet,


00:02:25.620 --> 00:02:27.660
caches some information about the packages,


00:02:27.660 --> 00:02:30.460
and it says, all right, you've got all these things installed,


00:02:30.460 --> 00:02:32.620
they're this version, some of them it'll just say,


00:02:32.620 --> 00:02:35.900
this was updated 10 months ago, or a year and three days ago.


00:02:35.900 --> 00:02:38.060
Others it'll say it was updated a year ago,


00:02:38.060 --> 00:02:41.220
but only six months on the latest version.


00:02:41.220 --> 00:02:42.540
It says remote such and such,


00:02:42.540 --> 00:02:44.620
that's the one you could install if you were to update it.


00:02:44.620 --> 00:02:45.940
So it's a real nice way to see,


00:02:45.940 --> 00:02:49.500
well, which ones are here that could be updated,


00:02:49.500 --> 00:02:52.260
or even also sometimes it's interesting to know like,


00:02:52.260 --> 00:02:55.000
"Oh, this library, it doesn't have an update,


00:02:55.000 --> 00:02:56.160
"but it's 10 years old.


00:02:56.160 --> 00:02:58.240
"Maybe I should consider switching to a library


00:02:58.240 --> 00:03:01.460
"that's a little more maintained and making progress."


00:03:01.460 --> 00:03:02.300
Right?


00:03:02.300 --> 00:03:03.120
What do you all think?


00:03:03.120 --> 00:03:03.960
- That's handy.


00:03:03.960 --> 00:03:04.800
- Yeah, cool, right?


00:03:04.800 --> 00:03:05.640
- It is pretty neat.


00:03:05.640 --> 00:03:07.400
- So yeah, I've been playing around with this today,


00:03:07.400 --> 00:03:08.560
installed it, checked it out,


00:03:08.560 --> 00:03:11.200
even pointed out that, you know, since yesterday,


00:03:11.200 --> 00:03:13.000
some things changed in one of my projects


00:03:13.000 --> 00:03:14.080
that I wanna keep up to date.


00:03:14.080 --> 00:03:15.320
So I updated it.


00:03:15.320 --> 00:03:16.240
Yeah, so I like it.


00:03:16.240 --> 00:03:18.680
It's got a nice command line interface.


00:03:18.680 --> 00:03:23.540
you basically specify the Python that is in the environment


00:03:23.540 --> 00:03:24.380
that you want to check.


00:03:24.380 --> 00:03:25.780
That could either be the main Python


00:03:25.780 --> 00:03:29.000
or a virtual environment Python.


00:03:29.000 --> 00:03:30.820
Like I said, you can control the caching


00:03:30.820 --> 00:03:31.900
'cause the first time it runs,


00:03:31.900 --> 00:03:33.380
it has to go get lots of information


00:03:33.380 --> 00:03:35.180
about each package that's installed


00:03:35.180 --> 00:03:36.700
and it's faster the second time.


00:03:36.700 --> 00:03:38.460
It also has some cool parallelism.


00:03:38.460 --> 00:03:41.880
So you can say number of jobs, like --jobs,


00:03:41.880 --> 00:03:45.580
and by default it runs 10 downloads in parallel


00:03:45.580 --> 00:03:46.900
as it's pulling this information in,


00:03:46.900 --> 00:03:48.940
but I guess you could go crazy there.


00:03:48.940 --> 00:03:50.780
So anyway, I thought this was pretty cool.


00:03:50.780 --> 00:03:52.560
It's a nice little thing to have.


00:03:52.560 --> 00:03:54.740
So I pipx installed this.


00:03:54.740 --> 00:03:56.140
It's perfect for pipx


00:03:56.140 --> 00:04:00.020
because it doesn't need to be in the project it's testing.


00:04:00.020 --> 00:04:02.260
It just needs to be on your machine as a command.


00:04:02.260 --> 00:04:04.280
And then you point it at the environment,


00:04:04.280 --> 00:04:05.120
different environments,


00:04:05.120 --> 00:04:07.060
and it gives you reports on those environments.


00:04:07.060 --> 00:04:08.980
- Yeah, I love pipx too.


00:04:08.980 --> 00:04:10.780
One of the things I wanna note,


00:04:10.780 --> 00:04:13.740
just as I know a lot of package maintainers,


00:04:13.740 --> 00:04:16.020
having, I mean, it's worth checking things out


00:04:16.020 --> 00:04:18.460
if it's a really old packet,


00:04:18.460 --> 00:04:20.260
if it hasn't been updated for a long time.


00:04:20.260 --> 00:04:21.860
But some things are pure Python things


00:04:21.860 --> 00:04:23.560
that just do a little tiny thing


00:04:23.560 --> 00:04:25.460
and don't need updated very often.


00:04:25.460 --> 00:04:29.120
So it's not necessarily a bad thing that it's not updated,


00:04:29.120 --> 00:04:32.320
but it's an indicator of something.


00:04:32.320 --> 00:04:34.040
Yes, exactly.


00:04:34.040 --> 00:04:36.420
Let's see out in the live audience,


00:04:36.420 --> 00:04:37.860
Anthony Lister, hey, says,


00:04:37.860 --> 00:04:39.900
"Can the changes be exported to a text file?"


00:04:39.900 --> 00:04:41.260
I haven't seen anything about that


00:04:41.260 --> 00:04:43.900
other than just piping it into a text file


00:04:43.900 --> 00:04:46.900
and who knows what happens with all the color in there,


00:04:46.900 --> 00:04:48.460
but perhaps.


00:04:48.460 --> 00:04:51.060
Yeah, Renee, what do you do to manage your dependencies


00:04:51.060 --> 00:04:53.220
and all those kinds of things?


00:04:53.220 --> 00:04:55.540
- Well, at work we started using Docker for that.


00:04:55.540 --> 00:04:58.660
So we have a centralized Docker container


00:04:58.660 --> 00:05:00.100
that everyone on my team uses


00:05:00.100 --> 00:05:02.500
and we make sure we have the same setup in there.


00:05:02.500 --> 00:05:05.400
So I'm not the one that directly manages it,


00:05:05.400 --> 00:05:08.300
but that's the solution that we've gone towards


00:05:08.300 --> 00:05:10.380
to make sure we're all on the same page.


00:05:10.380 --> 00:05:11.220
- Oh, interesting.


00:05:11.220 --> 00:05:12.220
So you've got the Docker environment


00:05:12.220 --> 00:05:14.020
that has some version of Python set up


00:05:14.020 --> 00:05:16.160
with all the libraries you need pre-installed,


00:05:16.160 --> 00:05:17.940
and then you just use that to run


00:05:17.940 --> 00:05:19.740
and that way you know it's the same.


00:05:19.740 --> 00:05:20.860
- Yep, and then it's also nice


00:05:20.860 --> 00:05:23.860
because when we kind of move some of our projects


00:05:23.860 --> 00:05:26.300
into production, we can include that Docker container


00:05:26.300 --> 00:05:28.540
with it, so it will have whatever version it had


00:05:28.540 --> 00:05:30.740
at the time, so if for some reason it's not compatible


00:05:30.740 --> 00:05:33.020
with some later version we upgraded to,


00:05:33.020 --> 00:05:35.580
it still lives out there with the version of the tools


00:05:35.580 --> 00:05:38.220
that it had until we have a chance to update everything.


00:05:38.220 --> 00:05:40.620
- One of the challenges that people have sometimes


00:05:40.620 --> 00:05:43.620
as they say, even though you've got some kind of version management,


00:05:43.620 --> 00:05:46.620
iProject.toml or requirements.txt or whatever,


00:05:46.620 --> 00:05:50.020
that doesn't necessarily mean that people actually install them,


00:05:50.020 --> 00:05:52.220
the latest, so you could still be out of sync, right?


00:05:52.220 --> 00:05:55.020
So having the image that's constantly the same,


00:05:55.020 --> 00:05:57.420
constantly in sync, that's kind of a way to force it.


00:05:57.420 --> 00:06:00.620
I also want to give a quick shout out to this project,


00:06:00.620 --> 00:06:03.620
pip-deptry, remember Brian, we spoke about that before?


00:06:03.620 --> 00:06:04.020
Yeah.


00:06:04.020 --> 00:06:04.820
Which is pretty cool.


00:06:04.820 --> 00:06:07.420
And what it'll show you is, this will show you


00:06:07.420 --> 00:06:10.020
the things you've directly installed


00:06:10.020 --> 00:06:12.520
versus the things that happen to be installed.


00:06:12.520 --> 00:06:15.160
So if we go back to this like animation here,


00:06:15.160 --> 00:06:17.060
you can see that it's got flask,


00:06:17.060 --> 00:06:18.920
which is 2.0.2,


00:06:18.920 --> 00:06:21.480
but then it's got markup safe,


00:06:21.480 --> 00:06:22.720
it's got it's dangerous,


00:06:22.720 --> 00:06:24.560
like nobody installed it's dangerous.


00:06:24.560 --> 00:06:27.020
That's a thing that was installed because of flask.


00:06:27.020 --> 00:06:29.680
And so for example, when I look at my environments,


00:06:29.680 --> 00:06:31.260
there were some things that were out of date,


00:06:31.260 --> 00:06:32.880
but they were out of date because they were


00:06:32.880 --> 00:06:34.860
pinned requirements of


00:06:34.860 --> 00:06:36.960
other things that I actually wanted to install.


00:06:36.960 --> 00:06:38.880
So for example, example,


00:06:38.880 --> 00:06:41.780
DocOpt and some other things are pinned to lower versions.


00:06:41.780 --> 00:06:45.240
And I can't really update those, but they'll show up as outdated.


00:06:45.240 --> 00:06:50.000
So you might pair this with some pip dept tree to see like, what ones are you in


00:06:50.000 --> 00:06:51.780
control of and what ones are just kind of out there.


00:06:51.780 --> 00:06:52.720
That's pretty cool.


00:06:52.720 --> 00:06:53.640
That's that one.


00:06:53.640 --> 00:06:54.760
Well, you got it for us.


00:06:54.760 --> 00:06:58.500
Well, this is a interesting, there's a discussion about a


00:06:58.500 --> 00:07:00.940
possible change to future Python.


00:07:00.940 --> 00:07:04.580
Um, again, this is just stuff that people are discussing.


00:07:04.580 --> 00:07:08.560
It's nothing that's even decided on, but, it's a, it's an


00:07:08.560 --> 00:07:16.240
idea of late bound arguments for Python for late bound arguments for deep deep, I don't know,


00:07:16.240 --> 00:07:22.640
late bound argument defaults, that's it, for, for functions. So here's the idea. So you've got,


00:07:22.640 --> 00:07:30.080
so we know that if you, if you assign the default, default value for a function argument,


00:07:30.960 --> 00:07:33.920
that is bound at definition time.


00:07:33.920 --> 00:07:36.240
So when Python first goes and reads it,


00:07:36.240 --> 00:07:38.800
that seems fine.


00:07:38.800 --> 00:07:42.020
It's a weird thing about the namespace there though.


00:07:42.020 --> 00:07:46.840
So what happens is if you have a variable foo,


00:07:46.840 --> 00:07:50.680
for instance, or a value foo,


00:07:50.680 --> 00:07:53.080
the value expression can be,


00:07:53.080 --> 00:07:56.300
you can look that up in the defining area.


00:07:56.300 --> 00:07:58.600
So the namespace where the function is defined.


00:07:58.600 --> 00:08:02.200
It's a little specific, but it causes some weirdness.


00:08:02.200 --> 00:08:04.560
It's not the namespace of the function,


00:08:04.560 --> 00:08:07.760
it's the namespace of the surrounding the function.


00:08:07.760 --> 00:08:10.660
The problem with that really is that, like for instance,


00:08:10.660 --> 00:08:13.440
if we wanted to do something like a bisect function


00:08:13.440 --> 00:08:18.440
that took, you know, has a, you give it an array


00:08:18.440 --> 00:08:21.520
and maybe an X value for the middle or something,


00:08:21.520 --> 00:08:23.080
we also have a high and low.


00:08:23.080 --> 00:08:26.180
We know the low is index would be zero as a default,


00:08:26.180 --> 00:08:29.680
But what the high should be is should be the length of the array.


00:08:29.680 --> 00:08:34.020
And it's, you can't do that because you can't reference the array


00:08:34.020 --> 00:08:35.620
as a default value.


00:08:35.620 --> 00:08:39.820
So that's what this, kind of what this discussion is about,


00:08:39.820 --> 00:08:44.320
is trying to figure out a way to possibly have an optional late binding


00:08:44.320 --> 00:08:46.020
of those values.


00:08:46.020 --> 00:08:49.280
And in this specific case, it'd be very helpful


00:08:49.280 --> 00:08:51.180
to be able to late bind that value,


00:08:51.180 --> 00:08:53.620
like at the time that the function is called,


00:08:53.620 --> 00:08:55.420
not at the time that it's defined.


00:08:55.960 --> 00:09:02.360
And this was you want to take the first parameter and use it to set the default value of the subsequent parameter.


00:09:02.360 --> 00:09:07.560
Yeah, like to say like the length of the array is the default for length or something.


00:09:07.560 --> 00:09:14.960
And that's the that was was it Chris Angelico that suggested this.


00:09:14.960 --> 00:09:21.360
And the discussion actually got has some some people even even Guido said, I'm not really opposed to it.


00:09:21.360 --> 00:09:22.960
Let's let's explore it a little bit.


00:09:22.960 --> 00:09:26.960
So there is some, Chris is trying to do a proof of concept.


00:09:26.960 --> 00:09:31.120
There is some question about what the syntax should be.


00:09:31.120 --> 00:09:35.320
So Chris suggested a equal colon,


00:09:35.320 --> 00:09:38.220
so like the reverse of the walrus operator,


00:09:38.220 --> 00:09:41.100
because apparently that's available.


00:09:41.100 --> 00:09:46.280
Another suggestion was equal greater than to look like an arrow,


00:09:46.280 --> 00:09:49.760
but we already have dash arrow to mean something else.


00:09:49.760 --> 00:09:52.380
So up in the air on the syntax,


00:09:52.380 --> 00:10:01.020
But anyway, one of the things I wanted to comment about is the in the article we're linking to,


00:10:01.020 --> 00:10:08.540
it says at first blush, Angelico's idea to fix this wart in Python seems fairly straightforward,


00:10:08.540 --> 00:10:11.980
but the discussion has shown that there are multiple facets to consider.


00:10:11.980 --> 00:10:12.460
>> Oh, yeah.


00:10:12.460 --> 00:10:19.820
>> And it's always tricky to add complexity or to the language. So, you know, the people in


00:10:19.820 --> 00:10:22.460
the steering council will take it, think about it, right?


00:10:22.460 --> 00:10:24.220
- Under consideration. - Yes.


00:10:24.220 --> 00:10:26.220
- Okay. Renee, what do you think about this?


00:10:26.220 --> 00:10:31.740
- I'm going to be honest, it's going over my head a little bit. I don't consider myself like a real


00:10:31.740 --> 00:10:36.300
software developer. So I usually use Python for, you know, standard data science type of scripts.


00:10:36.300 --> 00:10:41.500
I'm trying to sit here thinking of a use case for this that I would use and not coming up with one.


00:10:41.500 --> 00:10:46.540
- Yeah, I'm with you on that one as well. It's not, doesn't mean it's a bad idea necessarily.


00:10:46.540 --> 00:10:48.700
- Well, one use case. - Yeah, go ahead, Brian.


00:10:48.700 --> 00:10:53.700
- One use case would be to be able to set an empty list


00:10:53.700 --> 00:10:55.340
as a default value.


00:10:55.340 --> 00:10:59.440
You can't do that now because the list is bound.


00:10:59.440 --> 00:11:01.700
All calls to the function will get


00:11:01.700 --> 00:11:04.040
whatever the last function set it to.


00:11:04.040 --> 00:11:05.660
And that's a weirdness in Python,


00:11:05.660 --> 00:11:07.460
but we could probably fix that with this.


00:11:07.460 --> 00:11:09.500
- Yeah, yeah, that's what I was thinking as well,


00:11:09.500 --> 00:11:13.400
is if you pass immutable value as the default,


00:11:13.400 --> 00:11:15.180
then you're asking for trouble, right?


00:11:15.180 --> 00:11:17.020
Because if it gets changed anywhere,


00:11:17.020 --> 00:11:20.220
then every subsequent call gets those changes applied to it.


00:11:20.220 --> 00:11:21.500
So that seems useful.


00:11:21.500 --> 00:11:25.060
This, like sort of flowing one parameter into the next.


00:11:25.060 --> 00:11:28.200
Um, I'm not sure it's worth the complexity.


00:11:28.200 --> 00:11:32.700
So Renee, what I wanted to ask you was as somebody who doesn't dive deep


00:11:32.700 --> 00:11:37.340
into the like low levels of the language and like compiler parsing, all that


00:11:37.340 --> 00:11:38.660
kind of stuff, which is totally fine.


00:11:38.660 --> 00:11:40.580
That's like 99% of the people.


00:11:40.580 --> 00:11:44.100
How do you feel about these kinds of new features coming along?


00:11:44.100 --> 00:11:46.780
Are you like, oh, geez, now I got to learn the walrus operator.


00:11:46.780 --> 00:11:48.500
I had to learn pattern matching.


00:11:48.500 --> 00:11:50.540
I was fine, and now I've got to deal with this code.


00:11:50.540 --> 00:11:50.980
What is this?


00:11:50.980 --> 00:11:53.420
Or do you see it as like, oh, awesome, here's new stuff?


00:11:53.420 --> 00:11:57.260
- Yeah, I mean, I guess it depends how much it really impacts my day-to-day work.


00:11:57.260 --> 00:12:00.660
If it's something that it's not impacting something I use frequently,


00:12:00.660 --> 00:12:06.180
or it's kind of abstracted away from me or optional, then, you know, go ahead.


00:12:06.180 --> 00:12:09.900
But if it's something that some, you know, some features they roll out clearly have


00:12:09.900 --> 00:12:13.060
a wide-ranging impact and you have to go update everything.


00:12:13.060 --> 00:12:17.460
So I'm not great at keeping up with that, which is one reason that, you know, of course,


00:12:17.460 --> 00:12:20.420
you have to be so careful when you update to a new version.


00:12:20.420 --> 00:12:24.260
But, you know, I guess that's why people listen to podcasts like this.


00:12:24.260 --> 00:12:25.900
So you know, it's potentially coming.


00:12:25.900 --> 00:12:26.820
So you're aware.


00:12:26.820 --> 00:12:27.340
I guess so.


00:12:27.340 --> 00:12:29.900
When it does come out, you're on top of it.


00:12:29.900 --> 00:12:32.380
But I don't have strong opinions.


00:12:32.380 --> 00:12:35.580
And what we worry about a lot in data science is the packages, right?


00:12:35.580 --> 00:12:40.380
So not the base Python, but the packages are constantly changing and the dependencies and the versions.


00:12:40.380 --> 00:12:43.380
So that does end up affecting us


00:12:43.380 --> 00:12:45.540
when it follows through to that level.


00:12:45.540 --> 00:12:49.340
- Yeah, my concern is around teaching Python


00:12:49.340 --> 00:12:52.780
because every new syntax thing you put in


00:12:52.780 --> 00:12:54.900
makes it something that you potentially


00:12:54.900 --> 00:12:56.140
have to teach somebody.


00:12:56.140 --> 00:12:59.420
And maybe you don't have to teach newbies this,


00:12:59.420 --> 00:13:01.820
but they'll see it in code.


00:13:01.820 --> 00:13:04.940
So they should be able to understand what it is.


00:13:04.940 --> 00:13:06.060
But on the other hand,


00:13:06.060 --> 00:13:10.280
like things like you can do really crazy comprehensions.


00:13:10.280 --> 00:13:13.000
list comprehensions and stuff, but you don't have to.


00:13:13.000 --> 00:13:14.960
And most of the ones I see are fairly simple ones.


00:13:14.960 --> 00:13:17.680
So I don't think we should nix a phone.


00:13:17.680 --> 00:13:19.200
Nick shouldn't nix something just


00:13:19.200 --> 00:13:21.160
because it can be complicated.


00:13:21.160 --> 00:13:22.080
Anyway.


00:13:22.080 --> 00:13:22.920
- Yeah. - Cool.


00:13:22.920 --> 00:13:23.920
- Indeed. - Yeah, good one.


00:13:23.920 --> 00:13:25.240
- All right, Renee, you got the next one.


00:13:25.240 --> 00:13:28.480
- All right, so speaking of data science packages,


00:13:28.480 --> 00:13:30.800
a lot of us use pandas.


00:13:30.800 --> 00:13:32.800
So I wrote a book, which I'll come back to later


00:13:32.800 --> 00:13:34.840
called "SQL for Data Scientists."


00:13:34.840 --> 00:13:37.500
And since I wrote that, and you know,


00:13:37.500 --> 00:13:39.840
some people that have been learning data science in school


00:13:39.840 --> 00:13:43.500
or on the job haven't always used SQL,


00:13:43.500 --> 00:13:45.340
or if they use it as kind of a separate process


00:13:45.340 --> 00:13:46.180
from their Python.


00:13:46.180 --> 00:13:47.220
So they started asking me,


00:13:47.220 --> 00:13:49.900
how do you SQL alongside Python?


00:13:49.900 --> 00:13:52.060
So this is kind of beginner level,


00:13:52.060 --> 00:13:54.600
but also something that's just very useful.


00:13:54.600 --> 00:13:58.920
In the pandas package, there's a read SQL function.


00:13:58.920 --> 00:14:01.500
And so you can read a SQL query.


00:14:01.500 --> 00:14:02.460
It runs the query.


00:14:02.460 --> 00:14:04.780
It's kind of a wrapper around some other functions.


00:14:04.780 --> 00:14:07.580
It will run the query and return the dataset


00:14:07.580 --> 00:14:09.600
into your data frame.


00:14:09.600 --> 00:14:12.080
And so basically you're just running a query


00:14:12.080 --> 00:14:14.840
and the results become the data frame right in your notebook.


00:14:14.840 --> 00:14:17.880
So let's see some of my notes on here.


00:14:17.880 --> 00:14:21.240
So you can save your SQL as a text file.


00:14:21.240 --> 00:14:24.000
So you don't have to have the string in your actual notebook,


00:14:24.000 --> 00:14:25.460
which is sometimes useful.


00:14:25.460 --> 00:14:29.160
And then when you import it in from that pandas data frame,


00:14:29.160 --> 00:14:31.500
that's where a lot of people do their data cleaning


00:14:31.500 --> 00:14:33.360
and feature engineering and everything like that.


00:14:33.360 --> 00:14:35.600
So you could just pull in the raw data from SQL


00:14:35.600 --> 00:14:38.280
and do a lot of the data engineering there.


00:14:38.280 --> 00:14:40.660
Sometimes I do feature engineering in SQL


00:14:40.660 --> 00:14:41.500
and then pull it in.


00:14:41.500 --> 00:14:43.720
So that's kind of up to each user,


00:14:43.720 --> 00:14:46.620
but you really just set up the connection in your database


00:14:46.620 --> 00:14:48.380
using a package like SQL alchemy.


00:14:48.380 --> 00:14:50.960
So you have a connection to the database


00:14:50.960 --> 00:14:53.100
and you pass your SQL string,


00:14:53.100 --> 00:14:55.060
either directly or from the file


00:14:55.060 --> 00:14:57.060
and the database connection


00:14:57.060 --> 00:14:59.140
and it returns a pandas data frame.


00:14:59.140 --> 00:15:01.500
So I'm happy to talk a little bit more about,


00:15:01.500 --> 00:15:03.340
you know, how I use this at work.


00:15:03.340 --> 00:15:04.780
- Yeah, I think this is really good.


00:15:04.780 --> 00:15:07.760
You know, one of the things to do with pandas


00:15:07.760 --> 00:15:11.160
is there's just so many of these little functions


00:15:11.160 --> 00:15:13.040
that solve whole problems.


00:15:13.040 --> 00:15:14.920
You know, it's like, oh, you could go


00:15:14.920 --> 00:15:18.200
and use requests to download some HTML,


00:15:18.200 --> 00:15:20.800
and then you could use beautiful soup to do some selectors,


00:15:20.800 --> 00:15:23.480
and you could get some stuff and parse out some HTML,


00:15:23.480 --> 00:15:25.520
and then you could get some table information out


00:15:25.520 --> 00:15:27.600
and then convert that into a data frame.


00:15:27.600 --> 00:15:30.880
Or you could just say, read HTML table,


00:15:30.880 --> 00:15:32.960
bracket zero or whatever, and boom, you have it.


00:15:32.960 --> 00:15:35.560
Like, knowing about these, I think, is really interesting.


00:15:35.560 --> 00:15:37.160
So it's cool that you highlighted this one.


00:15:37.160 --> 00:15:41.040
I actually just, on a side, I'm just literally like in an hour.


00:15:41.040 --> 00:15:43.760
So probably before this show ships, we'll ship.


00:15:43.760 --> 00:15:47.760
This episode I did with Vex, which you have about 25


00:15:47.760 --> 00:15:49.760
Panda functions you didn't even know existed.


00:15:49.760 --> 00:15:52.320
And what's interesting is like this one wasn't even on the list.


00:15:52.320 --> 00:15:53.920
- Mm-hmm.


00:15:53.920 --> 00:15:57.160
So good. So I'll highlight another one now you know exists.


00:15:57.160 --> 00:15:58.600
- That's pretty cool.


00:15:58.600 --> 00:16:00.920
- Let's see a couple of comments from the audience.


00:16:00.920 --> 00:16:03.400
Sam Morley, hey Sam, says, "Pandas is so amazing.


00:16:03.400 --> 00:16:06.680
I always find something too late that it has all of these


00:16:06.680 --> 00:16:11.160
I/O functions and then we have Paul, Anzal, hey Paul,


00:16:11.160 --> 00:16:14.120
says, "Do you have any recommendations on tutorials


00:16:14.120 --> 00:16:17.340
"for how to create good SQL Alchemy selectables?


00:16:17.340 --> 00:16:19.280
"This always feels like the scariest bit."


00:16:19.280 --> 00:16:21.280
- I don't have any of that on hand.


00:16:21.280 --> 00:16:23.040
I'll try to find something later


00:16:23.040 --> 00:16:25.280
or I'll ask my Twitter following and see what they recommend.


00:16:25.280 --> 00:16:27.840
I don't have a good list of tutorials for that one.


00:16:27.840 --> 00:16:31.040
I can talk about, yeah, by selectable,


00:16:31.040 --> 00:16:32.880
he said he means connectable.


00:16:32.880 --> 00:16:36.000
So yeah, I don't have a tutorial for that.


00:16:36.000 --> 00:16:38.780
There's a lot of documentation and I know that SQL alchemy


00:16:38.780 --> 00:16:40.940
can be a little mysterious sometimes.


00:16:40.940 --> 00:16:42.440
Maybe that's why it's alchemy.


00:16:42.440 --> 00:16:47.320
But yeah, I will try to share that later on Twitter.


00:16:47.320 --> 00:16:48.480
- Yeah, fantastic.


00:16:48.480 --> 00:16:49.820
All right, and Paul says,


00:16:49.820 --> 00:16:51.940
a read clipboard is pretty great.


00:16:51.940 --> 00:16:52.780
- Yeah.


00:16:52.780 --> 00:16:53.760
- Yeah, very cool.


00:16:53.760 --> 00:16:55.060
Bunch of different things there.


00:16:55.060 --> 00:16:56.820
- Yeah, so if you want me to walk through an example


00:16:56.820 --> 00:16:58.780
of how I use this at work, I'm happy to do that.


00:16:58.780 --> 00:17:00.440
- Yeah, give us a quick sample.


00:17:00.440 --> 00:17:02.540
- Yeah, so at Helio Campus,


00:17:02.540 --> 00:17:05.740
one thing we do is we connect to a lot of different databases


00:17:05.740 --> 00:17:06.740
at universities.


00:17:06.740 --> 00:17:09.140
So the universities will have separate databases


00:17:09.140 --> 00:17:12.620
for admissions, enrollment, financial aid.


00:17:12.620 --> 00:17:14.100
Those are all separate systems.


00:17:14.100 --> 00:17:16.820
And so we pull all that data into a data warehouse


00:17:16.820 --> 00:17:19.300
and in SQL, we can combine that data,


00:17:19.300 --> 00:17:22.460
build some extracts that we're all using the same way.


00:17:22.460 --> 00:17:24.900
And so we can either use this to just read


00:17:24.900 --> 00:17:26.940
one of those tables directly,


00:17:26.940 --> 00:17:29.020
or we can combine, what I typically do


00:17:29.020 --> 00:17:32.260
is do a little bit of cleanup and feature engineering


00:17:32.260 --> 00:17:34.340
and narrow down my dataset to the population


00:17:34.340 --> 00:17:37.140
that I want to run through my model in SQL,


00:17:37.140 --> 00:17:38.760
and then just pull those final results.


00:17:38.760 --> 00:17:40.320
And now I've got my data set


00:17:40.320 --> 00:17:42.140
with at least preliminary features.


00:17:42.140 --> 00:17:43.740
I might do some standardization


00:17:43.740 --> 00:17:45.200
and things like that in pandas,


00:17:45.200 --> 00:17:48.500
but I've got a pretty clean and subset


00:17:48.500 --> 00:17:52.340
of the data that I need right into my Jupyter notebook.


00:17:52.340 --> 00:17:53.500
- Oh, that's fantastic.


00:17:53.500 --> 00:17:54.340
- Pretty great.


00:17:54.340 --> 00:17:56.740
- Yeah, I think definitely understanding SQL


00:17:56.740 --> 00:17:59.340
is an important skill for data scientists.


00:17:59.340 --> 00:18:02.500
And it's slightly different than for say,


00:18:02.500 --> 00:18:04.540
like a web API developer, right?


00:18:04.540 --> 00:18:06.540
- Absolutely, that's why I wrote the book.


00:18:06.540 --> 00:18:08.060
- That's awesome, yeah, for sure.


00:18:08.060 --> 00:18:10.780
So on the API side, you kind of get something set up,


00:18:10.780 --> 00:18:13.580
you're very likely using an ORM like SQLAlchemy


00:18:13.580 --> 00:18:15.220
and you just connect it and go.


00:18:15.220 --> 00:18:17.540
And once you get it set, like you can kind of forget about it


00:18:17.540 --> 00:18:18.760
and just program against it.


00:18:18.760 --> 00:18:20.640
As a data scientist, you're exploring,


00:18:20.640 --> 00:18:21.760
you don't totally know, right?


00:18:21.760 --> 00:18:24.580
You're kind of out there testing and digging into stuff


00:18:24.580 --> 00:18:26.140
and sorting and filtering.


00:18:26.140 --> 00:18:28.020
And yeah, I think you need,


00:18:28.020 --> 00:18:30.460
I would say you probably need a better fluency


00:18:30.460 --> 00:18:32.460
with SQL as a data scientist


00:18:32.460 --> 00:18:34.060
a lot of times than as a web developer.


00:18:34.060 --> 00:18:35.780
'Cause I can just use an ORM or ODM


00:18:35.780 --> 00:18:37.980
and just kind of know what it's doing.


00:18:37.980 --> 00:18:40.320
- Yeah, and it enables you to build your own data sets


00:18:40.320 --> 00:18:42.120
instead of relying on a data engineering


00:18:42.120 --> 00:18:44.300
trying to explain what you need and why


00:18:44.300 --> 00:18:45.260
and which fields you need.


00:18:45.260 --> 00:18:46.500
Now you can just do it yourself


00:18:46.500 --> 00:18:49.100
or add a field if you need it.


00:18:49.100 --> 00:18:51.700
You can do more sophisticated things like window functions.


00:18:51.700 --> 00:18:55.260
So yeah, I think knowing SQL is really a value add


00:18:55.260 --> 00:18:57.440
if you're looking to become a data scientist


00:18:57.440 --> 00:18:59.860
and putting yourself out there on the market.


00:18:59.860 --> 00:19:02.380
if you can do the whole pipeline end to end,


00:19:02.380 --> 00:19:03.940
it definitely makes you stand out.


00:19:03.940 --> 00:19:04.900
- I would think so.


00:19:04.900 --> 00:19:06.780
All right, one thing to wrap up on this.


00:19:06.780 --> 00:19:09.180
Sam asks, "Can you configure SQLAlchemy


00:19:09.180 --> 00:19:11.240
to dump the raw queries that it runs?"


00:19:11.240 --> 00:19:12.080
Yes.


00:19:12.080 --> 00:19:13.440
- Yeah, in this case,


00:19:13.440 --> 00:19:16.060
you have the raw query in your function call.


00:19:16.060 --> 00:19:19.540
So I'm not actually using SQLAlchemy for that


00:19:19.540 --> 00:19:20.380
'cause I'm providing the query.


00:19:20.380 --> 00:19:21.380
- Yeah, you just got like a select statement, right?


00:19:21.380 --> 00:19:23.800
The problem with SQLAlchemy and data science


00:19:23.800 --> 00:19:26.500
is you have just the structure of your models


00:19:26.500 --> 00:19:28.720
has to exactly match the structure of the data.


00:19:28.720 --> 00:19:31.240
And often I imagine you're just kind of dealing


00:19:31.240 --> 00:19:32.880
with the loose data and it doesn't make sense


00:19:32.880 --> 00:19:35.440
to take the time to like model it in classes.


00:19:35.440 --> 00:19:37.760
But for SQLAlchemy, you can just set echo equal true


00:19:37.760 --> 00:19:38.660
when you create the engine.


00:19:38.660 --> 00:19:40.240
And then everything that would get sent


00:19:40.240 --> 00:19:42.360
to the crossover to the database gets echoed


00:19:42.360 --> 00:19:46.320
as like DDL or SQL or whatever that it does.


00:19:46.320 --> 00:19:47.160
So yes.


00:19:47.160 --> 00:19:48.200
- Good impact. - Cool, for sure.


00:19:48.200 --> 00:19:49.040
- Yeah.


00:19:49.040 --> 00:19:52.100
All right, Brian, wanna tell us about our sponsor?


00:19:52.100 --> 00:19:52.940
- Yeah, let's.


00:19:52.940 --> 00:19:56.780
I am pleased and happy to that Shortcut


00:19:56.780 --> 00:19:58.240
is sponsoring the episode.


00:19:58.240 --> 00:20:01.000
So thank you, Shortcut, formerly Clubhouse,


00:20:01.000 --> 00:20:02.280
for sponsoring the episode.


00:20:02.280 --> 00:20:04.240
There are a lot of project management tools out there,


00:20:04.240 --> 00:20:06.840
but most suffer from common problems,


00:20:06.840 --> 00:20:10.000
like it's too simple for an engineering team to use


00:20:10.000 --> 00:20:13.000
on several projects, or it's too complex


00:20:13.000 --> 00:20:16.520
and it's hard to get started, and there's tons of options.


00:20:16.520 --> 00:20:18.560
And some of them are great for managers,


00:20:18.560 --> 00:20:20.720
but bad for engineers, and some are great for engineers


00:20:20.720 --> 00:20:21.880
and bad for managers.


00:20:21.880 --> 00:20:23.240
Shortcut is different.


00:20:23.240 --> 00:20:25.600
It's built for software teams


00:20:25.600 --> 00:20:28.460
based on making workflows super easy.


00:20:28.460 --> 00:20:30.720
For example, keyboard-friendly user interface,


00:20:30.720 --> 00:20:34.080
the UI is intuitive for mouse lovers, of course,


00:20:34.080 --> 00:20:36.760
but the activities that you use every day


00:20:36.760 --> 00:20:40.200
can be set to keyboard shortcuts if they aren't already.


00:20:40.200 --> 00:20:43.720
Just learn them and you'll start working faster.


00:20:43.720 --> 00:20:44.840
It's awesome.


00:20:44.840 --> 00:20:47.400
Tight VCS integration, so you can update tasks,


00:20:47.400 --> 00:20:50.320
progress, and commits with a commit or a PR.


00:20:50.320 --> 00:20:51.160
That's sweet.


00:20:51.160 --> 00:20:53.600
And iteration planning is a breeze.


00:20:53.600 --> 00:20:57.360
I like that there's a burndown and cycle time charts built in.


00:20:57.360 --> 00:21:00.560
They just are set up already for you when you start using this.


00:21:00.560 --> 00:21:02.640
So it's a pretty clean system.


00:21:02.640 --> 00:21:05.960
Give it a try at shortcut.com/pythonbytes.


00:21:05.960 --> 00:21:08.800
>> Absolutely. Thanks, Shortcut, for sponsoring this episode.


00:21:08.800 --> 00:21:11.160
Now, what have we got next here?


00:21:11.160 --> 00:21:12.960
Pigeon. I want to talk about Pigeon.


00:21:12.960 --> 00:21:18.000
So we already talked about Will McGugan and Rich.


00:21:18.000 --> 00:21:20.240
So it's time to talk about Anthony Shaw so that we can


00:21:20.240 --> 00:21:23.020
and complete our shout outs we always seem to give


00:21:23.020 --> 00:21:24.440
over on the podcast.


00:21:24.440 --> 00:21:26.260
So I wanna talk about Pidgin


00:21:26.260 --> 00:21:28.460
because I just interviewed Anthony Chabot.


00:21:28.460 --> 00:21:32.260
More importantly, he just released Pidgin as 1.0.


00:21:32.260 --> 00:21:36.900
So Pidgin is a drop-in JIT compiler for Python 3.10.


00:21:36.900 --> 00:21:40.360
Let me say that again, a JIT compiler for Python.


00:21:40.360 --> 00:21:43.500
And there've been other speed up type of attempts


00:21:43.500 --> 00:21:46.020
where people will like fork CPython


00:21:46.020 --> 00:21:49.260
and they'll do something inside of it to make it different.


00:21:49.260 --> 00:21:53.520
Think Cinder, there have been attempts to create a totally different but compatible one,


00:21:53.520 --> 00:21:57.520
like PyPy, P-Y-P-Y.


00:21:57.520 --> 00:22:02.360
And that's, they've worked pretty well, but they always have some sort of incompatibility or something.


00:22:02.360 --> 00:22:08.160
It would be nice if just the Python you ran could be compiled to go faster if you want it to be.


00:22:08.160 --> 00:22:09.320
So that's what this is.


00:22:09.320 --> 00:22:15.880
It uses a pep, whose number I forgot, that allows you to plug in something that inspects the method frames


00:22:15.880 --> 00:22:17.600
before they get executed.


00:22:17.600 --> 00:22:21.860
And then instead of just interpreting that code,


00:22:21.860 --> 00:22:24.040
the bytecode as Python bytecode,


00:22:24.040 --> 00:22:27.040
it'll actually compile it to machine instructions


00:22:27.040 --> 00:22:30.200
first to .NET intermediate instructions,


00:22:30.200 --> 00:22:31.040
intermediate language,


00:22:31.040 --> 00:22:33.360
and then those get compiled to machine instructions


00:22:33.360 --> 00:22:35.340
that then run directly.


00:22:35.340 --> 00:22:40.340
Works on Linux, Mac OS, Windows, x64, and ARM64.


00:22:40.340 --> 00:22:43.040
So this is a pretty cool development.


00:22:43.040 --> 00:22:44.060
- It is pretty cool.


00:22:44.060 --> 00:22:47.580
- Yeah, so if we go over here and check it out,


00:22:47.580 --> 00:22:49.980
in order to use it, it has some requirements.


00:22:49.980 --> 00:22:51.980
You just pip install Pigeon, that's it.


00:22:51.980 --> 00:22:52.900
That's crazy, right?


00:22:52.900 --> 00:22:55.420
And then it has to be on 3.10, it can't be older than that.


00:22:55.420 --> 00:22:58.380
And you have to have .NET 6 installed.


00:22:58.380 --> 00:23:00.140
Okay, so that just got released.


00:23:00.140 --> 00:23:02.740
It's a good chance you don't have .NET 6 installed.


00:23:02.740 --> 00:23:04.420
But then once you set it up right,


00:23:04.420 --> 00:23:05.700
you can just say import Pigeon,


00:23:05.700 --> 00:23:08.060
pigeon.enable at the startup of your app,


00:23:08.060 --> 00:23:10.100
and then it will look at all the methods


00:23:10.100 --> 00:23:11.660
and JIT compile them.


00:23:11.660 --> 00:23:15.660
So if you come down here, he has an example of a half function


00:23:15.660 --> 00:23:17.020
that Anthony put up here.


00:23:17.020 --> 00:23:20.160
And when it first loads, it's not JIT compiled.


00:23:20.160 --> 00:23:22.580
But after that, you can go and say--


00:23:22.580 --> 00:23:24.700
if you run it, you can say disassemble this thing.


00:23:24.700 --> 00:23:28.460
And it'll show you basically assembly instructions


00:23:28.460 --> 00:23:31.380
of what would have otherwise been Python code.


00:23:31.380 --> 00:23:31.940
Wow.


00:23:31.940 --> 00:23:32.820
It's wild, right?


00:23:32.820 --> 00:23:34.940
So it's a little bit like Numba.


00:23:34.940 --> 00:23:36.540
It's a little bit like--


00:23:36.540 --> 00:23:38.820
a tiny bit like Cython in the sense


00:23:38.820 --> 00:23:40.900
that it takes Python code, translates it


00:23:40.900 --> 00:23:43.540
into something else that then can be interoperated with


00:23:43.540 --> 00:23:45.400
and then makes it go fast.


00:23:45.400 --> 00:23:46.500
So this is all well and good.


00:23:46.500 --> 00:23:48.380
If you're gonna use it on the web,


00:23:48.380 --> 00:23:49.860
by default it would be just fine,


00:23:49.860 --> 00:23:52.140
except if you're hosting it,


00:23:52.140 --> 00:23:56.040
normally you host it in this like supervisor process


00:23:56.040 --> 00:23:57.820
and then a bunch of forked off processes.


00:23:57.820 --> 00:24:01.100
So there's a WSGI app configuration thing


00:24:01.100 --> 00:24:02.960
you can do as well, somewhere in the docs.


00:24:02.960 --> 00:24:03.800
I'm not seeing it right now,


00:24:03.800 --> 00:24:08.260
but you basically allow it to push the pigeon changes


00:24:08.260 --> 00:24:10.500
on down into the worker processes,


00:24:10.500 --> 00:24:11.380
which is pretty cool.


00:24:11.380 --> 00:24:13.700
And it has a bunch of comparisons against PyPy,


00:24:13.700 --> 00:24:16.420
Kisten, Numba, IronPython, et cetera,


00:24:16.420 --> 00:24:19.580
Nutca and so on.


00:24:19.580 --> 00:24:21.280
Now it's not that much faster.


00:24:21.280 --> 00:24:23.140
It is faster when you're doing more like


00:24:23.140 --> 00:24:25.420
data sciencey things, I believe,


00:24:25.420 --> 00:24:28.260
than if you're doing just like a query against a database


00:24:28.260 --> 00:24:30.180
where you're mostly just waiting anyway.


00:24:30.180 --> 00:24:31.900
But still, I think this is promising


00:24:31.900 --> 00:24:33.300
and it's really pretty early days.


00:24:33.300 --> 00:24:37.780
So the thing to look at is if there's optimizations


00:24:37.780 --> 00:24:41.540
coming along here somewhere in the docs.


00:24:41.540 --> 00:24:43.520
Anthony lists out the various optimizations


00:24:43.520 --> 00:24:44.580
he's put in so far,


00:24:44.580 --> 00:24:46.920
and really it just needs more optimizations


00:24:46.920 --> 00:24:50.580
to make it faster still, which is pretty neat.


00:24:50.580 --> 00:24:52.080
- I think that's pretty cool.


00:24:52.080 --> 00:24:55.200
One of the things that my first reaction was,


00:24:55.200 --> 00:24:58.620
oh, it's .NET only, so I have to use it on Windows.


00:24:58.620 --> 00:25:00.940
But that's not been that way for a long time.


00:25:00.940 --> 00:25:02.900
So .NET runs on just about everything.


00:25:02.900 --> 00:25:03.740
- Yeah, exactly.


00:25:03.740 --> 00:25:05.220
It supports all the different frameworks.


00:25:05.220 --> 00:25:08.060
There's even this thing called live.trypigeon.com,


00:25:08.060 --> 00:25:12.020
where you can write Python code, like over here on the left,


00:25:12.020 --> 00:25:14.060
and then you can say compile it,


00:25:14.060 --> 00:25:17.100
and it will actually show you the assembly


00:25:17.100 --> 00:25:17.980
that it would compile to.


00:25:17.980 --> 00:25:21.240
And then here's the .NET intermediate language.


00:25:21.240 --> 00:25:24.340
I guess maybe they should possibly be switching orders here.


00:25:24.340 --> 00:25:25.300
First it goes to IL,


00:25:25.300 --> 00:25:27.180
and then it goes to machine instructions through the JIT,


00:25:27.180 --> 00:25:29.160
but it shows you all the stuff


00:25:29.160 --> 00:25:31.180
that it's doing to make this work.


00:25:31.180 --> 00:25:32.340
And you can even see at the bottom,


00:25:32.340 --> 00:25:36.060
there's like sort of a visual understanding of what it's doing.


00:25:36.060 --> 00:25:40.700
One of the things that's really cool that it does is imagine you've got a math problem up here,


00:25:40.700 --> 00:25:47.980
like you're saying like x equals y times y plus z times z or something like that.


00:25:47.980 --> 00:25:51.460
Like each one of those steps generates an intermediate number.


00:25:51.460 --> 00:25:57.220
So for example, z times z would generate by default a Python number,


00:25:57.220 --> 00:25:59.020
and then so would y times y,


00:25:59.020 --> 00:26:00.860
and then the addition and finally you assign it.


00:26:00.860 --> 00:26:02.500
what it'll do is it'll say,


00:26:02.500 --> 00:26:04.220
"Okay, if those are two floats,


00:26:04.220 --> 00:26:06.580
let's just store that as a C float in


00:26:06.580 --> 00:26:09.340
the intermediate computation and then that's as a C float."


00:26:09.340 --> 00:26:11.780
So it can stay lower level


00:26:11.780 --> 00:26:13.960
as it's doing a lot of computational type of things.


00:26:13.960 --> 00:26:15.740
There's a bunch of interesting optimizations.


00:26:15.740 --> 00:26:18.020
People can check this out. I haven't had a chance to try it yet.


00:26:18.020 --> 00:26:19.820
I was hoping to, but I haven't got there yet.


00:26:19.820 --> 00:26:22.500
>> Yeah, really interesting conversation you had with them too.


00:26:22.500 --> 00:26:24.020
>> Thanks.


00:26:24.020 --> 00:26:27.380
>> It's interesting timing to just get him to jump on this.


00:26:27.380 --> 00:26:31.300
Like right after he wrote the book on Python internals,


00:26:31.300 --> 00:26:34.040
CPython internals, to jump into this,


00:26:34.040 --> 00:26:37.260
right, well I guess he was working on it before, but still.


00:26:37.260 --> 00:26:38.940
- Yeah, you definitely gotta know


00:26:38.940 --> 00:26:40.460
CPython internals to do this.


00:26:40.460 --> 00:26:44.900
Renee, do you guys do anything to optimize your code


00:26:44.900 --> 00:26:48.140
with like Numba or Cython or anything like that,


00:26:48.140 --> 00:26:49.940
or are you just running straight Python


00:26:49.940 --> 00:26:51.460
and letting the libraries deal with it?


00:26:51.460 --> 00:26:53.020
- Yeah, not currently.


00:26:53.020 --> 00:26:55.220
We have a pretty good server


00:26:55.220 --> 00:26:57.540
working with relatively small data sets,


00:26:57.540 --> 00:27:00.020
not millions of rows, for example.


00:27:00.020 --> 00:27:03.420
For right now, we haven't gone in this direction at all.


00:27:03.420 --> 00:27:06.500
I can imagine this would also be really useful if you were


00:27:06.500 --> 00:27:08.140
a computer science student and trying to


00:27:08.140 --> 00:27:09.500
understand what's going on


00:27:09.500 --> 00:27:11.220
under the hood when you run these things.


00:27:11.220 --> 00:27:14.820
It's interesting that for the people that aren't seeing the visual,


00:27:14.820 --> 00:27:17.420
you have three columns here with the code


00:27:17.420 --> 00:27:19.580
side-by-side to get a peek


00:27:19.580 --> 00:27:21.060
under the hood at what's going on there.


00:27:21.060 --> 00:27:23.300
But no, this isn't something I've used personally.


00:27:23.300 --> 00:27:25.400
- Yeah, yeah, I haven't used it either,


00:27:25.400 --> 00:27:26.640
but like I said, I would like to.


00:27:26.640 --> 00:27:29.180
I think it's got the ability to just plug in


00:27:29.180 --> 00:27:30.420
and make things faster.


00:27:30.420 --> 00:27:33.180
And really, it is faster to some degree.


00:27:33.180 --> 00:27:35.400
Sometimes I think it's slower, sometimes faster.


00:27:35.400 --> 00:27:39.060
But the more optimizations the JIT compiler gets,


00:27:39.060 --> 00:27:40.700
the better it could be, right?


00:27:40.700 --> 00:27:43.540
So like, if it could inline function calls


00:27:43.540 --> 00:27:46.260
rather than calling them, or it could,


00:27:46.260 --> 00:27:49.500
there's things like if it sees you allocating a list


00:27:49.500 --> 00:27:50.740
and putting stuff into it,


00:27:50.740 --> 00:27:53.060
it can skip some intermediate steps


00:27:53.060 --> 00:27:54.380
and just straight allocate that,


00:27:54.380 --> 00:27:57.160
or if you're doing accessing elements by index


00:27:57.160 --> 00:27:59.440
out of the list, it can just do pointer operations


00:27:59.440 --> 00:28:01.580
instead of going through the Python APIs.


00:28:01.580 --> 00:28:05.420
There's a lot of hard work that Anthony's put into this,


00:28:05.420 --> 00:28:07.540
and I think it's pretty cool.


00:28:07.540 --> 00:28:09.860
Yeah, I haven't tried it, would like to.


00:28:09.860 --> 00:28:10.900
Yeah. - Cool.


00:28:10.900 --> 00:28:13.080
- Indeed, all right, Brian, what do you got for us?


00:28:13.080 --> 00:28:15.100
- Well, actually, before I jump to the next topic,


00:28:15.100 --> 00:28:17.100
I wanted to mention, I wanted to shoo into


00:28:17.100 --> 00:28:18.400
this last conversation.


00:28:19.420 --> 00:28:23.900
Brett Cannon just wrote a interesting article


00:28:23.900 --> 00:28:25.580
called "Selecting a Programming Language


00:28:25.580 --> 00:28:28.000
Can Be a Form of Premature Optimization."


00:28:28.000 --> 00:28:30.680
And this is relevant to the conversation


00:28:30.680 --> 00:28:33.660
because the real steps, he says,


00:28:33.660 --> 00:28:35.940
if you think Python might be too slow,


00:28:35.940 --> 00:28:40.980
another implementation like Pidgin is like step three.


00:28:40.980 --> 00:28:43.040
So first prototype in Python,


00:28:43.040 --> 00:28:45.220
then optimize your data structures and algorithms


00:28:45.220 --> 00:28:48.580
and also like, you know, profile it.


00:28:48.580 --> 00:28:50.620
And then try another implementation


00:28:50.620 --> 00:28:53.260
before you abandon Python altogether.


00:28:53.260 --> 00:28:55.620
And then, you can do some late bindings


00:28:55.620 --> 00:28:58.900
like language bindings to connect to C if you need to,


00:28:58.900 --> 00:29:00.240
or Rust.


00:29:00.240 --> 00:29:02.780
But I think it ties in as like,


00:29:02.780 --> 00:29:07.600
when would I choose Pigeon or PyPI over CPython?


00:29:07.600 --> 00:29:10.460
Well, it's step three, just to let people know.


00:29:10.460 --> 00:29:12.140
(laughs)


00:29:12.140 --> 00:29:12.980
- Step three, got it.


00:29:12.980 --> 00:29:14.220
- Step three.


00:29:14.220 --> 00:29:15.900
I wanted to do something more lighthearted


00:29:15.900 --> 00:29:17.840
like use print for debugging.


00:29:17.840 --> 00:29:20.560
So I love this article.


00:29:20.560 --> 00:29:22.160
I am guilty of this.


00:29:22.160 --> 00:29:26.240
Of course, I use debuggers and logging systems as well,


00:29:26.240 --> 00:29:29.840
but I also throw print statements in there sometimes,


00:29:29.840 --> 00:29:31.920
and I'm not ashamed to say it.


00:29:31.920 --> 00:29:35.520
So Adam Johnson wrote tips for debugging the print,


00:29:35.520 --> 00:29:37.560
and there were a couple that with print,


00:29:37.560 --> 00:29:40.000
there were a couple that stood out to me I really wanted to


00:29:40.000 --> 00:29:41.640
mention because I use them a lot,


00:29:41.640 --> 00:29:43.120
even with logging though,


00:29:43.120 --> 00:29:46.440
is use debug variables with


00:29:46.440 --> 00:29:48.560
f strings and the equal sign.


00:29:48.560 --> 00:29:51.200
So this is brilliant.


00:29:51.200 --> 00:29:53.320
It's been in since 3.8.


00:29:53.320 --> 00:29:56.840
Instead of typing like a print widget equals


00:29:56.840 --> 00:29:59.360
and then in a string and then the widget number


00:29:59.360 --> 00:30:02.600
or something, you can just use the f strings


00:30:02.600 --> 00:30:05.280
and do the equal sign and it interpolates for you.


00:30:05.280 --> 00:30:08.000
Or it doesn't interpolate, it just prints it for you.


00:30:08.000 --> 00:30:10.200
So it's nice, I like that.


00:30:10.200 --> 00:30:13.920
The next one is, I love this, use emojis.


00:30:13.920 --> 00:30:15.040
I never thought to do this.


00:30:15.040 --> 00:30:16.340
This is brilliant.


00:30:16.340 --> 00:30:18.860
throw emojis in your print statements


00:30:18.860 --> 00:30:22.540
so that they pop out when you're debugging.


00:30:22.540 --> 00:30:23.380
Have you ever used emojis?


00:30:23.380 --> 00:30:24.200
- Yeah, this is cool.


00:30:24.200 --> 00:30:26.660
I started using emojis in comments.


00:30:26.660 --> 00:30:27.500
- Oh, okay.


00:30:27.500 --> 00:30:28.620
Comments, nice.


00:30:28.620 --> 00:30:31.740
- Yeah, so I'll put like the different emojis mean,


00:30:31.740 --> 00:30:33.140
for me, I was doing some API stuff.


00:30:33.140 --> 00:30:35.900
So like, this is the read-only method here of an API.


00:30:35.900 --> 00:30:37.540
So I'll put a certain emoji up there.


00:30:37.540 --> 00:30:39.060
And then this is one that changes data.


00:30:39.060 --> 00:30:40.740
So here's, so I'll put there,


00:30:40.740 --> 00:30:42.860
here's one that returns a list versus a single thing.


00:30:42.860 --> 00:30:45.620
So I'll put a whole bunch of those emojis and stuff.


00:30:45.620 --> 00:30:47.780
- Yeah, well, I mean, I used to do like a whole bunch


00:30:47.780 --> 00:30:49.940
of plus signs 'cause they're easy to see,


00:30:49.940 --> 00:30:52.140
but an emoji would be way easier to see.


00:30:52.140 --> 00:30:53.900
- It's way more fun, man.


00:30:53.900 --> 00:30:55.380
- Yeah, I do this as well.


00:30:55.380 --> 00:30:57.020
I print all the time for debugging,


00:30:57.020 --> 00:30:58.580
especially in Jupyter notebooks,


00:30:58.580 --> 00:30:59.860
because you don't always have


00:30:59.860 --> 00:31:01.960
the most sophisticated debugging tools in there,


00:31:01.960 --> 00:31:04.940
but being able to print and see what's going on


00:31:04.940 --> 00:31:06.840
as you go through each step of the notebook,


00:31:06.840 --> 00:31:09.180
and emojis are a great idea for that


00:31:09.180 --> 00:31:11.140
because it's so visual as you're scrolling through.


00:31:11.140 --> 00:31:13.160
You want to, like they're showing there the X


00:31:13.160 --> 00:31:14.260
and the check mark emoji.


00:31:14.260 --> 00:31:16.140
I like that for my little to-do lists


00:31:16.140 --> 00:31:18.140
in the comments that I leave for myself.


00:31:18.140 --> 00:31:18.980
- Yeah, yeah, that's awesome.


00:31:18.980 --> 00:31:20.420
I've done that as well, that's cool.


00:31:20.420 --> 00:31:24.820
Chris May out in the audience just put a heart sign,


00:31:24.820 --> 00:31:27.420
smiley face emoji as a response to this.


00:31:27.420 --> 00:31:28.260
Love it.


00:31:28.260 --> 00:31:30.100
- Last thing, he's got like seven tips.


00:31:30.100 --> 00:31:33.700
The last tip I wanted to talk about was using rich end


00:31:33.700 --> 00:31:38.700
or specifically rich print, rich.print or pprint.


00:31:38.700 --> 00:31:41.620
So for pprint, you have to do from pprint,


00:31:41.620 --> 00:31:43.660
install pprint or something,


00:31:43.660 --> 00:31:47.460
or unless you wanted to say it twice with pprint.pprint.


00:31:47.460 --> 00:31:50.580
But pprint stands for pretty printing.


00:31:50.580 --> 00:31:53.640
And the gist of this really is that structures


00:31:53.640 --> 00:31:56.160
by default print horribly.


00:31:56.160 --> 00:31:59.980
If you just print like a dict or a set or something,


00:31:59.980 --> 00:32:00.980
it looks gross.


00:32:00.980 --> 00:32:04.080
But rich and pretty print make it look nice.


00:32:04.080 --> 00:32:07.400
So if you're printing with those and debugging, use that.


00:32:07.400 --> 00:32:08.700
So yeah.


00:32:08.700 --> 00:32:12.120
- There's also exception handling stuff in there for it.


00:32:12.120 --> 00:32:15.280
There's a lot of that kind of debugging stuff in Ridge.


00:32:15.280 --> 00:32:17.840
- Yeah, printing exceptions is great with that.


00:32:17.840 --> 00:32:20.040
I also wanted to say one of the reasons why,


00:32:20.040 --> 00:32:24.320
one of the places where I use printing a lot for debugging


00:32:24.320 --> 00:32:27.440
is I print to print stuff in my,


00:32:27.440 --> 00:32:30.680
what I expect is going on when I'm writing a test function.


00:32:30.680 --> 00:32:34.440
So I'll often print out the flow, what's going on.


00:32:34.440 --> 00:32:37.120
The reason I do that is when, if PyTest,


00:32:37.120 --> 00:32:40.680
for PyTest, if a test fails, PyTest dumps the standard out.


00:32:40.680 --> 00:32:42.460
so it'll dump all of your print statements


00:32:42.460 --> 00:32:44.080
from the failed procedure.


00:32:44.080 --> 00:32:47.760
So that's either the test under code or the test itself.


00:32:47.760 --> 00:32:49.680
If there's print statements, it gets dumped out.


00:32:49.680 --> 00:32:50.920
So that's helpful.


00:32:50.920 --> 00:32:52.000
- Yeah, nice.


00:32:52.000 --> 00:32:53.000
- That's great, I love it.


00:32:53.000 --> 00:32:54.060
I use print statements a lot.


00:32:54.060 --> 00:32:56.000
My output is very verbose.


00:32:56.000 --> 00:32:58.800
- You can see right in order what's happening.


00:32:58.800 --> 00:33:00.200
Sometimes a debugger helps,


00:33:00.200 --> 00:33:02.640
but sometimes it's time to just print.


00:33:02.640 --> 00:33:03.480
- Yeah.


00:33:03.480 --> 00:33:04.720
- Speaking of visual stuff,


00:33:04.720 --> 00:33:06.000
what's your last one here, Renee?


00:33:06.000 --> 00:33:08.680
- Yeah, so in our line of work with data science,


00:33:08.680 --> 00:33:12.360
especially when you're providing the models as tools


00:33:12.360 --> 00:33:15.120
for end users that aren't the data scientists themselves,


00:33:15.120 --> 00:33:18.280
you really want, the explainability is really important.


00:33:18.280 --> 00:33:21.200
So being able to explain why a certain prediction


00:33:21.200 --> 00:33:24.580
got the value it did, what the different inputs are,


00:33:24.580 --> 00:33:27.240
we're always working to make that more transparent


00:33:27.240 --> 00:33:28.400
for our end users.


00:33:28.400 --> 00:33:31.840
In our case, for example, we might be predicting


00:33:31.840 --> 00:33:35.680
which students might be at risk of not retaining


00:33:35.680 --> 00:33:38.280
at the university, so not being enrolled a year later.


00:33:38.280 --> 00:33:39.800
So what are the different factors,


00:33:39.800 --> 00:33:42.080
both overall for the whole population


00:33:42.080 --> 00:33:45.120
that are correlated with not being enrolled for a year


00:33:45.120 --> 00:33:47.240
and for each individual student,


00:33:47.240 --> 00:33:49.120
what might be particular factors that,


00:33:49.120 --> 00:33:51.320
at least from the model's perspective,


00:33:51.320 --> 00:33:53.060
puts them at higher risk?


00:33:53.060 --> 00:33:56.040
So this package is called SHAP


00:33:56.040 --> 00:34:00.380
and that stands for Shapley Additive Explanations.


00:34:00.380 --> 00:34:02.500
It was brought to my attention by my team member,


00:34:02.500 --> 00:34:04.660
Brian Richards at Helio Campus.


00:34:04.660 --> 00:34:06.440
And now we use it very frequently


00:34:06.440 --> 00:34:09.280
because it has really good visualizations.


00:34:09.280 --> 00:34:11.200
So these Shapley values,


00:34:11.200 --> 00:34:12.720
apparently they're from game theory.


00:34:12.720 --> 00:34:14.360
I won't pretend to understand the details


00:34:14.360 --> 00:34:15.960
of how they're generated,


00:34:15.960 --> 00:34:18.020
but you can think of it as like a model


00:34:18.020 --> 00:34:19.280
on top of your model.


00:34:19.280 --> 00:34:22.780
So it's additive and all the different features,


00:34:22.780 --> 00:34:24.160
if you see the visualization here,


00:34:24.160 --> 00:34:26.720
it's showing kind of a little waterfall chart.


00:34:26.720 --> 00:34:29.500
So some of the values that,


00:34:29.500 --> 00:34:30.720
think of a particular row


00:34:30.720 --> 00:34:32.440
that you're running through your algorithm.


00:34:32.440 --> 00:34:36.000
Some of the values in that row are gonna make the,


00:34:36.000 --> 00:34:37.720
if you're doing a classification model,


00:34:37.720 --> 00:34:40.340
some values might make you more likely to be in one class,


00:34:40.340 --> 00:34:43.040
some might make you more likely to be in the other class.


00:34:43.040 --> 00:34:45.400
So you have these visuals of kind of the push and pull


00:34:45.400 --> 00:34:46.800
of each value.


00:34:46.800 --> 00:34:48.480
In this visual we're seeing,


00:34:48.480 --> 00:34:51.200
age is pushing a number to the right,


00:34:51.200 --> 00:34:53.220
sex is pushing it to the left,


00:34:53.220 --> 00:34:56.160
I guess BP and BMI, that looks like a blood pressure.


00:34:56.160 --> 00:34:58.540
So it's got this like waterfall type of chart.


00:34:58.540 --> 00:35:00.620
And what it's actually doing is it's comparing,


00:35:00.620 --> 00:35:04.040
it starts with the expected value for the whole population


00:35:04.040 --> 00:35:07.680
And then it's showing you for this particular record,


00:35:07.680 --> 00:35:11.760
each of the input values is kind of nudging


00:35:11.760 --> 00:35:16.480
that eventual prediction one in one direction or the other.


00:35:16.480 --> 00:35:19.280
So it was just nice visually to have those waterfall plots


00:35:19.280 --> 00:35:22.720
and to see which features are negatively


00:35:22.720 --> 00:35:27.720
or positively correlated with the end result.


00:35:27.720 --> 00:35:30.400
And you could also do some cool scatter plots with this.


00:35:30.400 --> 00:35:34.000
So you can do the input value versus the shop value


00:35:34.000 --> 00:35:37.440
and have a point for every item in your population.


00:35:37.440 --> 00:35:39.800
So in our example, that would be students.


00:35:39.800 --> 00:35:41.700
So we can have a scatterplot of all the students


00:35:41.700 --> 00:35:45.400
and something like the number of cumulative credits


00:35:45.400 --> 00:35:47.080
that they have as of that term.


00:35:47.080 --> 00:35:50.000
And so you'll see the gradient of like


00:35:50.000 --> 00:35:53.520
from low credits to high credits, it's not usually linear.


00:35:53.520 --> 00:35:54.960
What are those kind of break points


00:35:54.960 --> 00:35:57.520
and at what point are the values, you know,


00:35:57.520 --> 00:36:01.280
positively impactful to likelihood to retain


00:36:01.280 --> 00:36:03.560
or in the opposite direction.


00:36:03.560 --> 00:36:08.040
Of course, I'm glad that they put in this documentation,


00:36:08.040 --> 00:36:09.860
they have a whole section on basically,


00:36:09.860 --> 00:36:11.480
correlation is not causation.


00:36:11.480 --> 00:36:14.360
And we're constantly having to talk to our end users


00:36:14.360 --> 00:36:14.860
about that.


00:36:14.860 --> 00:36:20.880
But if we say a student that lives in a certain town


00:36:20.880 --> 00:36:23.100
is potentially more likely to retain,


00:36:23.100 --> 00:36:24.980
maybe because of distance from campus,


00:36:24.980 --> 00:36:28.260
or maybe you have traditionally recruit a lot of students


00:36:28.260 --> 00:36:31.020
from that town, it doesn't mean that if you force someone


00:36:31.020 --> 00:36:33.080
to move to that town, they're more likely to stay


00:36:33.080 --> 00:36:34.800
at your institution, right?


00:36:34.800 --> 00:36:37.920
So yeah, correlation is not causation.


00:36:37.920 --> 00:36:40.800
And I'm gonna switch over here to the visual


00:36:40.800 --> 00:36:42.600
to something called a Beeswarm plot


00:36:42.600 --> 00:36:45.120
that you can output this right in your Jupyter notebook,


00:36:45.120 --> 00:36:48.560
which is really handy when you develop a new model.


00:36:48.560 --> 00:36:50.800
And I'll try to describe this for people


00:36:50.800 --> 00:36:53.120
who are listening to the audio.


00:36:53.120 --> 00:36:56.700
It has along the X-axis, a list of features.


00:36:56.700 --> 00:36:59.120
So you've got in this example on their website,


00:36:59.120 --> 00:37:02.280
age, relationship, capital gain, marital status.


00:37:02.280 --> 00:37:05.720
And then you see a bunch of dots going across horizontally.


00:37:05.720 --> 00:37:08.520
And there's areas where there's little clusters of dots.


00:37:08.520 --> 00:37:12.780
So what this is showing is the X axis is the shop value.


00:37:12.780 --> 00:37:16.320
So what this shop package outputs.


00:37:16.320 --> 00:37:19.520
So you can see visually across,


00:37:19.520 --> 00:37:22.840
what is the spread of the impact of this value?


00:37:22.840 --> 00:37:25.500
So if each dot is a person in this case,


00:37:25.500 --> 00:37:28.080
you see people all the way to the right,


00:37:28.080 --> 00:37:29.840
whatever their age was,


00:37:29.840 --> 00:37:32.680
positively impacted their eventual score,


00:37:32.680 --> 00:37:34.060
people all the way to the left,


00:37:34.060 --> 00:37:36.380
their age negatively impacted the score.


00:37:36.380 --> 00:37:37.940
And then each dot is a color


00:37:37.940 --> 00:37:40.100
that ranges from blue to red.


00:37:40.100 --> 00:37:43.040
So the blue ones are people with low age


00:37:43.040 --> 00:37:45.500
and the red ones are people with a high age.


00:37:45.500 --> 00:37:48.840
So you can see here, basically the higher the age,


00:37:48.840 --> 00:37:52.620
the more positive their eventual prediction.


00:37:52.620 --> 00:37:54.520
So just an interesting way to get both


00:37:54.520 --> 00:37:56.260
like a feature importance


00:37:56.260 --> 00:37:59.600
and see the distribution of the values


00:37:59.600 --> 00:38:00.560
within each feature.


00:38:00.560 --> 00:38:01.880
So it's just really helpful


00:38:01.880 --> 00:38:03.440
when you're doing predictive models,


00:38:03.440 --> 00:38:05.520
both for evaluating your own model


00:38:05.520 --> 00:38:08.880
and then eventually explaining it to end users.


00:38:08.880 --> 00:38:12.920
- So would a wider spread mean that the feature


00:38:12.920 --> 00:38:17.080
is more useful or does it have any?


00:38:17.080 --> 00:38:19.060
- Yeah, especially if you can see a split


00:38:19.060 --> 00:38:19.900
in the numbers there.


00:38:19.900 --> 00:38:22.360
So you see in this example, relationship,


00:38:22.360 --> 00:38:24.300
you've got all the red ones to the right


00:38:24.300 --> 00:38:25.840
and all the blue ones to the left.


00:38:25.840 --> 00:38:28.600
That means that there's a clear relationship


00:38:28.600 --> 00:38:35.560
this relationship field with the target variable. So there's a clear split where the low values are


00:38:35.560 --> 00:38:41.000
on one side and the high values are on the other side. And then yeah, the spread means that if


00:38:41.000 --> 00:38:45.480
there's, there's not a good example here, but sometimes you'll see like two clumps,


00:38:45.480 --> 00:38:50.280
two B-swarms spread apart with nothing in the middle. So that's when you have a really clear


00:38:50.280 --> 00:38:55.960
spread of the high impact group versus the low impact group. And if it's more narrow, that's


00:38:56.520 --> 00:39:04.200
less of an important variable. You see if you look at the one that's sorted by max, here we go,


00:39:04.200 --> 00:39:11.480
absolute value of the shop value, the ones near the bottom for the population have less impact.


00:39:11.480 --> 00:39:16.840
Now, there might be one person in there where that particular value was like the deciding factor of


00:39:16.840 --> 00:39:21.640
which class they ended up in, but for the population as a whole, there's less differentiation


00:39:21.640 --> 00:39:25.800
across these values than across the ones near the top of the list.


00:39:25.800 --> 00:39:30.840
Yeah, this is cool because that visualization of models is very tricky, right? And it's something


00:39:30.840 --> 00:39:34.280
like knowing why you got an answer. Now this looks very helpful.


00:39:34.280 --> 00:39:38.520
Yeah, it's really useful. And the visuals are so pretty by default. But then you can also


00:39:38.520 --> 00:39:45.240
pull those values into other tools. So we'll, for example, so for each feature in each row,


00:39:45.240 --> 00:39:49.400
you get a shop value. So you can write those back to the database and then pull those values into


00:39:49.400 --> 00:39:51.440
to another tool, like we use it in Tableau


00:39:51.440 --> 00:39:53.200
to highlight for each student,


00:39:53.200 --> 00:39:55.960
what are those really important features,


00:39:55.960 --> 00:39:58.160
either making them, you know,


00:39:58.160 --> 00:40:00.080
if you're not making them, it's not causation,


00:40:00.080 --> 00:40:04.920
but you know, correlated with their more likely to retain


00:40:04.920 --> 00:40:06.400
or less likely to retain.


00:40:06.400 --> 00:40:09.240
So we might say, well, for this student, their GPA,


00:40:09.240 --> 00:40:10.320
that's the main factor.


00:40:10.320 --> 00:40:11.800
Their GPA is really low.


00:40:11.800 --> 00:40:14.200
Students with low GPAs tend not to retain.


00:40:14.200 --> 00:40:17.560
And so when the end user's looking at all of their values


00:40:17.560 --> 00:40:20.980
in a table or some other kind of view,


00:40:20.980 --> 00:40:22.920
you can use the SHAP value to highlight.


00:40:22.920 --> 00:40:24.600
GPA is the one you need to hone in on.


00:40:24.600 --> 00:40:26.360
The student is struggling academically.


00:40:26.360 --> 00:40:27.480
- Right, try to help them,


00:40:27.480 --> 00:40:29.440
give some help with grades, for example.


00:40:29.440 --> 00:40:30.280
Cool.


00:40:30.280 --> 00:40:31.680
Yeah, this is a great find.


00:40:31.680 --> 00:40:33.080
Indeed, indeed.


00:40:33.080 --> 00:40:35.160
Brian, that brings us to the extras.


00:40:35.160 --> 00:40:36.800
- Extras, extras. - Got any extras for us?


00:40:36.800 --> 00:40:40.800
- I do, I've got one that was just a quick one.


00:40:40.800 --> 00:40:42.840
Let's see, pull it up.


00:40:42.840 --> 00:40:46.560
Matthew Fiegaert mentioned on Twitter


00:40:46.560 --> 00:40:50.040
That pip index is a cool thing.


00:40:50.040 --> 00:40:53.320
And I kind of didn't know about it, so this is neat.


00:40:53.320 --> 00:40:57.580
So pip index is something you can take a pip index,


00:40:57.580 --> 00:41:00.660
well, specifically pips, pip index versions.


00:41:00.660 --> 00:41:02.480
So pip index does a whole bunch of stuff,


00:41:02.480 --> 00:41:05.360
but pip index versions will tell you,


00:41:05.360 --> 00:41:07.480
if you also give it a package,


00:41:07.480 --> 00:41:10.640
it'll tell you all the different versions


00:41:10.640 --> 00:41:14.520
that are available on PyPI and which one you have,


00:41:14.520 --> 00:41:16.920
and which, you know, if you're out of date and stuff,


00:41:16.920 --> 00:41:18.840
but so for instance,


00:41:18.840 --> 00:41:21.040
if you're thinking about upgrading something


00:41:21.040 --> 00:41:23.640
and you don't know what to upgrade to,


00:41:23.640 --> 00:41:26.360
you can look to see what all is there, I guess.


00:41:26.360 --> 00:41:27.320
- Or you wanna roll it back.


00:41:27.320 --> 00:41:28.960
You're like, oh, this version is not working.


00:41:28.960 --> 00:41:32.880
I wanna go back to a lower one, but you're on 2.0.


00:41:32.880 --> 00:41:34.720
I say, it's not 1.0, what is it, right?


00:41:34.720 --> 00:41:35.560
What do you go back to?


00:41:35.560 --> 00:41:37.560
And so this will like list all the available versions.


00:41:37.560 --> 00:41:40.480
Basically, this is a CLI version


00:41:40.480 --> 00:41:44.440
of the releases option in pypi.org.


00:41:44.440 --> 00:41:48.560
- Right, and that's not obvious how to get to on PyPI,


00:41:48.560 --> 00:41:51.880
but I know you can get to it, you can see all the releases,


00:41:51.880 --> 00:41:54.200
but by default, it doesn't show those,


00:41:54.200 --> 00:41:55.440
so this is pretty quick.


00:41:55.440 --> 00:41:57.680
- Yeah, good one, good one.


00:41:57.680 --> 00:41:59.560
Renee, how about you, some extras?


00:41:59.560 --> 00:42:01.880
- Sure, I wanted to make sure to mention my book.


00:42:01.880 --> 00:42:05.460
So just published and just out in Europe this week,


00:42:05.460 --> 00:42:06.400
actually as a paperback,


00:42:06.400 --> 00:42:08.480
but it's been out since September in the US,


00:42:08.480 --> 00:42:10.240
"SQL for Data Scientists,


00:42:10.240 --> 00:42:13.560
"A Beginner's Guide for Building Datasets for Analysis."


00:42:13.560 --> 00:42:15.920
So I mentioned earlier, I wrote this book


00:42:15.920 --> 00:42:18.780
because I think a lot of students coming out


00:42:18.780 --> 00:42:21.520
of data science programs or people who are coming


00:42:21.520 --> 00:42:26.420
from maybe a statistics background that are in data science


00:42:26.420 --> 00:42:28.760
might not have experience pulling the data.


00:42:28.760 --> 00:42:31.760
So in class, a lot of times you're given a clean spreadsheet


00:42:31.760 --> 00:42:33.960
to start with when you're building your predictive model.


00:42:33.960 --> 00:42:36.560
Then you get to the job and you sit down the first day


00:42:36.560 --> 00:42:38.280
and they say, "Great, build us a model."


00:42:38.280 --> 00:42:39.920
And you say, "Well, where's the data?"


00:42:39.920 --> 00:42:42.560
It's in a raw form in the database.


00:42:42.560 --> 00:42:43.960
So you have to build your own data set.


00:42:43.960 --> 00:42:45.400
So that's what the purpose of the book is,


00:42:45.400 --> 00:42:47.000
to kind of get you from that point


00:42:47.000 --> 00:42:49.040
of when you have access to raw data,


00:42:49.040 --> 00:42:51.360
to exploring and building your data set


00:42:51.360 --> 00:42:53.400
so that you can run it through your predictive model.


00:42:53.400 --> 00:42:56.280
So on the screen there, you see my website


00:42:56.280 --> 00:42:57.960
and for people on the audio,


00:42:57.960 --> 00:43:01.140
it's SQLfordatascientist.com.


00:43:01.140 --> 00:43:05.040
And you can go to different chapters on the website


00:43:05.040 --> 00:43:07.780
and I have some example SQL and you can also run it.


00:43:07.780 --> 00:43:11.640
So there's a SQLite database in the browser here.


00:43:11.640 --> 00:43:13.920
And so you can actually copy and paste


00:43:13.920 --> 00:43:15.920
some of the SQL on the page,


00:43:15.920 --> 00:43:18.600
click execute and it shows up in a table down here.


00:43:18.600 --> 00:43:20.200
You can edit it and rerun it.


00:43:20.200 --> 00:43:21.720
So you get a little bit of practice


00:43:21.720 --> 00:43:24.360
with using the database in the book.


00:43:24.360 --> 00:43:25.180
- Neat.


00:43:25.180 --> 00:43:26.400
Yeah, cool book.


00:43:26.400 --> 00:43:29.440
And wow, SQLite in the browser, very neat.


00:43:29.440 --> 00:43:30.280
- Thank you.


00:43:30.280 --> 00:43:31.120
- Yeah, awesome.


00:43:31.120 --> 00:43:33.280
That's a book that definitely should exist.


00:43:33.280 --> 00:43:34.120
All right, really quickly,


00:43:34.120 --> 00:43:37.720
I'm gonna do a webcast with Paul Everett.


00:43:37.720 --> 00:43:39.240
Haven't seen Paul in the audience today.


00:43:39.240 --> 00:43:40.060
Paul, where are you?


00:43:40.060 --> 00:43:42.060
I'm not sure it might be working.


00:43:42.060 --> 00:43:43.700
But on November 23rd,


00:43:43.700 --> 00:43:46.620
I'm going to be doing a webcast around PyCharm.


00:43:46.620 --> 00:43:50.700
I've updated my PyCharm course with all sorts of good stuff.


00:43:50.700 --> 00:43:53.740
I haven't quite totally announced it yet because there's a few things I'm waiting,


00:43:53.740 --> 00:43:56.260
slightly more stable versions to come out of


00:43:56.260 --> 00:43:59.860
JetBrains to finish some of their data science tools actually.


00:43:59.860 --> 00:44:01.460
Then I'll talk more about it,


00:44:01.460 --> 00:44:04.180
but we're doing a webcast in about a week or so.


00:44:04.180 --> 00:44:06.340
So that should be a lot of fun.


00:44:06.340 --> 00:44:09.100
Come check it out, watch Paul and me,


00:44:09.100 --> 00:44:12.020
>> Two days before Thanksgiving.


00:44:12.020 --> 00:44:13.660
>> Yes, indeed.


00:44:13.660 --> 00:44:15.460
That brings us to our joke.


00:44:15.460 --> 00:44:16.540
>> I need a joke.


00:44:16.540 --> 00:44:21.740
>> In the joke, it is a response to something that you posted on Twitter.


00:44:21.740 --> 00:44:27.380
Really appreciating my foresight using lots of stuff comment as the message in Git commit.


00:44:27.380 --> 00:44:30.300
>> Well, it actually confused me because I did a Git rebase main


00:44:30.300 --> 00:44:31.820
and it said applying lots of stuff.


00:44:31.820 --> 00:44:35.420
I thought it was like a feature of Git rebase,


00:44:35.420 --> 00:44:37.940
and it just happened to be my commit message.


00:44:37.940 --> 00:44:40.220
It's like, oh, Git's gotten real casual.


00:44:40.220 --> 00:44:42.220
It's a lot of stuff.


00:44:42.220 --> 00:44:47.380
So Francois Voron said, "Time for a classic XKCD."


00:44:47.380 --> 00:44:48.380
Link here.


00:44:48.380 --> 00:44:49.380
Yeah.


00:44:49.380 --> 00:44:50.380
Yeah.


00:44:50.380 --> 00:44:55.940
And so this is like the commit history throughout the project as you get farther into it.


00:44:55.940 --> 00:45:00.940
So it starts out with very formal, proper comments like, "Created main loop and timing


00:45:00.940 --> 00:45:01.940
control."


00:45:01.940 --> 00:45:04.860
The next commit is, "Enabled config file parsing."


00:45:04.860 --> 00:45:08.180
And then it starts to fit miscellaneous bug fixes,


00:45:08.180 --> 00:45:10.180
then code additions and edits,


00:45:10.180 --> 00:45:12.880
and then a branch, more code,


00:45:12.880 --> 00:45:16.260
you have code, just eight letter A's.


00:45:16.260 --> 00:45:18.900
It comes back with-- - Internal screaming.


00:45:18.900 --> 00:45:23.900
- Exactly, just ADK, FJ, SLK, just a bunch of home row.


00:45:23.900 --> 00:45:25.940
And then my hands are typing words,


00:45:25.940 --> 00:45:28.480
and then just hands, and the title is,


00:45:28.480 --> 00:45:31.980
as a project drags on, my git commit messages


00:45:31.980 --> 00:45:33.760
get less and less informative.


00:45:33.760 --> 00:45:34.700
We've all been there, right?


00:45:34.700 --> 00:45:35.700
- Yeah. - Yes.


00:45:35.700 --> 00:45:39.640
- It happens to me with branch names too,


00:45:39.640 --> 00:45:42.920
'cause if I'm working on one feature and push part of it,


00:45:42.920 --> 00:45:44.800
and then I go and I'm still working on it,


00:45:44.800 --> 00:45:47.320
I like to use a new branch name,


00:45:47.320 --> 00:45:51.680
and I just, it's hard to come up with good branch names


00:45:51.680 --> 00:45:53.280
for a feature. - I'm branching.


00:45:53.280 --> 00:45:55.440
Exactly.


00:45:55.440 --> 00:45:58.160
I try to be more formal on the branches at least,


00:45:58.160 --> 00:45:59.880
so I know I can delete them later.


00:45:59.880 --> 00:46:02.720
And so when I'm working on projects that are mostly just me,


00:46:02.720 --> 00:46:06.320
I'll create a GitHub issue and then create the branch name


00:46:06.320 --> 00:46:08.360
to be like a short version of the issue title


00:46:08.360 --> 00:46:09.760
and the issue number.


00:46:09.760 --> 00:46:11.260
So then when I commit back in,


00:46:11.260 --> 00:46:12.680
I can just look at the branch name


00:46:12.680 --> 00:46:14.320
and put a hash that number,


00:46:14.320 --> 00:46:17.880
and it'll tag it in the commit on the issue in GitHub.


00:46:17.880 --> 00:46:19.880
If I'm working with someone like a team,


00:46:19.880 --> 00:46:23.320
I might put like my name slash branch name.


00:46:23.320 --> 00:46:25.560
And then actually in some of the tools like SourceTree,


00:46:25.560 --> 00:46:27.360
you have like little expando widgets


00:46:27.360 --> 00:46:28.920
around that on the branches.


00:46:28.920 --> 00:46:30.760
So you can say these are Michael's branches


00:46:30.760 --> 00:46:32.760
and these are Renee's branches and so on.


00:46:32.760 --> 00:46:34.380
- Yeah, we got into the habit of doing that too.


00:46:34.380 --> 00:46:36.460
It helps a lot to see right up front,


00:46:36.460 --> 00:46:37.800
whose branch is this?


00:46:37.800 --> 00:46:40.020
- Yeah, it can get out of control, right?


00:46:40.020 --> 00:46:42.800
All right, a quick couple of follow-ups, Brian.


00:46:42.800 --> 00:46:45.020
Anthony says, "The book looks great, Renee.


00:46:45.020 --> 00:46:45.920
I'll check it out."


00:46:45.920 --> 00:46:47.040
- Great, thank you.


00:46:47.040 --> 00:46:48.520
- Chris May likes it as well.


00:46:48.520 --> 00:46:49.360
It's a great book idea.


00:46:49.360 --> 00:46:50.700
- Glad you like it.


00:46:50.700 --> 00:46:52.420
- Especially when I keep working long


00:46:52.420 --> 00:46:53.400
after I should have gone home.


00:46:53.400 --> 00:46:54.720
No, this is the joke.


00:46:54.720 --> 00:46:56.560
This is me, especially after I keep working long


00:46:56.560 --> 00:46:57.960
after I should have gone home.


00:46:57.960 --> 00:46:59.800
And gone home, yeah, absolutely.


00:46:59.800 --> 00:47:02.160
And Sam, oops, forgot to stage this


00:47:02.160 --> 00:47:04.880
as a common message in my repositories.


00:47:04.880 --> 00:47:05.840
(laughing)


00:47:05.840 --> 00:47:07.200
- Nice. - Indeed.


00:47:07.200 --> 00:47:08.800
So, cool.


00:47:08.800 --> 00:47:09.720
It was a fun episode.


00:47:09.720 --> 00:47:11.200
Thanks, Renee, for coming on.


00:47:11.200 --> 00:47:12.120
- Yeah, thanks for having me.


00:47:12.120 --> 00:47:12.960
It's fun.


00:47:12.960 --> 00:47:15.360
Don't get to dive into Python too often.


00:47:15.360 --> 00:47:17.360
I'm using the same type of things over and over,


00:47:17.360 --> 00:47:20.220
so it's nice to see what's new and what's on the horizon.


00:47:20.220 --> 00:47:21.120
- Awesome, yep.


00:47:21.120 --> 00:47:21.960
Thanks, Marc. - Thanks, Renee.


00:47:21.960 --> 00:47:22.780
Thanks, Brian.


00:47:22.780 --> 00:47:23.620
See y'all. - Bye.

