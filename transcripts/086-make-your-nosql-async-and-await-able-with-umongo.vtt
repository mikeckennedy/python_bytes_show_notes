WEBVTT

00:00:00.080 --> 00:00:05.200
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:05.200 --> 00:00:10.740
This is episode 86, recorded July 11th, 2018. I'm Michael Kennedy.

00:00:10.740 --> 00:00:11.560
And I'm Brian Okken.

00:00:11.560 --> 00:00:14.500
And Brian, we have a new special guest, Bob Belderbos.

00:00:14.500 --> 00:00:15.360
Yeah, pretty excited.

00:00:15.360 --> 00:00:16.120
Yeah, welcome, Bob.

00:00:16.120 --> 00:00:18.140
Hey, nice to be here. Thanks.

00:00:18.140 --> 00:00:24.700
Yeah, so people may recognize Bob from his PyBytes with an I, code challenge stuff that he does,

00:00:24.700 --> 00:00:27.180
as well as the 100 Days of Code course that we did together, right?

00:00:27.180 --> 00:00:34.160
Yeah, we did a major course on 100 Days of Code in Python. It was very fun.

00:00:34.160 --> 00:00:38.100
Yeah, it was only, what, 20 hours of video and 80 hours of exercise?

00:00:38.100 --> 00:00:38.840
Yeah.

00:00:38.840 --> 00:00:42.620
That was awesome. So welcome to the show. We're super excited to have you here.

00:00:42.620 --> 00:00:47.560
Before we get into everything, let's just say thank you to DigitalOcean, our customer,

00:00:47.560 --> 00:00:52.900
and their sponsor of our show as well. Let's check them out at pythonbytes.fm/DigitalOcean.

00:00:52.900 --> 00:00:56.040
You'll get $100 free credit if you're a new user. That's pretty awesome.

00:00:56.500 --> 00:01:00.900
Brian, if I had to guess, if I were just going to pick out of thin air what kind of topic you might have,

00:01:00.900 --> 00:01:02.360
it might have something to do with testing.

00:01:02.360 --> 00:01:05.660
Yeah, I do like testing quite a bit.

00:01:05.660 --> 00:01:06.580
So what do you got for us?

00:01:06.580 --> 00:01:11.000
Well, we have responses, and there's a funny story around it, but this is,

00:01:11.000 --> 00:01:17.040
responses is a utility library for mocking out requests, Python library.

00:01:17.620 --> 00:01:20.080
And it's from GitSentry.

00:01:20.080 --> 00:01:23.980
So it's under the GitSentry GitHub account.

00:01:23.980 --> 00:01:25.700
And it looks pretty cool.

00:01:25.700 --> 00:01:30.500
It's actually, we'll include a small snippet in our show notes, but there's,

00:01:30.500 --> 00:01:35.980
it's a decorator approach to, and other ways to be able to test your,

00:01:35.980 --> 00:01:37.300
pretty much mock out.

00:01:37.480 --> 00:01:43.640
If you have an application that uses requests to access any, really any end point on the internet,

00:01:43.640 --> 00:01:45.800
you can use this to mock out those.

00:01:45.800 --> 00:01:49.680
And it has some dynamic, dynamicness to it.

00:01:49.680 --> 00:01:52.460
And it's, it looks actually pretty complete and pretty nice.

00:01:52.460 --> 00:01:53.360
That's pretty sweet.

00:01:53.360 --> 00:01:53.680
Yeah.

00:01:53.880 --> 00:01:56.180
You put an attribute on your, your function.

00:01:56.180 --> 00:02:02.200
And during that one, any call to requests like request.get or the response.json or whatever

00:02:02.200 --> 00:02:06.120
is going to be basically overridden as if you had done that with patch,

00:02:06.120 --> 00:02:09.180
but it's, it's a little more focused on just requests, right?

00:02:09.180 --> 00:02:09.540
Yeah.

00:02:09.540 --> 00:02:16.600
It's, it's focused on requests and it's also, it's designed to go well with the pytest framework.

00:02:16.600 --> 00:02:19.500
So it cleans up after itself really easily.

00:02:19.500 --> 00:02:19.820
Nice.

00:02:19.820 --> 00:02:21.080
How does it integrate with pytest?

00:02:21.080 --> 00:02:22.640
Like what, what's special about that?

00:02:22.820 --> 00:02:26.560
You have the decorator you put on your test is like responses activate.

00:02:26.560 --> 00:02:32.520
So it'll, and then you're, you're going to have it, you register a, an end point to

00:02:32.520 --> 00:02:34.800
mark and what response it should give.

00:02:34.800 --> 00:02:38.160
And then all of that gets cleaned up at the end of the test.

00:02:38.160 --> 00:02:40.420
You don't have to undo it or anything like that.

00:02:40.420 --> 00:02:40.620
Yeah.

00:02:40.620 --> 00:02:41.160
That's awesome.

00:02:41.160 --> 00:02:42.160
Very nice.

00:02:42.160 --> 00:02:48.240
The funny thing is, is this is exactly what Anthony and I were, we're considering building

00:02:48.240 --> 00:02:48.740
together.

00:02:48.740 --> 00:02:50.500
We just didn't know this one existed.

00:02:50.760 --> 00:02:56.000
And so I wanted to point it out because, your responses is a clever name to go with

00:02:56.000 --> 00:02:56.620
requests.

00:02:56.620 --> 00:02:57.580
I get it.

00:02:57.580 --> 00:03:03.240
But if I'm trying to find something that goes well with pytest and goes well with, requests,

00:03:03.240 --> 00:03:06.280
I might not know to search for responses.

00:03:06.280 --> 00:03:08.560
So that's why I'm violating it out.

00:03:08.560 --> 00:03:12.300
So I think anybody that's trying to do something like this should check it out.

00:03:12.300 --> 00:03:13.240
It looks pretty complete.

00:03:13.240 --> 00:03:13.760
Cool.

00:03:13.760 --> 00:03:14.620
It looks very useful.

00:03:14.860 --> 00:03:17.940
So it's not making any call over the network, right?

00:03:17.940 --> 00:03:20.220
That's the whole point of, of patching it out.

00:03:20.220 --> 00:03:20.640
Right?

00:03:20.640 --> 00:03:22.180
Well, it's patching.

00:03:22.180 --> 00:03:25.420
It'll patch out the end points that you specify.

00:03:25.420 --> 00:03:26.680
I don't really know.

00:03:26.680 --> 00:03:28.720
I don't know what the behavior is for other ones.

00:03:28.720 --> 00:03:30.620
It probably lets everything else go through.

00:03:30.620 --> 00:03:30.960
Yeah.

00:03:30.960 --> 00:03:32.160
That's the one of the things I like about it.

00:03:32.160 --> 00:03:39.160
As you say this, if I request this HTTP endpoint, then do this rather than I'm just replacing,

00:03:39.160 --> 00:03:41.720
you know, request.get with everything.

00:03:41.720 --> 00:03:42.060
Right.

00:03:42.060 --> 00:03:42.820
Right.

00:03:42.820 --> 00:03:43.360
Oh yeah.

00:03:43.360 --> 00:03:43.760
Pretty nice.

00:03:43.760 --> 00:03:50.280
I do see your point about SEO and discoverability for responses because like response and responses

00:03:50.280 --> 00:03:53.900
is just such a common word on so many API libraries.

00:03:53.900 --> 00:03:55.720
Like how are you going to find the testing one?

00:03:55.720 --> 00:03:58.040
Yeah, I was looking.

00:03:58.040 --> 00:04:01.220
It says in its description that it's Python 2.7 or newer.

00:04:01.700 --> 00:04:08.720
Well, so it isn't obvious to me that it was 3x, but it looks like in the investigate the

00:04:08.720 --> 00:04:12.140
toxiny file, it's tested up through 3.5 at least.

00:04:12.140 --> 00:04:15.240
So it's probably 3.6 and 3.7 compatible too.

00:04:15.240 --> 00:04:16.580
Haven't tried it, but.

00:04:16.580 --> 00:04:17.160
Yeah, probably.

00:04:17.160 --> 00:04:17.700
Probably.

00:04:17.700 --> 00:04:18.080
Yeah.

00:04:18.080 --> 00:04:18.660
Very nice.

00:04:18.660 --> 00:04:20.240
All right, Bob, it's time for yours.

00:04:20.240 --> 00:04:21.060
What one did you bring?

00:04:21.060 --> 00:04:28.820
Yeah, I found an interesting decision tree article, 29 common beginner Python errors on one page.

00:04:29.600 --> 00:04:35.420
And I found this interesting because these kind of decision trees or graphics, you get

00:04:35.420 --> 00:04:40.260
a lot of information in one page you can print out or study in detail.

00:04:40.260 --> 00:04:42.340
And it's like a flow.

00:04:42.340 --> 00:04:45.920
It's like an infographic for like getting my code to work.

00:04:45.920 --> 00:04:46.600
It's amazing.

00:04:46.600 --> 00:04:48.760
Yeah, it didn't land directly on the article.

00:04:48.760 --> 00:04:51.680
Actually, it was Microsoft devs that tweeted it out.

00:04:51.680 --> 00:04:54.420
And that's how I found it on the Python hashtag.

00:04:54.900 --> 00:04:59.420
And it goes through this whole flow, like what kind of error do you get?

00:04:59.420 --> 00:05:05.200
And then it goes into these common Python errors, like attribute errors, syntax error, type errors.

00:05:05.200 --> 00:05:08.960
And for each one, it gives like a couple of plausible causes.

00:05:08.960 --> 00:05:14.180
And yeah, I mean, if you have more experience, some might be obvious, but some are very subtle.

00:05:14.180 --> 00:05:21.980
And that was like a great reminder, like comparing three int with a three string that returns false.

00:05:21.980 --> 00:05:28.440
And for example, when I was going through it, I also could relate to similar things.

00:05:28.440 --> 00:05:32.740
Like when you exhaust the file, that also can happen with a generator, right?

00:05:32.740 --> 00:05:34.400
In generator, you go through it once.

00:05:34.520 --> 00:05:42.840
And then if you do that again, then, hey, it's like an empty list because a generator only, you can only consume once, right?

00:05:42.840 --> 00:05:48.320
So it was a nice, I guess, exercise to take a lot of info in from one infograph.

00:05:48.320 --> 00:05:52.340
And I think for a beginner, it's very useful to go through that at least once.

00:05:52.340 --> 00:06:01.780
And I think the author made the infograph after having teached Python for a long time in the biology space.

00:06:01.780 --> 00:06:05.780
So that was also inspiring for me, like teaching others.

00:06:05.780 --> 00:06:06.360
Yeah.

00:06:06.360 --> 00:06:09.180
How you could summarize that information at some point.

00:06:09.180 --> 00:06:12.060
I'll try to give a quick summary just so people can get the visual.

00:06:12.060 --> 00:06:13.720
So it's like an infographing.

00:06:13.720 --> 00:06:14.580
It says, start here.

00:06:14.580 --> 00:06:16.440
Do you get an error when you run your code?

00:06:16.440 --> 00:06:16.900
Yes.

00:06:16.900 --> 00:06:17.980
What type of error do you get?

00:06:17.980 --> 00:06:18.880
And there's a whole branch there.

00:06:18.880 --> 00:06:19.220
No.

00:06:19.220 --> 00:06:21.280
Does your code use loops or if statements?

00:06:21.280 --> 00:06:23.060
If you use an if statement, go check this.

00:06:23.060 --> 00:06:25.780
It just like walks you through some pretty basic stuff.

00:06:25.780 --> 00:06:26.660
I kind of like it.

00:06:26.660 --> 00:06:27.520
Brian, what do you think?

00:06:27.520 --> 00:06:27.820
Yeah.

00:06:27.820 --> 00:06:31.280
Actually, this is one that I've run across before.

00:06:31.280 --> 00:06:43.720
And when our team started using Python for testing, one of the other engineers actually printed this out and posted it on the side of their cubicle so that people that came and asked them questions could just look at that first.

00:06:43.720 --> 00:06:44.700
Oh, that's pretty cool.

00:06:44.700 --> 00:06:49.400
And I like the fact that it's coming from Python for biologists.com.

00:06:49.400 --> 00:06:53.920
So we're seeing Python being taught in a lot of different domains, which is awesome.

00:06:53.920 --> 00:06:54.300
Yeah.

00:06:54.300 --> 00:06:55.420
That actually is a really good point.

00:06:55.420 --> 00:06:56.180
It's pretty awesome.

00:06:56.180 --> 00:07:03.740
So the next one that I have for us is this thing called MicroMongo, which somehow I have not heard of previously.

00:07:03.740 --> 00:07:10.320
But Brian, you know, I go on and on about async programming stuff and parallelism and things like that, right?

00:07:10.520 --> 00:07:10.880
Yes.

00:07:10.880 --> 00:07:13.940
And I do know that you kind of like MongoDB also.

00:07:13.940 --> 00:07:17.540
This is like I get to put them together.

00:07:17.540 --> 00:07:18.120
It's amazing.

00:07:18.540 --> 00:07:26.040
So one of the main challenges of this async await stuff actually becoming super useful and super powerful.

00:07:26.040 --> 00:07:30.620
There's two fundamental problems limiting like the serious adoption of this.

00:07:30.620 --> 00:07:33.420
One is the web frameworks don't deeply support it.

00:07:33.420 --> 00:07:35.880
So I can't have an async flask method.

00:07:36.060 --> 00:07:41.640
I have to switch to something like Cort or use Fibora or some other framework like the main Django pyramid flask.

00:07:41.640 --> 00:07:43.280
They don't support the async.

00:07:43.280 --> 00:07:44.760
So that's thing one.

00:07:44.760 --> 00:07:46.860
But we're seeing some movement there.

00:07:46.860 --> 00:07:58.080
But even if you could get that to work, a lot of the ORMs don't have great ways to take advantage of their parallelism or their potential parallelism while they're waiting on the network talking to the database.

00:07:58.280 --> 00:08:01.400
Because usually that's what your web app is doing and that's why you would want the async.

00:08:01.400 --> 00:08:04.840
It's like you could let it do other processing while you're waiting on a database response.

00:08:04.840 --> 00:08:15.060
So what you need is if you're using an ORM or something equivalent called an ODM for Mongo is the ability to interact with those databases in an async way.

00:08:15.060 --> 00:08:27.260
And so this micro Mongo is a very lightweight and small, as you might imagine from the name, object document mapper for MongoDB and Python that brings this ability to do async operations against MongoDB.

00:08:27.680 --> 00:08:28.200
Right.

00:08:28.200 --> 00:08:35.380
So if you wanted to use, say, Cort or Fibora and you want to use MongoDB as the backend, you have to use something like this, which is pretty sweet.

00:08:35.380 --> 00:08:36.060
Very interesting.

00:08:36.060 --> 00:08:39.120
I need to go on the async train myself yet.

00:08:39.120 --> 00:08:41.220
So maybe this is a good opportunity to learn it.

00:08:41.220 --> 00:08:42.280
So definitely.

00:08:42.280 --> 00:08:47.100
It's not that, I mean, Mongo itself, you don't need, that's on the other end.

00:08:47.100 --> 00:08:53.080
So that's already asynchronous or can be, but it's the document mapper that's the problem.

00:08:53.080 --> 00:08:57.400
You need the library that talks to the database to have an async option.

00:08:57.580 --> 00:09:02.160
So for example, like let's take something that people know more about probably SQLAlchemy, right?

00:09:02.160 --> 00:09:10.800
If you go to SQLAlchemy and you create a query and you say like order by or filter or whatever, you need SQLAlchemy to be rewritten.

00:09:10.800 --> 00:09:16.440
So that filter is async is an async method or it's useless in terms that, right?

00:09:16.440 --> 00:09:20.020
So it's like the place you want to get to is interacting with your database asynchronously.

00:09:20.020 --> 00:09:26.020
But if the ODM or ORM that you're working with in the middle doesn't support that, there's zero workaround.

00:09:26.020 --> 00:09:27.520
You're done, right?

00:09:27.520 --> 00:09:28.760
You cannot do that.

00:09:28.760 --> 00:09:33.740
Whereas most of the things you're doing is waiting on either web services or you're waiting on databases.

00:09:33.740 --> 00:09:36.380
And that's where you would get like the massive scalability.

00:09:36.660 --> 00:09:42.860
Another thing that's really cool here is there is something called motor, which is another async way of programming against MongoDB.

00:09:42.860 --> 00:09:46.640
But this one will let you choose the foundational bits.

00:09:46.640 --> 00:09:48.920
So you can say, I don't care about asynchronous programming.

00:09:49.140 --> 00:09:51.060
So I just want the base to be PyMongo.

00:09:51.060 --> 00:09:53.600
Or you can have TXMongo.

00:09:53.600 --> 00:10:00.300
Or you can use motor async, which is something from Jesse Davis, I believe, at MongoDB.

00:10:00.300 --> 00:10:01.820
Or you'll like this, Brian.

00:10:01.820 --> 00:10:08.340
You can even say the driver, the foundational database access part of this ODM is MongoMock.

00:10:08.340 --> 00:10:13.760
So if you want, you can just say actually replace the internals with this mocking database layer for testing.

00:10:13.760 --> 00:10:15.540
Oh, actually, that's pretty cool.

00:10:15.540 --> 00:10:16.640
Okay.

00:10:16.640 --> 00:10:17.500
Neat.

00:10:17.500 --> 00:10:19.800
Yeah, so this is, I haven't used it.

00:10:19.800 --> 00:10:21.340
I generally use Mongo Engine.

00:10:21.340 --> 00:10:24.580
But this is really looking quite promising and powerful.

00:10:24.580 --> 00:10:27.000
So definitely want to give a shout out to that.

00:10:27.000 --> 00:10:29.940
Speaking of shout outs, let's give a shout out to DigitalOcean.

00:10:29.940 --> 00:10:32.080
So DigitalOcean is sponsoring this episode.

00:10:32.080 --> 00:10:39.140
And they have a great, very affordable, very reliable service over at DigitalOcean.com.

00:10:39.140 --> 00:10:41.460
So our stuff runs on DigitalOcean.

00:10:41.460 --> 00:10:45.180
We have a couple of servers doing all the magic, including one doing MongoDB.

00:10:45.360 --> 00:10:48.540
Back there somewhere in New York City, I think it is.

00:10:48.540 --> 00:10:50.100
Anyway, they're super great.

00:10:50.100 --> 00:10:51.740
Go over there and create a virtual machine.

00:10:51.740 --> 00:10:54.560
Get an awesome machine for five bucks a month.

00:10:54.560 --> 00:10:56.200
Get it set up in 30 seconds.

00:10:56.200 --> 00:10:57.300
And off you go.

00:10:57.300 --> 00:11:02.840
If you want to create something more pre-configured, they have a bunch of one-click apps to say set

00:11:02.840 --> 00:11:05.740
up like a ghost blog for five bucks a month for one click.

00:11:05.740 --> 00:11:06.460
Things like that.

00:11:06.520 --> 00:11:08.940
So check them out at pythonbytes.fm/DigitalOcean.

00:11:08.940 --> 00:11:10.760
You get $100 credit for a new user.

00:11:10.760 --> 00:11:13.220
And you'll let them know you're supporting the show.

00:11:13.220 --> 00:11:15.600
And thanks for them supporting the show.

00:11:15.600 --> 00:11:19.280
So, Brian, what's up with this statistics stuff here?

00:11:19.280 --> 00:11:21.480
I've not done statistics for a really long time.

00:11:21.480 --> 00:11:30.220
I'm one for saying that I've been known to oppose the stringent math requirements in a lot of computer science and other science fields.

00:11:30.720 --> 00:11:36.860
But regardless, there's a lot of people that end up having to learn statistics.

00:11:36.860 --> 00:11:40.060
And I think statistics is a good thing to learn, at least some of the basics.

00:11:40.060 --> 00:11:45.200
Yeah, I think we often come into, like, even going through computer science, you might not even take statistics.

00:11:45.200 --> 00:11:49.480
You probably took calculus and differential equations and other stuff that you never, ever use again.

00:11:49.480 --> 00:11:49.880
Right.

00:11:49.880 --> 00:11:50.820
Yeah, exactly.

00:11:50.820 --> 00:11:51.440
Yeah.

00:11:51.440 --> 00:11:54.460
Let's not go down that tangent too far.

00:11:54.460 --> 00:11:58.660
We'll all start crying about remembering how much work we put into learning that stuff, right?

00:11:58.660 --> 00:12:03.680
I know I have never needed to factor a polynomial, ever, in real life.

00:12:03.680 --> 00:12:06.200
How about computing the inverse of a non-segular matrix?

00:12:06.200 --> 00:12:07.880
Sorry, let's keep going on statistics.

00:12:07.880 --> 00:12:14.600
However, sometimes I do need to know, like, averages and medians and stuff like that.

00:12:14.600 --> 00:12:16.800
So this is, I'm highlighting this article.

00:12:16.800 --> 00:12:21.640
It's called the Basic Statistics in Python, Descriptive Statistics.

00:12:21.640 --> 00:12:35.300
And I like it, it's just using some simple Python to demonstrate how you would build up some simple statistics concepts to teach the concepts, like min, max, mean, median, mode.

00:12:35.300 --> 00:12:37.280
Some of the others, like standard deviation.

00:12:37.280 --> 00:12:39.180
It's just a handful of them.

00:12:39.600 --> 00:12:43.080
But those are kind of hard things to get your head around when you're first looking at it.

00:12:43.080 --> 00:12:46.780
So being able to play with the numbers with a computer, I think, is a neat thing.

00:12:46.780 --> 00:12:52.800
So they give some descriptions on how you would implement some of these functions in Python.

00:12:52.800 --> 00:12:53.980
Oh, yeah, that's nice.

00:12:53.980 --> 00:12:55.180
It does a nice job.

00:12:55.680 --> 00:13:04.180
Like, for instance, if you wanted to figure out the average, you can take the sum of all of everything and then take how many scores.

00:13:04.180 --> 00:13:06.280
And it's like the sum divided by how many.

00:13:06.280 --> 00:13:08.360
Those are good concepts to look at.

00:13:08.360 --> 00:13:17.980
The thing that was missing out of it is the little bit at the end, I think, that says, by the way, don't ever do this if you're actually writing Python code.

00:13:17.980 --> 00:13:19.820
Because all this stuff's already built in.

00:13:19.820 --> 00:13:20.300
Exactly.

00:13:20.300 --> 00:13:23.300
Yeah, you've got the various numerical libraries for it, right?

00:13:23.300 --> 00:13:24.900
Isn't this stuff already built in?

00:13:25.320 --> 00:13:29.320
And, you know, min and max are already built in just normally and some of the others.

00:13:29.320 --> 00:13:35.560
But I actually went and looked and found I didn't know about the statistics module.

00:13:35.560 --> 00:13:40.140
That's built in, I think, as of 3.4 or 3.5 or something.

00:13:40.140 --> 00:13:40.740
That's right.

00:13:40.740 --> 00:13:41.540
It's quite new.

00:13:41.540 --> 00:13:42.400
I don't remember.

00:13:42.400 --> 00:13:44.000
But I think it might be 3.5, actually.

00:13:44.000 --> 00:13:44.900
3.4.

00:13:44.900 --> 00:13:45.960
3.4.

00:13:45.960 --> 00:13:46.700
Thank you, Bob.

00:13:46.700 --> 00:13:47.220
Okay.

00:13:47.220 --> 00:13:49.440
But I threw in some examples.

00:13:49.440 --> 00:13:55.080
But, you know, if you're just using that, it doesn't help you learn what statistics is.

00:13:55.080 --> 00:13:57.320
So that's why I think the article is still good.

00:13:57.320 --> 00:13:58.420
I stuck up.

00:13:58.420 --> 00:14:07.180
I was looking at the statistics and I noticed that it had both standard deviation variance and population standard deviation and population variance.

00:14:07.600 --> 00:14:11.020
I don't know enough statistics to know what the difference in those are.

00:14:12.060 --> 00:14:14.180
I know P goes in front of the method name.

00:14:14.180 --> 00:14:17.520
No, that's awesome that that's in there.

00:14:17.520 --> 00:14:22.160
Yeah, I think it's interesting that they added that module into the standard library in 3.4.

00:14:22.160 --> 00:14:22.960
It's cool.

00:14:22.960 --> 00:14:27.960
Yeah, I guess maybe they were tired of people implementing them in crazy hand-coded ways.

00:14:28.120 --> 00:14:33.280
Yeah, and it's got to be faster written in C to compute the variance than to do it in, like, a Python loop.

00:14:33.280 --> 00:14:34.040
That's a good point.

00:14:34.040 --> 00:14:44.560
Yeah, and it, again, goes to say that always keep up with the standard library because there's so much stuff in there that can save you writing code and probably gain you performance.

00:14:44.560 --> 00:14:45.860
Yeah, absolutely.

00:14:45.860 --> 00:14:47.540
All right, Bob, what's the next one you got here?

00:14:47.720 --> 00:14:48.980
This is a big piece.

00:14:48.980 --> 00:14:52.980
Strings and character data in Python by real Python.

00:14:52.980 --> 00:14:54.880
I don't have the...

00:14:54.880 --> 00:14:57.480
If it's by real Python, you know it's kind of like a novella.

00:14:57.480 --> 00:15:05.080
Yeah, exactly, because I want to compare it with that AetherTools article you featured a couple of weeks ago.

00:15:05.080 --> 00:15:09.320
That was, like, this long piece that took me an hour to read, but I got so much out of that.

00:15:09.320 --> 00:15:10.720
And it's the same here.

00:15:10.720 --> 00:15:13.220
I didn't even, honestly, didn't finish it yet.

00:15:13.220 --> 00:15:17.300
I'm, like, 60, 70% in and already got so much value out of it.

00:15:17.840 --> 00:15:25.760
Because it does this great detailed tour of strings in Python and all the methods you can use on them.

00:15:25.760 --> 00:15:33.540
And I put some snippets in the show notes because, I mean, for a beginner, it's great because you will be working with strings from day one.

00:15:33.540 --> 00:15:40.840
But even if you know Python, there's, like, a lot of these little tricks in there that can just make you faster in Python.

00:15:41.260 --> 00:15:47.000
If a string is a digit, you can use isDigit on the string, which returns a Boolean.

00:15:47.000 --> 00:15:52.700
Rather than try to convert it to an int, catch the exception, go, looks like it's not an int.

00:15:52.700 --> 00:15:53.780
Yeah, that kind of thing.

00:15:53.820 --> 00:15:55.100
Yeah, so you can use that method.

00:15:55.100 --> 00:15:59.880
Or, for example, you want to look for white space, a space, a tab, or a new line.

00:15:59.880 --> 00:16:03.840
There's also an isSpace method that does that for you.

00:16:03.840 --> 00:16:09.260
Or commonly with terminal apps, you want to have this banner with the text centered.

00:16:09.780 --> 00:16:16.200
Well, you can just do string, center, and then the width, and then the filler character.

00:16:16.200 --> 00:16:19.040
So there's a lot of good stuff in there.

00:16:19.040 --> 00:16:23.860
And I think it's worth to go and spend that hour and learn all that stuff.

00:16:23.860 --> 00:16:27.880
Because, I mean, it will just shave off time when you're actually coding.

00:16:27.880 --> 00:16:32.860
And another thing I also found, kind of the linking you do when you read such an article.

00:16:32.860 --> 00:16:35.320
For example, polymorphism, right?

00:16:35.400 --> 00:16:39.860
If you have the index method, it works on a string, but it also works on a list.

00:16:39.860 --> 00:16:45.400
So I put a snippet in the show notes that I use index on a string and a list.

00:16:45.400 --> 00:16:48.280
And you see that they behave in a similar way.

00:16:48.280 --> 00:16:49.740
Same goes for count.

00:16:49.740 --> 00:16:53.140
So I found that also an interesting point to highlight.

00:16:53.140 --> 00:16:53.680
Oh, yeah.

00:16:53.680 --> 00:16:54.480
This is really interesting.

00:16:54.480 --> 00:16:56.020
I just threw that into Instapaper.

00:16:56.020 --> 00:16:58.980
And Instapaper says, reading time, 33 minutes.

00:16:58.980 --> 00:17:03.000
Yeah, this is definitely, it's like a book chapter almost on strings, character strings.

00:17:03.000 --> 00:17:04.640
I might be a slow reader, but.

00:17:04.640 --> 00:17:06.560
Well, I'm sure I would, too.

00:17:06.560 --> 00:17:08.900
And, you know, that's not counting that it's like code.

00:17:08.900 --> 00:17:11.240
Code you got to analyze, right?

00:17:11.240 --> 00:17:11.740
Yeah.

00:17:11.740 --> 00:17:13.100
You want to try some things.

00:17:13.100 --> 00:17:13.480
Yeah.

00:17:13.480 --> 00:17:13.660
Yeah.

00:17:13.660 --> 00:17:13.940
Yeah.

00:17:13.940 --> 00:17:14.980
Exactly.

00:17:14.980 --> 00:17:15.380
Exactly.

00:17:15.380 --> 00:17:16.260
That's a great find.

00:17:16.260 --> 00:17:17.000
It's really cool.

00:17:17.000 --> 00:17:20.620
And people coming from different languages, I know I was like this.

00:17:20.620 --> 00:17:26.360
I did not expect that strings would have all of these cool operations on them.

00:17:26.360 --> 00:17:26.600
Yeah.

00:17:26.600 --> 00:17:32.700
Especially if you're coming from C, where strings are really just, you know, character, pointer, array type things.

00:17:32.700 --> 00:17:34.220
They're basically just memory, right?

00:17:34.380 --> 00:17:34.660
Yeah.

00:17:34.660 --> 00:17:35.080
Yeah.

00:17:35.080 --> 00:17:39.120
But imagine you have to do that, leaving zeros to a number.

00:17:39.120 --> 00:17:41.800
And that would take you a couple lines of code.

00:17:41.800 --> 00:17:47.020
In Python, it's just a number, string, z fill, and then the number of zeros you want to be penned.

00:17:47.020 --> 00:17:48.840
And it just makes for shorter code.

00:17:48.840 --> 00:17:49.560
Yeah, it's wonderful.

00:17:49.560 --> 00:17:50.300
Z fill?

00:17:50.300 --> 00:17:50.940
Who's he?

00:17:51.100 --> 00:17:51.480
Yeah.

00:17:51.480 --> 00:17:51.520
Yeah.

00:17:51.520 --> 00:17:51.520
Yeah.

00:17:51.520 --> 00:17:57.760
So, you want to have 42, for example, and it needs to be a width of five.

00:17:57.860 --> 00:18:00.200
You can just set fill it with zeros.

00:18:00.200 --> 00:18:02.440
Nice.

00:18:02.680 --> 00:18:07.920
So, I'm going to close this out with something that is surprisingly controversial.

00:18:07.920 --> 00:18:09.220
I don't know.

00:18:09.220 --> 00:18:10.640
I'll see what your thoughts are.

00:18:11.300 --> 00:18:13.120
So, there's a new PEP in town.

00:18:13.120 --> 00:18:13.140
So, there's a new PEP in town.

00:18:13.140 --> 00:18:15.220
Pep 572.

00:18:15.220 --> 00:18:20.240
And whenever I think about these things, I always think, you know, someone has worked super hard on this.

00:18:20.240 --> 00:18:21.900
And that's really awesome.

00:18:21.900 --> 00:18:23.020
They're making a contribution.

00:18:23.260 --> 00:18:28.780
And then, you know, to see people react in, I don't know, not totally excited ways.

00:18:28.780 --> 00:18:29.680
I don't know.

00:18:29.680 --> 00:18:31.520
It's sort of, I don't know how to feel about it, let's say.

00:18:31.520 --> 00:18:41.680
But there's a new piece of Python syntax that will allow you to, in a single expression, create a variable and assign to it.

00:18:41.680 --> 00:18:55.020
So, so often you have to do something to the effect of, like, I'm going to create a variable, set a value, and then if that value is something, I'm going to do a thing or I'm going to do something else.

00:18:55.020 --> 00:19:01.380
So, the new syntax lets you put a colon equals to define that and put it all in one line.

00:19:01.380 --> 00:19:12.460
So, instead of saying, like, match equals pattern.search, if match is not none, et cetera, et cetera, you can just say, if match colon equals pattern.search is not none, all in one.

00:19:12.460 --> 00:19:14.600
I'm actually even confused about your example.

00:19:14.600 --> 00:19:20.440
I thought that the point to that new operator was explicitly to check against none.

00:19:20.440 --> 00:19:29.960
The point of the thing is to allow you to both create the variable and set its initial value and check it at the same time, whatever you're checking it for.

00:19:29.960 --> 00:19:31.140
Oh, right.

00:19:31.300 --> 00:19:32.500
And you don't even have to check it.

00:19:32.500 --> 00:19:39.700
For example, one of the really common use cases for this is to use it in, like, a list comprehension or something like that.

00:19:39.700 --> 00:19:47.220
And any time you need more than one line, that cannot be put into a list comprehension or a lambda expression, right?

00:19:47.220 --> 00:19:59.040
But now, with this one line variable creation assignment potential test behavior, you can put these into inline expressions like list comprehensions or lambdas or so on.

00:19:59.040 --> 00:20:00.460
I think that's it.

00:20:00.500 --> 00:20:03.380
I've only skimmed some of the use cases, but that's what I'm thinking it's for.

00:20:03.380 --> 00:20:03.740
Okay.

00:20:03.900 --> 00:20:05.100
So this is interesting.

00:20:05.100 --> 00:20:05.600
So this is interesting.

00:20:05.600 --> 00:20:06.940
The syntax is not terrible.

00:20:06.940 --> 00:20:08.080
I think it's kind of okay.

00:20:08.080 --> 00:20:13.760
There's already lots of examples of this in other languages that had pretty decent implementations.

00:20:13.760 --> 00:20:17.000
So one of my thoughts was like, well, why didn't that get adopted?

00:20:17.000 --> 00:20:27.700
So both in like C# link expressions as well as JavaScript expressions, you have let something equals a value in terms of like a, like in terms of a for loop or something like that.

00:20:27.700 --> 00:20:29.840
That could have also been an interesting option.

00:20:29.840 --> 00:20:31.420
But I don't know.

00:20:31.520 --> 00:20:32.720
To me, it's okay.

00:20:32.720 --> 00:20:35.600
But I don't know that it's necessarily needed for the language.

00:20:35.600 --> 00:20:39.640
Like it's not solving a problem that I think very many people actually have.

00:20:39.640 --> 00:20:46.860
I wouldn't have to use it and see it in other people's code because from the snippet you posted, I find it a bit confusing.

00:20:46.860 --> 00:20:50.120
It might just be me having to get used to it.

00:20:50.180 --> 00:20:54.320
But it's not the kind of syntax I'm used to from Python, right?

00:20:54.320 --> 00:20:55.680
Which is more readable.

00:20:55.680 --> 00:20:57.100
What do you guys think?

00:20:57.100 --> 00:21:01.580
To me, it's like one step down the slippery slope.

00:21:01.580 --> 00:21:03.620
You know, I mentioned C# and the let stuff.

00:21:03.620 --> 00:21:06.280
And I feel like the C# language used to be pretty nice.

00:21:06.280 --> 00:21:07.900
And it's just a complete train wreck.

00:21:07.900 --> 00:21:11.220
Now, there's all these little three or four ways of doing the same thing.

00:21:11.220 --> 00:21:13.240
And they're all getting like a few characters shorter.

00:21:13.240 --> 00:21:14.640
But now there's five of them.

00:21:14.640 --> 00:21:16.520
They're all more or less equivalent.

00:21:16.520 --> 00:21:20.000
It's just like, whoa, why do we keep adding these things to this language?

00:21:20.000 --> 00:21:21.080
They're just unneeded.

00:21:21.080 --> 00:21:24.220
And I feel like this is sort of in that category of stuff.

00:21:24.220 --> 00:21:25.820
Python's nowhere near as bad.

00:21:25.820 --> 00:21:33.800
Might not be the PEP itself, but more what we start to introduce and what other syntax changes

00:21:33.800 --> 00:21:34.800
that might be coming, right?

00:21:34.800 --> 00:21:36.480
If you open it up for this.

00:21:36.480 --> 00:21:37.000
Yeah.

00:21:37.000 --> 00:21:42.260
So what I want to sort of point people at for this is the tweet by Raymond Hedner.

00:21:42.260 --> 00:21:47.580
And then the Twitter conversation that follows it, which is really interesting.

00:21:47.580 --> 00:21:49.820
Like you don't normally see this much conversation

00:21:49.820 --> 00:21:51.300
in a thread on Twitter.

00:21:51.300 --> 00:21:55.400
But there's like 44 messages onto this one tweet.

00:21:55.400 --> 00:21:57.640
And it's pretty interesting.

00:21:57.640 --> 00:21:59.100
Some people like it.

00:21:59.100 --> 00:22:00.400
Some people don't.

00:22:00.400 --> 00:22:01.620
But I think it's worth reading through.

00:22:01.620 --> 00:22:02.020
Nice.

00:22:02.020 --> 00:22:03.400
So anyway, new PEP in town.

00:22:03.400 --> 00:22:04.500
And it's approved, right?

00:22:04.500 --> 00:22:05.480
This is not proposed.

00:22:05.480 --> 00:22:07.100
My understanding is this is approved.

00:22:07.320 --> 00:22:10.560
So it's now going to be part of maybe Python 3.8.

00:22:10.560 --> 00:22:10.800
Wow.

00:22:10.800 --> 00:22:11.000
Yeah.

00:22:11.000 --> 00:22:12.340
I'll totally use it.

00:22:12.340 --> 00:22:13.160
But it is.

00:22:13.160 --> 00:22:13.820
It did one.

00:22:13.820 --> 00:22:20.080
It was one thing that made Python different was that like in C, if you tried to do check

00:22:20.080 --> 00:22:24.520
for equality and you accidentally did assignment instead, it's wrong.

00:22:25.100 --> 00:22:30.480
And I guess that's why the syntax is specific so that it's not going to be an accident.

00:22:30.480 --> 00:22:31.160
Right.

00:22:31.220 --> 00:22:37.760
In C, you could say something to the effect of like, if match equals pattern.match, do

00:22:37.760 --> 00:22:38.400
such and such.

00:22:38.400 --> 00:22:38.860
Right.

00:22:38.860 --> 00:22:41.700
And you actually meant if those two things were actually equal.

00:22:41.700 --> 00:22:41.940
Right.

00:22:41.940 --> 00:22:42.680
So there's a way.

00:22:42.680 --> 00:22:47.140
The syntax does make that sort of fall through error case not actually.

00:22:47.140 --> 00:22:50.400
You can't omit an equal on accident and actually get assignment.

00:22:50.400 --> 00:22:50.840
Yeah.

00:22:50.840 --> 00:22:53.140
You have to explicitly put the colon in there.

00:22:53.140 --> 00:22:53.880
It's colon equal.

00:22:53.880 --> 00:22:54.460
So.

00:22:54.460 --> 00:22:54.880
Mm-hmm.

00:22:54.940 --> 00:22:55.300
Okay.

00:22:55.300 --> 00:22:56.140
All right.

00:22:56.140 --> 00:22:57.220
Well, there it is.

00:22:57.220 --> 00:23:01.360
PEP 572, the most controversial accepted PEP I've heard in a little while.

00:23:01.360 --> 00:23:01.920
Pretty interesting.

00:23:01.920 --> 00:23:02.920
All right.

00:23:02.920 --> 00:23:04.320
Well, that's it for our news items, you guys.

00:23:04.320 --> 00:23:07.380
Brian, you got anything else you want to share with the world these days?

00:23:07.380 --> 00:23:08.240
What's going on?

00:23:08.240 --> 00:23:12.820
Well, actually, kind of nice tie-in with this PEP 572.

00:23:12.820 --> 00:23:19.140
I wanted to just talk with somebody about all the new stuff that's actually proposed and

00:23:19.140 --> 00:23:21.640
accepted already for 3.8.

00:23:21.640 --> 00:23:24.060
And I think just for 3.8.

00:23:24.400 --> 00:23:27.160
So that's kind of what Anthony Shaw has been up to lately.

00:23:27.160 --> 00:23:31.740
So I'm going to have Anthony on testing code and we're going to talk about that.

00:23:31.740 --> 00:23:32.640
Oh, that's going to be great.

00:23:32.640 --> 00:23:38.660
I've also realized that doing this podcast with you, it's pretty easy to do it once a

00:23:38.660 --> 00:23:40.920
week because you're waiting for me to do it once a week.

00:23:40.920 --> 00:23:46.500
So I'm trying to rope in some other people and Anthony's one of the people that agreed

00:23:46.500 --> 00:23:50.240
to try to do testing code more regularly to try to get more of those out.

00:23:50.240 --> 00:23:51.060
Oh, yeah.

00:23:51.060 --> 00:23:51.560
That's awesome.

00:23:51.560 --> 00:23:52.020
Yeah.

00:23:52.020 --> 00:23:52.720
That's really cool.

00:23:52.720 --> 00:23:54.000
How about you, Michael?

00:23:54.000 --> 00:23:58.140
Well, if we want to give shout outs to Anthony, I just had him on Talk Python as well about

00:23:58.140 --> 00:23:58.920
his security article.

00:23:58.920 --> 00:23:59.820
He's really killing it.

00:23:59.820 --> 00:24:03.220
Him and the real Python guys, they're definitely cranking out the content.

00:24:03.220 --> 00:24:03.800
That's great.

00:24:03.800 --> 00:24:08.600
But the thing that I guess is the biggest news that has me getting up early and staying up

00:24:08.600 --> 00:24:14.860
late is I'm working on a new about 10 hour course for data driven apps in Pyramid with

00:24:14.860 --> 00:24:17.900
SQLAlchemy and like production migrations and all sorts of stuff.

00:24:17.900 --> 00:24:19.700
That is almost done.

00:24:19.760 --> 00:24:21.020
It should be out next week.

00:24:21.020 --> 00:24:25.320
I'm just finalizing a lot of the videos this week and it'll be rolling.

00:24:25.320 --> 00:24:25.740
Nice.

00:24:25.740 --> 00:24:26.200
Nice.

00:24:26.200 --> 00:24:26.740
Nice.

00:24:26.740 --> 00:24:27.420
So that's what I'm up to.

00:24:27.420 --> 00:24:29.200
Bob, how about you?

00:24:29.200 --> 00:24:31.240
You want to tell people about PyBytes real quick?

00:24:31.240 --> 00:24:31.720
What that is?

00:24:31.720 --> 00:24:32.040
Yeah.

00:24:32.040 --> 00:24:38.220
PyBytes started out as a blog with articles and we quickly moved into a blog code challenges

00:24:38.220 --> 00:24:40.740
and that got quite some traction.

00:24:40.740 --> 00:24:46.460
So we built out a code challenge platform, which you can find on codechallenge.es.

00:24:46.460 --> 00:24:51.880
So code challenges spelled as code challenges together, but ending in .es.

00:24:51.880 --> 00:24:56.540
And you can log in with GitHub and code in the browser.

00:24:56.540 --> 00:24:59.620
So there are exercises with automated pytest.

00:24:59.620 --> 00:25:01.100
Yes, Brian, it's pytest.

00:25:02.140 --> 00:25:05.800
And you can code in the browser and verify those exercises.

00:25:05.800 --> 00:25:07.860
And yeah, the feedback is great.

00:25:07.860 --> 00:25:12.180
I mean, people are learning a lot of Python that way because it's so practical.

00:25:12.180 --> 00:25:14.520
And so we're growing that.

00:25:14.520 --> 00:25:19.940
We have a Slack community behind it where a lot of people are joining and we have very good

00:25:19.940 --> 00:25:21.220
Pythonic discussions.

00:25:21.220 --> 00:25:24.780
So let's, yeah, I'm excited about this.

00:25:24.780 --> 00:25:25.380
Yeah, right on.

00:25:25.380 --> 00:25:26.320
Yeah, it's a cool platform.

00:25:26.320 --> 00:25:27.580
Happy to see you doing it.

00:25:27.920 --> 00:25:30.320
And thank you for being on the show, Brian.

00:25:30.320 --> 00:25:31.120
Thank you.

00:25:31.120 --> 00:25:32.380
Thank you, as always.

00:25:32.380 --> 00:25:34.560
I'm happy to hear you're doing more testing code as well.

00:25:34.560 --> 00:25:35.100
That's pretty sweet.

00:25:35.100 --> 00:25:35.460
Yeah.

00:25:35.460 --> 00:25:36.140
All right, catch you later.

00:25:36.140 --> 00:25:36.360
Bye.

00:25:36.360 --> 00:25:40.680
Thank you for listening to Python Bytes.

00:25:40.680 --> 00:25:43.240
Follow the show on Twitter via at Python Bytes.

00:25:43.240 --> 00:25:46.140
That's Python Bytes as in B-Y-T-E-S.

00:25:46.140 --> 00:25:49.580
And get the full show notes at pythonbytes.fm.

00:25:49.580 --> 00:25:53.900
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:25:53.900 --> 00:25:56.640
We're always on the lookout for sharing something cool.

00:25:57.260 --> 00:26:00.000
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:26:00.000 --> 00:26:03.620
Thank you for listening and sharing this podcast with your friends and colleagues.

