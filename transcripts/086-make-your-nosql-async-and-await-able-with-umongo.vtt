
00:00:00.000 --> 00:00:05.600
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:05.600 --> 00:00:10.800
This is episode 86 recorded July 11th, 2018. I'm Michael Kennedy.


00:00:10.800 --> 00:00:11.600
And I'm Brian Atkin.


00:00:11.600 --> 00:00:14.600
And Brian, we have a new special guest, Bob Belderbose.


00:00:14.600 --> 00:00:15.400
Yeah, pretty excited.


00:00:15.400 --> 00:00:16.100
Yeah, welcome Bob.


00:00:16.100 --> 00:00:18.200
Hey, nice to be here. Thanks.


00:00:18.200 --> 00:00:24.800
Yeah, so people may recognize Bob from his PyBytes with an I code challenge stuff that he does,


00:00:24.800 --> 00:00:27.200
as well as the 100 days of code course that we did together, right?


00:00:27.200 --> 00:00:33.040
Yeah, we did a major course on 100 days of code in Python.


00:00:33.040 --> 00:00:34.240
It was very fun.


00:00:34.240 --> 00:00:38.320
Yeah, it was only what 20 hours of video and 80 hours of exercise.


00:00:38.320 --> 00:00:40.040
Yeah, that was awesome.


00:00:40.040 --> 00:00:41.200
So welcome to the show.


00:00:41.200 --> 00:00:43.160
We're super excited to have you here.


00:00:43.160 --> 00:00:47.580
Before we get into everything, let's just say thank you to DigitalOcean, our customer


00:00:47.580 --> 00:00:49.600
and their sponsor, our show as well.


00:00:49.600 --> 00:00:53.080
Check them out at pythonbytes.fm/digitalocean.


00:00:53.080 --> 00:00:55.560
You'll get $100 free credit if you're a new user.


00:00:55.560 --> 00:00:56.560
That's pretty awesome.


00:00:56.560 --> 00:01:00.000
Brian, if I had to guess if I were just going to like pick out of like thin air, what kind


00:01:00.000 --> 00:01:02.400
of topic you might have, it might have something to do with testing.


00:01:02.400 --> 00:01:05.600
I do like testing quite a bit.


00:01:05.600 --> 00:01:06.560
So what do you got for us?


00:01:06.560 --> 00:01:11.040
Well, we have responses. And this is it. There's a funny story around it. But this is a


00:01:11.040 --> 00:01:19.120
responses is a utility library for mocking out requests Python library. And it's from


00:01:19.120 --> 00:01:25.360
it's from get century. So it's under the get century, GitHub account. And it looks pretty


00:01:25.360 --> 00:01:31.440
cool. It's actually, we'll include a small snippet in our show notes, but there's, it's a decorator


00:01:31.440 --> 00:01:38.480
approach to, and other ways to be able to test your, pretty much mock out if you have an application


00:01:38.480 --> 00:01:45.120
that uses requests to access any, really any end point on the internet, you can use this to mock


00:01:45.120 --> 00:01:51.680
out those. And it has some dynamic, dynamicness to it. And it's, it looks actually pretty complete


00:01:51.680 --> 00:01:52.680
and pretty nice.


00:01:52.680 --> 00:01:53.680
It's pretty sweet.


00:01:53.680 --> 00:01:56.920
Yeah, you put an attribute on your your function.


00:01:56.920 --> 00:02:01.840
And during that one, any call to requests like request I get or the response JSON or


00:02:01.840 --> 00:02:06.880
whatever is going to be basically overridden as if you had done that with patch, but it's


00:02:06.880 --> 00:02:09.480
a little more focused on just requests, right?


00:02:09.480 --> 00:02:11.160
Yeah, it's focused on requests.


00:02:11.160 --> 00:02:16.800
And it's also it's designed to go well with the pytest framework.


00:02:16.800 --> 00:02:19.560
So it cleans up after itself really easily.


00:02:19.560 --> 00:02:20.560
Nice.


00:02:20.560 --> 00:02:22.720
with pytest? Like what's special about that?


00:02:22.720 --> 00:02:25.320
Yeah, the decorator you put on your test is like


00:02:25.320 --> 00:02:28.080
responses activate. So it'll


00:02:28.080 --> 00:02:30.080
and then you're going to have it


00:02:30.080 --> 00:02:32.320
you register an end point


00:02:32.320 --> 00:02:34.360
to mark and what response it should


00:02:34.360 --> 00:02:36.520
give. And then all of that


00:02:36.520 --> 00:02:38.600
gets cleaned up at the end of the test. You don't have


00:02:38.600 --> 00:02:40.600
to undo it or anything like that. Yeah,


00:02:40.600 --> 00:02:42.780
that's awesome. Very nice. The funny


00:02:42.780 --> 00:02:44.960
thing is, is this is exactly what


00:02:44.960 --> 00:02:47.320
Anthony and I were


00:02:47.320 --> 00:02:49.320
considering building together. We just


00:02:49.320 --> 00:02:51.020
didn't know this one existed.


00:02:51.020 --> 00:02:53.360
And so I wanted to point it out because


00:02:53.360 --> 00:02:56.960
your responses is a clever name to go with requests.


00:02:56.960 --> 00:02:58.000
I get it.


00:02:58.000 --> 00:03:00.360
But if I'm trying to find something that goes well


00:03:00.360 --> 00:03:03.600
with pytest and goes well with requests,


00:03:03.600 --> 00:03:06.880
I might not know to search for responses.


00:03:06.880 --> 00:03:09.020
So that's why I'm violating it out.


00:03:09.020 --> 00:03:11.680
So I think anybody that's trying to do something like this


00:03:11.680 --> 00:03:12.520
should check it out.


00:03:12.520 --> 00:03:13.560
It looks pretty complete.


00:03:13.560 --> 00:03:15.080
- Cool. It looks very useful.


00:03:15.080 --> 00:03:18.060
So it's not making any call over the network, right?


00:03:18.060 --> 00:03:20.860
That's the whole point of patching it out, right?


00:03:20.860 --> 00:03:26.060
Well, it's patching, it'll patch out the endpoints you specify.


00:03:26.060 --> 00:03:28.820
I don't really know, I don't know what the behavior is for other ones.


00:03:28.820 --> 00:03:30.820
It probably lets everything else go through.


00:03:30.820 --> 00:03:32.220
Yeah, that's one of the things I like about it.


00:03:32.220 --> 00:03:39.700
As you say, this, if I request this HTTP endpoint, then do this, rather than I'm just replacing,


00:03:39.700 --> 00:03:41.660
you know, request.get with everything.


00:03:41.660 --> 00:03:42.660
Right, right.


00:03:42.660 --> 00:03:43.780
Oh, yeah, pretty nice.


00:03:43.780 --> 00:03:50.380
I do see your point about SEO and discoverability for responses, because like response and responses


00:03:50.380 --> 00:03:54.140
is just such a common word on so many API libraries.


00:03:54.140 --> 00:03:56.340
Like, how are you going to find the testing one?


00:03:56.340 --> 00:04:01.820
Yeah, I was looking, it says in its description that it's Python 2.7 or newer.


00:04:01.820 --> 00:04:05.780
Well, so it isn't obvious to me that it was 3x.


00:04:05.780 --> 00:04:11.340
But it looks in like in the investigate the talks any file, it's tested up through three


00:04:11.340 --> 00:04:12.460
five at least.


00:04:12.460 --> 00:04:15.860
So it's probably three, six, three, seven compatible too.


00:04:15.860 --> 00:04:17.860
Haven't tried it, but yeah, probably.


00:04:17.860 --> 00:04:18.860
Yeah, very nice.


00:04:18.860 --> 00:04:20.500
All right, Bob, it's time for yours.


00:04:20.500 --> 00:04:21.500
What one did you bring?


00:04:21.500 --> 00:04:28.100
Yeah, I found an interesting decision tree article 29 common beginner Python errors on


00:04:28.100 --> 00:04:30.180
one page.


00:04:30.180 --> 00:04:35.380
And I found this interesting because these kind of decision trees or graphics, you get


00:04:35.380 --> 00:04:41.180
a lot of information in one page, you can print out or study in detail.


00:04:41.180 --> 00:04:42.380
It's like a flow.


00:04:42.380 --> 00:04:46.100
It's like an infographic for like getting my code to work.


00:04:46.100 --> 00:04:47.100
It's amazing.


00:04:47.100 --> 00:04:48.100
Yeah.


00:04:48.100 --> 00:04:49.100
It didn't land directly on the article actually.


00:04:49.100 --> 00:04:53.980
It was a Microsoft devs that tweeted it out and that's how I found it on the Python has


00:04:53.980 --> 00:04:55.360
hashtag.


00:04:55.360 --> 00:04:56.860
And it goes through this whole flow.


00:04:56.860 --> 00:04:59.520
Like what kind of error do you get?


00:04:59.520 --> 00:05:04.700
And then it goes into these common Python errors, like attribute error, syntax error,


00:05:04.700 --> 00:05:05.700
type errors.


00:05:05.700 --> 00:05:09.740
And for each one, it gives like a couple of plausible causes.


00:05:09.740 --> 00:05:14.620
Yeah, I mean, if you have more experience, some might be obvious, but some are very subtle.


00:05:14.620 --> 00:05:21.820
And that was like a great reminder, like comparing three int with a three string that returns


00:05:21.820 --> 00:05:22.820
false.


00:05:22.820 --> 00:05:29.500
And for example, when I was going through it also could relate to similar things like


00:05:29.500 --> 00:05:32.860
when you exhaust a file that also can happen with a generator, right?


00:05:32.860 --> 00:05:37.700
A generator, you go through it once and then if you do that again, then hey, it's like


00:05:37.700 --> 00:05:42.560
an empty list because the generator only, you can only consume once.


00:05:42.560 --> 00:05:42.880
Right.


00:05:42.880 --> 00:05:48.380
So it was a nice, I guess, exercise to take a lot of info in from one infograph.


00:05:48.380 --> 00:05:52.340
And I think for a beginner, it's very useful to go through that at least once.


00:05:52.340 --> 00:05:57.760
And I think the author made the infograph after having teached Python


00:05:57.760 --> 00:06:01.900
for a long time in the biology space.


00:06:01.900 --> 00:06:05.840
So that was also inspiring for me, like teaching others.


00:06:06.080 --> 00:06:09.200
Yeah, how you could summarize that information at some point.


00:06:09.200 --> 00:06:12.480
I'll try to give a quick summary just so people can get the visual.


00:06:12.480 --> 00:06:16.480
So it's like an infographing. It says, "Start here. Do you get an error when you run your code?


00:06:16.480 --> 00:06:19.440
Yes. What type of error do you get?" And there's a whole branch there. "No.


00:06:19.440 --> 00:06:22.960
Does your code use loops or if statements? If you use an if statement, go check this."


00:06:22.960 --> 00:06:26.720
You know, it just like walks you through some pretty basic stuff. I kind of like it.


00:06:26.720 --> 00:06:27.520
Brian, what do you think?


00:06:27.520 --> 00:06:31.680
Yeah, actually, this is one that I've run across before.


00:06:31.680 --> 00:06:37.120
And when our team started using Python for testing, one of the other engineers actually


00:06:37.120 --> 00:06:41.440
printed this out and posted it on the side of their cubicle so that people that came


00:06:41.440 --> 00:06:43.600
and asked them questions could just look at that first.


00:06:43.600 --> 00:06:44.720
Wow, that's pretty cool.


00:06:44.720 --> 00:06:49.440
And I like the fact that it's coming from Python for biologists.com.


00:06:49.440 --> 00:06:54.000
So we're seeing Python being taught in a lot of different domains, which is awesome.


00:06:54.000 --> 00:06:55.360
Yeah, that actually is a really good point.


00:06:55.360 --> 00:06:56.480
It's pretty awesome.


00:06:56.480 --> 00:07:00.920
So the next one that I have for us is this thing called micro Mongo, which


00:07:00.920 --> 00:07:03.880
somehow I have not heard of previously.


00:07:03.880 --> 00:07:08.400
But Brian, you know, I go on and on about async programming stuff and


00:07:08.400 --> 00:07:10.320
parallelism and things like that, right?


00:07:10.320 --> 00:07:10.860
Yes.


00:07:10.860 --> 00:07:13.920
And I do know that you kind of like Mongo DB also.


00:07:13.920 --> 00:07:17.520
This is like, this is like, I get to put them together.


00:07:17.520 --> 00:07:18.160
It's amazing.


00:07:18.160 --> 00:07:24.160
So one of the main challenges of this async await stuff actually becoming


00:07:24.160 --> 00:07:26.160
super useful and super powerful.


00:07:26.320 --> 00:07:30.900
There's two fundamental problems limiting the serious adoption of this.


00:07:30.900 --> 00:07:33.840
One is the web frameworks don't deeply support it.


00:07:33.840 --> 00:07:36.040
So I can't have an async flask method.


00:07:36.040 --> 00:07:39.840
I have to switch to something like Court or use Fibora or some other framework, like the


00:07:39.840 --> 00:07:43.640
main Django pyramid flask, they don't support async.


00:07:43.640 --> 00:07:47.320
So that's thing one, but we're seeing some movement there.


00:07:47.320 --> 00:07:52.680
But even if you could get that to work, a lot of the ORMs don't have great ways to take


00:07:52.680 --> 00:07:57.080
advantage of their parallelism or their potential parallelism, why they're waiting on the network


00:07:57.080 --> 00:08:00.120
talking to the database, because usually that's what your web app is doing.


00:08:00.120 --> 00:08:03.160
And that's why you would want the async is like you could let it do other processing


00:08:03.160 --> 00:08:05.120
while you're waiting on a database response.


00:08:05.120 --> 00:08:09.560
So what you need is if you're using an ORM or something equivalent called an ODM for


00:08:09.560 --> 00:08:15.420
Mongo is the ability to interact with those databases is in an async way.


00:08:15.420 --> 00:08:19.720
And so this micro Mongo is a very lightweight and small as you might imagine from the name


00:08:19.720 --> 00:08:27.420
object document mapper for MongoDB and Python that brings this ability to do async operations against MongoDB.


00:08:27.420 --> 00:08:32.820
So if you wanted to use say, Quart or Vibora, and you want to use MongoDB as the back end,


00:08:32.820 --> 00:08:35.360
you have to use something like this, which is pretty sweet.


00:08:35.360 --> 00:08:36.360
Very interesting.


00:08:36.360 --> 00:08:39.120
I need to go on the async train myself yet.


00:08:39.120 --> 00:08:41.420
So maybe this is a good opportunity to learn it.


00:08:41.420 --> 00:08:47.160
So definitely, it's not that, I mean, Mongo itself, you don't need, that's on the other end.


00:08:47.160 --> 00:08:50.880
So that's already asynchronous or can be,


00:08:50.880 --> 00:08:53.200
but it's the document mapper that's the problem.


00:08:53.200 --> 00:08:56.020
- You need the library that talks to the database


00:08:56.020 --> 00:08:57.800
to have an async option.


00:08:57.800 --> 00:08:59.480
So for example, like let's take something


00:08:59.480 --> 00:09:02.200
that people know more about probably SQLAlchemy, right?


00:09:02.200 --> 00:09:04.060
If you go to SQLAlchemy and you create a query


00:09:04.060 --> 00:09:08.060
and you say like order by or filter or whatever,


00:09:08.060 --> 00:09:11.040
you need SQLAlchemy to be rewritten


00:09:11.040 --> 00:09:14.200
so that filter is async, is an async method


00:09:14.200 --> 00:09:16.480
or it's useless in terms that, right?


00:09:16.480 --> 00:09:20.640
So it's like the place you want to get to is interact with your database asynchronously.


00:09:20.640 --> 00:09:25.040
But if the ODM or ORM that you're working with in the middle doesn't support that there's


00:09:25.040 --> 00:09:27.800
zero workaround, you're done, right?


00:09:27.800 --> 00:09:29.080
You cannot do that.


00:09:29.080 --> 00:09:32.760
Whereas most of the things you're doing is waiting on either web services, or you're


00:09:32.760 --> 00:09:34.020
waiting on databases.


00:09:34.020 --> 00:09:36.800
And that's where you would get like the massive scalability.


00:09:36.800 --> 00:09:40.280
Another thing that's really cool here is there, there is something called motor, which is


00:09:40.280 --> 00:09:43.320
another async way of programming against MongoDB.


00:09:43.320 --> 00:09:46.800
But this one will let you choose the foundational bits.


00:09:46.800 --> 00:09:49.360
So you can say I don't care about asynchronous programming.


00:09:49.360 --> 00:09:51.920
So I just want the base to be pi Mongo.


00:09:51.920 --> 00:09:59.040
Or you can have TX Mongo, or you can use motor async, which is something from Jesse Davis,


00:09:59.040 --> 00:10:00.760
I believe, at MongoDB.


00:10:00.760 --> 00:10:05.620
Or you like this, Brian, you can even say the driver, the foundational database access


00:10:05.620 --> 00:10:08.820
part of this ODM is Mongo mock.


00:10:08.820 --> 00:10:13.000
So if you want, you can just say actually replace the internals with this mocking database


00:10:13.000 --> 00:10:19.320
later for testing. Oh, actually, that's pretty cool. Yeah. Yeah. So this is this is not I haven't


00:10:19.320 --> 00:10:25.000
used it. I generally use Mongo engine, but this is really looking quite promising and powerful.


00:10:25.000 --> 00:10:29.320
So definitely want to give a shout out to that. Speaking of shout outs, let's give a shout out to


00:10:29.320 --> 00:10:35.800
DigitalOcean. So DigitalOcean is sponsoring this episode and they have a great, very affordable,


00:10:35.800 --> 00:10:42.200
very reliable service over at DigitalOcean.com. So our stuff runs on DigitalOcean. We have a couple


00:10:42.200 --> 00:10:47.880
servers doing all the magic including one doing MongoDB back there somewhere in New York City,


00:10:47.880 --> 00:10:51.640
I think it is. Anyway, they're super great. Go over there and create a virtual machine,


00:10:51.640 --> 00:10:57.400
get an awesome machine for five bucks a month, get it set up in 30 seconds, and off you go.


00:10:57.400 --> 00:11:01.880
If you want to create something more pre-configured, they have a bunch of one-click


00:11:01.880 --> 00:11:06.280
apps to say set up like a ghost blog for five bucks a month for one click, things like that.


00:11:06.280 --> 00:11:11.720
So check them out at pythonbytes.fm/digitalocean. You get $100 credit for a new user and you'll


00:11:11.720 --> 00:11:13.480
So let them know you're supporting the show,


00:11:13.480 --> 00:11:16.420
and thanks for them supporting the show.


00:11:16.420 --> 00:11:19.420
So Brian, what's up with this statistics stuff here?


00:11:19.420 --> 00:11:21.740
I've not done statistics for a really long time.


00:11:21.740 --> 00:11:25.080
- I'm one for saying that I've been known to oppose


00:11:25.080 --> 00:11:27.960
the stringent math requirements in a lot of


00:11:27.960 --> 00:11:30.900
computer science and other science fields,


00:11:30.900 --> 00:11:32.980
but regardless, there's a lot of people


00:11:32.980 --> 00:11:37.160
that end up being, that end up having to learn statistics.


00:11:37.160 --> 00:11:39.140
And I think statistics is a good thing to learn,


00:11:39.140 --> 00:11:40.340
at least some of the basics.


00:11:40.340 --> 00:11:45.260
I think we often come into like even going through computer science. You might not even take statistics


00:11:45.260 --> 00:11:51.320
You probably took calculus and differential equations and other stuff that you never ever use again, right? Yeah, exactly. Yeah


00:11:51.320 --> 00:11:54.440
Let's not go down that tangent too far


00:11:54.440 --> 00:11:58.600
Crying about remembering how much work we put into learning those stuff, right?


00:11:58.600 --> 00:12:03.540
I know I have never needed to factor a polynomial ever in real life


00:12:03.540 --> 00:12:07.940
How about computing the inverse of a non-secular matrix? Sorry, let's keep going on statistics


00:12:09.700 --> 00:12:14.660
However, sometimes I do need to know like averages and medians and stuff like that.


00:12:14.660 --> 00:12:21.060
So this is, I'm highlighting this article, it's called the basic statistics in Python,


00:12:21.060 --> 00:12:22.060
descriptive statistics.


00:12:22.060 --> 00:12:27.160
And I like it, it's just using some simple Python to demonstrate how you would build


00:12:27.160 --> 00:12:35.860
up some simple statistics concepts to teach the concepts like min max, mean, median, mode,


00:12:35.860 --> 00:12:38.020
some of the others like standard deviation.


00:12:38.020 --> 00:12:41.920
It's just a handful of them, but those are kind of hard things to get your head around


00:12:41.920 --> 00:12:43.220
when you're first looking at it.


00:12:43.220 --> 00:12:47.200
So being able to play with the numbers with a computer, I think is a neat thing.


00:12:47.200 --> 00:12:52.380
So they give some descriptions on how you would implement some of these functions in


00:12:52.380 --> 00:12:53.380
Python.


00:12:53.380 --> 00:12:54.380
>> Yeah, that's nice.


00:12:54.380 --> 00:12:55.380
>> It does a nice job.


00:12:55.380 --> 00:13:00.260
Like for instance, if you wanted to figure out the average, you can take the sum of all


00:13:00.260 --> 00:13:06.860
of everything and then take how many scores and it's like the sum divided by how many.


00:13:06.860 --> 00:13:08.720
Those are good concepts to look at.


00:13:08.720 --> 00:13:14.520
The thing that was missing out of it is the little bit at the end, I think, that says,


00:13:14.520 --> 00:13:19.140
by the way, don't ever do this if you're actually writing Python code, because all this stuff's


00:13:19.140 --> 00:13:20.140
already built in.


00:13:20.140 --> 00:13:21.140
Exactly.


00:13:21.140 --> 00:13:23.620
Yeah, you've got the various numerical libraries for it, right?


00:13:23.620 --> 00:13:25.420
Isn't this stuff already built in?


00:13:25.420 --> 00:13:29.540
And Min and Max are already built in just normally, and some of the others.


00:13:29.540 --> 00:13:33.580
But I actually went and looked and found a...


00:13:33.580 --> 00:13:36.320
I didn't know about the statistics module.


00:13:36.320 --> 00:13:40.440
built in, I think as of 3.4 or 3.5 or something.


00:13:40.440 --> 00:13:41.440
That's right.


00:13:41.440 --> 00:13:42.440
It's quite new.


00:13:42.440 --> 00:13:44.440
I don't remember, but I think it might be 3.5 actually.


00:13:44.440 --> 00:13:45.440
3.4.


00:13:45.440 --> 00:13:46.440
3.4.


00:13:46.440 --> 00:13:47.440
Thank you, Bob.


00:13:47.440 --> 00:13:48.440
Okay.


00:13:48.440 --> 00:13:53.700
But I threw in some examples, but if you're just using that, it doesn't help you learn


00:13:53.700 --> 00:13:57.800
what statistics is, so that's why I think the article is still good.


00:13:57.800 --> 00:14:02.640
I stuck up, I was looking at the statistics and I noticed that it had both standard deviation


00:14:02.640 --> 00:14:08.960
variance and population standard deviation and population variance. I don't know enough


00:14:08.960 --> 00:14:11.120
statistics to know what the difference in those are.


00:14:11.120 --> 00:14:17.720
I know P goes in front of the method name. No, that's awesome that that's in there. Yeah,


00:14:17.720 --> 00:14:22.440
I think it's interesting that they added that module into the standard library in 3.4. It's


00:14:22.440 --> 00:14:23.440
cool.


00:14:23.440 --> 00:14:27.920
Yeah, I guess maybe they were tired of people implementing them in crazy hand-coded ways.


00:14:27.920 --> 00:14:32.240
Yeah, and it's got to be faster written in C to compute the variance than to do it in


00:14:32.240 --> 00:14:33.400
in like a Python loop.


00:14:33.400 --> 00:14:34.960
- That's a good point.


00:14:34.960 --> 00:14:38.000
Yeah, and it again goes to say that always keep up


00:14:38.000 --> 00:14:39.040
with the standard library


00:14:39.040 --> 00:14:41.400
because there's so much stuff in there


00:14:41.400 --> 00:14:42.920
that can save you writing code


00:14:42.920 --> 00:14:45.280
and probably gain you performance.


00:14:45.280 --> 00:14:46.240
- Yeah, absolutely.


00:14:46.240 --> 00:14:48.120
All right, Bob, what's the next one you got here?


00:14:48.120 --> 00:14:49.560
- This is a big piece.


00:14:49.560 --> 00:14:54.020
Strings and character data in Python by RealPython.


00:14:54.020 --> 00:14:54.920
I don't know if--


00:14:54.920 --> 00:14:55.920
- If it's by RealPython,


00:14:55.920 --> 00:14:58.240
you know it's kind of like a novella.


00:14:58.240 --> 00:14:59.600
- Yeah, exactly.


00:14:59.600 --> 00:15:04.600
Because I want to compare it with that it or tools article you featured a couple of


00:15:04.600 --> 00:15:05.120
weeks ago.


00:15:05.120 --> 00:15:06.480
That was like this long piece.


00:15:06.480 --> 00:15:09.400
It took me an hour to read, but I got so much out of that.


00:15:09.400 --> 00:15:10.880
And it's the same here.


00:15:10.880 --> 00:15:13.220
I didn't even honestly didn't finish it yet.


00:15:13.220 --> 00:15:18.720
I've been like 60, 70% in and always already got so much value out of it because it does


00:15:18.720 --> 00:15:24.480
this great detailed tour of strings in Python and all the methods you can use on


00:15:24.480 --> 00:15:25.880
methods you can use on them.


00:15:26.480 --> 00:15:30.720
And I put some snippets in the, in the show notes because I mean, for a beginner,


00:15:30.720 --> 00:15:33.620
it's great because you will be working with strings from day one.


00:15:33.620 --> 00:15:38.640
But even if you know Python, there's like a lot of these little tricks in there


00:15:38.640 --> 00:15:41.000
that can just make you faster in Python.


00:15:41.000 --> 00:15:46.580
Um, if a string is a digit, you can use is digit on the string, which returns


00:15:46.580 --> 00:15:51.500
a Boolean rather than try, try to convert it to an int, catch the exception and go


00:15:51.500 --> 00:15:53.760
to the exact, if not an int, yeah, that kind of thing.


00:15:53.760 --> 00:15:53.960
Yeah.


00:15:53.960 --> 00:15:55.160
So you can use that method.


00:15:55.160 --> 00:15:59.620
Um, or for example, you want to look for white space, a space, a tap or a new


00:15:59.620 --> 00:16:05.220
line, there's also an is space method that does that for you, or, commonly


00:16:05.220 --> 00:16:09.380
with, terminal apps, you want to have this banner with a tech centered.


00:16:09.380 --> 00:16:13.280
Well, you can just do string center and then the width and


00:16:13.280 --> 00:16:16.420
then the, the, the filler character.


00:16:16.420 --> 00:16:19.100
So there's, there's a lot of good stuff in there.


00:16:19.100 --> 00:16:23.860
And, I think it's worth to go and spend that hour and learn all that stuff.


00:16:23.860 --> 00:16:28.000
because you mean that we'll just shave off time when you're actually coding.


00:16:28.000 --> 00:16:32.560
And another thing I also found kind of the linking you do when you read such an


00:16:32.560 --> 00:16:35.380
article, for example, polymorphism, right?


00:16:35.380 --> 00:16:39.960
If you have the index method works on a string, but also works on a, on a list.


00:16:39.960 --> 00:16:45.700
So I put a snippet in the show notes that I use index on a string and a list, and


00:16:45.700 --> 00:16:48.380
you see that they behave in a similar way.


00:16:48.380 --> 00:16:49.820
Same goes for count.


00:16:49.820 --> 00:16:53.220
So I found that also an interesting point to highlight.


00:16:53.220 --> 00:16:53.700
Oh yeah.


00:16:53.700 --> 00:16:54.620
- Yeah, this is really interesting.


00:16:54.620 --> 00:16:56.580
I just threw that into Instapaper


00:16:56.580 --> 00:16:59.100
and Instapaper says reading time 33 minutes.


00:16:59.100 --> 00:17:01.500
Yeah, this is definitely, it's like a book chapter


00:17:01.500 --> 00:17:03.260
almost on strings character.


00:17:03.260 --> 00:17:05.540
- I might be a slow reader, but.


00:17:05.540 --> 00:17:06.620
- Well, I'm sure I would too.


00:17:06.620 --> 00:17:09.900
And you know, that's not counting that it's like code.


00:17:09.900 --> 00:17:11.460
Code you gotta analyze, right?


00:17:11.460 --> 00:17:13.180
- Yeah, you want to try some things.


00:17:13.180 --> 00:17:14.500
Yeah, yeah, yeah.


00:17:14.500 --> 00:17:15.580
- Exactly, exactly.


00:17:15.580 --> 00:17:16.540
No, it's a great find.


00:17:16.540 --> 00:17:17.380
It's really cool.


00:17:17.380 --> 00:17:19.580
- And people coming from different languages,


00:17:19.580 --> 00:17:21.100
I know I was like this.


00:17:21.100 --> 00:17:26.380
I did not expect that strings would have all of these cool operations on them.


00:17:26.380 --> 00:17:31.260
Yeah, especially if you're coming from C where strings are really just, you know, character


00:17:31.260 --> 00:17:32.740
pointer array type things.


00:17:32.740 --> 00:17:34.540
They're basically just memory, right?


00:17:34.540 --> 00:17:35.540
Yeah.


00:17:35.540 --> 00:17:36.540
Yeah.


00:17:36.540 --> 00:17:40.420
But imagine you have to do by leading zeros to a number.


00:17:40.420 --> 00:17:42.140
And that would take you a couple lines of code.


00:17:42.140 --> 00:17:46.580
In Python, it's just number string Z fill, and then the number of zeros you want to be


00:17:46.580 --> 00:17:47.580
penned.


00:17:47.580 --> 00:17:48.940
And it's it just makes for shorter code.


00:17:48.940 --> 00:17:49.940
Yeah, it's wonderful.


00:17:49.940 --> 00:17:56.180
fill this he. Yeah. So you want to have a 42, for example, and it needs to be five,


00:17:56.180 --> 00:18:00.180
a width of five, you can just set fill it with zeros.


00:18:00.180 --> 00:18:07.140
Nice. So I'm going to bring I'm going to close this out with something that is surprisingly


00:18:07.140 --> 00:18:13.220
controversial. I don't know, I'll see what your thoughts are. So there's a new PEP in town,


00:18:13.220 --> 00:18:19.100
 PEP 572 and whenever I think about these things always think you know someone has


00:18:19.100 --> 00:18:22.580
worked super hard on this and that's really awesome they're making a


00:18:22.580 --> 00:18:28.100
contribution and then you know to see people react and I don't know not totally


00:18:28.100 --> 00:18:31.460
excited ways I don't know it's sort of I don't know how to feel about let's say


00:18:31.460 --> 00:18:38.460
but there is a new piece of Python syntax that will allow you to in a


00:18:38.460 --> 00:18:45.300
single expression, create a variable and assign to it. So, so often you have to do


00:18:45.300 --> 00:18:50.140
something to the effect of like, I'm going to create a variable, set a value,


00:18:50.140 --> 00:18:54.580
and then if that value is something I'm going to do a thing or I'm going to do


00:18:54.580 --> 00:19:00.220
something else. So the new syntax lets you put a colon equals to define that


00:19:00.220 --> 00:19:04.220
and put it all in one line. So instead of saying like match equals pattern dot


00:19:04.220 --> 00:19:10.620
search if match is not none, etc, etc. You can just say if match colon equals


00:19:10.620 --> 00:19:14.020
pattern dot search is not none, all in one. I'm actually even confused about


00:19:14.020 --> 00:19:19.100
your example. I thought that the point to that new operator was explicitly to


00:19:19.100 --> 00:19:25.380
check against none. The point of the thing is to allow you to both create the


00:19:25.380 --> 00:19:29.020
variable and set its initial value and check it at the same time whatever


00:19:29.020 --> 00:19:33.180
you're checking it for. Oh, right. And you don't even have to check it. For example,


00:19:33.180 --> 00:19:38.060
one of the really common use cases for this is to use it in like a list


00:19:38.060 --> 00:19:42.940
comprehension or something like that. And anytime you need more than one line, that


00:19:42.940 --> 00:19:48.740
cannot be put into a list comprehension or lambda expression, right? But now with


00:19:48.740 --> 00:19:54.260
this one line variable creation assignment potential test behavior, you


00:19:54.260 --> 00:19:58.700
can put these into inline expressions like list comprehensions or lambdas or


00:19:58.700 --> 00:20:02.620
so on. I think that's it. I've only skimmed some of the use cases but that's


00:20:02.620 --> 00:20:03.620
That's what I'm thinking it's for.


00:20:03.620 --> 00:20:04.620
Okay.


00:20:04.620 --> 00:20:05.980
So this is interesting.


00:20:05.980 --> 00:20:07.080
The syntax is not terrible.


00:20:07.080 --> 00:20:08.600
I think it's kind of okay.


00:20:08.600 --> 00:20:14.360
There's already lots of examples of this in other languages that had pretty decent implementations.


00:20:14.360 --> 00:20:17.220
So one of my thoughts was like, well, why didn't that get adopted?


00:20:17.220 --> 00:20:22.260
So both in like C# link expressions, as well as JavaScript expressions, you have


00:20:22.260 --> 00:20:27.300
let something equals a value in terms of like a, like in terms of for loop or something


00:20:27.300 --> 00:20:30.900
like that, that could have also been an interesting option.


00:20:30.900 --> 00:20:31.900
But I don't know.


00:20:31.900 --> 00:20:35.780
To me it's okay, but I don't know that it's necessarily needed for the language.


00:20:35.780 --> 00:20:39.780
It's not solving a problem that I think very many people actually have.


00:20:39.780 --> 00:20:44.700
I wouldn't have to use it and see it in other people's code because from the snippet you


00:20:44.700 --> 00:20:46.980
posted I find it a bit confusing.


00:20:46.980 --> 00:20:53.260
It might just be me having to get used to it, but it's not the kind of syntax I'm used


00:20:53.260 --> 00:20:54.540
to from Python, right?


00:20:54.540 --> 00:20:55.780
It's more readable.


00:20:55.780 --> 00:20:57.340
What do you guys think?


00:20:57.340 --> 00:21:02.020
To me, it's like one step down the slippery slope.


00:21:02.020 --> 00:21:04.100
I mentioned C# and the let stuff.


00:21:04.100 --> 00:21:08.140
I feel like the C# language used to be pretty nice and it's just a complete train wreck.


00:21:08.140 --> 00:21:11.500
Now there's all these little three or four ways of doing the same thing and they're all


00:21:11.500 --> 00:21:15.200
getting a few characters shorter, but now there's five of them.


00:21:15.200 --> 00:21:16.740
They're all more or less equivalent.


00:21:16.740 --> 00:21:20.500
It's just like, "Whoa, why do we keep adding these things to this language?


00:21:20.500 --> 00:21:21.500
They're just unneeded."


00:21:21.500 --> 00:21:24.820
I feel like this is in that category of stuff.


00:21:24.820 --> 00:21:25.820
Python's nowhere near as bad.


00:21:25.820 --> 00:21:31.340
But might not be the PEP itself, but more about the, we start to introduce and


00:21:31.340 --> 00:21:34.860
what other syntax changes that might be coming, right.


00:21:34.860 --> 00:21:36.540
If you open it up for this.


00:21:36.540 --> 00:21:37.020
Yeah.


00:21:37.020 --> 00:21:41.860
So what I want to sort of point people out for this is the tweet by Raymond


00:21:41.860 --> 00:21:47.120
Hedinger and then the Twitter conversation that follows it, which is really


00:21:47.120 --> 00:21:47.740
interesting.


00:21:47.740 --> 00:21:51.440
Like you don't normally see this much conversation in a thread on Twitter, but


00:21:51.440 --> 00:21:55.520
There's like 44 messages in the, out to this one tweet.


00:21:55.520 --> 00:21:57.960
And it's, it's pretty interesting.


00:21:57.960 --> 00:22:01.700
Some people like it, some people don't, but I think it's worth reading through.


00:22:01.700 --> 00:22:02.200
Nice.


00:22:02.200 --> 00:22:04.540
So anyway, new PEP in town and it's approved, right?


00:22:04.540 --> 00:22:05.600
This is not proposed.


00:22:05.600 --> 00:22:07.200
My understanding is this is approved.


00:22:07.200 --> 00:22:10.600
So it's, it's now going to be part of maybe three Python three eight.


00:22:10.600 --> 00:22:11.080
Yeah.


00:22:11.080 --> 00:22:15.600
I'll totally use it, but it is, it did one was one thing that made Python


00:22:15.600 --> 00:22:20.920
different was that like conceive you've, if you tried to do check for equality


00:22:20.960 --> 00:22:25.100
and you accidentally did assignment instead, it's wrong.


00:22:25.100 --> 00:22:28.740
And I guess that's why the syntax is specific,


00:22:28.740 --> 00:22:30.900
so that it's not gonna be an accident.


00:22:30.900 --> 00:22:33.140
- Right, and C, you could say something to the effect


00:22:33.140 --> 00:22:37.540
of like, if match equals pattern.match,


00:22:37.540 --> 00:22:39.180
do such and such, right?


00:22:39.180 --> 00:22:40.780
And you actually meant if those two things


00:22:40.780 --> 00:22:42.060
were actually equal, right?


00:22:42.060 --> 00:22:44.640
So there's a way, the syntax does make


00:22:44.640 --> 00:22:47.640
that sort of fall through error case, not actually.


00:22:47.640 --> 00:22:49.540
You can't omit an equal on accident


00:22:49.540 --> 00:22:50.620
and actually get assignment.


00:22:50.620 --> 00:22:53.200
- Yeah, you have to explicitly put the colon in there.


00:22:53.200 --> 00:22:54.260
It's colon equal.


00:22:54.260 --> 00:22:55.940
So, okay.


00:22:55.940 --> 00:22:57.740
- All right, well, there it is.


00:22:57.740 --> 00:23:00.740
PEP 572, the most controversial accepted PEP


00:23:00.740 --> 00:23:01.580
I've heard in a little while.


00:23:01.580 --> 00:23:02.800
Pretty interesting.


00:23:02.800 --> 00:23:04.860
All right, well, that's it for our news items, you guys.


00:23:04.860 --> 00:23:06.060
Brian, you got anything else


00:23:06.060 --> 00:23:07.700
you wanna share with the world these days?


00:23:07.700 --> 00:23:08.540
What's going on?


00:23:08.540 --> 00:23:13.420
- Well, actually, kind of nice tie in with this PEP 572.


00:23:13.420 --> 00:23:15.500
I wanted to just talk with somebody


00:23:15.500 --> 00:23:18.020
about all the new stuff that's proposed,


00:23:18.020 --> 00:23:24.580
actually proposed and accepted already for 3.8 and I think just for 3.8.


00:23:24.580 --> 00:23:27.420
So that's kind of what Anthony Shaw has been up to lately.


00:23:27.420 --> 00:23:31.780
So I'm going to have Anthony on testing code and we're going to talk about that.


00:23:31.780 --> 00:23:32.780
>> Oh, that's going to be great.


00:23:32.780 --> 00:23:38.540
>> I've also realized that doing this podcast with you, it's pretty easy to do it once a


00:23:38.540 --> 00:23:41.700
week because you're waiting for me to do it once a week.


00:23:41.700 --> 00:23:46.780
So I'm trying to rope in some other people and Anthony is one of the people that agreed


00:23:46.780 --> 00:23:50.380
to try to do testing code more regularly to try to get more of those out.


00:23:50.380 --> 00:23:51.820
Oh, yeah, that's awesome.


00:23:51.820 --> 00:23:52.820
Yeah, that's really cool.


00:23:52.820 --> 00:23:53.820
How about you, Michael?


00:23:53.820 --> 00:23:57.820
Well, if we're going to give shout outs to Anthony, I just had him on Talk Python as well


00:23:57.820 --> 00:23:59.100
about his security article.


00:23:59.100 --> 00:24:00.100
He's really killing it.


00:24:00.100 --> 00:24:03.500
Him and the real Python guys, they're definitely cranking out the content.


00:24:03.500 --> 00:24:04.500
That's great.


00:24:04.500 --> 00:24:08.420
But the thing that I guess is the biggest news that has me getting up early and staying


00:24:08.420 --> 00:24:14.780
up late is I'm working on a new about 10 hour course for data driven apps in Pyramid with


00:24:14.780 --> 00:24:17.260
of SQL alchemy and like production migrations


00:24:17.260 --> 00:24:18.340
and all sorts of stuff.


00:24:18.340 --> 00:24:19.780
That is almost done.


00:24:19.780 --> 00:24:21.580
It should be out next week.


00:24:21.580 --> 00:24:23.740
Just finalizing a lot of the videos this week


00:24:23.740 --> 00:24:25.500
and it'll be rolling.


00:24:25.500 --> 00:24:26.340
- Nice. - Nice.


00:24:26.340 --> 00:24:28.100
- Yeah, so that's what I'm up to.


00:24:28.100 --> 00:24:29.460
Bob, how about you?


00:24:29.460 --> 00:24:31.340
You wanna tell people about PyBytes real quick,


00:24:31.340 --> 00:24:32.180
what that is?


00:24:32.180 --> 00:24:35.660
- Yeah, PyBytes started out as a blog with articles


00:24:35.660 --> 00:24:38.780
and we quickly moved into a blog code challenges


00:24:38.780 --> 00:24:41.500
and that got quite some traction.


00:24:41.500 --> 00:24:44.020
So we build out a code challenge platform


00:24:44.020 --> 00:24:46.700
which you can find on codechallenge.es.


00:24:46.700 --> 00:24:50.500
So codechallenge is spelled as codechallenges together,


00:24:50.500 --> 00:24:52.620
but ending in .es.


00:24:52.620 --> 00:24:56.860
And you can log in with GitHub and code in the browser.


00:24:56.860 --> 00:25:00.060
So there are exercises with automated pytest.


00:25:00.060 --> 00:25:01.360
Yes, Brian, it's pytest.


00:25:01.360 --> 00:25:06.120
And you can code in a browser and verify those exercises.


00:25:06.120 --> 00:25:07.980
And yeah, the feedback is great.


00:25:07.980 --> 00:25:11.180
I mean, people are learning a lot of Python that way


00:25:11.180 --> 00:25:13.340
because it's so practical.


00:25:13.340 --> 00:25:16.040
And so we're growing that we have a Slack community


00:25:16.040 --> 00:25:18.500
behind it where a lot of people are joining


00:25:18.500 --> 00:25:21.460
and we have very good Pythonic discussions.


00:25:21.460 --> 00:25:24.940
So that's, yeah, I'm excited about this.


00:25:24.940 --> 00:25:25.780
- Yeah, right on.


00:25:25.780 --> 00:25:26.800
Yeah, it's a cool platform.


00:25:26.800 --> 00:25:28.060
Happy to see you doing it.


00:25:28.060 --> 00:25:30.820
And thank you for being on the show, Brian.


00:25:30.820 --> 00:25:31.660
- Thank you.


00:25:31.660 --> 00:25:32.580
- Thank you, as always.


00:25:32.580 --> 00:25:34.620
I'm happy to hear you're doing more testing code as well.


00:25:34.620 --> 00:25:35.460
That's pretty sweet.


00:25:35.460 --> 00:25:36.280
- Yeah.


00:25:36.280 --> 00:25:37.120
- All right, catch you later.


00:25:37.120 --> 00:25:37.940
- Bye.


00:25:37.940 --> 00:25:40.900
- Thank you for listening to Python Bytes.


00:25:40.900 --> 00:25:46.700
Follow the show on Twitter via @pythonbytes, that's Python Bytes as in B-Y-T-E-S.


00:25:46.700 --> 00:25:50.000
And get the full show notes at PythonBytes.fm.


00:25:50.000 --> 00:25:53.700
If you have a news item you want featured, just visit PythonBytes.fm and send it our


00:25:53.700 --> 00:25:54.700
way.


00:25:54.700 --> 00:25:57.200
We're always on the lookout for sharing something cool.


00:25:57.200 --> 00:26:00.660
On behalf of myself and Brian Auchin, this is Michael Kennedy.


00:26:00.660 --> 00:26:03.700
Thank you for listening and sharing this podcast with your friends and colleagues.

