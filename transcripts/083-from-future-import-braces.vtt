
00:00:00.000 --> 00:00:05.040
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:05.040 --> 00:00:09.840
This is episode 83 recorded June 20th, 2018. I'm Michael Kennedy.


00:00:09.840 --> 00:00:10.480
I'm Brian Okken.


00:00:10.480 --> 00:00:12.000
And Brian, we have a special guest, don't we?


00:00:12.000 --> 00:00:12.560
Yes, we do.


00:00:12.560 --> 00:00:17.840
Yeah, so Chris Medina is here to join in the fun and share his perspective on things.


00:00:17.840 --> 00:00:18.720
Hey, Chris, welcome to the show.


00:00:18.720 --> 00:00:20.480
Hey, guys, how's it going? Good to be here.


00:00:20.480 --> 00:00:21.760
Yeah, it's good to have you.


00:00:21.760 --> 00:00:23.600
And I also want to say thank you to DigitalOcean.


00:00:23.600 --> 00:00:27.920
They are a major, major sponsor of the show and they're sponsoring this one as well.


00:00:27.920 --> 00:00:32.080
tell you more about them. But the short version is Python bytes out of them slash digital ocean,


00:00:32.080 --> 00:00:37.520
get $100 credit for new users. Brian, speaking of new users, people are in Python, they might


00:00:37.520 --> 00:00:42.560
want to set up a server at some point, set up a server. Well, you know, eventually, eventually,


00:00:42.560 --> 00:00:46.880
they'll have a website or something, right? Once they learn to code, but you've got a really nice


00:00:46.880 --> 00:00:52.400
way for them to get started. I have been always been reluctant to try to look or play with some


00:00:52.400 --> 00:00:55.300
some of these beginning code editors,


00:00:55.300 --> 00:00:57.420
because part of learning how to code


00:00:57.420 --> 00:00:59.260
is learning an editor.


00:00:59.260 --> 00:01:01.420
But I'm kind of warming to the idea


00:01:01.420 --> 00:01:03.800
of some of these specialized editors.


00:01:03.800 --> 00:01:06.800
And there's one that I wasn't familiar with,


00:01:06.800 --> 00:01:07.800
which is Moo.


00:01:07.800 --> 00:01:10.060
I think it's Moo or Mew, I don't know.


00:01:10.060 --> 00:01:12.060
Hey, Mew, code with Moo.


00:01:12.060 --> 00:01:14.300
It's got a whole bunch of people on board.


00:01:14.300 --> 00:01:17.820
If I go to the, I can't remember where it is,


00:01:17.820 --> 00:01:19.820
but there's a bunch of people working on this.


00:01:19.820 --> 00:01:23.140
And it's a kind of a neat little editor that has,


00:01:23.140 --> 00:01:24.980
I was playing with it this morning,


00:01:24.980 --> 00:01:28.180
and it has some built, you just open it up


00:01:28.180 --> 00:01:29.660
and it has built in right off the bat.


00:01:29.660 --> 00:01:32.060
It asks you if you're gonna do it for Python 3,


00:01:32.060 --> 00:01:36.820
or if you're targeting like an Adafruit chip or a micro bit.


00:01:36.820 --> 00:01:40.160
So it has built in targeting of those things like right away.


00:01:40.160 --> 00:01:42.180
And there's like along the top,


00:01:42.180 --> 00:01:45.660
there's some icons for loading and saving files,


00:01:45.660 --> 00:01:49.500
running it, debugging it, popping up the REPL,


00:01:49.500 --> 00:01:51.240
interacting with the plotter.


00:01:51.240 --> 00:01:53.640
And then there's a, even there's a theme button


00:01:53.640 --> 00:01:55.560
so you can jump back and forth


00:01:55.560 --> 00:01:57.640
between dark theme and light theme.


00:01:57.640 --> 00:01:59.880
And it even has like a linter built in


00:01:59.880 --> 00:02:01.520
for you can check things.


00:02:01.520 --> 00:02:03.540
And it's all like you don't have to memorize


00:02:03.540 --> 00:02:07.720
any key sequences or there's not really any menus around.


00:02:07.720 --> 00:02:09.400
It just is all up there.


00:02:09.400 --> 00:02:11.240
And I think this is actually be great


00:02:11.240 --> 00:02:13.760
for teaching people how to code.


00:02:13.760 --> 00:02:17.480
So I'm gonna start using it for like demos and stuff.


00:02:17.480 --> 00:02:18.320
- It's pretty cool, yeah.


00:02:18.320 --> 00:02:23.320
So as you type, basically, it pulls up both the completion


00:02:23.320 --> 00:02:26.280
for the arguments that go to a method or something,


00:02:26.280 --> 00:02:29.000
but also the documentation, like while you're typing.


00:02:29.000 --> 00:02:30.720
So, you know, you might get annoyed with that


00:02:30.720 --> 00:02:33.200
if you know what you're doing, but if you're new,


00:02:33.200 --> 00:02:34.320
it's really cool to show you like,


00:02:34.320 --> 00:02:35.880
hey, you can call these various things


00:02:35.880 --> 00:02:38.160
and here's the arguments, here's what it means,


00:02:38.160 --> 00:02:40.280
and even has a debug, it's pretty cool.


00:02:40.280 --> 00:02:42.200
- And the-- - So it's a separate app?


00:02:42.200 --> 00:02:44.620
- Yeah, it's a separate app, but you can,


00:02:44.620 --> 00:02:47.560
there's an installer available, so you can just,


00:02:47.560 --> 00:02:49.680
You don't even have to tell people about pip right away,


00:02:49.680 --> 00:02:53.360
'cause you can just install it with an installer.


00:02:53.360 --> 00:02:54.960
But you can install it with pip,


00:02:54.960 --> 00:02:56.840
'cause it's just a Python thing.


00:02:56.840 --> 00:02:59.700
I think it's a Qt, or Qt, I've been corrected.


00:02:59.700 --> 00:03:01.960
It's a Qt application.


00:03:01.960 --> 00:03:02.960
- Oh, that's really cool.


00:03:02.960 --> 00:03:04.000
It's Qt, okay.


00:03:04.000 --> 00:03:05.440
- Yeah, I installed it with pip.


00:03:05.440 --> 00:03:07.340
And then one of the things that it has


00:03:07.340 --> 00:03:09.520
in the installation instructions


00:03:09.520 --> 00:03:12.480
is instructions on how to use.


00:03:12.480 --> 00:03:14.320
So when you install it with pip,


00:03:14.320 --> 00:03:17.800
you get like a command line invocation to invoke it,


00:03:17.800 --> 00:03:22.320
but it recommends using another package called shortcut,


00:03:22.320 --> 00:03:24.840
which you just, if you pip install shortcut,


00:03:24.840 --> 00:03:27.360
you get shortcut new editor, for instance,


00:03:27.360 --> 00:03:31.160
and it'll create on my Mac, it created a,


00:03:31.160 --> 00:03:33.880
I just went ahead and created a shortcut


00:03:33.880 --> 00:03:36.540
in my launchpad to launch it.


00:03:36.540 --> 00:03:37.380
So I didn't--


00:03:37.380 --> 00:03:39.720
>>Oh, that's pretty cool.


00:03:39.720 --> 00:03:41.920
>>Attach that to any Python script,


00:03:41.920 --> 00:03:44.060
you can just launch it from there.


00:03:44.060 --> 00:03:45.300
- Nice, oh, but--


00:03:45.300 --> 00:03:47.460
- Looks like it has different modes too.


00:03:47.460 --> 00:03:50.300
Like you can set it up to work for writing code


00:03:50.300 --> 00:03:53.540
for Adafruit or for Pygame or stuff like that.


00:03:53.540 --> 00:03:54.620
That looks kind of neat.


00:03:54.620 --> 00:03:57.020
- Yeah, and then when it has the built-in REPL,


00:03:57.020 --> 00:04:00.060
if you pop open the REPL, it's not just your normal REPL,


00:04:00.060 --> 00:04:03.780
it's a Jupyter notebook, or a Jupyter REPL,


00:04:03.780 --> 00:04:04.900
which is pretty cool.


00:04:04.900 --> 00:04:06.900
- Yeah, that's really cool, I love this.


00:04:06.900 --> 00:04:07.860
Yeah, it's very neat.


00:04:07.860 --> 00:04:10.700
- And there's some, like on the tutorials link,


00:04:10.700 --> 00:04:12.560
there's a whole bunch of tutorials


00:04:12.560 --> 00:04:14.180
that aren't quite there yet.


00:04:14.180 --> 00:04:16.480
So I'm guessing they could use some people


00:04:16.480 --> 00:04:18.520
to help out with this project.


00:04:18.520 --> 00:04:20.400
- All right, yeah, and that'd be a great easy way


00:04:20.400 --> 00:04:23.280
to get sort of get your feet wet in open source


00:04:23.280 --> 00:04:25.080
is to write some tutorials, right?


00:04:25.080 --> 00:04:26.940
You don't have to too much to depend upon


00:04:26.940 --> 00:04:29.560
or you probably won't break anybody's code by writing one.


00:04:29.560 --> 00:04:31.160
- Yeah. - Yeah, nice.


00:04:31.160 --> 00:04:33.320
So Chris, one of the things I find


00:04:33.320 --> 00:04:35.080
that's pretty interesting is


00:04:35.080 --> 00:04:37.720
we love to talk about super advanced topics,


00:04:37.720 --> 00:04:42.200
but a lot of times it's really what people need or want,


00:04:42.200 --> 00:04:43.960
especially if you're helping or mentoring someone else,


00:04:43.960 --> 00:04:45.760
is like some more fundamental stuff, right?


00:04:45.760 --> 00:04:49.060
- Yep, I found this a kind of an intro topic


00:04:49.060 --> 00:04:52.640
into how the Python parentheses system works.


00:04:52.640 --> 00:04:55.240
It's pretty interesting also for folks


00:04:55.240 --> 00:04:56.760
that come from other languages,


00:04:56.760 --> 00:04:59.360
so you can get kind of like a quick translation


00:04:59.360 --> 00:05:01.880
from one place to another, how things operate.


00:05:01.880 --> 00:05:02.800
- It sounds pretty simple.


00:05:02.800 --> 00:05:04.800
I mean, it's about Python parentheses, right?


00:05:04.800 --> 00:05:08.620
The Python princess, the primer from Reuven Lerner,


00:05:08.620 --> 00:05:10.000
shout out to him on that.


00:05:10.000 --> 00:05:12.120
But there's some pretty advanced things going on,


00:05:12.120 --> 00:05:15.440
and a pretty cool feature coming at the end.


00:05:15.440 --> 00:05:16.600
- Great.


00:05:16.600 --> 00:05:17.440
- So tell us about it.


00:05:17.440 --> 00:05:19.680
- So the fun stuff is,


00:05:19.680 --> 00:05:21.120
it goes into all the different ways


00:05:21.120 --> 00:05:22.400
that you actually use parentheses


00:05:22.400 --> 00:05:23.960
while you're doing your Python syntax


00:05:23.960 --> 00:05:25.280
and what you can use it for.


00:05:25.280 --> 00:05:27.120
So you get a couple of the simple topics,


00:05:27.120 --> 00:05:32.000
like usually a parentheses is used in a callable


00:05:32.000 --> 00:05:33.720
to call a function and pass in parameters


00:05:33.720 --> 00:05:37.080
or to call a class that implements callable.


00:05:37.080 --> 00:05:40.920
Things like prioritization of operations


00:05:40.920 --> 00:05:43.840
or conditionals, you also use parentheses


00:05:43.840 --> 00:05:47.200
for making tuples, but you also get a little bit


00:05:47.200 --> 00:05:50.520
into generator expressions and the advantages of that.


00:05:50.520 --> 00:05:52.600
And a couple little quirks, you can use it


00:05:52.600 --> 00:05:55.740
for screening some of the indentation rules


00:05:55.740 --> 00:05:58.460
that Python has that some people kind of hate,


00:05:58.460 --> 00:06:02.160
but other people like me love, so I'm special.


00:06:02.160 --> 00:06:04.600
You also get into square brackets and curly braces.


00:06:04.600 --> 00:06:08.640
And square brackets, which are typically used


00:06:08.640 --> 00:06:10.280
for lists and for indexing.


00:06:10.280 --> 00:06:15.600
For somebody that's new to the topic, you'll want to look at the slices section


00:06:15.600 --> 00:06:20.080
because slices are a pretty powerful little tool that you get out of Python.


00:06:20.080 --> 00:06:27.800
If you haven't used it before, how to get specific sections of a list or a variable.


00:06:27.800 --> 00:06:31.520
And there's also, well, not in the article itself,


00:06:31.520 --> 00:06:34.320
but some of the folks that commented on the article also mentioned


00:06:34.320 --> 00:06:37.260
that some of the new type hint stuff also uses


00:06:37.260 --> 00:06:42.260
square brackets for identifying like the variables,


00:06:42.260 --> 00:06:45.000
if you have a variable that's say a list


00:06:45.000 --> 00:06:47.900
or a container class of some sort,


00:06:47.900 --> 00:06:50.540
the data type that it's implementing.


00:06:50.540 --> 00:06:52.260
So if you have a list of floats,


00:06:52.260 --> 00:06:53.900
you would say list curly bracket floats


00:06:53.900 --> 00:06:55.620
when you're specifying what type it is.


00:06:55.620 --> 00:06:56.700
- Yeah, that's really interesting.


00:06:56.700 --> 00:07:00.220
It's almost like generics in like C#


00:07:00.220 --> 00:07:02.740
or templates in C++,


00:07:02.740 --> 00:07:06.180
where you would say, this thing takes a list of strings.


00:07:06.180 --> 00:07:07.800
You can say it's just a list,


00:07:07.800 --> 00:07:09.800
but then you don't get any help


00:07:09.800 --> 00:07:11.140
on what's contained within it.


00:07:11.140 --> 00:07:12.860
But you could say, import the list thing


00:07:12.860 --> 00:07:15.300
and say list square bracket int square bracket.


00:07:15.300 --> 00:07:17.500
Then it has to be a homogeneous list of ints,


00:07:17.500 --> 00:07:19.620
not just any random list, which is pretty cool.


00:07:19.620 --> 00:07:20.460
- Exactly.


00:07:20.460 --> 00:07:22.540
- I was looking through here and down at the bottom,


00:07:22.540 --> 00:07:24.640
they're talking about some of the ways


00:07:24.640 --> 00:07:26.340
to future-proof your code.


00:07:26.340 --> 00:07:31.020
So you can say from dunder future import division.


00:07:32.460 --> 00:07:35.780
- And there's a proposal for braces, huh?


00:07:35.780 --> 00:07:37.060
- Uh-huh.


00:07:37.060 --> 00:07:39.180
If you have a Python REPL open right now


00:07:39.180 --> 00:07:41.140
and you kind of want to try that,


00:07:41.140 --> 00:07:43.580
you'll get a neat little message


00:07:43.580 --> 00:07:45.940
of what the future will look like


00:07:45.940 --> 00:07:47.700
if you ever actually import braces.


00:07:47.700 --> 00:07:50.340
- Right, so if you can see the coming braces feature,


00:07:50.340 --> 00:07:53.460
you can say from dunder future import braces


00:07:53.460 --> 00:07:55.180
and see what support Python's probably


00:07:55.180 --> 00:07:56.780
gonna be adding for braces soon.


00:07:56.780 --> 00:07:59.580
Which, you know, not everyone's typing,


00:07:59.580 --> 00:08:00.420
they're probably driving this up.


00:08:00.420 --> 00:08:04.780
So basically it throws a syntax exception error


00:08:04.780 --> 00:08:08.940
and says, not a chance, we're never adding braces.


00:08:08.940 --> 00:08:09.980
It's beautiful.


00:08:09.980 --> 00:08:12.140
I knew about anti-gravity, we were joking about that earlier,


00:08:12.140 --> 00:08:14.060
but I didn't know about the import braces,


00:08:14.060 --> 00:08:14.900
that's pretty sweet.


00:08:14.900 --> 00:08:16.420
- One more interesting thing to mention,


00:08:16.420 --> 00:08:17.740
obviously it goes into curly braces


00:08:17.740 --> 00:08:18.980
and how you use that as well


00:08:18.980 --> 00:08:21.660
for set comprehensions and dictionaries.


00:08:21.660 --> 00:08:24.740
The other thing to remind folks is Python 3.6 Plus,


00:08:24.740 --> 00:08:28.540
there is f-strings, and with f-strings,


00:08:28.540 --> 00:08:36.820
You can use braces inside a string that you prefix with F to the interpreter replaces


00:08:36.820 --> 00:08:41.180
any code that you put inside those braces actually executes it and replaces the result


00:08:41.180 --> 00:08:42.180
into the string.


00:08:42.180 --> 00:08:43.180
Yeah, very nice.


00:08:43.180 --> 00:08:44.180
f-strings are great.


00:08:44.180 --> 00:08:45.180
And it's way more efficient.


00:08:45.180 --> 00:08:46.180
Fastest and the shortest.


00:08:46.180 --> 00:08:47.180
Cleanest.


00:08:47.180 --> 00:08:48.180
Very nice.


00:08:48.180 --> 00:08:53.980
So Brian, you mentioned that that Mew Editor is a Qt application and Qt is kind of making


00:08:53.980 --> 00:08:55.740
a bit of a resurgence these days.


00:08:55.740 --> 00:08:57.820
At least I've been paying more attention to it.


00:08:57.820 --> 00:09:01.020
- Yeah, well it had gone through some fairly dark times.


00:09:01.020 --> 00:09:03.740
I mean, obviously we've been on our gooey kick for a while.


00:09:03.740 --> 00:09:04.980
We're going through all these different options


00:09:04.980 --> 00:09:06.980
and there's still tons of great options.


00:09:06.980 --> 00:09:09.140
Like WX Python had their Phoenix release,


00:09:09.140 --> 00:09:12.340
which was sort of a rebuilding of that whole thing,


00:09:12.340 --> 00:09:13.180
which is awesome.


00:09:13.180 --> 00:09:14.760
A little while ago we talked about that.


00:09:14.760 --> 00:09:17.940
So the Qt company, Qt company,


00:09:17.940 --> 00:09:21.140
is the company that is behind the Qt framework.


00:09:21.140 --> 00:09:24.020
And they just announced the official release


00:09:24.020 --> 00:09:26.140
for Python for Qt,


00:09:26.140 --> 00:09:30.180
which is taking these various version mismatch,


00:09:30.180 --> 00:09:32.220
PySide 2, PyCube, all those things,


00:09:32.220 --> 00:09:34.700
and rebuilding it in a two-year project


00:09:34.700 --> 00:09:36.620
into a fresh, new, shiny version.


00:09:36.620 --> 00:09:38.740
So that's pretty awesome that that's more or less out.


00:09:38.740 --> 00:09:39.580
- Oh, that's exciting.


00:09:39.580 --> 00:09:42.860
We heard recent, not too long ago, that it was coming,


00:09:42.860 --> 00:09:45.140
but having it be released, wonderful.


00:09:45.140 --> 00:09:46.380
- Yeah, so if you're messing with this,


00:09:46.380 --> 00:09:49.720
it's version 5.11, and I think it's still


00:09:49.720 --> 00:09:53.780
in a tech preview in terms of the execution bits,


00:09:53.780 --> 00:09:56.540
but I suspect that this means the APIs are frozen.


00:09:56.540 --> 00:09:58.220
So you can go and check that out.


00:09:58.220 --> 00:10:00.060
Yeah, so it started two years ago,


00:10:00.060 --> 00:10:01.260
they've been working on this.


00:10:01.260 --> 00:10:03.460
And one thing that's really nice is the way you get it,


00:10:03.460 --> 00:10:05.380
is you just pip install.


00:10:05.380 --> 00:10:10.380
And they, right now it's not coming out of pypi.org itself,


00:10:10.380 --> 00:10:11.900
it's coming out of a different place.


00:10:11.900 --> 00:10:15.060
So they show you the command like to pass their particular


00:10:15.060 --> 00:10:18.020
sort of dev, their dev index URL,


00:10:18.020 --> 00:10:19.260
which I put in the show notes.


00:10:19.260 --> 00:10:20.100
So people can check that out.


00:10:20.100 --> 00:10:21.740
- So that looks like they have their own


00:10:21.740 --> 00:10:24.220
of IPI implementation there.


00:10:24.220 --> 00:10:25.300
- Yeah, something like that, right?


00:10:25.300 --> 00:10:27.740
Like a little bit like what you guys are doing


00:10:27.740 --> 00:10:29.540
that we talked about over on Talk Python, right, Chris?


00:10:29.540 --> 00:10:30.380
- Yep, exactly.


00:10:30.380 --> 00:10:33.420
- But this one goes outside the firewall, it looks like.


00:10:33.420 --> 00:10:35.940
Nice, so I just wanna give a shout out.


00:10:35.940 --> 00:10:38.660
People who are looking, waiting for Qt


00:10:38.660 --> 00:10:41.940
to become more important to get revitalized.


00:10:41.940 --> 00:10:44.220
I feel like this is the announcement


00:10:44.220 --> 00:10:45.300
we've been waiting for.


00:10:45.300 --> 00:10:47.180
Hopefully this means lots of good things.


00:10:47.180 --> 00:10:48.220
We'll see what happens.


00:10:48.220 --> 00:10:49.180
- Yeah, pretty cool.


00:10:49.180 --> 00:10:50.100
- Yeah, for sure.


00:10:50.100 --> 00:10:52.820
So speaking of good things, DigitalOcean, they're very good.


00:10:52.820 --> 00:10:54.980
They do all sorts of awesome stuff, right?


00:10:54.980 --> 00:10:58.140
They're giving you guys tons of credit if you want to get started there.


00:10:58.140 --> 00:11:03.060
And I always try to talk about different ways we are using them in our various bits of infrastructure.


00:11:03.060 --> 00:11:05.260
And that's still true, still are still enjoying that.


00:11:05.260 --> 00:11:08.700
But one of the things that they have that's really cool is when you go create a virtual


00:11:08.700 --> 00:11:12.500
machine, you can say I want to one click app, which really means a virtual machine configured


00:11:12.500 --> 00:11:14.360
to run something.


00:11:14.360 --> 00:11:18.700
And they recently set up a machine learning virtual machine for you.


00:11:18.700 --> 00:11:20.140
So you can go there, create a droplet,


00:11:20.140 --> 00:11:21.920
that's their VM terminology.


00:11:21.920 --> 00:11:24.900
Click on one click apps, pick machine learning and AI,


00:11:24.900 --> 00:11:27.740
and you automatically get a machine with Python 3,


00:11:27.740 --> 00:11:31.240
R, Jupyter, Notebooks, TensorFlow, PyTorch, all that stuff.


00:11:31.240 --> 00:11:33.940
And you pick like a CPU optimized,


00:11:33.940 --> 00:11:36.900
optimized CPU for your virtual machine.


00:11:36.900 --> 00:11:37.740
All sorts of good stuff.


00:11:37.740 --> 00:11:39.300
So if you want to check that out,


00:11:39.300 --> 00:11:41.740
you can do it real quick and affordably,


00:11:41.740 --> 00:11:43.780
just play around with those tools, which is pretty awesome.


00:11:43.780 --> 00:11:48.620
So check them out over at pythonbytes.fm/tools.


00:11:48.620 --> 00:11:50.140
slash DigitalOcean.


00:11:50.140 --> 00:11:52.900
And like I said, if you go there and you're a new user,


00:11:52.900 --> 00:11:56.540
you'll get $100 credit, which is also pretty sweet.


00:11:56.540 --> 00:12:00.380
So Brian, iteration is a key element of Python, right?


00:12:00.380 --> 00:12:04.220
Yeah, we often deal with lots of iteration and generators


00:12:04.220 --> 00:12:06.100
and iterators and all sorts of things.


00:12:06.100 --> 00:12:06.600
Exactly.


00:12:06.600 --> 00:12:07.860
We've got generators.


00:12:07.860 --> 00:12:11.540
The primary for loop is not for i equals 0, i plus plus,


00:12:11.540 --> 00:12:13.260
but it's for thing in collection.


00:12:13.260 --> 00:12:14.740
And it's beautiful, right?


00:12:14.740 --> 00:12:15.860
But it goes even deeper.


00:12:15.860 --> 00:12:17.700
Developing your own iterators and generators


00:12:17.700 --> 00:12:19.980
is a fun thing to learn about,


00:12:19.980 --> 00:12:23.580
but I have to admit that I don't often do that very much.


00:12:23.580 --> 00:12:25.540
And one of the things that I've,


00:12:25.540 --> 00:12:27.380
it's always been on my to-do list


00:12:27.380 --> 00:12:31.340
is to learn more about the IterTools module.


00:12:31.340 --> 00:12:34.060
And I've not really ever explored it too much.


00:12:34.060 --> 00:12:39.060
And RealPython has a blog post called


00:12:39.060 --> 00:12:41.820
IterTools in Python 3 by example.


00:12:41.820 --> 00:12:43.300
And I really enjoyed this.


00:12:43.300 --> 00:12:45.900
It's a nice introduction as to


00:12:45.900 --> 00:12:50.060
what is the problem that iterators and generators are dealing with?


00:12:50.060 --> 00:12:53.860
And then, for example, it starts off with just,


00:12:53.860 --> 00:12:56.900
how does zip work to take two lists


00:12:56.900 --> 00:13:00.160
and create another list with each element?


00:13:00.160 --> 00:13:04.640
And then what if you need not quite the same zip?


00:13:04.640 --> 00:13:07.160
What if they're not the same length and things like that?


00:13:07.160 --> 00:13:09.060
And some of the problems that can happen


00:13:09.060 --> 00:13:11.760
and why lazy evaluation is a good thing.


00:13:11.760 --> 00:13:15.200
And actually, in the discussion, it used the time function,


00:13:15.260 --> 00:13:17.860
the time shell function is I guess this is a like a


00:13:17.860 --> 00:13:20.060
Unix-y kind of thing


00:13:20.060 --> 00:13:22.700
with a -f, which I've never used


00:13:22.700 --> 00:13:23.860
before, and


00:13:23.860 --> 00:13:26.580
that showed the memory used also. Didn't know


00:13:26.580 --> 00:13:29.180
that was a thing. Oh, that's cool. But as this example


00:13:29.180 --> 00:13:31.420
of using like a big example


00:13:31.420 --> 00:13:33.380
in the memory usage blew up to like


00:13:33.380 --> 00:13:34.660
huge.


00:13:34.660 --> 00:13:37.180
And so just talk through


00:13:37.180 --> 00:13:39.700
like some of the different things that are in


00:13:39.700 --> 00:13:41.820
IterTools and why that helps you. I


00:13:41.820 --> 00:13:43.900
pulled out a couple like a lot


00:13:43.900 --> 00:13:47.180
of these things, if you don't know they're there, you'll just come up with it on your


00:13:47.180 --> 00:13:54.060
own. Like doing combinatorial sets, those are already in there. Coming up with permutations,


00:13:54.060 --> 00:14:01.100
you don't have to do a random index. You can just use their iterate, the ones that are


00:14:01.100 --> 00:14:02.100
built in.


00:14:02.100 --> 00:14:06.180
I think that's a good example of being fluent in Python versus being able to make the code


00:14:06.180 --> 00:14:10.060
work but not really deeply knowing it. If somebody said, "Hey, I want you to take this


00:14:10.060 --> 00:14:15.740
thing and generate a set of permutations, all the permutations of say this word or whatever,


00:14:15.740 --> 00:14:21.040
you might attempt to implement the fairly complicated algorithm or you might just call


00:14:21.040 --> 00:14:23.420
IterTools permute sort of thing, right?


00:14:23.420 --> 00:14:24.620
And then boom, it's just there.


00:14:24.620 --> 00:14:28.100
So there's so many things like that that are just at your fingertips if you just import


00:14:28.100 --> 00:14:29.100
them.


00:14:29.100 --> 00:14:33.260
Yeah, I mean, a lot of people are smart enough to like, if you come up with all the combinations,


00:14:33.260 --> 00:14:36.940
you can just have a nested for loop and figure out how to do that.


00:14:36.940 --> 00:14:39.020
But you don't have to, it's already there.


00:14:39.020 --> 00:14:45.180
One of the things I didn't know, there's some fun things like some fun uses of count and cycle.


00:14:45.180 --> 00:14:47.180
I didn't know about cycle, that's pretty cool.


00:14:47.180 --> 00:14:52.680
It just kind of cycles through a set and then keeps giving you more of the same.


00:14:52.680 --> 00:14:59.380
And the tutorial also talks about, in the tutorial it's using the next function,


00:14:59.380 --> 00:15:03.180
which is for iterators, you don't have to use them in a loop,


00:15:03.180 --> 00:15:07.680
you can even just call the next function, which is kind of fun.


00:15:07.680 --> 00:15:11.280
And then something that's I slice, I didn't know this was a thing.


00:15:11.280 --> 00:15:19.480
So if you want to take a slice of a list or a slice of some other iterator, you can do that.


00:15:19.480 --> 00:15:24.680
But if you want that to be an iterable also, this does it for you.


00:15:24.680 --> 00:15:26.880
And so there's a whole bunch of goodies in here.


00:15:26.880 --> 00:15:31.180
Yeah, one of my favorites is I slice because like Chris already said, slicing is awesome.


00:15:31.180 --> 00:15:35.580
But if you try to do, say, slice on a generator, it'll just go fail like that.


00:15:35.580 --> 00:15:37.180
Nope, we don't slice generators.


00:15:37.180 --> 00:15:43.420
Well, you can I slice them and it works just fine. It's beautiful. All right, so it's you sort of make things sliceable


00:15:43.420 --> 00:15:47.740
That otherwise would not be it's really great. Yeah, so there's definitely a definitely good read to


00:15:47.740 --> 00:15:51.180
Beef up on the the inner tools. So


00:15:51.180 --> 00:15:57.500
Yeah, I recommend everybody that writes any python code to just go look at inner tools and all the things you can do


00:15:57.500 --> 00:16:00.620
There's lots of stuff online and this is a good resource


00:16:00.620 --> 00:16:05.660
Every once in a while every every time there's an article that's something about inner tools. I always go


00:16:06.300 --> 00:16:12.540
Just at least skim it because there's always some little magic in there. You're like, oh, I implemented that myself the other day


00:16:12.540 --> 00:16:17.020
Let me go delete that code and actually do something that's maintained by somebody that knows something more more than that


00:16:17.020 --> 00:16:19.180
Yeah, and maybe even in c


00:16:19.180 --> 00:16:21.820
So it's a little faster right down in the internals


00:16:21.820 --> 00:16:27.260
Nice so speaking of sort of working with collections and intervals and things like that chris


00:16:27.260 --> 00:16:30.860
I feel like your item dovetails really in well in with this right?


00:16:30.860 --> 00:16:35.740
So the the next item is about python sets and set theory. It's a nice


00:16:35.740 --> 00:16:42.640
It's also kind of a primer on how sets work in Python, how you define them, how you work


00:16:42.640 --> 00:16:46.500
with them, and just a tiny bit on set theory.


00:16:46.500 --> 00:16:49.340
So you can build sets different ways.


00:16:49.340 --> 00:16:53.780
The most common way is by calling the set function to build an empty set.


00:16:53.780 --> 00:16:59.740
But you can also use curly braces, which we were talking about earlier, to have set comprehensions.


00:16:59.740 --> 00:17:03.660
And it's a great way of, say, deduping items in a list.


00:17:03.660 --> 00:17:09.540
So if you have a list of a bunch of integers or something like that, you can use comprehension


00:17:09.540 --> 00:17:12.780
to iterate through the list and just grab the items that you care about.


00:17:12.780 --> 00:17:15.100
And you only get the unique items out of it.


00:17:15.100 --> 00:17:20.320
The interesting part about sets as well is that they're all one.


00:17:20.320 --> 00:17:25.580
So when you're making a membership test, you can, it's fast, it's considerably faster than


00:17:25.580 --> 00:17:29.080
going through, say, a list where you have to iterate through the entire list to see


00:17:29.080 --> 00:17:30.080
if the item is in it.


00:17:30.080 --> 00:17:31.080
Yeah, that's cool.


00:17:31.080 --> 00:17:32.940
I definitely like the distinct aspect.


00:17:32.940 --> 00:17:37.340
that's what I use a lot of sets for is like I have all these things, there might be duplication,


00:17:37.340 --> 00:17:42.780
I just want them one of each, you know, if there's duplicate, just don't add it right.


00:17:42.780 --> 00:17:48.020
So you can just like, you could even say set of some list, and then, you know, just get


00:17:48.020 --> 00:17:51.380
that back as here's the distinct stuff in the list, which is great.


00:17:51.380 --> 00:17:54.180
Also for simplifying conditionals.


00:17:54.180 --> 00:17:58.220
So you have the example, well, real Python had the sample and the stuff you covered about


00:17:58.220 --> 00:18:05.660
parentheses of if item equals x or item equals y or item equals z or whatever,


00:18:05.660 --> 00:18:09.980
right? Like that becomes like kind of a nasty multi-line looking thing. Maybe a


00:18:09.980 --> 00:18:14.820
more Pythonic way would be say if x is in set, you know, curly set x, y, z. Right.


00:18:14.820 --> 00:18:19.300
You can do stuff like that. It's always another point to keep in mind is sets


00:18:19.300 --> 00:18:28.100
are sets are of immutable values. So you can't put like say a normal set inside


00:18:28.100 --> 00:18:32.020
of a set, there's other value types and stuff like that.


00:18:32.020 --> 00:18:33.420
You can't just like stick in a set.


00:18:33.420 --> 00:18:33.700
Right.


00:18:33.700 --> 00:18:36.260
So it has to be hashable, basically same as dictionary keys.


00:18:36.260 --> 00:18:37.180
Yeah.


00:18:37.180 --> 00:18:37.780
Yeah.


00:18:37.780 --> 00:18:38.420
Right.


00:18:38.420 --> 00:18:39.180
So it can't change.


00:18:39.180 --> 00:18:43.180
But it's always, always interesting to remember once you've made a set that


00:18:43.180 --> 00:18:47.260
you're looking for distinct values and things like that, I always try to look


00:18:47.260 --> 00:18:52.180
through my code, if there's some sort of, if I'm checking, if item is in list one.


00:18:52.180 --> 00:18:55.820
And also in list two, because you can always have two sets and do


00:18:55.820 --> 00:18:56.980
an intersection between them.


00:18:57.580 --> 00:19:01.740
And then you don't have to do those for loops and the code is kind of optimized to do that for you,


00:19:01.740 --> 00:19:06.940
which I'm sure will not be O of N squared, I think, when you're writing your code, right?


00:19:06.940 --> 00:19:07.660
Yeah, exactly.


00:19:07.660 --> 00:19:11.420
And then just to quickly look back on immutability,


00:19:11.420 --> 00:19:15.340
if you want to make a set of sets, there's also such a thing as a frozen set,


00:19:15.340 --> 00:19:20.140
where the set itself is immutable, and you can stick that into a set.


00:19:20.140 --> 00:19:21.660
So stuff like that.


00:19:21.660 --> 00:19:22.460
That's very meta.


00:19:22.460 --> 00:19:23.580
Brian, do you use sets very often?


00:19:23.580 --> 00:19:26.380
I always have a tutorial like this or something to look up,


00:19:26.380 --> 00:19:29.420
because I forget what the operators are.


00:19:29.420 --> 00:19:33.740
Because it does have union, intersection, difference,


00:19:33.740 --> 00:19:35.620
symmetric difference, things like that.


00:19:35.620 --> 00:19:39.620
And remembering all of that stuff from your college days


00:19:39.620 --> 00:19:43.660
is good to try to make some elegant code.


00:19:43.660 --> 00:19:47.140
But it has, for instance, the union operator is,


00:19:47.140 --> 00:19:49.420
you can just use the bar function for that.


00:19:49.420 --> 00:19:52.700
And looking up all those is a good thing.


00:19:52.700 --> 00:19:55.060
Although, since I know I have to look it up,


00:19:55.060 --> 00:20:01.900
I usually put a comment in there to tell anybody else what I'm doing to say this is a set operation


00:20:01.900 --> 00:20:02.900
going on here.


00:20:02.900 --> 00:20:03.900
Yeah, it makes sense.


00:20:03.900 --> 00:20:09.440
I feel like sometimes knowing the right data structure can really open people's eyes, really


00:20:09.440 --> 00:20:11.500
change the way they're doing something.


00:20:11.500 --> 00:20:15.660
And sets and dictionaries definitely seem to fall into that space where you don't use


00:20:15.660 --> 00:20:19.940
them that much, but when you do, you're like, "Whoa, that really is better."


00:20:19.940 --> 00:20:20.940
So many ways.


00:20:20.940 --> 00:20:26.940
also one of those things of like it's a new hammer. Try to be sure that you don't see


00:20:26.940 --> 00:20:31.100
everything as a set problem because everything isn't a set problem.


00:20:31.100 --> 00:20:36.220
Yeah, for sure. All right, so last item that I wanted to cover on this episode is a little


00:20:36.220 --> 00:20:42.380
bit of a look ahead maybe to next week, but to put this on people's radar so when it launches


00:20:42.380 --> 00:20:48.060
you can like do maybe a backflip or something if you've been practicing. So coming up, we


00:20:48.060 --> 00:20:55.720
We just had the release of Python 3.7 release candidate one, which was on June 12, and expected


00:20:55.720 --> 00:21:01.900
or planned for June 27, which is seven days from now is the final release of Python 3.7


00:21:01.900 --> 00:21:02.900
official.


00:21:02.900 --> 00:21:03.900
How about that?


00:21:03.900 --> 00:21:04.900
I'm so excited.


00:21:04.900 --> 00:21:06.060
Do you know what makes me most excited about this?


00:21:06.060 --> 00:21:09.700
There's certain things in here like okay, cool, date breakpoint, that's kind of nice


00:21:09.700 --> 00:21:11.200
data classes kind of nice.


00:21:11.200 --> 00:21:16.940
But what really makes me most excited is this is the categorically fastest Python period.


00:21:16.940 --> 00:21:21.820
So all the people that say no, we're using legacy Python, because under this particular


00:21:21.820 --> 00:21:26.940
use case, it's faster than Python three, seven, and there may still be some very narrow use


00:21:26.940 --> 00:21:27.940
case.


00:21:27.940 --> 00:21:33.340
But generally speaking, this is the fastest Python period, it's much faster than Python


00:21:33.340 --> 00:21:38.780
three, certainly up to three, three, but it's it's even quite a bit faster than three, six.


00:21:38.780 --> 00:21:43.740
So for example, from three, six to three, seven, when you're calling methods, especially


00:21:43.740 --> 00:21:49.660
methods that are part of classes, not standalone functions, but like bound methods to classes.


00:21:49.660 --> 00:21:50.660
It's like 20% faster.


00:21:50.660 --> 00:21:52.660
That's a reason right there to switch.


00:21:52.660 --> 00:21:53.660
Yeah.


00:21:53.660 --> 00:21:55.940
And what's cool, like all you got to do is just run on the new version, right?


00:21:55.940 --> 00:21:58.580
There's no like, oh, I switched to pipe, pipe or something.


00:21:58.580 --> 00:22:00.420
It's just, I now have three seven.


00:22:00.420 --> 00:22:02.940
So life is better, especially if you're using a framework.


00:22:02.940 --> 00:22:03.940
Yeah.


00:22:03.940 --> 00:22:06.980
Anybody who's using a framework, remember, there's a bunch of levels of abstraction around


00:22:06.980 --> 00:22:07.980
it.


00:22:07.980 --> 00:22:08.980
So there's a bunch of function calls.


00:22:08.980 --> 00:22:09.980
Exactly.


00:22:09.980 --> 00:22:10.980
Yeah.


00:22:10.980 --> 00:22:11.980
There's tons of function calls.


00:22:11.980 --> 00:22:14.820
So this is really, really good news.


00:22:14.820 --> 00:22:16.420
So just to run through some of the features,


00:22:16.420 --> 00:22:21.420
there's improvements to coupling that type annotations


00:22:21.420 --> 00:22:24.700
or type hints added to the system.


00:22:24.700 --> 00:22:28.220
So previously, if I wanted to say here's a function


00:22:28.220 --> 00:22:30.700
and it returns this type of thing, right?


00:22:30.700 --> 00:22:33.420
It returns like this object or some type I've defined,


00:22:33.420 --> 00:22:35.620
I have to literally import that type


00:22:35.620 --> 00:22:37.420
at the top of that file.


00:22:37.420 --> 00:22:40.100
And what that means is at import time,


00:22:40.100 --> 00:22:43.360
I pay an extra import processing that file,


00:22:43.360 --> 00:22:46.280
which I might not have otherwise loaded potentially,


00:22:46.280 --> 00:22:48.040
or at least not right then.


00:22:48.040 --> 00:22:50.960
The other one is circular dependencies


00:22:50.960 --> 00:22:52.840
are super annoying in that.


00:22:52.840 --> 00:22:56.640
Like, so for example, I've got like a repository class


00:22:56.640 --> 00:22:59.480
and it returns some kind of object, right?


00:22:59.480 --> 00:23:00.920
But that object when it's defined,


00:23:00.920 --> 00:23:02.120
it has to know about the repository.


00:23:02.120 --> 00:23:05.360
So it says it returned, like it uses this somewhere else.


00:23:05.360 --> 00:23:08.480
Like that basically will fail and break the import


00:23:08.480 --> 00:23:10.080
because it's circular, right?


00:23:10.080 --> 00:23:16.160
So with this new thing, this change is, instead of actually evaluating these type ints and


00:23:16.160 --> 00:23:21.480
having to import them, it's just evaluated as if you would type them as strings.


00:23:21.480 --> 00:23:25.920
So they're not actually evaluating the true types when you do type annotation.


00:23:25.920 --> 00:23:29.440
So that gives you more flexibility, the circular dependencies aren't a problem, and it's faster.


00:23:29.440 --> 00:23:30.440
Yeah.


00:23:30.440 --> 00:23:31.440
Yeah.


00:23:31.440 --> 00:23:32.440
Yeah.


00:23:32.440 --> 00:23:34.720
The one that this, the type annotations thing that makes me the most crazy is I have a class


00:23:34.720 --> 00:23:38.520
and it's got like some function that returns an instance of itself.


00:23:38.520 --> 00:23:43.920
You can't say that in the previous type ins as a concrete types because you can't say


00:23:43.920 --> 00:23:46.420
the name of the class until it's fully defined.


00:23:46.420 --> 00:23:50.600
But you're halfway through the class trying to say this method returns one of me.


00:23:50.600 --> 00:23:54.840
You can get around it by putting quotes, but that's effectively like what this does without


00:23:54.840 --> 00:23:56.440
the syntax to put in the quotes.


00:23:56.440 --> 00:23:57.440
So it looks more natural.


00:23:57.440 --> 00:23:59.680
So you can do that now with the three side.


00:23:59.680 --> 00:24:03.960
Yeah, but you have to put quotes and you have to like say the name out exactly in as a string.


00:24:03.960 --> 00:24:04.960
Okay.


00:24:04.960 --> 00:24:05.960
Yeah.


00:24:05.960 --> 00:24:06.960
Let's take a look at that.


00:24:06.960 --> 00:24:07.960
Yeah, it's pretty cool.


00:24:07.960 --> 00:24:12.280
data classes, which are really nice. They're kind of like tuples. They have a lot of interesting


00:24:12.280 --> 00:24:18.760
hashing and equality operators on them as well as representation ones, they can be frozen,


00:24:18.760 --> 00:24:23.800
so they can be mutable or immutable, all sorts of things. So kind of like enumeration name tuple,


00:24:23.800 --> 00:24:30.680
tuple, it's stuff all brought together. It's sort of a derivative of the adders project,


00:24:30.680 --> 00:24:34.440
but they decided not to move adders into the framework because it's evolving quickly and


00:24:34.440 --> 00:24:35.880
and they don't want to like freeze it.


00:24:35.880 --> 00:24:37.760
So data classes kind of same thing.


00:24:37.760 --> 00:24:41.300
I just want to point out that data classes has a backport for 3.6.


00:24:41.300 --> 00:24:45.480
So you can go ahead and start using those in 3.6 as long as you pip install them first.


00:24:45.480 --> 00:24:46.480
Yeah, how do I get that?


00:24:46.480 --> 00:24:48.320
Oh, did pip install data classes?


00:24:48.320 --> 00:24:49.320
pip install data classes.


00:24:49.320 --> 00:24:50.600
Oh, that's pretty killer.


00:24:50.600 --> 00:24:51.960
I didn't know about that.


00:24:51.960 --> 00:24:56.440
Alright, so there's a new breakpoint function, which we talked about, we don't use that much


00:24:56.440 --> 00:25:01.120
because like if you just fire a PyCharm, who cares, but there's some pretty interesting


00:25:01.120 --> 00:25:03.400
It's got to be click in the gutters.


00:25:03.400 --> 00:25:08.080
But there's actually some pretty interesting ways to like, say, hook a remote debugger


00:25:08.080 --> 00:25:09.800
to your code, things like that.


00:25:09.800 --> 00:25:11.360
There's really interesting stuff going on there.


00:25:11.360 --> 00:25:12.360
AsyncIO got better.


00:25:12.360 --> 00:25:13.720
Chris, you should be happy about that.


00:25:13.720 --> 00:25:14.720
Did you see these?


00:25:14.720 --> 00:25:15.960
Some of this is pretty cool.


00:25:15.960 --> 00:25:16.960
Tell me about it.


00:25:16.960 --> 00:25:22.040
This AsyncIO run function is a way of running a coroutine from synchronous code, which I


00:25:22.040 --> 00:25:25.920
mean that existed before, but you had to do like 50 million things to set your stuff up


00:25:25.920 --> 00:25:28.160
correctly and make sure you didn't break other.


00:25:28.160 --> 00:25:32.000
You just call run and it will internally create the loop and do it for you?


00:25:32.000 --> 00:25:34.560
Yep. Just call run, starts coroutine.


00:25:34.560 --> 00:25:35.920
Oh, that is sweet.


00:25:35.920 --> 00:25:40.080
It starts an event loop, runs your coroutine, and closes the event loop at the end.


00:25:40.080 --> 00:25:42.800
So you're going to have to be careful when you use this. This is pretty cool.


00:25:42.800 --> 00:25:48.560
And there's some of the task management stuff that's also a little bit better.


00:25:48.560 --> 00:25:52.160
So this is pretty cool. I'll have to maybe write a post on this.


00:25:52.160 --> 00:25:53.680
Yeah, that's awesome. Yeah, definitely cool.


00:25:53.680 --> 00:25:56.880
Another one that's really nice is the time module.


00:25:57.520 --> 00:26:02.960
and a bunch of other functions as well have become more accurate, especially over long durations,


00:26:02.960 --> 00:26:09.200
and they've taken on nanosecond resolution. So you can import time and say time,


00:26:09.200 --> 00:26:13.840
you just call time, and it'll give you a floating point value of the number of seconds since the


00:26:13.840 --> 00:26:22.240
epoch, like 1970. But this, you can also now in 3.7 say time_ns, and it'll give you the nanoseconds


00:26:22.240 --> 00:26:25.560
as an integer and because it's an integer not a float,


00:26:25.560 --> 00:26:28.600
that means there's no drift or anything


00:26:28.600 --> 00:26:30.240
in sort of the floating point operations.


00:26:30.240 --> 00:26:33.240
It's like truly the nanoseconds, which is awesome.


00:26:33.240 --> 00:26:34.480
All right, and finally I just wanna close out,


00:26:34.480 --> 00:26:37.160
give it like what would a Python Bytes show be


00:26:37.160 --> 00:26:40.000
without a shout out to Anthony Shaw, right Brian?


00:26:40.000 --> 00:26:42.480
- Yeah, he's been a part of the show a lot.


00:26:42.480 --> 00:26:43.440
- For sure.


00:26:43.440 --> 00:26:46.560
So he actually did a brand new course


00:26:46.560 --> 00:26:49.600
on Pluralsight called What's New in Python 3.7.


00:26:49.600 --> 00:26:51.360
So I put a link to his course there as well.


00:26:51.360 --> 00:26:53.400
And actually, it's only about an hour long,


00:26:53.400 --> 00:26:55.600
but it goes really in-depth into the advantages


00:26:55.600 --> 00:26:56.740
or all these various things.


00:26:56.740 --> 00:26:58.040
So quite cool.


00:26:58.040 --> 00:26:59.880
If that's easy for you to check out,


00:26:59.880 --> 00:27:01.360
go ahead and drop over there


00:27:01.360 --> 00:27:02.800
and check out Anthony's course.


00:27:02.800 --> 00:27:04.060
Very nice.


00:27:04.060 --> 00:27:06.320
Yeah, so I'm really excited for when this ships.


00:27:06.320 --> 00:27:07.600
I think it's gonna be great.


00:27:07.600 --> 00:27:09.800
There always seems to be some latency


00:27:09.800 --> 00:27:11.600
on the Linux distributions and stuff


00:27:11.600 --> 00:27:12.960
before I can really make use of it,


00:27:12.960 --> 00:27:16.080
but pretty soon I'll be happy to be running this.


00:27:16.080 --> 00:27:16.920
- Yeah, definitely.


00:27:16.920 --> 00:27:19.280
- Yeah, you guys have any extra news that you wanna cover?


00:27:19.280 --> 00:27:21.000
That's it for our official items.


00:27:21.000 --> 00:27:23.960
I've been doing a lot of going back,


00:27:23.960 --> 00:27:28.040
went through all of the code that was in the pytest book


00:27:28.040 --> 00:27:30.480
to make sure it's 3.7 compatible,


00:27:30.480 --> 00:27:33.400
which I was happy to find out that it's fine.


00:27:33.400 --> 00:27:34.920
So that's good. - Nice.


00:27:34.920 --> 00:27:35.760
Yeah, very cool.


00:27:35.760 --> 00:27:40.760
- I saw this really cool tutorial series about Mongo.


00:27:40.760 --> 00:27:42.480
Do you know anything about this?


00:27:42.480 --> 00:27:44.800
- May have spent an incredible amount of time


00:27:44.800 --> 00:27:45.780
working on this project.


00:27:45.780 --> 00:27:50.280
Yeah, so I did a three-part, three-hour webcast series


00:27:50.280 --> 00:27:52.600
in partnership with MongoDB.


00:27:52.600 --> 00:27:56.500
And basically from concept to actually deploying it


00:27:56.500 --> 00:28:01.500
on DigitalOcean actually, I rebuilt the pypi.org website


00:28:01.500 --> 00:28:04.400
in MongoDB and then published it to the internet.


00:28:04.400 --> 00:28:06.060
Which I then deleted so I don't have to pay


00:28:06.060 --> 00:28:07.920
to keep it running 'cause there's a real one.


00:28:07.920 --> 00:28:10.640
But yeah, it's recorded, people can go check it out.


00:28:10.640 --> 00:28:12.360
You got the link in the show notes, so that's awesome.


00:28:12.360 --> 00:28:14.240
- Yeah, nice, it looks pretty fun.


00:28:14.240 --> 00:28:15.400
- Yeah, thanks for the shout out.


00:28:15.400 --> 00:28:16.860
Chris, anything you wanna let people know about


00:28:16.860 --> 00:28:17.700
while you're here?


00:28:17.700 --> 00:28:18.880
- Nope, I don't really have anything new.


00:28:18.880 --> 00:28:22.720
Maybe just keep an eye out for a few new posts coming up,


00:28:22.720 --> 00:28:24.440
then try to accept that.


00:28:24.440 --> 00:28:26.600
And my new blog.


00:28:26.600 --> 00:28:28.040
- Awesome, yeah, there might be one


00:28:28.040 --> 00:28:29.920
about this asyncio.run, huh?


00:28:29.920 --> 00:28:31.080
- Yeah.


00:28:31.080 --> 00:28:32.120
- Yeah, you called it out.


00:28:32.120 --> 00:28:33.800
You gotta write it now, so.


00:28:33.800 --> 00:28:34.640
- Yeah.


00:28:34.640 --> 00:28:36.360
- Remember, the internet is written in ink,


00:28:36.360 --> 00:28:39.280
and so this is permanent now.


00:28:39.280 --> 00:28:42.520
- My next post was gonna be about one of my modules


00:28:42.520 --> 00:28:44.400
which uses asyncio a bunch,


00:28:44.400 --> 00:28:48.080
so maybe I'm going to go back and experiment


00:28:48.080 --> 00:28:50.680
with 3.7 and what changes I would have to do there to write it up.


00:28:50.680 --> 00:28:52.320
So this is pretty cool.


00:28:52.320 --> 00:28:53.120
Yeah, awesome.


00:28:53.120 --> 00:28:54.480
Well, Chris, thanks for being on the show.


00:28:54.480 --> 00:28:55.920
And Brian, thank you as always.


00:28:55.920 --> 00:28:56.400
Yeah, thank you.


00:28:56.400 --> 00:28:58.080
Thanks for having me.


00:28:58.080 --> 00:28:59.840
Thank you for listening to Python Bytes.


00:28:59.840 --> 00:29:02.320
Follow the show on Twitter via @pythonbytes.


00:29:02.320 --> 00:29:05.520
That's Python Bytes as in B-Y-T-E-S.


00:29:05.520 --> 00:29:08.920
And get the full show notes at pythonbytes.fm.


00:29:08.920 --> 00:29:11.960
If you have a news item you want featured, just visit pythonbytes.fm


00:29:11.960 --> 00:29:12.960
and send it our way.


00:29:12.960 --> 00:29:16.120
We're always on the lookout for sharing something cool.


00:29:16.120 --> 00:29:17.980
On behalf of myself and Brian Okken,


00:29:17.980 --> 00:29:19.500
this is Michael Kennedy.


00:29:19.500 --> 00:29:21.500
Thank you for listening and sharing this podcast


00:29:21.500 --> 00:29:23.100
with your friends and colleagues.

