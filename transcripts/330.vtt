WEBVTT

00:00:00.000 --> 00:00:01.720
- Hello and welcome to Python Bytes,


00:00:01.720 --> 00:00:03.740
where we deliver Python news and headlines


00:00:03.740 --> 00:00:05.460
directly to your earbuds.


00:00:05.460 --> 00:00:10.460
This is episode 330, recorded April 4th, 2023.


00:00:10.460 --> 00:00:11.620
I'm Michael Kennedy.


00:00:11.620 --> 00:00:12.740
- And I'm Brian Okken.


00:00:12.740 --> 00:00:16.660
- And you can connect with us over on FaucetOn.


00:00:16.660 --> 00:00:18.700
If you're on Mastodon, find us there.


00:00:18.700 --> 00:00:20.940
I'm at mkennedy@fauceton.org.


00:00:20.940 --> 00:00:22.460
Brian's Brian Okken over there.


00:00:22.460 --> 00:00:25.300
And the show is at pythonbytes@fauceton.org.


00:00:25.300 --> 00:00:29.020
And if you're interested in the video version,


00:00:29.020 --> 00:00:31.920
Check out pythonbytes.fm/live, click that,


00:00:31.920 --> 00:00:34.020
go over to the YouTube channel, subscribe, get notified,


00:00:34.020 --> 00:00:37.520
you'll get a little pop-up when we start streaming live.


00:00:37.520 --> 00:00:39.260
It's always fun to be part of it.


00:00:39.260 --> 00:00:42.260
We encourage people to check the show out that way as well.


00:00:42.260 --> 00:00:44.440
So Brian, let's start off with something


00:00:44.440 --> 00:00:47.980
that has been almost exactly one year in the works.


00:00:47.980 --> 00:00:50.620
- I was just gonna ask you about that.


00:00:50.620 --> 00:00:53.960
So was this about a year ago


00:00:53.960 --> 00:00:56.540
we talked about this Pydantic re-arrange?


00:00:56.540 --> 00:01:05.020
I think I saw something on Twitter of all places from Samuel Colvin saying it was April


00:01:05.020 --> 00:01:09.900
4th, 2022 that I started working on Pydantic version two.


00:01:09.900 --> 00:01:11.740
So that sounds like to the day.


00:01:11.740 --> 00:01:12.740
Okay.


00:01:12.740 --> 00:01:16.960
Well, it's, it's not completely here yet, but it's here enough to try.


00:01:16.960 --> 00:01:18.420
So I'm pretty excited about it.


00:01:18.420 --> 00:01:22.940
So by Pydantic V2 version two pre-release.


00:01:22.940 --> 00:01:24.980
So people can, it's available now.


00:01:24.980 --> 00:01:26.460
so people can install it.


00:01:26.460 --> 00:01:31.460
You have to do the, like the pip install dash dash pre


00:01:31.460 --> 00:01:33.340
Pynantic, and then you can say


00:01:33.340 --> 00:01:37.140
Bitantic greater than or equal to 2.0 A1,


00:01:37.140 --> 00:01:39.900
I guess, if you want to get the alpha one or better.


00:01:39.900 --> 00:01:42.880
So the big news is alpha one's available.


00:01:42.880 --> 00:01:45.180
And it's pretty exciting.


00:01:45.180 --> 00:01:47.100
There's a whole bunch of great stuff changes.


00:01:47.100 --> 00:01:48.780
We've talked, I think we talked about it.


00:01:48.780 --> 00:01:50.460
You talked about it on your show, I think also.


00:01:50.460 --> 00:01:51.700
- Yeah, yeah.


00:01:51.700 --> 00:01:55.380
But the headlines here is,


00:01:55.380 --> 00:01:57.460
well, one, it's not complete yet.


00:01:57.460 --> 00:01:59.700
This is the alpha, we're not even debate is yet.


00:01:59.700 --> 00:02:03.060
So if you try it out and you see something,


00:02:03.060 --> 00:02:06.700
they've got a GitHub created GitHub issue.


00:02:06.700 --> 00:02:10.900
And they wanna have people use the bug v2 label


00:02:10.900 --> 00:02:13.700
to create issues around the version two,


00:02:13.700 --> 00:02:15.400
'cause they wanna hop on those right away.


00:02:15.400 --> 00:02:18.420
Anyway, so the big change was,


00:02:18.420 --> 00:02:23.300
One of the big changes was to move all a lot of Pydantic


00:02:23.300 --> 00:02:25.140
and the rules and everything


00:02:25.140 --> 00:02:28.840
into a different module called Pydantic Core.


00:02:28.840 --> 00:02:31.260
That one's mostly written in Rust.


00:02:31.260 --> 00:02:36.260
And so it's like five to 50 times faster overall


00:02:36.260 --> 00:02:38.100
for performance.


00:02:38.100 --> 00:02:39.340
So that's pretty exciting.


00:02:39.340 --> 00:02:40.900
'Cause these are, I mean, this is,


00:02:40.900 --> 00:02:42.260
when you're using Pydantic,


00:02:42.260 --> 00:02:44.140
it's hitting for every interaction, right?


00:02:44.140 --> 00:02:46.500
So as fast as possible is great.


00:02:47.380 --> 00:02:51.380
And I do like the idea of the separating the Rust part out


00:02:51.380 --> 00:02:54.500
into a different module, a different package,


00:02:54.500 --> 00:02:57.660
by data core, so that they can have--


00:02:57.660 --> 00:03:00.540
kind of maintain it and have safety and maintenance


00:03:00.540 --> 00:03:02.460
around that a little separate.


00:03:02.460 --> 00:03:03.860
I think that makes sense.


00:03:03.860 --> 00:03:07.640
Yeah, and people used to have to create their derived classes


00:03:07.640 --> 00:03:09.220
and put a lot of their customization


00:03:09.220 --> 00:03:10.660
in their--


00:03:10.660 --> 00:03:12.820
what's called root level validators and things


00:03:12.820 --> 00:03:13.740
like that, where it's like, I want


00:03:13.740 --> 00:03:16.220
to validate the whole class, not just a certain field.


00:03:16.220 --> 00:03:19.460
or if this is set, then that has to be set that way.


00:03:19.460 --> 00:03:22.780
A lot of those things had to be done in an OOP way.


00:03:22.780 --> 00:03:24.420
And I think with the PyDandic core,


00:03:24.420 --> 00:03:27.380
you have more direct access to a layer below.


00:03:27.380 --> 00:03:29.820
So it's not just faster, which is fantastic,


00:03:29.820 --> 00:03:33.460
but it also opens up more ways to interact with PyDandic,


00:03:33.460 --> 00:03:34.340
which is cool.


00:03:34.340 --> 00:03:35.420
- Yeah.


00:03:35.420 --> 00:03:38.660
So they've got a lot of stuff working already.


00:03:38.660 --> 00:03:41.500
They want people to be able to experiment and try out


00:03:41.500 --> 00:03:46.180
their base model changes, a lot of the same features


00:03:46.180 --> 00:03:48.740
for validation, but there's new method names.


00:03:48.740 --> 00:03:51.020
And it is a change.


00:03:51.020 --> 00:03:53.420
Data classes, serialization, strict mode,


00:03:53.420 --> 00:03:56.580
different schemas, lots of changes for V2.


00:03:56.580 --> 00:03:58.800
So I'd like people to try it out.


00:03:58.800 --> 00:04:03.780
There is a lot of stuff still under construction,


00:04:03.780 --> 00:04:05.740
mostly documentation.


00:04:05.740 --> 00:04:09.300
And some of the base settings have changed from,


00:04:09.300 --> 00:04:10.220
they were base settings,


00:04:10.220 --> 00:04:12.360
and now they're gonna be in by identic settings.


00:04:12.360 --> 00:04:14.000
That's not quite ready.


00:04:14.000 --> 00:04:17.080
So there's still some work to do,


00:04:17.080 --> 00:04:18.320
even in the migration guide.


00:04:18.320 --> 00:04:20.780
So they've gotten a start on the migration guide,


00:04:20.780 --> 00:04:21.620
but it's not there.


00:04:21.620 --> 00:04:23.800
As you see on some of the links,


00:04:23.800 --> 00:04:27.320
there's changes to data classes, changes to base model.


00:04:27.320 --> 00:04:29.240
Some of the stuff's already there,


00:04:29.240 --> 00:04:31.600
but it's still under construction.


00:04:31.600 --> 00:04:33.160
So pretty exciting.


00:04:33.160 --> 00:04:34.880
- I'm definitely excited.


00:04:34.880 --> 00:04:39.400
And the five to 50 times faster, that's no joke.


00:04:39.400 --> 00:04:41.360
There's the idea, okay, well, what are you doing?


00:04:41.360 --> 00:04:43.280
I'm like parsing a settings file,


00:04:43.280 --> 00:04:45.560
I got a single JSON document, whatever.


00:04:45.560 --> 00:04:48.840
All of FastAPI is deeply, not all,


00:04:48.840 --> 00:04:51.200
but much of FastAPI is deeply based


00:04:51.200 --> 00:04:54.640
on exchanging rich data with Pydantic, right?


00:04:54.640 --> 00:04:58.520
So your API layer could get much faster, right?


00:04:58.520 --> 00:05:02.340
And you can also use this, people maybe don't realize it.


00:05:02.340 --> 00:05:04.720
You can use this with other frameworks as well.


00:05:04.720 --> 00:05:07.720
You could use it with Flask, you could use it with Pyramid.


00:05:07.720 --> 00:05:09.640
FastAPI is cool 'cause you can put just,


00:05:09.640 --> 00:05:12.480
there's a argument of type Pydantic model


00:05:12.480 --> 00:05:14.320
and it automatically fills it all in.


00:05:14.320 --> 00:05:16.120
But all you got to do is just take,


00:05:16.120 --> 00:05:18.680
here's the post dictionary and feed it to a Pydantic model.


00:05:18.680 --> 00:05:20.400
Like just inside the function is


00:05:20.400 --> 00:05:22.120
the first line and you're in the same place.


00:05:22.120 --> 00:05:22.360
>> Yeah.


00:05:22.360 --> 00:05:24.560
>> So you can use this across all these areas.


00:05:24.560 --> 00:05:28.240
Then for example, Python bytes.fm is powered by Beanie,


00:05:28.240 --> 00:05:32.200
which is Pydantic plus MongoDB plus Async, which is awesome.


00:05:32.200 --> 00:05:35.400
But every single database record comes back,


00:05:35.400 --> 00:05:36.480
goes through Pydantic.


00:05:36.480 --> 00:05:39.200
If you're using something like Beanie or SQL model,


00:05:39.200 --> 00:05:41.680
and fast API, your data layer goes through Pydantic,


00:05:41.680 --> 00:05:46.000
and your web layer, 'cause there's like multi-layered


00:05:46.000 --> 00:05:48.440
Pydantic operations on every interaction.


00:05:48.440 --> 00:05:51.500
And so making that part five to 50 times faster


00:05:51.500 --> 00:05:53.640
is just huge, right?


00:05:53.640 --> 00:05:56.280
That's a really big surface area to make a lot faster.


00:05:56.280 --> 00:05:59.080
I got speedups as well to talk about later in the show.


00:05:59.080 --> 00:06:01.720
But it's not that much area, that's awesome.


00:06:01.720 --> 00:06:04.120
- One of the things you bring up, which is interesting,


00:06:04.120 --> 00:06:07.040
is that a lot of people, I mean there's tons of people


00:06:07.040 --> 00:06:11.080
that use Pydantic just by itself with their own code.


00:06:11.080 --> 00:06:15.240
But the people that mostly touch it through FastAPI or Beanie


00:06:15.240 --> 00:06:18.600
or something, they may have to wait until those projects


00:06:18.600 --> 00:06:22.840
bring on the changes then, unless those projects have


00:06:22.840 --> 00:06:24.840
branches for B2, which who knows?


00:06:24.840 --> 00:06:27.640
>> I hope so.


00:06:27.640 --> 00:06:29.120
And maybe there's a way--


00:06:29.120 --> 00:06:33.520
I think the breaking changes in, say, base model, for example,


00:06:33.520 --> 00:06:34.280
are--


00:06:34.280 --> 00:06:38.880
I think they're kind of deprecated already in 1.10.7.


00:06:38.880 --> 00:06:40.240
Just they're still there.


00:06:40.240 --> 00:06:42.760
but I think they become breaking changes here.


00:06:42.760 --> 00:06:47.400
If you're also, if you're doing model validation,


00:06:47.400 --> 00:06:50.800
a lot of the function names gets changed.


00:06:50.800 --> 00:06:53.320
Yeah, like things like from RM go away.


00:06:53.320 --> 00:06:56.120
There's a bunch of little, I don't think they're big changes


00:06:56.120 --> 00:06:57.640
that are gonna be a huge problem for people,


00:06:57.640 --> 00:07:00.000
but they are incompatibilities, as you point out.


00:07:00.000 --> 00:07:02.560
Both Roman Wright and Sebastian Ramirez


00:07:02.560 --> 00:07:04.720
seem to be really on top of their projects,


00:07:04.720 --> 00:07:06.480
respectively Beanie and FastAPI.


00:07:06.480 --> 00:07:10.200
So I feel like by the time this becomes fully released,


00:07:10.200 --> 00:07:11.200
will be there.


00:07:11.200 --> 00:07:13.280
- Yeah, and what's one of the reasons why I covered it


00:07:13.280 --> 00:07:14.880
is to try to like promote everybody.


00:07:14.880 --> 00:07:16.200
- Nudge nudge, hey, exactly.


00:07:16.200 --> 00:07:17.040
- Nudge nudge.


00:07:17.040 --> 00:07:17.860
(laughing)


00:07:17.860 --> 00:07:18.700
- Exactly.


00:07:18.700 --> 00:07:19.540
- Please.


00:07:19.540 --> 00:07:20.360
(laughing)


00:07:20.360 --> 00:07:22.000
- So, yes, indeed.


00:07:22.000 --> 00:07:23.880
Yeah, it would be awesome that when this comes out


00:07:23.880 --> 00:07:25.940
for just boom, V2 is out,


00:07:25.940 --> 00:07:28.720
like you just update all the packages that depend upon it


00:07:28.720 --> 00:07:30.840
and you can adopt it right away, that would be great.


00:07:30.840 --> 00:07:33.560
- But to be fair, like let's say I'm working on


00:07:33.560 --> 00:07:36.320
like a side project that's using FastAPI


00:07:36.320 --> 00:07:37.520
or Beanie or something,


00:07:37.520 --> 00:07:39.340
and I don't have it in production yet,


00:07:39.340 --> 00:07:42.860
I'd be like, yeah, let's use V2 right away.


00:07:42.860 --> 00:07:44.520
But if I've got a production system,


00:07:44.520 --> 00:07:46.080
I don't want to switch right away.


00:07:46.080 --> 00:07:50.440
So I get that there's projects at different levels


00:07:50.440 --> 00:07:53.080
and group projects like FastAPI and BNI


00:07:53.080 --> 00:07:54.460
have to keep that in mind.


00:07:54.460 --> 00:07:55.880
So yeah.


00:07:55.880 --> 00:07:56.720
All right.


00:07:56.720 --> 00:07:58.760
- All right, well, this is exciting to me.


00:07:58.760 --> 00:08:00.420
I've known this has been coming for a long time.


00:08:00.420 --> 00:08:01.660
So excellent work.


00:08:01.660 --> 00:08:03.400
- What you got for us?


00:08:03.400 --> 00:08:05.840
- Well, that's quick real-time follow-up.


00:08:05.840 --> 00:08:08.080
I interviewed Samuel Colvin.


00:08:08.080 --> 00:08:10.120
He loves to do stuff on the fourth of months,


00:08:10.120 --> 00:08:11.680
apparently on August 4th,


00:08:11.680 --> 00:08:15.520
as well, last year called Titanic V2, the plan.


00:08:15.520 --> 00:08:18.080
So people can check that out if they're interested.


00:08:18.080 --> 00:08:20.360
Let's talk about something really small,


00:08:20.360 --> 00:08:22.800
okay? From a friend of the show,


00:08:22.800 --> 00:08:26.760
Miguel Grinberg, and he created this thing called micro dot.


00:08:26.760 --> 00:08:28.400
Micro dot, it's very small.


00:08:28.400 --> 00:08:34.800
It's bigger even than the semi dot or the regular dot, very small.


00:08:35.240 --> 00:08:39.960
- No, so this is, yeah, so back to web frameworks.


00:08:39.960 --> 00:08:42.240
This is the impossibly small web framework


00:08:42.240 --> 00:08:44.360
for Python and MicroPython.


00:08:44.360 --> 00:08:47.920
So it's, I believe it's reason for existence


00:08:47.920 --> 00:08:52.120
really is to basically bring something like Flask


00:08:52.120 --> 00:08:54.660
to MicroPython and CircuitPython, which is cool.


00:08:54.660 --> 00:08:57.600
However, it also runs under standard CPython,


00:08:57.600 --> 00:09:01.040
which opens up some interesting possibilities as well.


00:09:01.040 --> 00:09:04.000
So if we go down here.


00:09:04.000 --> 00:09:07.120
So if you're familiar with the Flask API,


00:09:07.120 --> 00:09:10.400
you should be real familiar with micro dot.


00:09:10.400 --> 00:09:13.360
So app equals, instead of Flask, you say micro dot.


00:09:13.360 --> 00:09:17.320
Got a function, it says I want to do an app.route on it.


00:09:17.320 --> 00:09:20.640
Or I don't know if he supports a direct verb,


00:09:20.640 --> 00:09:22.560
HTTP verbs there like app.get,


00:09:22.560 --> 00:09:25.120
app.post like Flask adopted recently,


00:09:25.120 --> 00:09:26.780
but app.route for sure.


00:09:26.780 --> 00:09:29.360
And then one of the differences is you have to pass


00:09:29.360 --> 00:09:32.480
a request object into the functions there,


00:09:32.480 --> 00:09:36.600
whereas Flask has this thread local ambient variation


00:09:36.600 --> 00:09:37.560
of this thing.


00:09:37.560 --> 00:09:40.560
So you'll get like a 500 error if you try to,


00:09:40.560 --> 00:09:42.720
you know, just run this directly


00:09:42.720 --> 00:09:43.840
without adding that request.


00:09:43.840 --> 00:09:44.860
So it's easy to overlook.


00:09:44.860 --> 00:09:46.560
But other than that, other than the fact


00:09:46.560 --> 00:09:50.320
that there's a request parameter to the views,


00:09:50.320 --> 00:09:51.840
basically the same thing.


00:09:51.840 --> 00:09:54.120
Okay, so yeah, that's pretty interesting.


00:09:54.120 --> 00:09:57.720
Now, there's a bunch of compromises that are made here


00:09:57.720 --> 00:10:00.600
because MicroPython doesn't support Jinja,


00:10:00.600 --> 00:10:03.360
It doesn't support Flask, all of these different things.


00:10:03.360 --> 00:10:06.880
All right, so there is a template language,


00:10:06.880 --> 00:10:09.320
but it's not Jinja, right?


00:10:09.320 --> 00:10:11.000
So there's a bit of a migration


00:10:11.000 --> 00:10:13.480
if you were going to take this on, right?


00:10:13.480 --> 00:10:15.480
So you can run it under CPython,


00:10:15.480 --> 00:10:18.380
but you can also run it under MicroPython.


00:10:18.380 --> 00:10:20.280
There's the HTTP methods.


00:10:20.280 --> 00:10:22.200
I think you see the old style.


00:10:22.200 --> 00:10:24.800
Yeah, no, no, there is an app.get.


00:10:24.800 --> 00:10:25.640
You can do the old style


00:10:25.640 --> 00:10:27.840
where you pass the method names like get and post,


00:10:27.840 --> 00:10:29.720
or you can just do an app.get.


00:10:29.720 --> 00:10:32.840
But yeah, again, if you're familiar with Flask,


00:10:32.840 --> 00:10:33.960
the way you do routes,


00:10:33.960 --> 00:10:35.760
the way you pass data into the functions,


00:10:35.760 --> 00:10:38.440
all those things are absolutely the same,


00:10:38.440 --> 00:10:40.120
which is pretty cool.


00:10:40.120 --> 00:10:43.200
One thing you can do is you can return JSON responses,


00:10:43.200 --> 00:10:45.320
and you can even just return a dictionary,


00:10:45.320 --> 00:10:47.920
which I don't think you can do in Flask.


00:10:47.920 --> 00:10:50.280
Maybe you can, but I think you have to JSONify it.


00:10:50.280 --> 00:10:51.840
I think you gotta say Flask.JSONify.


00:10:51.840 --> 00:10:54.420
So this is kind of an upgrade, I would say.


00:10:54.420 --> 00:10:57.160
So if you have a little tiny thing,


00:10:57.160 --> 00:10:58.400
like let's get it,


00:10:58.400 --> 00:11:00.080
little tiny thing like this, Brian.


00:11:00.080 --> 00:11:00.600
>> Okay.


00:11:00.600 --> 00:11:02.600
>> Right here. How big is that?


00:11:02.600 --> 00:11:04.880
Not by the size of my hand,


00:11:04.880 --> 00:11:06.880
half the way across the pole of my hand.


00:11:06.880 --> 00:11:08.920
Got one of these little tiny micro-Python,


00:11:08.920 --> 00:11:09.880
circuit Python things.


00:11:09.880 --> 00:11:12.080
You can now put APIs on here,


00:11:12.080 --> 00:11:14.980
and you can put even really interesting things


00:11:14.980 --> 00:11:17.880
like it has support for concurrency.


00:11:17.880 --> 00:11:19.720
So Flask doesn't support


00:11:19.720 --> 00:11:22.440
directly having async and await, I don't believe.


00:11:22.440 --> 00:11:24.840
Not fully anyway, you got to switch over to court to do that.


00:11:24.840 --> 00:11:26.400
I think they partially support it,


00:11:26.400 --> 00:11:28.460
but not full async and await.


00:11:28.460 --> 00:11:32.920
But you can use the MicroPython async I/O extension here


00:11:32.920 --> 00:11:35.800
and get APIs running with full async and await,


00:11:35.800 --> 00:11:39.420
concurrency support, doing JSON or other things,


00:11:39.420 --> 00:11:40.800
maybe with PyJSON, not sure.


00:11:40.800 --> 00:11:42.360
- That's pretty cool, 'cause a lot of the,


00:11:42.360 --> 00:11:44.320
I mean, that's just an easy, like,


00:11:44.320 --> 00:11:47.280
throw in a REST API or some sort of API on something


00:11:47.280 --> 00:11:49.680
to throw back JSON to,


00:11:49.680 --> 00:11:53.040
that would be really cool, and you don't need,


00:11:53.040 --> 00:11:54.520
I mean, for applications like that,


00:11:54.520 --> 00:11:57.040
you don't need a lot of templating around.


00:11:57.040 --> 00:12:00.580
- Yeah, and so let's see, go to the core extensions here.


00:12:00.580 --> 00:12:01.980
You can see there's actually a bunch


00:12:01.980 --> 00:12:03.000
of cool core extensions.


00:12:03.000 --> 00:12:04.700
So got the async and await support.


00:12:04.700 --> 00:12:06.440
So all you gotta do is just,


00:12:06.440 --> 00:12:11.320
just write async def endpoint, right?


00:12:11.320 --> 00:12:12.580
Boom, off it goes.


00:12:12.580 --> 00:12:15.320
- Yeah, 'cause you really wanna async that hello world.


00:12:15.320 --> 00:12:16.680
- Yeah, for hello world, not so much.


00:12:16.680 --> 00:12:18.300
But if you're talking to files


00:12:18.300 --> 00:12:19.680
that similar database or something.


00:12:19.680 --> 00:12:21.000
- Yeah, sure.


00:12:21.000 --> 00:12:23.140
- You can use, what is that, micro template?


00:12:23.140 --> 00:12:26.620
It says uTemplate, but I bet it's a micro.


00:12:26.620 --> 00:12:28.380
- I think it's pronounced template.


00:12:28.380 --> 00:12:30.740
- A template, yeah, uTemplate.


00:12:30.740 --> 00:12:36.060
It's a lightweight and memory efficient template for Python,


00:12:36.060 --> 00:12:40.260
which it looks very, very Jinja-like as well.


00:12:40.260 --> 00:12:41.980
So that's a pretty straightforward thing,


00:12:41.980 --> 00:12:43.540
but it's not identical, right?


00:12:43.540 --> 00:12:44.380
What else we got?


00:12:44.380 --> 00:12:46.180
- Ooh, this is Jinja, isn't it?


00:12:46.180 --> 00:12:47.800
- So, oh, can you?


00:12:47.800 --> 00:12:51.180
Oh, you, but no, hold on.


00:12:51.180 --> 00:12:52.580
It's CPython only.


00:12:52.580 --> 00:12:54.140
>> Okay. Got it.


00:12:54.140 --> 00:12:56.820
>> Because it's not supported in MicroPython.


00:12:56.820 --> 00:12:59.540
>> Got it. But if you're doing it on CPython,


00:12:59.540 --> 00:13:01.540
you can add those templates.


00:13:01.540 --> 00:13:03.580
>> Yes. This is actually why it's pretty interesting to me.


00:13:03.580 --> 00:13:06.460
So you can do TLS,


00:13:06.460 --> 00:13:09.020
HTTPS support, which is pretty cool.


00:13:09.020 --> 00:13:11.820
You have WebSockets, you have Asynchronous WebSockets,


00:13:11.820 --> 00:13:13.780
you have Cores, Cross-Origin,


00:13:13.780 --> 00:13:18.060
Resource Sharing settings, and you can even deploy it.


00:13:18.060 --> 00:13:20.220
So it comes with its own little web server,


00:13:20.220 --> 00:13:24.040
which you can run on your MicroPython DLE.


00:13:24.040 --> 00:13:27.140
But if you were going to put this into a big data center


00:13:27.140 --> 00:13:29.180
on a huge rack of servers,


00:13:29.180 --> 00:13:31.060
that might not be the best choice.


00:13:31.060 --> 00:13:33.980
So you can run it on MicroWSGI, which is awesome.


00:13:33.980 --> 00:13:35.620
You can run it on GUnicorn.


00:13:35.620 --> 00:13:39.460
You can even run it on GUnicorn with


00:13:39.460 --> 00:13:44.620
UVicorn workers to get the awesome libUV,


00:13:44.620 --> 00:13:46.700
high-performance async support.


00:13:46.700 --> 00:13:50.540
So you can deploy it onto kind of the top tier Python stuff,


00:13:50.540 --> 00:13:53.100
put, you know, Nginx in front of it and all that.


00:13:53.100 --> 00:13:53.980
It's pretty cool, right?


00:13:53.980 --> 00:13:54.820
- Yeah.


00:13:54.820 --> 00:13:59.020
- Now, one of the ways you run web apps on servers,


00:13:59.020 --> 00:14:01.060
especially in Python, because of the threading support


00:14:01.060 --> 00:14:04.420
is not as friction-free, I guess,


00:14:04.420 --> 00:14:05.940
you know, like the GIL and all that,


00:14:05.940 --> 00:14:08.700
is you'll farm it out into multiple workers, right?


00:14:08.700 --> 00:14:11.540
So I can't remember what we have for Python by,


00:14:11.540 --> 00:14:13.820
it's not too many, like two or four


00:14:13.820 --> 00:14:15.500
different worker processes.


00:14:15.500 --> 00:14:17.740
And each of the worker processes


00:14:17.740 --> 00:14:20.860
kind of gets round Robin brought in to handle requests.


00:14:20.860 --> 00:14:22.380
So like if one of them is busy,


00:14:22.380 --> 00:14:25.940
it'll automatically send the request over to another one.


00:14:25.940 --> 00:14:28.780
Now, usually there's maybe a couple of limits,


00:14:28.780 --> 00:14:31.000
but one of the limits you really wanna consider is,


00:14:31.000 --> 00:14:32.920
I don't wanna run the machine out of memory.


00:14:32.920 --> 00:14:36.500
So I think the ones we use like 150 megs per worker process.


00:14:36.500 --> 00:14:38.220
So at some point, they'll only create so many


00:14:38.220 --> 00:14:41.580
and then the servers like, okay, I've had it.


00:14:41.580 --> 00:14:43.980
But with this little thing that runs on MicroPython,


00:14:43.980 --> 00:14:45.420
you could scale the heck out of it.


00:14:45.420 --> 00:14:48.960
you could have a ton of worker processes under microWSGI.


00:14:48.960 --> 00:14:49.800
- Oh yeah.


00:14:49.800 --> 00:14:52.920
- Or under uviacorn, right?


00:14:52.920 --> 00:14:56.340
And I actually did a little super simple test,


00:14:56.340 --> 00:14:59.700
like I wrote the Flask equivalent of hello world,


00:14:59.700 --> 00:15:01.060
literally exactly the same code


00:15:01.060 --> 00:15:02.340
but the changes I talked about.


00:15:02.340 --> 00:15:04.220
And then the microPython version,


00:15:04.220 --> 00:15:07.340
the, sorry, the microDot version,


00:15:07.340 --> 00:15:10.420
and that one both running on CPython,


00:15:10.420 --> 00:15:12.980
nine megs for this framework,


00:15:12.980 --> 00:15:15.380
25 megs for the Flask framework.


00:15:15.380 --> 00:15:18.340
So maybe you can have twice as much processing


00:15:18.340 --> 00:15:21.540
horizontal scale with this thing,


00:15:21.540 --> 00:15:23.340
but deployed to real servers.


00:15:23.340 --> 00:15:26.360
So there might actually be some interesting advantages


00:15:26.360 --> 00:15:28.300
to having this like really tight framework.


00:15:28.300 --> 00:15:30.720
Like I wanna run it in a bunch of Docker containers


00:15:30.720 --> 00:15:32.620
that are like using the smallest amount of memory.


00:15:32.620 --> 00:15:34.180
I wanna farm it out and say,


00:15:34.180 --> 00:15:37.380
no, I'll have 30 worker processes on this server, not five.


00:15:37.380 --> 00:15:38.300
I don't know, we'll see.


00:15:38.300 --> 00:15:39.660
Yeah, yeah.


00:15:39.660 --> 00:15:42.660
So Pamphle is pretty psyched about the memory saving


00:15:42.660 --> 00:15:43.480
out there as well.


00:15:43.480 --> 00:15:45.180
So I think it's good.


00:15:45.180 --> 00:15:48.060
- Yeah, and I mean, for lots of jobs where you don't need,


00:15:48.060 --> 00:15:50.540
if you don't need the power, don't use the power.


00:15:50.540 --> 00:15:51.980
- Yeah, yeah, pretty neat.


00:15:51.980 --> 00:15:54.780
So well done, Miguel, and yeah.


00:15:54.780 --> 00:15:57.380
Now, Brian, let me take just a moment


00:15:57.380 --> 00:15:59.260
and tell everyone about our sponsor.


00:15:59.260 --> 00:16:01.300
This episode of Python Bytes is brought to you


00:16:01.300 --> 00:16:04.940
by Influx Data, the makers of InfluxDB.


00:16:04.940 --> 00:16:07.460
InfluxDB is a database purpose-built


00:16:07.460 --> 00:16:09.220
for handling time series data


00:16:09.220 --> 00:16:12.380
at a massive scale for real-time analytics.


00:16:12.380 --> 00:16:17.740
Developers can ingest, store, and analyze all types of time series data, metrics, events,


00:16:17.740 --> 00:16:20.420
traces in a single platform.


00:16:20.420 --> 00:16:22.540
So dear listener, let me ask you a question.


00:16:22.540 --> 00:16:27.140
How would boundless cardinality and lightning fast SQL queries impact the way you develop


00:16:27.140 --> 00:16:29.260
real-time applications?


00:16:29.260 --> 00:16:34.420
InfluxDB processes large time series data sets and provides low latency SQL queries,


00:16:34.420 --> 00:16:39.080
making it a go-to choice for developers building real-time applications and seeking crucial


00:16:39.080 --> 00:16:40.740
insights.


00:16:40.740 --> 00:16:46.220
for developer efficiency, InfluxDB helps you create IoT, analytics, and cloud applications


00:16:46.220 --> 00:16:52.520
using time-stamped data rapidly and at scale. It's designed to ingest billions of data points


00:16:52.520 --> 00:16:59.100
in real time with boundless cardinality. InfluxDB streamlines building once and deploying across


00:16:59.100 --> 00:17:04.380
various products and environments, from the edge, on-premise, and to the cloud. Try it


00:17:04.380 --> 00:17:08.160
for free at pythonbytes.fm/influx DB.


00:17:08.160 --> 00:17:10.140
The links in your podcast show notes.


00:17:10.140 --> 00:17:12.300
Thanks to influx data for supporting the show.


00:17:12.300 --> 00:17:14.160
Over to you.


00:17:14.160 --> 00:17:14.760
What's your next one?


00:17:14.760 --> 00:17:17.480
I want to talk about GitHub actions a bit.


00:17:17.480 --> 00:17:20.960
So I'm a lot of my workflows have moved over to get hub actions.


00:17:20.960 --> 00:17:26.040
And so there's actually three projects that I wanted to talk about that I thought


00:17:26.040 --> 00:17:29.720
were neat and worth, and they're all kind of in the GitHub action genre.


00:17:29.720 --> 00:17:32.800
What you got, what you got, what you got first.


00:17:32.920 --> 00:17:37.480
Um, what, what, what you got, watch GHA.


00:17:37.480 --> 00:17:39.400
It comes from the Ed batch elder.


00:17:39.400 --> 00:17:44.640
Um, this is a, a, just a simple tool to, to watch your


00:17:44.640 --> 00:17:47.200
GitHub action progress from a command line.


00:17:47.200 --> 00:17:50.560
Um, so, pretty, I think it's a command line thing.


00:17:50.560 --> 00:17:51.480
It looks like command line.


00:17:51.480 --> 00:17:56.120
Um, and so it looks so you can, it has like a little progress bar thing,


00:17:56.120 --> 00:17:59.980
progress dots that go green and then there's start out gray and then they


00:17:59.980 --> 00:18:02.140
to go white and green and stuff,


00:18:02.140 --> 00:18:03.960
to see the different things.


00:18:03.960 --> 00:18:08.340
You got like, we were running 3.7 on Ubuntu, 5.8.


00:18:08.340 --> 00:18:11.900
So if you've got a big matrix that's doing a lot of stuff,


00:18:11.900 --> 00:18:14.020
it's kind of hard to keep up with what all is going on.


00:18:14.020 --> 00:18:16.500
So this is kind of neat to watch,


00:18:16.500 --> 00:18:19.040
just a little tool from Ned, thanks Ned.


00:18:19.040 --> 00:18:23.140
One of the other things I was thinking about,


00:18:23.140 --> 00:18:26.820
so I just, my talk at PyCascades was talking about


00:18:28.340 --> 00:18:30.580
that you can share, you can just,


00:18:30.580 --> 00:18:34.120
you can share packages without actually ever building it


00:18:34.120 --> 00:18:36.580
because pip install will build your wheel for you


00:18:36.580 --> 00:18:38.260
if it's not built already.


00:18:38.260 --> 00:18:41.260
But you probably should test that.


00:18:41.260 --> 00:18:43.820
And one of the ways you can test some of that building


00:18:43.820 --> 00:18:48.820
is with Linux build and inspect Python package.


00:18:48.820 --> 00:18:54.100
So this is a GitHub action that will,


00:18:54.100 --> 00:18:56.580
it does a lot of stuff, but it does a build


00:18:56.580 --> 00:18:58.360
to make sure the build works.


00:18:58.360 --> 00:19:03.240
It also has a linter to lint the wheel contents.


00:19:03.240 --> 00:19:06.560
It also uploads the wheel and the source distribution


00:19:06.560 --> 00:19:08.240
as GitHub action artifacts.


00:19:08.240 --> 00:19:11.320
So it actually does generate the wheel for you


00:19:11.320 --> 00:19:14.100
as an artifact, which is kind of neat.


00:19:14.100 --> 00:19:19.280
One of the things that's always a mystery to me


00:19:19.280 --> 00:19:23.840
is making sure I have everything that I want in the SDist,


00:19:23.840 --> 00:19:28.500
the source distribution and this will lint that and also,


00:19:28.500 --> 00:19:31.560
well, I guess it doesn't lint the contents of the S-disk,


00:19:31.560 --> 00:19:32.560
but it does print them out.


00:19:32.560 --> 00:19:35.740
So print does a tree of the S-disk and the wheel


00:19:35.740 --> 00:19:38.640
in the output so that you don't have to download it


00:19:38.640 --> 00:19:41.960
to check it, you can just look at it in your GitHub output.


00:19:41.960 --> 00:19:43.840
- Make sure all the files and resources


00:19:43.840 --> 00:19:45.480
you might need to send out come along.


00:19:45.480 --> 00:19:48.400
- Yeah, and this, yeah,


00:19:48.400 --> 00:19:51.920
I had recently made a change to a package


00:19:51.920 --> 00:19:54.760
and it took out the tests and I had somebody say,


00:19:54.760 --> 00:19:57.080
oh, look, we want the tests back in.


00:19:57.080 --> 00:19:58.340
So it's kind of nice.


00:19:58.340 --> 00:20:03.440
So I guess that's it with that.


00:20:03.440 --> 00:20:06.980
It's kind of a neat GitHub action thing


00:20:06.980 --> 00:20:08.920
that you just put it in.


00:20:08.920 --> 00:20:09.880
It's one of those actions.


00:20:09.880 --> 00:20:12.120
So you just like specify it and it just works.


00:20:12.120 --> 00:20:12.960
It's nice.


00:20:12.960 --> 00:20:16.160
The third thing I wanted to bring up


00:20:16.160 --> 00:20:20.620
was pytest GitHub actions annotate failures.


00:20:21.540 --> 00:20:25.180
So this is a, just a nice extra thing


00:20:25.180 --> 00:20:27.100
that I hadn't heard about before.


00:20:27.100 --> 00:20:30.620
pytest, it's under the pytest dev umbrella,


00:20:30.620 --> 00:20:33.980
but it's a pip install sort of a thing.


00:20:33.980 --> 00:20:35.780
And what it does is it makes sure


00:20:35.780 --> 00:20:40.060
that all the proper stuff gets output


00:20:40.060 --> 00:20:42.340
so that you can have nice annotated,


00:20:42.340 --> 00:20:44.780
your asserts, if there's failures,


00:20:44.780 --> 00:20:47.180
it's annotated nicely in GitHub Actions.


00:20:47.180 --> 00:20:48.020
That's it.


00:20:48.020 --> 00:20:49.820
Just some fun GitHub Actions stuff.


00:20:49.820 --> 00:20:53.660
- Yeah, once you really start getting into CI/CD,


00:20:53.660 --> 00:20:54.500
it's fun and you're just like,


00:20:54.500 --> 00:20:56.460
"Oh, and now that it's automated, we could do this,


00:20:56.460 --> 00:20:57.900
"or we could do that."


00:20:57.900 --> 00:21:00.620
- Yeah, but when you automate all the things


00:21:00.620 --> 00:21:02.340
and then when things go wrong, you're like,


00:21:02.340 --> 00:21:04.820
"Oh God, then we have to pull it down and check it again."


00:21:04.820 --> 00:21:07.360
But having some of these debug stuff


00:21:07.360 --> 00:21:10.140
and things up in the cloud is good.


00:21:10.140 --> 00:21:11.860
- Yeah, very handy.


00:21:11.860 --> 00:21:12.700
Excellent.


00:21:12.700 --> 00:21:16.140
All right, well, I have a PEP for us to discuss.


00:21:16.140 --> 00:21:16.980
- Okay.


00:21:16.980 --> 00:21:20.020
709, inlined comprehensions.


00:21:20.020 --> 00:21:25.020
Now, this is a debate that I seem to have only on YouTube.


00:21:25.020 --> 00:21:27.580
If I'll do, like I've done some videos


00:21:27.580 --> 00:21:31.580
about list comprehensions or other sort of design patterns,


00:21:31.580 --> 00:21:34.300
you might involve comprehensions and people are like,


00:21:34.300 --> 00:21:36.980
oh, Michael, you said that a for loop


00:21:36.980 --> 00:21:38.980
is different than a list comprehension,


00:21:38.980 --> 00:21:41.360
but look, it says for thing in collection,


00:21:41.360 --> 00:21:42.420
and so they're the same,


00:21:42.420 --> 00:21:45.260
and so you just don't know what you're talking about.


00:21:45.260 --> 00:21:47.340
Like, you know what, let's disassemble it.


00:21:47.340 --> 00:21:48.700
Well, let's see what it does.


00:21:48.700 --> 00:21:49.900
Is it the same disassembly?


00:21:49.900 --> 00:21:52.220
No, it's completely different disassembly.


00:21:52.220 --> 00:21:53.660
That means the implementation


00:21:53.660 --> 00:21:55.100
of those comprehensions are different.


00:21:55.100 --> 00:21:57.100
I don't care if the word for appears in both of them.


00:21:57.100 --> 00:21:58.220
They're not the same thing.


00:21:58.220 --> 00:22:00.900
This pep brings them,


00:22:00.900 --> 00:22:04.100
and it tries to take the best of both worlds though.


00:22:04.100 --> 00:22:06.740
And it says, there are some things we do


00:22:06.740 --> 00:22:09.100
to make comprehensions work,


00:22:09.100 --> 00:22:12.220
but look like they're just right there in the same function


00:22:12.220 --> 00:22:14.380
or in line, even if you don't have a function.


00:22:14.380 --> 00:22:18.120
But in fact, there's kind of this thing behind the scenes


00:22:18.120 --> 00:22:20.540
that's happening where we create a nested function


00:22:20.540 --> 00:22:22.660
that you never see, but the interpreter creates


00:22:22.660 --> 00:22:26.180
and then calls it, and that's the interpreter, okay?


00:22:26.180 --> 00:22:28.080
That's the comprehension rather.


00:22:28.080 --> 00:22:33.080
So this pep by Karl Mayer is basically saying


00:22:33.080 --> 00:22:37.380
we could get really good performance increases


00:22:37.380 --> 00:22:39.860
if we just change that implementation a little.


00:22:39.860 --> 00:22:43.140
And the reason it's created as a nested function


00:22:43.140 --> 00:22:44.980
and not just some inline code is,


00:22:44.980 --> 00:22:49.180
what if you have a variable x in your regular function,


00:22:49.180 --> 00:22:51.820
and then you have x as a loop variable,


00:22:51.820 --> 00:22:53.860
or as the item variable in


00:22:53.860 --> 00:22:55.420
your comprehension or things like that,


00:22:55.420 --> 00:22:57.020
you want them to still be isolated.


00:22:57.020 --> 00:22:59.820
So that's basically the idea here.


00:22:59.820 --> 00:23:01.900
It says, "Comprehensions are currently compiled as


00:23:01.900 --> 00:23:04.340
nested functions which provides isolation of


00:23:04.340 --> 00:23:06.540
the comprehension's iteration variable


00:23:06.540 --> 00:23:08.620
but is inefficient at runtime."


00:23:08.620 --> 00:23:11.580
So PEP 709 proposes to


00:23:11.580 --> 00:23:16.500
inline list dictionary and set comprehensions into the code where they are defined and provide


00:23:16.500 --> 00:23:22.820
the expected isolation by looking at all the variables, creating a copy of them, running


00:23:22.820 --> 00:23:28.580
this in place, and then if there was a variable for that loop variable, just put the old value


00:23:28.580 --> 00:23:29.580
back, right?


00:23:29.580 --> 00:23:30.580
Kind of push and pop them.


00:23:30.580 --> 00:23:37.620
And the benefits here are up to two times as fast as comprehensions.


00:23:37.620 --> 00:23:42.300
So then they said, this is translating to an 11% speed up


00:23:42.300 --> 00:23:45.100
in one sample benchmark derived from real world code


00:23:45.100 --> 00:23:46.840
that makes heavy use of comprehensions


00:23:46.840 --> 00:23:48.800
in the context of doing actual work.


00:23:48.800 --> 00:23:49.780
That's pretty cool, right?


00:23:49.780 --> 00:23:50.620
- Yeah.


00:23:50.620 --> 00:23:53.860
- I believe comprehensions were in general slightly faster


00:23:53.860 --> 00:23:55.980
than for loops that would just do something


00:23:55.980 --> 00:23:56.980
and put it in a list.


00:23:56.980 --> 00:24:00.000
So making it two times faster still is even better.


00:24:00.000 --> 00:24:02.780
So if this gets adopted, it's in draft form right now.


00:24:02.780 --> 00:24:04.620
I can go back to my YouTube comments


00:24:04.620 --> 00:24:06.980
and have even further nuanced discussions


00:24:06.980 --> 00:24:09.780
about like, here's yet again,


00:24:09.780 --> 00:24:12.600
how they are not the same thing, but they look similar.


00:24:12.600 --> 00:24:14.060
So yeah.


00:24:14.060 --> 00:24:16.860
- I never would have thought that


00:24:16.860 --> 00:24:20.260
I should reuse a variable in a comprehension though.


00:24:20.260 --> 00:24:22.900
I don't do that, but I guess.


00:24:22.900 --> 00:24:24.820
- No, I think it's like,


00:24:24.820 --> 00:24:27.660
let's say you've got two less comprehensions,


00:24:27.660 --> 00:24:32.540
you know, X squared for X in first set,


00:24:32.540 --> 00:24:36.220
then X, two X plus one for X in other set.


00:24:36.220 --> 00:24:37.980
those are two separate list comprehensions.


00:24:37.980 --> 00:24:41.180
You don't want like one of those variables too.


00:24:41.180 --> 00:24:42.660
You want to keep them, they want to be like,


00:24:42.660 --> 00:24:45.500
okay, this X is only for this comprehension.


00:24:45.500 --> 00:24:46.740
That's what it's like.


00:24:46.740 --> 00:24:48.660
>> If you have an embedded comprehension,


00:24:48.660 --> 00:24:50.220
you might use X in both places.


00:24:50.220 --> 00:24:52.940
>> Right. Or if you have an X and Y equals something,


00:24:52.940 --> 00:24:54.460
and then you generate a comprehension,


00:24:54.460 --> 00:24:57.300
you say X in there. There's a couple of, there's some weird.


00:24:57.300 --> 00:25:00.660
>> Yeah. I guess I was just thinking my own style.


00:25:00.660 --> 00:25:02.540
The second one I would never do.


00:25:02.540 --> 00:25:04.300
If I was already using X,


00:25:04.300 --> 00:25:06.340
I probably wouldn't use X in the comprehension.


00:25:06.340 --> 00:25:11.180
But I'll often use I or X in a comprehension


00:25:11.180 --> 00:25:13.380
in embedded ones and don't even think about it.


00:25:13.380 --> 00:25:15.180
So yeah, interesting.


00:25:15.180 --> 00:25:16.220
- Cool. - Yeah.


00:25:16.220 --> 00:25:18.700
David Poole says, "I'm sure there's good reasons for it,


00:25:18.700 --> 00:25:20.480
"but I wonder why comprehensions don't use


00:25:20.480 --> 00:25:23.360
"name mingling strategies for their foreign names.


00:25:23.360 --> 00:25:25.860
"Everyone's gotta be named underscore, underscore X."


00:25:25.860 --> 00:25:27.740
(David laughs)


00:25:27.740 --> 00:25:29.780
That is a good question. - It reminds me of a joke.


00:25:29.780 --> 00:25:32.340
- Well, so what it's doing now is it basically says,


00:25:33.220 --> 00:25:37.460
We're going to create a function.


00:25:37.460 --> 00:25:40.080
And so that variable is basically a local variable,


00:25:40.080 --> 00:25:43.100
that function, which has no influence on it.


00:25:43.100 --> 00:25:45.100
Were you going to actually tell us the joke?


00:25:45.100 --> 00:25:46.500
(laughing)


00:25:46.500 --> 00:25:47.620
- No, I was going to wait.


00:25:47.620 --> 00:25:49.140
- Okay, all right.


00:25:49.140 --> 00:25:50.740
- Or should we do it now?


00:25:50.740 --> 00:25:53.420
Oh, just, I think it was Ned Batchelder actually


00:25:53.420 --> 00:25:56.700
that mentioned that Dunder,


00:25:56.700 --> 00:25:58.260
we often talk about Dunder init


00:25:58.260 --> 00:26:01.520
instead of double underscore init,


00:26:01.520 --> 00:26:04.080
but it's really underscore, underscore,


00:26:04.080 --> 00:26:05.360
and it underscore, underscore.


00:26:05.360 --> 00:26:07.320
So it's really quunder.


00:26:07.320 --> 00:26:08.960
>> Quunder.


00:26:08.960 --> 00:26:12.860
>> So I responded to him and said, "I don't think so.


00:26:12.860 --> 00:26:16.420
I think it's dunder and it dunder is what it should be."


00:26:16.420 --> 00:26:19.760
But that would be redundant.


00:26:19.760 --> 00:26:22.840
>> It's pretty bad. That's pretty much on par with


00:26:22.840 --> 00:26:25.480
the joke we got at the end. So I'm preparing some people.


00:26:25.480 --> 00:26:28.680
All right. So basically the way to understand this,


00:26:28.680 --> 00:26:30.600
you can't look at the code and tell,


00:26:30.600 --> 00:26:34.920
which is why people incorrectly try to correct me on YouTube.


00:26:34.920 --> 00:26:38.000
So you look at the code and it looks like, oh, it's just a for list,


00:26:38.000 --> 00:26:41.000
and we took out the line breaks and put brackets, so it's the same thing.


00:26:41.000 --> 00:26:43.120
So if you look at it now,


00:26:43.120 --> 00:26:47.600
you can see if you create a function that creates a list comprehension,


00:26:47.600 --> 00:26:53.240
you'll see it creates what's called a code object of type list comprehension.


00:26:53.240 --> 00:26:56.880
Then it calls make function, then it loads the list, and


00:26:56.880 --> 00:26:58.600
then it does a bunch of stuff on it.


00:26:58.600 --> 00:27:00.400
And then it actually, you can see there's like


00:27:00.400 --> 00:27:02.120
the sub-function that gets disassembled,


00:27:02.120 --> 00:27:03.560
and it says, we're gonna build a list,


00:27:03.560 --> 00:27:05.840
load fast, iterate it, list append,


00:27:05.840 --> 00:27:06.840
and what's really interesting,


00:27:06.840 --> 00:27:09.320
this is the part that differs from for loops.


00:27:09.320 --> 00:27:12.720
There's a byte code called list_append.


00:27:12.720 --> 00:27:14.520
If you do this with a for loop,


00:27:14.520 --> 00:27:16.240
where you have a list and you call append,


00:27:16.240 --> 00:27:17.760
it loads the function append,


00:27:17.760 --> 00:27:19.880
and then calls append on the operands,


00:27:19.880 --> 00:27:22.960
but it's not in the runtime in a for loop.


00:27:22.960 --> 00:27:25.600
In a comprehension, there's a special byte code that runs,


00:27:25.600 --> 00:27:27.400
and that's like the primary difference, okay?


00:27:27.400 --> 00:27:30.480
So, but the drawback, right?


00:27:30.480 --> 00:27:33.520
So the benefit is list append is a byte code operation,


00:27:33.520 --> 00:27:34.720
not a function call.


00:27:34.720 --> 00:27:37.040
But the drawback is there's this object created,


00:27:37.040 --> 00:27:38.280
there's a stack frame created,


00:27:38.280 --> 00:27:41.000
there's a function call over to this comprehension call.


00:27:41.000 --> 00:27:43.980
Like there is an issue with all that stuff, right?


00:27:43.980 --> 00:27:45.440
So the new one just says,


00:27:45.440 --> 00:27:48.240
what we're gonna do is we're gonna create a new opcode


00:27:48.240 --> 00:27:50.200
called load fast and clear,


00:27:50.200 --> 00:27:52.320
which is like, I'm gonna load the variable X


00:27:52.320 --> 00:27:54.160
and if there was one of those before,


00:27:55.080 --> 00:27:58.600
we're going to hang on to that just in case,


00:27:58.600 --> 00:28:00.360
so we can put it back to avoid that.


00:28:00.360 --> 00:28:01.760
And then it calls build list,


00:28:01.760 --> 00:28:05.720
and you can notice there's no function calls,


00:28:05.720 --> 00:28:07.920
so no stack frame, no extra function call,


00:28:07.920 --> 00:28:11.040
there's no list comprehension object, all those things.


00:28:11.040 --> 00:28:13.980
And so this is the new bytecode operation


00:28:13.980 --> 00:28:16.880
that manages that variable isolation,


00:28:16.880 --> 00:28:19.580
and then you just do it directly, which saves you a bunch.


00:28:19.580 --> 00:28:21.560
We talked about the 2x speed there.


00:28:21.560 --> 00:28:23.560
So that's the pep.


00:28:23.560 --> 00:28:25.320
people check it out, see what you think.


00:28:25.320 --> 00:28:26.640
- That's really interesting, Michael,


00:28:26.640 --> 00:28:29.320
but you had me at it's faster.


00:28:29.320 --> 00:28:30.880
- I know, exactly.


00:28:30.880 --> 00:28:33.000
I just want people to kind of know what's happening


00:28:33.000 --> 00:28:35.080
and why it might be faster and so on.


00:28:35.080 --> 00:28:36.500
So pretty neat.


00:28:36.500 --> 00:28:41.920
You can see it does have the only possible,


00:28:41.920 --> 00:28:44.200
I guess, concern, or the reason they say,


00:28:44.200 --> 00:28:45.180
why is this even a pep?


00:28:45.180 --> 00:28:46.960
Why is this not just, hey, I made it faster?


00:28:46.960 --> 00:28:48.840
Like, why do we need to discuss this?


00:28:48.840 --> 00:28:49.680
- Yeah.


00:28:49.680 --> 00:28:50.500
- Just like you said, right?


00:28:50.500 --> 00:28:52.080
Like, it's faster, we're done, let's go.


00:28:52.080 --> 00:28:55.160
is there are user observable changes


00:28:55.160 --> 00:28:58.480
if the user doesn't like themselves, basically.


00:28:58.480 --> 00:29:03.700
For example, why would a user return locals


00:29:03.700 --> 00:29:06.320
as the item you want put into a list


00:29:06.320 --> 00:29:07.800
during a list comprehension?


00:29:07.800 --> 00:29:09.340
Well, if you did do that,


00:29:09.340 --> 00:29:11.820
you would see that it's not the same as before.


00:29:11.820 --> 00:29:15.660
I have no idea why you would ever try to do that,


00:29:15.660 --> 00:29:18.120
but that would technically would be a breaking change.


00:29:18.120 --> 00:29:20.920
The other one was slightly more valid perhaps


00:29:20.920 --> 00:29:24.760
is that if there's an exception inside the list comprehension,


00:29:24.760 --> 00:29:27.320
because it used to be in a separate function call,


00:29:27.320 --> 00:29:33.080
it would show up in the actual traceback call stack.


00:29:33.080 --> 00:29:35.520
But now you are not in another function,


00:29:35.520 --> 00:29:38.760
you're on a line in the OG function.


00:29:38.760 --> 00:29:41.720
So you don't have that,


00:29:41.720 --> 00:29:43.800
basically it's missing from there.


00:29:43.800 --> 00:29:47.080
So you would have a slightly different traceback exception.


00:29:47.080 --> 00:29:48.560
Well, the exception would be the same,


00:29:48.560 --> 00:29:52.040
but the trace back call stack listing would be different.


00:29:52.040 --> 00:29:55.480
That potentially affects somebody, but not a lot.


00:29:55.480 --> 00:29:56.320
I don't know.


00:29:56.320 --> 00:29:57.740
It's a two X, it's a trade off


00:29:57.740 --> 00:29:59.840
I would totally think is worth taking.


00:29:59.840 --> 00:30:01.720
- Yeah, but I see why that's a,


00:30:01.720 --> 00:30:03.840
it's a observable interface


00:30:03.840 --> 00:30:06.480
or an observable behavior change.


00:30:06.480 --> 00:30:08.280
So, yeah. - Yeah, yeah.


00:30:08.280 --> 00:30:10.500
- Although I learned from Brett Cannon


00:30:10.500 --> 00:30:12.480
just a couple weeks ago that


00:30:12.480 --> 00:30:14.600
locals often has weird stuff in it.


00:30:14.600 --> 00:30:16.080
If you look at locals a lot,


00:30:16.080 --> 00:30:17.260
sometimes there's stuff in there


00:30:17.260 --> 00:30:18.940
that you don't recognize.


00:30:18.940 --> 00:30:21.580
>> Interesting. Yeah, the local one seems like,


00:30:21.580 --> 00:30:23.620
you know what, don't do that.


00:30:23.620 --> 00:30:25.780
But the trace back one,


00:30:25.780 --> 00:30:28.100
I can see, okay, we're always looking for this.


00:30:28.100 --> 00:30:29.340
If I get an error,


00:30:29.340 --> 00:30:32.540
I try to look at the trace back to figure out what to tell people.


00:30:32.540 --> 00:30:34.660
I don't know, theoretically,


00:30:34.660 --> 00:30:36.300
it still seems unlikely.


00:30:36.300 --> 00:30:39.780
I feel like you shouldn't depend upon what's listed there,


00:30:39.780 --> 00:30:41.580
but I'm sure somebody does somewhere.


00:30:41.580 --> 00:30:43.900
>> Well, like ID makers and things like that.


00:30:43.900 --> 00:30:45.940
>> Yeah. Cool. All right.


00:30:45.940 --> 00:30:48.660
Well, that's it for all of our items.


00:30:48.660 --> 00:30:50.020
You got any extras?


00:30:50.020 --> 00:30:51.660
- I don't, do you?


00:30:51.660 --> 00:30:52.860
- I thought I didn't have any extras,


00:30:52.860 --> 00:30:55.080
but I think by the time,


00:30:55.080 --> 00:30:56.860
I'm gonna try to predict the future a little bit


00:30:56.860 --> 00:30:58.380
because I have some control over it.


00:30:58.380 --> 00:30:59.500
So I do have an extra.


00:30:59.500 --> 00:31:03.340
I'm gonna be releasing either today or tomorrow.


00:31:03.340 --> 00:31:05.380
By the time this podcast comes out,


00:31:05.380 --> 00:31:06.560
this is going to be released.


00:31:06.560 --> 00:31:09.540
But if you're watching it live, it's not yet released.


00:31:09.540 --> 00:31:12.140
So I'm gonna be releasing a new course,


00:31:12.140 --> 00:31:14.140
Python Web Apps that Fly with CDNs.


00:31:14.140 --> 00:31:16.000
It's just over a three hour course


00:31:16.000 --> 00:31:19.520
that's all about taking CDNs and applying them


00:31:19.520 --> 00:31:24.080
to like Flask web apps and also hosting video content


00:31:24.080 --> 00:31:26.960
and large files and how do you geo replicate that.


00:31:26.960 --> 00:31:28.900
We use a lot of these techniques in Python Bytes


00:31:28.900 --> 00:31:32.320
to like make the website faster as well as to make,


00:31:32.320 --> 00:31:36.680
to deliver, you know, terabytes of MP4, MP3s to people.


00:31:36.680 --> 00:31:38.560
So check that out.


00:31:38.560 --> 00:31:40.400
I will put a link in the show notes.


00:31:40.400 --> 00:31:42.440
Again, if you're listening live, this is not out yet,


00:31:42.440 --> 00:31:45.520
but it will be out by the time the MP3 hits


00:31:45.520 --> 00:31:46.360
your podcast player.


00:31:46.360 --> 00:31:47.880
So if you have the audio only version,


00:31:47.880 --> 00:31:49.560
go check it out, links in the show notes.


00:31:49.560 --> 00:31:50.400
- Nice.


00:31:50.400 --> 00:31:51.940
- Yeah, I think that's a really, really cool course.


00:31:51.940 --> 00:31:54.760
I think there's so much people can get out of it


00:31:54.760 --> 00:31:57.080
in terms of like, it's really easy.


00:31:57.080 --> 00:31:58.200
You know, 30 minutes and you're like,


00:31:58.200 --> 00:32:00.200
"Oh, our app is so much faster


00:32:00.200 --> 00:32:02.160
"and we can use smaller servers."


00:32:02.160 --> 00:32:03.000
That's really great.


00:32:03.000 --> 00:32:05.840
- Well, three hours plus 30 minutes.


00:32:05.840 --> 00:32:08.120
- Yes, well, once you know the thing,


00:32:08.120 --> 00:32:09.800
it's probably 30 minutes to apply it to your app,


00:32:09.800 --> 00:32:10.640
is what I mean.


00:32:10.640 --> 00:32:11.480
- Yeah.


00:32:11.480 --> 00:32:12.320
- Yeah.


00:32:12.320 --> 00:32:14.640
David Poole says, "The traceback one could be worked around


00:32:14.640 --> 00:32:18.680
"if the debug compiled used the old function style method,


00:32:18.680 --> 00:32:20.740
"like aggressive optimizations in GCC


00:32:20.740 --> 00:32:22.440
"with inline functions."


00:32:22.440 --> 00:32:24.540
Okay, possibly, interesting.


00:32:24.540 --> 00:32:27.960
You would have to have people buy into that, but right.


00:32:27.960 --> 00:32:30.680
I mean, I'm sure Brian, you're very well aware


00:32:30.680 --> 00:32:34.720
of the debug versus release builds and optimization levels


00:32:34.720 --> 00:32:36.800
and all that stuff in C, right?


00:32:36.800 --> 00:32:39.200
- No, I mean, yes, but I don't use 'em.


00:32:39.200 --> 00:32:40.640
- No, you don't need that.


00:32:40.640 --> 00:32:44.680
- Well, I personally don't like to test


00:32:44.680 --> 00:32:46.560
in something my user isn't gonna see.


00:32:46.560 --> 00:32:49.800
So I always test in optimized released.


00:32:49.800 --> 00:32:51.020
- Got it, yeah, yeah.


00:32:51.020 --> 00:32:52.880
But it can make a big difference.


00:32:52.880 --> 00:32:54.360
But in the Python world,


00:32:54.360 --> 00:32:57.200
we don't really discuss that so much, right?


00:32:57.200 --> 00:32:59.600
- Yeah, and except for the comment,


00:32:59.600 --> 00:33:01.920
the one thing to be aware of that I would,


00:33:01.920 --> 00:33:05.400
while we're on it, we probably haven't mentioned this lately


00:33:05.400 --> 00:33:07.720
is asserts are awesome in your test code,


00:33:07.720 --> 00:33:10.200
but they're not that great in your,


00:33:10.200 --> 00:33:13.060
Actually, they're pretty great in your function code also,


00:33:13.060 --> 00:33:14.780
but just don't depend on it,


00:33:14.780 --> 00:33:17.600
because assert lines can be completely removed


00:33:17.600 --> 00:33:20.140
if you have the optimization on.


00:33:20.140 --> 00:33:21.220
- Absolutely.


00:33:21.220 --> 00:33:22.740
All right, you ready for a joke?


00:33:22.740 --> 00:33:23.580
- Yes.


00:33:23.580 --> 00:33:24.640
- You a fan of movies?


00:33:24.640 --> 00:33:26.300
Like watching movies and stuff?


00:33:26.300 --> 00:33:28.340
- Yeah, I just went to a great movie, yeah, so.


00:33:28.340 --> 00:33:30.660
- Nice, well, as a software person,


00:33:30.660 --> 00:33:33.340
especially if you do a lot with Linux or Mac OS,


00:33:33.340 --> 00:33:35.180
you might not be able to watch the movies too much.


00:33:35.180 --> 00:33:37.380
This one says, "I can't watch movies on my computer.


00:33:37.380 --> 00:33:38.900
"All it does is bash scripts."


00:33:39.820 --> 00:33:45.960
bash on the scripts of the movie, not plot or run shelf scripts.


00:33:45.960 --> 00:33:47.060
I'm not sure which.


00:33:47.060 --> 00:33:48.760
>> Okay. That's funny. I think.


00:33:48.760 --> 00:33:49.760
>> Sort of. Yeah.


00:33:49.760 --> 00:33:50.840
>> [LAUGHTER]


00:33:50.840 --> 00:33:53.280
>> Somewhat. Anyway, it's what I have for you.


00:33:53.280 --> 00:33:56.000
I have an incredible one that I want to put up,


00:33:56.000 --> 00:34:01.400
but it's like only video that has music and no spoken word.


00:34:01.400 --> 00:34:02.920
I don't think it fits for this format,


00:34:02.920 --> 00:34:04.300
but you know what, I'll throw it in.


00:34:04.300 --> 00:34:06.240
I'll throw it in. People also check out the movie.


00:34:06.240 --> 00:34:07.920
It's about releasing stuff to production.


00:34:07.920 --> 00:34:09.560
So it's pretty epic.


00:34:09.560 --> 00:34:13.200
Put it in the list, but we won't play something that's like 30 seconds long.


00:34:13.200 --> 00:34:15.440
That has nothing but music.


00:34:15.440 --> 00:34:17.120
Cool.


00:34:17.120 --> 00:34:17.600
Nice.


00:34:17.600 --> 00:34:18.160
All right.


00:34:18.160 --> 00:34:19.680
Um, is that all we got?


00:34:19.680 --> 00:34:20.600
That's all we got.


00:34:20.600 --> 00:34:21.200
It's a wrap.


00:34:21.200 --> 00:34:22.280
It's a wrap.


00:34:22.280 --> 00:34:22.640
Yeah.


00:34:22.640 --> 00:34:23.560
Thanks as always.


00:34:23.560 --> 00:34:24.080
Thank you.


00:34:24.080 --> 00:34:24.320
Later.

