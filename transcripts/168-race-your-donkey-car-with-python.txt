00:00:00 Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to

00:00:04 your earbuds. This is episode 168, recorded February 5th, 2020. I'm Brian Okken.

00:00:11 I'm Michael Kennedy.

00:00:12 And I'm Kojo Adresa.

00:00:13 Yay, we have Kojo here as a special guest.

00:00:15 Hey, Kojo, welcome to the show. Happy you're here.

00:00:17 Hello. Thank you, thank you.

00:00:18 This episode is brought to you by DigitalOcean. Thank you, DigitalOcean.

00:00:22 Michael, I'm actually confused about this.

00:00:25 It's a little bit of a funny name, right? So let me tell you about Donkey Car.

00:00:29 Have either of you participated in or at least watched a proper RC remote control car race?

00:00:36 Not really. Just sort of like the random ones. Like, random people have random remote control

00:00:40 cars and running them around the neighborhood, but not an actual official proper one. No, I have not.

00:00:44 Brian?

00:00:44 Yeah, I just watched a little video that you sent me and it was quite exciting.

00:00:49 These are really weird things. If you've never seen one of these, I put a link to like a three-minute

00:00:54 video from GoPro where they put a GoPro on one of these little RC race cars.

00:00:58 I used to have one of these when I was a kid, like high school, maybe late middle school. And

00:01:03 they're insane. They're these little cars and your remote control and they go like 35 miles

00:01:06 an hour. They're super quick and responsive. Really interesting. But what would be even cooler

00:01:11 is if I could use Python to like win an RC car race. Don't you think?

00:01:16 Ah, yeah, that would be cool.

00:01:17 Yeah.

00:01:18 You're right.

00:01:19 I mean, you've already got the GoPro on there. It's already got a camera that's high quality.

00:01:24 So, the thing that I want to talk about is this thing called Donkey Car. And it's a minimalist,

00:01:29 modular, self-driving library, self-driving car library for Python.

00:01:35 So, people are always looking for ways to get kids into programming or themselves to get into

00:01:40 programming if they don't have some like formal project. Like, I want to build this website or I've

00:01:45 got the data science thing I want to do. Something like a self-driving car I think could be really

00:01:49 interesting. They have some much tamer vehicles that they have pictures of on the Donkey Car repo where

00:01:56 it's more like little Lego cars and stuff. But you basically have these little tiny cars and you can

00:02:01 put cameras on them and then you put a Raspberry Pi and then you teach it how to drive. And I think

00:02:06 that's pretty awesome.

00:02:07 Yeah. That looks fun.

00:02:09 Doesn't it? Yeah. So, it says you can use Donkey Car if you want to make an RC car drive itself and

00:02:15 win an RC car race. That would be awesome. If you want to compete in self-driving races like DIY

00:02:20 RoboCars are, you know, the great robot race from DARPA way back in the day. I guess that's probably

00:02:27 a little bit quite enough, but still quite cool. If you want to experiment with like autopilot or

00:02:32 mapping computer vision and neural networks, if you want to log sensor data while you're driving around,

00:02:38 if you want to drive a car via an Xbox game controller, that's pretty cool. Because you can

00:02:46 then communicate, you know, with the controller over to the Raspberry Pi and then just tell it to drive

00:02:50 however it tells it. Yeah. A lot of cool stuff. And yeah, I think if you have anything to do with

00:02:57 like you're playing with AI and computer vision, this seems like a really fun way to make it interactive

00:03:02 or kind of exciting without a lot of code. There's, it's pretty simple actually.

00:03:07 Do you know if any of these RoboCars are going, or the self-driving are going like 35 miles an hour?

00:03:14 I don't see, well, when I watched the video that I included, like on one hand, like I don't see why

00:03:18 it would be hard because they have these little rails and it's kind of clear where the edge of the track is.

00:03:22 You could even put up markers, like little things that you could like shine, you know, have detected

00:03:27 with the computer vision, but they're so bouncy and incredibly jiggly. And it's really hard.

00:03:35 I think, I think it would be a little bit hard. So maybe slow, but I don't know. I, my joke about winning

00:03:39 the race, it seems a little far fetched. You'd have to have a really stable camera, which I guess you could get.

00:03:43 Yeah.

00:03:43 But anyway, I think this is a fun one. So if people are out there looking to play with a little AI

00:03:48 computer vision, this seems cool. Check it out.

00:03:50 It's very interesting.

00:03:51 Yeah, for sure. Brian, there's a bit of a sad one coming up, right?

00:03:54 What's going on?

00:03:55 Yeah. Rest in peace. I ran across an interesting article by Nick Timkovic, I think, called,

00:04:02 RIP Pipenv. Try too hard. Do what you need with pip tools. So I didn't realize that that

00:04:11 Pipenv was kind of stagnating. There's not been a release in 2019. I didn't check to see if maybe

00:04:17 they slipped one in in 2020 yet. But apparently there's some problems with the subdependencies

00:04:24 and complicated release process or something. But...

00:04:28 Well, I want to add one really bit of a small bit of detail here because I think it's interesting.

00:04:33 There's not been a release of Pipenv in 2019. And that makes it sound like all people have walked

00:04:39 away, haven't done anything. There are 650 commits to that project and there's still not a release in

00:04:44 the year, which is kind of rough, right? Like the people who worked on it, if that stuff's not

00:04:48 getting released, that can't be great.

00:04:50 Yeah. So I'm not sure what's going on. But the main emphasis of the article really isn't that

00:04:55 whether, I mean, whether or not Pipenv survives or it's really dead. I don't think it's dead.

00:05:00 I don't know what the state of it is. But one of the benefits that we saw with Pipenv was this idea

00:05:07 of pinning everything and using, like having a pip file and a pip lock file or a lock file that says,

00:05:14 these are the packages that I really depend on. And then all of those, plus all of the subpackages,

00:05:20 I put those in another file, a lock file with their hashes so that I can know that I can reproduce

00:05:27 that environment. And that's a, it's a really cool idea. I like the concept. Most of the bulk of the

00:05:33 article is just basically saying, you can do that yourself without Pipenv. You can use pip compile

00:05:38 that comes from pip tools and there's a generate hashes function. But basically you do that yourself.

00:05:44 You just have a smaller requirements file that just has what you really need, your direct

00:05:49 dependencies. And then you can generate a hash file that is directly readable by pip. You can pip install

00:05:56 from this, this other generated hash requirements file. The other part of Pipenv that people are using

00:06:04 is virtual environment support. But I guess I'm on board with Nick to say, I don't understand why these

00:06:09 were bundled into one tool and I'm using virtual VENV, the built-in just fine. I don't really need

00:06:16 Pipenv for that. So I think I'm going to try to incorporate this possibly in my workflow, at least

00:06:22 on one project to see how it goes.

00:06:24 Yeah, that's pretty cool. I didn't realize you could output the requirements.txt with the hashes

00:06:29 using pip compile either. That definitely was one of the selling points of pip enf was like,

00:06:34 everything is locked, not just by pinning the version, but by the hash as well to make sure

00:06:39 that it couldn't get messed up. Pipenv uses pip compile anyway. So I see. And it uses pip file

00:06:45 and pip file.lock. You know more about this than I do, Brian. Isn't pyproject.toml the new hotness

00:06:51 instead of pip file?

00:06:53 The pyproject.toml doesn't have, I don't think that it supports doing hashes and stuff like that. So

00:06:58 they still kind of support different ideas. I think the pyproject.toml is, I'm not sure where

00:07:06 they cross over, but there still is this difference between a library that you can use for lots of

00:07:14 stuff with lots of different versions of things in an application. With an application, you definitely

00:07:19 want to lock things down to know what you're doing.

00:07:22 For sure. Kojo, did you use pip enf any? What's your virtual environment preference?

00:07:28 So I used it a small amount. I never used it a huge amount. I think my virtual environment

00:07:33 preference has been virtual. Well, I had been virtual env wrapper, but I've recently started using

00:07:38 pyenv. Well, actually, I started using pyenv, but that's more for managing different versions of Python.

00:07:46 Right, right. I want this virtual environment to be Python 3.7 and that one to 3.8 and gasp that one too.

00:07:51 Yeah. And so I've been using pyenv to manage different versions of Python, but then there's a pyenv-virtualenv

00:07:58 module. And so that makes it a little easier to create virtual environments as you switch between

00:08:04 Python versions. But for me, so pipenv, again, I'd never really gotten into using it, but having looked

00:08:10 at it a little bit and I saw some of the early talks about it, it introduced me to that idea of a lock

00:08:14 file. And then my personal blog is Jekyll, which is in Ruby. And Ruby uses a similar thing, that sort

00:08:20 of gem lock file. And so just the familiarity with it there from pipenv was helpful to me as far as

00:08:26 having to try to sort out stuff with Jekyll because I don't, Jekyll is the only thing, the only Ruby

00:08:31 project I use. It's the only time I ever really use Ruby. So it was helpful at least to be familiar

00:08:36 with that set of concepts there. Yeah. Yeah. Cool. And Brian, I'm very excited about Python 3.9 having the

00:08:43 --prompt dot. So you get the folder name without the extra bits that you have to put in

00:08:49 there to make that happen in the shell. Yeah. That's going to be cool. I love using prompt. Yeah,

00:08:53 for sure. Kojo, what you got next? I'm going to talk about string, a string method called case fold.

00:08:57 And this is something that's interesting. It actually just came up this morning. I was working on something

00:09:02 this morning and you can use case fold in places where you're trying to do comparisons without

00:09:10 having to look at the case of a string. And so they call it caseless matching. And so the standard thing

00:09:15 in Python or the more common thing that you would do in Python is maybe you use like the string method,

00:09:20 like string dot lower. And so you're not worried about whether someone types something in with,

00:09:24 you know, uppercase or lowercase. And that works in a lot of situations.

00:09:27 Wait a minute. Wait a minute. You're telling me that I've been doing it wrong for all these years?

00:09:30 Completely wrong? Shame on you.

00:09:31 Yes. I didn't. I knew the function case fold was here, but until you brought it up, I'm like,

00:09:37 oh, whatever, like lowers. I've been doing it wrong. Carry on. This is awesome. I'm ready to hear about it.

00:09:42 Well, and so the interesting thing about this is that, you know, lower works in a lot of,

00:09:46 it works. It covers a lot of, a lot of use cases, especially if you're, you're using English or

00:09:52 a similar language. It's interesting in the, the docs that case folding is similar to lower casing,

00:09:56 but more aggressive, which is just a little funny to hear when my coworkers got a kick out of that.

00:10:00 And I think where case fold becomes especially useful is if you're using a lot of Unicode characters.

00:10:07 And I think, Michael, you had an example here, but so it stood out to me partially because I was

00:10:12 working on a thing where I wanted to make sure cases, things were being compared and I didn't have

00:10:16 to worry about the case of what was entered versus what was expected.

00:10:18 Right, right, right. And until like today I would have written dot lower dot strip and been happy

00:10:22 with that.

00:10:23 Exactly. And so, and I started looking for some other ways. I, in addition to other things,

00:10:28 I lived in China for two and a half years, so I can read and write Mandarin, a functional ability to

00:10:32 read and write Japanese. I taught myself to read and write Hangul. And so I tend to use Unicode characters

00:10:39 maybe a little more, a little more frequently than, than the average American. And so for me,

00:10:43 I was like, and if I'm trying to build something and I'm concerned about handling text or case

00:10:48 matching, I'm always interested in things that will support Unicode because the Unicode characters,

00:10:53 because, you know, of course, like emoji, probably the most popular Unicode characters among English

00:10:58 speakers, but you also have a number of other languages where the entire language is represented

00:11:03 in Unicode characters. So something like this that will work in these, in these situations

00:11:07 where you get Unicode characters is important. So like I said, I just discovered that this morning

00:11:12 and ended up using it in a test I was writing and I'm like, okay, I can see how I can use this

00:11:16 going forward. And I think, Michael, I think you've got like a, a slightly more flushed out example.

00:11:20 Yeah. Yeah. So let me just give people an example because aggressively lower casing,

00:11:24 that doesn't mean anything to me. When I read this, I'm like, I still have no, I read what the,

00:11:28 the docs said about it. I'm like, I still have no idea what this means. Like if I had like

00:11:33 Michael dash Kennedy with the dash be down, like underscore now, like, I mean, I just,

00:11:38 I don't even know. Right. And so I found this example and it has two strings,

00:11:42 the river in German, and there's sort of the formal German way to spell it where you have an,

00:11:48 what's called an S set. It's like a, looks like a beta symbol, which is like two sharp,

00:11:53 two S's together, like a super S. And then you could just, if you were on like an American or English

00:11:58 keyboard, you're like, I can't find that character. I'm just type two S's as common in German.

00:12:02 And if you case fold those, it will actually convert their flus with the S set that like the

00:12:08 beta thing down to lowercase F L U S S and compare it, which I had no idea. That's pretty cool. So it,

00:12:14 it'll take these letters that are, I guess, considered uppercase, but you know, not quite the same.

00:12:20 And it'll sort of normalize the string more than just lower is the way I see it. It's like the

00:12:24 canonical lowercase version of it. Yeah. And, and, I've, I've seen the, the example like that and I have no knowledge of German at all. And so, but it was useful to see

00:12:35 that example. It's like, okay, here's, you know, here's another concrete reason, you know,

00:12:39 why you might want to use this. but, but I think also with a lot of applications,

00:12:43 be they web applications or standalone apps, when people are dealing with internationalization and

00:12:47 localization, that kind of thing, having some sort of a method for caseless matching that,

00:12:53 that, you know, will work across the Unicode characters, then, you know,

00:12:56 it's not going to break once you get outside of, you know, the 26 letters of the, you know,

00:13:00 the English alphabet is helpful. So yeah. Yeah. Brian, did you know about this? I I'm like blown

00:13:05 away. I've always been doing lowercase. And so you've been doing it wrong. Yeah. I think it's

00:13:11 pretty new from like, I think it's a, it got added in Python 3.3. So it's not, you know, it's not

00:13:15 like, you know, it's not like a thing that you haven't been using for a very long time. Cause it

00:13:19 hasn't been around that long, but as a, I think one, another thing that drew me to it

00:13:23 was that the idea that in Python 3 and going forward, everything is, you know,

00:13:27 everything is Unicode, the default sort of text handling mode is Unicode. And so it's not brand

00:13:33 new, but it's also not like super old. So if you haven't been using it, you haven't been, you know,

00:13:37 missing out in, and again, bring that lower still works unless you run into a situation where you

00:13:42 were actively having to deal with Unicode characters, which, which a lot of us, you know,

00:13:46 honestly, a lot of folks here in the U S don't. So.

00:13:48 Yeah. Yeah. Pretty interesting. Thank you. That's awesome.

00:13:50 This episode of Python bytes is sponsored by digital ocean. They have awesome infrastructure

00:13:55 and awesome product. And we use them in our services. Do you have a memory intensive workload,

00:14:01 maybe something like a high performance SQL or no SQL database or an in-memory cache,

00:14:06 like maybe Redis or some indexes or some kind of large data analysis runtime? Well, check out

00:14:12 digital oceans, new memory optimized droplets. They're optimized, especially for these high

00:14:18 memory workloads. So check them out at pythonbytes.fm/digital ocean, and you can get a hundred

00:14:24 dollar credit. Awesome. Yeah. Thanks to digital ocean for sponsoring the show, Brian. I feel like

00:14:29 we're kind of in the same groove this week. You pick this rest in peace, pip enf, which to be clear,

00:14:34 the pip enf people didn't say rest in peace, our project. Someone from the outside looked at it and

00:14:39 made this declaration, but it's still an interesting article, right? Yes. Something that I have often

00:14:44 wondered about is like, you see a lot of times people talking about virtual enf, and this was like

00:14:50 the way to create virtual environments prior to VE and V being built in in Python, right? Yeah. Yeah.

00:14:55 There's a new release of it. And my first thought was, why? Why is there a new release of it? Because

00:15:01 Python 3-M, VNV, whatever I'm going to type after that, seems like it's solving my problem for me.

00:15:07 And so why would you continue to work on this? You know, like it's, we're technically in the post

00:15:11 Python 2 era officially, right? I mean, not in practice, there's a lot of Python 2 still out there,

00:15:17 but it is now no longer supported being past January 1st, 2020. So why work on this thing,

00:15:23 right? Well, Brian Skin sent in this and I'm like, all right, I'll take a look. Brian usually recommends

00:15:28 good stuff. And it's this announcement by Bernat Gabor, who is working on the project and said,

00:15:34 hey, we just did a major release of virtual enf. I'm like, okay, I got to figure out why this is

00:15:40 still a thing. And he said, look, there's a couple of pain points that exist with current,

00:15:44 you know, the dash MV and V style that creating a virtual environment is slow. It takes around three

00:15:49 seconds, even in offline mode. Unless you're on Windows, then it takes longer. I don't know how

00:15:54 much longer, but it seems to be that it copies more into the virtual environment rather than sim

00:15:59 linking it on Windows. So it seems like it's a little slower. The other thing is that the API

00:16:03 used around PEP 405 is great if you just want to create virtual environments, but it doesn't allow

00:16:10 you to target very much around that or describe the target environment without actually creating the

00:16:16 environment. And then the duality of virtual ENV versus VNV. So Python 3.4 has VNV added, as I said.

00:16:25 So in theory, you could just switch away. But there's some other benefits that he talks about as well.

00:16:30 So over specifically over VNV, which is the ability to discover and use alternate pythons, right? I can say

00:16:37 dash P2 to create a virtual Python 2 virtual environment or kind of like you were saying, Kojo, I could say

00:16:43 dash P3.8 or 3.7 or even dash P pypi 3 and get one of those environments created. So I can select from the

00:16:51 different installed pythons as I create these, which is pretty cool. It also packages out of the box,

00:16:57 out of the box, it packages the wheel package as part of the seed package, or caches part of the seed,

00:17:02 the wheels as part of the seed packages, which after it's been created and cached, it speeds up the install

00:17:09 time, especially for things like micro whiskey or whatever, like that thing takes 15 seconds to pip install

00:17:14 at least. So making that faster seems awesome. And it's also guaranteed to work in places where VNV is

00:17:22 not included with Python by default. For example, if you get the Debian or certain versions of Ubuntu,

00:17:28 and you say Python 3 dash MVNV, it'll say VNV is not installed on this computer, and you've got to

00:17:35 apt install it, right? Which is kind of funky. And then around that as well, you can also,

00:17:41 because it's pip installed, not apt installed, it will, you know, you can upgrade it right away with

00:17:47 pip whenever there's new changes and version it separately than what the OS is versioning VNV. So

00:17:53 I don't know, what do you guys think? Does that, that sounds like a pretty good reason for it to be

00:17:56 around actually, all those reasons. Yeah. The downside of it's confusing to have two.

00:18:03 It is confusing to have two. Well, and I was confused about as well. And I'm not saying I'm switching to

00:18:07 it necessarily, but I can see why that it's pretty interesting. I guess I'm sort of between the two

00:18:12 of you from the standpoint of, I like that there is a lot of activity in this space as far as both,

00:18:17 like we just, we just talked about PipBend with, you know, virtual environments and with, you know,

00:18:22 installing and package management, that sort of thing. It's sort of a tricky issue. And so the fact

00:18:27 that people are trying to improve, you know, people are looking at pain points and trying to build tools

00:18:32 to improve on those is fantastic. I think sort of the confusing part is, and again, as someone who

00:18:37 just started a new job and I've just been going through the process of setting up a new machine.

00:18:40 You've been installing all the things, right?

00:18:42 Yeah. Well, either installing all the things, or unfortunately there's, you run into sort of like

00:18:47 a namespace pollution thing where like almost everything is called like Pi ENV something or,

00:18:54 or pip Venve, or, you know, like a lot of the names are very similar. It's one of those things where

00:19:00 it's, you know, sort of the good side of the bad side of the coin. Again, like it's great that these

00:19:06 things are being worked on because, you know, especially with Python, you want to have, you know,

00:19:10 some sort of separation, some sort of dependency management. And so wanting to make sure that

00:19:15 you're developing the right version of Python and that you're not overriding things or creating

00:19:18 conflicts. But I guess it's a situation where one or two dominant solutions show up. We'll sort of

00:19:25 standardize on those, but now there's, you know, a little bit of confusion as we get to that point.

00:19:29 Yeah. Yeah. It's good to see a thousand flowers blooming, but it is tricky to know which one's

00:19:34 going to be around. All right. Which flower do you pick? You know, there are literally a thousand

00:19:39 of them blooming, Seth. Exactly. Exactly. Brian, what you got next for us?

00:19:42 Well, a little bit of testing. I don't know if we've talked much about hypothesis, but people

00:19:47 probably know about hypothesis, property-based testing. Hypothesis is kind of mind-blowing a little

00:19:52 bit, to be honest. It isn't a silver bullet, but it's kind of a cool thing. So I am highlighting a

00:19:57 project, which is relatively new by Zach Hatfield, Dodds, and Paul Gansel are two people working on it so far.

00:20:04 This is the idea of adding property-based tests for the Python standard library and for the built-ins.

00:20:11 And their comments are that the CPython's existing test suite is actually very good, but bugs do still

00:20:18 slip through occasionally. And maybe throwing some property-based testing tools at some parts of it

00:20:24 could help. It's not a magic bullet, but computer-assisted testing techniques routinely try inputs that humans

00:20:30 wouldn't. And hypothesis is what we got for Python. So why not? There's not very much covered yet in this

00:20:37 project, so I'm highlighting it to try to get other people that are interested on board. But they want

00:20:42 to try to have a compelling proof of concept by PyCon US this year to be running as a, and to see if it'd be

00:20:49 worthwhile to have it running as part of the Python continuous integration suite to see how that goes.

00:20:56 I think it's really, my view on the hypothesis really is that it's especially geared towards helpful for

00:21:03 algorithmic pure functions. And in a lot of cases where you have like two functions that work kind of

00:21:09 in opposite directions, so you can do round trip, it's easier to set up a test for hypothesis to see,

00:21:15 like for instance, encode or decode. You can take some sort of string or something and encode it,

00:21:20 and then use the decode to make sure that you've got the final output is the same as your input.

00:21:26 These are easier tests. Functions that have, that are not pure, that have state, that depend on state,

00:21:32 those are harder things to test with hypothesis. So I think there's actually quite, and that kind of

00:21:38 applies to a whole bunch of the standard library. So I think there's a whole bunch of stuff that could

00:21:42 be tested more thoroughly with hypothesis. So this is pretty cool.

00:21:46 Yeah, it's a really interesting way of testing, and I'm glad to see the project. It looks cool.

00:21:49 One of the things I like about it is these are some people that I respect,

00:21:53 and having some people do these focused examples of how to use hypothesis in this way,

00:22:00 I think will actually help as a teaching tool to help other people learn how to use it.

00:22:04 Yeah. I would love to see like a big set of the standard unit tests for CPython moved over

00:22:13 and maybe condensed and brought down into like this hypothesis style to see what the two sets of test

00:22:18 suites look like. That would be interesting. Feels like a lot of work. That would be interesting.

00:22:22 Oh, but even like a specific case of taking like one, what are the functional tests in that exist in

00:22:29 CPython already? What do those look like compared to the property-based test? They're testing different

00:22:34 things. So I think it'd be cool to see them side by side too. That's neat.

00:22:38 Yeah. So property-based testing is a thing that I saw in my prior job, I did mostly QA.

00:22:43 And so I started to look into property-based testing. It's one of those things that it sounds very

00:22:47 interesting and that something that I'd like to know more about and just have another time to dig into.

00:22:51 But this project looks interesting. And it also kind of flows right into my topic. So the people

00:22:58 that you were just talking about, Zach Hatfield-Dowd and Paul, they are doing a tutorial on

00:23:04 property-based testing. And so what I wanted to talk about was just about, what time is it now?

00:23:08 Three of my time. So about two hours ago, I got an email from PyCon saying that the PyCon tutorials,

00:23:13 the schedule for the PyCon US tutorials, PyCon US 2020, the schedule for those tutorials is up and

00:23:19 available and you can register for them now. And so if you are thinking about going to PyCon,

00:23:24 depending on what you do, different people, you know, some people work in places where their

00:23:30 companies would just send them PyCon and it's not a big deal. Other people have to make a business case

00:23:34 to try to sort of convince their organizations to let them go. If you are in a situation where you need

00:23:38 to make a business case, the tutorials are often an excellent tool for that because you can get

00:23:43 a lot of high quality training from people who are very knowledgeable in their fields. And so one of

00:23:49 the sets of people, one of the tutorials is actually an introduction to property-based testing by the same

00:23:55 people that Brian was just talking about. So there's a link here, you know, to PyCon.org. So

00:24:00 there's a full schedule of the different tutorials that are available and you can register for them

00:24:05 now if you'd like. They do tend to sell out pretty quickly though. The PyCon tutorials tend to be

00:24:09 pretty popular. They tend to sell out pretty quickly. The good news is that the videos of the tutorials are

00:24:15 all available. So even if you haven't, if you weren't able to make it to a prior PyCon, the videos for

00:24:21 those tutorials are available. And so you can look at past tutorials. The big advantage of actually going to

00:24:26 PyCon and going to a tutorial is again, just the fact that you have a chance to interact with the

00:24:31 people who are giving the tutorial and to be able to ask specific questions that meet your specific

00:24:35 use case. Yeah. And make connections, right? Yeah, exactly. I mean, make it, make connections with

00:24:39 people. Again, like if you are trying to say, for instance, you know, just to say with the hypothesis,

00:24:44 with the properties-based testing, if you're trying to implement that where you are, not only now is

00:24:48 there this effort to bring some property-based testing into CPython, but you take a tutorial,

00:24:55 you can actually interact with the people who are sort of leading this effort. And then if you have

00:24:59 specific questions, you've made a connection where you can reach out to those folks and try to get some

00:25:04 help as far as implementing, you know, trying to figure out, you know, what to do to implement that kind of

00:25:07 thing where you are to get a better understanding of the use cases, that sort of thing. So I went through,

00:25:12 like I said, I think the schedule just went up an hour or so ago. So I went through and sort of looked at ones

00:25:18 that were interesting to me. A couple of standouts to me were one, there's a tutorial on migration from

00:25:22 Python 2 to Python 3. And as Michael was just talking about, you know, Python 2 is now end of

00:25:27 life. And so, you know, if you have not moved to Python 3, now, you know, now is the time, you know,

00:25:33 earlier was really a better time, but you know, there's no time better than now if you haven't

00:25:38 done it before. So a tutorial on that, that'll be really helpful. Another one called Welcome to

00:25:42 Circuit Python by Katni Rembor. We were talking before with Michael's point about the remote control

00:25:48 cars. If you're looking at ways to get started with programming or to get other people into

00:25:51 programming, actually programming hardware is a good way to do that. You know, few things get

00:25:57 people's attention, like writing some code and making it, making the light turn on and making the light

00:26:00 change color or making it flash in a certain pattern. And so the Circuit Python, I remember, I think at

00:26:05 PyCon last year, everybody got like a Circuit Python playground board, like a small little mini circular

00:26:11 board that had lights and various sensors on it. And so I've been to one of Katni's tutorials,

00:26:16 like a PyOhio in 2018, maybe. And so it's the Circuit Python boards are really interesting.

00:26:23 You've got lights and sensors and you can, you know, you can build all sorts of things with them.

00:26:26 And it's a great gateway into programming, great, great way to get started. Or if you're an experienced

00:26:31 developer, a great way to start get started with hardware programming. And then the intro to

00:26:34 property based testing. And then there's another tutorial called Minimum Viable Documentation by a

00:26:39 woman named Heidi Waterhouse. And I've met Heidi, we spoke at PyCaribbean together, I think a couple of

00:26:43 years ago. But it's this idea about how do you set up a proper technical, you know, a proper

00:26:50 documentation structure for your projects, and focusing on the technical writing aspect. I think

00:26:54 it's one of those things, especially as a project gets larger, but even in a smaller project that gets

00:26:58 overlooked, sometimes there's so much focus on, let's write code that does this thing. And that's

00:27:02 fantastic. But what if you want to add a second person, add a third person to that project,

00:27:07 and your options then become either the first person sits down and just spends four hours talking

00:27:13 to the new person, you know, or if you have good documentation, a good documentation, a good

00:27:18 documentation structure, you can just point them to the documentation and let them get up to speed on

00:27:23 their own. I mean, there are multiple other tutorials, but those are ones that just sort of stood out to me.

00:27:27 But if you haven't been to a PyCon US, the tutorials are, I think, one of the strong reasons

00:27:33 to want to go, among other things, you know, meeting people and making connections and that sort of

00:27:36 stuff. And the open, you know, the open spaces in the hallway track, but the tutorials, especially

00:27:41 also if you're in a situation where you need to make a business case to your company to get support to

00:27:46 go, the tutorials are really good, a really good option for that.

00:27:49 I love that angle. And I also approached it the same way that you do is like, oh, these are out,

00:27:53 let me see which are interesting to me. So I came up with three as well, maps and machine learning,

00:27:59 spatial analysis with TensorFlow, scikit-learn and PyTorch. And I think it's really cool,

00:28:03 kind of like you're talking about the hardware is like, you take geospatial data and real world

00:28:08 things and do awesome stuff with it with Python. So here's kind of the map version of that. I think

00:28:13 that one's a fun one. And then hands-on web app test automation by Andrew Knight. Brian,

00:28:22 that'd be a good one for you as well, right? Like that sounds pretty interesting.

00:28:25 Yeah, it does look good.

00:28:26 Yeah. And finally, bigger, better, faster, more building applications in Python. That also looks

00:28:31 pretty cool to me. So there's a bunch of other great, and this is not like the best of list or

00:28:36 whatever. This is just like stuff that stood out to me like, oh, I'd go to these. Sounds pretty cool.

00:28:40 And these tutorials are priced way lower than any sort of corporate training is going to be

00:28:44 priced. Yeah. Yeah. Very cool. You guys are both going to be at PyCon, right? Brian,

00:28:49 you're speaking. Is that true? I am speaking. Yes. On what topic do you speak? I am talking about

00:28:54 parameterized testing. Awesome. And Kojo, I'm guessing that you're going to be there. You're at a lot of

00:28:58 the conferences. Yeah. And actually, so this year, I just started a new job. I'm working with a company

00:29:03 called RevSys now. They're sponsoring it, so I will be there. But yeah, Ian, I would have been there either way,

00:29:07 probably so. Yeah. Awesome. I'm glad you're going to be there as well. All right, Brian,

00:29:12 I guess that's it for our main items, huh? Yeah, it is. You got anything to share with folks?

00:29:15 I was going to share with folks that I'm speaking at PyCon, but we already covered that.

00:29:19 We snuck it in the previous one. How about you, Kojo? Anything extra you want to throw out there for

00:29:24 the world? No, I don't think I have any new, exciting Python-related stuff.

00:29:28 Well, I've got a couple to share. One, Eric Cho, just released the third edition of his

00:29:34 Mastering Python Networking, which is a cool little use Python to control all the network

00:29:39 things and set up network topologies and whatnot book, which is quite interesting. And I got a chance

00:29:43 to write the foreword for that. So thank you, Eric, and I'll link to the book. Also, speaking of network

00:29:49 things, both Pyramid, through the Waitress web server thing, and Django have issued vulnerability

00:29:57 CVEs. So yeah, if you have either of those in production and they're on the internet,

00:30:02 or even not, you might want to do a little upgrade, a Pippin's all upgrade, all the things on it.

00:30:07 Because yeah, there's like a SQL injection vulnerability, like a little Bobby Tables

00:30:12 vulnerability in Django, and some other similar type of thing for Waitress, and those are not

00:30:17 good to have. And why is Pyramid and Waitress together? Is Waitress bundled with Pyramid?

00:30:22 It comes with Pyramid. And I think the guys who work on Pyramid may also work on Waitress. I'm not

00:30:28 sure I could be wrong about that. So sorry, people who work on Waitress, if I got that wrong. But

00:30:32 certainly when you install Pyramid, you get Waitress, and you want that to be up to date.

00:30:36 Waitress server, you know, things like that.

00:30:38 Okay, and then the last thing, kind of like your item here, Kojo, even shorter time, like 45 minutes

00:30:46 ago, the Stack Overflow 2020 survey is open. So everyone should go fill that out. There's a ton

00:30:52 of information about where the broader ecosystem is at here. So it takes about 10 minutes. It's a

00:30:59 little bit long, but it's totally worth it, I think.

00:31:01 Yeah, and if there's anywhere in there where you can plug our podcasts, go for it.

00:31:05 I don't know if there is.

00:31:06 There totally should be.

00:31:06 Like, where do you get your news or something like that?

00:31:08 Yes, exactly. Other. All right, Brian, I picked a joke for us that's graphical, so we have to do a

00:31:14 little work describing it. But I think it's going to come out pretty well, because I think it's right

00:31:20 up your alley, actually, here. So this is a comic, which is Richard's Guide to Software Development.

00:31:27 And I'll kick it off. There's like a cat with little like super bionic legs. And underneath the

00:31:34 caption is, how the software is designed. You want to take it from here?

00:31:38 Okay, well then the next one is, how much time has to be spent on each part? And there's like 4%

00:31:46 for the head, and then 2% for the middle of it, 80% for the tail. Oh yeah, that's totally true.

00:31:52 Nice. The next one is, how the software looks before the beta test. It's a cat, but it has no back

00:31:59 legs at all, but it's still like suspended somehow.

00:32:01 Yeah, and then how the software looks after the beta test, there's no front legs, but there are back

00:32:06 legs. I'm just trying to imagine what happened here. Like, no, no, we wanted legs on the back of

00:32:10 the cat. Like, oh, you want the legs on the back? Sure, we'll put them on the back. Okay, we'll just

00:32:13 move them. Yeah.

00:32:14 And then how the software is advertised is like a tiger springing out of a picture with like action.

00:32:21 Yeah. What the customer really wanted, there's just a question mark, because nobody asked.

00:32:26 Exactly. And then how the software looks two versions later, it has a nose like an anteater or an elephant.

00:32:33 It's just a random human arm coming out the back of it.

00:32:36 Oh man. And the last scene has like a dude petting this cat that has the arm sticking out with the

00:32:43 elephant nose saying, I still like you anyway.

00:32:46 The cat says toots. Yeah.

00:32:49 Anyway, there's a nice little testing one. Actually for you as well, Kojo, right? You were in QA.

00:32:53 Yeah, it used to be. Yeah, the developers love their software.

00:32:56 That's great. All right. Well, this is a lot of fun. Kojo, thanks for being here. And Brian,

00:33:03 thanks as always. Glad to have you back this week.

00:33:04 Yeah, yeah. Thanks.

00:33:06 Thanks for having me, you guys.

00:33:07 Yep. Bye, everyone.

00:33:08 Bye.

00:33:09 Bye.

