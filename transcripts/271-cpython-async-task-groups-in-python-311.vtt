
00:00:00.000 --> 00:00:01.960
Hey there, thanks for listening.


00:00:01.960 --> 00:00:05.220
Before we jump into this episode, I just want to remind you that this episode is brought


00:00:05.220 --> 00:00:10.360
to you by us over at TalkBython Training, and Brian through his pytest book.


00:00:10.360 --> 00:00:15.460
So if you want to get hands on and learn something with Python, be sure to consider our courses


00:00:15.460 --> 00:00:17.320
over at TalkBython Training.


00:00:17.320 --> 00:00:21.040
Visit them via pythonbytes.fm/courses.


00:00:21.040 --> 00:00:25.420
And if you're looking to do testing and get better with pytest, check out Brian's book


00:00:25.420 --> 00:00:28.440
at pythonbytes.fm/pytest.


00:00:28.440 --> 00:00:29.440
Enjoy the episode.


00:00:29.440 --> 00:00:33.480
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly


00:00:33.480 --> 00:00:34.480
to your earbuds.


00:00:34.480 --> 00:00:36.040
This is episode 271.


00:00:36.040 --> 00:00:37.040
Really?


00:00:37.040 --> 00:00:38.040
Wow.


00:00:38.040 --> 00:00:41.080
Recorded February 16th, 2022.


00:00:41.080 --> 00:00:42.080
I'm Brian Okken.


00:00:42.080 --> 00:00:43.480
Hi, I'm Michael Kennedy.


00:00:43.480 --> 00:00:44.480
And I'm Steve Dower.


00:00:44.480 --> 00:00:45.480
Welcome, Steve.


00:00:45.480 --> 00:00:46.480
So, who's Steve Dower?


00:00:46.480 --> 00:00:47.480
Who's Steve Dower?


00:00:47.480 --> 00:00:48.480
Yeah.


00:00:48.480 --> 00:00:51.480
A number of things.


00:00:51.480 --> 00:00:55.440
Probably most interesting to this audience is I'm a core developer on CPython, one of


00:00:55.440 --> 00:00:56.440
our Windows experts.


00:00:56.440 --> 00:01:00.600
So I spend a lot of my time focusing on making Python run better on Windows.


00:01:00.600 --> 00:01:03.240
I also work on Microsoft, work at Microsoft,


00:01:03.240 --> 00:01:06.340
where I also spend a lot of my time making Python run better on Windows.


00:01:06.340 --> 00:01:09.960
So I'm kind of a bit of a one trick pony, I guess, but it's,


00:01:09.960 --> 00:01:13.640
I feel like it's good work and it helps a lot of people. So,


00:01:13.640 --> 00:01:16.480
So if I have a problem with Python on Windows, it's your fault.


00:01:16.480 --> 00:01:21.280
I, if there's solutions for Python on Windows, then it's, it's my fault.


00:01:21.280 --> 00:01:23.600
I'll let other people own the problems.


00:01:25.240 --> 00:01:30.240
So if I go to the Windows store, I can now install Python from there.


00:01:30.240 --> 00:01:32.420
And you were you were part of that, right?


00:01:32.420 --> 00:01:34.920
Oh, I should I should have had that up on screen, shouldn't I?


00:01:34.920 --> 00:01:37.620
Yeah, that was that that was actually


00:01:37.620 --> 00:01:42.120
the request came from people within Microsoft to like, hey, why can't


00:01:42.120 --> 00:01:45.280
why can't we get Python up on the store to it?


00:01:45.280 --> 00:01:48.520
And my response to all of these is like, well, if the community is willing to do it,


00:01:48.520 --> 00:01:52.080
which is half me and is half the people who would have to take over


00:01:52.080 --> 00:01:55.320
If I stop doing it, then yeah, we'll go ahead and do it.


00:01:55.320 --> 00:01:58.360
And so I got actual work time for that.


00:01:58.360 --> 00:02:01.560
That was a contribution from Microsoft for that one.


00:02:01.560 --> 00:02:03.160
But yeah, the community was on board


00:02:03.160 --> 00:02:06.000
and it's going really well.


00:02:06.000 --> 00:02:09.680
That's also the one that we tied into the default Python.exe


00:02:09.680 --> 00:02:11.440
that's on every Windows machine now.


00:02:11.440 --> 00:02:12.720
So if you go to a brand new machine


00:02:12.720 --> 00:02:14.260
and just type in Python,


00:02:14.260 --> 00:02:18.180
you'll get straight to the PSF's Python.


00:02:18.180 --> 00:02:19.580
Microsoft is not doing it anymore.


00:02:19.580 --> 00:02:20.720
We just contributed the change


00:02:20.720 --> 00:02:24.160
and now I switch hat and do it with the other hat on.


00:02:24.160 --> 00:02:26.920
So, you know, it's real Python, right?


00:02:26.920 --> 00:02:28.960
It's exactly the same as what you get from python.org.


00:02:28.960 --> 00:02:30.520
It's just delivered, you know,


00:02:30.520 --> 00:02:32.920
easily fast install automatic updates


00:02:32.920 --> 00:02:36.840
and a couple of edge issues


00:02:36.840 --> 00:02:38.680
that we're working on bringing down.


00:02:38.680 --> 00:02:40.400
So, yeah.


00:02:40.400 --> 00:02:41.240
- Fantastic.


00:02:41.240 --> 00:02:42.060
- Automatic update.


00:02:42.060 --> 00:02:43.400
I know this wasn't one of the topics,


00:02:43.400 --> 00:02:45.440
but now I think I might have to rethink


00:02:45.440 --> 00:02:48.440
how I'm installing Python on my desktop at work.


00:02:48.440 --> 00:02:50.800
So that's a cool idea.


00:02:50.800 --> 00:02:56.160
>> I have only had store installs on my own machines since 3.8.


00:02:56.160 --> 00:02:58.320
I think I haven't, apart from testing,


00:02:58.320 --> 00:03:01.560
I haven't actually used the regular installer on my own.


00:03:01.560 --> 00:03:04.400
>> But I mean, you, of course, that makes sense.


00:03:04.400 --> 00:03:06.640
>> It's always testing.


00:03:06.640 --> 00:03:09.320
Every time I'm using Python, I'm testing.


00:03:09.320 --> 00:03:11.400
>> Chris May out there says,


00:03:11.400 --> 00:03:14.000
"Thank you so much for making my work life in Windows easier."


00:03:14.000 --> 00:03:14.560
>> Anytime.


00:03:14.560 --> 00:03:18.120
>> Yeah. Well, Michael, why don't you kick us off with a story or a topic?


00:03:18.120 --> 00:03:20.680
I have got a good one.


00:03:20.680 --> 00:03:24.560
So I'm a big fan of FastAPI and FastAPI being built


00:03:24.560 --> 00:03:25.440
on Starlet.


00:03:25.440 --> 00:03:28.320
So by the transit of property, I'm also a fan of Starlet.


00:03:28.320 --> 00:03:30.720
And there's this thing I want to cover


00:03:30.720 --> 00:03:33.360
called FastAPI events.


00:03:33.360 --> 00:03:38.040
So when a request comes in to a particular API endpoint,


00:03:38.040 --> 00:03:39.760
or if you convert it over to a web app,


00:03:39.760 --> 00:03:42.280
to a webpage sort of request or something,


00:03:42.280 --> 00:03:44.520
you might want to dispatch that out to say


00:03:44.520 --> 00:03:47.400
like WebSocket listeners or something along those lines.


00:03:47.400 --> 00:03:49.960
So there's this cool project called Fast API Events.


00:03:49.960 --> 00:03:51.640
It's pretty small and new.


00:03:51.640 --> 00:03:53.080
So I'm gonna try to give it some visibility.


00:03:53.080 --> 00:03:54.460
It's only got 36 stars.


00:03:54.460 --> 00:03:57.480
It's pretty new, but the idea is that you can go through


00:03:57.480 --> 00:04:00.640
and basically create this middleware handler


00:04:00.640 --> 00:04:03.400
that will let you say, when a request comes in,


00:04:03.400 --> 00:04:05.480
here's the way, when an event is raised,


00:04:05.480 --> 00:04:06.960
here's the thing that's going to handle it.


00:04:06.960 --> 00:04:10.000
And then in some API endpoint, you can say dispatch,


00:04:10.000 --> 00:04:13.040
give the event a name and some dictionary data


00:04:13.040 --> 00:04:13.880
to be passed along.


00:04:13.880 --> 00:04:16.080
I suppose it doesn't have to be a dictionary,


00:04:16.080 --> 00:04:16.960
it could be whatever.


00:04:16.960 --> 00:04:18.680
And then in other parts of your code, you say,


00:04:18.680 --> 00:04:21.860
I wanna just hear about this event that happens


00:04:21.860 --> 00:04:24.400
no matter what API endpoint received it,


00:04:24.400 --> 00:04:27.860
no matter where in like how deep down in the code


00:04:27.860 --> 00:04:30.160
it was received and so on.


00:04:30.160 --> 00:04:31.960
So then way down here,


00:04:31.960 --> 00:04:34.720
you just put a role handler decorator on there.


00:04:34.720 --> 00:04:37.080
You say, I wanna capture all the events that start with,


00:04:37.080 --> 00:04:39.100
you know, some substring like cat star


00:04:39.100 --> 00:04:41.040
for like category, whatever,


00:04:41.040 --> 00:04:43.480
or this one is actually literally about cats.


00:04:43.480 --> 00:04:46.500
And then you can just go through and write these functions


00:04:46.500 --> 00:04:48.540
that will then handle that and you know,


00:04:48.540 --> 00:04:51.100
you can, you can also pass them off to queues


00:04:51.100 --> 00:04:54.300
like you can use the SQS, the simple queuing service


00:04:54.300 --> 00:04:57.420
from AWS I believe that is, as the endpoint


00:04:57.420 --> 00:04:59.140
instead of it just being your app, right?


00:04:59.140 --> 00:05:01.540
So if you've got like lots of scale out and stuff like that.


00:05:01.540 --> 00:05:02.380
- Wow, cool.


00:05:02.380 --> 00:05:04.820
So is this like a neat way to do logging


00:05:04.820 --> 00:05:06.100
or even distributed logging, I guess,


00:05:06.100 --> 00:05:08.340
if you've got forwarding handlers in there, you can just--


00:05:08.340 --> 00:05:10.020
- Yeah, yeah, it seems like it, right?


00:05:10.020 --> 00:05:13.740
Like, or if you know, you want to sort of build up


00:05:13.740 --> 00:05:15.500
like here's the request transaction


00:05:15.500 --> 00:05:16.560
and here we're at this stage,


00:05:16.560 --> 00:05:18.500
or you could maybe do visibility


00:05:18.500 --> 00:05:20.420
into long-running workflows with this kind of thing,


00:05:20.420 --> 00:05:22.260
or something along those lines, I would think.


00:05:22.260 --> 00:05:25.540
So, yeah, there's also an echo handler for debugging.


00:05:25.540 --> 00:05:26.380
I kind of like that.


00:05:26.380 --> 00:05:27.900
If I just need to see what is happening,


00:05:27.900 --> 00:05:29.780
it'll just print whatever's happening.


00:05:29.780 --> 00:05:31.560
It'll just start printing out all the behaviors


00:05:31.560 --> 00:05:32.940
that you're logging.


00:05:32.940 --> 00:05:34.500
- And then when you want to stop doing that,


00:05:34.500 --> 00:05:35.820
you just take away the handler,


00:05:35.820 --> 00:05:39.100
and you don't have to search the entire code base for print


00:05:39.100 --> 00:05:42.220
and find everywhere that you added it in for debugging.


00:05:42.220 --> 00:05:43.320
- Exactly.


00:05:44.400 --> 00:05:47.320
- Alvaro out there says, "This looks similar


00:05:47.320 --> 00:05:48.240
"to Django events."


00:05:48.240 --> 00:05:51.840
Yeah, I suspect it is similar.


00:05:51.840 --> 00:05:53.580
Anyway, pretty short and simple,


00:05:53.580 --> 00:05:56.320
but if you're looking for a way to sort of


00:05:56.320 --> 00:05:58.840
put notifications in a structured way


00:05:58.840 --> 00:06:01.640
into a fast API app, well, here you go.


00:06:01.640 --> 00:06:03.040
- Oh, I'm thinking of a whole bunch


00:06:03.040 --> 00:06:04.880
of more abusive ways to use this.


00:06:04.880 --> 00:06:07.920
(both laughing)


00:06:07.920 --> 00:06:10.240
- I mean, yeah, you can write some really impressive


00:06:10.240 --> 00:06:11.640
spaghetti code with this.


00:06:11.640 --> 00:06:13.760
- Yeah, I'm sure that you can.


00:06:13.760 --> 00:06:15.760
cloud involved in everything.


00:06:15.760 --> 00:06:20.440
>> Yeah. Let's switch gears a little bit and talk about testing.


00:06:20.440 --> 00:06:23.040
Imagine that I've got a testing topic.


00:06:23.040 --> 00:06:25.560
I'm pretty excited.


00:06:25.560 --> 00:06:30.280
I've been asked a lot about testing pipelines,


00:06:30.280 --> 00:06:31.760
testing data science stuff,


00:06:31.760 --> 00:06:35.280
and that's not something I do day-to-day.


00:06:35.280 --> 00:06:38.480
I'm really glad to find people talking about it.


00:06:38.480 --> 00:06:42.180
We've got an article from Peter Baumgartner,


00:06:42.180 --> 00:06:46.260
ways to use testing, ways I use testing as a data scientist.


00:06:46.260 --> 00:06:49.180
And I just really love this article.


00:06:49.180 --> 00:06:50.660
It's great.


00:06:50.660 --> 00:06:56.300
To start with, he starts off with what he uses testing for as a data scientist.


00:06:56.300 --> 00:06:59.420
He uses testing to make sure things work,


00:06:59.420 --> 00:07:01.420
to document his understanding,


00:07:01.420 --> 00:07:04.100
and to prevent future errors.


00:07:04.100 --> 00:07:06.100
Well, that seems straightforward.


00:07:06.100 --> 00:07:09.580
But the reason why he wrote this up is


00:07:09.580 --> 00:07:11.700
apparently because there's a lot of software,


00:07:11.700 --> 00:07:14.020
there's a lot of testing stuff out on the web,


00:07:14.020 --> 00:07:18.700
but it's geared towards test engineers or software developers.


00:07:18.700 --> 00:07:20.380
He's like, "I'm not a software developer.


00:07:20.380 --> 00:07:23.380
I'm doing something else.


00:07:23.380 --> 00:07:25.940
I'm doing analysis. I'm not a software person."


00:07:25.940 --> 00:07:28.100
Even though, yeah, you are.


00:07:28.100 --> 00:07:31.780
But to write this up in


00:07:31.780 --> 00:07:35.980
a context where data people might understand it better.


00:07:35.980 --> 00:07:38.220
For instance, he doesn't even start off with


00:07:38.220 --> 00:07:43.140
writing, having written tests, his, his analysis is like, if


00:07:43.140 --> 00:07:47.820
you're doing notebooks or other code, just use assert a lot. So


00:07:47.820 --> 00:07:52.820
he's using assert all over the place, including he says, I


00:07:52.820 --> 00:07:57.020
already have use it for as many intermediate calculations and


00:07:57.020 --> 00:08:02.180
processes as as you can, as it makes sense. Because in doing


00:08:02.180 --> 00:08:05.540
things like checking obvious stuff, like he's got an example


00:08:05.540 --> 00:08:09.620
of a table count where he's counting up all the yeses.


00:08:09.620 --> 00:08:11.420
Well, you can do a little bit of math


00:08:11.420 --> 00:08:12.780
just to make sure the math works.


00:08:12.780 --> 00:08:14.700
So like all the yeses and nos and missing


00:08:14.700 --> 00:08:17.060
should all add up to the same count.


00:08:17.060 --> 00:08:18.700
Go ahead and throw an assert in there


00:08:18.700 --> 00:08:20.560
because sometimes it doesn't.


00:08:20.560 --> 00:08:23.920
And in this example, he said that he actually caught an error


00:08:23.920 --> 00:08:28.380
because he was looking at two different data frames.


00:08:28.380 --> 00:08:31.340
So they really weren't, they didn't add up to the same.


00:08:31.340 --> 00:08:33.080
So you can catch things like that.


00:08:33.080 --> 00:08:36.880
So just double checking yourself on things


00:08:36.880 --> 00:08:41.660
as you go away, go as you're developing.


00:08:41.660 --> 00:08:43.740
One of the cool quotes he has in here is like,


00:08:43.740 --> 00:08:47.000
as he has a habit of when he's using notebooks


00:08:47.000 --> 00:08:50.200
to whenever he's visually inspecting the output,


00:08:50.200 --> 00:08:53.080
if you're visually looking at the data that comes out,


00:08:53.080 --> 00:08:57.800
maybe write an assert statement to do that analysis


00:08:57.800 --> 00:09:00.420
so that it's always checked.


00:09:00.420 --> 00:09:03.660
And this is a cool use of putting asserts in notebooks.


00:09:03.660 --> 00:09:04.680
I like this idea.


00:09:04.680 --> 00:09:08.540
The article goes on, it's pretty extensive,


00:09:08.540 --> 00:09:13.540
talking about checking the data, using hypothesis to,


00:09:13.540 --> 00:09:16.640
well, not the data at this part,


00:09:16.640 --> 00:09:19.180
but your assumptions around the data.


00:09:19.180 --> 00:09:21.980
So using hypothesis to check your assumptions


00:09:21.980 --> 00:09:24.860
and hypothesis will show you things


00:09:24.860 --> 00:09:25.960
that maybe you didn't consider,


00:09:25.960 --> 00:09:29.660
like NANDs, are you handling those correctly?


00:09:29.660 --> 00:09:34.340
empty series or empty data structures that are going into your code?


00:09:34.340 --> 00:09:35.740
Are you handling those?


00:09:35.740 --> 00:09:39.540
I mean, hypothesis does take some hand-holding,


00:09:39.540 --> 00:09:44.140
but it does make you think about really what is the shape of the data going in,


00:09:44.140 --> 00:09:47.540
and do you need to limit it?


00:09:47.540 --> 00:09:49.620
What hypothesis is looking at or do you


00:09:49.620 --> 00:09:51.660
need to change your code to handle more things?


00:09:51.660 --> 00:09:54.220
>> Hypothesis is great. I've used that for a couple


00:09:54.220 --> 00:09:58.200
of parsing projects or combining projects.


00:09:58.200 --> 00:10:01.100
I spent way too long adding all the strategies


00:10:01.100 --> 00:10:05.020
to be able to test a URL parser that I was calling into.


00:10:05.020 --> 00:10:09.460
But it's fantastic for finding kind of things


00:10:09.460 --> 00:10:11.140
that you would not have thought of.


00:10:11.140 --> 00:10:13.180
- Yeah, I mean, it's finding things,


00:10:13.180 --> 00:10:14.980
but it's also, and it does make, yeah,


00:10:14.980 --> 00:10:17.660
that aspect of it seems like the point of it,


00:10:17.660 --> 00:10:20.580
but the real value I get out of hypothesis


00:10:20.580 --> 00:10:23.500
is thinking, making sure I really understand


00:10:23.500 --> 00:10:27.620
the data that's gonna come in and thinking through those.


00:10:27.620 --> 00:10:29.860
It goes on to talk about actually testing your data


00:10:29.860 --> 00:10:32.880
using things like Pandera, which I wasn't familiar with,


00:10:32.880 --> 00:10:35.200
and another package called Great Expectations


00:10:35.200 --> 00:10:39.120
to look at like putting schemas around the data coming in


00:10:39.120 --> 00:10:42.360
and making sure that the data always matches the schema,


00:10:42.360 --> 00:10:46.400
going on to talk about Arrange Act Insert and using pytest.


00:10:46.400 --> 00:10:47.780
pytest comes in with,


00:10:47.780 --> 00:10:49.880
he's only really writing formal tests


00:10:49.880 --> 00:10:52.280
when he's writing libraries for other people,


00:10:52.280 --> 00:10:54.280
but all these other packages


00:10:54.280 --> 00:10:56.640
to be able to test with data science,


00:10:56.640 --> 00:10:57.880
I think this is a great addition


00:10:57.880 --> 00:10:59.600
to the data science community.


00:10:59.600 --> 00:11:02.700
- Yeah. Alvaro talks about how this is,


00:11:02.700 --> 00:11:04.880
you know, often referred to as defensive programming.


00:11:04.880 --> 00:11:07.080
And then, you know, I feel for him a little bit,


00:11:07.080 --> 00:11:09.280
he says, "At work we use this with our Fortran code."


00:11:09.280 --> 00:11:12.720
So there's that, but I do think this is a really


00:11:12.720 --> 00:11:15.720
interesting way of thinking about defensive code.


00:11:15.720 --> 00:11:17.980
You know, I just, I think of writing defensive code


00:11:17.980 --> 00:11:19.920
as like, oh, I'm gonna have a bunch of if statements


00:11:19.920 --> 00:11:21.360
to verify this thing's not none,


00:11:21.360 --> 00:11:23.020
or verify that this is the right type


00:11:23.020 --> 00:11:26.900
and that it has a reasonable value and raise exceptions.


00:11:26.900 --> 00:11:30.500
I haven't really thought so much of it for notebooks.


00:11:30.500 --> 00:11:31.620
So that's pretty interesting.


00:11:31.620 --> 00:11:33.260
- And one of the neat things about


00:11:33.260 --> 00:11:35.660
if you're actually putting asserts in your code,


00:11:35.660 --> 00:11:38.580
you can write tests against your code


00:11:38.580 --> 00:11:41.300
that don't even have any asserts in them.


00:11:41.300 --> 00:11:44.380
And because the asserts will happen within your code


00:11:44.380 --> 00:11:46.140
and the test will still fail and catch it.


00:11:46.140 --> 00:11:47.380
So it's kind of cool.


00:11:47.380 --> 00:11:48.740
- Yeah, yeah, very cool.


00:11:48.740 --> 00:11:49.580
Good stuff.


00:11:49.580 --> 00:11:50.820
- Yeah.


00:11:50.820 --> 00:11:52.540
- Steve, I am super excited to hear


00:11:52.540 --> 00:11:54.540
about what you're, you got coming up


00:11:54.540 --> 00:11:56.140
because this is brand new.


00:11:56.140 --> 00:11:58.260
Being a core developer, I feel it is appropriate


00:11:58.260 --> 00:12:00.500
that you break this news here.


00:12:00.500 --> 00:12:02.420
- I mean, I'm not gonna lie when it came to,


00:12:02.420 --> 00:12:03.640
you know, what am I gonna talk about?


00:12:03.640 --> 00:12:05.900
Okay, what's the most recently accepted pep


00:12:05.900 --> 00:12:07.500
that was somewhat controversial?


00:12:07.500 --> 00:12:11.540
And I think just as you kind of look down


00:12:11.540 --> 00:12:13.940
to the section on rejected ideas,


00:12:13.940 --> 00:12:16.780
which is considerably longer than the accepted ideas,


00:12:16.780 --> 00:12:21.420
you probably get a bit of a sense for just what went on


00:12:21.420 --> 00:12:24.080
with exception groups.


00:12:24.080 --> 00:12:26.080
And I know, Michael, you just had a conversation.


00:12:26.080 --> 00:12:27.320
You've learned all about them.


00:12:27.320 --> 00:12:30.720
So you can take over when I run out here.


00:12:30.720 --> 00:12:31.220
But--


00:12:31.220 --> 00:12:32.520
I'll share my thoughts with it.


00:12:32.520 --> 00:12:33.080
But yeah, go ahead.


00:12:33.080 --> 00:12:34.180
I'd love to hear about it.


00:12:34.180 --> 00:12:37.200
This is sort of inspired by Trio, right?


00:12:37.200 --> 00:12:40.020
The end goal kind of is-- so this is an interesting pep.


00:12:40.020 --> 00:12:42.220
And we've got a few of these on the go at the moment.


00:12:42.220 --> 00:12:44.560
It's kind of like a stepping stone towards a better


00:12:44.560 --> 00:12:46.720
programming model or a stepping stone


00:12:46.720 --> 00:12:48.120
towards better libraries.


00:12:48.120 --> 00:12:52.440
So it's something that I think in my opinion,


00:12:52.440 --> 00:12:57.080
very few application developers, the last developer


00:12:57.080 --> 00:13:00.200
in the chain, are often not going to use them,


00:13:00.200 --> 00:13:02.160
and they're not going to need them.


00:13:02.160 --> 00:13:05.440
But as you go further in towards the lower levels of libraries,


00:13:05.440 --> 00:13:08.280
especially people writing async schedulers,


00:13:08.280 --> 00:13:10.200
are going to find incredible value out of them.


00:13:10.200 --> 00:13:13.440
Essentially, what the idea is is that when you're


00:13:13.440 --> 00:13:16.840
running multiple tasks in parallel, if some of them


00:13:16.840 --> 00:13:19.720
fail, we don't currently have a neat way


00:13:19.720 --> 00:13:23.560
to capture the exceptions from all of the ones that failed.


00:13:23.560 --> 00:13:26.520
There's some approaches that would be like, wait for all of them to complete


00:13:26.520 --> 00:13:30.320
and wrap it in a list, and then you get some exception that contains a list of


00:13:30.320 --> 00:13:33.840
exceptions, but that's lost a whole lot of context.


00:13:33.840 --> 00:13:37.360
You can get just whichever exception happens first, but then you lose all the


00:13:37.360 --> 00:13:40.680
other exceptions and there's just been no real way to handle it.


00:13:40.680 --> 00:13:45.120
So an exception group essentially does bundle up all the exceptions


00:13:45.120 --> 00:13:46.560
internally in some way.


00:13:46.560 --> 00:13:49.860
But the really interesting thing is the accept star syntax,


00:13:49.860 --> 00:13:53.160
which I'm going to have to scroll a long way down to find where that comes up.


00:13:53.160 --> 00:13:58.260
But this is really clever because if you're in that


00:13:58.260 --> 00:14:02.340
situation where say you're running 10 parallel processes,


00:14:02.340 --> 00:14:04.380
so here's kind of the first example of it,


00:14:04.380 --> 00:14:08.300
then exceptions are no longer control flow at this level.


00:14:08.300 --> 00:14:09.140
Cause if you're,


00:14:09.140 --> 00:14:12.540
if you've run 10 things and you're waiting for 10 things to complete,


00:14:12.540 --> 00:14:14.940
you're not actually doing control flow with the exceptions anymore.


00:14:14.940 --> 00:14:18.220
What you're doing is handling the exception,


00:14:18.220 --> 00:14:22.500
but then the control flow is going to go back to where it was anyway, because,


00:14:22.500 --> 00:14:26.260
because you're going to be doing something different. So for example,


00:14:26.260 --> 00:14:31.060
if a file doesn't open, then you would want to do something different,


00:14:31.060 --> 00:14:34.220
right? You're going to stop going on and trying to read from the file.


00:14:34.220 --> 00:14:39.980
But if you've tried to open 10 files and three of them failed you at the


00:14:39.980 --> 00:14:43.460
outside level. So at the end, at the inner level for each file that may have failed,


00:14:43.460 --> 00:14:46.820
you'll do something different at the outer level. All you're really going to do is say,


00:14:46.820 --> 00:14:51.500
hey, this task failed because a file couldn't be opened and maybe you do something else,


00:14:51.500 --> 00:14:55.300
but it's at the outside level. So except star takes that exception group and it's going


00:14:55.300 --> 00:14:59.780
to give you a chance to handle each exception, essentially on its own. It will group


00:14:59.780 --> 00:15:05.300
them together. So in this example, if you know, five tasks report spam error, then you'll


00:15:05.300 --> 00:15:11.140
get into this except spam error block with all five of them at once, which is just...


00:15:11.140 --> 00:15:16.340
Is that a list of spam exception, spam error exceptions? Something like, or a tuple,


00:15:16.340 --> 00:15:20.820
something like that? I think it's a tuple. I think with the star syntax, I believe.


00:15:20.820 --> 00:15:23.620
Something iterable, basically, yeah.


00:15:23.620 --> 00:15:29.460
Yeah. Something you can iterate over to see the exceptions, but it's really just,


00:15:29.460 --> 00:15:34.980
you know, this happened at some point and you process it. And if the group actually contains


00:15:34.980 --> 00:15:39.380
multiple types of exceptions, then each handler that matches is going to be called for all the


00:15:39.380 --> 00:15:45.460
exceptions that match that. So you could have this try block raise an exception group that has some


00:15:45.460 --> 00:15:51.060
spam errors, it has some foo errors, it has some bar errors, and all three except star blocks are


00:15:51.060 --> 00:15:56.660
going to get called with the exceptions that match those, which is a bit, it's definitely going to


00:15:56.660 --> 00:16:01.860
confuse a lot of people. It confuses me, which is why I was keen to actually spend a bit more time


00:16:01.860 --> 00:16:08.100
digging into it and trying to figure out what's really valuable about this. And I do think the


00:16:08.100 --> 00:16:13.540
most valuable one is really where the error is cancelled error. Because if for whatever reason,


00:16:13.540 --> 00:16:18.660
five of your tasks have been cancelled, then you need to capture that and do something with that


00:16:18.660 --> 00:16:24.180
outside of it. But it doesn't necessarily mean you want to throw away the five successful results.


00:16:24.180 --> 00:16:28.340
And so you do kind of want to keep a bit of everything going on.


00:16:28.340 --> 00:16:33.780
And like I say, it's a building block on its own. This isn't enough to


00:16:33.780 --> 00:16:38.580
do anything new and useful. The next thing that comes along is task groups.


00:16:38.580 --> 00:16:44.500
And that's being worked on by... I expect a lot of the same people who worked on exception groups,


00:16:44.500 --> 00:16:48.260
because with task groups, now you can actually start... There we go.


00:16:48.980 --> 00:16:56.500
Guidos just merged task groups. Excellent. Then now you can actually run the task group. And if


00:16:56.500 --> 00:17:00.500
the group raises any errors, then you'll catch them through an exception group.


00:17:00.500 --> 00:17:09.620
And so that enables a whole lot of new uses and new ways to use async.io or just async generally,


00:17:09.620 --> 00:17:12.820
no matter the library. As you say, Trios already has something like this for a while.


00:17:12.820 --> 00:17:15.220
>> Yeah, from their nursery thing.


00:17:15.220 --> 00:17:18.940
- Yeah, and so that is now being standardized


00:17:18.940 --> 00:17:22.020
so libraries can kind of share their implementations


00:17:22.020 --> 00:17:23.680
and work together on it.


00:17:23.680 --> 00:17:27.100
- So one of the reasons you need this is if I start


00:17:27.100 --> 00:17:29.860
two web requests and three database queries,


00:17:29.860 --> 00:17:31.360
and then I go to wait on them,


00:17:31.360 --> 00:17:34.140
you know, then if several of them fail,


00:17:34.140 --> 00:17:39.140
the error state captured in totality is a tree of errors


00:17:39.140 --> 00:17:42.940
that represent, well, this task started this other task,


00:17:42.940 --> 00:17:45.740
which then had this error, this other one, right?


00:17:45.740 --> 00:17:48.300
So you need some way to deal with a group of errors


00:17:48.300 --> 00:17:50.580
that could happen kind of all at once, right?


00:17:50.580 --> 00:17:52.860
In one of these task groups that gets kicked off.


00:17:52.860 --> 00:17:53.700
- Yeah.


00:17:53.700 --> 00:17:55.900
- So the new task group thing is super cool.


00:17:55.900 --> 00:17:59.120
So you say async with task group as TG,


00:17:59.120 --> 00:18:00.580
and there's two things that are neat about it.


00:18:00.580 --> 00:18:03.380
One is right now, if you fire off a bunch of tasks


00:18:03.380 --> 00:18:06.540
in async and await style, they're basically unrelated.


00:18:06.540 --> 00:18:09.340
Like if one fails, that means nothing for the other, right?


00:18:09.340 --> 00:18:10.500
They're just like, well, here's a bunch of stuff


00:18:10.500 --> 00:18:12.900
that happened, and this creates a relationship


00:18:12.900 --> 00:18:14.020
between them, right?


00:18:14.020 --> 00:18:16.540
So that if one fails, I think it might not schedule new ones


00:18:16.540 --> 00:18:18.220
something to that of like it's brand new.


00:18:18.220 --> 00:18:19.100
I'm just seeing the tweets.


00:18:19.100 --> 00:18:20.860
So I think that that's the story.


00:18:20.860 --> 00:18:23.420
I believe that was the story of Rio.


00:18:23.420 --> 00:18:25.580
The other thing that's interesting here that


00:18:25.580 --> 00:18:29.460
in this example, which I'll link to from Yuri


00:18:29.460 --> 00:18:31.900
that he posted, he tweeted about the news


00:18:31.900 --> 00:18:34.700
was notice that the first one says,


00:18:34.700 --> 00:18:37.260
task group create task for some task


00:18:37.260 --> 00:18:40.040
and then await something that creates another task.


00:18:40.040 --> 00:18:41.520
There's nowhere where you say,


00:18:41.520 --> 00:18:44.840
store all those values into like some lists of tasks,


00:18:44.840 --> 00:18:47.000
then go to the task and iterate them and wait for them


00:18:47.000 --> 00:18:48.700
or gather them or whatever the heck it was


00:18:48.700 --> 00:18:49.800
you had to do before.


00:18:49.800 --> 00:18:52.880
This now makes tasks fire and forget.


00:18:52.880 --> 00:18:54.120
I can say, run this, run this,


00:18:54.120 --> 00:18:56.840
and within that, I could do more of those types of things.


00:18:56.840 --> 00:19:01.000
And then you just block at the with context manager level


00:19:01.000 --> 00:19:02.680
to wait for all the tasks to finish,


00:19:02.680 --> 00:19:04.640
which I think is a real big improvement


00:19:04.640 --> 00:19:06.880
'cause right now you've got to like constantly juggle,


00:19:06.880 --> 00:19:08.080
well, I've got to return a task from this


00:19:08.080 --> 00:19:09.360
so I can go wait on it later


00:19:09.360 --> 00:19:10.840
and all those sort of oddities.


00:19:10.840 --> 00:19:12.920
And this cleans up a lot of that.


00:19:12.920 --> 00:19:14.480
- Right, and of course being Python,


00:19:14.480 --> 00:19:16.400
I don't know exactly how the syntax works,


00:19:16.400 --> 00:19:19.600
but being Python, that TG object, the task group,


00:19:19.600 --> 00:19:21.640
doesn't actually disappear at the end of the with block.


00:19:21.640 --> 00:19:24.320
So if that's got results stored into it,


00:19:24.320 --> 00:19:26.100
then you still have access to those


00:19:26.100 --> 00:19:28.240
and all of the information about the task group,


00:19:28.240 --> 00:19:30.720
even after you've waited for it to complete running.


00:19:30.720 --> 00:19:31.800
- Oh yeah, that's cool.


00:19:31.800 --> 00:19:33.560
Yeah, so I think this is a nice addition


00:19:33.560 --> 00:19:35.720
to async IO in Python.


00:19:35.720 --> 00:19:36.560
This is cool.


00:19:36.560 --> 00:19:38.000
And apparently 3.11 is coming.


00:19:38.000 --> 00:19:40.120
Yeah, coming in 3.11.


00:19:40.120 --> 00:19:42.240
I do see a question from Sam Morley in the chat there.


00:19:42.240 --> 00:19:43.360
Is there a way to short circuit


00:19:43.360 --> 00:19:45.800
so that you don't recatch certain exceptions?


00:19:45.800 --> 00:19:47.720
My understanding, and Michael,


00:19:47.720 --> 00:19:50.200
if you've got a better one, correct me,


00:19:50.200 --> 00:19:53.400
is that the except blocks work in the same way


00:19:53.400 --> 00:19:56.400
as regular ones, and the first one


00:19:56.400 --> 00:19:58.680
that matches a particular exception will handle it,


00:19:58.680 --> 00:20:01.940
and the later ones don't, even if they would also match.


00:20:01.940 --> 00:20:05.840
So if you have, so if the spam error


00:20:05.840 --> 00:20:07.360
is a subclass of foo error,


00:20:07.360 --> 00:20:09.240
but there's another subclass of foo error,


00:20:09.240 --> 00:20:12.680
then spam errors will get handled by the spam error handler.


00:20:12.680 --> 00:20:16.320
The foo error handler will handle all the other ones


00:20:16.320 --> 00:20:18.640
apart from the spam error subclass.


00:20:18.640 --> 00:20:21.640
- Nice, yeah, I don't know much about the accept star


00:20:21.640 --> 00:20:23.560
other than it was basically a requirement


00:20:23.560 --> 00:20:26.200
for the task group stuff to be implemented properly.


00:20:26.200 --> 00:20:28.800
So when one came in, then the other could come in, yeah.


00:20:28.800 --> 00:20:32.860
- It's the only feasible way to actually do something


00:20:32.860 --> 00:20:34.600
as a result of an exception group.


00:20:34.600 --> 00:20:39.000
Otherwise, you do end up with a very generic exception,


00:20:39.000 --> 00:20:42.440
and then you write a for loop over all the exceptions


00:20:42.440 --> 00:20:44.060
that it handled and try and figure it out yourself.


00:20:44.060 --> 00:20:46.240
So you'd end up rewriting the code,


00:20:46.240 --> 00:20:48.540
and it was just not gonna be feasible.


00:20:48.540 --> 00:20:50.800
It needed to be syntax, and so it is.


00:20:50.800 --> 00:20:52.480
- Yeah, right on.


00:20:52.480 --> 00:20:54.080
Very exciting and very timely.


00:20:54.080 --> 00:20:54.920
Thanks, Steve.


00:20:54.920 --> 00:20:56.480
- I'm kinda glad that I put off learning


00:20:56.480 --> 00:20:58.880
how to do async code until 3.11.


00:20:58.880 --> 00:21:00.760
This looks easier.


00:21:00.760 --> 00:21:03.560
- It's a good band and a good time for async I/O.


00:21:03.560 --> 00:21:04.400
- Well, cool.


00:21:04.400 --> 00:21:06.280
- All right, I guess I'm up with the next one, huh, Brian?


00:21:06.280 --> 00:21:08.480
- Yeah, let's see what you got.


00:21:08.480 --> 00:21:10.920
- I have got some other interesting things.


00:21:10.920 --> 00:21:15.040
I'm here about showing off the underappreciated projects,


00:21:15.040 --> 00:21:17.360
or the new projects, just a couple of stars here.


00:21:17.360 --> 00:21:18.880
And we've talked about overloading before,


00:21:18.880 --> 00:21:20.960
but I thought this was a clean way to do it


00:21:20.960 --> 00:21:21.800
that people could think about.


00:21:21.800 --> 00:21:23.120
And Steve, I would definitely love


00:21:23.120 --> 00:21:24.000
to hear your thoughts on this.


00:21:24.000 --> 00:21:29.000
So Felix the cat created this library called PyOverload.


00:21:29.000 --> 00:21:32.900
And the idea is basically once you have type information,


00:21:32.900 --> 00:21:35.560
then you can have method or function overloading.


00:21:35.560 --> 00:21:36.540
The idea being like, okay,


00:21:36.540 --> 00:21:38.720
if a function called boo or whatever,


00:21:38.720 --> 00:21:40.820
and if it, you can say, if it takes an integer,


00:21:40.820 --> 00:21:42.380
I want this implementation run.


00:21:42.380 --> 00:21:43.220
If it takes a string,


00:21:43.220 --> 00:21:45.780
I want some other implementation to run, right?


00:21:45.780 --> 00:21:49.460
That's sort of the traditional C++, C# definition of it.


00:21:49.460 --> 00:21:52.100
But in Python, we don't have that really


00:21:52.100 --> 00:21:54.140
because the language started without type.


00:21:54.140 --> 00:21:56.100
So how are you gonna figure out the type to overload it?


00:21:56.100 --> 00:21:56.940
You know, right?


00:21:56.940 --> 00:21:58.120
That just like, doesn't make any sense.


00:21:58.120 --> 00:22:00.260
So with this one, you could sort of use,


00:22:00.260 --> 00:22:01.960
like traditionally you could use is instance.


00:22:01.960 --> 00:22:03.520
we're gonna do one thing or another.


00:22:03.520 --> 00:22:05.560
Is it a single thing or is it a list of those things?


00:22:05.560 --> 00:22:06.600
What are we gonna do?


00:22:06.600 --> 00:22:09.720
But with this one, you can put just @overload


00:22:09.720 --> 00:22:11.860
and then whatever the signature is,


00:22:11.860 --> 00:22:14.600
if you can say it has no functions or has no parameters


00:22:14.600 --> 00:22:17.680
or it has like two integers or it has three integers


00:22:17.680 --> 00:22:20.840
or it has like a list of them, whatever.


00:22:20.840 --> 00:22:22.800
And there's even a way to sort of say


00:22:22.800 --> 00:22:24.560
somewhere down here, there's a way to say like,


00:22:24.560 --> 00:22:27.120
if none of them match, call this particular one.


00:22:27.120 --> 00:22:30.040
So basically it's just straight function overloading


00:22:30.040 --> 00:22:31.680
in Python if that's the thing you want.


00:22:31.680 --> 00:22:33.680
Steve, does this make you cringe or do you like it?


00:22:33.680 --> 00:22:35.680
Uh, well, it's...


00:22:35.680 --> 00:22:37.680
Both?


00:22:37.680 --> 00:22:39.680
You know, I'm not going to lie, I'm not


00:22:39.680 --> 00:22:41.680
the most into


00:22:41.680 --> 00:22:43.680
static typing in my Python code


00:22:43.680 --> 00:22:45.680
as a lot of other people.


00:22:45.680 --> 00:22:47.680
And there's a lot of


00:22:47.680 --> 00:22:49.680
complicated reasons, but I think for a situation like this


00:22:49.680 --> 00:22:51.680
I mean, I know if I was


00:22:51.680 --> 00:22:53.680
writing a function that took a string or an int


00:22:53.680 --> 00:22:55.680
the very first line would be


00:22:55.680 --> 00:22:57.680
converted to whichever type I actually want


00:22:57.680 --> 00:22:59.680
and then the rest of the function is going to look


00:22:59.680 --> 00:23:05.040
identical. And that's sure. And that in that case where like there might be a unparsed


00:23:05.040 --> 00:23:09.560
type of thing for sure. I think you wouldn't really do an overload. That would be insane.


00:23:09.560 --> 00:23:15.280
And my kind of gut feel and you know, I'm always open to to examples proving me wrong.


00:23:15.280 --> 00:23:19.480
In which case I, you know, I would write the is instance code that's in those examples.


00:23:19.480 --> 00:23:22.960
You know, my kind of gut feeling is that if you're doing two drastically different things


00:23:22.960 --> 00:23:28.240
in the function based on the type, you need two functions. And once you've got two separate


00:23:28.240 --> 00:23:32.140
And if the people calling don't know what they're passing you,


00:23:32.140 --> 00:23:34.180
then they've got a problem.


00:23:34.180 --> 00:23:36.440
And it's not so much my responsibility


00:23:36.440 --> 00:23:37.700
to fix it with overloading.


00:23:37.700 --> 00:23:40.380
That said, overloading is really cool.


00:23:40.380 --> 00:23:43.300
And I am the exact opposite person


00:23:43.300 --> 00:23:45.020
when it comes to C and C++.


00:23:45.020 --> 00:23:47.220
I will do all the craziest possible stuff


00:23:47.220 --> 00:23:48.500
with overloading in those languages,


00:23:48.500 --> 00:23:50.040
because I think it fits the language,


00:23:50.040 --> 00:23:51.500
and it's a lot of fun.


00:23:51.500 --> 00:23:53.780
And there's definitely occasions and value


00:23:53.780 --> 00:23:55.340
for having it in Python.


00:23:55.340 --> 00:23:57.540
We do have the single dispatch decorator.


00:23:57.540 --> 00:23:59.860
has been part of Python for a while, which will do this


00:23:59.860 --> 00:24:02.700
on the very first parameter.


00:24:02.700 --> 00:24:06.820
This, very trivially extending it to the whole function


00:24:06.820 --> 00:24:09.660
signature is really cool.


00:24:09.660 --> 00:24:14.020
So if I needed to do this, I would probably


00:24:14.020 --> 00:24:15.620
want to use a library like this.


00:24:15.620 --> 00:24:21.140
I would probably reconsider my API design choices


00:24:21.140 --> 00:24:23.100
up to that point.


00:24:23.100 --> 00:24:26.240
But I can understand the attraction of getting to,


00:24:26.240 --> 00:24:29.460
you know, to reuse the name


00:24:29.460 --> 00:24:31.860
and not make the person calling it think too hard


00:24:31.860 --> 00:24:35.360
about how, you know, what's actually gonna run.


00:24:35.360 --> 00:24:38.060
- Yeah, the place where this sort of seems interesting


00:24:38.060 --> 00:24:39.460
to me is, you know, there's some,


00:24:39.460 --> 00:24:41.480
lot of like tricks and juggling people do


00:24:41.480 --> 00:24:43.460
with like star args, star star kW args,


00:24:43.460 --> 00:24:45.700
where like, okay, depending on how you pass it,


00:24:45.700 --> 00:24:47.220
stuff will do a bunch of things.


00:24:47.220 --> 00:24:48.060
- Yeah.


00:24:48.060 --> 00:24:51.180
- And I'm always looking for a way to like not do that.


00:24:51.180 --> 00:24:52.020
- Yeah.


00:24:52.020 --> 00:24:57.140
How can I not? How can I remove that? Like it's completely opaque. I have to do a Google search


00:24:57.140 --> 00:25:02.260
and read the docs to figure out what is at all possible here. Well, one of these days I'm going


00:25:02.260 --> 00:25:05.700
probably going to take all of the kind of patents for that kind of thing that I've collected and


00:25:05.700 --> 00:25:10.900
turn it into a book. But writing a book just feels like way too much work. So not anytime soon. Sorry.


00:25:10.900 --> 00:25:16.100
My colleagues at work can ping me at any time and I'll give them a patent for what they're


00:25:16.100 --> 00:25:24.020
trying to do. But that's, I do have quite a set of, oh, you're trying to make stuff weirdly work


00:25:24.020 --> 00:25:29.460
in this way. Here's a nice way that you can enable that without having to resort to, you know, type


00:25:29.460 --> 00:25:34.020
checks and everything. Yeah, yeah. I've been using, I mean, I've been using Python for a long time.


00:25:34.020 --> 00:25:38.900
And I do remember one of the first things that I noticed is I couldn't do overloading. And at the


00:25:38.900 --> 00:25:44.420
time, so this is, you know, many years ago, I was using a lot of overloading in my C and C++ code.


00:25:45.220 --> 00:25:48.300
and I was like, "Oh, I can't do overloading."


00:25:48.300 --> 00:25:50.300
But one of the things I've noticed is actually,


00:25:50.300 --> 00:25:54.660
instead of wishing that I had overloading in Python,


00:25:54.660 --> 00:25:58.980
I've noticed that I don't really use it in C and C++ anymore.


00:25:58.980 --> 00:26:00.540
>> It's gone the other way.


00:26:00.540 --> 00:26:03.780
>> Yeah. I'd rather be more explicit about


00:26:03.780 --> 00:26:09.660
the two functions that maybe they're similarly named,


00:26:09.660 --> 00:26:13.020
but they have an appendix that's different.


00:26:13.020 --> 00:26:15.260
so that if you have different data, you pass it.


00:26:15.260 --> 00:26:17.660
And I'm with you, Michael, I'd rather have people go,


00:26:17.660 --> 00:26:19.180
well, which one do I need?


00:26:19.180 --> 00:26:22.940
I'll look it up, then just passing the wrong data type


00:26:22.940 --> 00:26:25.860
and having me, because sometimes


00:26:25.860 --> 00:26:27.600
if they haven't converted the data,


00:26:27.600 --> 00:26:31.380
like string versus number is a scary one for me


00:26:31.380 --> 00:26:33.860
because I'm often getting my numbers


00:26:33.860 --> 00:26:38.020
from an API or something, and they come in as a string


00:26:38.020 --> 00:26:39.420
if you forgot to convert it


00:26:39.420 --> 00:26:41.120
and you passed it to the wrong thing,


00:26:41.120 --> 00:26:43.680
and you're really doing something completely different.


00:26:43.680 --> 00:26:45.600
That's not a good thing.


00:26:45.600 --> 00:26:47.640
- I got bit by that one just yesterday,


00:26:47.640 --> 00:26:51.840
updating one of my CI builds to use Python 3.1,


00:26:51.840 --> 00:26:52.860
I mean 3.10.


00:26:52.860 --> 00:26:54.680
(laughing)


00:26:54.680 --> 00:26:55.520
- Exactly.


00:26:55.520 --> 00:26:57.140
- Is it a string or is it a number?


00:26:57.140 --> 00:26:59.000
(laughing)


00:26:59.000 --> 00:27:00.080
- Interesting, yeah.


00:27:00.080 --> 00:27:05.120
- But yeah, certainly that conversion would be worrying.


00:27:05.120 --> 00:27:07.680
The other one is, is it a string or is it a list of strings?


00:27:07.680 --> 00:27:10.000
And that's the one that bites us in Python all the time.


00:27:10.000 --> 00:27:13.680
and I don't even know how you resolve an overloaded function


00:27:13.680 --> 00:27:17.640
based on, is it a string or can I iterate it?


00:27:17.640 --> 00:27:19.040
- Well, like in that case, actually,


00:27:19.040 --> 00:27:21.600
I would rather just have that part be part of the function.


00:27:21.600 --> 00:27:23.920
At the top of it, if it can handle both,


00:27:23.920 --> 00:27:28.880
to check the type and iterate or not, but you know.


00:27:28.880 --> 00:27:30.520
- Yeah, well, all right, let me close this out


00:27:30.520 --> 00:27:32.720
with two quick thoughts.


00:27:32.720 --> 00:27:34.840
First, I think this is interesting


00:27:34.840 --> 00:27:37.560
because it's one of the things that's possible


00:27:37.560 --> 00:27:38.680
with modern Python.


00:27:38.680 --> 00:27:40.000
Like once we've added typing,


00:27:40.000 --> 00:27:41.840
now you could consider this as a thing,


00:27:41.840 --> 00:27:45.640
whereas previously it really was highly impractical,


00:27:45.640 --> 00:27:48.320
I think, as a way to do it.


00:27:48.320 --> 00:27:49.520
So I think that's kind of cool.


00:27:49.520 --> 00:27:52.240
And then two, I think it might be an entryway


00:27:52.240 --> 00:27:53.760
for people who are not where Brian,


00:27:53.760 --> 00:27:55.600
and I'll put myself in there as well,


00:27:55.600 --> 00:27:57.400
yet of going like, actually,


00:27:57.400 --> 00:27:59.480
these things I thought I need, I don't need those, right?


00:27:59.480 --> 00:28:00.840
There's a lot of stuff I thought I needed


00:28:00.840 --> 00:28:02.560
and I haven't used it for three years,


00:28:02.560 --> 00:28:03.980
so maybe I actually don't need it.


00:28:03.980 --> 00:28:06.640
But that's not how you maybe first approach


00:28:06.640 --> 00:28:08.560
solving your first problem in Python,


00:28:08.560 --> 00:28:11.800
that you're coming from C++ or whatever, C#, whatever,


00:28:11.800 --> 00:28:13.720
this might be a gateway.


00:28:13.720 --> 00:28:15.480
So anyway, those are my two thoughts.


00:28:15.480 --> 00:28:18.720
- One more thought from Dean after Python 3.11,


00:28:18.720 --> 00:28:20.280
do we get Python 95?


00:28:20.280 --> 00:28:22.080
(laughing)


00:28:22.080 --> 00:28:24.960
- There was a Windows 3.12.


00:28:24.960 --> 00:28:27.600
So I think Python gets to do a 3.12 as well.


00:28:27.600 --> 00:28:28.440
(laughing)


00:28:28.440 --> 00:28:29.280
- 3.12.


00:28:29.280 --> 00:28:32.560
- I think it was only available in China.


00:28:32.560 --> 00:28:33.400
- Interesting.


00:28:33.400 --> 00:28:35.560
- And I believe, I like to follow on with that, Dean,


00:28:35.560 --> 00:28:36.800
very funny.


00:28:36.800 --> 00:28:40.760
I believe that Windows 10 was named--


00:28:40.760 --> 00:28:42.920
you let me know if you know a difference, Steve.


00:28:42.920 --> 00:28:44.760
Windows 10 was named Windows 10 because there


00:28:44.760 --> 00:28:47.800
used to be the check Windows 9 as the starting


00:28:47.800 --> 00:28:49.480
string for 95 and 98.


00:28:49.480 --> 00:28:51.880
So you can't be 9 because then you're going to be 95.


00:28:51.880 --> 00:28:53.200
So we got to kick on past it.


00:28:53.200 --> 00:28:54.580
It's kind of like your 310 thing.


00:28:54.580 --> 00:28:58.600
There was some embarrassingly big language run times


00:28:58.600 --> 00:29:03.000
out there still doing that check that really struggled


00:29:03.000 --> 00:29:07.480
with Windows 9 and showed up in enough places


00:29:07.480 --> 00:29:11.400
that, yeah, I think it just made sense for everyone


00:29:11.400 --> 00:29:14.520
to just skip it.


00:29:14.520 --> 00:29:15.440
Not skipping 13.


00:29:15.440 --> 00:29:16.200
We're skipping 9.


00:29:16.200 --> 00:29:17.000
It's too unlucky.


00:29:17.000 --> 00:29:17.680
All right.


00:29:17.680 --> 00:29:18.180
Awesome.


00:29:18.180 --> 00:29:19.360
Brian, what you got for us?


00:29:19.360 --> 00:29:20.480
Oh, what do I have next?


00:29:20.480 --> 00:29:24.960
I have the next generation Seaborn interface.


00:29:24.960 --> 00:29:29.520
So Seaborn is a really awesome plotting library


00:29:29.520 --> 00:29:31.520
built on Matplotlib.


00:29:31.520 --> 00:29:34.360
And I, you know, actually I don't use it that much,


00:29:34.360 --> 00:29:36.360
but I've always been intrigued by it


00:29:36.360 --> 00:29:39.560
and kind of watching what plotting libraries do and stuff.


00:29:39.560 --> 00:29:41.440
And one of the things I was curious about,


00:29:41.440 --> 00:29:44.320
which I'm really grateful for this article,


00:29:44.320 --> 00:29:46.080
is some of the history behind it.


00:29:46.080 --> 00:29:48.000
So the article starts off,


00:29:48.000 --> 00:29:50.240
next generation Seaboard interface,


00:29:50.240 --> 00:29:52.760
talks about the background and goals,


00:29:52.760 --> 00:29:56.000
but some of the great things in here,


00:29:56.000 --> 00:29:57.900
let me grab some notes.


00:29:57.900 --> 00:30:00.760
This work grew out of a long running effort


00:30:00.760 --> 00:30:05.240
to refactor Seaborn internals, so that functions,


00:30:05.240 --> 00:30:08.120
you know, anyway, where I wanted to get at


00:30:08.120 --> 00:30:10.240
was he was developing a refactor of the internals.


00:30:10.240 --> 00:30:11.440
And he's like, wait, wait a second,


00:30:11.440 --> 00:30:12.400
if I want to refactor it,


00:30:12.400 --> 00:30:14.480
maybe I should expose more stuff.


00:30:14.480 --> 00:30:18.440
And some of the background was Seaborn


00:30:18.440 --> 00:30:20.720
was originally conceived of as a toolbox


00:30:20.720 --> 00:30:25.040
to do of domain-specific statistical graphics


00:30:25.040 --> 00:30:27.040
to be used alongside Matplotlib.


00:30:27.040 --> 00:30:29.200
So the intent was people would use both Seaborn


00:30:29.200 --> 00:30:30.640
and Matplotlib together.


00:30:30.640 --> 00:30:34.480
However, things that people are doing things differently.


00:30:34.480 --> 00:30:36.860
A lot of people just grab Seaborn by itself.


00:30:36.860 --> 00:30:38.800
Some people even just learn Seaborn


00:30:38.800 --> 00:30:40.760
before they even learn Matplotlib,


00:30:40.760 --> 00:30:42.400
which is an interesting thing.


00:30:42.400 --> 00:30:45.200
And that's how I thought you were supposed to be doing this.


00:30:45.200 --> 00:30:48.580
But the concept was, and then over time,


00:30:48.580 --> 00:30:49.700
there's a whole bunch of features


00:30:49.700 --> 00:30:50.920
that have been added to Seaborn


00:30:50.920 --> 00:30:53.280
to where it's like really slick looking,


00:30:53.280 --> 00:30:56.040
but to do the same thing by hand in Matplotlib


00:30:56.040 --> 00:30:57.080
is a lot of work.


00:30:57.080 --> 00:30:59.240
So there's some things that,


00:30:59.240 --> 00:31:02.000
Like if you see born is almost there,


00:31:02.000 --> 00:31:03.240
but you need to tweak it a little bit


00:31:03.240 --> 00:31:04.760
and you have to do things manually,


00:31:04.760 --> 00:31:06.860
well, then you have to just do everything by yourself


00:31:06.860 --> 00:31:07.980
and it's a lot of work.


00:31:07.980 --> 00:31:12.060
So the idea around this, a rewrite of the API


00:31:12.060 --> 00:31:14.700
is let's rework some of the internals


00:31:14.700 --> 00:31:17.040
so that a lot of the little sub components


00:31:17.040 --> 00:31:20.380
that go inside of a plot are exposed.


00:31:20.380 --> 00:31:22.540
That way people can get access to it


00:31:22.540 --> 00:31:26.940
to do a more fine tune configuration within the,


00:31:26.940 --> 00:31:28.900
so they don't really have to just do everything


00:31:28.900 --> 00:31:31.860
It's either all or nothing Seaborn or Matplotlib.


00:31:31.860 --> 00:31:34.020
You can kind of do both more easily,


00:31:34.020 --> 00:31:36.060
which is a kind of a cool idea.


00:31:36.060 --> 00:31:37.940
There's a whole bunch of great details in here


00:31:37.940 --> 00:31:40.380
that talk about some of the API changes.


00:31:40.380 --> 00:31:43.580
Basically, it's exposing the internal.


00:31:43.580 --> 00:31:45.260
If you create a plot, there's nothing there


00:31:45.260 --> 00:31:46.100
and it won't show up.


00:31:46.100 --> 00:31:48.060
You have to create layers on the plot.


00:31:48.060 --> 00:31:50.340
And then within the layers, you've got marks


00:31:50.340 --> 00:31:53.100
and different components that go into it.


00:31:53.100 --> 00:31:55.820
I kind of like this idea of building things up.


00:31:55.820 --> 00:31:58.620
But what I really like is the public aspect of this.


00:31:58.620 --> 00:32:01.760
You've got a library that's out in the open.


00:32:01.760 --> 00:32:04.140
It's being used by a lot of people already,


00:32:04.140 --> 00:32:06.360
and somebody's saying, "Maybe we should tweak


00:32:06.360 --> 00:32:08.020
the API and do something different."


00:32:08.020 --> 00:32:10.660
Just going ahead and doing that in the open saying,


00:32:10.660 --> 00:32:11.880
"Hey, we're going to do this.


00:32:11.880 --> 00:32:13.180
There's a note at the top,


00:32:13.180 --> 00:32:14.620
or I'm thinking about doing this,


00:32:14.620 --> 00:32:15.860
note at the top saying,


00:32:15.860 --> 00:32:17.140
it's a work in progress.


00:32:17.140 --> 00:32:20.220
Don't depend on these examples because things might change,


00:32:20.220 --> 00:32:22.800
but this is the direction we're trying to go,


00:32:22.800 --> 00:32:25.100
trying to get feedback from people."


00:32:25.100 --> 00:32:28.020
I think this is a lot of things that a lot of people


00:32:28.020 --> 00:32:30.340
struggle with when they're maintaining packages


00:32:30.340 --> 00:32:32.980
that have been around for a long time is,


00:32:32.980 --> 00:32:34.380
I wanna do things a little different,


00:32:34.380 --> 00:32:36.660
but am I gonna break everybody?


00:32:36.660 --> 00:32:37.980
And talking through it.


00:32:37.980 --> 00:32:40.060
So anyway, this is a great read,


00:32:40.060 --> 00:32:43.380
especially if you're a data plotting kind of person.


00:32:43.380 --> 00:32:44.220
- Yeah, very nice.


00:32:44.220 --> 00:32:46.340
I always wanna do more with visualization,


00:32:46.340 --> 00:32:48.780
and I'm sure that I have some good data I could pull up.


00:32:48.780 --> 00:32:49.620
- Yeah.


00:32:49.620 --> 00:32:51.180
- I end up basically just writing APIs


00:32:51.180 --> 00:32:52.700
on websites these days.


00:32:52.700 --> 00:32:54.660
But I really should be pulling this up


00:32:54.660 --> 00:32:55.760
and doing some of these graphs,


00:32:55.760 --> 00:32:58.180
And I'm really happy these are around.


00:32:58.180 --> 00:32:59.260
Steve, how about you?


00:32:59.260 --> 00:33:00.320
- See, Seaborn's great.


00:33:00.320 --> 00:33:04.000
It's always, like, back when I first discovered it,


00:33:04.000 --> 00:33:07.600
one of its major selling points was simply importing Seaborn


00:33:07.600 --> 00:33:09.320
would magically make your default


00:33:09.320 --> 00:33:11.140
Matplotlib charts look nicer.


00:33:11.140 --> 00:33:13.600
Which Matplotlib is--


00:33:13.600 --> 00:33:15.920
- I love it, it's like the bootstrap of Matplotlib.


00:33:15.920 --> 00:33:16.760
- It really was.


00:33:16.760 --> 00:33:19.760
It's like they just apply their style by default


00:33:19.760 --> 00:33:22.680
and every Matplotlib chart suddenly look nicer.


00:33:22.680 --> 00:33:24.840
Which, you know, Matplotlib's done their own


00:33:24.840 --> 00:33:28.200
styling work now, so it's less valuable for that.


00:33:28.200 --> 00:33:30.120
I do like this API.


00:33:30.120 --> 00:33:30.760
It looks good.


00:33:30.760 --> 00:33:32.880
And as Dean's pointing out in chat,


00:33:32.880 --> 00:33:35.720
it's like, Matplotlib has an object-oriented plotting API


00:33:35.720 --> 00:33:37.800
similar to this, possibly identical,


00:33:37.800 --> 00:33:38.920
just like everyone else.


00:33:38.920 --> 00:33:42.440
I've never learned the object-oriented API.


00:33:42.440 --> 00:33:43.120
But it is there.


00:33:43.120 --> 00:33:47.000
And that's the modern one.


00:33:47.000 --> 00:33:48.640
I know a lot of people say Matplotlib


00:33:48.640 --> 00:33:51.840
is impenetrable and kind of hard to build things up.


00:33:51.840 --> 00:33:53.720
But it does have a really nice API there.


00:33:53.720 --> 00:33:57.640
It's just not the PiPlot one that kind of imitates


00:33:57.640 --> 00:34:00.760
MATLAB's old API.


00:34:00.760 --> 00:34:03.880
And so having it there is really nice.


00:34:03.880 --> 00:34:07.440
And Seaborn, having their own is also great.


00:34:07.440 --> 00:34:10.480
Another nice thing to read about in this


00:34:10.480 --> 00:34:18.080
is he does a hat tip to ggplot2 or whatever it's called,


00:34:18.080 --> 00:34:21.080
saying that, yes, it's going to look--


00:34:21.080 --> 00:34:23.600
a lot of this is similar to ggplot.


00:34:23.600 --> 00:34:26.040
but it isn't that I'm trying to copy it


00:34:26.040 --> 00:34:29.000
or maybe that's definitely influence,


00:34:29.000 --> 00:34:33.520
but it is that Seaborn is important


00:34:33.520 --> 00:34:36.320
because we think about things differently in Python


00:34:36.320 --> 00:34:37.760
than we do in R.


00:34:37.760 --> 00:34:41.600
And just having, it would be,


00:34:41.600 --> 00:34:43.640
but also a hat tip to another library


00:34:43.640 --> 00:34:45.840
that is a wrapper around ggplot.


00:34:45.840 --> 00:34:48.480
If you just want that, you can do that in Python too,


00:34:48.480 --> 00:34:49.320
that's available.


00:34:49.320 --> 00:34:52.520
So it is interesting to,


00:34:52.520 --> 00:34:54.320
We think of these as competing libraries,


00:34:54.320 --> 00:34:56.120
but they're really not competing with each other.


00:34:56.120 --> 00:34:59.760
They're working together to push the push plotting forward.


00:34:59.760 --> 00:35:01.100
- So yeah, nice.


00:35:01.100 --> 00:35:05.560
Dean out there points out you can do plot.style.useSeaborne


00:35:05.560 --> 00:35:07.400
or ggplot, which is another.


00:35:07.400 --> 00:35:08.920
- You can use ggplot.


00:35:08.920 --> 00:35:10.280
- Let me throw out, oh yeah, go ahead, Steve.


00:35:10.280 --> 00:35:12.200
- ggplot's certainly the one to copy from.


00:35:12.200 --> 00:35:15.480
I mean, there's a reason that one is


00:35:15.480 --> 00:35:19.340
as universally popular as any plotting library


00:35:19.340 --> 00:35:21.040
can possibly be.


00:35:21.040 --> 00:35:26.000
It's probably competing with Excel for popularity


00:35:26.000 --> 00:35:27.680
of plotting data, realistically.


00:35:27.680 --> 00:35:30.640
It's a really nice API, and it looks good,


00:35:30.640 --> 00:35:32.360
and everyone's familiar with it.


00:35:32.360 --> 00:35:35.560
And so there's nothing wrong with copying from ggplot.


00:35:35.560 --> 00:35:36.320
MARK MANDEL: Nice.


00:35:36.320 --> 00:35:39.560
I got one more shout out to throw into this conversation.


00:35:39.560 --> 00:35:43.880
The XKCD plotting style for Matplotlib.


00:35:43.880 --> 00:35:45.080
So you've got--


00:35:45.080 --> 00:35:46.920
I mean, this is fantastic.


00:35:46.920 --> 00:35:48.920
It looks like the--


00:35:48.920 --> 00:35:52.440
It really does look like XKCD would,


00:35:52.440 --> 00:35:55.040
you know, the comic would do for these.


00:35:55.040 --> 00:35:57.440
So this is fantastic, I love it.


00:35:57.440 --> 00:35:59.040
- What I love is I actually see this.


00:35:59.040 --> 00:36:00.840
I see this in papers and stuff like that.


00:36:00.840 --> 00:36:03.360
People just go ahead and use the XKCD style


00:36:03.360 --> 00:36:05.000
and for serious stuff.


00:36:05.000 --> 00:36:06.680
And it just is, it's awesome.


00:36:06.680 --> 00:36:07.520
I love it.


00:36:07.520 --> 00:36:08.840
- I think there's actually some value


00:36:08.840 --> 00:36:11.120
to having like cartoony looking graphics,


00:36:11.120 --> 00:36:13.160
like UI sketches and graphs to say like,


00:36:13.160 --> 00:36:14.520
look, this is speculative.


00:36:14.520 --> 00:36:16.880
This is just like, don't read too much into it.


00:36:16.880 --> 00:36:17.900
I'm trying to give you an idea


00:36:17.900 --> 00:36:19.780
rather than an exact thing.


00:36:19.780 --> 00:36:22.940
And I think sort of UI, like cartoony looking sketches


00:36:22.940 --> 00:36:25.220
and this also plays into that.


00:36:25.220 --> 00:36:26.060
- Yeah.


00:36:26.060 --> 00:36:27.580
- Right, Steve, you got the last one?


00:36:27.580 --> 00:36:28.620
- I got the last one, yeah.


00:36:28.620 --> 00:36:31.580
So this is another kind of recent delivery


00:36:31.580 --> 00:36:34.100
from the CPython core team.


00:36:34.100 --> 00:36:37.180
We can now compile CPython to WebAssembly.


00:36:37.180 --> 00:36:38.460
- Wow.


00:36:38.460 --> 00:36:41.260
- And to a lot of people, that probably means very little.


00:36:41.260 --> 00:36:44.980
But I guess the brief, brief summary is WebAssembly


00:36:44.980 --> 00:36:48.740
is kind of what the JavaScript in your browser


00:36:48.740 --> 00:36:50.580
compiles to before it runs.


00:36:50.580 --> 00:36:53.540
So it's skipped that initial step of being JavaScript,


00:36:53.540 --> 00:36:56.380
and it's now ready to run in the browser.


00:36:56.380 --> 00:36:58.580
So it's a lower level.


00:36:58.580 --> 00:37:00.060
There are tool chains out there that


00:37:00.060 --> 00:37:01.940
can compile all sorts of languages


00:37:01.940 --> 00:37:03.700
directly to WebAssembly.


00:37:03.700 --> 00:37:05.500
And so in this case, we've taken--


00:37:05.500 --> 00:37:08.900
I believe we use one of the--


00:37:08.900 --> 00:37:11.020
I don't know the exact tool chain that's used,


00:37:11.020 --> 00:37:11.940
and it may not matter.


00:37:11.940 --> 00:37:13.560
But it basically takes the C code


00:37:13.560 --> 00:37:15.440
and compiles that to WebAssembly,


00:37:15.440 --> 00:37:19.520
gives you a package that can be brought into an Electron app


00:37:19.520 --> 00:37:22.000
or a Node.js app or a web browser,


00:37:22.000 --> 00:37:25.360
modern web browser, and be run in the browser.


00:37:25.360 --> 00:37:28.480
There is, so this page is a little bit dated.


00:37:28.480 --> 00:37:29.720
There's been a bit more work since then,


00:37:29.720 --> 00:37:31.280
but I found this is the best overview


00:37:31.280 --> 00:37:32.760
of where things are kind of at.


00:37:32.760 --> 00:37:34.720
Long list of C extensions that don't work.


00:37:34.720 --> 00:37:37.720
Probably unsurprising, like the browser doesn't have


00:37:37.720 --> 00:37:39.000
a lot of this stuff in it.


00:37:39.000 --> 00:37:42.560
- Yeah, you don't have all the different APIs,


00:37:42.560 --> 00:37:45.560
the Win32 API underneath or whatever it was delegating to.


00:37:45.560 --> 00:37:46.060
Yeah.


00:37:46.060 --> 00:37:47.360
No TK enter?


00:37:47.360 --> 00:37:49.400
What?


00:37:49.400 --> 00:37:52.440
Yeah, no TK enter, no subprocess.


00:37:52.440 --> 00:37:53.880
C types, apparently, you can do.


00:37:53.880 --> 00:37:59.000
I've heard there is a libffi port to the Emscripten


00:37:59.000 --> 00:38:00.880
kind of platform.


00:38:00.880 --> 00:38:05.440
So how this kind of works is when


00:38:05.440 --> 00:38:07.680
you take WebAssembly into a browser,


00:38:07.680 --> 00:38:09.080
it has access to nothing.


00:38:09.080 --> 00:38:12.200
It starts off in a really enclosed kind of box of things


00:38:12.200 --> 00:38:13.520
that it can do.


00:38:13.520 --> 00:38:15.560
And that doesn't actually work for Python at all,


00:38:15.560 --> 00:38:17.760
because the very only thing that it tries to do


00:38:17.760 --> 00:38:19.840
is search the file system for what


00:38:19.840 --> 00:38:22.640
files it should be loading.


00:38:22.640 --> 00:38:25.680
So we actually build it as part of another platform.


00:38:25.680 --> 00:38:30.320
Emscripten is one platform that kind of polyfills


00:38:30.320 --> 00:38:32.840
a whole lot of native-looking APIs


00:38:32.840 --> 00:38:35.320
so that code that's compiled on top of Emscripten


00:38:35.320 --> 00:38:36.840
is able to use it.


00:38:36.840 --> 00:38:40.360
And this little demo, which I just hit Start,


00:38:40.360 --> 00:38:42.440
REPL. This is running on that.


00:38:42.440 --> 00:38:44.520
So this is a build of Python 3.11,


00:38:44.520 --> 00:38:48.520
Alpha 4 built with Clang running on Emscripten.


00:38:48.520 --> 00:38:51.600
And I can, I believe I can do this,


00:38:51.600 --> 00:38:53.400
do like OSLister.


00:38:53.400 --> 00:38:54.960
And it thinks there's a file system there.


00:38:54.960 --> 00:38:56.200
Now that's not my file system.


00:38:56.200 --> 00:38:57.760
That's in memory.


00:38:57.760 --> 00:38:59.960
It can be changed to browser storage,


00:38:59.960 --> 00:39:01.400
but this is entirely in the browser.


00:39:01.400 --> 00:39:02.680
Like there's nothing downloaded.


00:39:02.680 --> 00:39:04.400
There's nothing running on my machine here.


00:39:04.400 --> 00:39:06.080
There's nothing running in the cloud.


00:39:06.080 --> 00:39:07.080
It's literally in the browser.


00:39:07.080 --> 00:39:09.120
I can probably freeze my browser with this.


00:39:09.120 --> 00:39:10.700
Like I can do an infinite loop.


00:39:10.700 --> 00:39:11.560
>> Yeah, do it.


00:39:11.560 --> 00:39:14.780
>> Do it. Let's see if this cuts me off.


00:39:14.780 --> 00:39:16.660
I'll just let that run.


00:39:16.660 --> 00:39:18.340
>> Hit clear. What happens if you hit clear?


00:39:18.340 --> 00:39:20.020
>> [LAUGHTER]


00:39:20.020 --> 00:39:20.820
>> Started again?


00:39:20.820 --> 00:39:21.260
>> No.


00:39:21.260 --> 00:39:22.140
>> We're going to start again?


00:39:22.140 --> 00:39:22.420
>> No.


00:39:22.420 --> 00:39:23.540
>> No, it's done.


00:39:23.540 --> 00:39:25.780
>> I'll refresh.


00:39:25.780 --> 00:39:30.340
There's a second one that


00:39:30.340 --> 00:39:32.820
the actual build as it was committed support,


00:39:32.820 --> 00:39:35.420
which is WASI, W-A-S-I.


00:39:35.420 --> 00:39:37.420
That's a slightly different approach to adding


00:39:37.420 --> 00:39:41.500
all the functionality around a WebAssembly module.


00:39:41.500 --> 00:39:44.420
It's a little bit more flexible, a little bit more controlled.


00:39:44.420 --> 00:39:46.860
Emscripten is really like, give me


00:39:46.860 --> 00:39:51.140
POSIX system inside my browser, all in memory.


00:39:51.140 --> 00:39:52.780
And so we have two options.


00:39:52.780 --> 00:39:57.660
And these are available in the main branch.


00:39:57.660 --> 00:40:00.140
At the moment, we're not shipping pre-built modules


00:40:00.140 --> 00:40:01.260
for WebAssembly.


00:40:01.260 --> 00:40:02.920
That might be a possibility.


00:40:02.920 --> 00:40:05.380
If that's something that you'd like to see, then I guess


00:40:05.380 --> 00:40:08.260
go to discuss.python.org and post about it.


00:40:08.260 --> 00:40:09.380
It's probably a post there.


00:40:09.380 --> 00:40:11.460
I should've looked for a post there.


00:40:11.460 --> 00:40:15.500
But we're not currently doing pre-built releases.


00:40:15.500 --> 00:40:16.660
But I think we could.


00:40:16.660 --> 00:40:19.540
I think this is one of these options where the WebAssembly


00:40:19.540 --> 00:40:21.460
build is totally portable.


00:40:21.460 --> 00:40:24.220
And so if we build it, we can distribute it.


00:40:24.220 --> 00:40:26.980
And then websites that want to do something like this


00:40:26.980 --> 00:40:29.940
could just download it from our servers and run it.


00:40:29.940 --> 00:40:32.340
So I think there's a lot of potential here.


00:40:34.900 --> 00:40:36.800
And it's at the potential stage, right?


00:40:36.800 --> 00:40:40.980
This is another stepping stone to bigger and better things.


00:40:40.980 --> 00:40:43.800
Our kind of responsibility as the core team is to enable it.


00:40:43.800 --> 00:40:46.340
And now we really want people to come in and pick this up


00:40:46.340 --> 00:40:48.100
and do awesome things with it.


00:40:48.100 --> 00:40:49.940
Firstly, so we can figure out what gaps still


00:40:49.940 --> 00:40:53.380
need to be filled, but also just to expand


00:40:53.380 --> 00:40:54.940
the growth in the reach of Python,


00:40:54.940 --> 00:40:57.740
to bring it into places that currently doesn't exist


00:40:57.740 --> 00:41:02.140
or can't work, and give it new life and new places,


00:41:02.140 --> 00:41:03.380
open it up to new people.


00:41:03.380 --> 00:41:05.220
This is fantastic.


00:41:05.220 --> 00:41:06.300
Congratulations.


00:41:06.300 --> 00:41:09.060
- And so the work for this primarily done


00:41:09.060 --> 00:41:12.220
by Katie Bell, Christian Himes, and Ethan Smith.


00:41:12.220 --> 00:41:15.140
So I think Christian got to do all the merge commits,


00:41:15.140 --> 00:41:17.220
but it's definitely been a number of people


00:41:17.220 --> 00:41:18.820
working on this for a while.


00:41:18.820 --> 00:41:22.200
Those are the primary three.


00:41:22.200 --> 00:41:24.500
- I'm really excited for the possibility for this.


00:41:24.500 --> 00:41:27.400
I think one of the things that could be amazing,


00:41:27.400 --> 00:41:29.660
obviously running it in the front end


00:41:29.660 --> 00:41:31.500
is a thing that could be done.


00:41:31.500 --> 00:41:34.200
I saw the documentation said it was about 10 megs


00:41:34.200 --> 00:41:35.140
to download it.


00:41:35.140 --> 00:41:37.460
I'm sure you can put that on like a CDN.


00:41:37.460 --> 00:41:39.620
So you kind of hit it once somewhere


00:41:39.620 --> 00:41:41.480
for a particular version of Python.


00:41:41.480 --> 00:41:42.380
That's pretty good.


00:41:42.380 --> 00:41:44.740
You know, we all have pretty fast things these days.


00:41:44.740 --> 00:41:46.580
- Yeah, it's still bigger than Doodle.


00:41:46.580 --> 00:41:48.180
- Yeah.


00:41:48.180 --> 00:41:49.640
What gets me really excited though


00:41:49.640 --> 00:41:52.760
is putting that into an ElectronJS app.


00:41:52.760 --> 00:41:53.600
- Yeah, absolutely.


00:41:53.600 --> 00:41:54.420
- Right?


00:41:54.420 --> 00:41:56.760
Because ElectronJS is a really interesting way


00:41:56.760 --> 00:41:59.320
to bring web technologies across platform.


00:41:59.320 --> 00:42:02.280
As much as I'm like, oh, it's an Electron app.


00:42:02.280 --> 00:42:05.080
Still, it's really opened up the possibility


00:42:05.080 --> 00:42:05.920
for a lot of things.


00:42:05.920 --> 00:42:07.960
But it really has meant, OK, you're doing TypeScript,


00:42:07.960 --> 00:42:09.600
you're doing JavaScript, and you just


00:42:09.600 --> 00:42:11.000
have to go full on in that world.


00:42:11.000 --> 00:42:14.240
So here, you could still do your front end and whatever.


00:42:14.240 --> 00:42:17.840
But having the core logic of that desktop app being


00:42:17.840 --> 00:42:19.880
in Python running in this, that's


00:42:19.880 --> 00:42:22.000
exciting if that can be put together.


00:42:22.000 --> 00:42:23.720
- I should also add two things.


00:42:23.720 --> 00:42:26.560
Pyodide is a project that people have probably


00:42:26.560 --> 00:42:28.460
heard of before, which has been working


00:42:28.460 --> 00:42:30.860
this for considerably longer than the core team has.


00:42:30.860 --> 00:42:34.380
And so I think a lot of the patches that needed to happen have come from them.


00:42:34.380 --> 00:42:39.420
And they now get to spend more time focusing on the data science stack,


00:42:39.420 --> 00:42:43.060
which because they've got ports of NumPy and pandas and other libraries


00:42:43.060 --> 00:42:46.140
to actually do data science in the browser.


00:42:46.140 --> 00:42:50.620
And the other interesting thing that I saw was someone from from Condor


00:42:50.620 --> 00:42:54.540
Forge suggesting that they could elevate was wasn't builds to


00:42:54.540 --> 00:42:56.700
their kind of automated level.


00:42:56.700 --> 00:43:03.960
And so all of conda forge may suddenly become available to use in the browser on top of a build of Python like this.


00:43:03.960 --> 00:43:04.560
Wow.


00:43:04.560 --> 00:43:07.600
That would unlock so much. That would be incredible.


00:43:07.600 --> 00:43:08.880
Interesting.


00:43:08.880 --> 00:43:11.600
I imagine initially would unlock a lot of bug reports.


00:43:11.600 --> 00:43:14.960
But we need to work through those first.


00:43:14.960 --> 00:43:19.440
Yeah, I was just thinking of, you know, take the top 1000 most popular packages.


00:43:19.440 --> 00:43:22.280
Could you get 90% of those compiled to like


00:43:22.280 --> 00:43:24.280
other WebAssembly things that then could be


00:43:24.280 --> 00:43:26.280
included and then imported here


00:43:26.280 --> 00:43:27.680
somehow. - Exactly.


00:43:27.680 --> 00:43:29.920
And the top 1000 with native code,


00:43:29.920 --> 00:43:32.480
because it's only the native code, right? The Python code


00:43:32.480 --> 00:43:36.640
still compiles in the browser just like it would in the CPython interpreter.


00:43:36.640 --> 00:43:39.320
It's only the native code that has to be


00:43:39.320 --> 00:43:40.320
ported and built.


00:43:40.320 --> 00:43:42.840
And so once that's done, then


00:43:42.840 --> 00:43:45.240
you know, we're up and running. So the top 1000 is


00:43:45.240 --> 00:43:47.960
probably more than you need. - Yeah, absolutely.


00:43:47.960 --> 00:43:48.360
All right.


00:43:48.360 --> 00:43:48.800
Awesome.


00:43:48.800 --> 00:43:50.680
I'm looking forward to seeing where this goes.


00:43:50.680 --> 00:43:52.440
So many neat options.


00:43:52.440 --> 00:43:57.000
There's, there's just cool ways to say like ship the Python runtime, the places


00:43:57.000 --> 00:43:58.880
where maybe it would have been hard to get.


00:43:58.880 --> 00:44:02.640
Now you drop this WASM file plus something that can run WASM.


00:44:02.640 --> 00:44:07.160
And then now you've got a deployable shippable CPython runtime without TK


00:44:07.160 --> 00:44:09.640
enter and a few things, but still you might not miss it.


00:44:09.640 --> 00:44:11.840
Depending on what you're doing.


00:44:11.840 --> 00:44:14.760
I mean, most apps are not TK enter apps is all I'm saying.


00:44:14.760 --> 00:44:15.840
I'm not trying to bang on it.


00:44:15.840 --> 00:44:16.880
No, no.


00:44:16.920 --> 00:44:20.520
But I just haven't every time it comes up that it's still there.


00:44:20.520 --> 00:44:22.720
I'm like, really? We still have that. OK.


00:44:22.720 --> 00:44:26.420
Don't ask me what I've been spending my week working on.


00:44:26.420 --> 00:44:29.820
Brian, it's not going to make you happy.


00:44:29.820 --> 00:44:33.720
Are you are you creating a TK enter base killer for against textual?


00:44:33.720 --> 00:44:38.420
No, no, unfortunately not.


00:44:38.420 --> 00:44:42.080
Awesome. All right.


00:44:42.080 --> 00:44:43.980
Well, Brian, are we at extras?


00:44:43.980 --> 00:44:45.560
We are at extras.


00:44:45.560 --> 00:44:46.600
Do you want to kick us off?


00:44:46.600 --> 00:44:47.680
I will kick us off.


00:44:47.680 --> 00:44:51.160
So I've got a couple of things that I think are interesting.


00:44:51.160 --> 00:44:52.120
Let's start with this one.


00:44:52.120 --> 00:44:56.280
We've talked about, Oh, Oh, my Z shell.


00:44:56.280 --> 00:44:56.880
Right.


00:44:56.880 --> 00:44:57.260
Yeah.


00:44:57.260 --> 00:44:57.680
A lot.


00:44:57.680 --> 00:44:58.320
Love it.


00:44:58.320 --> 00:45:03.560
I just came across, realizing that actually this is a Portland company that


00:45:03.560 --> 00:45:09.040
puts together the sort of core maintainers of, that, so I just thought it was


00:45:09.040 --> 00:45:12.160
funny to give a quick shout out to, play to Argon.


00:45:12.160 --> 00:45:15.240
They're not really in the Python space, but they're in Portland, which I thought


00:45:15.240 --> 00:45:16.600
That was kind of fun.


00:45:16.600 --> 00:45:18.180
And then, what is this?


00:45:18.180 --> 00:45:22.360
This next one comes to us, I think, via PyCoders.


00:45:22.360 --> 00:45:24.100
That's where I got this.


00:45:24.100 --> 00:45:27.960
Django just reformatted all of Django with black.


00:45:27.960 --> 00:45:29.780
I know I was just having a discussion with somebody like,


00:45:29.780 --> 00:45:32.840
oh, your code doesn't have, doesn't follow pep8.


00:45:32.840 --> 00:45:34.200
Or like, oh, I don't want it to follow pep8.


00:45:34.200 --> 00:45:36.760
Yeah, but if people are gonna use your code,


00:45:36.760 --> 00:45:38.480
you know, like literally you gotta import it,


00:45:38.480 --> 00:45:39.920
then it probably should follow,


00:45:39.920 --> 00:45:41.760
like it should not come up with all sorts of warnings.


00:45:41.760 --> 00:45:42.880
And so I thought it was interesting


00:45:42.880 --> 00:45:45.660
that Django just said, everything, make it black.


00:45:45.660 --> 00:45:48.060
Steve, what do you think about that?


00:45:48.060 --> 00:45:51.980
- I'm totally on board with just using black on everything.


00:45:51.980 --> 00:45:54.340
I don't agree 100% with the style,


00:45:54.340 --> 00:45:56.480
but I agree 100% with not arguing about it.


00:45:56.480 --> 00:45:59.460
So, it's close enough. - Exactly.


00:45:59.460 --> 00:46:00.900
Yeah. - It's close enough.


00:46:00.900 --> 00:46:04.580
- Yeah, plus there's enough tweaks that make it good.


00:46:04.580 --> 00:46:08.740
I'm really grateful that you can tweak the line length,


00:46:08.740 --> 00:46:10.300
for instance. - Yes.


00:46:10.300 --> 00:46:12.300
- Because, I mean, here's an example.


00:46:12.300 --> 00:46:13.600
What if I want it really short?


00:46:13.600 --> 00:46:18.140
So for, no, seriously, for formatting the code


00:46:18.140 --> 00:46:22.320
for the pytest book, I wanted them all quite a bit shorter


00:46:22.320 --> 00:46:25.100
so that they fit better in a book format.


00:46:25.100 --> 00:46:27.720
And I could use black to cover with that


00:46:27.720 --> 00:46:31.200
and convert everything with black to make them like that.


00:46:31.200 --> 00:46:32.440
So it was great.


00:46:32.440 --> 00:46:33.400
- Nice, awesome.


00:46:33.400 --> 00:46:36.240
All right, and the final one is I have been doing


00:46:36.240 --> 00:46:40.000
some stuff with more fun things on YouTube,


00:46:40.000 --> 00:46:41.520
trying to put these little short videos together.


00:46:41.520 --> 00:46:42.720
So here's a how long is it?


00:46:42.720 --> 00:46:46.360
Six minutes, 44 second video on using time delta


00:46:46.360 --> 00:46:49.640
to get like how many weeks are in some time span.


00:46:49.640 --> 00:46:51.480
You know, the cool tricks you can do there.


00:46:51.480 --> 00:46:52.880
So people should check that out.


00:46:52.880 --> 00:46:54.840
That's my latest Python short thing.


00:46:54.840 --> 00:46:57.780
And yeah, that's it for my extras.


00:46:57.780 --> 00:47:00.320
- Okay, so I've got a quick one.


00:47:00.320 --> 00:47:03.840
Just I've got, I don't have a graph, something to throw up,


00:47:03.840 --> 00:47:08.600
but I just, I was looking at the get history of a repo


00:47:08.600 --> 00:47:10.840
and trying to figure out whether I included


00:47:10.840 --> 00:47:13.120
one of my coworkers branches in it,


00:47:13.120 --> 00:47:15.600
if I merged it yet or not, things like that.


00:47:15.600 --> 00:47:17.600
And I was on the command line and I just learned,


00:47:17.600 --> 00:47:20.040
I'm like, can I just do this with the command line?


00:47:20.040 --> 00:47:22.000
Apparently I didn't know this exists.


00:47:22.000 --> 00:47:25.400
So apparently a get log dash dash graph


00:47:25.400 --> 00:47:27.900
just shows you the get graph,


00:47:27.900 --> 00:47:31.560
your branch history or the branch graph on the command line.


00:47:31.560 --> 00:47:33.820
And I didn't know it was there until today.


00:47:33.820 --> 00:47:36.680
I started using it, tweeted about it.


00:47:36.680 --> 00:47:39.080
And then a whole bunch of people said,


00:47:39.080 --> 00:47:40.720
oh, you should use these flags too.


00:47:40.720 --> 00:47:41.780
that makes it even nicer.


00:47:41.780 --> 00:47:46.780
So it's fun to learn something old as a new thing.


00:47:46.780 --> 00:47:50.300
And then somebody else told me, how about GitK?


00:47:50.300 --> 00:47:55.300
So GitK is a graphical browser of your repository


00:47:55.300 --> 00:48:00.300
that just comes with most Git installs


00:48:00.300 --> 00:48:01.600
that I didn't know was there.


00:48:01.600 --> 00:48:02.820
I'm like, do I need to install it?


00:48:02.820 --> 00:48:04.420
I'll just type it and see what happens.


00:48:04.420 --> 00:48:06.380
And it popped up this graphical interface.


00:48:06.380 --> 00:48:07.380
I'm like, this is great.


00:48:07.380 --> 00:48:09.060
This is exactly what I wanted.


00:48:09.060 --> 00:48:10.740
So, GitK is pretty cool.


00:48:10.740 --> 00:48:11.980
- I didn't know about that one.


00:48:11.980 --> 00:48:12.980
I've seen the command,


00:48:12.980 --> 00:48:14.980
I've never actually run it to see what happens.


00:48:14.980 --> 00:48:17.460
So, (laughs)


00:48:17.460 --> 00:48:19.260
was not feeling quite brave enough.


00:48:19.260 --> 00:48:21.040
(laughs)


00:48:21.040 --> 00:48:22.980
- Did it mean GitKill or was it something else?


00:48:22.980 --> 00:48:25.180
(laughs)


00:48:25.180 --> 00:48:26.620
- I was just most Git commands scare me


00:48:26.620 --> 00:48:29.220
until I've run them the first hundred times or so.


00:48:29.220 --> 00:48:30.060
- How about you?


00:48:30.060 --> 00:48:31.580
- Yeah, I got a couple of extras.


00:48:31.580 --> 00:48:33.980
Okay, can I get my screen back up there?


00:48:33.980 --> 00:48:36.080
There's, I was feeling a little bad about, you know,


00:48:36.080 --> 00:48:37.100
being a bit self-serving here,


00:48:37.100 --> 00:48:39.100
but then Michael just promoted his video series.


00:48:39.100 --> 00:48:40.380
So I don't feel too bad anymore.


00:48:40.380 --> 00:48:41.880
- Get it on man.


00:48:41.880 --> 00:48:44.980
- This is the Python 3.11 Alpha 5 download page.


00:48:44.980 --> 00:48:46.740
And we have a new addition this time round,


00:48:46.740 --> 00:48:49.540
which is this Windows Installer for ARM64.


00:48:49.540 --> 00:48:53.620
So ARM64 is not a massive, massive platform for Windows yet,


00:48:53.620 --> 00:48:57.300
but it's growing and we wanna have Python support on it.


00:48:57.300 --> 00:49:00.340
So the builds have been running in the background for a while


00:49:00.340 --> 00:49:01.580
but we've never actually released it.


00:49:01.580 --> 00:49:03.700
We're hoping to get it out with 3.11.


00:49:03.700 --> 00:49:07.380
that is going to depend largely on do people use it?


00:49:07.380 --> 00:49:09.700
Do they love it? Do they hate it?


00:49:09.700 --> 00:49:13.620
My experience so far with it has been that it is noticeably faster


00:49:13.620 --> 00:49:19.380
on at least on the arm 64 devices I've had access to compared to the Intel devices,


00:49:19.380 --> 00:49:22.540
which is really, really cool.


00:49:22.540 --> 00:49:26.980
And that's like the test suite is kind of 30 to 50 percent faster,


00:49:26.980 --> 00:49:30.300
which is huge, huge, really.


00:49:30.300 --> 00:49:31.940
So so I think there's a lot of potential here.


00:49:31.940 --> 00:49:33.340
I may just have had awesome hardware.


00:49:33.340 --> 00:49:35.800
I'm not sure it was a virtual machine, so it's kind of hard to tell.


00:49:35.800 --> 00:49:38.040
Yeah, but this is fantastic.


00:49:38.040 --> 00:49:39.240
This is new.


00:49:39.240 --> 00:49:42.200
If you have an arm 64 device like a Surface Pro X


00:49:42.200 --> 00:49:45.100
or there's a couple out there from other manufacturers.


00:49:45.100 --> 00:49:50.200
I'm running Windows 11 arm on my MacBook Pro through parallels.


00:49:50.200 --> 00:49:55.600
I then use please in download and install it and let let me know how it goes.


00:49:55.600 --> 00:49:59.240
If you get it through the Windows store, which is currently still not public,


00:49:59.240 --> 00:50:02.400
you need to get the the link from basically from one of my tweets


00:50:02.960 --> 00:50:07.520
to the Windows Store, you'll automatically get the ARM64 version on ARM64 as well.


00:50:07.520 --> 00:50:09.700
So this installer is the traditional one.


00:50:09.700 --> 00:50:12.700
Otherwise, you get it through the store.


00:50:12.700 --> 00:50:15.460
The other thing which I wasn't going to do, and then I spent a bit of time


00:50:15.460 --> 00:50:19.660
working on this a couple couple of years back at the


00:50:19.660 --> 00:50:22.100
at the Core Dev Sprints.


00:50:22.100 --> 00:50:23.300
I forget who I was chatting with.


00:50:23.300 --> 00:50:26.700
I was chatting with one of the other core devs about everyone typing


00:50:26.700 --> 00:50:30.100
from collections, import deck and misspelling it.


00:50:30.100 --> 00:50:34.000
And it's like you tell, you know, so a deck DQE is double ended queue,


00:50:34.000 --> 00:50:38.360
very useful data type for certain purposes, but people would type it deck,


00:50:38.360 --> 00:50:39.940
like deck as in DECK.


00:50:39.940 --> 00:50:41.880
Because it's phonetically what it sounds like.


00:50:41.880 --> 00:50:46.400
Exactly. And so as, as a bit of a joke, I made a package that when you,


00:50:46.400 --> 00:50:50.320
when you installed it, it would give you from collections import deck.


00:50:50.320 --> 00:50:53.720
and obviously the thing that that collection should be is a, a deck,


00:50:53.720 --> 00:50:58.040
a double ended queue of 52 cards representing the cards in a normal deck.


00:50:59.040 --> 00:51:01.300
And over time, for various reasons, it's just kind of grown.


00:51:01.300 --> 00:51:06.300
And and I recently, you know, added support for calculating poker hands to it.


00:51:06.300 --> 00:51:08.840
And so now you can build a game with this.


00:51:08.840 --> 00:51:10.580
It does. It uses enums.


00:51:10.580 --> 00:51:13.180
It's got shuffling, dealing.


00:51:13.180 --> 00:51:17.240
Jokers are optional and you can calculate a poker hand.


00:51:17.240 --> 00:51:22.440
And yeah, my little compare them poker hand one greater than poker hand to.


00:51:22.440 --> 00:51:24.840
I spent a lot of time.


00:51:24.840 --> 00:51:27.740
Most of my work on this over the last week was writing the tests


00:51:27.740 --> 00:51:31.020
that proved how incorrect that function was until I wrote the test for it.


00:51:31.020 --> 00:51:37.020
But now at this point, yeah, you can look at the values it gives back. It's actually a tuple


00:51:37.020 --> 00:51:42.940
with an enumeration saying what the hand is and then a selection of the card values in a way that


00:51:42.940 --> 00:51:49.180
makes the tuples comparable. So you can actually look and see, you know, it's a pair of aces that


00:51:49.180 --> 00:51:54.620
will have the number 14 there for the ace and the next highest card was a 10. So if someone else has


00:51:54.620 --> 00:51:56.820
has a pair of aces and their next highest card was a nine,


00:51:56.820 --> 00:51:58.020
then you're still going to compare higher.


00:51:58.020 --> 00:52:00.540
So I'm pretty proud of that function.


00:52:00.540 --> 00:52:01.700
>> Yeah, that's clever.


00:52:01.700 --> 00:52:04.700
>> But yeah, this is and it's code style block.


00:52:04.700 --> 00:52:07.140
>> Nice. Very nice.


00:52:07.140 --> 00:52:09.700
>> It's one short file.


00:52:09.700 --> 00:52:13.940
It does still override deck in the collections module for you.


00:52:13.940 --> 00:52:17.780
>> I love it.


00:52:17.780 --> 00:52:19.580
>> So that deck isn't there.


00:52:19.580 --> 00:52:22.140
It's like DQE is untouched.


00:52:22.140 --> 00:52:24.500
But if you try and import DECK from collections,


00:52:24.500 --> 00:52:26.160
then you'll get it.


00:52:26.160 --> 00:52:27.000
- Nice.


00:52:27.000 --> 00:52:28.820
Hey, one other quick thing to shout out.


00:52:28.820 --> 00:52:31.220
We're hiring contractors to help develop features


00:52:31.220 --> 00:52:32.420
for pypi.org.


00:52:32.420 --> 00:52:34.740
It says at the top of pipi.org.


00:52:34.740 --> 00:52:36.500
That's, do you know anything about this?


00:52:36.500 --> 00:52:38.220
I guess if people want to work on pipi.org,


00:52:38.220 --> 00:52:39.060
that's pretty neat.


00:52:39.060 --> 00:52:41.020
- Yeah, no, they have funding.


00:52:41.020 --> 00:52:45.380
And there is a post that describes the surveys.


00:52:45.380 --> 00:52:48.260
I believe this is the organizational accounts project


00:52:48.260 --> 00:52:49.100
they're looking at.


00:52:49.100 --> 00:52:51.100
Yeah, organization accounts.


00:52:51.100 --> 00:52:57.680
So if like me, you are kind of the one of the primary Python


00:52:57.680 --> 00:53:00.000
people at your company, then you'll spend a lot of time


00:53:00.000 --> 00:53:02.740
helping people publish packages to PyPI if that's the business


00:53:02.740 --> 00:53:03.360
you're in.


00:53:03.360 --> 00:53:05.080
Certainly is for us.


00:53:05.080 --> 00:53:08.600
There's a lot of packages from Microsoft up on PyPI.


00:53:08.600 --> 00:53:12.960
And the kind of corporate account for that is--


00:53:12.960 --> 00:53:13.840
it does exist.


00:53:13.840 --> 00:53:17.120
We have a user account with 483 projects.


00:53:17.120 --> 00:53:19.720
This is all manually curated right now,


00:53:19.720 --> 00:53:24.520
Because PyPI just doesn't have the functionality to kind of hand out permissions to it safely.


00:53:24.520 --> 00:53:26.280
The teams and all that kind of stuff.


00:53:26.280 --> 00:53:26.780
Yeah.


00:53:26.780 --> 00:53:32.360
So I believe the idea of this is to add that functionality to PyPI.


00:53:32.360 --> 00:53:35.360
So I would love it if someone comes along and does this.


00:53:35.360 --> 00:53:38.800
I believe we've contributed some of the funding towards this.


00:53:38.800 --> 00:53:40.000
So, you know.


00:53:40.000 --> 00:53:41.000
Yeah, looks like it.


00:53:41.000 --> 00:53:44.000
So Steve, I've got a 3.11 question for you.


00:53:44.000 --> 00:53:46.560
So 3.11 is in alpha.


00:53:46.560 --> 00:53:48.160
So what does that mean really?


00:53:48.160 --> 00:53:51.960
Does that mean I can like start using 3.11 or should I wait?


00:53:51.960 --> 00:53:59.440
It means you can. It means we still may change stuff that will break you and we won't apologize.


00:53:59.440 --> 00:54:03.720
Okay, but if my code runs, can I trust it?


00:54:03.720 --> 00:54:10.240
Yeah, if all of your tests pass, then you should be able to trust it fairly well.


00:54:10.240 --> 00:54:11.540
Certainly existing code.


00:54:11.540 --> 00:54:17.820
There will be new features available in the alpha that have not been as thoroughly tested yet or may change again.


00:54:17.820 --> 00:54:19.780
But again, if you're running existing code,


00:54:19.780 --> 00:54:21.180
you won't be using those.


00:54:21.180 --> 00:54:23.220
So that won't matter.


00:54:23.220 --> 00:54:25.100
But yeah, it's totally viable to use.


00:54:25.100 --> 00:54:28.460
You can specify 3.11 dev on GitHub Actions.


00:54:28.460 --> 00:54:32.060
I believe it compiles from source when you do that now.


00:54:32.060 --> 00:54:33.580
They don't have a build there.


00:54:33.580 --> 00:54:34.980
They should for beta.


00:54:34.980 --> 00:54:37.740
Beta is when we really want people to start doing stuff.


00:54:37.740 --> 00:54:40.420
At this point, alpha is so that people


00:54:40.420 --> 00:54:43.040
can test the new features, kind of targeted testing


00:54:43.040 --> 00:54:44.660
on anything new that we've put in.


00:54:44.660 --> 00:54:49.000
Beta is when we really want people to start porting


00:54:49.000 --> 00:54:51.440
libraries, especially kind of the core libraries,


00:54:51.440 --> 00:54:53.600
to be able to work with it.


00:54:53.600 --> 00:54:54.720
And just test it.


00:54:54.720 --> 00:54:57.280
Because if existing code doesn't work on the beta,


00:54:57.280 --> 00:55:00.320
we want to hear about that so we can fix it in the runtime


00:55:00.320 --> 00:55:02.280
and not force you to fix it in your code.


00:55:02.280 --> 00:55:04.080
OK, but if I'm like a package maintainer,


00:55:04.080 --> 00:55:06.160
I can start-- if it's got GitHub Actions for it,


00:55:06.160 --> 00:55:10.200
I can start testing, having my CI test against 3.11, then 2.


00:55:10.200 --> 00:55:11.280
Absolutely.


00:55:11.280 --> 00:55:14.720
You will likely want to mark it as it's okay if it fails.


00:55:14.720 --> 00:55:16.560
- Okay. - Yeah, awesome.


00:55:16.560 --> 00:55:17.480
- Okay, thanks.


00:55:17.480 --> 00:55:19.520
Should we do a joke?


00:55:19.520 --> 00:55:21.040
- Let's do a joke.


00:55:21.040 --> 00:55:22.160
Let's do a joke.


00:55:22.160 --> 00:55:25.880
All right, so this one coming from the programming humor one


00:55:25.880 --> 00:55:27.840
and it's a, like you talked about


00:55:27.840 --> 00:55:29.760
the visualization stuff, Brian.


00:55:29.760 --> 00:55:32.520
And this one it says, there's a search that says,


00:55:32.520 --> 00:55:37.080
how to get labels on MATLAB bar charts to be horizontal.


00:55:37.080 --> 00:55:39.600
Look what the result came back from Google was.


00:55:40.880 --> 00:55:42.920
says, "You're not alone, help is available.


00:55:42.920 --> 00:55:44.680
If you're experiencing difficult thoughts,


00:55:44.680 --> 00:55:49.680
please call 116-123, or if this is an emergency, call 999."


00:55:49.680 --> 00:55:50.920
(laughing)


00:55:50.920 --> 00:55:52.920
And the underlying bit here is,


00:55:52.920 --> 00:55:55.120
"It isn't that drastic, Google, but thanks."


00:55:55.120 --> 00:55:56.880
(laughing)


00:55:56.880 --> 00:55:59.940
And I believe it might also work on Bing, I'm not sure.


00:55:59.940 --> 00:56:02.200
There's a, if you scroll down,


00:56:02.200 --> 00:56:03.840
I think there's a Bing equivalent down here.


00:56:03.840 --> 00:56:06.560
Yeah, not just Google, Bing thinks you're an emergency.


00:56:06.560 --> 00:56:08.280
So, well, yeah.


00:56:08.280 --> 00:56:10.320
(laughing)


00:56:10.320 --> 00:56:11.760
- That's awesome. - Wow.


00:56:11.760 --> 00:56:12.920
- Yeah.


00:56:12.920 --> 00:56:15.740
So it's not that much of an emergency.


00:56:15.740 --> 00:56:17.840
I'll go to Stack Overflow.


00:56:17.840 --> 00:56:19.260
- Nice to know that the big search engines


00:56:19.260 --> 00:56:21.320
are looking out for our mental health.


00:56:21.320 --> 00:56:22.200
- That's right.


00:56:22.200 --> 00:56:24.040
People become very upset after failing


00:56:24.040 --> 00:56:26.000
to get those bar charts in your result.


00:56:26.000 --> 00:56:27.160
(laughing)


00:56:27.160 --> 00:56:29.120
This is not the emergency, but it's coming next


00:56:29.120 --> 00:56:30.720
when you realize what the answer is.


00:56:30.720 --> 00:56:31.780
Something, I don't know.


00:56:31.780 --> 00:56:34.240
(laughing)


00:56:34.240 --> 00:56:36.440
Anyway, that's the joke I found for us, guys.


00:56:36.440 --> 00:56:38.000
- Well, thanks everybody.


00:56:38.000 --> 00:56:39.760
Thanks, Steve, for coming.


00:56:39.760 --> 00:56:40.760
And thanks, Michael, again.


00:56:40.760 --> 00:56:41.760
Yeah.


00:56:41.760 --> 00:56:42.760
Thanks for having me.


00:56:42.760 --> 00:56:43.760
Thanks, all.


00:56:43.760 --> 00:56:44.760
Bye.


00:56:44.760 --> 00:56:45.760
Bye.


00:56:45.760 --> 00:56:46.760
Bye, everyone.


00:56:46.760 --> 00:56:47.760
Thanks for listening to Python Bytes.


00:56:47.760 --> 00:56:48.760
Follow the show on Twitter via @PythonBytes.


00:56:48.760 --> 00:56:51.680
That's Python Bytes as in B-Y-T-E-S.


00:56:51.680 --> 00:56:54.520
Get the full show notes over at PythonBytes.fm.


00:56:54.520 --> 00:56:58.920
If you have a news item we should cover, just visit PythonBytes.fm and click Submit in the


00:56:58.920 --> 00:56:59.920
nav bar.


00:56:59.920 --> 00:57:02.000
We're always on the lookout for sharing something cool.


00:57:02.000 --> 00:57:06.060
If you want to join us for the live recording, just visit the website and click Live Stream


00:57:06.060 --> 00:57:09.260
to get notified of when our next episode goes live.


00:57:09.260 --> 00:57:12.640
That's usually happening at noon Pacific on Wednesdays


00:57:12.640 --> 00:57:13.620
over at YouTube.


00:57:13.620 --> 00:57:15.700
On behalf of myself and Brian Okken,


00:57:15.700 --> 00:57:17.020
this is Michael Kennedy.


00:57:17.020 --> 00:57:19.220
Thank you for listening and sharing this podcast


00:57:19.220 --> 00:57:20.820
with your friends and colleagues.

