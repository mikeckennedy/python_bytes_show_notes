00:00:00 Hey there, thanks for listening.

00:00:01 Before we jump into this episode, I just want to remind you that this episode is brought to you by us over at TalkBython Training, and Brian through his pytest book.

00:00:10 So if you want to get hands on and learn something with Python, be sure to consider our courses over at TalkBython Training.

00:00:17 Visit them via pythonbytes.fm/courses.

00:00:21 And if you're looking to do testing and get better with pytest, check out Brian's book at pythonbytes.fm/pytest.

00:00:28 Enjoy the episode.

00:00:29 Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:34 This is episode 271.

00:00:36 Really?

00:00:37 Wow.

00:00:38 Recorded February 16th, 2022.

00:00:41 I'm Brian Okken.

00:00:42 Hi, I'm Michael Kennedy.

00:00:43 And I'm Steve Dower.

00:00:44 Welcome, Steve.

00:00:45 So, who's Steve Dower?

00:00:46 Who's Steve Dower?

00:00:47 Yeah.

00:00:48 A number of things.

00:00:51 Probably most interesting to this audience is I'm a core developer on CPython, one of our Windows experts.

00:00:56 So I spend a lot of my time focusing on making Python run better on Windows.

00:01:00 I also work on Microsoft, work at Microsoft, where I also spend a lot of my time making Python run better on Windows.

00:01:06 So I'm kind of a bit of a one trick pony, I guess, but it's, I feel like it's good work and it helps a lot of people. So, So if I have a problem with Python on Windows, it's your fault.

00:01:16 I, if there's solutions for Python on Windows, then it's, it's my fault.

00:01:21 I'll let other people own the problems.

00:01:25 So if I go to the Windows store, I can now install Python from there.

00:01:30 And you were you were part of that, right?

00:01:32 Oh, I should I should have had that up on screen, shouldn't I?

00:01:34 Yeah, that was that that was actually the request came from people within Microsoft to like, hey, why can't why can't we get Python up on the store to it?

00:01:45 And my response to all of these is like, well, if the community is willing to do it, which is half me and is half the people who would have to take over If I stop doing it, then yeah, we'll go ahead and do it.

00:01:55 And so I got actual work time for that.

00:01:58 That was a contribution from Microsoft for that one.

00:02:01 But yeah, the community was on board and it's going really well.

00:02:06 That's also the one that we tied into the default Python.exe that's on every Windows machine now.

00:02:11 So if you go to a brand new machine and just type in Python, you'll get straight to the PSF's Python.

00:02:18 Microsoft is not doing it anymore.

00:02:19 We just contributed the change and now I switch hat and do it with the other hat on.

00:02:24 So, you know, it's real Python, right?

00:02:26 It's exactly the same as what you get from python.org.

00:02:28 It's just delivered, you know, easily fast install automatic updates and a couple of edge issues that we're working on bringing down.

00:02:38 So, yeah.

00:02:40 - Fantastic.

00:02:41 - Automatic update.

00:02:42 I know this wasn't one of the topics, but now I think I might have to rethink how I'm installing Python on my desktop at work.

00:02:48 So that's a cool idea.

00:02:50 >> I have only had store installs on my own machines since 3.8.

00:02:56 I think I haven't, apart from testing, I haven't actually used the regular installer on my own.

00:03:01 >> But I mean, you, of course, that makes sense.

00:03:04 >> It's always testing.

00:03:06 Every time I'm using Python, I'm testing.

00:03:09 >> Chris May out there says, "Thank you so much for making my work life in Windows easier." >> Anytime.

00:03:14 >> Yeah. Well, Michael, why don't you kick us off with a story or a topic?

00:03:18 I have got a good one.

00:03:20 So I'm a big fan of FastAPI and FastAPI being built on Starlet.

00:03:25 So by the transit of property, I'm also a fan of Starlet.

00:03:28 And there's this thing I want to cover called FastAPI events.

00:03:33 So when a request comes in to a particular API endpoint, or if you convert it over to a web app, to a webpage sort of request or something, you might want to dispatch that out to say like WebSocket listeners or something along those lines.

00:03:47 So there's this cool project called FastAPI Events.

00:03:49 It's pretty small and new.

00:03:51 So I'm gonna try to give it some visibility.

00:03:53 It's only got 36 stars.

00:03:54 It's pretty new, but the idea is that you can go through and basically create this middleware handler that will let you say, when a request comes in, here's the way, when an event is raised, here's the thing that's going to handle it.

00:04:06 And then in some API endpoint, you can say dispatch, give the event a name and some dictionary data to be passed along.

00:04:13 I suppose it doesn't have to be a dictionary, it could be whatever.

00:04:16 And then in other parts of your code, you say, I wanna just hear about this event that happens no matter what API endpoint received it, no matter where in like how deep down in the code it was received and so on.

00:04:30 So then way down here, you just put a role handler decorator on there.

00:04:34 You say, I wanna capture all the events that start with, you know, some substring like cat star for like category, whatever, or this one is actually literally about cats.

00:04:43 And then you can just go through and write these functions that will then handle that and you know, you can, you can also pass them off to queues like you can use the SQS, the simple queuing service from AWS I believe that is, as the endpoint instead of it just being your app, right?

00:04:59 So if you've got like lots of scale out and stuff like that.

00:05:01 - Wow, cool.

00:05:02 So is this like a neat way to do logging or even distributed logging, I guess, if you've got forwarding handlers in there, you can just--

00:05:08 - Yeah, yeah, it seems like it, right?

00:05:10 Like, or if you know, you want to sort of build up like here's the request transaction and here we're at this stage, or you could maybe do visibility into long-running workflows with this kind of thing, or something along those lines, I would think.

00:05:22 So, yeah, there's also an echo handler for debugging.

00:05:25 I kind of like that.

00:05:26 If I just need to see what is happening, it'll just print whatever's happening.

00:05:29 It'll just start printing out all the behaviors that you're logging.

00:05:32 - And then when you want to stop doing that, you just take away the handler, and you don't have to search the entire code base for print and find everywhere that you added it in for debugging.

00:05:42 - Exactly.

00:05:44 - Alvaro out there says, "This looks similar "to Django events." Yeah, I suspect it is similar.

00:05:51 Anyway, pretty short and simple, but if you're looking for a way to sort of put notifications in a structured way into a FastAPI app, well, here you go.

00:06:01 - Oh, I'm thinking of a whole bunch of more abusive ways to use this.

00:06:04 (both laughing)

00:06:07 - I mean, yeah, you can write some really impressive spaghetti code with this.

00:06:11 - Yeah, I'm sure that you can.

00:06:13 cloud involved in everything.

00:06:15 >> Yeah. Let's switch gears a little bit and talk about testing.

00:06:20 Imagine that I've got a testing topic.

00:06:23 I'm pretty excited.

00:06:25 I've been asked a lot about testing pipelines, testing data science stuff, and that's not something I do day-to-day.

00:06:35 I'm really glad to find people talking about it.

00:06:38 We've got an article from Peter Baumgartner, ways to use testing, ways I use testing as a data scientist.

00:06:46 And I just really love this article.

00:06:49 It's great.

00:06:50 To start with, he starts off with what he uses testing for as a data scientist.

00:06:56 He uses testing to make sure things work, to document his understanding, and to prevent future errors.

00:07:04 Well, that seems straightforward.

00:07:06 But the reason why he wrote this up is apparently because there's a lot of software, there's a lot of testing stuff out on the web, but it's geared towards test engineers or software developers.

00:07:18 He's like, "I'm not a software developer.

00:07:20 I'm doing something else.

00:07:23 I'm doing analysis. I'm not a software person." Even though, yeah, you are.

00:07:28 But to write this up in a context where data people might understand it better.

00:07:35 For instance, he doesn't even start off with writing, having written tests, his, his analysis is like, if you're doing notebooks or other code, just use assert a lot. So he's using assert all over the place, including he says, I already have use it for as many intermediate calculations and processes as as you can, as it makes sense. Because in doing things like checking obvious stuff, like he's got an example of a table count where he's counting up all the yeses.

00:08:09 Well, you can do a little bit of math just to make sure the math works.

00:08:12 So like all the yeses and nos and missing should all add up to the same count.

00:08:17 Go ahead and throw an assert in there because sometimes it doesn't.

00:08:20 And in this example, he said that he actually caught an error because he was looking at two different data frames.

00:08:28 So they really weren't, they didn't add up to the same.

00:08:31 So you can catch things like that.

00:08:33 So just double checking yourself on things as you go away, go as you're developing.

00:08:41 One of the cool quotes he has in here is like, as he has a habit of when he's using notebooks to whenever he's visually inspecting the output, if you're visually looking at the data that comes out, maybe write an assert statement to do that analysis so that it's always checked.

00:09:00 And this is a cool use of putting asserts in notebooks.

00:09:03 I like this idea.

00:09:04 The article goes on, it's pretty extensive, talking about checking the data, using hypothesis to, well, not the data at this part, but your assumptions around the data.

00:09:19 So using hypothesis to check your assumptions and hypothesis will show you things that maybe you didn't consider, like NANDs, are you handling those correctly?

00:09:29 empty series or empty data structures that are going into your code?

00:09:34 Are you handling those?

00:09:35 I mean, hypothesis does take some hand-holding, but it does make you think about really what is the shape of the data going in, and do you need to limit it?

00:09:47 What hypothesis is looking at or do you need to change your code to handle more things?

00:09:51 >> Hypothesis is great. I've used that for a couple of parsing projects or combining projects.

00:09:58 I spent way too long adding all the strategies to be able to test a URL parser that I was calling into.

00:10:05 But it's fantastic for finding kind of things that you would not have thought of.

00:10:11 - Yeah, I mean, it's finding things, but it's also, and it does make, yeah, that aspect of it seems like the point of it, but the real value I get out of hypothesis is thinking, making sure I really understand the data that's gonna come in and thinking through those.

00:10:27 It goes on to talk about actually testing your data using things like Pandera, which I wasn't familiar with, and another package called Great Expectations to look at like putting schemas around the data coming in and making sure that the data always matches the schema, going on to talk about Arrange Act Insert and using pytest.

00:10:46 pytest comes in with, he's only really writing formal tests when he's writing libraries for other people, but all these other packages to be able to test with data science, I think this is a great addition to the data science community.

00:10:59 - Yeah. Alvaro talks about how this is, you know, often referred to as defensive programming.

00:11:04 And then, you know, I feel for him a little bit, he says, "At work we use this with our Fortran code." So there's that, but I do think this is a really interesting way of thinking about defensive code.

00:11:15 You know, I just, I think of writing defensive code as like, oh, I'm gonna have a bunch of if statements to verify this thing's not none, or verify that this is the right type and that it has a reasonable value and raise exceptions.

00:11:26 I haven't really thought so much of it for notebooks.

00:11:30 So that's pretty interesting.

00:11:31 - And one of the neat things about if you're actually putting asserts in your code, you can write tests against your code that don't even have any asserts in them.

00:11:41 And because the asserts will happen within your code and the test will still fail and catch it.

00:11:46 So it's kind of cool.

00:11:47 - Yeah, yeah, very cool.

00:11:48 Good stuff.

00:11:49 - Yeah.

00:11:50 - Steve, I am super excited to hear about what you're, you got coming up because this is brand new.

00:11:56 Being a core developer, I feel it is appropriate that you break this news here.

00:12:00 - I mean, I'm not gonna lie when it came to, you know, what am I gonna talk about?

00:12:03 Okay, what's the most recently accepted pep that was somewhat controversial?

00:12:07 And I think just as you kind of look down to the section on rejected ideas, which is considerably longer than the accepted ideas, you probably get a bit of a sense for just what went on with exception groups.

00:12:24 And I know, Michael, you just had a conversation.

00:12:26 You've learned all about them.

00:12:27 So you can take over when I run out here.

00:12:30 But--

00:12:31 I'll share my thoughts with it.

00:12:32 But yeah, go ahead.

00:12:33 I'd love to hear about it.

00:12:34 This is sort of inspired by Trio, right?

00:12:37 The end goal kind of is-- so this is an interesting pep.

00:12:40 And we've got a few of these on the go at the moment.

00:12:42 It's kind of like a stepping stone towards a better programming model or a stepping stone towards better libraries.

00:12:48 So it's something that I think in my opinion, very few application developers, the last developer in the chain, are often not going to use them, and they're not going to need them.

00:13:02 But as you go further in towards the lower levels of libraries, especially people writing async schedulers, are going to find incredible value out of them.

00:13:10 Essentially, what the idea is is that when you're running multiple tasks in parallel, if some of them fail, we don't currently have a neat way to capture the exceptions from all of the ones that failed.

00:13:23 There's some approaches that would be like, wait for all of them to complete and wrap it in a list, and then you get some exception that contains a list of exceptions, but that's lost a whole lot of context.

00:13:33 You can get just whichever exception happens first, but then you lose all the other exceptions and there's just been no real way to handle it.

00:13:40 So an exception group essentially does bundle up all the exceptions internally in some way.

00:13:46 But the really interesting thing is the accept star syntax, which I'm going to have to scroll a long way down to find where that comes up.

00:13:53 But this is really clever because if you're in that situation where say you're running 10 parallel processes, so here's kind of the first example of it, then exceptions are no longer control flow at this level.

00:14:08 Cause if you're, if you've run 10 things and you're waiting for 10 things to complete, you're not actually doing control flow with the exceptions anymore.

00:14:14 What you're doing is handling the exception, but then the control flow is going to go back to where it was anyway, because, because you're going to be doing something different. So for example, if a file doesn't open, then you would want to do something different, right? You're going to stop going on and trying to read from the file.

00:14:34 But if you've tried to open 10 files and three of them failed you at the outside level. So at the end, at the inner level for each file that may have failed, you'll do something different at the outer level. All you're really going to do is say, hey, this task failed because a file couldn't be opened and maybe you do something else, but it's at the outside level. So except star takes that exception group and it's going to give you a chance to handle each exception, essentially on its own. It will group them together. So in this example, if you know, five tasks report spam error, then you'll get into this except spam error block with all five of them at once, which is just...

00:15:11 Is that a list of spam exception, spam error exceptions? Something like, or a tuple, something like that? I think it's a tuple. I think with the star syntax, I believe.

00:15:20 Something iterable, basically, yeah.

00:15:23 Yeah. Something you can iterate over to see the exceptions, but it's really just, you know, this happened at some point and you process it. And if the group actually contains multiple types of exceptions, then each handler that matches is going to be called for all the exceptions that match that. So you could have this try block raise an exception group that has some spam errors, it has some foo errors, it has some bar errors, and all three except star blocks are going to get called with the exceptions that match those, which is a bit, it's definitely going to confuse a lot of people. It confuses me, which is why I was keen to actually spend a bit more time digging into it and trying to figure out what's really valuable about this. And I do think the most valuable one is really where the error is cancelled error. Because if for whatever reason, five of your tasks have been cancelled, then you need to capture that and do something with that outside of it. But it doesn't necessarily mean you want to throw away the five successful results.

00:16:24 And so you do kind of want to keep a bit of everything going on.

00:16:28 And like I say, it's a building block on its own. This isn't enough to do anything new and useful. The next thing that comes along is task groups.

00:16:38 And that's being worked on by... I expect a lot of the same people who worked on exception groups, because with task groups, now you can actually start... There we go.

00:16:48 Guidos just merged task groups. Excellent. Then now you can actually run the task group. And if the group raises any errors, then you'll catch them through an exception group.

00:17:00 And so that enables a whole lot of new uses and new ways to use async.io or just async generally, no matter the library. As you say, Trios already has something like this for a while.

00:17:12 >> Yeah, from their nursery thing.

00:17:15 - Yeah, and so that is now being standardized so libraries can kind of share their implementations and work together on it.

00:17:23 - So one of the reasons you need this is if I start two web requests and three database queries, and then I go to wait on them, you know, then if several of them fail, the error state captured in totality is a tree of errors that represent, well, this task started this other task, which then had this error, this other one, right?

00:17:45 So you need some way to deal with a group of errors that could happen kind of all at once, right?

00:17:50 In one of these task groups that gets kicked off.

00:17:52 - Yeah.

00:17:53 - So the new task group thing is super cool.

00:17:55 So you say async with task group as TG, and there's two things that are neat about it.

00:18:00 One is right now, if you fire off a bunch of tasks in async and await style, they're basically unrelated.

00:18:06 Like if one fails, that means nothing for the other, right?

00:18:09 They're just like, well, here's a bunch of stuff that happened, and this creates a relationship between them, right?

00:18:14 So that if one fails, I think it might not schedule new ones something to that of like it's brand new.

00:18:18 I'm just seeing the tweets.

00:18:19 So I think that that's the story.

00:18:20 I believe that was the story of Rio.

00:18:23 The other thing that's interesting here that in this example, which I'll link to from Yuri that he posted, he tweeted about the news was notice that the first one says, task group create task for some task and then await something that creates another task.

00:18:40 There's nowhere where you say, store all those values into like some lists of tasks, then go to the task and iterate them and wait for them or gather them or whatever the heck it was you had to do before.

00:18:49 This now makes tasks fire and forget.

00:18:52 I can say, run this, run this, and within that, I could do more of those types of things.

00:18:56 And then you just block at the with context manager level to wait for all the tasks to finish, which I think is a real big improvement 'cause right now you've got to like constantly juggle, well, I've got to return a task from this so I can go wait on it later and all those sort of oddities.

00:19:10 And this cleans up a lot of that.

00:19:12 - Right, and of course being Python, I don't know exactly how the syntax works, but being Python, that TG object, the task group, doesn't actually disappear at the end of the with block.

00:19:21 So if that's got results stored into it, then you still have access to those and all of the information about the task group, even after you've waited for it to complete running.

00:19:30 - Oh yeah, that's cool.

00:19:31 Yeah, so I think this is a nice addition to async IO in Python.

00:19:35 This is cool.

00:19:36 And apparently 3.11 is coming.

00:19:38 Yeah, coming in 3.11.

00:19:40 I do see a question from Sam Morley in the chat there.

00:19:42 Is there a way to short circuit so that you don't recatch certain exceptions?

00:19:45 My understanding, and Michael, if you've got a better one, correct me, is that the except blocks work in the same way as regular ones, and the first one that matches a particular exception will handle it, and the later ones don't, even if they would also match.

00:20:01 So if you have, so if the spam error is a subclass of foo error, but there's another subclass of foo error, then spam errors will get handled by the spam error handler.

00:20:12 The foo error handler will handle all the other ones apart from the spam error subclass.

00:20:18 - Nice, yeah, I don't know much about the accept star other than it was basically a requirement for the task group stuff to be implemented properly.

00:20:26 So when one came in, then the other could come in, yeah.

00:20:28 - It's the only feasible way to actually do something as a result of an exception group.

00:20:34 Otherwise, you do end up with a very generic exception, and then you write a for loop over all the exceptions that it handled and try and figure it out yourself.

00:20:44 So you'd end up rewriting the code, and it was just not gonna be feasible.

00:20:48 It needed to be syntax, and so it is.

00:20:50 - Yeah, right on.

00:20:52 Very exciting and very timely.

00:20:54 Thanks, Steve.

00:20:54 - I'm kinda glad that I put off learning how to do async code until 3.11.

00:20:58 This looks easier.

00:21:00 - It's a good band and a good time for async I/O.

00:21:03 - Well, cool.

00:21:04 - All right, I guess I'm up with the next one, huh, Brian?

00:21:06 - Yeah, let's see what you got.

00:21:08 - I have got some other interesting things.

00:21:10 I'm here about showing off the underappreciated projects, or the new projects, just a couple of stars here.

00:21:17 And we've talked about overloading before, but I thought this was a clean way to do it that people could think about.

00:21:21 And Steve, I would definitely love to hear your thoughts on this.

00:21:24 So Felix the cat created this library called PyOverload.

00:21:29 And the idea is basically once you have type information, then you can have method or function overloading.

00:21:35 The idea being like, okay, if a function called boo or whatever, and if it, you can say, if it takes an integer, I want this implementation run.

00:21:42 If it takes a string, I want some other implementation to run, right?

00:21:45 That's sort of the traditional C++, C# definition of it.

00:21:49 But in Python, we don't have that really because the language started without type.

00:21:54 So how are you gonna figure out the type to overload it?

00:21:56 You know, right?

00:21:56 That just like, doesn't make any sense.

00:21:58 So with this one, you could sort of use, like traditionally you could use is instance.

00:22:01 we're gonna do one thing or another.

00:22:03 Is it a single thing or is it a list of those things?

00:22:05 What are we gonna do?

00:22:06 But with this one, you can put just @overload and then whatever the signature is, if you can say it has no functions or has no parameters or it has like two integers or it has three integers or it has like a list of them, whatever.

00:22:20 And there's even a way to sort of say somewhere down here, there's a way to say like, if none of them match, call this particular one.

00:22:27 So basically it's just straight function overloading in Python if that's the thing you want.

00:22:31 Steve, does this make you cringe or do you like it?

00:22:33 well, it's...

00:22:35 Both?

00:22:37 You know, I'm not going to lie, I'm not the most into static typing in my Python code as a lot of other people.

00:22:45 And there's a lot of complicated reasons, but I think for a situation like this I mean, I know if I was writing a function that took a string or an int the very first line would be converted to whichever type I actually want and then the rest of the function is going to look identical. And that's sure. And that in that case where like there might be a unparsed type of thing for sure. I think you wouldn't really do an overload. That would be insane.

00:23:09 And my kind of gut feel and you know, I'm always open to to examples proving me wrong.

00:23:15 In which case I, you know, I would write the is instance code that's in those examples.

00:23:19 You know, my kind of gut feeling is that if you're doing two drastically different things in the function based on the type, you need two functions. And once you've got two separate And if the people calling don't know what they're passing you, then they've got a problem.

00:23:34 And it's not so much my responsibility to fix it with overloading.

00:23:37 That said, overloading is really cool.

00:23:40 And I am the exact opposite person when it comes to C and C++.

00:23:45 I will do all the craziest possible stuff with overloading in those languages, because I think it fits the language, and it's a lot of fun.

00:23:51 And there's definitely occasions and value for having it in Python.

00:23:55 We do have the single dispatch decorator.

00:23:57 has been part of Python for a while, which will do this on the very first parameter.

00:24:02 This, very trivially extending it to the whole function signature is really cool.

00:24:09 So if I needed to do this, I would probably want to use a library like this.

00:24:15 I would probably reconsider my API design choices up to that point.

00:24:23 But I can understand the attraction of getting to, you know, to reuse the name and not make the person calling it think too hard about how, you know, what's actually gonna run.

00:24:35 - Yeah, the place where this sort of seems interesting to me is, you know, there's some, lot of like tricks and juggling people do with like star args, star star kW args, where like, okay, depending on how you pass it, stuff will do a bunch of things.

00:24:47 - Yeah.

00:24:48 - And I'm always looking for a way to like not do that.

00:24:51 - Yeah.

00:24:52 How can I not? How can I remove that? Like it's completely opaque. I have to do a Google search and read the docs to figure out what is at all possible here. Well, one of these days I'm going probably going to take all of the kind of patents for that kind of thing that I've collected and turn it into a book. But writing a book just feels like way too much work. So not anytime soon. Sorry.

00:25:10 My colleagues at work can ping me at any time and I'll give them a patent for what they're trying to do. But that's, I do have quite a set of, oh, you're trying to make stuff weirdly work in this way. Here's a nice way that you can enable that without having to resort to, you know, type checks and everything. Yeah, yeah. I've been using, I mean, I've been using Python for a long time.

00:25:34 And I do remember one of the first things that I noticed is I couldn't do overloading. And at the time, so this is, you know, many years ago, I was using a lot of overloading in my C and C++ code.

00:25:45 and I was like, "Oh, I can't do overloading." But one of the things I've noticed is actually, instead of wishing that I had overloading in Python, I've noticed that I don't really use it in C and C++ anymore.

00:25:58 >> It's gone the other way.

00:26:00 >> Yeah. I'd rather be more explicit about the two functions that maybe they're similarly named, but they have an appendix that's different.

00:26:13 so that if you have different data, you pass it.

00:26:15 And I'm with you, Michael, I'd rather have people go, well, which one do I need?

00:26:19 I'll look it up, then just passing the wrong data type and having me, because sometimes if they haven't converted the data, like string versus number is a scary one for me because I'm often getting my numbers from an API or something, and they come in as a string if you forgot to convert it and you passed it to the wrong thing, and you're really doing something completely different.

00:26:43 That's not a good thing.

00:26:45 - I got bit by that one just yesterday, updating one of my CI builds to use Python 3.1, I mean 3.10.

00:26:52 (laughing)

00:26:54 - Exactly.

00:26:55 - Is it a string or is it a number?

00:26:57 (laughing)

00:26:59 - Interesting, yeah.

00:27:00 - But yeah, certainly that conversion would be worrying.

00:27:05 The other one is, is it a string or is it a list of strings?

00:27:07 And that's the one that bites us in Python all the time.

00:27:10 and I don't even know how you resolve an overloaded function based on, is it a string or can I iterate it?

00:27:17 - Well, like in that case, actually, I would rather just have that part be part of the function.

00:27:21 At the top of it, if it can handle both, to check the type and iterate or not, but you know.

00:27:28 - Yeah, well, all right, let me close this out with two quick thoughts.

00:27:32 First, I think this is interesting because it's one of the things that's possible with modern Python.

00:27:38 Like once we've added typing, now you could consider this as a thing, whereas previously it really was highly impractical, I think, as a way to do it.

00:27:48 So I think that's kind of cool.

00:27:49 And then two, I think it might be an entryway for people who are not where Brian, and I'll put myself in there as well, yet of going like, actually, these things I thought I need, I don't need those, right?

00:27:59 There's a lot of stuff I thought I needed and I haven't used it for three years, so maybe I actually don't need it.

00:28:03 But that's not how you maybe first approach solving your first problem in Python, that you're coming from C++ or whatever, C#, whatever, this might be a gateway.

00:28:13 So anyway, those are my two thoughts.

00:28:15 - One more thought from Dean after Python 3.11, do we get Python 95?

00:28:20 (laughing)

00:28:22 - There was a Windows 3.12.

00:28:24 So I think Python gets to do a 3.12 as well.

00:28:27 (laughing)

00:28:28 - 3.12.

00:28:29 - I think it was only available in China.

00:28:32 - Interesting.

00:28:33 - And I believe, I like to follow on with that, Dean, very funny.

00:28:36 I believe that Windows 10 was named--

00:28:40 you let me know if you know a difference, Steve.

00:28:42 Windows 10 was named Windows 10 because there used to be the check Windows 9 as the starting string for 95 and 98.

00:28:49 So you can't be 9 because then you're going to be 95.

00:28:51 So we got to kick on past it.

00:28:53 It's kind of like your 310 thing.

00:28:54 There was some embarrassingly big language run times out there still doing that check that really struggled with Windows 9 and showed up in enough places that, yeah, I think it just made sense for everyone to just skip it.

00:29:14 Not skipping 13.

00:29:15 We're skipping 9.

00:29:16 It's too unlucky.

00:29:17 All right.

00:29:17 Awesome.

00:29:18 Brian, what you got for us?

00:29:19 Oh, what do I have next?

00:29:20 I have the next generation Seaborn interface.

00:29:24 So Seaborn is a really awesome plotting library built on Matplotlib.

00:29:31 And I, you know, actually I don't use it that much, but I've always been intrigued by it and kind of watching what plotting libraries do and stuff.

00:29:39 And one of the things I was curious about, which I'm really grateful for this article, is some of the history behind it.

00:29:46 So the article starts off, next generation Seaboard interface, talks about the background and goals, but some of the great things in here, let me grab some notes.

00:29:57 This work grew out of a long running effort to refactor Seaborn internals, so that functions, you know, anyway, where I wanted to get at was he was developing a refactor of the internals.

00:30:10 And he's like, wait, wait a second, if I want to refactor it, maybe I should expose more stuff.

00:30:14 And some of the background was Seaborn was originally conceived of as a toolbox to do of domain-specific statistical graphics to be used alongside Matplotlib.

00:30:27 So the intent was people would use both Seaborn and Matplotlib together.

00:30:30 However, things that people are doing things differently.

00:30:34 A lot of people just grab Seaborn by itself.

00:30:36 Some people even just learn Seaborn before they even learn Matplotlib, which is an interesting thing.

00:30:42 And that's how I thought you were supposed to be doing this.

00:30:45 But the concept was, and then over time, there's a whole bunch of features that have been added to Seaborn to where it's like really slick looking, but to do the same thing by hand in Matplotlib is a lot of work.

00:30:57 So there's some things that, Like if you see born is almost there, but you need to tweak it a little bit and you have to do things manually, well, then you have to just do everything by yourself and it's a lot of work.

00:31:07 So the idea around this, a rewrite of the API is let's rework some of the internals so that a lot of the little sub components that go inside of a plot are exposed.

00:31:20 That way people can get access to it to do a more fine tune configuration within the, so they don't really have to just do everything It's either all or nothing Seaborn or Matplotlib.

00:31:31 You can kind of do both more easily, which is a kind of a cool idea.

00:31:36 There's a whole bunch of great details in here that talk about some of the API changes.

00:31:40 Basically, it's exposing the internal.

00:31:43 If you create a plot, there's nothing there and it won't show up.

00:31:46 You have to create layers on the plot.

00:31:48 And then within the layers, you've got marks and different components that go into it.

00:31:53 I kind of like this idea of building things up.

00:31:55 But what I really like is the public aspect of this.

00:31:58 You've got a library that's out in the open.

00:32:01 It's being used by a lot of people already, and somebody's saying, "Maybe we should tweak the API and do something different." Just going ahead and doing that in the open saying, "Hey, we're going to do this.

00:32:11 There's a note at the top, or I'm thinking about doing this, note at the top saying, it's a work in progress.

00:32:17 Don't depend on these examples because things might change, but this is the direction we're trying to go, trying to get feedback from people." I think this is a lot of things that a lot of people struggle with when they're maintaining packages that have been around for a long time is, I wanna do things a little different, but am I gonna break everybody?

00:32:36 And talking through it.

00:32:37 So anyway, this is a great read, especially if you're a data plotting kind of person.

00:32:43 - Yeah, very nice.

00:32:44 I always wanna do more with visualization, and I'm sure that I have some good data I could pull up.

00:32:48 - Yeah.

00:32:49 - I end up basically just writing APIs on websites these days.

00:32:52 But I really should be pulling this up and doing some of these graphs, And I'm really happy these are around.

00:32:58 Steve, how about you?

00:32:59 - See, Seaborn's great.

00:33:00 It's always, like, back when I first discovered it, one of its major selling points was simply importing Seaborn would magically make your default Matplotlib charts look nicer.

00:33:11 Which Matplotlib is--

00:33:13 - I love it, it's like the bootstrap of Matplotlib.

00:33:15 - It really was.

00:33:16 It's like they just apply their style by default and every Matplotlib chart suddenly look nicer.

00:33:22 Which, you know, Matplotlib's done their own styling work now, so it's less valuable for that.

00:33:28 I do like this API.

00:33:30 It looks good.

00:33:30 And as Dean's pointing out in chat, it's like, Matplotlib has an object-oriented plotting API similar to this, possibly identical, just like everyone else.

00:33:38 I've never learned the object-oriented API.

00:33:42 But it is there.

00:33:43 And that's the modern one.

00:33:47 I know a lot of people say Matplotlib is impenetrable and kind of hard to build things up.

00:33:51 But it does have a really nice API there.

00:33:53 It's just not the PiPlot one that kind of imitates MATLAB's old API.

00:34:00 And so having it there is really nice.

00:34:03 And Seaborn, having their own is also great.

00:34:07 Another nice thing to read about in this is he does a hat tip to ggplot2 or whatever it's called, saying that, yes, it's going to look--

00:34:21 a lot of this is similar to ggplot.

00:34:23 but it isn't that I'm trying to copy it or maybe that's definitely influence, but it is that Seaborn is important because we think about things differently in Python than we do in R.

00:34:37 And just having, it would be, but also a hat tip to another library that is a wrapper around ggplot.

00:34:45 If you just want that, you can do that in Python too, that's available.

00:34:49 So it is interesting to, We think of these as competing libraries, but they're really not competing with each other.

00:34:56 They're working together to push the push plotting forward.

00:34:59 - So yeah, nice.

00:35:01 Dean out there points out you can do plot.style.useSeaborne or ggplot, which is another.

00:35:07 - You can use ggplot.

00:35:08 - Let me throw out, oh yeah, go ahead, Steve.

00:35:10 - ggplot's certainly the one to copy from.

00:35:12 I mean, there's a reason that one is as universally popular as any plotting library can possibly be.

00:35:21 It's probably competing with Excel for popularity of plotting data, realistically.

00:35:27 It's a really nice API, and it looks good, and everyone's familiar with it.

00:35:32 And so there's nothing wrong with copying from ggplot.

00:35:35 MARK MANDEL: Nice.

00:35:36 I got one more shout out to throw into this conversation.

00:35:39 The XKCD plotting style for Matplotlib.

00:35:43 So you've got--

00:35:45 I mean, this is fantastic.

00:35:46 It looks like the--

00:35:48 It really does look like XKCD would, you know, the comic would do for these.

00:35:55 So this is fantastic, I love it.

00:35:57 - What I love is I actually see this.

00:35:59 I see this in papers and stuff like that.

00:36:00 People just go ahead and use the XKCD style and for serious stuff.

00:36:05 And it just is, it's awesome.

00:36:06 I love it.

00:36:07 - I think there's actually some value to having like cartoony looking graphics, like UI sketches and graphs to say like, look, this is speculative.

00:36:14 This is just like, don't read too much into it.

00:36:16 I'm trying to give you an idea rather than an exact thing.

00:36:19 And I think sort of UI, like cartoony looking sketches and this also plays into that.

00:36:25 - Yeah.

00:36:26 - Right, Steve, you got the last one?

00:36:27 - I got the last one, yeah.

00:36:28 So this is another kind of recent delivery from the CPython core team.

00:36:34 We can now compile CPython to WebAssembly.

00:36:37 - Wow.

00:36:38 - And to a lot of people, that probably means very little.

00:36:41 But I guess the brief, brief summary is WebAssembly is kind of what the JavaScript in your browser compiles to before it runs.

00:36:50 So it's skipped that initial step of being JavaScript, and it's now ready to run in the browser.

00:36:56 So it's a lower level.

00:36:58 There are tool chains out there that can compile all sorts of languages directly to WebAssembly.

00:37:03 And so in this case, we've taken--

00:37:05 I believe we use one of the--

00:37:08 I don't know the exact tool chain that's used, and it may not matter.

00:37:11 But it basically takes the C code and compiles that to WebAssembly, gives you a package that can be brought into an Electron app or a Node.js app or a web browser, modern web browser, and be run in the browser.

00:37:25 There is, so this page is a little bit dated.

00:37:28 There's been a bit more work since then, but I found this is the best overview of where things are kind of at.

00:37:32 Long list of C extensions that don't work.

00:37:34 Probably unsurprising, like the browser doesn't have a lot of this stuff in it.

00:37:39 - Yeah, you don't have all the different APIs, the Win32 API underneath or whatever it was delegating to.

00:37:45 Yeah.

00:37:46 No TK enter?

00:37:47 What?

00:37:49 Yeah, no TK enter, no subprocess.

00:37:52 C types, apparently, you can do.

00:37:53 I've heard there is a libffi port to the Emscripten kind of platform.

00:38:00 So how this kind of works is when you take WebAssembly into a browser, it has access to nothing.

00:38:09 It starts off in a really enclosed kind of box of things that it can do.

00:38:13 And that doesn't actually work for Python at all, because the very only thing that it tries to do is search the file system for what files it should be loading.

00:38:22 So we actually build it as part of another platform.

00:38:25 Emscripten is one platform that kind of polyfills a whole lot of native-looking APIs so that code that's compiled on top of Emscripten is able to use it.

00:38:36 And this little demo, which I just hit Start, REPL. This is running on that.

00:38:42 So this is a build of Python 3.11, Alpha 4 built with Clang running on Emscripten.

00:38:48 And I can, I believe I can do this, do like OSLister.

00:38:53 And it thinks there's a file system there.

00:38:54 Now that's not my file system.

00:38:56 That's in memory.

00:38:57 It can be changed to browser storage, but this is entirely in the browser.

00:39:01 Like there's nothing downloaded.

00:39:02 There's nothing running on my machine here.

00:39:04 There's nothing running in the cloud.

00:39:06 It's literally in the browser.

00:39:07 I can probably freeze my browser with this.

00:39:09 Like I can do an infinite loop.

00:39:10 >> Yeah, do it.

00:39:11 >> Do it. Let's see if this cuts me off.

00:39:14 I'll just let that run.

00:39:16 >> Hit clear. What happens if you hit clear?

00:39:18 >> [LAUGHTER]

00:39:20 >> Started again?

00:39:20 >> No.

00:39:21 >> We're going to start again?

00:39:22 >> No.

00:39:22 >> No, it's done.

00:39:23 >> I'll refresh.

00:39:25 There's a second one that the actual build as it was committed support, which is WASI, W-A-S-I.

00:39:35 That's a slightly different approach to adding all the functionality around a WebAssembly module.

00:39:41 It's a little bit more flexible, a little bit more controlled.

00:39:44 Emscripten is really like, give me POSIX system inside my browser, all in memory.

00:39:51 And so we have two options.

00:39:52 And these are available in the main branch.

00:39:57 At the moment, we're not shipping pre-built modules for WebAssembly.

00:40:01 That might be a possibility.

00:40:02 If that's something that you'd like to see, then I guess go to discuss.python.org and post about it.

00:40:08 It's probably a post there.

00:40:09 I should've looked for a post there.

00:40:11 But we're not currently doing pre-built releases.

00:40:15 But I think we could.

00:40:16 I think this is one of these options where the WebAssembly build is totally portable.

00:40:21 And so if we build it, we can distribute it.

00:40:24 And then websites that want to do something like this could just download it from our servers and run it.

00:40:29 So I think there's a lot of potential here.

00:40:34 And it's at the potential stage, right?

00:40:36 This is another stepping stone to bigger and better things.

00:40:40 Our kind of responsibility as the core team is to enable it.

00:40:43 And now we really want people to come in and pick this up and do awesome things with it.

00:40:48 Firstly, so we can figure out what gaps still need to be filled, but also just to expand the growth in the reach of Python, to bring it into places that currently doesn't exist or can't work, and give it new life and new places, open it up to new people.

00:41:03 This is fantastic.

00:41:05 Congratulations.

00:41:06 - And so the work for this primarily done by Katie Bell, Christian Himes, and Ethan Smith.

00:41:12 So I think Christian got to do all the merge commits, but it's definitely been a number of people working on this for a while.

00:41:18 Those are the primary three.

00:41:22 - I'm really excited for the possibility for this.

00:41:24 I think one of the things that could be amazing, obviously running it in the front end is a thing that could be done.

00:41:31 I saw the documentation said it was about 10 megs to download it.

00:41:35 I'm sure you can put that on like a CDN.

00:41:37 So you kind of hit it once somewhere for a particular version of Python.

00:41:41 That's pretty good.

00:41:42 You know, we all have pretty fast things these days.

00:41:44 - Yeah, it's still bigger than Doodle.

00:41:46 - Yeah.

00:41:48 What gets me really excited though is putting that into an ElectronJS app.

00:41:52 - Yeah, absolutely.

00:41:53 - Right?

00:41:54 Because ElectronJS is a really interesting way to bring web technologies across platform.

00:41:59 As much as I'm like, oh, it's an Electron app.

00:42:02 Still, it's really opened up the possibility for a lot of things.

00:42:05 But it really has meant, OK, you're doing TypeScript, you're doing JavaScript, and you just have to go full on in that world.

00:42:11 So here, you could still do your front end and whatever.

00:42:14 But having the core logic of that desktop app being in Python running in this, that's exciting if that can be put together.

00:42:22 - I should also add two things.

00:42:23 Pyodide is a project that people have probably heard of before, which has been working this for considerably longer than the core team has.

00:42:30 And so I think a lot of the patches that needed to happen have come from them.

00:42:34 And they now get to spend more time focusing on the data science stack, which because they've got ports of NumPy and pandas and other libraries to actually do data science in the browser.

00:42:46 And the other interesting thing that I saw was someone from from Condor Forge suggesting that they could elevate was wasn't builds to their kind of automated level.

00:42:56 And so all of conda forge may suddenly become available to use in the browser on top of a build of Python like this.

00:43:03 Wow.

00:43:04 That would unlock so much. That would be incredible.

00:43:07 Interesting.

00:43:08 I imagine initially would unlock a lot of bug reports.

00:43:11 But we need to work through those first.

00:43:14 Yeah, I was just thinking of, you know, take the top 1000 most popular packages.

00:43:19 Could you get 90% of those compiled to like other WebAssembly things that then could be included and then imported here somehow. - Exactly.

00:43:27 And the top 1000 with native code, because it's only the native code, right? The Python code still compiles in the browser just like it would in the CPython interpreter.

00:43:36 It's only the native code that has to be ported and built.

00:43:40 And so once that's done, then you know, we're up and running. So the top 1000 is probably more than you need. - Yeah, absolutely.

00:43:47 All right.

00:43:48 Awesome.

00:43:48 I'm looking forward to seeing where this goes.

00:43:50 So many neat options.

00:43:52 There's, there's just cool ways to say like ship the Python runtime, the places where maybe it would have been hard to get.

00:43:58 Now you drop this WASM file plus something that can run WASM.

00:44:02 And then now you've got a deployable shippable CPython runtime without TK enter and a few things, but still you might not miss it.

00:44:09 Depending on what you're doing.

00:44:11 I mean, most apps are not TK enter apps is all I'm saying.

00:44:14 I'm not trying to bang on it.

00:44:15 No, no.

00:44:16 But I just haven't every time it comes up that it's still there.

00:44:20 I'm like, really? We still have that. OK.

00:44:22 Don't ask me what I've been spending my week working on.

00:44:26 Brian, it's not going to make you happy.

00:44:29 Are you are you creating a TK enter base killer for against textual?

00:44:33 No, no, unfortunately not.

00:44:38 Awesome. All right.

00:44:42 Well, Brian, are we at extras?

00:44:43 We are at extras.

00:44:45 Do you want to kick us off?

00:44:46 I will kick us off.

00:44:47 So I've got a couple of things that I think are interesting.

00:44:51 Let's start with this one.

00:44:52 We've talked about, Oh, Oh, my Z shell.

00:44:56 Right.

00:44:56 Yeah.

00:44:57 A lot.

00:44:57 Love it.

00:44:58 I just came across, realizing that actually this is a Portland company that puts together the sort of core maintainers of, that, so I just thought it was funny to give a quick shout out to, play to Argon.

00:45:12 They're not really in the Python space, but they're in Portland, which I thought That was kind of fun.

00:45:16 And then, what is this?

00:45:18 This next one comes to us, I think, via PyCoders.

00:45:22 That's where I got this.

00:45:24 Django just reformatted all of Django with black.

00:45:27 I know I was just having a discussion with somebody like, oh, your code doesn't have, doesn't follow pep8.

00:45:32 Or like, oh, I don't want it to follow pep8.

00:45:34 Yeah, but if people are gonna use your code, you know, like literally you gotta import it, then it probably should follow, like it should not come up with all sorts of warnings.

00:45:41 And so I thought it was interesting that Django just said, everything, make it black.

00:45:45 Steve, what do you think about that?

00:45:48 - I'm totally on board with just using black on everything.

00:45:51 I don't agree 100% with the style, but I agree 100% with not arguing about it.

00:45:56 So, it's close enough. - Exactly.

00:45:59 Yeah. - It's close enough.

00:46:00 - Yeah, plus there's enough tweaks that make it good.

00:46:04 I'm really grateful that you can tweak the line length, for instance. - Yes.

00:46:10 - Because, I mean, here's an example.

00:46:12 What if I want it really short?

00:46:13 So for, no, seriously, for formatting the code for the pytest book, I wanted them all quite a bit shorter so that they fit better in a book format.

00:46:25 And I could use black to cover with that and convert everything with black to make them like that.

00:46:31 So it was great.

00:46:32 - Nice, awesome.

00:46:33 All right, and the final one is I have been doing some stuff with more fun things on YouTube, trying to put these little short videos together.

00:46:41 So here's a how long is it?

00:46:42 Six minutes, 44 second video on using time delta to get like how many weeks are in some time span.

00:46:49 You know, the cool tricks you can do there.

00:46:51 So people should check that out.

00:46:52 That's my latest Python short thing.

00:46:54 And yeah, that's it for my extras.

00:46:57 - Okay, so I've got a quick one.

00:47:00 Just I've got, I don't have a graph, something to throw up, but I just, I was looking at the get history of a repo and trying to figure out whether I included one of my coworkers branches in it, if I merged it yet or not, things like that.

00:47:15 And I was on the command line and I just learned, I'm like, can I just do this with the command line?

00:47:20 Apparently I didn't know this exists.

00:47:22 So apparently a get log dash dash graph just shows you the get graph, your branch history or the branch graph on the command line.

00:47:31 And I didn't know it was there until today.

00:47:33 I started using it, tweeted about it.

00:47:36 And then a whole bunch of people said, oh, you should use these flags too.

00:47:40 that makes it even nicer.

00:47:41 So it's fun to learn something old as a new thing.

00:47:46 And then somebody else told me, how about GitK?

00:47:50 So GitK is a graphical browser of your repository that just comes with most Git installs that I didn't know was there.

00:48:01 I'm like, do I need to install it?

00:48:02 I'll just type it and see what happens.

00:48:04 And it popped up this graphical interface.

00:48:06 I'm like, this is great.

00:48:07 This is exactly what I wanted.

00:48:09 So, GitK is pretty cool.

00:48:10 - I didn't know about that one.

00:48:11 I've seen the command, I've never actually run it to see what happens.

00:48:14 So, (laughs)

00:48:17 was not feeling quite brave enough.

00:48:19 (laughs)

00:48:21 - Did it mean GitKill or was it something else?

00:48:22 (laughs)

00:48:25 - I was just most Git commands scare me until I've run them the first hundred times or so.

00:48:29 - How about you?

00:48:30 - Yeah, I got a couple of extras.

00:48:31 Okay, can I get my screen back up there?

00:48:33 There's, I was feeling a little bad about, you know, being a bit self-serving here, but then Michael just promoted his video series.

00:48:39 So I don't feel too bad anymore.

00:48:40 - Get it on man.

00:48:41 - This is the Python 3.11 Alpha 5 download page.

00:48:44 And we have a new addition this time round, which is this Windows Installer for ARM64.

00:48:49 So ARM64 is not a massive, massive platform for Windows yet, but it's growing and we wanna have Python support on it.

00:48:57 So the builds have been running in the background for a while but we've never actually released it.

00:49:01 We're hoping to get it out with 3.11.

00:49:03 that is going to depend largely on do people use it?

00:49:07 Do they love it? Do they hate it?

00:49:09 My experience so far with it has been that it is noticeably faster on at least on the arm 64 devices I've had access to compared to the Intel devices, which is really, really cool.

00:49:22 And that's like the test suite is kind of 30 to 50 percent faster, which is huge, huge, really.

00:49:30 So so I think there's a lot of potential here.

00:49:31 I may just have had awesome hardware.

00:49:33 I'm not sure it was a virtual machine, so it's kind of hard to tell.

00:49:35 Yeah, but this is fantastic.

00:49:38 This is new.

00:49:39 If you have an arm 64 device like a Surface Pro X or there's a couple out there from other manufacturers.

00:49:45 I'm running Windows 11 arm on my MacBook Pro through parallels.

00:49:50 I then use please in download and install it and let let me know how it goes.

00:49:55 If you get it through the Windows store, which is currently still not public, you need to get the the link from basically from one of my tweets to the Windows Store, you'll automatically get the ARM64 version on ARM64 as well.

00:50:07 So this installer is the traditional one.

00:50:09 Otherwise, you get it through the store.

00:50:12 The other thing which I wasn't going to do, and then I spent a bit of time working on this a couple couple of years back at the at the Core Dev Sprints.

00:50:22 I forget who I was chatting with.

00:50:23 I was chatting with one of the other core devs about everyone typing from collections, import deck and misspelling it.

00:50:30 And it's like you tell, you know, so a deck DQE is double ended queue, very useful data type for certain purposes, but people would type it deck, like deck as in DECK.

00:50:39 Because it's phonetically what it sounds like.

00:50:41 Exactly. And so as, as a bit of a joke, I made a package that when you, when you installed it, it would give you from collections import deck.

00:50:50 and obviously the thing that that collection should be is a, a deck, a double ended queue of 52 cards representing the cards in a normal deck.

00:50:59 And over time, for various reasons, it's just kind of grown.

00:51:01 And and I recently, you know, added support for calculating poker hands to it.

00:51:06 And so now you can build a game with this.

00:51:08 It does. It uses enums.

00:51:10 It's got shuffling, dealing.

00:51:13 Jokers are optional and you can calculate a poker hand.

00:51:17 And yeah, my little compare them poker hand one greater than poker hand to.

00:51:22 I spent a lot of time.

00:51:24 Most of my work on this over the last week was writing the tests that proved how incorrect that function was until I wrote the test for it.

00:51:31 But now at this point, yeah, you can look at the values it gives back. It's actually a tuple with an enumeration saying what the hand is and then a selection of the card values in a way that makes the tuples comparable. So you can actually look and see, you know, it's a pair of aces that will have the number 14 there for the ace and the next highest card was a 10. So if someone else has has a pair of aces and their next highest card was a nine, then you're still going to compare higher.

00:51:58 So I'm pretty proud of that function.

00:52:00 >> Yeah, that's clever.

00:52:01 >> But yeah, this is and it's code style block.

00:52:04 >> Nice. Very nice.

00:52:07 >> It's one short file.

00:52:09 It does still override deck in the collections module for you.

00:52:13 >> I love it.

00:52:17 >> So that deck isn't there.

00:52:19 It's like DQE is untouched.

00:52:22 But if you try and import DECK from collections, then you'll get it.

00:52:26 - Nice.

00:52:27 Hey, one other quick thing to shout out.

00:52:28 We're hiring contractors to help develop features for pypi.org.

00:52:32 It says at the top of pipi.org.

00:52:34 That's, do you know anything about this?

00:52:36 I guess if people want to work on pipi.org, that's pretty neat.

00:52:39 - Yeah, no, they have funding.

00:52:41 And there is a post that describes the surveys.

00:52:45 I believe this is the organizational accounts project they're looking at.

00:52:49 Yeah, organization accounts.

00:52:51 So if like me, you are kind of the one of the primary Python people at your company, then you'll spend a lot of time helping people publish packages to PyPI if that's the business you're in.

00:53:03 Certainly is for us.

00:53:05 There's a lot of packages from Microsoft up on PyPI.

00:53:08 And the kind of corporate account for that is--

00:53:12 it does exist.

00:53:13 We have a user account with 483 projects.

00:53:17 This is all manually curated right now, Because PyPI just doesn't have the functionality to kind of hand out permissions to it safely.

00:53:24 The teams and all that kind of stuff.

00:53:26 Yeah.

00:53:26 So I believe the idea of this is to add that functionality to PyPI.

00:53:32 So I would love it if someone comes along and does this.

00:53:35 I believe we've contributed some of the funding towards this.

00:53:38 So, you know.

00:53:40 Yeah, looks like it.

00:53:41 So Steve, I've got a 3.11 question for you.

00:53:44 So 3.11 is in alpha.

00:53:46 So what does that mean really?

00:53:48 Does that mean I can like start using 3.11 or should I wait?

00:53:51 It means you can. It means we still may change stuff that will break you and we won't apologize.

00:53:59 Okay, but if my code runs, can I trust it?

00:54:03 Yeah, if all of your tests pass, then you should be able to trust it fairly well.

00:54:10 Certainly existing code.

00:54:11 There will be new features available in the alpha that have not been as thoroughly tested yet or may change again.

00:54:17 But again, if you're running existing code, you won't be using those.

00:54:21 So that won't matter.

00:54:23 But yeah, it's totally viable to use.

00:54:25 You can specify 3.11 dev on GitHub Actions.

00:54:28 I believe it compiles from source when you do that now.

00:54:32 They don't have a build there.

00:54:33 They should for beta.

00:54:34 Beta is when we really want people to start doing stuff.

00:54:37 At this point, alpha is so that people can test the new features, kind of targeted testing on anything new that we've put in.

00:54:44 Beta is when we really want people to start porting libraries, especially kind of the core libraries, to be able to work with it.

00:54:53 And just test it.

00:54:54 Because if existing code doesn't work on the beta, we want to hear about that so we can fix it in the runtime and not force you to fix it in your code.

00:55:02 OK, but if I'm like a package maintainer, I can start-- if it's got GitHub Actions for it, I can start testing, having my CI test against 3.11, then 2.

00:55:10 Absolutely.

00:55:11 You will likely want to mark it as it's okay if it fails.

00:55:14 - Okay. - Yeah, awesome.

00:55:16 - Okay, thanks.

00:55:17 Should we do a joke?

00:55:19 - Let's do a joke.

00:55:21 Let's do a joke.

00:55:22 All right, so this one coming from the programming humor one and it's a, like you talked about the visualization stuff, Brian.

00:55:29 And this one it says, there's a search that says, how to get labels on MATLAB bar charts to be horizontal.

00:55:37 Look what the result came back from Google was.

00:55:40 says, "You're not alone, help is available.

00:55:42 If you're experiencing difficult thoughts, please call 116-123, or if this is an emergency, call 999." (laughing)

00:55:50 And the underlying bit here is, "It isn't that drastic, Google, but thanks." (laughing)

00:55:56 And I believe it might also work on Bing, I'm not sure.

00:55:59 There's a, if you scroll down, I think there's a Bing equivalent down here.

00:56:03 Yeah, not just Google, Bing thinks you're an emergency.

00:56:06 So, well, yeah.

00:56:08 (laughing)

00:56:10 - That's awesome. - Wow.

00:56:11 - Yeah.

00:56:12 So it's not that much of an emergency.

00:56:15 I'll go to Stack Overflow.

00:56:17 - Nice to know that the big search engines are looking out for our mental health.

00:56:21 - That's right.

00:56:22 People become very upset after failing to get those bar charts in your result.

00:56:26 (laughing)

00:56:27 This is not the emergency, but it's coming next when you realize what the answer is.

00:56:30 Something, I don't know.

00:56:31 (laughing)

00:56:34 Anyway, that's the joke I found for us, guys.

00:56:36 - Well, thanks everybody.

00:56:38 Thanks, Steve, for coming.

00:56:39 And thanks, Michael, again.

00:56:40 Yeah.

00:56:41 Thanks for having me.

00:56:42 Thanks, all.

00:56:43 Bye.

00:56:44 Bye.

00:56:45 Bye, everyone.

00:56:46 Thanks for listening to Python Bytes.

00:56:47 Follow the show on Twitter via @PythonBytes.

00:56:48 That's Python Bytes as in B-Y-T-E-S.

00:56:51 Get the full show notes over at PythonBytes.fm.

00:56:54 If you have a news item we should cover, just visit PythonBytes.fm and click Submit in the nav bar.

00:56:59 We're always on the lookout for sharing something cool.

00:57:02 If you want to join us for the live recording, just visit the website and click Live Stream to get notified of when our next episode goes live.

00:57:09 That's usually happening at noon Pacific on Wednesdays over at YouTube.

00:57:13 On behalf of myself and Brian Okken, this is Michael Kennedy.

00:57:17 Thank you for listening and sharing this podcast with your friends and colleagues.

