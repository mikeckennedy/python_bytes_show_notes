00:00:00 Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:04 This is episode 191, recorded July 14th, 2020.

00:00:09 I'm Michael Kennedy.

00:00:10 And I'm Brian Okken.

00:00:11 And welcome, special guest Ines.

00:00:12 Hi.

00:00:13 It's great to have you here.

00:00:14 So I want to kick this off with a cool IoT thing.

00:00:19 Now, IoT and Python, they've got a pretty special place.

00:00:23 Because when I think about Python, I think of it as not being something that sort of competes with assembly language and really, really low level type of programming for small devices.

00:00:33 But, you know, amazing people put together MicroPython, which is a reimplementation of Python that runs on little tiny devices.

00:00:42 And we're talking like $5 microchip type devices, right?

00:00:46 Have either of you all played with these?

00:00:47 No.

00:00:48 No, I haven't.

00:00:49 But I've been seeing a bit of this from my brother.

00:00:51 So he's pretty amazing.

00:00:53 Like, he's a bit younger than me.

00:00:54 He's an event technician.

00:00:55 And he recently taught himself programming and everything just so he can build stuff on these, like, tiny raspberry pies.

00:01:02 And, like, I don't know.

00:01:03 He's doing super advanced stuff.

00:01:04 It's been really interesting to see him learn to program.

00:01:07 And he's also, he's incredibly good.

00:01:09 He has, like, amazing instincts about programming, even though he's never done it before.

00:01:12 But, like, so I've been kind of watching this from afar.

00:01:14 And it made me really want to build stuff.

00:01:16 So I'm very curious.

00:01:17 Yeah, I've done the CircuitPython on some of the Adafruit stuff.

00:01:22 Exactly.

00:01:22 So I always just want to build these things.

00:01:25 I'm like, what could I think of that I could build with these cool little devices?

00:01:28 I just, in my world, I don't have it.

00:01:31 Maybe if I had a farm, I could, like, automate, you know, like, watering or monitoring the crops.

00:01:36 Or if I had a factory.

00:01:38 But I just don't live in a world that allows me to automate these things.

00:01:41 Do you have pets?

00:01:42 Maybe you can build something for pets.

00:01:44 We generally don't have pets.

00:01:46 But we are fostering kittens for the summer.

00:01:48 So I could put a little device onto one of the kittens, potentially.

00:01:52 GPS tracker.

00:01:55 Yeah.

00:01:56 So in general, you have to get these little devices, right?

00:01:59 You've got the US PyCon.

00:02:01 We got the Circuit Playground Express, which is that little circular thing.

00:02:05 It's got some 10 LEDs and a bunch of buttons and other really advanced things like motion sensors and temperature and so on.

00:02:13 Probably the earliest one of these that was a big hit was the BBC Microbit, where I think every seventh grader in the UK got it.

00:02:20 Some grade around that scale got one of these.

00:02:23 And it really made a difference in kids seeing themselves as a programmer.

00:02:27 And interestingly, especially women were more likely to see programming as something they might be interested in in that group where they went through that experience.

00:02:37 So I think there's a real value to work with these little devices.

00:02:39 But getting a hold of them can be a challenge, right?

00:02:43 You've got to physically get this device.

00:02:44 That means you have that idea of I want to do this thing and then I have to order it from Adafruit or somewhere else and then wait for it to come.

00:02:51 And my experience has been I'll go there and I'm like, oh, this is really cool.

00:02:54 I want one of these.

00:02:55 Oh, wait, no, it's sold out right now.

00:02:56 You can order it again in a month.

00:02:58 Right.

00:02:58 So getting is a challenge.

00:02:59 And also, if you're working in a group of, say, like you want to teach a high school class or a college class or something like that, and you want everyone to have access to these.

00:03:10 Well, then all of a sudden, the fact that maybe it costs $50 wasn't a big deal.

00:03:15 But if it's $50 times 20 or 100 kids, then all of a sudden, well, maybe not.

00:03:20 So I want to talk about this thing called Device Simulator Express.

00:03:24 So this is a plug in or extension or whatever the things that I think is extensions that VS Code calls them that makes VS Code do more stuff.

00:03:33 And it's a open source free device simulator.

00:03:37 So what you can do is you just go to the Visual Studio Code extensions thing and you type device probably is sufficient, but device simulator express.

00:03:44 And it'll let you install this extra thing inside of VS Code that is really quite legit.

00:03:51 So it gives you a simulated Circuit Playground Express, a simulated BBC Microbit.

00:03:58 And the most impressive to me is the clue from Adafruit, which actually has a screen that you can put graphics on.

00:04:06 So really, really cool way to get these little IoT devices with Circuit Playground, Circuit Python.

00:04:13 So Adafruit's fork of MicroPython on there.

00:04:17 What do you guys think?

00:04:17 See that picture?

00:04:18 Look how cool that is.

00:04:19 Yeah, so you can write Python in one tab and then just have the visualization in the other.

00:04:25 That's pretty cool.

00:04:26 Yeah.

00:04:26 Yeah, exactly.

00:04:27 And it's very similar to, say, what you might do with Xcode and iPhones, where you have an emulator that looks quite a bit like it or what you would do on the Android equivalent.

00:04:37 I actually think this is a little bit better than the device because it's actually larger, right?

00:04:41 Like the devices are really small, but here's like, you know, you could be like a huge thing on your 4K monitor with a little clue device.

00:04:48 So you can simulate Circuit Playground Express, BBC MicroBit, and the clue in here.

00:04:52 And we just say new project, and it'll actually write the boilerplate code for the main.py or code.py or whatever it's called that the various thing is going to run.

00:05:02 And like you said, Ines, on one half, it's got the code, and the other half, it has the device that you can interact with.

00:05:07 I was thinking that a couple of cases that would be great is, like you were saying, trying to get a hold of it.

00:05:13 But you might not even know if the concept that you're going to use is really going to work for the device you're thinking of.

00:05:19 So this would be a good way to try it out, to try out whether the thing you're thinking of trying for your house or whatever would actually work for this device.

00:05:27 The other thing was, yes, you brought up education and that it's big.

00:05:33 I was thinking about a couple of conferences where they tried to do the display and try to have a camera or something.

00:05:40 Yes.

00:05:40 Sometimes it works and sometimes it doesn't.

00:05:43 This way you could just do a tutorial or in a teaching scenario and everybody could see it because it's just going to be displayed on your monitor.

00:05:51 Right.

00:05:52 Your standard screen sharing would totally work here.

00:05:53 That's a good point as well.

00:05:55 And it doesn't have to be all or nothing.

00:05:56 Actually, what's really interesting is this thing isn't just an emulator, but you can do debugging.

00:06:01 You can set like a breakpoint and like step through it running on the device simulated or you can actually run it.

00:06:07 If you had a real device plugged in, you can run it on there as well and then do debugging and breakpoints and stuff on the actual device.

00:06:13 So it's like you tested here.

00:06:14 I always admire people who actually use like the proper debugging features.

00:06:18 I know VS Code has like so much of this and I'm always like I should use this more, but I'm like, okay, print.

00:06:23 Print, print.

00:06:25 Yeah.

00:06:26 There's some really cool libraries that will actually do that.

00:06:29 I can't remember what it's called, but Brian and I recently covered one that would actually like print out a little bit of your code and the variables as they change over time.

00:06:36 It was like the height of the print debugging world.

00:06:39 It was really, really cool.

00:06:40 I wish I could remember.

00:06:41 Do you remember, Brian?

00:06:42 No, we actually covered a couple of them.

00:06:44 I know.

00:06:44 I know.

00:06:45 That's a problem.

00:06:47 We cover thousands of things in here.

00:06:48 So another thing that's interesting is like, okay, so you see the device.

00:06:52 Some of them have buttons and they have lights and you can imagine maybe you could touch the button, but they also have things like temperature,

00:06:57 gyro meter type things or like you moving it or motion sensing or even like if you shake it,

00:07:02 this thing has little ways to simulate all that stuff.

00:07:07 So you can like have a temperature slider that freaks it out and says, hey, the temperature is actually this on your temperature sensor and so on.

00:07:13 So all the stuff that the devices simulate are available here.

00:07:16 Oh, that's cool.

00:07:16 Yeah.

00:07:16 So I actually had the team over on Talk Python not long ago.

00:07:20 So people can check that over at talkpython.fm.

00:07:23 And yeah, I'm also really excited about what you got coming here next, Brian.

00:07:27 What is that?

00:07:28 Yeah.

00:07:28 Well, speaking of, I guess, debugging versus test.

00:07:31 We didn't really talk about testing.

00:07:33 Anyway, I'm really excited.

00:07:34 We should have talked about testing.

00:07:35 Yeah.

00:07:36 So I was just, I was thinking it.

00:07:38 I was thinking that, that I hardly ever use a debugger for my source code, but I use a debugger all the time when I'm debugging my tests.

00:07:47 I don't know.

00:07:48 It's just something different about it.

00:07:50 But I've been running a lot of tests and debugging a lot of tests lately because pytest 6, the candidate release is out.

00:07:57 Now, by the time this episode airs, I don't know if the release candidate will be released or just the release candidate still.

00:08:05 But it's, you can install it, we'll have instructions in the show notes, but essentially you just have to say 6.0.0 RC1 and you'll get it.

00:08:15 So there's a whole bunch of stuff that I'm really excited about.

00:08:18 There's a lot of configuration that you used to be able to put in lots of places in your pytest Any or your setup config or tox any or something.

00:08:27 pytest 6 will support pyproject.toml now.

00:08:30 So if you jumped on the Toml bandwagon, you can stick your pytest configuration in there too.

00:08:35 There's a lot of people excited about the type annotations.

00:08:38 So the 6.0 is going to support type annotations.

00:08:41 So it actually was a lot of work.

00:08:43 There was a volunteer that went through and added type annotations to a bunch of it, especially the user facing API.

00:08:49 And why this is important is if you're type checking, you're running mypy or something over your source and everything, your project, why not include your tests?

00:09:02 But if pytest doesn't support types, it doesn't really help you much.

00:09:06 So it will now.

00:09:08 So that's really, really cool addition.

00:09:09 What this is basically the API of pytest itself is now annotated with types.

00:09:15 Yes.

00:09:15 And well, a lot of the internal code as well.

00:09:18 So they actually went through and did a lot.

00:09:20 There was a lot of work.

00:09:21 And if you look at the conversation chain, it went on for, it was a month, several month project.

00:09:27 Wow.

00:09:28 What does that mean for compatibility?

00:09:30 Does that make pytest like 3.6 only and above?

00:09:33 I think the modern versions of pytest really already are 3.6 and above.

00:09:37 I'm not sure about that.

00:09:39 Right.

00:09:39 So then the door was open to use that because otherwise it would cut.

00:09:42 I mean, it would be a weird move to like release a completely new version with Python 2 backwards compatibility.

00:09:50 Like that's like, you wouldn't do that.

00:09:53 Right.

00:09:53 I mean, it's, it's, I think, well, I think the message it sends, it's like not great.

00:09:57 I totally agree.

00:09:58 Totally agree.

00:09:58 There is a pinned version of pytest.

00:10:01 I don't remember which one it is.

00:10:02 That is still supports 2.7 if you're on it, but no new features are going in there.

00:10:08 The thing I'm really excited about is the, is a, is a little flag they've added called no header.

00:10:13 So don't use this.

00:10:15 Most people don't use this.

00:10:17 When you run pytest, it prints out some stuff like the version of Python, the version of pytest, all the plugins you're using, a bunch of information about it.

00:10:25 All this stuff is really important for logging.

00:10:28 If you're, if you're capturing the output to save somewhere or do a deep, a bug report or something, that information is great to help other people understand it.

00:10:36 What I don't like about that is that it, it's not helpful if you're writing tutorials or if you're writing code to put on a slide or something.

00:10:46 All that extra stuff just takes up space and it distracts.

00:10:49 Yeah.

00:10:49 Like I've had students say, like, I ran it, I think pytest in PyCharm and it has like some kind of output just stating where it is and what it's doing.

00:10:58 They're like, this didn't work for me.

00:11:00 I'm like, well, that was just random output from the tool.

00:11:02 You're not actually supposed to try to run that part.

00:11:04 You know what I mean?

00:11:05 But it's, it's, I mean, I saw why they saw that.

00:11:07 But at the same time, like the ability to just say like, these details don't matter in the longterm.

00:11:11 Yeah.

00:11:12 Yeah.

00:11:13 So I'm, I'm excited about that to trim it down.

00:11:16 There was a plugin called TLDR.

00:11:18 Too long.

00:11:19 Didn't read.

00:11:20 But it, it actually didn't take enough of the header off than I wanted.

00:11:23 So I had my own tool that would do this, but now I've got this, which is great.

00:11:29 So a lot of the configuration, there is a chance for human error if you type something wrong and you type a variable name wrong.

00:11:36 And so I really like this new, a new flag called strict config, which will throw an error.

00:11:43 If you have the pytest section of your configuration has something that it doesn't recognize.

00:11:48 And it probably is just, you've misspelled some variable or something.

00:11:52 Yeah, that's good to know.

00:11:53 And then not too, I can't remember the version, but it was, I think it was in pytest 5.

00:11:58 They added some code highlighting stuff that.

00:12:00 Yeah, that's super cool.

00:12:01 I discovered that just the other day.

00:12:02 I like just somehow updated all my dependencies in some environment and suddenly pytest output was colored.

00:12:07 And I was like, whoa, this is amazing.

00:12:09 Yeah.

00:12:10 Yeah.

00:12:10 The syntax highlighting.

00:12:11 I love it.

00:12:12 Nice.

00:12:12 But there's times where you don't want that, I guess.

00:12:15 Oh yeah, sure.

00:12:15 Yeah.

00:12:15 So there's a new flag to turn it off.

00:12:18 And then a little tiny detail that I really like is the diff comparisons on pytest are wonderful,

00:12:24 but apparently they didn't do recursive comparisons of data classes and adder classes, but now they do.

00:12:31 So that's neat.

00:12:31 There's a whole bunch of new features, there's fixes.

00:12:34 I ran through some of the features I really liked.

00:12:37 There are deprecations and it's a large list of breaking changes and deprecations.

00:12:42 That's why they went to a new number, pytest 6.

00:12:45 But I went through the whole list and I didn't see anything that was like, oh, that's going to stop me.

00:12:50 I'm going to have to change something.

00:12:51 Okay.

00:12:51 That's good to know.

00:12:52 Like, I mean, if you say, oh, there was nothing that like we're using, I feel confident that maybe there's nothing in my code either.

00:12:58 And I knew that somebody was going to ask, is my pytest book still valid?

00:13:02 Yes, it is.

00:13:04 I'm going through it right now.

00:13:05 I haven't gone through the whole thing yet to make sure.

00:13:07 The side that is not compatible is not the book.

00:13:10 The book's fine.

00:13:10 It's, I have a plugin that now is broken.

00:13:14 So pytest check still works.

00:13:17 But if you depend on X fail, pytest, this is a, wow, this is a corner case.

00:13:22 But if you depend on pytest check and the X fail feature of it, it doesn't work right now.

00:13:28 So I'll have to fix that.

00:13:29 So you would say X fail fails temporarily?

00:13:31 Yeah.

00:13:32 It actually marks everything as a pass.

00:13:35 So if you mark X fail.

00:13:36 Oh, wow.

00:13:36 That's like X fail-ception.

00:13:38 Yeah.

00:13:39 Yeah.

00:13:40 It's really bad.

00:13:42 Anyway, I'll have to get back to that.

00:13:44 Yeah.

00:13:44 This is really exciting that pytest 6 is out.

00:13:46 Super cool.

00:13:47 I know that there were some waves, some uncertainty in the ecosystem.

00:13:51 So it sounds like that got ironed out.

00:13:53 Things are going strong.

00:13:54 New versions coming out.

00:13:54 I even saw that Guido had tweeted the announcement, retweeted the announcement and said,

00:14:00 yay, type annotations coming in pytest.

00:14:02 Of course, he's been all about type annotations these days.

00:14:05 We'll come back to that later in the show, actually.

00:14:07 So Ines, I know you work a lot with text, but are you frustrated with it?

00:14:10 What's the story of this name here?

00:14:11 Oh, my point of the day.

00:14:14 Yeah.

00:14:16 Text attack.

00:14:17 Text attack.

00:14:17 What does text attack?

00:14:17 What else about it?

00:14:17 I thought I'd present something for my space, obviously.

00:14:20 Yeah.

00:14:21 Awesome.

00:14:21 Yeah.

00:14:21 There's this new framework that I came across and it's called text attack.

00:14:24 Yay.

00:14:25 And it's a framework for adversarial attacks and data augmentation for natural language processing.

00:14:31 So what are adversarial attacks?

00:14:33 You've probably, you might've actually seen a lot of examples of it.

00:14:37 For instance, an image classifier that predicts a cat or some other image, even though you show it complete noise and you somehow trick the model.

00:14:45 Or you might've seen people at protests wearing like funny shirts or masks to trick facial recognition technology.

00:14:52 So really to trick the model into, to like, you know, not recognize them.

00:14:57 Or the famous example of Google Translate suddenly hallucinating these crazy Bible texts.

00:15:03 If you just put in some complete gibberish, like just gah, gah, gah, gah.

00:15:07 And then it would go like, the Lord has spoken to like the people, stuff like that.

00:15:11 That's amazing.

00:15:13 I include a link to an article by a researcher who explains like why this happened and shows the example.

00:15:20 But it's, it's pretty fascinating, but I think it all comes down to like the fundamental problem of like, what, how do you understand a model that you train?

00:15:29 And what does it, you know, what does it mean to understand your model?

00:15:32 And how does it behave in situations when it suddenly gets to see something that it doesn't expect at all?

00:15:37 Like gah, gah, gah, what does it do?

00:15:38 And the thing with neural network models is you can't just look at the weights.

00:15:42 They're not linear.

00:15:43 They're like, you know, you can't just look at what your model is.

00:15:47 You have to actually run it.

00:15:48 And so the, that library takes the tack that lets you actually try out different types of attacks from the academic literature and different types of inputs that you can give a model to see whether it produces something that you're like not happy with.

00:16:03 Or that's like really weird and exposes some problems in your model.

00:16:07 And it also lets you then, because normally what's the goal?

00:16:10 The goal is, well, you do that and then you find out, oh damn, like if I suddenly feed it this complete nonsense or if I feed it Spanish text, it like goes completely in the wrong direction and suddenly predicts stuff that's not there.

00:16:22 And if you, you know, if you deployed that model into like a context where it's actually used, that would be pretty terrible.

00:16:28 And, you know, there are much worse things that can be happening.

00:16:30 So you can also create more robust training data by like replacing, replacing words with synonyms.

00:16:36 You can swap out characters and just, you know, see how the model does.

00:16:41 So I thought that was very cool.

00:16:42 And yeah, I thought in general, I think adversarial attacks, it's a pretty interesting topic.

00:16:46 And yeah.

00:16:47 Yeah, it's super interesting.

00:16:49 So the idea is basically you've trained up a model on some text and for what you've given it, it's probably working.

00:16:54 But if you give it something you weren't expecting, you want to try that to make sure that it doesn't go insane.

00:17:00 Yeah, exactly.

00:17:02 And it can do, it can expose very unexpected things like the Bible text, for example.

00:17:05 That sounds really bizarre when you like first hear it.

00:17:08 But one explanation for that would be that, well, especially it happens in low resource languages where, you know,

00:17:13 we don't have much text and especially not much text translated into other languages.

00:17:18 But there's one type of text that has a lot of translations available and that's the Bible.

00:17:23 And so they're parallel corpora where you have one text, one line in English, one line in Somali, for example.

00:17:30 And then people train their models on that.

00:17:32 But one thing that also is very specific about Bible text is that some Bible text has some words that like really only occur in a Bible text.

00:17:40 But it uses some really weird words.

00:17:42 So what your model might be learning is if I come across a super unexpected word that's really, really rare, that must be Bible.

00:17:49 And also, also the objective is you want your model to output a reasonable sentence.

00:17:53 So the model's like, well, okay, you know, if that's the rare word, then the next word needs to be something that matches.

00:17:59 And then you have like this bizarre sentence from the Bible, even though you typed in ga ga ga.

00:18:03 And that happens.

00:18:05 Yeah, how funny.

00:18:06 Yeah.

00:18:06 Yeah.

00:18:07 So it looks like they have actually a bunch of trained models already at the text attack model zoo, they call it, I guess.

00:18:15 Yeah.

00:18:15 Yeah.

00:18:16 Everything's called the model zoo.

00:18:17 Yeah.

00:18:18 And so you can just take these and run it against it, like the movie reviews from Rotten Tomatoes or IMDb or the news set or Yelp.

00:18:28 And just give it that kind of data and see how it comes out, right?

00:18:32 Exactly.

00:18:32 Yeah.

00:18:32 I think that's pretty cool.

00:18:33 And yeah, and then you can actually, you can also generate your own data or load in your data and generate data that maybe, you know, produces a better model or like covers things that your model previously couldn't handle at all.

00:18:45 So that's the data augmentation part.

00:18:47 Yeah, that's all very important.

00:18:48 And I think it's also very important to understand the models that we train and, you know, really try them out and think about like, what do they do and how are they going to behave in like a real world scenario that we care about?

00:18:59 Because, yeah, the consequences.

00:19:00 Right.

00:19:01 Because as soon as you're making decisions on this data, right?

00:19:03 Yes, of course.

00:19:03 On these models.

00:19:04 Yeah.

00:19:04 I guess as soon as a human is convinced that the model works and they start making decisions on it, right, that could go bad if the situation changes or the type of data.

00:19:15 And especially if the model is bad, like I'm always saying, like, well, people are always scared of these dystopian futures where like we have AI that can, I don't know, know anything about us and predict anything and works.

00:19:26 But the real dystopia is if we have models that kind of don't work and are really shit, but people believe that they work.

00:19:34 That's much more.

00:19:35 It's not even about whether they work.

00:19:37 It's about whether people believe it.

00:19:38 And then, you know, that's where it gets really bad.

00:19:40 And yeah.

00:19:41 Yeah.

00:19:41 Yeah.

00:19:42 And that's way more likely.

00:19:43 Yeah.

00:19:44 Yes.

00:19:45 It's a more difficult world to test this sort of stuff to figure out.

00:19:50 What does it mean for a model to be bad?

00:19:52 How do you tell if it's bad?

00:19:53 And models can be both working with some data sets and produce gibberish with or, yeah, I guess in this case, the reverse, not produce gibberish if you pass in gibberish.

00:20:07 Yeah.

00:20:07 Actually, yeah.

00:20:08 I just realized it ties in very well with the pie test point earlier and just like, yep.

00:20:12 Machine learning is quite special in a way that it's code plus data.

00:20:15 Code, you can test, you can have a function and you're like, yay, that comes in.

00:20:18 That's what I expect out.

00:20:20 Easy.

00:20:20 Write a test for it.

00:20:21 You know, it's not that easy.

00:20:23 Testing is hard, but like fundamentally, yeah.

00:20:25 It's somewhat deterministic.

00:20:27 Yeah.

00:20:28 Right.

00:20:28 And even if it's not, there's like something you can, you know, test around it and it's much harder with the model.

00:20:34 Yeah.

00:20:34 Yeah, for sure.

00:20:35 All right.

00:20:36 Before we get to the next item, just want to let you know this episode is brought to you all by us.

00:20:41 Over at Talk Python Training, we have a bunch of courses.

00:20:44 You can check them out.

00:20:45 And we're actually featured in the Humble Bundle that's running the Python Humble Bundle right now.

00:20:49 So if you go to talkpython.fm/humble2020, you can get $1,400 worth of Python training tools and whatnot for 25 bucks.

00:20:59 So that's a pretty decent deal.

00:21:01 And Brian, you mentioned your book before.

00:21:03 Tell people about your book real quick.

00:21:04 Yeah.

00:21:04 So Python Testing with pytest is a book I wrote and it's still very valid, even though it was written a few years ago.

00:21:11 The intent was the 80% of pytest that you will always need to know for any version of pytest.

00:21:17 And I've had a lot of feedback from people saying a weekend of skimming this makes it so that they understand how to test.

00:21:25 It's a weekend worthwhile.

00:21:26 Yeah, absolutely.

00:21:27 And Ines, you want to talk a little bit about Explosion just to let people know?

00:21:30 Yeah.

00:21:30 So, I mean, some of you who are listening to this might know me from my work on spaCy, which is an open source library for NLP and Python, which I'm one of the core developers of.

00:21:40 And yeah, that's all free open source.

00:21:42 And we're actually just working on the nightly version or the pre-release of spaCy 3, which is going to have a lot of exciting features.

00:21:51 I might also mention a few more things later on.

00:21:54 And yeah, so maybe that's already going to be out by the time this podcast officially comes out.

00:22:00 Maybe not.

00:22:01 I don't want to overpromise.

00:22:02 But yeah, you can definitely try that out.

00:22:04 And we also recently released a new version of our annotation tool, Prodigy, which comes with a lot of new features for annotating relations, audio, video.

00:22:13 And the idea here is, well, once you get serious about training your own models, you usually want to create your own data sets for your very specific problems that solve your problems.

00:22:22 But often the first idea you have might not be the best one.

00:22:24 It's a continuous process.

00:22:25 You want to develop your data.

00:22:27 And Prodigy was really designed as a developer tool that lets you create your own data sets with a web app, a Python backend.

00:22:35 You can script.

00:22:36 That's our commercial tool.

00:22:37 That's how we make money.

00:22:38 And it's very cool to see a growing community around this.

00:22:42 So yeah, that's what we're doing.

00:22:43 We have some more cool stuff planned for the future.

00:22:45 So stay tuned.

00:22:46 Yeah, people should check it out.

00:22:48 Actually, you and I talked on Talk Python 202 about building a software business and entrepreneurship.

00:22:53 You had a bunch of great advice.

00:22:54 So people might want to check that out as well.

00:22:55 Do you actually know these episode numbers by heart?

00:22:58 Or did you look that up before?

00:22:59 Some of them I know, but that one I used the search.

00:23:01 Okay.

00:23:02 I remember you were on there.

00:23:03 I remember what it was about, but not the number.

00:23:05 I just put together that I know two people from Explosion.

00:23:08 So that's interesting.

00:23:09 Yeah, it's Sebastian.

00:23:10 Sebastian.

00:23:11 Yeah, he was on your podcast recently, which I feel really bad.

00:23:15 I wanted to listen to this because he advertised it with like, it will tell the true story

00:23:20 behind his mustache, which I really wanted to know.

00:23:22 But then I was like, I'll need to listen to this on the weekend.

00:23:25 And I forgot.

00:23:25 So yeah, if he's listening, I'm sorry.

00:23:27 I will definitely, I need to know this.

00:23:29 So I will listen.

00:23:29 Excellent.

00:23:30 So don't spoil it.

00:23:31 Do a great work on FastAPI.

00:23:34 All right.

00:23:35 Speaking of people that have been on all the podcasts as well as Brett Cannon, he recently

00:23:39 wrote an interesting article called, What is the Core of the Python Programming Language?

00:23:45 And he's legitimately asking as a core developer, what is not the maybe lowest level, but what

00:23:52 is the essence, I guess, is maybe the way to think about it.

00:23:55 Oh, wow.

00:23:56 I only just got the core, core pun.

00:23:58 Like it did not occur to me when I first read the article.

00:24:01 I'm really, I feel really embarrassed now.

00:24:03 To be fair, English is not my first language, but still, it's not about that.

00:24:06 Anyway, sorry for interrupting.

00:24:09 When I first read it, I was thinking like, okay, we're going to talk about what is the

00:24:12 lowest level.

00:24:14 And yeah, okay, it's probably C and C eval.h, C eval.c and so on.

00:24:18 But really the thing is, Brett has been thinking a lot about WebAssembly.

00:24:23 And what does that mean for Python in the broad sense?

00:24:26 He and I talked about it on Talk Python.

00:24:28 I think at the very last PyCon event, we did a live conversation there about that.

00:24:34 And it's important because there's a few areas where Python is not the first choice, maybe

00:24:42 not the second choice, sometimes not even the 10th choice of what you might use to program

00:24:47 some very important things like maybe mobile, maybe the web, the front end part of the web,

00:24:54 importantly, I mean.

00:24:55 So there's a few really important parts of technology where Python doesn't have much reach, but all

00:25:02 of those areas support WebAssembly these days, right?

00:25:05 And if you have something in C, you can compile it to WebAssembly.

00:25:09 So there's some thought about like, well, what could we do potentially to make a WebAssembly

00:25:16 runtime for Python so that Python magically almost instantly gets access to what was just JavaScript

00:25:24 front end frameworks space and what is mobile, iOS and Android and all those things allow you

00:25:32 to directly run JavaScript as part of your app?

00:25:34 So how would we make that happen?

00:25:36 So it's pretty important, right?

00:25:38 If we could solve that problem, like Python is already so popular and its growth is so incredible.

00:25:42 Like what if we could say, oh, yeah, and now it's an important language on mobile and it's

00:25:47 an important front end language framework like that would just take it to the next level or

00:25:51 maybe a couple levels up if you do them both.

00:25:53 And WebAssembly seems to be one of the keys to kind of bridge that gap, right?

00:25:57 So Brett talks about in this article how for so long we've just had CPython is what we

00:26:04 think of when we have Python.

00:26:05 Sometimes people use PyPy, P-Y-P-Y, as a partially JIT compiled version, sometimes faster version

00:26:14 of Python, but not always because the way it interacts with C, libraries that you might be

00:26:19 using through packages and so on.

00:26:22 And really, it's a lot of Python's dynamic nature makes it hard to do outside of an interpreter

00:26:26 where, to be clear, WebAssembly is a compiled language, right?

00:26:31 So if you're going to put it over there, maybe it's going to require it to be compiled.

00:26:34 So this is a really interesting thing to go through and read and think about with Brett.

00:26:38 He talks about things like, well, how much of the Python language would you have to implement

00:26:42 and still consider it to be valid Python?

00:26:45 Like we talked about MicroPython and usually don't people look at, they don't look at that

00:26:49 and go, that's not Python.

00:26:50 That's fake, right?

00:26:51 No, like it's Python, but it's not as much Python, right?

00:26:53 You don't have the same, all the APIs on MicroPython as you do on regular Python.

00:26:58 So questions like, do you still need a REPL?

00:27:01 Could you live without locals, right?

00:27:04 The ability to ask what the local variables are and so on.

00:27:06 So he said he didn't really have a great bunch of, a great answer.

00:27:11 It's more of a philosophical, like we need to solve this.

00:27:13 But I do want to share some of my thoughts on this.

00:27:16 And I feel like maybe what we could do is we could come up with like a standard Python

00:27:22 language definition that is a subset of full Python, right?

00:27:27 Here's the essence.

00:27:28 Like, okay, we have to be able to create classes.

00:27:30 We have to be able to create functions.

00:27:31 You have to define strings.

00:27:32 Probably you want type annotations.

00:27:33 But do you need a vowel?

00:27:35 Maybe, maybe not.

00:27:37 Right?

00:27:38 So like that, if you could have a subset of the language that was smaller, as well as the standard library, because do you really need to like parse CSS hex colors?

00:27:49 Everywhere?

00:27:50 Probably not.

00:27:51 It's a very underused part of the library, but it's in there.

00:27:54 Right?

00:27:55 So if we could narrow it down, maybe it would be easier to think about how does it go to WebAssembly?

00:27:59 How does it go to like some kind of JavaScript runtime or something like that?

00:28:03 And if it sounds crazy, you know, the .NET people did this.

00:28:05 They have a .NET standard class library language.

00:28:09 They got it running on WebAssembly.

00:28:10 So it's, there's an example of it out there and something that's kind of sort of similar.

00:28:15 Right?

00:28:16 So I think this would just open stuff up if you could get Python in these places.

00:28:21 What do you guys think?

00:28:21 Initially, I was never so sold on WebAssembly until, and especially WebAssembly and Python until I watched Dave Beasley live code a compiler at PyCon India, I think it was.

00:28:33 And I was like, oh, this is kind of, this is kind of fun.

00:28:35 And I mean, it was just also fun to watch Dave Beasley live code a compiler.

00:28:40 Yeah, for sure.

00:28:40 Classic.

00:28:42 But so that did get me thinking.

00:28:45 I do think one question I think we should ask ourselves is like, well, do we really, do we really need Python to do all of the things in the browser?

00:28:53 Like, is this really, does this really have a benefit that like actually makes a difference?

00:28:58 A, B, there are a lot of things people use Python for that just wouldn't work in that way.

00:29:03 And that's also, I think, part of what makes Python so popular in the first place.

00:29:07 Like, for instance, you know, all the interactive computing environments.

00:29:10 That's why people want to use Python for data science.

00:29:14 Yeah, I Python, Jupyter Notebooks, that sort of stuff.

00:29:17 That's why, you know, Python as a dynamic language made so much sense to people.

00:29:21 And that's what made it popular.

00:29:23 And large scale processing, like a lot of the type of stuff we're working on.

00:29:26 It's like, yeah, there's stuff that you can run in the browser, but it's never going to be viable to run large scale information extraction in the browser because you want to run that on a machine for like a few hours.

00:29:37 But I think there are a lot of opportunities also in the machine learning space for privacy preserving technologies that already exist.

00:29:43 I think from what I understand, Mozilla is working on some features built into the browser, where, you know, you can have models predicting things without it being sent to someone's server.

00:29:53 And I think that's obviously very powerful.

00:29:55 That's an interesting idea.

00:29:57 Right.

00:29:57 Yeah.

00:29:57 Yeah.

00:29:58 Because if you could have a little bit of machine learning.

00:30:00 Yeah.

00:30:01 But you don't have to give up the data privacy aspect of it.

00:30:03 That's pretty cool.

00:30:04 Yeah.

00:30:04 So I think for that, there's a lot of potential here for running Python in a browser.

00:30:07 Yeah.

00:30:08 Well, we start getting used to saying what is Python is what is the CPython implementation.

00:30:13 And we got to remember CPython is the reference implementation for the language spec.

00:30:19 And I think, I guess we're kind of getting at maybe we need to split it up and have a, like a core language spec and an extended one or something.

00:30:30 I don't know.

00:30:30 The, where would you divide the line?

00:30:32 Because we've seen, like you said, we've seen things like CircuitPython and, and other things.

00:30:36 And we've actually talked about several smaller languages based on Python that just try to be the same syntax.

00:30:43 But at which point is it, when is it not Python anymore?

00:30:48 And there's at least some of the stuff.

00:30:50 Like I could totally see having a distribution of Python that doesn't have a REPL still count.

00:30:56 I could totally see not having idle, for instance.

00:31:00 If something doesn't ship with idle, is it still Python?

00:31:02 I think so.

00:31:04 And because of idle, then you need Tkinter and, or you need TK stuff in there.

00:31:09 And there's a lot of stuff that maybe I would be in like, you know, could you live without locals?

00:31:14 Most of the time, probably.

00:31:16 I actually think this would be since the web and since mobile is so, such a big part of our lives.

00:31:23 And it will be for a while.

00:31:24 This might be a decent dividing line to say whether or not it's for WebAssembly or not.

00:31:29 Maybe we should split the division at whatever we need to implement a WebAssembly version of Python.

00:31:35 And anything above that line is an extended version of Python or something.

00:31:41 Yeah.

00:31:41 Yeah, that's a good point.

00:31:42 All right.

00:31:43 I don't want to go too long at this section because I want to make sure we get the others.

00:31:47 But I do want to leave you with just some thoughts.

00:31:48 What if shipping Python was just shipping a single binary and a thing that ran it?

00:31:53 You could do that with WebAssembly.

00:31:55 Maybe two WebAssemblies, the runtime plus the code.

00:31:58 What if all the browsers had capability to plug in alternate runtimes through WebAssembly?

00:32:05 So right now you have a JavaScript engine.

00:32:06 But what if, like, say, Firefox and Edge and whatnot came up with a way to say, here's a WebAssembly API to plug in alternate runtimes, Python, Ruby, .NET, Java, you name it, and then shipped with the latest version of each of those runtimes.

00:32:24 So you just don't have to download.

00:32:25 Like, the big problem now is you can do it, but you've still got to download, like, 10 megs per page, which is not a good idea.

00:32:32 So anyway, I think there's a ton of interesting things that open up if this were possible.

00:32:37 So I'm glad Brett's still on this, and hopefully he keeps thinking about it.

00:32:40 Brian, I still need to learn Pathlib.

00:32:43 Really?

00:32:43 You got any ideas on how I do that?

00:32:44 Really?

00:32:44 You're not using Pathlib?

00:32:46 I'm just stuck in the OS.path world.

00:32:51 I just really need to get with the time.

00:32:53 Help me out here.

00:32:54 Okay.

00:32:54 So Pathlib is where...

00:32:55 I mean, I know the value.

00:32:56 Yeah, you're like some kind of animal, like OS.path.

00:32:58 So I have no offense to OS.path.

00:33:04 But, you know.

00:33:05 No, I really love Pathlib a lot.

00:33:07 But there is...

00:33:09 I got to tell you that the documentation for Pathlib doesn't cut it as an introduction.

00:33:13 You can find what you're looking for, but if you know what you're looking for.

00:33:17 But I agree with Chris May.

00:33:19 So Chris May wrote a post called Getting Started with Pathlib.

00:33:23 I guess it's kind of...

00:33:24 He's got a little PDF field guide that you can download, but he has a little bit of a blog

00:33:28 post introducing it.

00:33:30 But I downloaded it.

00:33:31 It's like nine or ten pages.

00:33:32 And it's actually a really good introduction to Pathlib.

00:33:36 So I really like it.

00:33:37 The big thing with OS.path versus Pathlib is Pathlib creates path objects.

00:33:42 So there's a class that represents a path that you have methods on.

00:33:45 And it makes it different for when you're dealing with this.

00:33:49 With OS.path, it's just strings.

00:33:51 So it's manipulating strings that represent paths.

00:33:54 So the object's different.

00:33:56 I like it.

00:33:57 Actually, I switched just for the ability to add buildup paths with just having the slash operator.

00:34:03 Yeah, it's really interesting how they've overridden division.

00:34:06 But I think it's a good example of where this makes sense.

00:34:09 It's a reasonable use case.

00:34:10 It looks good.

00:34:11 It's defensible.

00:34:12 There are other cases where you're like, oh, did you really have to overload these operators?

00:34:16 But they're fine.

00:34:17 I think that's very valid.

00:34:19 Yeah.

00:34:19 And things like how do you find parts of a path?

00:34:23 When you have to parse paths, that's where Pathlib really shines for me.

00:34:27 So if you want to find the parent of something or the parent of the second level parent,

00:34:31 there's ways to do that in Pathlib.

00:34:34 And in OS.path, you're stuck with trying to split things and stuff.

00:34:38 And it's gross.

00:34:39 I mean, there are operations to do it.

00:34:41 But it's very good to have this relative, I don't know, just all these operators, like parent.

00:34:47 And then one of the things that it took me a while to figure out was I was used to trying to find the absolute path of something.

00:34:55 And in Pathlib, finding the absolute path is the resolve method.

00:34:58 So you say resolve and it finds the absolute path for you.

00:35:02 You can find the current working directory.

00:35:04 You can go up and down folders.

00:35:05 You can use globs.

00:35:07 You can find parts of path names and stuff.

00:35:10 And it's just a really comfortable thing.

00:35:12 So I think you should give it a whirl.

00:35:14 And it's not like it's going to change your life a lot.

00:35:18 But the next time you come up with, when the next time you're programming, you're like, okay, I got to figure out, I got to have a base directory and some other directory.

00:35:25 Well, I'll reach for Pathlib instead of OS.path.

00:35:28 Yeah.

00:35:29 I guess it has been there since 3.4, so I should give it the times.

00:35:32 Yeah.

00:35:32 So, I mean, now, before I could see the objection of, like, oh, you have to backport it.

00:35:36 And also, I think what I like as well is a lot of integrations that, like, you know, automatically can perform checks where the path exists, stuff like that.

00:35:44 Or for me as a library author, you know, you're writing stuff for users and you want to give them feedback.

00:35:49 And, for instance, in a library like Click or Typer, which is the modern type hint version CLI interface, which was also built by my colleague, Sebastian, you can just say, hey, this argument is a path.

00:36:01 What you get back from the command line is a path.

00:36:03 It will check that a path exists via Pathlib.

00:36:06 So it does, like, you know, a whole bunch of magic there.

00:36:10 Yeah.

00:36:10 That is super cool.

00:36:11 Yeah.

00:36:12 Or you can say it can't be a directory.

00:36:14 And then you write your CLI, user passes in an invalid path, and you don't even have to do any error handling.

00:36:19 It will automatically, before it even runs your code, say, nope, that argument is bad.

00:36:24 So that's pretty cool.

00:36:25 That's awesome.

00:36:25 And you don't have to care about Unix versus Mac or PC or something like that.

00:36:30 Yeah.

00:36:30 I mean, Windows.

00:36:31 I mean, no offense to Windows, but it's always handling paths and Windows is always the classic story.

00:36:37 Also, as a library author, where you just, well, we're supporting all operating systems.

00:36:41 But, like, well, Windows just does it a bit differently.

00:36:43 And you cannot assume that a slash means a slash.

00:36:47 Yeah, for sure.

00:36:48 All right.

00:36:49 Well, the final item is yours, Ines.

00:36:51 And it's definitely interesting.

00:36:53 So if you're working in the machine learning data science side of things, it might not be enough to just back up your algorithms and your code, right?

00:37:01 Yeah.

00:37:02 You also have, yeah, machine learning is code and data.

00:37:04 So, yeah.

00:37:05 So this is something we discovered a while ago and that we're now using internally.

00:37:10 Internally, so we currently, as I mentioned before, we're working on version three of spaCy.

00:37:13 And one of the big features is going to be a completely new optimized way for training your custom models, managing the whole end-to-end workflows from pre-processing to training to packaging and also making the experiments more reproducible.

00:37:27 You want to train a cool model and then send it over to your colleague and your colleague should be able to run the same thing and get the same results.

00:37:34 Sounds really basic, but it's pretty hard in general in machine learning.

00:37:37 So our spaCy stuff will also integrate with a tool called DVC, which is short for data version control, which we've started using internally for our models.

00:37:47 And DVC is basically an open source tool for version control, specifically for machine learning and for data.

00:37:54 So, you know, you can't really, you can check your code into a Git repo as you're working on it, but you can't just check your data sets and models and artifacts into Git or your model weights.

00:38:03 Like that's, so it's very, very difficult normally to keep track of changes and your files.

00:38:08 You kind of, most people just end up with this directory of files somewhere and it can be very frustrating.

00:38:13 And so you can really, you can think of DVC as Git for data and the command line usage is actually pretty similar.

00:38:18 So like you type Git in it and DVC in it to initialize it.

00:38:22 And then you can do DVC add to start tracking your assets and add them.

00:38:27 So it's like, I think if, yeah, if you're familiar with Git as like abstract, it can be at times, you will also kind of find it easy to get into DVC.

00:38:35 And it basically lets you track any assets like data sets, models, whatever, by adding meta files to your repository.

00:38:44 So you always have like the checksum in there and you always have these checkpoints of the asset, even though you're not actually checking that file into your repo.

00:38:52 And that means you can always go back, fetch whatever it was from your cache and rerun your experiments.

00:38:59 And it also builds this really cool dependency graph.

00:39:02 So you can really have these complex pipelines with different steps.

00:39:06 And then you only have to rerun one step if some of the inputs to it have changed.

00:39:12 So, you know, in machine learning, you'd often have pipeline, like you start, you download your data, then you pre-process it.

00:39:19 Then you convert it to something, then you train, then you run an evaluation step.

00:39:24 And everything sort of depends on each other.

00:39:26 And that can make things like really hard.

00:39:28 And you never know, you usually have to run everything, you know, clean from scratch.

00:39:33 Because, yeah, if something changes, your whole results change.

00:39:36 So if you set up your pipelines with DVC, it can actually decide whether something needs to be rerun.

00:39:42 Or it can also know what needs to be rerun to reproduce exactly what you're trying to do.

00:39:47 So that's pretty cool.

00:39:48 Yeah, that could save you a ton of time and money if you're doing it in the cloud.

00:39:51 Yes, exactly.

00:39:52 Yeah.

00:39:53 And, you know, you can share it with other people.

00:39:55 It's like, it's, I think it definitely solves a problem that's very real.

00:39:58 And, yeah, the people making DVC, they've also recently released a new tool that I have not personally checked out yet.

00:40:04 But it looks very interesting.

00:40:05 It's called CML, which is short for Continuous Machine Learning.

00:40:08 And that's really more of the CI, which kind of is logically the next step, right?

00:40:12 You manage everything in your repo.

00:40:14 And then you obviously want to run automated tests and continuous integration.

00:40:18 So the previous looked really cool.

00:40:21 Like it showed kind of a GitHub action where you can submit a PR with like some changes to your code and your data.

00:40:28 And then you have the bot commenting on it and it shows like accuracy results and a little graph and how stuff changes.

00:40:34 So it's really like these code coverage bots that you've probably seen where like you change some lines and then it tells you, oh, coverage has gone up or down and, you know, the new view of your code.

00:40:45 So that's what it looks like.

00:40:47 So I think, yeah, I'm really excited about this.

00:40:49 And definitely it solves a problem.

00:40:50 It's already been solving a problem for us.

00:40:52 And yeah.

00:40:52 How does it store the large files?

00:40:54 I know it has this cache.

00:40:55 Is that a thing that you host?

00:40:56 Does it have a hosted thing that's kind of like GitHub?

00:40:59 I'm not sure if you could.

00:41:01 You probably connected to some cloud, but like normally you have that locally.

00:41:03 It also has a cool thing where you can actually download files via the tool.

00:41:07 And then depending on where you're fetching it from, if it's a Google storage bucket or S3 bucket or something, you can actually also tell if the file has changed and whether it needs to be redownloaded.

00:41:17 And so, for example, internally, what we're doing is we're mounting a Google storage, Google cloud storage bucket or however they call it locally as like, you know, so it's like kind of a drive you have access to locally.

00:41:30 And then you can just sort of type GS, blah, blah, blah, blah, and then the path and really work with it like a local file system.

00:41:36 And that's pretty nice.

00:41:38 So you can, you know, you can have, you can work with private assets because the thing is a lot of toy examples assume that, oh, you just download a public data set and then you train your model and then you upload it somewhere.

00:41:47 But that's not very realistic because most of the time the data you have can't just go in the cloud publicly.

00:41:52 So, yeah.

00:41:54 But yeah, I think I don't even know exactly how it works in detail, but like it can basically tell fetch, I think from the headers or something, it can tell whether the file you're downloading has changed and whether there's something new.

00:42:04 Yeah.

00:42:05 Yeah.

00:42:05 With a normal version control, one of the reasons we use it is to try to find what's different.

00:42:09 Can you do, do you do diffs on data or?

00:42:12 I don't know.

00:42:13 Maybe.

00:42:14 I mean, I'm not sure if there's, I think the main diff is more like around the results that you get because diff, I mean, diffing large data set, diffing weights, you kind of can't.

00:42:25 That's really where we are.

00:42:26 The other problem where like you need to run the model to find out what it does and then you're diffing accuracies rather than weights.

00:42:33 Okay.

00:42:34 I don't know if it does like actual diffing of the data sets, but often the thing that changes is really the models.

00:42:38 Like you have the, you know, you have your whole data and then you change things about your code.

00:42:44 Yeah.

00:42:44 And something changes and it's, you want to keep track of what it is or how it manifests.

00:42:48 Yeah.

00:42:49 It's really cool to see them working on this.

00:42:50 Yeah.

00:42:51 So, and also we'll be in, in spaCy 3.

00:42:53 We'll hopefully have a pretty neat integration where, you know, if you want, it's not like mandatory, but if you say, Hey, that's cool.

00:42:59 That's how I want to manage my assets.

00:43:00 You can just run that in your, in a spaCy project and then it just automatically tracks everything.

00:43:06 And it, you know, you can check that into Git and share it and other, other people can download it.

00:43:11 So that's, yeah, I'm pretty excited about that.

00:43:13 It works pretty well so far.

00:43:14 Yeah.

00:43:15 Everything you can do to make it a little easier to work with spaCy and just make it reproducible.

00:43:19 Yeah.

00:43:20 And it's just, the things are hard.

00:43:21 Like there is, I'm not a fan of these all one click, everything just magically works.

00:43:25 Like it looks, it looks nice and it's a nice demo, but like once you actually get down to like the real work, like things need to be a bit modular.

00:43:32 Things need to be customizable.

00:43:33 Otherwise you're always hitting edge cases or you have these leaky abstractions.

00:43:37 So yeah.

00:43:39 Yeah.

00:43:39 I think things should be easy to use, but you can't just magically cover everything by just providing one button.

00:43:45 That's just not going to work.

00:43:47 Yeah.

00:43:47 Cause when it doesn't work, it's not good anymore.

00:43:49 Yeah, exactly.

00:43:49 All right.

00:43:50 Yeah.

00:43:51 All right.

00:43:52 Well, that's our six items that we go in depth into, but at the end, we always just throw out a couple of really quick things that maybe we didn't have time to fit into the main section.

00:44:01 And I want to talk about two things that are pretty exciting.

00:44:05 One is if you care about podcasts as a catalog of a whole bunch of things, I don't know how many podcasts there are.

00:44:13 There's probably over a million podcasts these days.

00:44:15 One of our listeners, Anton Ziyanov wrote a cool Python package that will let you search the iTunes directory and query it.

00:44:24 And it's basically a Python API into iTunes podcasting directory.

00:44:29 You know, some people think that you've got to be part of the Apple ecosystem to care about iTunes, but really that's just the biggest like directory kind of Yahoo circa 1995 style of listing of podcasts.

00:44:42 So if you care about digging in and researching podcasts, check that out.

00:44:45 That's pretty cool.

00:44:46 And then, yeah.

00:44:48 And then I've also, I'm such a big fan of f-strings.

00:44:51 How about you too?

00:44:51 Yes.

00:44:52 Yes.

00:44:52 F, yes, right?

00:44:54 Yeah.

00:44:54 I'm finally, I'm finally working in like Python three only.

00:44:57 I remember, I think last time I was on the podcast, I was basically, I was saying how like, oh, all these modern things, they're so nice.

00:45:03 I wish I could use them more, but we're still supporting Python two, but like, no, everything I write now, 3.6.

00:45:09 Yes.

00:45:09 And I've talked previously about a tool called Flint, F-L-Y-N-T, which lets you run against an old code base and convert all the various Python two and three styles of formatting magically into Python three.

00:45:22 I think that was actually really nice.

00:45:24 The episode I was.

00:45:25 Yeah.

00:45:25 You might've been right.

00:45:26 Like, I wish I could run this.

00:45:28 Right.

00:45:28 Yeah.

00:45:28 And yeah, I ran that against like 20,000 lines of Python.

00:45:31 I found like just a couple errors reported them.

00:45:33 They got fixed.

00:45:34 So that's nice.

00:45:35 But the thing that's bugged me endlessly about f-strings is I'll be halfway through writing the string and I'm like, oh yeah, I want to put data here.

00:45:42 So I got to go back to the front of the string, not necessarily back to the front of the line, but maybe back to like the string is being passed to a function.

00:45:49 So I go back to the first quote, put the F, go back forward and then start typing out the thing I actually wanted.

00:45:55 Right.

00:45:55 Or maybe I'll F string something.

00:45:57 And when I really, I, oh, I'm not going to put data.

00:45:59 Right.

00:45:59 So it's like you're halfway through and you want it to become an F string.

00:46:02 Well, PyCharm is coming with a new feature where if you start writing a regular string and pretend like it's an F string, it'll automatically upgrade to f-strings.

00:46:11 Yes.

00:46:11 Halfway through.

00:46:12 Yes.

00:46:13 Without leaving.

00:46:14 So you just say curly variable.

00:46:15 It's like, oh, okay.

00:46:16 That means that's an F string and the F appears at the front.

00:46:18 Yes.

00:46:19 Nice.

00:46:19 So that is pretty awesome.

00:46:20 Anyway, those are my two quick items.

00:46:22 Ines, I'm also excited about the one you got here.

00:46:24 Yeah.

00:46:25 This is awesome.

00:46:25 Yeah.

00:46:25 I had one, which is something coming to 3.9 or in 3.9, which is PEP 585.

00:46:31 And you can use, when you use type annotations, you can now use the built in types like list and dict as generic types.

00:46:40 So that means no more from typing import list with a capital L.

00:46:45 Yes.

00:46:46 Yes.

00:46:48 So you just literally, I mean, when I first saw it, I'm like, that looks strange.

00:46:52 But like, yes, I'm so excited about this.

00:46:55 It probably, it'd be years until I can just like use it all across my code bases because.

00:46:58 True.

00:46:59 Yeah.

00:46:59 But like, yay.

00:47:00 That's in 3.9?

00:47:01 Yeah.

00:47:02 Yeah.

00:47:03 That's in 3.9.

00:47:03 I'm already using 3.9 and I didn't know that.

00:47:06 You can do this.

00:47:06 Yeah.

00:47:07 Yeah.

00:47:07 And Guido is one of the guys on the PEP making this happen.

00:47:12 Like I said, he's really into typing.

00:47:13 Oh, that's great.

00:47:15 So this is really cool because it was super annoying to say, oh, you have this new import

00:47:18 just because you want to use type annotations on a collection.

00:47:20 Right?

00:47:21 Now you don't have to.

00:47:22 And there's actually a bunch of the collection stuff and iterators and whatnot.

00:47:25 Like the, you know, the collections module, like that, a bunch of stuff in there is really

00:47:31 nice.

00:47:32 And they're compatible, like lowercase list of str is the same as capital list of str, I believe.

00:47:38 All right, Brian, what you got?

00:47:39 Oh, I just wanted to, I'll drop a link in the show notes.

00:47:42 Testing code 120 is where I interviewed Sebastian Ramirez from Explosion also.

00:47:48 And talking about FastAPI and Typer because I'm kind of in love with both of those.

00:47:54 They're really cool.

00:47:55 Yeah.

00:47:55 Absolutely.

00:47:56 All right.

00:47:57 Well, that's a cool one.

00:47:58 Definitely going to check that out.

00:47:59 And you can find out why he has the cool mustache.

00:48:02 That's right.

00:48:04 All right.

00:48:05 So we always end the show with a joke and I thought we could do two jokes today.

00:48:10 So I think, Ines, do you want to talk about this first one?

00:48:13 Oh, yeah.

00:48:13 I mean, I'm not even sure it counts as a joke per se, but like it's more of a humorous

00:48:17 situation, I guess.

00:48:19 Yeah.

00:48:19 It ties in.

00:48:21 Well, it's Sebastian again.

00:48:24 Like he had this very viral tweet the other day where he posted about some experience.

00:48:28 I can just read it out because I think it needs to kind of stand on its own.

00:48:32 So he's right.

00:48:33 I saw a job post the other day.

00:48:35 It required four plus years of experience in FastAPI.

00:48:38 I couldn't apply as I only have 1.5 plus years of experience since I created that thing.

00:48:44 And then he says, maybe it's time to reevaluate that years of experience equals skill level.

00:48:50 And this was like, it resonated with people so much.

00:48:53 I was actually surprised to see like everyone was like, oh, yeah, HR.

00:48:56 Like apparently this seems to be this huge issue, obviously, that like, well, not most job ads

00:49:02 not written by the people who actually work with the technologies and where you have.

00:49:07 Yeah.

00:49:07 Actually.

00:49:08 Yeah, this is awesome.

00:49:09 And this tweet actually just got covered on DTNS, the daily news tech show, daily tech news show.

00:49:14 I guess it is.

00:49:15 Alongside another posting that said you needed eight years of Kubernetes experience for another job.

00:49:21 But of course, Kubernetes has only been around for four years.

00:49:24 Yeah.

00:49:24 When you say this went viral, it had 46,000 retweets and 174,000 likes.

00:49:29 That's like, that's got some traction.

00:49:31 I feel like this might be a problem.

00:49:33 Yeah.

00:49:33 Yeah.

00:49:33 I was surprised that like so many people are like, yeah, that's a big deal.

00:49:37 And it's like, and I mean, it is true.

00:49:39 Like kind of tech hiring sort of seems to be broken.

00:49:42 And it's also, it's like, it's a bit different in my case, I guess.

00:49:45 But like, I don't qualify for most roles using the tech that I write.

00:49:50 And in some cases that's justified because I'm not a data scientist just because I write developer

00:49:54 tools for data scientists doesn't mean I can do the job.

00:49:56 But in other cases, I'm like, there's kind of a ridiculous amount of arbitrary stuff you're

00:50:01 asking for in this job ad.

00:50:02 Maybe that's needed.

00:50:02 Maybe not, but like it centers around like a piece of software that I happen to have

00:50:07 written and I do not qualify for your job ad at all.

00:50:10 Like the last time I wrote a job description, I intentionally left off the college degree

00:50:18 requirement because all of the other requirements I was listing in there, either they had it from

00:50:23 college plus experience or they had it just from experience.

00:50:26 So I was fine with that.

00:50:27 By the time it actually went live, somebody in HR had added a college degree requirement

00:50:33 to it.

00:50:33 I just couldn't get away with that list in that, I guess.

00:50:36 Yeah.

00:50:37 Master's degree in spaCy is preferred.

00:50:39 In spaCy preferred.

00:50:40 Yeah.

00:50:41 But I guess another problem there is, it's like, well, look, if you ask, if HR writes these

00:50:44 job ads with these bullshit requirements, then well, who applies?

00:50:49 Like it's either people who are like, yeah, whatever, or people who are full of shit.

00:50:52 And then that's the sort of culture you're fostering.

00:50:54 And it might not even be the engineer's fault who wrote a very honest job description, but

00:50:59 like, yep.

00:50:59 Who applies to that?

00:51:00 Like, yeah.

00:51:01 You're going to make me lie about my FastAPI experience.

00:51:04 Yeah.

00:51:04 People just apply to anything.

00:51:05 I'm like, yep, I have 10 years experience in everything.

00:51:07 Great.

00:51:08 And they're like, perfect.

00:51:09 That's what we're looking for.

00:51:10 You're hired.

00:51:10 And then you wonder like, why is our company culture so terrible?

00:51:13 Hmm.

00:51:14 Well, I actually did have somebody apply to a job and say they have multiple years of experience

00:51:21 in any new language coming up.

00:51:23 Nice.

00:51:27 All right, guys.

00:51:28 Well, it looks like we're just about out of time.

00:51:29 Let me give you one more joke for it.

00:51:32 Brian, will you describe this picture and then I'll read what it says?

00:51:35 There's a poorly drawn horse, I think.

00:51:39 Zebra, horse that has white on the back end and black on the front end.

00:51:43 And the text says, I defragged my zebra.

00:51:46 I don't even know if people defrag drives anymore.

00:51:48 So this is only going to resonate with the folks that have been around for a while.

00:51:51 I saw that there was this great video I came across on YouTube where you can actually watch

00:51:55 like a live defrag session.

00:51:56 Like, I don't know, Windows 95.

00:51:57 And it's like, I don't know, it takes a few hours.

00:52:00 And, you know, you can kind of bring back that nostalgia and just put it on your TV and

00:52:03 just sit there and you're like, yeah.

00:52:05 Oh, it's like the aquarium you would put on your TV.

00:52:08 Yeah.

00:52:09 Like, but for tech.

00:52:10 Follow the show on Twitter via at Python Bytes.

00:52:13 That's Python Bytes as in B-Y-T-E-S.

00:52:16 And get the full show notes at pythonbytes.fm.

00:52:19 If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:52:23 We're always on the lookout for sharing something cool.

00:52:26 On behalf of myself and Brian Okken, this is Michael Kennedy.

00:52:29 Thank you for listening and sharing this podcast with your friends and colleagues.

