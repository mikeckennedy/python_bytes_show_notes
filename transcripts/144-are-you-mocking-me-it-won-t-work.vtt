
00:00:00.000 --> 00:00:04.960
Hello and welcome to Python Bytes, where we deliver news and headlines directly to your earbuds.


00:00:04.960 --> 00:00:12.160
This is episode 144, recorded August 20th, 2019. I'm Brian Oggen, and Michael's on vacation,


00:00:12.160 --> 00:00:15.520
but I have two awesome guest hosts. Welcome, Chris May.


00:00:15.520 --> 00:00:16.080
Hey there.


00:00:16.080 --> 00:00:18.480
And also welcome Mahmoud Hashemi.


00:00:18.480 --> 00:00:20.080
Hello, everybody. It's good to be back.


00:00:20.080 --> 00:00:26.240
So both of you have been on Test and Code, but have either of you been guests on Python Bytes


00:00:26.240 --> 00:00:26.640
before?


00:00:26.640 --> 00:00:32.160
I think I actually guest hosted once in a similar situation where Michael was on vacation


00:00:32.160 --> 00:00:33.160
or you were on vacation.


00:00:33.160 --> 00:00:34.800
I think it was me and Michael that time.


00:00:34.800 --> 00:00:36.120
So it's good to get the reverse.


00:00:36.120 --> 00:00:37.120
Cool.


00:00:37.120 --> 00:00:40.160
And I definitely never have been on Python Bytes, but it's been something I would have


00:00:40.160 --> 00:00:43.360
been excited about ever since I thought I had the opportunity.


00:00:43.360 --> 00:00:44.360
Dreams do come true.


00:00:44.360 --> 00:00:45.360
Indeed.


00:00:45.360 --> 00:00:48.240
I really appreciate both of you coming on.


00:00:48.240 --> 00:00:51.600
As a reminder to everybody, this episode is brought to you by DigitalOcean.


00:00:51.600 --> 00:00:55.840
Check them out at pythonbytes.fm/digitalocean.


00:00:55.840 --> 00:00:58.880
a $50 credit for new users, lots of good stuff.


00:00:58.880 --> 00:01:00.080
More about that later.


00:01:00.080 --> 00:01:01.080
Let's just jump in.


00:01:01.080 --> 00:01:05.720
I'm going to put Chris on the spot and have him go first since he's new here and we can


00:01:05.720 --> 00:01:06.720
heckle.


00:01:06.720 --> 00:01:07.720
Yeah, bring it on.


00:01:07.720 --> 00:01:08.720
No.


00:01:08.720 --> 00:01:15.480
Yeah, my first topic I selected was "Why Your Mock Doesn't Work" by Ned Batchelor.


00:01:15.480 --> 00:01:20.320
And it's an article that just came out like perfect timing for my team and I because there


00:01:20.320 --> 00:01:25.320
There are members on my team who are building an application


00:01:25.320 --> 00:01:28.680
that's syncing or bringing data from one database server


00:01:28.680 --> 00:01:32.980
to another across cloud platforms.


00:01:32.980 --> 00:01:35.960
Essentially, they're trying to do a test-driven development


00:01:35.960 --> 00:01:39.440
and they came to me and they're like,


00:01:39.440 --> 00:01:41.020
"How are we supposed to do this?


00:01:41.020 --> 00:01:42.260
There are all these third-party clients


00:01:42.260 --> 00:01:45.200
that we're connecting to and trying to get authorization from


00:01:45.200 --> 00:01:47.920
and all these different things."


00:01:47.920 --> 00:01:49.000
They quickly found out that mocking


00:01:46.240 --> 00:01:49.300
these third party tools was hard.


00:01:49.300 --> 00:01:51.180
I was just so thankful that Ned wrote this article


00:01:51.180 --> 00:01:56.000
to show us that one problem is that sometimes mocking,


00:01:56.000 --> 00:01:57.960
the way that they're setting up their mocks,


00:01:57.960 --> 00:02:02.520
the item that they were mocking never actually mocked


00:02:02.520 --> 00:02:05.200
the object that they were trying to mock.


00:02:05.200 --> 00:02:06.560
It's a little hard to explain in video,


00:02:06.560 --> 00:02:08.080
but, or in audio rather,


00:02:08.080 --> 00:02:11.440
but Ned actually has some great illustrations


00:02:11.440 --> 00:02:15.400
to show exactly how mocking works and when it works


00:02:15.400 --> 00:02:17.680
and how it can be messed up.


00:02:17.680 --> 00:02:18.840
- I saw those illustrations.


00:02:18.840 --> 00:02:20.360
I don't know if he's using graphvis or what,


00:02:20.360 --> 00:02:22.580
but we're definitely getting the point across.


00:02:22.580 --> 00:02:24.000
- Yeah, I was wondering,


00:02:24.000 --> 00:02:25.840
'cause I thought he did such a great job


00:02:25.840 --> 00:02:26.680
with those illustrations.


00:02:26.680 --> 00:02:29.680
I was like, how did he take the time to design those?


00:02:29.680 --> 00:02:32.120
It's good to know that there may be a tool behind that.


00:02:32.120 --> 00:02:34.000
- Well, I mean, and he's got, yeah.


00:02:34.000 --> 00:02:36.860
I mean, he used them in his Python names and values talk


00:02:36.860 --> 00:02:39.280
and blog post, and I always,


00:02:39.280 --> 00:02:41.080
like especially for beginner to intermediate programmers,


00:02:41.080 --> 00:02:43.720
I always send them to that Python names and values talk.


00:02:43.720 --> 00:02:46.360
It's a really good use of the half hour.


00:02:46.360 --> 00:02:47.200
- Nice.


00:02:47.200 --> 00:02:48.920
Hey, look, we're getting bonus content already.


00:02:48.920 --> 00:02:52.560
- Yeah, and that actually, that names and values talk


00:02:52.560 --> 00:02:55.960
actually makes you a better mock user as well,


00:02:55.960 --> 00:02:59.340
'cause it helps you understand how that all works.


00:02:59.340 --> 00:03:01.480
Plus Ned's just really good at explaining stuff.


00:03:01.480 --> 00:03:02.400
- Absolutely.


00:03:02.400 --> 00:03:04.640
The other thing I love about this article


00:03:04.640 --> 00:03:06.560
is he also links to two other resources,


00:03:06.560 --> 00:03:10.760
another article and a video where people gave examples


00:03:10.760 --> 00:03:13.000
of when you don't wanna use mocking


00:03:13.000 --> 00:03:18.000
and also good practices when you do.


00:03:18.000 --> 00:03:19.820
And one of the takeaways I took away from my team is that,


00:03:19.820 --> 00:03:23.600
especially if you're trying to mock third-party code,


00:03:23.600 --> 00:03:26.280
you're going to need to create tests


00:03:26.280 --> 00:03:27.600
that of course test your own application against the mock,


00:03:27.600 --> 00:03:31.640
but also test the mock against the third-party tool.


00:03:31.640 --> 00:03:34.480
And so this is a bunch of stuff that you're going to invest in


00:03:34.480 --> 00:03:37.200
if you want to test with mocks.


00:03:37.200 --> 00:03:38.880
If I can jump in,


00:03:38.880 --> 00:03:40.680
what I'll say, whenever you're integrating


00:03:38.760 --> 00:03:41.120
and there's an SDK or a library for integrating,


00:03:41.120 --> 00:03:45.480
chances are you're not gonna use 100% of that library


00:03:45.480 --> 00:03:46.360
or that service.


00:03:46.360 --> 00:03:47.840
You're probably gonna use a little sliver of it.


00:03:47.840 --> 00:03:49.460
I know it seems like, oh, great,


00:03:49.460 --> 00:03:50.580
they wrote all the code for me.


00:03:50.580 --> 00:03:52.940
Let me jump right in and integrate directly


00:03:52.940 --> 00:03:54.040
with their library.


00:03:54.040 --> 00:03:55.580
But it really makes sense a lot of the time


00:03:55.580 --> 00:03:57.420
to use a gateway or some other pattern


00:03:57.420 --> 00:03:59.620
to kind of like make explicit


00:03:59.620 --> 00:04:02.120
which parts of that library you use.


00:04:02.120 --> 00:04:03.540
Because eventually when you have to integrate


00:04:03.540 --> 00:04:05.700
with another service or you wanna throw it away,


00:04:05.700 --> 00:04:07.840
it's just gonna be a lot easier


00:04:07.840 --> 00:04:10.880
to sort of like maintain that side of the integration.


00:04:10.880 --> 00:04:12.720
So yeah, great posts.


00:04:12.720 --> 00:04:14.000
>>Yeah, I also like to,


00:04:14.000 --> 00:04:15.840
I think it was in this post here where you mentioned


00:04:15.840 --> 00:04:17.200
the kind of what you were saying,


00:04:17.200 --> 00:04:18.920
usually there's only a thin sliver


00:04:18.920 --> 00:04:21.200
of the functionality you need


00:04:21.200 --> 00:04:23.860
and to use, you know, to create a mock that only does that,


00:04:23.860 --> 00:04:26.560
but also to make sure that across your organization


00:04:26.560 --> 00:04:30.240
or across your team to only have one mock object


00:04:30.240 --> 00:04:33.160
that handles like that one third party tool.


00:04:33.160 --> 00:04:34.720
>>Mm-hmm, mm-hmm, definitely.


00:04:34.720 --> 00:04:36.440
>>Well, Mahmoud, what do you got for us?


00:04:36.440 --> 00:04:46.440
So what I've got for the group here is a little library/application that I ran into while doing some research for a talk that I'll get into later.


00:04:46.440 --> 00:04:49.440
But basically it's called "vermin".


00:04:49.440 --> 00:04:58.440
And the name's not really explained, but the only reason I can see behind it is that Python has snakes, and snakes are kind of vermin, and vermin kind of sounds like "version".


00:04:58.440 --> 00:05:03.440
And so what vermin is, that's like, you know, V-E-R-M-I-N.


00:05:03.440 --> 00:05:06.440
Oh wait, I just got it. It's like version minimum. Okay.


00:05:06.440 --> 00:05:13.440
So what it does is it's a rules-based Python version compatibility detector with a pretty clever name.


00:05:13.440 --> 00:05:23.440
So what it does, maybe you heard the news, but basically now all 360 top downloaded PyPI libraries now support Python 3.


00:05:23.440 --> 00:05:25.440
There's like a website for it.


00:05:25.440 --> 00:05:28.160
And the way that that's determined is, I think,


00:05:28.160 --> 00:05:32.080
Brett Cannon has a library or application which basically


00:05:32.080 --> 00:05:38.640
looks at the setup.py and then looks at the index classifiers.


00:05:38.640 --> 00:05:40.600
And so if the person who published the package


00:05:40.600 --> 00:05:44.120
says it supports Python 3, it takes it at its word


00:05:44.120 --> 00:05:46.760
and says that this library says it supports Python 3.


00:05:46.760 --> 00:05:49.040
Now, the top 360 libraries have done so,


00:05:49.040 --> 00:05:50.760
which is a pretty good milestone for us,


00:05:50.760 --> 00:05:52.480
especially as we approach 2020.


00:05:52.480 --> 00:05:54.680
But the thing is that it's based on what people say.


00:05:54.680 --> 00:05:57.320
So if you, when it comes to your own code, right?


00:05:57.320 --> 00:06:00.240
Like if you're like a team at a company


00:06:00.240 --> 00:06:02.440
or a maintainer of an application


00:06:02.440 --> 00:06:04.680
that doesn't necessarily have a setup.py,


00:06:04.680 --> 00:06:07.120
there's, you know, can I use Python 3?


00:06:07.120 --> 00:06:08.440
It's not really gonna help you


00:06:08.440 --> 00:06:10.000
'cause you don't have those classifiers.


00:06:10.000 --> 00:06:12.480
So basically, vermin, what it does


00:06:12.480 --> 00:06:16.080
is it scans over every single py file,


00:06:16.080 --> 00:06:17.400
every single module,


00:06:17.400 --> 00:06:20.140
and it tells you the minimum Python version necessary


00:06:20.140 --> 00:06:21.780
to import that module.


00:06:21.780 --> 00:06:24.360
And it even gets down to the function level.


00:06:24.360 --> 00:06:28.440
So basically you can use this to scan your code and say like, look,


00:06:28.440 --> 00:06:32.120
there's a Python 2.7 like feature being used by this function over here in this


00:06:32.120 --> 00:06:34.400
module. And then you can also certify that, Hey,


00:06:34.400 --> 00:06:39.400
this module over here uses like Python 3.5 syntax, or, Hey,


00:06:39.400 --> 00:06:43.080
that one actually is using a 3.7 thing, but we're only on 3.6.


00:06:43.080 --> 00:06:47.440
So it's rules-based, it's got over a thousand rules. It's pip installable,


00:06:47.440 --> 00:06:51.560
you pip install vermin, and it has a little command line entry point. And,


00:06:51.640 --> 00:06:55.520
Yeah, when I found it, it had like less than 80 stars on GitHub, and I'm hoping,


00:06:55.520 --> 00:06:59.080
you know, I saw how much work went into this, I'm hoping that maybe it blows up a little bit,


00:06:59.080 --> 00:07:03.160
because it's a very useful tool, and I'll explain why in my next segment.


00:07:03.160 --> 00:07:06.200
But basically, yeah, definitely check it out, Vermin.


00:07:06.200 --> 00:07:08.520
That's really cool. I mean, I could definitely see...


00:07:08.520 --> 00:07:11.720
Yeah, it sounds really cool. It sounds like a lot of work went into that.


00:07:11.720 --> 00:07:14.960
Exactly, a lot of work went into it, and it's still a little bit quirky, I'll tell you.


00:07:14.960 --> 00:07:20.880
Like, I ran it with just plain Vermin as described, and I got one result,


00:07:20.880 --> 00:07:23.600
And then I ran it with -v, which made it kind of like,


00:07:23.600 --> 00:07:26.000
it's supposed to make it more verbose, I thought,


00:07:26.000 --> 00:07:28.840
but it actually made it look harder


00:07:28.840 --> 00:07:31.280
and it came back with a more accurate result.


00:07:31.280 --> 00:07:33.320
So maybe when you run it, run it with -v.


00:07:33.320 --> 00:07:34.920
Or maybe help the guy out,


00:07:34.920 --> 00:07:37.040
I think his name is Morton Christensen.


00:07:37.040 --> 00:07:38.980
Maybe help him out and give him a PR,


00:07:38.980 --> 00:07:42.000
make the verbose act the same way as the non-verbose.


00:07:42.000 --> 00:07:43.640
But no, great tool regardless.


00:07:43.640 --> 00:07:44.920
- Ah, okay.


00:07:44.920 --> 00:07:46.640
The verbose might be more picky.


00:07:46.640 --> 00:07:47.560
Very interesting.


00:07:47.560 --> 00:07:49.240
Well, I think vermin looks cool


00:07:49.240 --> 00:07:52.840
and I'm excited about going from not just from two to three,


00:07:52.840 --> 00:07:58.560
but for instance, we now are excited about Python 3.8 features or 3.7 features,


00:07:58.560 --> 00:08:02.880
and I want to make sure that it's possible to move things around.


00:08:02.880 --> 00:08:03.640
>> Exactly.


00:08:03.640 --> 00:08:06.960
>> There's a lot of use for that and forever, I think.


00:08:06.960 --> 00:08:09.280
Anyway, I don't want to talk about a new feature.


00:08:09.280 --> 00:08:11.800
I actually want to talk about something that's been around for a while,


00:08:11.800 --> 00:08:13.960
but I don't see it a lot in code.


00:08:13.960 --> 00:08:15.980
and I just saw this recently,


00:08:15.980 --> 00:08:19.760
an article called the non-local statement in Python.


00:08:19.760 --> 00:08:21.840
I'm going to attempt this name,


00:08:21.840 --> 00:08:24.600
Abolash Raj, I think that's it.


00:08:24.600 --> 00:08:28.360
But the idea is if you use a local variable,


00:08:28.360 --> 00:08:30.720
like if you assign to a local variable,


00:08:30.720 --> 00:08:35.880
it creates a new thing in the namespace, a local name.


00:08:35.880 --> 00:08:40.240
The normal thing that everybody knows is unless you add the global.


00:08:40.240 --> 00:08:49.680
But global doesn't just make it so that you can assign a variable that's not declared in this function.


00:08:49.680 --> 00:08:53.800
It also makes it so that it's a global scope variable.


00:08:53.800 --> 00:08:56.040
And sometimes that's not really what you want.


00:08:56.040 --> 00:09:03.800
You just want it to reference, like for instance, if you got a local function defined within another function,


00:09:03.800 --> 00:09:08.080
and you want to reference or assign to an outside variable,


00:09:08.080 --> 00:09:12.040
It's really easy to see when you look at the code, but I forgot this was around.


00:09:12.040 --> 00:09:14.200
I don't use it very much, but it's pretty cool.


00:09:14.200 --> 00:09:18.600
I think I run into this occasionally and I usually just make things global.


00:09:18.600 --> 00:09:21.200
So Mahmoud, you probably have more experience than me.


00:09:21.200 --> 00:09:22.200
Do you run into this ever?


00:09:22.200 --> 00:09:23.200
Oh my goodness.


00:09:23.200 --> 00:09:26.800
So back when I was like really learning the ropes in Python, and I remember it so clearly


00:09:26.800 --> 00:09:32.760
back in like 2011, I was playing with the concept of like dynamic scope, which is in


00:09:32.760 --> 00:09:34.120
contrast to lexical scope.


00:09:34.120 --> 00:09:38.620
So that's like, like Scopuscope, you sort of look within your block or your function, right?


00:09:38.620 --> 00:09:44.820
And Dynamic Scope is this older concept where it's like, you would look up the stack for something.


00:09:44.820 --> 00:09:49.020
I think Emacs Lisp still uses this. Kind of glad that Python doesn't.


00:09:49.020 --> 00:09:54.620
But you know, in like the mad science, like, you know, mode of learning all of Python's cool features,


00:09:54.620 --> 00:09:57.020
I wanted to, you know, do something like that.


00:09:57.020 --> 00:10:01.320
Yeah, somewhere in there, I was like messing with generators and Dynamic Scope,


00:10:01.320 --> 00:10:05.080
and I found myself just hitting right into a wall and I talked to Raymond Hedger and


00:10:05.080 --> 00:10:08.680
he's like, "Oh yeah, what you want is non-local and that's going to be sometime in the far


00:10:08.680 --> 00:10:14.920
future." Yeah, anyways, I mean, here we are and it's there and frankly if I use it, I'm


00:10:14.920 --> 00:10:18.960
over that phase. So if I use it, I feel like I'm doing something wrong and I should probably


00:10:18.960 --> 00:10:24.760
like factor this in a clearer way. But that said, I'm sure it still comes up and, you


00:10:24.760 --> 00:10:27.920
know, I think everyone's probably going to have a little mad science phase of their own


00:10:27.920 --> 00:10:31.280
And so let them use non-local and deal with the consequences.


00:10:31.280 --> 00:10:35.760
Well, right. I mean, it's like one of these features that it's used so little that you're


00:10:35.760 --> 00:10:39.280
just adding complexity to the code because most people won't know what it means.


00:10:39.280 --> 00:10:40.560
Right.


00:10:40.560 --> 00:10:41.360
You got to be careful.


00:10:41.360 --> 00:10:41.920
Yeah.


00:10:41.920 --> 00:10:45.920
You know, it's still like it has its own little place and I'm sure some,


00:10:45.920 --> 00:10:51.440
like someone has a legit use for it beyond like just messing around. So I'm glad it's there still.


00:10:51.440 --> 00:10:54.320
Yeah, definitely. I'm going to take a little bit of a sponsor break


00:10:54.880 --> 00:10:58.520
and thank DigitalOcean for sponsoring this show.


00:10:58.520 --> 00:11:01.720
DigitalOcean has been a long time supporter of Python Bytes


00:11:01.720 --> 00:11:03.200
and we really appreciate it.


00:11:03.200 --> 00:11:05.500
And not only that, all of the infrastructure


00:11:05.500 --> 00:11:08.680
for pythonbytes.fm runs on DigitalOcean.


00:11:08.680 --> 00:11:10.160
We've got our website, our database,


00:11:10.160 --> 00:11:12.280
and even the audio file hosting


00:11:12.280 --> 00:11:13.800
is done through DigitalOcean.


00:11:13.800 --> 00:11:17.180
It's been wonderful, super affordable and solid.


00:11:17.180 --> 00:11:19.680
There's enough features to get us going


00:11:19.680 --> 00:11:22.540
and to let us grow, but not so many


00:11:22.540 --> 00:11:24.120
that it's too complicated.


00:11:24.120 --> 00:11:31.000
So I think it's a great platform, easy to start, easy to grow, and highly recommended.


00:11:31.000 --> 00:11:35.880
So if you'd like to give it a shot, visit pythonbytes.fm/digitalocean.


00:11:35.880 --> 00:11:41.320
It'll give you $50 free credit for new accounts, so you can give it a try.


00:11:41.320 --> 00:11:42.520
I think it's a good place to be.


00:11:42.520 --> 00:11:43.800
Get yourself a droplet.


00:11:43.800 --> 00:11:45.400
Yeah, a droplet.


00:11:45.400 --> 00:11:51.880
So let's start this all over again, and not back from the beginning, but it's Chris's turn again.


00:11:51.880 --> 00:11:53.400
So Chris, what you got?


00:11:53.400 --> 00:12:00.500
Well, this week, Microsoft announced that they've improved Python support in their Azure platform.


00:12:00.500 --> 00:12:05.700
I think in particular, they've announced general availability for a bunch of new Python things,


00:12:05.700 --> 00:12:06.600
some of which I've...


00:12:06.600 --> 00:12:13.740
So the company I work for, we've primarily used Microsoft Azure, and I've used some of these tools in beta.


00:12:13.740 --> 00:12:15.740
But so now it's available to everybody.


00:12:15.740 --> 00:12:22.680
And I'm excited because reading through the announcement from Microsoft, I wasn't 100% sure what was new.


00:12:22.680 --> 00:12:27.180
But what I was really thankful for is Brett Cannon tweeted a link to it and said,


00:12:27.180 --> 00:12:30.180
"Here are the specific points that he was excited about."


00:12:30.180 --> 00:12:33.680
The first off is that it's debuting with Python 3.6,


00:12:33.680 --> 00:12:36.680
but 3.7 support is currently being worked on.


00:12:36.680 --> 00:12:40.180
And actually, I can already see it in preview, which is nice.


00:12:40.180 --> 00:12:44.680
And especially good news for me is that 3.8 support won't take nearly as long.


00:12:44.680 --> 00:12:50.680
So I'm hoping that very shortly after they release Python 3.8, it'll be available in Azure.


00:12:50.680 --> 00:12:54.680
And then the second thing is that there's native async and await support in there.


00:12:54.680 --> 00:12:58.680
And that's pretty exciting, but really the other thing that I wanted to pull from that,


00:12:58.680 --> 00:13:02.680
that Brett didn't mention in his tweet, is that it's actually pretty impressive,


00:13:02.680 --> 00:13:05.680
like the amount of stuff that Microsoft does for us.


00:13:05.680 --> 00:13:12.680
In particular, the Azure functions, it's just amazing to me because they have a way of deploying to the web


00:13:12.680 --> 00:13:17.680
where you essentially just create a new Git remote, and you just push your code up there,


00:13:17.680 --> 00:13:22.880
there and when it goes, when your code arrives there, it essentially sticks into a Docker


00:13:22.880 --> 00:13:27.840
image and runs it for you and it's a pretty fast startup and all these things that's like


00:13:27.840 --> 00:13:32.120
so complicated I can't imagine what's all going on and you don't have to worry about


00:13:32.120 --> 00:13:33.120
it at all.


00:13:33.120 --> 00:13:37.280
You just have something that runs in your computer, you push it up and it's done and


00:13:37.280 --> 00:13:38.280
it's really, really impressive.


00:13:38.280 --> 00:13:40.520
I've never played with Azure functions.


00:13:40.520 --> 00:13:44.160
So are those kind of like Lambda functions on AWS?


00:13:44.160 --> 00:13:45.160
Yeah, they sure are.


00:13:45.160 --> 00:13:48.000
and I hear they're probably about as easy.


00:13:48.000 --> 00:13:51.000
I've never actually, I've intended to play


00:13:51.000 --> 00:13:52.540
with the Azure Lambdas.


00:13:52.540 --> 00:13:55.080
In fact, at the local Python meetup,


00:13:55.080 --> 00:13:57.880
we've had a couple people talk about how easy it is to do,


00:13:57.880 --> 00:14:00.380
and I was just thankful that here at work,


00:14:00.380 --> 00:14:02.600
I've been able to try the Azure functions.


00:14:02.600 --> 00:14:04.320
So, it's really nice.


00:14:04.320 --> 00:14:05.140
- Nice.


00:14:05.140 --> 00:14:06.320
I'll have to give that a shot sometime.


00:14:06.320 --> 00:14:07.160
- Yeah.


00:14:07.160 --> 00:14:09.280
Actually, I think Microsoft offers a free month


00:14:09.280 --> 00:14:10.800
or two month thing if you want to do it,


00:14:10.800 --> 00:14:14.200
and on top of that, the Azure functions are incredibly cheap.


00:14:14.200 --> 00:14:16.280
I just, they have a calculator up


00:14:16.280 --> 00:14:18.680
and you can check to see how much it'll cost


00:14:18.680 --> 00:14:19.720
to do certain things.


00:14:19.720 --> 00:14:22.720
And I maxed it out, like I have a function


00:14:22.720 --> 00:14:24.620
that calls a bunch of API endpoints


00:14:24.620 --> 00:14:26.040
and saves them to the database.


00:14:26.040 --> 00:14:29.600
And we realized if we did it 48 times a day


00:14:29.600 --> 00:14:32.040
against every single website that the company owns,


00:14:32.040 --> 00:14:33.880
we still would be in the free tier.


00:14:33.880 --> 00:14:36.680
So it's really impressive what you can do.


00:14:36.680 --> 00:14:37.520
- That's cool.


00:14:37.520 --> 00:14:40.040
Well, I'm kind of excited about this next topic.


00:14:40.040 --> 00:14:43.280
Like super excited because we talked about,


00:14:43.280 --> 00:14:49.440
I'll have to dig up the episode, but we did bring up awesome Python applications before.


00:14:49.440 --> 00:14:50.440
But we have an update.


00:14:50.440 --> 00:14:51.440
Well, yes.


00:14:51.440 --> 00:14:52.440
I don't remember what it was.


00:14:52.440 --> 00:14:53.840
It was testing code with Python bytes.


00:14:53.840 --> 00:15:00.040
But I remember accidentally dropping this idea on the podcast and it blew up a little


00:15:00.040 --> 00:15:01.840
bit ahead of when I expected to launch it.


00:15:01.840 --> 00:15:07.200
But yeah, so I'm here bringing an awesome Python applications update.


00:15:07.200 --> 00:15:11.040
And so basically, awesome Python applications, for those who haven't heard of it, is sort


00:15:11.040 --> 00:15:14.760
of like your standard awesome list where it's like you're on GitHub and there's a


00:15:14.760 --> 00:15:18.920
readme and there's a ton of links you know and the all these links point to


00:15:18.920 --> 00:15:24.560
applications that are free and open source Python and so at first it looks


00:15:24.560 --> 00:15:28.980
like a normal awesome list one it's actually generated from some structured


00:15:28.980 --> 00:15:34.560
yaml and you know when I started out it was like 25 applications like Zulip and


00:15:34.560 --> 00:15:38.200
Sentry sort of came to mind but then like the more I look the more I found


00:15:38.200 --> 00:15:43.200
and it grew to something like 180 by the time it went a little viral.


00:15:43.200 --> 00:15:46.200
And then these days it's like 255.


00:15:46.200 --> 00:15:49.200
Frankly, it'll hit 260 by the end of the week.


00:15:49.200 --> 00:15:52.200
And so the list keeps growing, almost faster than I can keep up with it.


00:15:52.200 --> 00:15:54.200
Thank goodness it's somewhat automated.


00:15:54.200 --> 00:15:59.200
And so this last weekend I was at the local Python conference, PyBay.


00:15:59.200 --> 00:16:01.200
Maybe see you, PyBay 2020.


00:16:01.200 --> 00:16:03.200
It was a pretty big hit there.


00:16:03.200 --> 00:16:07.200
I basically put in the show notes a link to my slides


00:16:07.200 --> 00:16:12.480
and where the video will be and whatnot. But what I did for my talk there was I


00:16:12.480 --> 00:16:16.320
took, like I said, structured YAML. So I have all of the links to all of the


00:16:16.320 --> 00:16:20.480
repos. Technically any awesome list could do this and I'm surprised that more


00:16:20.480 --> 00:16:25.640
haven't. But I went and I cloned all of the repos. And this isn't just GitHub.


00:16:25.640 --> 00:16:29.400
This is things that are on GitLab, things that are sort of like off any


00:16:29.400 --> 00:16:33.600
particular software forge. There are things that are on Bitbucket, things


00:16:33.600 --> 00:16:36.940
they're in Bazaar, you know, it's a whole mix of things and


00:16:36.940 --> 00:16:42.160
I cloned them all and it was something like 30 gigabytes of code


00:16:42.160 --> 00:16:49.720
Yeah, and these packages they date all or these applications rather date all the way back to like 1998 like mailman and G edit


00:16:49.720 --> 00:16:55.680
You know if you're gnomes or G that uses Python and 95% of them have had a commit this year 2019


00:16:55.680 --> 00:17:01.080
So these are all very active and the reason I've compiled this isn't so much that we can go use them


00:17:01.080 --> 00:17:05.560
like of course I actually used several of them without even realizing that they're Python.


00:17:05.560 --> 00:17:13.480
But the thing is that as application developers we need exemplars we can go look to for patterns in


00:17:13.480 --> 00:17:18.200
testing and documentation and architecture and packaging. Things that people do without


00:17:18.200 --> 00:17:22.760
necessarily writing a blog post about them or you know going on a podcast or giving a conference


00:17:22.760 --> 00:17:27.720
talk. So basically I went and I cloned it and I did all this analysis and this is how I found


00:17:27.720 --> 00:17:32.720
And so, Vermin, the good news here, let me just, I should have led with this, right?


00:17:32.720 --> 00:17:36.720
But the good news is that, I was surprised by this,


00:17:36.720 --> 00:17:41.720
fully two-thirds of these Python applications, which are on median,


00:17:41.720 --> 00:17:46.720
like, you know, 10 years old, two-thirds of them support and use Python 3.


00:17:46.720 --> 00:17:47.720
Wow.


00:17:47.720 --> 00:17:51.720
So, I was expecting to find that a lot of these had sort of been, you know,


00:17:51.720 --> 00:17:53.720
it's tough to maintain open source.


00:17:53.720 --> 00:17:58.520
And I thought that they would sort of have maybe fallen behind a little bit.


00:17:58.520 --> 00:18:05.120
Goodness knows that most corporations I run into, well I don't know about most, but a lot of them


00:18:05.120 --> 00:18:08.620
are still using Python 2 for their Python applications.


00:18:08.620 --> 00:18:14.920
Even Google, everyone's favorite, even Google hasn't fully ported over to Python 3 yet.


00:18:14.920 --> 00:18:19.720
So yeah, but 66% support Python 3.


00:18:19.720 --> 00:18:22.520
And I've had a bunch of other interesting findings.


00:18:22.520 --> 00:18:24.520
If you go to my slides, you can check them out.


00:18:24.520 --> 00:18:27.420
And I'll also be giving the talk at PyGotham 2019.


00:18:27.420 --> 00:18:30.620
So if you're in New York, early October, I think tickets are available.


00:18:30.620 --> 00:18:32.720
So there's so many cool things in here.


00:18:32.720 --> 00:18:36.620
And there's stuff that I knew about once and forgot about,


00:18:36.620 --> 00:18:40.120
like Eric, one of the Python IDEs.


00:18:40.120 --> 00:18:41.620
So that's fun.


00:18:41.620 --> 00:18:45.520
Yeah, I mean, the newest one I found, someone at the conference came up and told me about it,


00:18:45.520 --> 00:18:49.820
is actually, I think, nia.is or .si or something like that.


00:18:49.820 --> 00:18:54.460
it's a torrent tracker for anime. And so this particular anime fan informed me


00:18:54.460 --> 00:18:58.180
that this is one of the largest torrent trackers out. And you know, it's written


00:18:58.180 --> 00:19:01.900
in Python, it's right there on GitHub. And you know, it's not on PyPI, it's not


00:19:01.900 --> 00:19:05.020
really discoverable. You need this word of mouth to kind of find these


00:19:05.020 --> 00:19:08.860
applications and all the lessons contained therein. Like I calculated it


00:19:08.860 --> 00:19:15.100
out, over 2,000 years of project maintenance, right? Like in these repos


00:19:15.100 --> 00:19:19.260
that was just waiting to be learned from. And you know, I think the list should


00:19:19.260 --> 00:19:23.460
grow even further. So if any of the listeners have applications that they


00:19:23.460 --> 00:19:27.180
happen to know are written in Python, you know, hit me up on GitHub. I'll


00:19:27.180 --> 00:19:31.020
definitely like, you know, consider and curate. Nice. Well, this is cool. Thanks.


00:19:31.020 --> 00:19:34.940
Absolutely. It's amazing to see how much that's grown. I remember when you were on


00:19:34.940 --> 00:19:38.740
whichever podcast you're on and I was just inspired and now I'm even more so


00:19:38.740 --> 00:19:42.820
again to see like how many things have been built with Python and I still


00:19:42.820 --> 00:19:46.460
haven't reached the bottom yet. That's amazing. My dream is really to like, you


00:19:46.460 --> 00:19:49.780
make a static site for this so that you can filter because basically like I can


00:19:49.780 --> 00:19:53.560
I now have the data and I'll look at publishing this data data set somewhere


00:19:53.560 --> 00:19:57.820
but basically it's like you know show me the projects that use Docker show me the


00:19:57.820 --> 00:20:01.660
project that use PI installer show me the projects that use twisted versus


00:20:01.660 --> 00:20:05.540
whatever you mentioned asyncio right earlier and I was kind of surprised


00:20:05.540 --> 00:20:11.100
there are quite a few older projects that have actually adopted async like


00:20:11.100 --> 00:20:15.580
asyncio rather you know like and it's pretty even split between concurrent


00:20:15.580 --> 00:20:18.940
futures, twisted, tornado, G event, and async I/O.


00:20:18.940 --> 00:20:21.700
They're basically all around 20% on this list.


00:20:21.700 --> 00:20:22.780
- How about that? - Yeah, nice.


00:20:22.780 --> 00:20:24.300
- Yeah, so, check it out.


00:20:24.300 --> 00:20:28.080
- Well, I'm gonna wrap this up with a really easy one.


00:20:28.080 --> 00:20:30.340
We've talked about pre-commit several times,


00:20:30.340 --> 00:20:32.660
I think, on the show, but if you,


00:20:32.660 --> 00:20:36.580
and pre-commit is a tool to allow you to run some code


00:20:36.580 --> 00:20:38.820
before you check in your code to make sure things


00:20:38.820 --> 00:20:40.860
that are whatever, you've got a style guide


00:20:40.860 --> 00:20:43.700
or some checks or whatever you wanna do.


00:20:43.700 --> 00:20:45.420
It really is general purpose,


00:20:45.420 --> 00:20:46.980
but how do you get started?


00:20:46.980 --> 00:20:50.660
And actually this is something that I needed myself,


00:20:50.660 --> 00:20:52.940
the pre-commit documents now


00:20:52.940 --> 00:20:56.280
that just recently added a quick start guide.


00:20:56.280 --> 00:20:57.420
And I love it.


00:20:57.420 --> 00:20:59.760
I mean, it just kind of walks you through


00:20:59.760 --> 00:21:03.320
installing pre-commit, configuring it for the first time,


00:21:03.320 --> 00:21:05.260
taking a look at what the hooks are,


00:21:05.260 --> 00:21:06.340
installing the hooks,


00:21:06.340 --> 00:21:08.580
'cause you have to install the hooks also,


00:21:08.580 --> 00:21:11.140
which is something I wasn't aware of.


00:21:11.140 --> 00:21:13.300
And then the initial attempt


00:21:13.300 --> 00:21:15.580
to just run your hooks against your project.


00:21:15.580 --> 00:21:18.040
That's awesome, but I wanted to add,


00:21:18.040 --> 00:21:19.960
and one of the reasons why I wanted to bring it up


00:21:19.960 --> 00:21:22.800
on the show wasn't just because, hey, go check this out,


00:21:22.800 --> 00:21:26.660
but I'd like to add that doing this slowly is a good idea.


00:21:26.660 --> 00:21:29.520
So I tried this with like three or four or five


00:21:29.520 --> 00:21:32.860
different hooks, like Flake 8, Black, and some other things,


00:21:32.860 --> 00:21:35.840
and then let it loose on my code base,


00:21:35.840 --> 00:21:38.080
and it changed like everything.


00:21:38.080 --> 00:21:41.160
And I thought, I don't really know what's going on here,


00:21:41.160 --> 00:21:44.480
So I'd like to modify it a little bit to say,


00:21:44.480 --> 00:21:46.240
if you're adding this to a project,


00:21:46.240 --> 00:21:48.480
for each new hook, add them one at a time


00:21:48.480 --> 00:21:50.560
to your YAML file,


00:21:50.560 --> 00:21:54.160
install it and run it against your files first,


00:21:54.160 --> 00:21:56.200
and then commit that if you're happy,


00:21:56.200 --> 00:21:58.200
review the changes if you're happy with it,


00:21:58.200 --> 00:22:00.020
your test pass and all that,


00:22:00.020 --> 00:22:02.800
check them in and then move on to the next one.


00:22:02.800 --> 00:22:06.300
I think it'll be easier for the rest of your team


00:22:06.300 --> 00:22:10.160
to swallow the fact that you just changed all the files.


00:22:11.080 --> 00:22:15.080
That's great news. This is one thing when I saw it in the news, I was super excited to see,


00:22:15.080 --> 00:22:19.080
because we want to start doing this here at work.


00:22:19.080 --> 00:22:24.080
And now that I know that there is a quick start guide to do it, it makes me so much more excited to do it,


00:22:24.080 --> 00:22:29.080
because I tried messing with the GitHub hooks or the GitHooks themselves,


00:22:29.080 --> 00:22:32.080
and I'm like, "God, I really need to learn Bash."


00:22:32.080 --> 00:22:35.080
Well, not just that. They're just basically unusable in a team environment


00:22:35.080 --> 00:22:37.080
without something like this to manage them.


00:22:37.080 --> 00:22:42.840
I think Anthony Sotow kicked this off and he's really just kept running with it, you know, right out the park


00:22:42.840 --> 00:22:46.720
He's done a great job and the community as a whole actually too because anyone can contribute


00:22:46.720 --> 00:22:52.340
Sort of useful pre-commit hooks there too. That's awesome. All right, so we're that's done with our six


00:22:52.340 --> 00:22:57.000
Does anybody have any extra information they'd like to shout out? I have a couple of things


00:22:57.000 --> 00:23:04.160
I'd like to share first off the humble bundle humble bundle easy for me to say by the no starch press is


00:23:04.640 --> 00:23:09.640
throwing a special with the Python Software Foundation,


00:23:09.640 --> 00:23:13.000
where if you buy,


00:23:13.000 --> 00:23:15.000
you can get a collection of books for a certain price


00:23:15.000 --> 00:23:17.400
and the PSF gets money, which is wonderful.


00:23:17.400 --> 00:23:21.240
They can use as much money as they can get, I think.


00:23:21.240 --> 00:23:23.240
And I'm all about supporting them.


00:23:23.240 --> 00:23:25.480
And the second thing I wanted to share was,


00:23:25.480 --> 00:23:27.400
I know friends of the show, PyBytes,


00:23:27.400 --> 00:23:30.120
have released their NewbieBytes,


00:23:30.120 --> 00:23:31.680
which I know they have put in a ton of hard work into.


00:23:29.640 --> 00:23:32.000
and I'm excited for them to have got it up and running.


00:23:32.000 --> 00:23:37.080
I'm excited to, like, as somebody who runs a local Python meetup group,


00:23:37.080 --> 00:23:39.960
I'm excited that there's another resource out there to help people


00:23:39.960 --> 00:23:43.280
who are very new to Python to learn how to use it.


00:23:43.280 --> 00:23:44.360
Nice. That's cool.


00:23:44.360 --> 00:23:47.400
I didn't have anything prepared, but I mean, I guess I'll just shout out again,


00:23:47.400 --> 00:23:50.400
like, you know, I'll be doing an East Coast tour, like PyGotham


00:23:50.400 --> 00:23:53.400
and the Maintainers Conference in Washington, D.C.


00:23:53.400 --> 00:23:55.400
You know, if you want to get a ticket to one of these,


00:23:55.400 --> 00:23:57.200
I'd be happy to meet anyone out there,


00:23:57.200 --> 00:24:01.760
chat about Python and versioning and all this stuff. I should also like, you know, shout out my wife.


00:24:01.760 --> 00:24:05.600
She helped me make all the graphs for this awesome Python applications presentation.


00:24:05.600 --> 00:24:11.120
And yeah, she was using like real Python, I think, to learn a lot of the pandas to do so. She really,


00:24:11.120 --> 00:24:16.240
again, just an amazing job. So thanks, Maya. Sweet. Well, I was going to plug the Pi 3


00:24:16.240 --> 00:24:19.360
readiness, but you already brought it up. So we'll drop a link to the other one.


00:24:20.320 --> 00:24:25.320
that the top 360 packages are now Python 3, which is great.


00:24:25.320 --> 00:24:28.080
And I was hoping that one of you had a joke,


00:24:28.080 --> 00:24:30.040
so I only have one and it's not very good.


00:24:30.040 --> 00:24:31.760
So either of you got a joke?


00:24:31.760 --> 00:24:32.760
- Joke?


00:24:32.760 --> 00:24:33.960
Oh my goodness.


00:24:33.960 --> 00:24:36.120
You go first, I'll see if it's an act I wanna follow.


00:24:36.120 --> 00:24:39.120
- Okay, well just, I was actually looking for some,


00:24:39.120 --> 00:24:42.320
so I was looking for programming one-liners,


00:24:42.320 --> 00:24:44.840
looked at a Reddit thread, read a great answer,


00:24:44.840 --> 00:24:47.240
which was, "Any joke can be a one-liner


00:24:47.240 --> 00:24:48.800
"with enough semicolons."


00:24:48.800 --> 00:24:56.520
I think that joke is obfuscated enough that I'm not going to try to follow it.


00:24:56.520 --> 00:24:57.920
I've got a good bad one.


00:24:57.920 --> 00:25:03.040
So a SQL statement walks into a bar up to a couple of tables and says, "Can I join you?"


00:25:03.040 --> 00:25:04.040
Ah, yeah.


00:25:04.040 --> 00:25:07.040
Just dropping that one on us.


00:25:07.040 --> 00:25:08.040
Okay.


00:25:08.040 --> 00:25:09.040
All right.


00:25:09.040 --> 00:25:10.040
All right.


00:25:10.040 --> 00:25:12.240
Well, let's leave it at that.


00:25:12.240 --> 00:25:19.240
So thank you everyone for sharing all these awesome items with us and we'll catch up with


00:25:19.240 --> 00:25:20.240
you later.


00:25:20.240 --> 00:25:21.240
All right.


00:25:21.240 --> 00:25:22.240
Sounds great.


00:25:22.240 --> 00:25:23.240
Thanks Brian.


00:25:23.240 --> 00:25:24.240
Bye bye.


00:25:24.240 --> 00:25:25.240
Thank you for listening to Python Bytes.


00:25:25.240 --> 00:25:26.640
Follow the show on Twitter via @pythonbytes.


00:25:26.640 --> 00:25:29.600
That's Python Bytes as in B-Y-T-E-S.


00:25:29.600 --> 00:25:32.720
And get the full show notes at pythonbytes.fm.


00:25:32.720 --> 00:25:36.440
If you have a news item you want featured, just visit pythonbytes.fm and send it our


00:25:36.440 --> 00:25:37.440
way.


00:25:37.440 --> 00:25:39.640
We're always on the lookout for sharing something cool.


00:25:39.640 --> 00:25:42.920
On behalf of myself and Brian Okken, this is Michael Kennedy.


00:25:42.920 --> 00:25:45.960
Thank you for listening and sharing this podcast with your friends and colleagues.

