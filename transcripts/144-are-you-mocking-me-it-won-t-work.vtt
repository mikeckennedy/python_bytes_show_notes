WEBVTT

00:00:00.001 --> 00:00:04.740
Hello and welcome to Python Bytes, where we deliver news and headlines directly to your earbuds.

00:00:04.740 --> 00:00:11.780
This is episode 144, recorded August 20th, 2019. I'm Brian Ogden, and Michael is on vacation,

00:00:11.780 --> 00:00:15.520
but I have two awesome guest hosts. Welcome, Chris May.

00:00:15.520 --> 00:00:16.000
Hey there.

00:00:16.000 --> 00:00:18.420
And also welcome, Mahmoud Hashemi.

00:00:18.420 --> 00:00:20.100
Hello, everybody. It's good to be back.

00:00:20.100 --> 00:00:26.600
So both of you have been on Test and Code, but have either of you been guests on Python Bytes before?

00:00:26.600 --> 00:00:33.300
I think I actually guest hosted once in a similar situation where Michael was on vacation or you were on vacation.

00:00:33.300 --> 00:00:36.100
I think it was me and Michael that time, so it's good to get the reverse.

00:00:36.100 --> 00:00:42.720
Cool. And I definitely never have been on Python Bytes, but it's been something I would have been excited about ever since I thought I had the opportunity.

00:00:42.720 --> 00:00:44.060
Dreams do come true.

00:00:44.060 --> 00:00:44.760
Indeed.

00:00:44.760 --> 00:00:47.880
I really appreciate both of you coming on.

00:00:47.880 --> 00:00:51.180
As a reminder to everybody, this episode is brought to you by DigitalOcean.

00:00:51.180 --> 00:00:55.120
Check them out at pythonbytes.fm/DigitalOcean.

00:00:55.360 --> 00:00:57.400
Get a $50 credit for new users.

00:00:57.400 --> 00:00:58.220
Lots of good stuff.

00:00:58.220 --> 00:00:59.580
More about that later.

00:00:59.580 --> 00:01:00.700
Let's just jump in.

00:01:00.700 --> 00:01:06.060
I'm going to put Chris on the spot and have him go first since he's new here, and we can heckle.

00:01:06.060 --> 00:01:06.720
Yeah, bring it on.

00:01:06.720 --> 00:01:06.960
No.

00:01:06.960 --> 00:01:14.140
Yeah, my first topic I selected was Why Your Mock Doesn't Work by Ned Batchelor.

00:01:14.940 --> 00:01:30.280
And it's an article that just came out like perfect timing for my team and I because there are members of my team who are building an application that's syncing or bringing data from one database server to another across cloud platforms.

00:01:31.280 --> 00:01:34.200
And essentially, they're trying to do a test-driven development.

00:01:34.200 --> 00:01:37.160
And they came to me and they're like, how are we supposed to do this?

00:01:37.160 --> 00:01:43.860
Like, there are all these third-party clients that we're connecting to and trying to get authorization from and all these different things.

00:01:44.000 --> 00:01:48.760
And they quickly found out that mocking these third-party tools was hard.

00:01:49.220 --> 00:02:04.960
I was just so thankful that Ned wrote this article to show us that one problem is that sometimes mocking, the way that they're setting up their mocks, the item that they were mocking never actually mocked the object that they were trying to mock.

00:02:04.960 --> 00:02:17.020
It's a little hard to explain in video, or in audio, rather, but Ned actually has some great illustrations to show exactly how mocking works and when it works and how it can be messed up.

00:02:17.020 --> 00:02:18.600
I saw those illustrations.

00:02:18.820 --> 00:02:22.120
I don't know if he's using GraphViz or what, but we're definitely getting the point across.

00:02:22.120 --> 00:02:22.860
Yeah.

00:02:22.860 --> 00:02:26.460
I was wondering, because I thought he did such a great job with those illustrations.

00:02:26.460 --> 00:02:29.200
Like, how did he take the time to design those?

00:02:29.200 --> 00:02:31.500
It's good to know that there may be a tool behind that.

00:02:31.500 --> 00:02:33.800
Well, I mean, and he's got, yeah.

00:02:33.800 --> 00:02:37.660
I mean, he used them in his Python name and values talk in the blog post.

00:02:37.660 --> 00:02:43.480
And I always, like, especially for beginner to intermediate programmers, I always send them to that Python names and values talk.

00:02:43.480 --> 00:02:45.780
It's a really good use of a half hour.

00:02:45.780 --> 00:02:46.740
Nice.

00:02:46.740 --> 00:02:48.620
Hey, look, we're getting bonus content already.

00:02:48.620 --> 00:02:58.680
Yeah, and that actually, that names and values talk actually makes you a better mock user as well, because it helps you understand how that all works.

00:02:58.680 --> 00:03:01.400
Plus, Ned's just really good at explaining stuff.

00:03:01.400 --> 00:03:01.860
Absolutely.

00:03:02.360 --> 00:03:14.680
The other thing I love about this article is he also links to two other resources, another article and a video where people gave examples of when you don't want to use mocking and also good practices when you do.

00:03:14.680 --> 00:03:29.340
And one of the takeaways I took away from my team is that, especially if you're trying to mock third party code, you're going to need to create tests that, of course, test your own application against the mock, but also test the mock against the third party tool.

00:03:29.460 --> 00:03:33.600
And so this is a bunch of stuff that you're going to invest in if you want to test with mocks.

00:03:33.600 --> 00:03:46.180
I mean, if I can jump in, what I'll say, whenever you're integrating, right, and there's an SDK or a library for integrating, chances are you're not going to use 100% of that library or that service.

00:03:46.280 --> 00:03:47.760
You're probably going to use a little sliver of it.

00:03:47.760 --> 00:03:50.520
I know it seems like, oh, great, they wrote all the code for me.

00:03:50.520 --> 00:03:53.580
Let me jump right in and integrate directly with their library.

00:03:53.580 --> 00:04:01.740
But it really makes sense a lot of the time to use a gateway or some other pattern to kind of like make explicit which parts of that library you use.

00:04:01.740 --> 00:04:10.620
Because eventually when you have to integrate with another service or you want to throw it away, it's just going to be a lot easier to sort of like maintain that side of the integration.

00:04:10.620 --> 00:04:12.300
So, yeah, great post.

00:04:12.720 --> 00:04:20.720
Yeah, I also like to, I think it was in this post here where you mentioned kind of what you were saying, there's only a, usually there's only a thin sliver of the functionality you need.

00:04:20.720 --> 00:04:32.860
And to use, you know, to create a mock that only does that, but also to make sure that across your organization or across your team to only have one mock object that handles like that one third party tool.

00:04:32.860 --> 00:04:34.500
That's a good idea.

00:04:34.500 --> 00:04:36.320
Well, Mahmoud, what do you got for us?

00:04:36.400 --> 00:04:46.640
So what I've got for the group here is a little library slash application that I ran into while doing some research for a talk that I'll get into later.

00:04:46.640 --> 00:04:49.120
But basically it's called Vermin.

00:04:49.120 --> 00:04:58.180
And the name's not really explained, but the only reason, I mean, the only reason I can see behind it is that Python has snakes and snakes are kind of vermin and vermin kind of sounds like version.

00:04:58.400 --> 00:05:03.340
And so what vermin is, that's like, you know, V-E-R-M-I-N.

00:05:03.340 --> 00:05:04.620
Oh, wait, I just got it.

00:05:04.620 --> 00:05:05.840
It's like version minimum.

00:05:05.840 --> 00:05:06.240
Okay.

00:05:06.240 --> 00:05:13.360
So what it does is it's a rules-based Python version compatibility detector with a pretty clever name.

00:05:13.440 --> 00:05:23.400
So what it does, maybe you heard the news, but basically now all 360 top downloaded PyPI libraries now support Python 3.

00:05:23.400 --> 00:05:24.920
There's like a website for it.

00:05:24.920 --> 00:05:38.440
And the way that that's determined is I think Brett Cannon has a library or application which basically looks at the setup py and then looks at the like index classifiers.

00:05:38.560 --> 00:05:46.380
And so if the person who published the package says it supports Python 3, it takes it at its word and says that this library says it supports Python 3.

00:05:46.380 --> 00:05:52.100
Now the top 360 libraries have done so, which is a pretty good milestone for us, especially as we approach 2020.

00:05:52.100 --> 00:05:54.600
But the thing is that it's based on what people say.

00:05:54.600 --> 00:06:04.040
So if you, when it comes to your own code, right, like if you're like a team at a company or a maintainer of an application that doesn't necessarily have a setup.py,

00:06:04.640 --> 00:06:09.800
there's, you know, can I use Python 3 is not really going to help you because you don't have those classifiers.

00:06:09.800 --> 00:06:21.460
So basically vermin, what it does is it scans over every single py file, every single module, and it tells you the minimum Python version necessary to import that module.

00:06:21.460 --> 00:06:24.100
And it even gets down to the function level.

00:06:24.520 --> 00:06:32.460
So basically, you can use this to scan your code and say like, look, there's a Python 2.7 like feature being used by this function over here in this module.

00:06:32.460 --> 00:06:38.360
And then you can also certify that, hey, this module over here uses like Python 3.5 syntax.

00:06:38.360 --> 00:06:42.980
Or, hey, that one actually is using a 3.7 thing, but we're only on 3.6.

00:06:43.380 --> 00:06:44.620
So it's rules-based.

00:06:44.620 --> 00:06:46.320
It's got over a thousand rules.

00:06:46.320 --> 00:06:47.360
It's pip install.

00:06:47.360 --> 00:06:48.400
You pip install vermin.

00:06:48.400 --> 00:06:50.400
And it has a little command line entry point.

00:06:50.400 --> 00:06:54.500
And, yeah, when I found it, it had like less than 80 stars on GitHub.

00:06:54.500 --> 00:06:57.220
And I'm hoping, you know, I saw how much work went into this.

00:06:57.220 --> 00:07:00.440
I'm hoping that maybe it blows up a little bit because it's a very useful tool.

00:07:00.440 --> 00:07:02.980
And I'll explain why in my next segment.

00:07:02.980 --> 00:07:05.660
But basically, yeah, definitely check it out.

00:07:05.660 --> 00:07:06.140
Vermin.

00:07:06.140 --> 00:07:07.020
That's really cool.

00:07:07.020 --> 00:07:08.480
I mean, I could definitely see.

00:07:08.480 --> 00:07:09.420
Yeah, it sounds really cool.

00:07:09.420 --> 00:07:11.380
It sounds like a lot of work went into that.

00:07:11.800 --> 00:07:12.120
Exactly.

00:07:12.120 --> 00:07:13.120
A lot of work went into it.

00:07:13.120 --> 00:07:14.900
And it's still a little bit quirky, I'll tell you.

00:07:14.900 --> 00:07:19.340
Like, I ran it with just plain vermin as described.

00:07:19.340 --> 00:07:20.640
And I got one result.

00:07:20.640 --> 00:07:25.640
And then I ran it with dash V, which made it kind of like, it's supposed to make it more verbose, I thought.

00:07:25.640 --> 00:07:28.580
But it actually made it like look harder.

00:07:28.580 --> 00:07:30.880
And it came back with a more accurate result.

00:07:30.880 --> 00:07:33.200
So maybe when you run it, run it with dash V.

00:07:33.200 --> 00:07:34.900
Or maybe like, you know, help the guy out.

00:07:34.900 --> 00:07:36.520
I think his name is Morten Christensen.

00:07:36.520 --> 00:07:38.760
Maybe help him out and give him a PR.

00:07:38.760 --> 00:07:41.600
Make the verbose act the same way as the non-verbose.

00:07:41.600 --> 00:07:43.440
But no, great tool regardless.

00:07:43.440 --> 00:07:44.600
Ah, okay.

00:07:44.600 --> 00:07:46.320
Verbose might be more picky.

00:07:46.320 --> 00:07:47.180
Interesting.

00:07:47.180 --> 00:07:49.180
Well, I think vermin looks cool.

00:07:49.180 --> 00:07:58.480
And I'm excited about going from, not just from 2 to 3, but for instance, we now are excited about Python 3.8 features or 3.7 features.

00:07:58.480 --> 00:08:02.780
And I want to make sure that, you know, it's possible to move things around.

00:08:02.780 --> 00:08:03.440
Exactly.

00:08:03.700 --> 00:08:06.760
There's a lot of use for that and forever, I think.

00:08:06.760 --> 00:08:09.200
So anyway, I don't want to talk about a new feature.

00:08:09.200 --> 00:08:13.620
I actually want to talk about something that's been around for a while, but I don't see it a lot in code.

00:08:13.800 --> 00:08:18.960
And I just saw this recently, an article called the non-local statement in Python.

00:08:18.960 --> 00:08:23.040
And I'm going to attempt this name, Abolash Raj.

00:08:23.040 --> 00:08:24.320
I think that's it.

00:08:24.580 --> 00:08:35.200
But the idea is if you use a local variable, like if you assign to a local variable, it creates a new thing in the namespace, a local name.

00:08:35.200 --> 00:08:39.840
And, you know, the normal thing that everybody knows is unless you add the global.

00:08:40.440 --> 00:08:49.380
But global doesn't just make it so that you can assign a variable that's not declared in this function.

00:08:49.380 --> 00:08:53.500
It also makes it so that it's a global scope variable.

00:08:53.500 --> 00:08:56.020
And sometimes that's not really what you want.

00:08:56.020 --> 00:08:59.320
You just want it to reference.

00:08:59.320 --> 00:09:03.560
Like, for instance, if you've got a local function defined within another function,

00:09:03.560 --> 00:09:07.940
and you want to reference or assign to an outside variable,

00:09:07.940 --> 00:09:09.920
it's really easy to see when you look at the code.

00:09:09.920 --> 00:09:11.940
But I forgot this was around.

00:09:11.940 --> 00:09:14.020
I don't use it very much, but it's pretty cool.

00:09:14.020 --> 00:09:17.900
I think I run into this occasionally, and I usually just make things global.

00:09:17.900 --> 00:09:21.120
So, Mahmoud, you probably have more experience than me.

00:09:21.120 --> 00:09:22.100
Do you run into this ever?

00:09:22.100 --> 00:09:22.960
Oh, my goodness.

00:09:22.960 --> 00:09:25.600
So, back when I was, like, really learning the ropes in Python,

00:09:25.600 --> 00:09:27.940
and I remember it so clearly back in, like, 2011,

00:09:27.940 --> 00:09:31.720
I was playing with the concept of, like, dynamic scope,

00:09:31.720 --> 00:09:34.000
which is in contrast to lexical scope.

00:09:34.000 --> 00:09:38.460
So, that's, like, lexical scope, you sort of look within your block or your function, right?

00:09:38.680 --> 00:09:41.140
And dynamic scope is this older concept where it's, like,

00:09:41.140 --> 00:09:44.700
you would look up the stack for something.

00:09:44.700 --> 00:09:47.300
And I think Emacs Lisp still uses this.

00:09:47.300 --> 00:09:49.160
Kind of glad that Python doesn't.

00:09:49.160 --> 00:09:51.820
But, you know, in, like, the mad science, like, you know,

00:09:51.820 --> 00:09:54.380
mode of learning all of Python's cool features,

00:09:54.380 --> 00:09:56.900
I wanted to, you know, do something like that.

00:09:56.900 --> 00:10:01.220
Yeah, somewhere in there, I was, like, messing with generators and dynamic scope,

00:10:01.220 --> 00:10:03.760
and I found myself just hitting right into a wall.

00:10:04.020 --> 00:10:06.880
And I talked to Raymond Hedinger, and he's, like, oh, yeah, what you want is non-local,

00:10:06.880 --> 00:10:09.200
and that's going to be sometime in the far future.

00:10:09.200 --> 00:10:12.540
Yeah, anyways, I mean, here we are, and it's there.

00:10:12.540 --> 00:10:15.600
And, frankly, if I use it, I'm over that phase.

00:10:15.600 --> 00:10:18.380
So, if I use it, I feel like I'm doing something wrong,

00:10:18.380 --> 00:10:21.680
and I should probably, like, factor this in a clearer way.

00:10:21.680 --> 00:10:23.820
But that said, I'm sure it still comes up.

00:10:23.820 --> 00:10:27.980
And, you know, I think everyone's probably going to have a little mad science phase of their own.

00:10:27.980 --> 00:10:31.260
And so, let them use non-local and deal with the consequences.

00:10:31.260 --> 00:10:31.940
Well, right.

00:10:31.940 --> 00:10:35.240
I mean, it's, like, one of these features that it's used so little

00:10:35.240 --> 00:10:39.460
that you're just adding complexity to the code because most people won't know what it means.

00:10:39.460 --> 00:10:40.440
Right.

00:10:40.440 --> 00:10:41.340
So, you got to be careful.

00:10:41.340 --> 00:10:41.620
Yeah.

00:10:41.620 --> 00:10:44.920
You know, it's still, like, it has its own little place,

00:10:44.920 --> 00:10:49.620
and I'm sure some, like, someone has a legit use for it beyond, like, just messing around.

00:10:49.620 --> 00:10:51.380
So, I'm glad it's there still.

00:10:51.380 --> 00:10:52.160
Yeah, definitely.

00:10:52.520 --> 00:10:58.060
I'm going to take a little bit of a sponsor break and thank DigitalOcean for sponsoring this show.

00:10:58.060 --> 00:11:02.860
DigitalOcean has been a longtime supporter of Python Bytes, and we really appreciate it.

00:11:02.860 --> 00:11:08.080
And not only that, all of the infrastructure for pythonbytes.fm runs on DigitalOcean.

00:11:08.080 --> 00:11:13.500
We've got our website, our database, and even the audio file hosting is done through DigitalOcean.

00:11:13.500 --> 00:11:16.560
It's been wonderful, super affordable, and solid.

00:11:17.020 --> 00:11:23.560
There's enough features to get us going and to let us grow, but not so many that it's too complicated.

00:11:23.560 --> 00:11:30.440
So, I think it's a great platform, easy to start, easy to grow, and highly recommended.

00:11:30.440 --> 00:11:35.400
So, if you'd like to give it a shot, visit pythonbytes.fm/DigitalOcean.

00:11:35.400 --> 00:11:41.160
It'll give you $50 free credit for new accounts, so you can give it a try.

00:11:41.160 --> 00:11:42.560
I think it's a good place to be.

00:11:42.560 --> 00:11:43.580
Get yourself a droplet.

00:11:43.580 --> 00:11:44.880
Yeah, a droplet.

00:11:45.280 --> 00:11:51.500
So, let's start this all over again, and not back from the beginning, but it's Chris's turn again.

00:11:51.500 --> 00:11:53.340
So, Chris, what you got?

00:11:53.340 --> 00:12:00.440
Well, this week, Microsoft announced that they've improved Python support in their Azure platform.

00:12:00.440 --> 00:12:05.660
I think, in particular, they've announced general availability for a bunch of new Python things.

00:12:05.660 --> 00:12:07.280
Some of which I've...

00:12:07.280 --> 00:12:13.660
So, the company I work for, we've primarily used Microsoft Azure, and I've used some of these tools in beta.

00:12:13.660 --> 00:12:15.640
But so now it's, like, available to everybody.

00:12:15.640 --> 00:12:22.620
And I'm excited because reading through the announcement from Microsoft, I wasn't 100% sure what was new.

00:12:22.780 --> 00:12:30.020
What I was really thankful for is Brett Cannon tweeted a link to it and said, here are the specific points that he was excited about.

00:12:30.020 --> 00:12:33.640
The first off is that it's debuting with Python 3.6.

00:12:33.640 --> 00:12:36.820
But 3.7 support is currently being worked on.

00:12:36.820 --> 00:12:40.060
And actually, I can already see it in preview, which is nice.

00:12:40.060 --> 00:12:44.620
And especially good news for me is that 3.8 support won't take nearly as long.

00:12:44.740 --> 00:12:50.200
So, I'm hoping that very shortly after they release Python 3.8, it'll be available in Azure.

00:12:50.200 --> 00:12:54.460
And then the second thing is that there's native async and await support in there.

00:12:54.460 --> 00:12:56.720
And that's pretty exciting.

00:12:56.720 --> 00:12:57.560
But it really...

00:12:57.560 --> 00:13:05.600
The other thing that I wanted to pull from that, that Brett didn't mention in his tweet, is that it's actually pretty impressive, like, the amount of stuff that Microsoft does for us.

00:13:05.600 --> 00:13:16.020
In particular, the Azure Functions, it's just amazing to me because they have a way of deploying to the web where you essentially just create a new Git remote.

00:13:16.020 --> 00:13:18.040
And you just push your code up there.

00:13:18.040 --> 00:13:19.260
And when it goes...

00:13:19.260 --> 00:13:24.820
When your code arrives there, it essentially sticks into a Docker image and runs it for you.

00:13:24.820 --> 00:13:26.540
And it's a pretty fast startup.

00:13:26.540 --> 00:13:30.520
And all these things that's, like, so complicated, I can't imagine what's all going on.

00:13:30.520 --> 00:13:32.600
And you don't have to worry about it at all.

00:13:32.600 --> 00:13:34.820
You just have something that runs in your computer.

00:13:35.400 --> 00:13:36.900
You push it up, and it's done.

00:13:36.900 --> 00:13:38.300
And it's really, really impressive.

00:13:38.300 --> 00:13:40.020
I've never played with Azure Functions.

00:13:40.020 --> 00:13:44.180
So are those kind of like Lambda Functions on AWS?

00:13:44.180 --> 00:13:45.260
Yeah, they sure are.

00:13:45.260 --> 00:13:47.760
And I hear they're probably about as easy.

00:13:47.760 --> 00:13:49.160
I've never actually...

00:13:49.160 --> 00:13:52.200
I've intended to play with Azure Lambdas.

00:13:52.200 --> 00:13:57.760
In fact, at the local Python meetup, we've had a couple people talk about how easy it is to do.

00:13:57.760 --> 00:14:02.440
And I was just thankful that here at work, I've been able to try the Azure Functions.

00:14:02.440 --> 00:14:04.100
So it's really nice.

00:14:04.100 --> 00:14:04.520
Nice.

00:14:04.880 --> 00:14:06.140
I'll have to give that a shot sometime.

00:14:06.140 --> 00:14:06.500
Yeah.

00:14:06.700 --> 00:14:10.800
Actually, I think Microsoft offers, like, a free, like, month or two-month thing if you want to do it.

00:14:10.800 --> 00:14:14.140
And on top of that, the Azure Functions are incredibly cheap.

00:14:14.140 --> 00:14:15.060
I just...

00:14:15.060 --> 00:14:19.620
They have a calculator up, and you can check to see how much it'll cost to do certain things.

00:14:19.620 --> 00:14:20.800
And I maxed it out.

00:14:20.800 --> 00:14:25.620
Like, I have a function that calls a bunch of API endpoints and saves them to the database.

00:14:25.980 --> 00:14:33.140
And we realized if we did it 48 times a day against every single website that the company owns, we still would be in the free tier.

00:14:33.140 --> 00:14:35.680
So it's really impressive what you can do.

00:14:35.680 --> 00:14:37.040
That's cool.

00:14:37.040 --> 00:14:39.640
Well, I'm kind of excited about this next topic.

00:14:39.640 --> 00:14:40.980
Like, super excited.

00:14:40.980 --> 00:14:43.240
Because we talked about...

00:14:43.240 --> 00:14:48.460
I'll have to dig up the episode, but we did bring up awesome Python applications before.

00:14:48.460 --> 00:14:49.660
Right.

00:14:49.660 --> 00:14:50.720
But we have an update.

00:14:50.720 --> 00:14:51.160
Well, yeah.

00:14:51.160 --> 00:14:52.360
No, I don't remember what it was.

00:14:52.360 --> 00:14:53.620
If it was test and code Python bytes.

00:14:53.620 --> 00:15:01.720
But I remember accidentally, like, sort of dropping this idea on the podcast, and it kind of blew up a little bit ahead of when I expected to launch it.

00:15:01.720 --> 00:15:02.100
But, yeah.

00:15:02.100 --> 00:15:06.740
So I'm here to bring, like, an awesome Python applications update.

00:15:06.740 --> 00:15:16.660
And so, basically, awesome Python applications, for those who haven't heard of it, is sort of like your standard awesome list, where it's like you're on GitHub, and there's a readme, and there's a ton of links, you know.

00:15:16.660 --> 00:15:22.520
And all these links point to applications that are free and open source Python.

00:15:23.320 --> 00:15:25.600
And so, at first, it looks like a normal awesome list.

00:15:25.600 --> 00:15:29.360
One, it's actually generated from some structured YAML.

00:15:29.360 --> 00:15:33.300
And, you know, when I started out, it was like 25 applications.

00:15:33.300 --> 00:15:36.080
Like, Zulip and Sentry sort of came to mind.

00:15:36.080 --> 00:15:43.140
But then, like, the more I looked, the more I found, and it grew to something like 180 by the time, like, you know, it sort of went a little viral.

00:15:43.140 --> 00:15:46.120
And then, these days, it's like 255.

00:15:46.120 --> 00:15:48.780
Frankly, it'll hit 260 by the end of the week.

00:15:48.780 --> 00:15:52.480
And so, the list keeps growing almost faster than I can keep up with it.

00:15:52.560 --> 00:15:54.140
Thank goodness it's somewhat automated.

00:15:54.140 --> 00:16:01.360
And so, this last weekend, I was at sort of the local Python conference, PyBay, you know, maybe CU PyBay 2020.

00:16:01.360 --> 00:16:02.700
It was a pretty big hit there.

00:16:03.080 --> 00:16:08.740
I basically, you know, I'll put in the show notes sort of a link to my slides and where the video will be and whatnot.

00:16:08.740 --> 00:16:14.420
But what I did for my talk there was I took, like I said, structured YAML.

00:16:14.420 --> 00:16:16.840
So, I have all of the links, all of the repos.

00:16:17.300 --> 00:16:20.960
Technically, any awesome list could do this, and I'm surprised that more haven't.

00:16:20.960 --> 00:16:24.220
But I went and I cloned all of the repos.

00:16:24.220 --> 00:16:25.580
And this isn't just GitHub.

00:16:25.580 --> 00:16:31.860
This is things that are on GitLab, things that are, like, sort of, like, off any particular software forge.

00:16:31.860 --> 00:16:34.780
There are things that are on Bitbucket, things that are in Bazaar.

00:16:34.780 --> 00:16:36.800
You know, it's a whole mix of things.

00:16:37.340 --> 00:16:39.180
And I cloned them all.

00:16:39.180 --> 00:16:42.300
And it was something like 30 gigabytes of code.

00:16:42.300 --> 00:16:49.700
Yeah, and these packages, they date, or these applications, rather, date all the way back to, like, 1998, like Mailman and G-Edit.

00:16:49.700 --> 00:16:52.120
You know, if you're a GNOME user, G-Edit uses Python.

00:16:52.120 --> 00:16:55.540
And 95% of them have had a commit this year, 2019.

00:16:55.540 --> 00:16:57.920
So, these are all very active.

00:16:57.920 --> 00:17:01.160
And the reason I've compiled this isn't so much that we can go use them.

00:17:01.160 --> 00:17:05.080
Like, of course, I actually use several of them without even realizing that they're Python.

00:17:05.360 --> 00:17:16.760
But the thing is that, as application developers, we need exemplars we can go look to for patterns in testing and documentation and architecture and packaging.

00:17:16.760 --> 00:17:23.060
Things that people do without necessarily writing a blog post about them or, you know, going on a podcast or giving a conference talk.

00:17:23.060 --> 00:17:26.020
So, basically, I went and I cloned it, and I did all this analysis.

00:17:26.020 --> 00:17:28.100
And this is how I found Vermin.

00:17:28.100 --> 00:17:33.240
And so, Vermin, the good news here, like, let me just, I should have led with this, right?

00:17:33.240 --> 00:17:46.340
But the good news is that, I was surprised by this, fully two-thirds of these Python applications, which are on median, like, you know, 10 years old, two-thirds of them support and use Python 3.

00:17:46.340 --> 00:17:47.020
Wow.

00:17:47.100 --> 00:17:53.620
So, I was expecting to find that a lot of these had sort of been, you know, it's tough to maintain open source.

00:17:53.620 --> 00:17:59.040
And, you know, I thought that they would sort of have maybe, like, sort of fallen behind a little bit, right?

00:17:59.040 --> 00:18:08.460
Goodness knows that most corporations I run into, well, I don't know about most, but, you know, a lot of them are still using Python 2 for their Python applications.

00:18:08.700 --> 00:18:11.300
You know, even, like, you know, Google, everyone's favorite, right?

00:18:11.300 --> 00:18:14.740
Even Google hasn't, like, fully ported over to Python 3 yet.

00:18:14.740 --> 00:18:19.480
So, yeah, but 66% support Python 3.

00:18:19.480 --> 00:18:22.440
And I've had a bunch of other interesting findings.

00:18:22.440 --> 00:18:24.300
If you go to my slides, you can check them out.

00:18:24.300 --> 00:18:27.120
And I'll also be giving the talk at PyGotham 2019.

00:18:27.120 --> 00:18:30.500
So, if you're in New York, early October, I think tickets are available.

00:18:30.500 --> 00:18:32.660
So, there's so many cool things in here.

00:18:32.660 --> 00:18:39.980
And there's stuff that I knew about once and forgot about, like Eric, one of the Python IDEs.

00:18:39.980 --> 00:18:41.480
So, that's fun.

00:18:41.480 --> 00:18:41.980
Yeah.

00:18:41.980 --> 00:18:49.900
Yeah, I mean, the newest one I found, someone at the conference came up and told me about it, is actually, I think, nia.is or .si or something like that.

00:18:49.900 --> 00:18:51.840
It's a torrent tracker for anime.

00:18:51.840 --> 00:18:56.640
And so, this particular anime fan informed me that this is one of the largest torrent trackers out.

00:18:56.640 --> 00:18:58.580
And, you know, it's written in Python.

00:18:58.580 --> 00:18:59.460
It's right there on GitHub.

00:19:00.160 --> 00:19:01.620
And, you know, it's not on PyPI.

00:19:01.620 --> 00:19:02.700
It's not really discoverable.

00:19:02.700 --> 00:19:07.840
You need this word of mouth to kind of find these applications and all the lessons contained therein.

00:19:07.840 --> 00:19:09.100
Like, I calculated it out.

00:19:09.100 --> 00:19:17.060
Over 2,000 years of project maintenance, right, like in these repos that was just waiting to be learned from.

00:19:17.060 --> 00:19:20.140
And, you know, I think the list should grow even further.

00:19:20.140 --> 00:19:26.540
So, if any of the listeners have applications that they happen to know are written in Python, you know, hit me up on GitHub.

00:19:26.540 --> 00:19:29.040
I'll definitely, like, you know, consider and curate.

00:19:29.040 --> 00:19:29.480
Nice.

00:19:29.760 --> 00:19:30.440
Well, this is cool.

00:19:30.440 --> 00:19:31.040
Thanks.

00:19:31.040 --> 00:19:31.640
Absolutely.

00:19:32.140 --> 00:19:33.720
It's amazing to see how much that's grown.

00:19:33.720 --> 00:19:37.580
I remember when you were on whichever podcast you were on and I was just inspired.

00:19:37.580 --> 00:19:41.740
And now I'm even more so, again, to see, like, how many things have been built with Python.

00:19:41.740 --> 00:19:43.900
And I still haven't reached the bottom yet.

00:19:43.900 --> 00:19:44.560
That's amazing.

00:19:45.020 --> 00:19:48.400
My dream is really to, like, you know, make a static site for this so that you can filter.

00:19:48.400 --> 00:19:53.540
Sure, because basically, like, I can, I now have the data and I'll look at publishing this data set somewhere.

00:19:54.040 --> 00:19:57.460
But basically, it's like, you know, show me the projects that use Docker.

00:19:57.460 --> 00:19:59.180
Show me the projects that use PyInstaller.

00:19:59.180 --> 00:20:02.060
Show me the projects that use Twisted versus whatever.

00:20:02.060 --> 00:20:04.100
You mentioned AsyncIO right earlier.

00:20:04.500 --> 00:20:05.640
And I was kind of surprised.

00:20:05.640 --> 00:20:12.660
There are quite a few older projects that have actually adopted Async, like AsyncIO rather, you know.

00:20:12.960 --> 00:20:18.380
Like, and it's pretty even split between concurrent futures, Twisted, Tornado, G-Event, and AsyncIO.

00:20:18.380 --> 00:20:21.400
They're basically all around 20% on this list.

00:20:21.400 --> 00:20:22.280
How about that?

00:20:22.280 --> 00:20:22.700
Nice.

00:20:22.700 --> 00:20:22.920
Yeah.

00:20:22.920 --> 00:20:24.140
So, figure it out.

00:20:24.140 --> 00:20:27.940
Well, I'm going to wrap this up with a really easy one.

00:20:27.940 --> 00:20:31.220
We've talked about pre-commit several times, I think, on the show.

00:20:31.220 --> 00:20:39.660
But if you, and pre-commit is a tool to allow you to run some code before you check in your code to make sure things that are whatever.

00:20:39.660 --> 00:20:43.200
You've got a style guide or some checks or whatever you want to do.

00:20:43.200 --> 00:20:45.280
It really is general purpose.

00:20:45.280 --> 00:20:46.840
But how do you get started?

00:20:46.840 --> 00:20:50.040
And actually, this is something that I needed myself.

00:20:50.040 --> 00:20:55.800
The pre-commit documents now, they just recently added a quick start guide.

00:20:55.800 --> 00:20:57.380
And I love it.

00:20:57.380 --> 00:21:06.260
It just kind of walks you through installing pre-commit, configuring it for the first time, taking a look at what the hooks are, installing the hooks,

00:21:06.260 --> 00:21:10.560
because you have to install the hooks also, which is something I wasn't aware of.

00:21:10.560 --> 00:21:15.380
And then the initial attempt to just run your hooks against your project.

00:21:15.380 --> 00:21:16.360
That's awesome.

00:21:16.360 --> 00:21:22.400
But I wanted to add, and one of the reasons why I wanted to bring it up on the show wasn't just because, hey, go check this out.

00:21:22.400 --> 00:21:26.240
But I'd like to add that doing this slowly is a good idea.

00:21:26.480 --> 00:21:35.300
So I tried this with like three or four or five different hooks, like flake 8, black, and some other things, and then let it loose on my code base.

00:21:35.300 --> 00:21:37.640
And it changed like everything.

00:21:38.240 --> 00:21:41.120
And I thought, I don't really know what's going on here.

00:21:41.120 --> 00:21:49.820
So I'd like to modify it a little bit to say, if you're adding this to a project, for each new hook, add them one at a time to your YAML file.

00:21:49.820 --> 00:21:53.700
Install it and run it against your files first.

00:21:53.700 --> 00:21:55.380
And then commit that.

00:21:55.380 --> 00:21:57.100
If you're happy, review the changes.

00:21:57.100 --> 00:22:02.360
If you're happy with it, your test pass and all that, check them in, and then move on to the next one.

00:22:02.360 --> 00:22:09.980
I think it'll be easier for the rest of your team to swallow the fact that you just changed all the files.

00:22:09.980 --> 00:22:11.820
That's great news.

00:22:11.820 --> 00:22:18.460
This is one thing when I saw it in the notes I was super excited to see because we want to start doing this here at work.

00:22:18.460 --> 00:22:24.300
And now that I know that there is a quick start guide to do it, it makes me so much more excited to do it.

00:22:24.300 --> 00:22:29.220
Because I tried messing with the GitHub hooks or the GitHub hooks themselves.

00:22:29.220 --> 00:22:31.100
I'm like, I really need to learn Bash.

00:22:31.100 --> 00:22:32.780
Well, not just that.

00:22:32.780 --> 00:22:36.800
They're just basically unusable in a team environment without something like this to manage them.

00:22:36.800 --> 00:22:42.940
So I think Anthony Sotow kicked this off, and he's really just kept running with it right out of the park.

00:22:42.940 --> 00:22:43.800
He's done a great job.

00:22:43.800 --> 00:22:49.560
And the community as a whole, actually, too, because anyone can contribute sort of useful pre-commit hooks there, too.

00:22:49.560 --> 00:22:50.380
That's awesome.

00:22:50.380 --> 00:22:50.820
All right.

00:22:50.820 --> 00:22:52.480
So that's done with our six.

00:22:52.480 --> 00:22:56.320
Does anybody have any extra information they'd like to shout out?

00:22:56.320 --> 00:22:57.680
I have a couple of things I'd like to share.

00:22:57.680 --> 00:23:12.280
First off, the Humble Bundle, Humble Bundle, easy for me to say, by the No Starch Press, is throwing a special with the Python Software Foundation, where if you buy, you can get a collection of the books for a certain price.

00:23:12.560 --> 00:23:15.900
And the PSF gets money, which is wonderful.

00:23:15.900 --> 00:23:18.040
They can use as much money as they can get, I think.

00:23:18.380 --> 00:23:22.540
And I'm all about supporting them.

00:23:22.540 --> 00:23:29.240
I know friends of the show, PyBytes, have released their newbie bytes, which I know they have put in a ton of hard work into.

00:23:29.240 --> 00:23:31.820
And I'm excited for them to have got it up and running.

00:23:31.820 --> 00:23:43.300
I'm excited to, like, as somebody who runs a local Python meetup group, I'm excited that there's another resource out there to help people who are very new to Python to learn how to use it.

00:23:43.300 --> 00:23:43.620
Nice.

00:23:43.620 --> 00:23:44.320
That's cool.

00:23:44.320 --> 00:23:47.380
I didn't have anything prepared, but, I mean, I guess I'll just shout out again.

00:23:47.380 --> 00:23:53.380
Like, you know, I'll be doing an East Coast tour, like PyGotham and the Maintainers Conference in Washington, D.C.

00:23:53.380 --> 00:23:59.720
You know, if you want to get a ticket to one of these, I'd be happy to meet anyone out there, chat about Python and versioning and all this stuff.

00:23:59.720 --> 00:24:01.800
I should also, like, you know, shout out my wife.

00:24:01.800 --> 00:24:05.160
She helped me make all the graphs for this awesome Python applications presentation.

00:24:05.160 --> 00:24:10.500
And, yeah, she was using, like, real Python, I think, to learn a lot of the pandas to do so.

00:24:10.500 --> 00:24:12.620
She really, again, just did an amazing job.

00:24:12.620 --> 00:24:13.460
So, thanks, Maya.

00:24:13.460 --> 00:24:13.820
Sweet.

00:24:14.220 --> 00:24:19.480
Well, I was going to plug the Py3 readiness, but you already brought it up, so we'll drop a link to the other one.

00:24:19.480 --> 00:24:24.960
The top 360 packages are now Python 3, which is great.

00:24:24.960 --> 00:24:27.980
And I was hoping that one of you had a joke.

00:24:27.980 --> 00:24:29.940
So, I only have one, and it's not very good.

00:24:29.940 --> 00:24:31.660
So, either of you got a joke?

00:24:31.660 --> 00:24:32.140
Joke.

00:24:32.140 --> 00:24:33.480
Oh, my goodness.

00:24:33.480 --> 00:24:34.560
You go first.

00:24:34.560 --> 00:24:35.960
I'll see if it's an act I want to follow.

00:24:35.960 --> 00:24:36.360
Okay.

00:24:36.360 --> 00:24:39.080
Well, just, I was actually looking for some.

00:24:39.080 --> 00:24:44.080
So, I was looking for programming one-liners, looked at a Reddit thread, read a great deal.

00:24:44.120 --> 00:24:48.460
And I had a great answer, which was, any joke can be a one-liner with enough semicolons.

00:24:48.460 --> 00:24:54.960
I think that joke is obfuscated enough that I'm not going to try to follow it.

00:24:55.760 --> 00:24:57.480
Oh, I've got a good, bad one.

00:24:57.480 --> 00:25:02.100
So, a SQL statement walks into a bar up to a couple of tables and says, can I join you?

00:25:02.100 --> 00:25:03.500
Oh.

00:25:03.500 --> 00:25:05.520
Yeah, yeah.

00:25:05.520 --> 00:25:06.220
Just dropping that one on us.

00:25:06.220 --> 00:25:06.500
Okay.

00:25:08.500 --> 00:25:09.340
All right.

00:25:09.340 --> 00:25:10.280
All right.

00:25:10.280 --> 00:25:12.100
Well, let's leave it at that.

00:25:12.100 --> 00:25:17.100
So, thank you, everyone, for sharing all these awesome items with us.

00:25:17.100 --> 00:25:19.580
And we'll catch up with you later.

00:25:19.580 --> 00:25:19.900
All right.

00:25:19.900 --> 00:25:20.240
Sounds great.

00:25:20.240 --> 00:25:20.760
Thanks, Brian.

00:25:20.760 --> 00:25:21.700
Bye-bye.

00:25:21.960 --> 00:25:23.800
Thank you for listening to Python Bytes.

00:25:23.800 --> 00:25:26.340
Follow the show on Twitter via at Python Bytes.

00:25:26.340 --> 00:25:29.200
That's Python Bytes as in B-Y-T-E-S.

00:25:29.200 --> 00:25:32.440
And get the full show notes at pythonbytes.fm.

00:25:32.440 --> 00:25:36.640
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:25:36.640 --> 00:25:39.340
We're always on the lookout for sharing something cool.

00:25:39.340 --> 00:25:42.460
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:25:42.460 --> 00:25:45.880
Thank you for listening and sharing this podcast with your friends and colleagues.

