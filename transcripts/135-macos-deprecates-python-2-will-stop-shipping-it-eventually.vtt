
00:00:00.000 --> 00:00:05.360
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:05.360 --> 00:00:10.320
This is episode 135 recorded June 12th, 2019. I'm Michael Kennedy.


00:00:10.320 --> 00:00:11.120
And I'm Brian Akin.


00:00:11.120 --> 00:00:12.160
And I'm Max Sklar.


00:00:12.160 --> 00:00:14.000
Yeah, welcome to the show. It's great to have you here.


00:00:14.000 --> 00:00:15.120
Good to be here today.


00:00:15.120 --> 00:00:18.720
You're here. You've got your own podcast and we're definitely gonna talk a little bit about


00:00:18.720 --> 00:00:21.920
that at the end and that'll be great. I do, before we kick things off, though,


00:00:21.920 --> 00:00:24.800
also want to say thank you to DigitalOcean for sponsoring the show. Check them out at


00:00:24.800 --> 00:00:28.640
pythonbytes.fm/digitalocean. More about them later as well.


00:00:28.640 --> 00:00:57.860
Okay, so Rufin Lerner has a he's got an email list that I'm signed up to. One of the things that he pointed out in one of the recent, I can't remember if it was on his email list or if it was on one of his blog posts. So I'm linking to a blog post. But it's this idea that I didn't even know you could do this. It's titled Why do Python lists let you do plus equals or in place assigned addition with a tuple. We can't do plus with a tuple. So here's the idea is you got, you got a list.


00:00:58.340 --> 00:01:03.940
and you want to add, combine the elements of a list and a tuple, end up with a list at the end.


00:01:03.940 --> 00:01:07.140
You can't just add them, because they're different types.


00:01:07.140 --> 00:01:12.240
But you can do incremental add, and it's just weird.


00:01:12.240 --> 00:01:14.240
I was like, I didn't know you could do that.


00:01:14.240 --> 00:01:21.040
But it turns out, it's a little surprising, but just as because the plus equals is not,


00:01:21.040 --> 00:01:28.240
I always think of it as equivalent to, like x plus equals one is the same as x equals x plus one.


00:01:28.240 --> 00:01:29.040
That's what I thought.


00:01:29.040 --> 00:01:32.080
But it turns out it's actually a different, it's a different call.


00:01:32.080 --> 00:01:33.880
It's implemented as a different call.


00:01:33.880 --> 00:01:37.640
I see like a different Dunder method, like a different magic method is being called.


00:01:37.640 --> 00:01:38.200
Yeah.


00:01:38.200 --> 00:01:44.480
And the Dunder method for list increment or in place add is what it does is it takes


00:01:44.480 --> 00:01:49.800
any iterable on the right-hand side and adds it one element at a time to the left


00:01:49.800 --> 00:01:53.640
side, so you can plus equals any iterable onto a list.


00:01:53.640 --> 00:01:54.880
That's neat.


00:01:54.880 --> 00:01:55.880
I didn't know you could do that.


00:01:55.880 --> 00:01:56.320
That's cool.


00:01:56.320 --> 00:01:57.400
This is so weird.


00:01:57.440 --> 00:02:01.320
I mean, it's cool and it's fine that += will do that.


00:02:01.320 --> 00:02:02.480
And I actually just tried it.


00:02:02.480 --> 00:02:07.280
I created a list of a bunch of numbers and then I += it with a string.


00:02:07.280 --> 00:02:11.400
And now I have a list that's full of numbers and single characters that made up that string,


00:02:11.400 --> 00:02:14.280
which is, which is, it's okay if that's the behavior.


00:02:14.280 --> 00:02:16.400
And it seems actually like the most reasonable behavior.


00:02:16.400 --> 00:02:18.680
But then why can't you just + them, right?


00:02:18.680 --> 00:02:20.560
Like, it seems odd that it's inconsistent.


00:02:20.560 --> 00:02:25.200
Plus, it seems like it should just create another list with that same behavior.


00:02:25.200 --> 00:02:26.880
So, yeah, not sure.


00:02:26.880 --> 00:02:27.880
Yeah, exactly.


00:02:27.880 --> 00:02:32.560
I assume there's a better way to turn a tuple into a list, but now that I'm looking at this,


00:02:32.560 --> 00:02:36.600
you could just create an empty list and then do plus equals your tuple.


00:02:36.600 --> 00:02:39.080
There you go, your conversion.


00:02:39.080 --> 00:02:40.080
It's all filled up.


00:02:40.080 --> 00:02:43.400
Yeah, it's definitely not the most obvious way.


00:02:43.400 --> 00:02:47.480
Probably the initializer constructor of the list is best, just pass it the iterable.


00:02:47.480 --> 00:02:49.880
But yeah, this is interesting.


00:02:49.880 --> 00:02:54.320
Also if the three of us didn't know you could do this, probably don't do this in your code


00:02:54.320 --> 00:02:56.600
because nobody will understand it.


00:02:56.600 --> 00:02:57.320
It's interesting.


00:02:57.320 --> 00:02:59.480
Yeah. Also, please don't put this in a job interview.


00:02:59.480 --> 00:03:02.680
Yeah.


00:03:02.680 --> 00:03:05.000
Don't make this one of these things.


00:03:05.000 --> 00:03:07.960
Oh, one of those questions that you mean an interview question?


00:03:07.960 --> 00:03:11.080
Yeah, exactly. Like what form of sort does a list use?


00:03:11.080 --> 00:03:14.280
What does a list plus a tuple mean?


00:03:14.280 --> 00:03:15.560
What is list plus equals?


00:03:15.560 --> 00:03:20.040
No, this belongs in a Watt talk, not in a job interview.


00:03:20.040 --> 00:03:21.400
Yeah, definitely.


00:03:21.400 --> 00:03:27.720
I think this is interesting because Python is mostly devoid of these weird oddities.


00:03:27.720 --> 00:03:30.440
It's mostly a pretty polished, simple, clean language.


00:03:30.440 --> 00:03:31.720
But yeah, this is weird.


00:03:31.720 --> 00:03:35.960
Gary Bernhardt could incorporate this into the talk, I'm pretty sure.


00:03:35.960 --> 00:03:36.280
Nice.


00:03:36.280 --> 00:03:36.840
All right.


00:03:36.840 --> 00:03:42.040
Speaking of jobs and growth and things that you might actually want to pay attention to


00:03:42.040 --> 00:03:44.440
or decide on, Max, what's this next one you got?


00:03:44.440 --> 00:03:47.160
This is an article called R versus Python.


00:03:47.160 --> 00:03:51.560
R is out of the top 20 languages despite statistical boom.


00:03:51.560 --> 00:03:55.720
And I know you guys have covered on the show before the whole R versus


00:03:55.720 --> 00:03:59.520
Python dynamic, all these articles coming out, this is, I'm not going to


00:03:59.520 --> 00:04:03.200
be anti R here, but even though I'm a Python guy, so the article is about


00:04:03.200 --> 00:04:07.840
an index on the popularity of programming languages and this organization, TIOB


00:04:07.840 --> 00:04:11.960
does one, I know that there could be, I imagine that there's some


00:04:11.960 --> 00:04:14.600
controversy around how to rank them.


00:04:14.600 --> 00:04:16.920
I'm just going to assume that they're doing a pretty good job.


00:04:16.920 --> 00:04:19.320
There's a few stories here, a few headlines.


00:04:19.320 --> 00:04:21.720
The first is that Python hit an all-time high.


00:04:21.720 --> 00:04:26.160
It's now language is at ranking number three on the chart.


00:04:26.160 --> 00:04:31.580
So it's just beats out, it beats out C++, I believe for the first time.


00:04:31.580 --> 00:04:35.440
Only Java and C are more popular than Python.


00:04:35.440 --> 00:04:41.080
And the other story is that the statistical language R dipped to number 21.


00:04:41.080 --> 00:04:45.440
And so the speculation is that Python has sort of taken over as the preferred statistical


00:04:45.440 --> 00:04:50.680
language to R. And then personally, I got into Python, because I kind of came at data


00:04:50.680 --> 00:04:56.560
science and ML from a from a software development perspective. I took CS, I learned C and Java.


00:04:56.560 --> 00:05:01.400
And so going over to Python was came a lot more naturally to me than going over to R.


00:05:01.400 --> 00:05:05.800
If you were say a statistician, maybe, yes, coming from R makes more sense, right? Or


00:05:05.800 --> 00:05:07.560
from MATLAB or something like that, right?


00:05:07.560 --> 00:05:13.840
Yes, yes. And I have worked with and met people who do that. And they have probably extra


00:05:13.840 --> 00:05:16.520
skills that I don't have, like they could do certain things a lot faster.


00:05:16.520 --> 00:05:20.800
So again, I'm not like anti-R, but I'm just, I think from the


00:05:20.800 --> 00:05:25.300
programmer's perspective, Python is a lot nicer for some people, people like me.


00:05:25.300 --> 00:05:28.080
So personally, I'm going to stick with Python because there's so many


00:05:28.080 --> 00:05:31.520
statistical libraries that even I have yet to learn and it's served me very well.


00:05:31.520 --> 00:05:32.120
Thus far.


00:05:32.120 --> 00:05:35.180
And then the third thing I wanted to point out the language that I use most


00:05:35.180 --> 00:05:37.160
in the recent years in is Scala.


00:05:37.160 --> 00:05:41.960
And that's surprisingly down at 31, which I looking at companies around


00:05:41.960 --> 00:05:44.200
here in New York at like startups, there's a lot that use Scala.


00:05:44.200 --> 00:05:45.500
So I was surprised it was that low, but


00:05:45.500 --> 00:05:50.300
well, I feel like Scala and those functional languages, they tend to be


00:05:50.300 --> 00:05:52.700
very popular in the financial space, right?


00:05:52.700 --> 00:05:53.120
Maybe.


00:05:53.120 --> 00:05:53.420
Yeah.


00:05:53.420 --> 00:05:56.240
You definitely are in the center of that and being in New York, right?


00:05:56.240 --> 00:05:56.620
Yes.


00:05:56.620 --> 00:05:59.180
But a lot of, you know, Foursquare where I worked for a long


00:05:59.180 --> 00:06:01.240
time was Scala based, Twitter.


00:06:01.240 --> 00:06:05.480
So there's a lot of, companies like that, social media, consumer


00:06:05.480 --> 00:06:06.740
app companies that use it.


00:06:06.740 --> 00:06:08.980
So why do you think this is?


00:06:08.980 --> 00:06:10.340
Why do you think Python is?


00:06:10.420 --> 00:06:14.740
I mean, you talked about why you were more comfortable with it, but it's a general trend.


00:06:14.740 --> 00:06:19.260
Even people who are scientific are taking up Python at much larger numbers.


00:06:19.260 --> 00:06:20.260
Why do you think that is?


00:06:20.260 --> 00:06:26.500
When companies actually want to apply machine learning or statistical methods to their data,


00:06:26.500 --> 00:06:30.840
they already have a lot of engineers and developers.


00:06:30.840 --> 00:06:37.020
And if you already have people who are fluent in Python, then why not use Python?


00:06:37.020 --> 00:06:42.540
Python has a lot of great libraries, NumPy is really great, and then a lot of the more


00:06:42.540 --> 00:06:45.060
sophisticated machine learning libraries are really great.


00:06:45.060 --> 00:06:47.340
So there's too many benefits, I think.


00:06:47.340 --> 00:06:48.340
Yeah, I definitely agree with that.


00:06:48.340 --> 00:06:53.300
I think another one has to do with the fact that Python is a full spectrum language.


00:06:53.300 --> 00:06:57.780
Like I can come with a very partial understanding of what Python is and what it does.


00:06:57.780 --> 00:06:59.100
And I can still be productive.


00:06:59.100 --> 00:07:02.700
I can if I know how to pip install a thing, write code, I need to know what a function


00:07:02.700 --> 00:07:03.700
or a class is.


00:07:03.700 --> 00:07:07.700
I can do amazing, I could like spin up a machine learning model and do something with it, right?


00:07:07.700 --> 00:07:14.260
But at the same time, that piece can grow and grow into like a fully distributed application


00:07:14.260 --> 00:07:15.260
or something like that, right?


00:07:15.260 --> 00:07:20.460
Like there's not many languages that start that simple and yet most of the simple languages


00:07:20.460 --> 00:07:23.860
that they top out and you say, well, now you go do C++.


00:07:23.860 --> 00:07:24.860
I hope you like templates.


00:07:24.860 --> 00:07:25.860
Good luck.


00:07:25.860 --> 00:07:26.860
Yeah.


00:07:26.860 --> 00:07:30.700
I'm still like stumped as to why Java is at the top.


00:07:30.700 --> 00:07:31.940
That is a good question.


00:07:31.940 --> 00:07:32.940
You know what I think?


00:07:32.940 --> 00:07:33.940
- That's a lot of legacy.


00:07:33.940 --> 00:07:35.180
- Yeah, I think that that's true.


00:07:35.180 --> 00:07:37.820
And I think the legacy is in two places.


00:07:37.820 --> 00:07:39.740
I think if you care about open source,


00:07:39.740 --> 00:07:43.020
but you want a compiled modern language,


00:07:43.020 --> 00:07:44.420
Java's a pretty good choice.


00:07:44.420 --> 00:07:47.820
Like, you know, C#, C++, those are also good,


00:07:47.820 --> 00:07:50.500
but C++ is, you know, doesn't have garbage collection,


00:07:50.500 --> 00:07:52.940
and C# is tied to Microsoft, right?


00:07:52.940 --> 00:07:55.340
So I can see that that's one of the things.


00:07:55.340 --> 00:08:00.340
I also think the academics, Stanford and Carnegie Mellon


00:08:00.460 --> 00:08:04.720
and all that stuff very much for many, for a long time,


00:08:04.720 --> 00:08:07.500
taught Java, Java, Java as the way to do things.


00:08:07.500 --> 00:08:10.860
And so the folks at the high end of decision making


00:08:10.860 --> 00:08:13.420
probably had that experience as well.


00:08:13.420 --> 00:08:14.820
So I don't know, that's my theory.


00:08:14.820 --> 00:08:16.620
- Okay, I'm not sure if there's this article


00:08:16.620 --> 00:08:19.500
or another one related to this that predict,


00:08:19.500 --> 00:08:20.700
I don't know if you already covered this,


00:08:20.700 --> 00:08:23.180
that predicted that Python will be at the top


00:08:23.180 --> 00:08:24.420
within like four years.


00:08:24.420 --> 00:08:26.940
- Yeah, that it's gonna surpass Java and C.


00:08:26.940 --> 00:08:28.900
Yeah, I mean, just look at the growth curves, right?


00:08:28.900 --> 00:08:30.420
Some are either flat or downward,


00:08:30.420 --> 00:08:32.180
and Python is like highly up.


00:08:32.180 --> 00:08:33.740
So pretty awesome.


00:08:33.740 --> 00:08:35.500
Very cool to be working in the Python space.


00:08:35.500 --> 00:08:36.320
It's exciting.


00:08:36.320 --> 00:08:37.540
Like every day is super exciting.


00:08:37.540 --> 00:08:42.020
- If like we said, Java is very popular because of,


00:08:42.020 --> 00:08:44.220
you know, there's a lot of legacy code written in Java,


00:08:44.220 --> 00:08:46.420
but new projects,


00:08:46.420 --> 00:08:49.100
I don't know if there's another score for new projects,


00:08:49.100 --> 00:08:51.740
but I assume that Python is way higher.


00:08:51.740 --> 00:08:53.180
- Yeah, that's probably, it probably is.


00:08:53.180 --> 00:08:54.140
I don't know where to find that either,


00:08:54.140 --> 00:08:55.340
but it'd be cool to have that data.


00:08:55.340 --> 00:08:56.180
- Yeah.


00:08:56.180 --> 00:08:58.060
- Speaking of exciting, Max, what OS do you use?


00:08:58.060 --> 00:08:58.940
- I'm on macOS.


00:08:58.940 --> 00:09:00.140
- Yeah, so am I.


00:09:00.140 --> 00:09:02.260
so is Brian, even though the majority of Python developers


00:09:02.260 --> 00:09:04.100
are on Windows, we happen to all be there.


00:09:04.100 --> 00:09:07.340
So we can all appreciate this next one that's coming here.


00:09:07.340 --> 00:09:11.940
So I recently watched the WWDC and somehow I didn't notice


00:09:11.940 --> 00:09:14.340
this or they didn't announce it, it was just in the fine print


00:09:14.340 --> 00:09:17.380
but Dan Bader from Real Python sent this over


00:09:17.380 --> 00:09:20.380
and there was an announcement, at least in the release notes


00:09:20.380 --> 00:09:23.300
for the new macOS, what is it, Catalina?


00:09:23.300 --> 00:09:25.460
Something like that, whatever their name is it


00:09:25.460 --> 00:09:28.760
for the new macOS, the one that replaces Mojave.


00:09:28.760 --> 00:09:30.920
It is deprecating Python 2.


00:09:30.920 --> 00:09:34.720
So finally, we have like a super old version of Python


00:09:34.720 --> 00:09:35.560
running in macOS.


00:09:35.560 --> 00:09:38.280
And if you type Python, you get Python 2.


00:09:38.280 --> 00:09:40.200
It doesn't ship with Python 3.


00:09:40.200 --> 00:09:44.040
Ideally, I would love to see Python 3 shipping,


00:09:44.040 --> 00:09:47.720
kind of like what the Windows Store and Microsoft is doing


00:09:47.720 --> 00:09:50.000
as an app that is auto updating and stuff,


00:09:50.000 --> 00:09:52.120
like a really nice way to get it there.


00:09:52.120 --> 00:09:54.600
Instead, they're just saying, we've decided that Python


00:09:54.600 --> 00:09:57.000
and all the scripting runtimes,


00:09:57.000 --> 00:09:59.400
So Pearl and Ruby and Python,


00:09:59.400 --> 00:10:00.920
those are not our problem anymore.


00:10:00.920 --> 00:10:02.160
We're washing our hands of them.


00:10:02.160 --> 00:10:03.280
That's the announcement.


00:10:03.280 --> 00:10:05.340
We are no longer recommending them.


00:10:05.340 --> 00:10:06.400
It is deprecated.


00:10:06.400 --> 00:10:09.040
We have to leave Python 2 there


00:10:09.040 --> 00:10:10.680
because stuff is depending upon it,


00:10:10.680 --> 00:10:13.600
but we do not recommend you use it at all, period.


00:10:13.600 --> 00:10:15.000
Find another way to get it there.


00:10:15.000 --> 00:10:16.440
- Yeah, it is interesting.


00:10:16.440 --> 00:10:17.960
- So on one hand, like that's good news.


00:10:17.960 --> 00:10:19.280
They're like, please don't,


00:10:19.280 --> 00:10:20.560
I know it has Python on it,


00:10:20.560 --> 00:10:21.680
but this is a broken old one.


00:10:21.680 --> 00:10:22.560
Don't use that.


00:10:22.560 --> 00:10:24.640
I feel like there's maybe some better way


00:10:24.640 --> 00:10:26.120
they could approach that.


00:10:26.120 --> 00:10:27.600
I don't know if there'll be some kind of warning


00:10:27.600 --> 00:10:29.860
when you run it, that would be great.


00:10:29.860 --> 00:10:32.580
But it does make it actually harder


00:10:32.580 --> 00:10:35.520
to get the right version of Python onto your system.


00:10:35.520 --> 00:10:37.200
Like if you wanna use Homebrew,


00:10:37.200 --> 00:10:39.940
brew install Python, installs Python 3,


00:10:39.940 --> 00:10:41.400
but you know what Brew runs on?


00:10:41.400 --> 00:10:44.020
Ruby, I believe, something like that.


00:10:44.020 --> 00:10:45.440
It depends on one of these things.


00:10:45.440 --> 00:10:48.680
So that's also, so like if that's also not there,


00:10:48.680 --> 00:10:50.240
then how do you brew?


00:10:50.240 --> 00:10:51.860
So there's a bunch of interesting changes here,


00:10:51.860 --> 00:10:54.220
but I do think it's interesting that Apple


00:10:54.220 --> 00:10:56.980
and the macOS team are addressing this Python story.


00:10:56.980 --> 00:10:57.980
What do you guys think?


00:10:57.980 --> 00:10:58.980
Yeah.


00:10:58.980 --> 00:11:02.020
Well, when did Python 3 come out, if you could remind me?


00:11:02.020 --> 00:11:03.020
Was it?


00:11:03.020 --> 00:11:04.020
2008.


00:11:04.020 --> 00:11:05.020
Wow.


00:11:05.020 --> 00:11:09.060
But realistically, I feel like 3.4 is where it really started to get traction, and that's


00:11:09.060 --> 00:11:12.460
more like 2012-ish, something like that.


00:11:12.460 --> 00:11:13.460
OK.


00:11:13.460 --> 00:11:18.500
Yeah, I'm just now I'm thinking, oh, God, I have some scripts in my GitHub that I may


00:11:18.500 --> 00:11:22.140
want to, that I built like five years ago, I may want to upgrade.


00:11:22.140 --> 00:11:23.980
I think it's a good thing, actually.


00:11:23.980 --> 00:11:29.700
I think it will be a good thing because people that just open up a terminal on Mac and type


00:11:29.700 --> 00:11:33.340
Python, they get 2.7 and that's not the right answer.


00:11:33.340 --> 00:11:34.340
Yeah.


00:11:34.340 --> 00:11:35.340
Yeah.


00:11:35.340 --> 00:11:39.180
And I've seen this where you always have two versions of Python on your machine.


00:11:39.180 --> 00:11:43.700
And there's always, did this the other day where you run the old version of Python and


00:11:43.700 --> 00:11:44.700
it doesn't work.


00:11:44.700 --> 00:11:47.820
You're like, oh, I did the, I called the wrong commands.


00:11:47.820 --> 00:11:51.140
And it would be nice to kind of put an end to that.


00:11:51.140 --> 00:11:52.700
So it doesn't waste people's time.


00:11:52.700 --> 00:11:53.700
Yeah, absolutely.


00:11:53.700 --> 00:11:57.980
to put an alias to alias Python to Python 3 inside my startup script.


00:11:57.980 --> 00:12:00.060
Yeah, that's a good idea.


00:12:00.060 --> 00:12:01.060
Interesting.


00:12:01.060 --> 00:12:05.820
Well, I would like a better outcome, but at least there's some kind of like Apple acknowledges


00:12:05.820 --> 00:12:08.060
how out of date the stuff they're shipping is.


00:12:08.060 --> 00:12:09.620
So that's pretty cool.


00:12:09.620 --> 00:12:13.620
Now before we get on to the next one, I want to talk really quickly about DigitalOcean.


00:12:13.620 --> 00:12:17.240
They've been a huge supporter of the show, and we really appreciate that.


00:12:17.240 --> 00:12:20.100
Our infrastructure runs on DigitalOcean, which is pretty cool.


00:12:20.100 --> 00:12:24.860
So we can definitely recommend it from someone who's using it, right?


00:12:24.860 --> 00:12:29.380
And I want to highlight their hosted database as a service right now.


00:12:29.380 --> 00:12:35.060
So if you want to use Postgres SQL, which is probably the most popular relational database


00:12:35.060 --> 00:12:39.580
these days in the Python space, you know, you look at the stack overflow survey and


00:12:39.580 --> 00:12:42.720
stuff like that, it's got a lot of love, and people love it a lot.


00:12:42.720 --> 00:12:47.660
So they have hosted as a service, just go there and say I want Postgres, turn on here's


00:12:47.660 --> 00:12:51.260
the connection string, they'll do all the backups and scaling and failover and all that stuff for


00:12:51.260 --> 00:12:56.940
you. So super great. Check them out at pythonbytes.fm/digitalocean and for new users you get a


00:12:56.940 --> 00:13:02.380
$50 credit to get started, which is also cool. Brian, would you say that dictionaries are important


00:13:02.380 --> 00:13:07.660
in Python? Yeah, definitely. The whole thing's built on dictionaries. It's turtles all the way


00:13:07.660 --> 00:13:11.260
down. Exactly. It's turtles all the way down. It's dictionaries all the way down. So what's up with


00:13:11.260 --> 00:13:12.100
- What's up with this one?


00:13:12.100 --> 00:13:15.420
- This is just a small article from Al Swigert,


00:13:15.420 --> 00:13:17.160
Pythonic Ways to Use Dictionaries.


00:13:17.160 --> 00:13:18.800
And I thought it was a good reminder


00:13:18.800 --> 00:13:20.880
because dictionaries really are not,


00:13:20.880 --> 00:13:22.940
I mean, they're not hard to use.


00:13:22.940 --> 00:13:26.820
People coming from, I guess I came from Perl before Python.


00:13:26.820 --> 00:13:30.600
So I was used to, I guess, what were they called in Perl?


00:13:30.600 --> 00:13:31.440
Hashes.


00:13:31.440 --> 00:13:33.400
- Yeah, hashes and hash maps and all these things, right?


00:13:33.400 --> 00:13:35.600
- Yeah, dictionary is a lookup thing.


00:13:35.600 --> 00:13:39.180
And using them like that is not that hard.


00:13:39.180 --> 00:13:40.880
But there's some gotchas in there


00:13:40.880 --> 00:13:44.320
that some people try to do weird things to work around them.


00:13:44.320 --> 00:13:46.020
So this is just a highlight article


00:13:46.020 --> 00:13:49.020
that a few ways to use them smartly.


00:13:49.020 --> 00:13:51.740
One of them is to use the get function for,


00:13:51.740 --> 00:13:54.220
if you try to retrieve an element out of a dictionary


00:13:54.220 --> 00:13:57.960
and the element isn't there, the key isn't there,


00:13:57.960 --> 00:14:00.200
you get a, I don't know, a lookup error or something


00:14:00.200 --> 00:14:01.480
in a certain keyer.


00:14:01.480 --> 00:14:03.720
But if you know it might not be there,


00:14:03.720 --> 00:14:05.240
so you can check beforehand,


00:14:05.240 --> 00:14:08.580
or you can just use the get with a default.


00:14:08.580 --> 00:14:11.880
and the default value will return something other than,


00:14:11.880 --> 00:14:13.580
if it's not there, it returns something else.


00:14:13.580 --> 00:14:15.300
- That's the primary way that I get stuff


00:14:15.300 --> 00:14:16.980
out of dictionaries these days.


00:14:16.980 --> 00:14:18.940
I used to do square brackets, but I don't do that anymore.


00:14:18.940 --> 00:14:20.060
It's always about dot get.


00:14:20.060 --> 00:14:21.020
- Yeah, me too.


00:14:21.020 --> 00:14:24.340
- I do that as well, especially since almost every dictionary


00:14:24.340 --> 00:14:27.980
is either something like a histogram


00:14:27.980 --> 00:14:30.180
or a sum of something where,


00:14:30.180 --> 00:14:31.620
the default's always going to be zero,


00:14:31.620 --> 00:14:34.220
and I don't want to distinguish between that


00:14:34.220 --> 00:14:36.260
and it not being there.


00:14:36.260 --> 00:14:42.660
The key for me is almost always there's other kind of validation you have to do anyway.


00:14:42.660 --> 00:14:44.260
So I'm thinking of the web, right?


00:14:44.260 --> 00:14:46.260
Like I want to get something posted on a form.


00:14:46.260 --> 00:14:49.260
I want to get the, say, the email they've submitted.


00:14:49.260 --> 00:14:52.660
I want to know that it's there, but I also got to make sure that it's not empty or it's not none.


00:14:52.660 --> 00:14:58.660
Like if I'm already doing the if test, I don't want to do the conditional test and a try except.


00:14:58.660 --> 00:15:00.060
You might as well just do one.


00:15:00.060 --> 00:15:02.260
The only one that's going to work is the if, so just use get.


00:15:02.260 --> 00:15:04.060
- The set default actually was something


00:15:04.060 --> 00:15:05.740
I didn't even know was there,


00:15:05.740 --> 00:15:07.820
which I learned something new.


00:15:07.820 --> 00:15:09.540
I don't use that normally, but--


00:15:09.540 --> 00:15:10.420
- What does that do?


00:15:10.420 --> 00:15:13.820
- Set default will only set the value


00:15:13.820 --> 00:15:16.220
if the element does not exist yet.


00:15:16.220 --> 00:15:17.820
- Yeah, that's perfect, yeah, it makes a lot of sense.


00:15:17.820 --> 00:15:20.600
- So like, his example, and the thing is perfect,


00:15:20.600 --> 00:15:22.500
is if you're storing a counter or something,


00:15:22.500 --> 00:15:25.820
like a number of hours, and you just wanna increment,


00:15:25.820 --> 00:15:27.540
if you're trying to increment something,


00:15:27.540 --> 00:15:29.900
you wanna set it to zero to begin with,


00:15:29.900 --> 00:15:31.580
but you only want it to set it to zero


00:15:31.580 --> 00:15:33.060
if it isn't there already.


00:15:33.060 --> 00:15:34.020
So that makes sense.


00:15:34.020 --> 00:15:35.340
- Yeah, yeah, perfect.


00:15:35.340 --> 00:15:36.540
So you don't have to do that test.


00:15:36.540 --> 00:15:38.340
Then it also talks about using dictionaries


00:15:38.340 --> 00:15:39.200
as a switch statement,


00:15:39.200 --> 00:15:41.460
which I thought was a funny language hack.


00:15:41.460 --> 00:15:43.900
I actually went and created a switch statement


00:15:43.900 --> 00:15:45.620
for the language in Python.


00:15:45.620 --> 00:15:46.780
It's on GitHub.


00:15:46.780 --> 00:15:48.040
And it's really nice.


00:15:48.040 --> 00:15:51.180
I use it in some of like some really gnarly code


00:15:51.180 --> 00:15:54.300
that has got like 50 or 100 cases.


00:15:54.300 --> 00:15:56.780
And it's just a lot nicer 'cause it'll do things


00:15:56.780 --> 00:15:59.540
like not let you have the same key twice, for example,


00:15:59.540 --> 00:16:00.820
things like that.


00:16:00.820 --> 00:16:02.420
- So you do use it?


00:16:02.420 --> 00:16:03.340
- Oh yeah, I use it, I love it.


00:16:03.340 --> 00:16:05.060
It's like, I think it's great.


00:16:05.060 --> 00:16:06.300
It uses a with block.


00:16:06.300 --> 00:16:10.380
So it uses the with block as the switch block, basically.


00:16:10.380 --> 00:16:11.980
And then you just have cases in there.


00:16:11.980 --> 00:16:15.860
Anyway, it's kind of funky, but I'll put a link into it.


00:16:15.860 --> 00:16:17.780
But I do think it's interesting that dictionaries


00:16:17.780 --> 00:16:19.060
can be used for switch statements.


00:16:19.060 --> 00:16:21.360
- Yeah, I think it's good to comment


00:16:21.360 --> 00:16:24.060
because not everybody's gonna understand what's going on.


00:16:24.060 --> 00:16:26.180
So make a comment about what your code's doing.


00:16:26.180 --> 00:16:27.680
- Yeah, yeah, for sure.


00:16:27.680 --> 00:16:30.180
All right, Max, what's this next one you got?


00:16:30.180 --> 00:16:32.300
All right, short article I found,


00:16:32.300 --> 00:16:35.740
things you're probably not using in Python 3 but should.


00:16:35.740 --> 00:16:38.420
This is from datawhatnow.com.


00:16:38.420 --> 00:16:39.780
So this is particularly relevant for me


00:16:39.780 --> 00:16:42.660
because I used Python legacy at Foursquare for many years.


00:16:42.660 --> 00:16:44.040
Now I'm coming back to it,


00:16:44.040 --> 00:16:47.860
taking another look at v3 over the last couple of years.


00:16:47.860 --> 00:16:51.340
So just a couple of things it has that stood out for me,


00:16:51.340 --> 00:16:53.060
one that looks very useful is fstrings,


00:16:53.060 --> 00:16:56.580
where you can put the variable name in braces in a string


00:16:56.580 --> 00:16:57.900
and just have it replaced.


00:16:57.900 --> 00:17:00.780
So long as you remember to put the character F


00:17:00.780 --> 00:17:03.020
before the string, that's very important.


00:17:03.020 --> 00:17:04.940
So, you know, I've seen things like this


00:17:04.940 --> 00:17:06.540
in other languages, Scala has it,


00:17:06.540 --> 00:17:09.780
PHP, most front end scripts have things like this,


00:17:09.780 --> 00:17:13.040
makes the code very readable, except I know myself,


00:17:13.040 --> 00:17:15.460
I know I'm gonna screw up by leaving out that straight F


00:17:15.460 --> 00:17:18.220
in front of the string, so I almost feel like


00:17:18.220 --> 00:17:21.020
it should be automatic, but it is very useful.


00:17:21.020 --> 00:17:21.900
- Yeah, I feel the same way.


00:17:21.900 --> 00:17:24.300
I'm always like, I'm halfway through writing a string


00:17:24.300 --> 00:17:26.300
and I'm like, oh, I should have put the F at the front.


00:17:26.300 --> 00:17:27.860
Well, now I'm just gonna do a format on the end


00:17:27.860 --> 00:17:32.580
with my editor, I type dot and F and it auto completes format. So it's just, we're just


00:17:32.580 --> 00:17:36.020
gonna keep rolling. You know what I mean? Like it's one of these things that is really nice,


00:17:36.020 --> 00:17:38.900
but you got to be a little cognizant up front, right?


00:17:38.900 --> 00:17:44.980
Yeah. If you're correct, it looks very good. And actually we did some things at Foursquare. We,


00:17:44.980 --> 00:17:50.420
and this was for Scala code where we had like a GitHub hooks that looked to see,


00:17:50.420 --> 00:17:55.380
Hey, this is a formatted string. And if you were trying to check in code, that was a formatted


00:17:55.380 --> 00:18:00.180
string, but you didn't actually put, I think in Scala, there was an S in front of it or


00:18:00.180 --> 00:18:01.180
something.


00:18:01.180 --> 00:18:04.340
If you didn't actually format the string, it's like, okay, this is probably an error.


00:18:04.340 --> 00:18:05.700
You probably shouldn't be checking this in.


00:18:05.700 --> 00:18:06.700
Oh, interesting.


00:18:06.700 --> 00:18:07.700
That's sort of a workaround.


00:18:07.700 --> 00:18:08.700
Yeah, yeah, yeah.


00:18:08.700 --> 00:18:11.300
It was helpful, but yeah, it'd be nice to have in the language, but just having the


00:18:11.300 --> 00:18:13.760
formatted strings is always helpful.


00:18:13.760 --> 00:18:17.780
Another thing I didn't know that Python 3 had is enumerations.


00:18:17.780 --> 00:18:22.180
You know, again, with the functional programming, I've been using enums for years.


00:18:22.180 --> 00:18:25.700
They tend to make code way more readable, in my opinion.


00:18:25.700 --> 00:18:28.100
And so that was good to know.


00:18:28.100 --> 00:18:30.140
I'll keep that in mind when developing in Python 3.


00:18:30.140 --> 00:18:31.140
Nice.


00:18:31.140 --> 00:18:33.000
I love the discoverability that enums give you, right?


00:18:33.000 --> 00:18:36.920
You can say enumy thing dot, and then there's the list of things.


00:18:36.920 --> 00:18:40.380
You don't have to go research, like, well, what values can I pass for level?


00:18:40.380 --> 00:18:41.380
Is it 1, 2, 3?


00:18:41.380 --> 00:18:44.040
Is it a 0 to 1?


00:18:44.040 --> 00:18:45.580
It's like low, medium, high.


00:18:45.580 --> 00:18:46.580
Pick one.


00:18:46.580 --> 00:18:47.580
Yeah.


00:18:47.580 --> 00:18:48.580
Yeah.


00:18:48.580 --> 00:18:49.580
And they're reusable.


00:18:49.580 --> 00:19:04.300
You know i could look at any number and figure out oh i know what this you know i know what this code is doing without having to really read tons of comments are really worth enough i see your e-numbs i can know what you're doing i feel like that under underutilized in general.


00:19:04.300 --> 00:19:14.020
Brian anything definitely underutilized by me i and it's one of those things that i've it's on my list to try to use more i don't use magic numbers too much but i.


00:19:14.360 --> 00:19:23.000
We do have cases where it just uses string, but it really ought to be an enum instead of a set of possible strings.


00:19:23.000 --> 00:19:23.720
For sure.


00:19:23.720 --> 00:19:34.840
Cool. Well, I think one of the themes of the show today is that modern Python is definitely making its way past legacy Python, right? Python 3 is coming on strong.


00:19:34.840 --> 00:19:42.120
And if you look at what the real challenge, I think there's a lot of things that made this move a little bit difficult.


00:19:42.120 --> 00:19:50.320
But if you look at the heart of it, really the heart of what made the Python 2-3 migration challenging were strings, right?


00:19:50.320 --> 00:20:00.320
So the fact that strings used to be the same as bytes and you could either treat it as like a byte list or actually an encoded string and you had to kind of know that was a problem.


00:20:00.320 --> 00:20:10.320
But it was also an opportunity to have simpler code like request, for example, could talk to the network differently than it has to now because it doesn't have to like do the encoding and all these changes, right?


00:20:10.320 --> 00:20:12.320
But it's important that we have emojis


00:20:12.320 --> 00:20:15.160
and support other languages that have umlauts


00:20:15.160 --> 00:20:16.240
and things like that.


00:20:16.240 --> 00:20:18.160
So having a Unicode is really important.


00:20:18.160 --> 00:20:20.040
But I do feel like if you look at all the stuff,


00:20:20.040 --> 00:20:23.040
like people say, oh, Python 3, I can't move to that.


00:20:23.040 --> 00:20:26.120
That's so, it sounds like a, you know,


00:20:26.120 --> 00:20:28.700
like a huge problem, it's gonna be so hard.


00:20:28.700 --> 00:20:30.060
But then when you look at the code,


00:20:30.060 --> 00:20:32.160
like how hard is it to write Python 2 code


00:20:32.160 --> 00:20:33.060
that's compatible with 3?


00:20:33.060 --> 00:20:36.180
It's like not very different.


00:20:36.180 --> 00:20:37.840
But one of the big differences is strings.


00:20:37.840 --> 00:20:40.080
So what's interesting is that I wanna cover


00:20:40.080 --> 00:20:42.220
This comes from James Small.


00:20:42.220 --> 00:20:45.680
He sent over an episode of the CPP Cast,


00:20:45.680 --> 00:20:48.400
which is a C++ podcast.


00:20:48.400 --> 00:20:49.440
I think one of the bigger ones.


00:20:49.440 --> 00:20:50.820
I don't really know all of them,


00:20:50.820 --> 00:20:53.020
but I definitely know of that one.


00:20:53.020 --> 00:20:57.560
And Herb Sutter, who was instrumental in C++,


00:20:57.560 --> 00:20:58.560
he was interviewed there,


00:20:58.560 --> 00:21:01.840
and the interviewers asked,


00:21:01.840 --> 00:21:04.960
"If you could go back and change C++ types,


00:21:04.960 --> 00:21:06.200
"what changes would you make?"


00:21:06.200 --> 00:21:07.720
and so on.


00:21:07.720 --> 00:21:10.800
And basically the answer was almost exactly what happened


00:21:10.800 --> 00:21:12.120
going from Python two to three.


00:21:12.120 --> 00:21:13.160
- Yeah, that was interesting.


00:21:13.160 --> 00:21:14.120
- Yeah, pretty interesting, right?


00:21:14.120 --> 00:21:17.380
So if it was possible, the C++ guys very well


00:21:17.380 --> 00:21:19.100
may have done exactly what we did


00:21:19.100 --> 00:21:20.920
to go from Python two to three.


00:21:20.920 --> 00:21:22.580
And it was like, we're gonna take strings


00:21:22.580 --> 00:21:24.280
and split them into Unicode characters


00:21:24.280 --> 00:21:26.480
and byte arrays and things like that.


00:21:26.480 --> 00:21:29.120
And so, I don't know, I feel like if that's really


00:21:29.120 --> 00:21:31.200
the essence of what is holding back people


00:21:31.200 --> 00:21:33.480
switching from two to three, I don't know,


00:21:33.480 --> 00:21:35.640
it just doesn't seem like that's that big of a deal.


00:21:35.640 --> 00:21:40.200
I know if you're writing requests or you're writing stuff that literally is a web server


00:21:40.200 --> 00:21:43.640
and you're talking on the network, okay, that's kind of a bigger deal.


00:21:43.640 --> 00:21:45.960
But in general, it doesn't seem like it's that big of a deal.


00:21:45.960 --> 00:21:51.400
Yeah, the big deal was that the Python, I think, from my perspective, that the Python


00:21:51.400 --> 00:21:58.120
strings used in two matched the idea of a character array in C.


00:21:58.120 --> 00:22:04.160
And so all of the DLLs that some packages interacted with could just interact with it


00:22:04.160 --> 00:22:05.160
directly.


00:22:05.160 --> 00:22:09.720
interacting with bytes, you're already doing something funky anyway. But now you have to


00:22:09.720 --> 00:22:14.440
split that up. And sometimes, you know what it's like, we're going to see sometimes you're


00:22:14.440 --> 00:22:21.320
using a character array, but it's really not characters, it's really bytes. And so when they


00:22:21.320 --> 00:22:24.760
were really strings, and when when they were just byte arrays, yeah, it's messy.


00:22:24.760 --> 00:22:26.360
Yeah, yeah, it's definitely messy.


00:22:26.360 --> 00:22:31.720
So I haven't used Python for the purpose of byte arrays before I did most of my,


00:22:32.520 --> 00:22:35.200
Python codes have been scripts.


00:22:35.200 --> 00:22:37.400
I haven't used it for web services.


00:22:37.400 --> 00:22:38.880
So is this something that's very common?


00:22:38.880 --> 00:22:41.280
And I have used Cython.


00:22:41.280 --> 00:22:44.400
So does that make use of strings as byte arrays,


00:22:44.400 --> 00:22:45.560
or am I overthinking this?


00:22:45.560 --> 00:22:48.760
- I think in Cython they have their own types


00:22:48.760 --> 00:22:50.040
for these types of things.


00:22:50.040 --> 00:22:51.720
I'm not 100% sure, but I think so.


00:22:51.720 --> 00:22:54.720
Like you could have pointers in Cython and stuff like that.


00:22:54.720 --> 00:22:57.400
In terms of, so you,


00:22:57.400 --> 00:23:00.560
basically now we have strings and we have lists, right?


00:23:00.560 --> 00:23:03.560
But lists are not at all like byte arrays, right?


00:23:03.560 --> 00:23:06.660
I can't pass it off to C as a contiguous block of memory


00:23:06.660 --> 00:23:08.160
of similar data, right?


00:23:08.160 --> 00:23:09.000
But you can actually create--


00:23:09.000 --> 00:23:09.840
- Sure.


00:23:09.840 --> 00:23:10.820
- Arrays that are typed.


00:23:10.820 --> 00:23:13.100
I can say I have arrays that hold bytes


00:23:13.100 --> 00:23:15.080
or arrays that hold integers and there's some--


00:23:15.080 --> 00:23:16.840
- You can do that in Python, you know.


00:23:16.840 --> 00:23:20.080
- I forget exactly what module you gotta use to do it,


00:23:20.080 --> 00:23:21.040
but there's some way to say,


00:23:21.040 --> 00:23:24.880
I have this homogeneous thing that I'm creating.


00:23:24.880 --> 00:23:27.320
It's something I've extremely rarely have done,


00:23:27.320 --> 00:23:29.560
so I forgot the steps of it.


00:23:29.560 --> 00:23:32.120
But yeah, there's some mechanism in there to do that.


00:23:32.120 --> 00:23:36.200
Yeah, and you can prefix a string with the B character in it.


00:23:36.200 --> 00:23:40.080
And then you can put byte codes inside of it for constants.


00:23:40.080 --> 00:23:41.200
That doesn't sound so bad.


00:23:41.200 --> 00:23:44.320
Although, the prefix strings, there's only 26 of them.


00:23:44.320 --> 00:23:45.360
So we'll see.


00:23:45.360 --> 00:23:47.200
We know there's an F and a B.


00:23:47.200 --> 00:23:52.400
Oh, we could probably put an OXU114 as a prefix.


00:23:52.400 --> 00:23:53.800
Yeah, so I don't know.


00:23:53.800 --> 00:23:57.840
I guess when I was thinking about this, the idea is pretty straightforward.


00:23:57.840 --> 00:24:01.160
but I'm just wondering, could the PSF,


00:24:01.160 --> 00:24:03.100
it just got me thinking about the whole transition


00:24:03.100 --> 00:24:07.060
from two to three, could the PSF been more proactive


00:24:07.060 --> 00:24:09.080
and strategical?


00:24:09.080 --> 00:24:11.200
Like could the PSF said, hey, it's super important


00:24:11.200 --> 00:24:12.280
we make this change.


00:24:12.280 --> 00:24:15.460
It looks like these seven libraries are the foundation


00:24:15.460 --> 00:24:18.840
of all the other libraries that are all stuck on Python 2


00:24:18.840 --> 00:24:21.120
because none of these are changing.


00:24:21.120 --> 00:24:24.460
Could we just raise $200,000, hire some people


00:24:24.460 --> 00:24:27.460
and just in three months, upgrade all these libraries


00:24:27.460 --> 00:24:28.960
and just be done with it?


00:24:28.960 --> 00:24:30.540
How would the world look different


00:24:30.540 --> 00:24:33.200
if there was a quick and focused response


00:24:33.200 --> 00:24:34.480
to this challenge?


00:24:34.480 --> 00:24:36.980
Right, 'cause I feel like the actual problem


00:24:36.980 --> 00:24:38.300
that most people hit was,


00:24:38.300 --> 00:24:41.060
the library I care about doesn't support Python 2.


00:24:41.060 --> 00:24:43.260
That library actually, sorry, three,


00:24:43.260 --> 00:24:45.340
that library only supported Python 2,


00:24:45.340 --> 00:24:46.580
not because that's what it wanted,


00:24:46.580 --> 00:24:49.700
but because the library it was based on only supported 2.


00:24:49.700 --> 00:24:51.780
It was like this sort of chain,


00:24:51.780 --> 00:24:54.500
and the lowest level pieces were getting everyone stuck.


00:24:54.500 --> 00:24:56.380
So, I don't know, it's interesting.


00:24:56.380 --> 00:24:59.260
There's so many corner cases that, like for instance,


00:24:59.260 --> 00:25:03.040
the hiccup for me was it was one library.


00:25:03.040 --> 00:25:06.980
And it was because the DLL,


00:25:06.980 --> 00:25:11.100
that the library is a thin wrapper around a DLL.


00:25:11.100 --> 00:25:14.060
And that DLL interaction was all this,


00:25:14.060 --> 00:25:15.660
the different ways--


00:25:15.660 --> 00:25:17.060
- It's a character pointer type thing, yeah.


00:25:17.060 --> 00:25:19.300
- Yeah, but it's on top of that,


00:25:19.300 --> 00:25:21.620
one of the hiccups wasn't just because of this.


00:25:21.620 --> 00:25:25.460
It was also because the way that Python libraries


00:25:25.460 --> 00:25:30.060
interact with DLLs, that changed completely also from two to three.


00:25:30.060 --> 00:25:31.060
Yeah.


00:25:31.060 --> 00:25:32.060
Okay.


00:25:32.060 --> 00:25:33.260
Yeah, the C extensions and stuff like that.


00:25:33.260 --> 00:25:34.260
Yeah.


00:25:34.260 --> 00:25:39.940
So the library that I needed was, that was just some complicated beast that a university


00:25:39.940 --> 00:25:44.460
in Germany finally had some people that converted it to Python 3.


00:25:44.460 --> 00:25:45.460
So well done.


00:25:45.460 --> 00:25:46.460
Well done, academia.


00:25:46.460 --> 00:25:47.460
Well done.


00:25:47.460 --> 00:25:48.460
Nice.


00:25:48.460 --> 00:25:49.460
All right.


00:25:49.460 --> 00:25:51.740
Well, that's our main topics today.


00:25:51.740 --> 00:25:54.060
I wanna just throw out, see if you all have a couple


00:25:54.060 --> 00:25:56.660
of extras, real quick things to touch on.


00:25:56.660 --> 00:26:00.100
I do wanna bring up this thing that Devo Kaplan sent over.


00:26:00.100 --> 00:26:02.420
He was listening to one of our episodes.


00:26:02.420 --> 00:26:04.220
I don't remember what we were even talking about,


00:26:04.220 --> 00:26:07.700
but it was something crazy about what happens


00:26:07.700 --> 00:26:10.380
when you pip install a thing, maybe running some code


00:26:10.380 --> 00:26:11.980
as part of the setup UI and so on.


00:26:11.980 --> 00:26:14.300
And so he said, all right, well, let me see


00:26:14.300 --> 00:26:16.460
if I can create something that's kind of funny


00:26:16.460 --> 00:26:19.140
and amusing based on what we've been talking about.


00:26:19.140 --> 00:26:21.440
So he created a package called mystery.


00:26:21.440 --> 00:26:26.800
Okay, so this sounds like a Russian roulette type situation. Yes, it does to me too


00:26:26.800 --> 00:26:30.900
So if you pip install a mystery it will then go and like randomly pick


00:26:30.900 --> 00:26:36.760
Something else out of pipe out of the package index and then install that so you never know what you get you can just pip


00:26:36.760 --> 00:26:42.140
It's gonna be it's gonna be a mystery. I don't actually recommend using this in production by the way


00:26:42.140 --> 00:26:49.020
Well, it'd be fun to give a try. It could be you could be installing numpy or numpy


00:26:49.040 --> 00:26:53.800
We had we've I've always thought about which one to describe or it could be something that


00:26:53.800 --> 00:26:58.780
Totally changes the language or something that takes 10 hours to install you never know


00:26:58.780 --> 00:27:01.860
Maybe do it in a virtual machine that you can erase later. Yeah


00:27:01.860 --> 00:27:06.760
also, I just want to give a shout out to the book that I released the effective pi charm book and


00:27:06.760 --> 00:27:13.760
Point out that if people are interested in the pi charm course and or the pi charm book if you go to effective pi charm comm


00:27:13.760 --> 00:27:15.560
I work Matt Harrison


00:27:15.560 --> 00:27:18.660
and I are running a bundle deal so you can get the course


00:27:18.660 --> 00:27:20.360
and the book discounted together.


00:27:20.360 --> 00:27:21.300
So check that out.


00:27:21.300 --> 00:27:22.760
And people, if they've already bought the course


00:27:22.760 --> 00:27:24.360
or they bought the bundle, shoot me a note


00:27:24.360 --> 00:27:27.160
and I'll give you the discount towards as,


00:27:27.160 --> 00:27:28.620
'cause you maybe bought it before this existed.


00:27:28.620 --> 00:27:30.520
So check that out. - That's awesome.


00:27:30.520 --> 00:27:31.520
- Yeah, thanks.


00:27:31.520 --> 00:27:32.640
Brian, how about you?


00:27:32.640 --> 00:27:33.480
What you got?


00:27:33.480 --> 00:27:38.000
- Just really quickly, the Python 3.8.0 Beta 1 is out.


00:27:38.000 --> 00:27:39.880
So if you're a package supporter,


00:27:39.880 --> 00:27:43.680
please go test your package and make sure that,


00:27:43.680 --> 00:27:45.940
That sounded weird, but go test your code


00:27:45.940 --> 00:27:48.680
to make sure that it works with Python 3.8.


00:27:48.680 --> 00:27:49.840
- That's super new.


00:27:49.840 --> 00:27:50.840
So this is beta one, right?


00:27:50.840 --> 00:27:51.680
This is a big deal.


00:27:51.680 --> 00:27:53.040
It's like the first feature freeze.


00:27:53.040 --> 00:27:54.680
- Yeah. - Yeah, cool.


00:27:54.680 --> 00:27:56.320
Max, how about you?


00:27:56.320 --> 00:27:58.080
- All right, well, thanks for letting me talk


00:27:58.080 --> 00:28:01.400
about my own podcast, which is called The Local Maximum.


00:28:01.400 --> 00:28:02.520
- Of course, it's a good one.


00:28:02.520 --> 00:28:03.480
I've listened to it.


00:28:03.480 --> 00:28:04.400
It's high quality.


00:28:04.400 --> 00:28:05.360
I definitely like it.


00:28:05.360 --> 00:28:06.200
Tell people about it.


00:28:06.200 --> 00:28:07.020
- Yeah, very cool.


00:28:07.020 --> 00:28:08.960
Well, it's a weekly tech podcast.


00:28:08.960 --> 00:28:11.680
And so I cover both the theoretical issues


00:28:11.680 --> 00:28:14.500
in probability theory, philosophy, and machine learning,


00:28:14.500 --> 00:28:16.540
but then I kind of apply it in a practical way


00:28:16.540 --> 00:28:18.220
to things like current events


00:28:18.220 --> 00:28:20.180
and product development and interviews.


00:28:20.180 --> 00:28:23.600
And I do some like opinion piece type stuff


00:28:23.600 --> 00:28:24.440
as I did this week.


00:28:24.440 --> 00:28:27.080
So for example, a few weeks ago,


00:28:27.080 --> 00:28:29.020
my co-host asked a question,


00:28:29.020 --> 00:28:31.300
how do you estimate the probability of an event


00:28:31.300 --> 00:28:32.720
that has never occurred?


00:28:32.720 --> 00:28:36.180
And so we dove into that question and I started with,


00:28:36.180 --> 00:28:37.800
well, every event has never occurred,


00:28:37.800 --> 00:28:39.500
but what are you really asking me here?


00:28:39.500 --> 00:28:43.600
And some of the news that we've dived into recently


00:28:43.600 --> 00:28:46.420
is Apple's decision to break up iTunes,


00:28:46.420 --> 00:28:48.900
what that means in terms of product development,


00:28:48.900 --> 00:28:51.340
how the internet is shaping up in places like Cuba.


00:28:51.340 --> 00:28:52.940
I find that stuff really interesting


00:28:52.940 --> 00:28:55.460
and the controversy around YouTube's


00:28:55.460 --> 00:28:57.100
recommendation algorithm.


00:28:57.100 --> 00:28:59.660
I also talk a lot about data science careers


00:28:59.660 --> 00:29:02.700
and I interview people like Hillary Mason here in New York


00:29:02.700 --> 00:29:05.300
and Mark Sanodella, who's the CEO of the latter's.


00:29:05.300 --> 00:29:08.260
He critiqued my resume on my podcast.


00:29:08.260 --> 00:29:09.100
That was very fun.


00:29:09.100 --> 00:29:10.260
That's a little stressful, huh?


00:29:10.260 --> 00:29:13.460
Yeah, he had me rewrite my resume.


00:29:13.460 --> 00:29:17.700
So yeah, there's probably something for everybody.


00:29:17.700 --> 00:29:19.020
It's the type of thing.


00:29:19.020 --> 00:29:21.260
I don't know if it's--


00:29:21.260 --> 00:29:23.100
I don't know if there's anyone who's into it


00:29:23.100 --> 00:29:27.740
every single week or if most people kind of skip around.


00:29:27.740 --> 00:29:29.140
But either way, it's cool with me.


00:29:29.140 --> 00:29:29.940
Yeah, it's cool.


00:29:29.940 --> 00:29:34.300
I like that it's technical, but not deeply technical.


00:29:34.300 --> 00:29:36.260
You can kind of make it casual listening, too.


00:29:36.260 --> 00:29:36.940
Yeah, yeah.


00:29:36.940 --> 00:29:37.180
Nice.


00:29:37.180 --> 00:29:37.680
All right.


00:29:37.680 --> 00:29:43.240
Well, I have a quick joke for you guys, and then Brian has an idea for something completely


00:29:43.240 --> 00:29:44.240
different.


00:29:44.240 --> 00:29:47.800
So, you know, Brian, they say there's only two hard problems in computer science, right?


00:29:47.800 --> 00:29:49.080
Yeah, tell me what they are.


00:29:49.080 --> 00:29:52.240
It's cache invalidation, naming things, and off by one errors.


00:29:52.240 --> 00:29:54.320
I love that joke.


00:29:54.320 --> 00:29:55.920
Yeah, it's a good one.


00:29:55.920 --> 00:29:59.240
All right, so I think you need to give a short explanation.


00:29:59.240 --> 00:30:01.440
There's also off by two errors.


00:30:01.440 --> 00:30:02.440
That's right.


00:30:02.440 --> 00:30:07.080
I think you need to give an explanation for what is about to come, because it actually


00:30:07.080 --> 00:30:09.800
is something completely different. Why are we going to do what we're about to do?


00:30:09.800 --> 00:30:17.160
Okay, so the Python 3.8.0 Beta 1 release notes, I was skimming down this and there's some pretty


00:30:17.160 --> 00:30:21.240
exciting stuff there. So I'm going to, I'm excited to try it out. But at the bottom,


00:30:21.240 --> 00:30:28.120
it says, and now for something completely different. And then it has like a skit from,


00:30:28.120 --> 00:30:32.840
it sounds, it looks like a little snippet of an interview from some of the Monty Python people.


00:30:32.840 --> 00:30:35.360
- Yeah, and I suspect most people know,


00:30:35.360 --> 00:30:36.680
but for those of you who don't,


00:30:36.680 --> 00:30:39.720
Python has nothing to do with a snake in its naming.


00:30:39.720 --> 00:30:41.260
It comes from Monty Python.


00:30:41.260 --> 00:30:43.360
That's what Guido got the inspiration from, right?


00:30:43.360 --> 00:30:45.420
- Yeah, even though all the logos are snakes,


00:30:45.420 --> 00:30:46.260
nobody knows why. - Yes, I know.


00:30:46.260 --> 00:30:48.400
- They should be cheese or something, I don't know.


00:30:48.400 --> 00:30:49.840
- We should change our logos to like,


00:30:49.840 --> 00:30:51.640
cheese and maybe a knight with no legs.


00:30:51.640 --> 00:30:53.840
- Yeah, yeah, rabbit, killer rabbit.


00:30:53.840 --> 00:30:55.680
- Yeah, oh. (laughs)


00:30:55.680 --> 00:30:57.320
Get the holy hand grenade out there.


00:30:57.320 --> 00:30:59.560
All right, so now for something completely different.


00:30:59.560 --> 00:31:01.560
- Yeah, I thought we could read this skit out.


00:31:01.560 --> 00:31:03.480
So are you guys ready?


00:31:03.480 --> 00:31:04.320
- Let's do it.


00:31:04.320 --> 00:31:05.440
- I'll try to do it with feeling,


00:31:05.440 --> 00:31:06.880
but I'm not very good with accents.


00:31:06.880 --> 00:31:09.440
So we'll see what happens.


00:31:09.440 --> 00:31:10.280
- Okay.


00:31:10.280 --> 00:31:11.100
- This is entirely in rehearsal.


00:31:11.100 --> 00:31:11.940
Let's do it.


00:31:11.940 --> 00:31:12.780
- Okay.


00:31:12.780 --> 00:31:13.620
- So who'd have thought 30 years ago


00:31:13.620 --> 00:31:15.360
that we'd all be sitting here drinking


00:31:15.360 --> 00:31:17.360
Chateau de Chassolet wine?


00:31:17.360 --> 00:31:18.840
- Aye, in them days,


00:31:18.840 --> 00:31:21.640
we'd be glad to have the price of a cup of tea.


00:31:21.640 --> 00:31:23.560
- A cup of cold tea.


00:31:23.560 --> 00:31:25.760
- With milk, without milk or sugar.


00:31:25.760 --> 00:31:26.600
- Or tea.


00:31:26.600 --> 00:31:27.880
- In a filthy crack cup.


00:31:27.880 --> 00:31:29.000
- We never used to have a cup.


00:31:29.000 --> 00:31:31.440
We used to drink tea out of a rolled up newspaper.


00:31:31.440 --> 00:31:35.120
The best we could manage was to suck on a piece of damp cloth.


00:31:35.120 --> 00:31:38.100
But you try and tell the young people today that, hey,


00:31:38.100 --> 00:31:39.040
won't believe you.


00:31:39.040 --> 00:31:39.540
No.


00:31:39.540 --> 00:31:40.040
Nope.


00:31:40.040 --> 00:31:40.540
Nope.


00:31:40.540 --> 00:31:43.320
Not at all.


00:31:43.320 --> 00:31:44.040
All right, folks.


00:31:44.040 --> 00:31:46.580
That was literally at the end of the official release notes


00:31:46.580 --> 00:31:47.440
for Python 3.8.


00:31:47.440 --> 00:31:48.280
So pretty cool.


00:31:48.280 --> 00:31:50.080
Good read through, people.


00:31:50.080 --> 00:31:52.520
All right, Max, thank you for joining us, Brian and me,


00:31:52.520 --> 00:31:53.160
on the show today.


00:31:53.160 --> 00:31:54.360
It was fun to have you as a guest.


00:31:54.360 --> 00:31:55.700
Thank you so much for having me.


00:31:55.700 --> 00:31:56.200
Thanks.


00:31:56.200 --> 00:31:57.320
This was a lot of fun.


00:31:57.320 --> 00:31:58.560
Brian, thanks as always.


00:31:58.560 --> 00:31:59.160
See you later.


00:31:59.160 --> 00:31:59.640
Thank you.


00:31:59.640 --> 00:32:00.120
Bye.


00:32:00.120 --> 00:32:01.820
Thank you for listening to Python Bytes.


00:32:01.820 --> 00:32:04.280
Follow the show on Twitter via @pythonbytes.


00:32:04.280 --> 00:32:07.320
That's Python Bytes as in B-Y-T-E-S.


00:32:07.320 --> 00:32:10.520
And get the full show notes at pythonbytes.fm.


00:32:10.520 --> 00:32:12.140
If you have a news item you want featured,


00:32:12.140 --> 00:32:14.600
just visit pythonbytes.fm and send it our way.


00:32:14.600 --> 00:32:17.480
We're always on the lookout for sharing something cool.


00:32:17.480 --> 00:32:19.320
On behalf of myself and Brian Auchin,


00:32:19.320 --> 00:32:20.640
this is Michael Kennedy.


00:32:20.640 --> 00:32:22.640
Thank you for listening and sharing this podcast


00:32:22.640 --> 00:32:24.280
with your friends and colleagues.

