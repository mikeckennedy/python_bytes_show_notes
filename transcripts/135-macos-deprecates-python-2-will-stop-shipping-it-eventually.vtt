WEBVTT

00:00:00.001 --> 00:00:04.540
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly

00:00:04.540 --> 00:00:10.300
to your earbuds. This is episode 135, recorded June 12th, 2019. I'm Michael Kennedy.

00:00:10.300 --> 00:00:11.120
And I'm Brian Okken.

00:00:11.120 --> 00:00:12.000
And I'm Max Sklar.

00:00:12.000 --> 00:00:14.040
Yeah, welcome to the show. It's great to have you here.

00:00:14.040 --> 00:00:15.020
Good to be here today.

00:00:15.020 --> 00:00:18.560
You're here. You've got your own podcast, and we're definitely going to talk a little bit

00:00:18.560 --> 00:00:21.960
about that at the end, and that'll be great. I do, before we kick things off, though,

00:00:21.960 --> 00:00:24.980
I also want to say thank you to DigitalOcean for sponsoring the show. Check them out at

00:00:24.980 --> 00:00:28.600
pythonbytes.fm/digitalocean. More about them later as well.

00:00:28.600 --> 00:00:34.280
Okay, so Reuven Lerner, he's got an email list that I'm signed up to. One of the things

00:00:34.280 --> 00:00:38.480
that he pointed out in one of the recent, I can't remember if it was on his email list

00:00:38.480 --> 00:00:43.780
or if it was on one of his blog posts. So I'm linking to a blog post. But it's this idea that

00:00:43.780 --> 00:00:49.660
I didn't even know you could do this. It's titled, why do Python lists let you do plus equals

00:00:49.660 --> 00:00:56.580
or in place assign addition with a tuple? We can't do plus with a tuple. So here's the idea is you got

00:00:56.580 --> 00:01:03.140
you got a list, and you want to add, combine the elements of a list and a tuple end up with a

00:01:03.140 --> 00:01:09.560
list at the end. You can't just add them because they're different types. But you can do incremental

00:01:09.560 --> 00:01:16.400
add. And it's just weird. I was like, I didn't know you could do that. But it turns out it's a

00:01:16.400 --> 00:01:22.660
little surprising. But it just is because the plus equals is not, I always think of it as equivalent

00:01:22.660 --> 00:01:29.620
to like x equal x plus equals one is the same as x equals x plus one. That's what I thought. But it

00:01:29.620 --> 00:01:34.220
turns out it's actually a different, it's a different call. It's implemented as a different call. I see like

00:01:34.220 --> 00:01:40.220
a different Dunder method, like a different magic method is being called. Yeah. And the Dunder method for

00:01:40.220 --> 00:01:46.340
list increment or in place add is what it does is it takes any iterable on the right hand side,

00:01:46.340 --> 00:01:53.560
and adds it one element at a time to the left side. So you can plus equals any iterable onto a list.

00:01:53.560 --> 00:01:56.300
That's neat. I didn't know you could do that. That's cool.

00:01:56.300 --> 00:02:01.820
This is so weird. I mean, it's cool. And it's it's fine that plus equals will do that. And I actually

00:02:01.820 --> 00:02:06.660
just tried it. I created a list of a bunch of numbers. And then I plus equaled it with a string.

00:02:06.880 --> 00:02:11.340
And now I have a list that's full of numbers and single characters that made up that string,

00:02:11.340 --> 00:02:15.640
which is, which is, it's okay, if that's the behavior, and it seems actually like the most

00:02:15.640 --> 00:02:19.920
reasonable behavior. But then why can't you just plus them, right? Like, it seems odd that it's

00:02:19.920 --> 00:02:25.020
inconsistent. Plus, it seems like it should just create another list with that same behavior.

00:02:25.020 --> 00:02:31.280
So yeah, not sure. Yeah, exactly. I assume there's a better way to turn a tuple into a list. But

00:02:31.280 --> 00:02:36.500
now that I'm looking at this, you could just create an empty list and then do plus equals your tuple.

00:02:36.500 --> 00:02:41.380
There you go. Your conversion. It's all it's all filled up. Yeah, it's definitely not the most

00:02:41.380 --> 00:02:46.740
obvious way. Yeah, probably the initializer constructor of the list is best just pass it

00:02:46.740 --> 00:02:52.180
the iterable. But yeah, this is interesting. Also, if the three of us didn't know you could do this,

00:02:52.180 --> 00:02:57.300
probably don't do this in your code, because nobody will understand it. But it's interesting.

00:02:57.300 --> 00:02:59.480
Yeah. Also, please don't put this in a job interview.

00:03:02.400 --> 00:03:04.800
Yeah. Don't make this one of these things.

00:03:04.800 --> 00:03:08.040
Oh, one of those questions that you mean an interview question?

00:03:08.040 --> 00:03:14.580
Yeah, exactly. Like, what form of sort does a list use? What does a list plus a tuple mean? What

00:03:14.580 --> 00:03:19.540
does list plus equals? No, this belongs in a Watt talk, not in a job interview.

00:03:19.540 --> 00:03:20.960
Yeah, definitely.

00:03:21.280 --> 00:03:27.380
I think this is interesting, because Python is mostly devoid of these like weird oddities,

00:03:27.380 --> 00:03:31.740
right? It's mostly a pretty polished, simple, clean language. But yeah, this is weird.

00:03:31.740 --> 00:03:37.900
Gary Bernhardt could incorporate this in a talk, I'm pretty sure. Nice. All right. Speaking of

00:03:37.900 --> 00:03:43.420
jobs and growth and things that you might actually want to pay attention to or decide on, Max,

00:03:43.420 --> 00:03:44.300
what's this next one you got?

00:03:44.300 --> 00:03:50.820
This is an article called R versus Python. R is out of the top 20 languages, despite statistical

00:03:50.820 --> 00:03:56.880
boom. And I know you guys have covered on the show before the whole R versus Python dynamic,

00:03:56.880 --> 00:04:02.100
all these articles coming out. This is I'm not going to be anti R here, but even though I'm a Python guy.

00:04:02.100 --> 00:04:07.120
So the article is about an index on the popularity of programming languages. And this organization,

00:04:07.120 --> 00:04:13.160
TIOB does one. I know that there could be, I imagine that there's some controversy around

00:04:13.160 --> 00:04:17.660
how to rank them. I'm just going to assume that they're doing a pretty good job. There's a few

00:04:17.660 --> 00:04:21.980
stories here, a few headlines. The first is that like Python hit an all time high. It's now

00:04:21.980 --> 00:04:29.440
language is at ranking number three on the chart. So it's just beats out, it beats out C++,

00:04:29.440 --> 00:04:36.420
I believe for the first time, only Java and C are more popular than Python. And the other story is

00:04:36.420 --> 00:04:43.360
that the statistical language R dipped to number 21. And so the speculation is that Python has sort

00:04:43.360 --> 00:04:48.880
of taken over as the preferred statistical language to R. And then personally, I got into Python because

00:04:48.880 --> 00:04:56.160
I kind of came at data science and ML from a software development perspective. I took CS, I learned C and

00:04:56.160 --> 00:05:01.300
Java. And so going over to Python was came a lot more naturally to me than going over to R.

00:05:01.300 --> 00:05:06.520
If you were say a statistician, maybe, maybe coming from R makes more sense, right? Or from MATLAB or

00:05:06.520 --> 00:05:07.160
something like that, right?

00:05:07.160 --> 00:05:14.460
Yes, yes. And I have worked with and met people who do that. And they have probably extra skills that I

00:05:14.460 --> 00:05:18.960
don't have, like they could do certain things a lot faster. So again, I'm not like anti R, but I'm just,

00:05:19.140 --> 00:05:25.280
I think from the programmer's perspective, Python is a lot nicer for some people, people like me.

00:05:25.280 --> 00:05:29.160
So personally, I'm going to stick with Python, because there's so many statistical libraries that

00:05:29.160 --> 00:05:33.520
even I have yet to learn, and it's served me very well thus far. And then the third thing I wanted to

00:05:33.520 --> 00:05:38.360
point out the language that I use most in the recent years in is Scala. And that's surprisingly down

00:05:38.360 --> 00:05:43.900
to 31, which I looking at companies around here in New York at like startups, there's a lot that use

00:05:43.900 --> 00:05:45.500
Scala. So I was surprised it was that low. But

00:05:45.500 --> 00:05:51.580
Well, I feel like Scala and those functional languages, they tend to be very popular in the

00:05:51.580 --> 00:05:52.640
financial space, right?

00:05:52.640 --> 00:05:53.360
Maybe, yeah.

00:05:53.360 --> 00:05:56.160
You definitely are in the center of that and being in New York, right?

00:05:56.160 --> 00:06:00.400
Yes, but a lot of, you know, Foursquare, where I worked for a long time was Scala based,

00:06:00.400 --> 00:06:06.760
Twitter. So there's a lot of companies like that, social media, consumer app companies that use it.

00:06:06.760 --> 00:06:12.540
So why do you think this is? Why do you think Python is? I mean, you talked about why you were

00:06:12.540 --> 00:06:18.160
more comfortable with it, but it's a general trend. Even people who are scientific are taking up Python

00:06:18.160 --> 00:06:19.940
at much larger numbers. Why do you think that is?

00:06:19.940 --> 00:06:25.900
When companies actually want to apply machine learning or statistical methods to their data,

00:06:25.900 --> 00:06:33.120
they already have a lot of engineers and developers. And if you already have people who are

00:06:33.120 --> 00:06:38.420
fluent in Python, then why not use Python? Python has a lot of great libraries,

00:06:38.420 --> 00:06:44.480
NumPy is really great. And then a lot of the more sophisticated machine learning libraries are

00:06:44.480 --> 00:06:47.320
really great. So there's too many benefits, I think.

00:06:47.320 --> 00:06:51.060
Yeah, I definitely agree with that. I think another one has to do with the fact that Python

00:06:51.060 --> 00:06:57.200
is a full spectrum language. Like, I can come with a very partial understanding of what Python is and

00:06:57.200 --> 00:07:01.680
what it does. And I can still be productive. If I know how to pip install a thing, write code,

00:07:01.680 --> 00:07:06.140
I don't even know what a function or a class is. I can do amazing. I could spin up a machine learning

00:07:06.140 --> 00:07:07.400
model and do something with it, right?

00:07:07.400 --> 00:07:08.200
Yeah.

00:07:08.200 --> 00:07:14.700
But at the same time, that piece can grow and grow into a fully distributed application or something

00:07:14.700 --> 00:07:20.140
like that, right? There's not many languages that start that simple. And yet, most of the simple

00:07:20.140 --> 00:07:25.160
languages, they top out. And you say, well, now you go do C++. I hope you like templates. Good luck.

00:07:25.160 --> 00:07:25.480
Yeah.

00:07:25.480 --> 00:07:28.380
I'm still stumped as to why Java is at the top.

00:07:28.380 --> 00:07:31.520
That is a good question.

00:07:31.520 --> 00:07:32.460
You know what I think?

00:07:32.460 --> 00:07:33.560
Probably a lot of legacy.

00:07:33.560 --> 00:07:38.680
Yeah, I think that that's true. And I think the legacy is in two places. I think if you care

00:07:38.680 --> 00:07:44.720
about open source, but you want a compiled modern language, Java is a pretty good choice. Like,

00:07:44.720 --> 00:07:50.860
you know, C Sharp, C++, those are also good. But C++ doesn't have garbage collection and C Sharp

00:07:50.860 --> 00:07:52.140
is tied to Microsoft, right?

00:07:52.700 --> 00:08:00.000
So, I can see that that's one of the things. I also think the academics, Stanford and Carnegie

00:08:00.000 --> 00:08:06.640
Mellon and all that stuff, very much for many, for a long time, taught Java, Java, Java as the

00:08:06.640 --> 00:08:12.540
way to do things. And so, the folks at the high end of decision making probably had that experience

00:08:12.540 --> 00:08:14.640
as well. So, I don't know. That's my theory.

00:08:14.640 --> 00:08:18.860
Okay. I'm not sure if there's this article or another one related to this that predict,

00:08:19.080 --> 00:08:23.100
I don't know if you already covered this, that predicted that Python will be at the top

00:08:23.100 --> 00:08:24.260
within like four years.

00:08:24.260 --> 00:08:26.360
Yeah, that it's going to surpass Java and C.

00:08:26.360 --> 00:08:27.000
Yeah.

00:08:27.000 --> 00:08:30.800
I mean, just look at the growth curves, right? Some are either flat or downward and Python

00:08:30.800 --> 00:08:35.920
is like highly up. So, pretty awesome. Very cool to be working in the Python space. It's exciting.

00:08:35.920 --> 00:08:37.380
Like every day is super exciting.

00:08:37.380 --> 00:08:43.500
If, like we said, Java is very popular because of, you know, there's a lot of legacy code written

00:08:43.500 --> 00:08:49.940
in Java, but new projects, I don't know if there's another score for new projects, but I assume that

00:08:49.940 --> 00:08:51.520
Python is way higher.

00:08:51.520 --> 00:08:54.840
Yeah, that's probably, it probably is. I don't know where to find that either, but it'd be cool to have

00:08:54.840 --> 00:08:55.200
that data.

00:08:55.200 --> 00:08:55.460
Yeah.

00:08:55.460 --> 00:08:57.860
Speaking of exciting, Max, what OS do you use?

00:08:57.860 --> 00:08:58.780
I'm on macOS.

00:08:58.780 --> 00:09:02.780
Yeah. So, so am I. So is Brian. Even though the majority of Python developers are on Windows,

00:09:02.780 --> 00:09:06.600
we happen to all be there. So, we can all appreciate this next one that's coming here.

00:09:06.600 --> 00:09:13.000
So, I recently watched the WWDC and somehow I didn't notice this or they didn't announce it.

00:09:13.000 --> 00:09:18.120
It was just in the fine print, but Dan Bader from RealPython sent this over and there was an

00:09:18.120 --> 00:09:23.680
announcement, at least in the release notes for the new macOS. What is it? Catalina? Something like

00:09:23.680 --> 00:09:29.700
that. Whatever their name is it for the new macOS, the one that replaces Mojave. It is deprecating

00:09:29.700 --> 00:09:35.480
Python too. So finally, you know, finally we have like a super old version of Python running in macOS.

00:09:35.580 --> 00:09:41.280
And if you type Python, you get Python too. It doesn't ship with Python 3. Ideally, I would

00:09:41.280 --> 00:09:47.260
love to see Python 3 shipping. I kind of like what the Windows store and Microsoft is doing

00:09:47.260 --> 00:09:52.420
as an app that is auto updating and stuff like a really nice way to get it there. Instead,

00:09:52.420 --> 00:09:58.600
they're just saying, we've decided that Python and all the scripting runtimes, so Perl and Ruby and

00:09:58.600 --> 00:10:02.880
Python, those are not our problem anymore. We're washing our hands of them. That's the announcement.

00:10:02.980 --> 00:10:08.320
We are no longer recommending them. It is deprecated. We have to leave Python 2 there

00:10:08.320 --> 00:10:14.100
because stuff is depending upon it, but we do not recommend you use it at all, period. Find another

00:10:14.100 --> 00:10:14.720
way to get it there.

00:10:14.720 --> 00:10:15.840
Yeah, that is interesting.

00:10:15.840 --> 00:10:20.180
Yeah. So on one hand, like that's good news. They're like, please don't, I know it has Python

00:10:20.180 --> 00:10:24.340
on it, but this is a broken old one. Don't use that. I feel like there's maybe some better way

00:10:24.340 --> 00:10:28.220
they could approach that. I don't know if there'll be some kind of warning when you run it.

00:10:28.400 --> 00:10:35.240
That would be great, but it does make it actually harder to get the right version of Python onto your

00:10:35.240 --> 00:10:40.400
system. Like if you want to use homebrew, brew install Python, installs Python 3, but you know

00:10:40.400 --> 00:10:45.300
what brew runs on? Ruby, I believe, something like that. It depends on one of these things.

00:10:45.300 --> 00:10:49.880
So that's also, so like, if that's also not there, then how do you brew? And like,

00:10:49.880 --> 00:10:53.500
so there's a bunch of interesting changes here, but I do think it's interesting that

00:10:53.500 --> 00:10:57.640
Apple and the macOS team are addressing this Python story. What do you guys think?

00:10:57.640 --> 00:11:02.240
Yeah. Well, when did Python 3 come out? If you could remind me, was it?

00:11:02.240 --> 00:11:02.880
2008.

00:11:02.880 --> 00:11:03.460
Wow.

00:11:03.460 --> 00:11:09.120
But in realistically, I feel like 3.4 is where it really started to get traction. And that's

00:11:09.120 --> 00:11:12.180
more like 2012-ish, something like that.

00:11:12.180 --> 00:11:18.280
Okay. Yeah. I'm just, now I'm thinking, oh God, I have some scripts in my GitHub that I may need,

00:11:18.280 --> 00:11:20.980
may want to, that I built like five years ago. I may want to upgrade.

00:11:21.940 --> 00:11:25.780
I think it's a good thing, actually. I think it will be a good thing because

00:11:25.780 --> 00:11:32.420
people that just open up a terminal on Mac and type Python, they get 2.7 and that's not the right

00:11:32.420 --> 00:11:33.760
answer. So.

00:11:33.760 --> 00:11:34.120
Yeah.

00:11:34.120 --> 00:11:38.320
Yeah. And I've seen this where you always have two versions of Python on your machine.

00:11:38.320 --> 00:11:44.000
And there's always, did this the other day where you run the old version of Python and it doesn't

00:11:44.000 --> 00:11:50.380
work. And you're like, oh, I called the wrong command and it would be nice to kind of put an end

00:11:50.380 --> 00:11:52.540
to that. So it doesn't waste people's time.

00:11:52.540 --> 00:11:57.860
Yeah, absolutely. I'm tempted to put an alias to alias Python to Python 3 inside my startup script.

00:11:57.860 --> 00:11:58.640
Yeah.

00:11:58.640 --> 00:11:59.380
That's a good idea.

00:11:59.380 --> 00:12:05.180
Interesting. Well, I would like a better outcome, but at least there's some kind of like Apple

00:12:05.180 --> 00:12:10.020
acknowledges how out of date the stuff they're shipping is. So that's pretty cool. Now, before

00:12:10.020 --> 00:12:14.120
we get onto the next one, I want to talk really quickly about DigitalOcean. They've been a huge

00:12:14.120 --> 00:12:18.820
supporter of the show and we really appreciate that. Our infrastructure runs on DigitalOcean,

00:12:18.820 --> 00:12:24.200
which is pretty cool. So we can definitely recommend it from someone who's using it. Right.

00:12:24.200 --> 00:12:30.260
And I want to highlight their hosted database as a service right now. So if you want to use

00:12:30.260 --> 00:12:36.700
Postgres SQL, which is probably the most popular relational database these days in the Python space,

00:12:36.700 --> 00:12:41.200
you know, you look at the Stack Overflow survey and stuff like that. It's got a lot of love

00:12:41.380 --> 00:12:45.500
and people love it a lot. So they have hosted as a service. Just go there and say,

00:12:45.500 --> 00:12:49.340
I want Postgres. Turn it on. Here's the connection string. They'll do all the backups

00:12:49.340 --> 00:12:53.400
and scaling and failover and all that stuff for you. So super great. Check them out at

00:12:53.400 --> 00:12:58.920
pythonbytes.fm/DigitalOcean. And for new users, you get a $50 credit to get started,

00:12:58.920 --> 00:13:03.000
which is also cool. Brian, would you say that dictionaries are important in Python?

00:13:03.000 --> 00:13:07.980
Yeah, definitely. The whole thing's built on dictionaries. It's turtles all the way down.

00:13:07.980 --> 00:13:10.480
Exactly. It's turtles all the way down. It's dictionaries all the way down.

00:13:10.480 --> 00:13:11.700
So what's up with this one?

00:13:11.700 --> 00:13:17.900
This is just a small article from L. Swigert, Pythonic ways to use dictionaries. And I thought

00:13:17.900 --> 00:13:22.240
it was a good reminder because dictionaries really are not, I mean, they're not hard. They're not hard

00:13:22.240 --> 00:13:28.800
to use. People coming from, I guess I came from Perl before Python. So I was used to, I guess,

00:13:28.800 --> 00:13:30.960
what were they called in Perl? Hashes.

00:13:30.960 --> 00:13:33.240
Yeah. Hashes and hash maps and all these things, right?

00:13:33.360 --> 00:13:39.860
Yeah. Dictionaries are a lookup thing. And using them like that is not that hard. But there's some

00:13:39.860 --> 00:13:45.200
gotchas in there that some people try to do weird things to work around them. So this is just a

00:13:45.200 --> 00:13:51.060
highlight article that a few ways to use them smartly. One of them is to use the get function for,

00:13:51.200 --> 00:13:56.780
if you try to retrieve an element out of a dictionary and the element isn't there, that the key isn't

00:13:56.780 --> 00:14:00.100
isn't there, you get a, I don't know, a lookup error or something.

00:14:00.100 --> 00:14:00.760
A key error.

00:14:00.760 --> 00:14:06.420
A key error. But if you know it might not be there, so you can check beforehand or you can just use the

00:14:06.420 --> 00:14:12.560
get with a default. And the default value will return something other than if it's not there,

00:14:12.560 --> 00:14:13.440
it returns something else.

00:14:13.540 --> 00:14:17.580
That's the primary way that I get stuff out of dictionaries these days. I used to do square

00:14:17.580 --> 00:14:19.900
brackets, but I don't do that anymore. It's always about .get.

00:14:19.900 --> 00:14:20.880
Yeah, me too.

00:14:20.880 --> 00:14:27.000
I do that as well, especially since almost every dictionary is either, you know, something like

00:14:27.000 --> 00:14:32.000
a histogram or a sum of something where, you know, the default's always going to be zero. And

00:14:32.000 --> 00:14:35.560
I don't want to distinguish between that and it not being there.

00:14:35.560 --> 00:14:42.520
The key for me is almost always there's other kinds of validation you have to do anyway.

00:14:42.960 --> 00:14:45.900
So I'm thinking of the web, right? Like I want to get something posted on a form.

00:14:45.900 --> 00:14:50.320
I want to get the, say the email they've submitted. I want to know that it's there,

00:14:50.320 --> 00:14:54.100
but I also got to make sure that it's not empty or it's not none. Like if I'm already doing the

00:14:54.100 --> 00:14:59.660
if test, I don't want to do the conditional test and a try except you might as well just do one.

00:14:59.660 --> 00:15:02.160
The only one that's going to work is the if. So just use get.

00:15:02.160 --> 00:15:07.380
The set default actually was something I didn't even know was there, which I learned something new.

00:15:07.380 --> 00:15:09.220
I don't use that normally, but.

00:15:09.220 --> 00:15:10.120
What does that do?

00:15:10.360 --> 00:15:16.120
Set default will only set the value if the element does not exist yet.

00:15:16.120 --> 00:15:17.720
Yeah, that's perfect. Yeah, it makes a lot of sense.

00:15:17.720 --> 00:15:23.680
So like their example, his example and the thing is perfect is if you're storing a counter or something like a number of hours

00:15:23.680 --> 00:15:29.500
and you just want to increment, if you're trying to increment something, you want to set it to zero to begin with,

00:15:29.600 --> 00:15:32.580
but you only want it to set it to zero if it isn't there already.

00:15:32.580 --> 00:15:33.920
So that makes sense.

00:15:33.920 --> 00:15:35.160
Yeah. Yeah. Perfect.

00:15:35.160 --> 00:15:36.300
So you don't have to do that test.

00:15:36.300 --> 00:15:40.860
Then it also talks about using dictionaries as a switch statement, which I thought was a funny language hack.

00:15:41.280 --> 00:15:45.440
I actually went and created a switch statement for the language in Python.

00:15:45.440 --> 00:15:46.260
It's on GitHub.

00:15:46.260 --> 00:15:47.980
And it's really nice.

00:15:47.980 --> 00:15:53.940
I use it in some of like some really gnarly code that has got like 50 or 100 cases.

00:15:53.940 --> 00:16:00.200
And, you know, it's just a lot nicer because it'll do things like not let you have the same key twice, for example, things like that.

00:16:00.200 --> 00:16:01.840
So you do use it?

00:16:02.400 --> 00:16:03.340
Oh, yeah. I use it. I love it.

00:16:03.340 --> 00:16:04.980
It's like, I think it's great.

00:16:04.980 --> 00:16:06.100
It uses a width block.

00:16:06.100 --> 00:16:10.220
So it uses the width block as the switch block, basically.

00:16:10.220 --> 00:16:11.580
And then you just have cases in there.

00:16:11.580 --> 00:16:15.820
Anyway, it's kind of funky, but I'll put a link into it.

00:16:15.820 --> 00:16:18.960
But I do think it's interesting that dictionaries can be used for switch statements.

00:16:18.960 --> 00:16:19.340
Yeah.

00:16:19.340 --> 00:16:24.000
I think it's good to comment because not everybody's going to understand what's going on.

00:16:24.000 --> 00:16:26.080
So make a comment about what your code's doing.

00:16:26.080 --> 00:16:27.420
Yeah. Yeah, for sure.

00:16:27.420 --> 00:16:29.760
All right, Max, what's this next one you got?

00:16:29.760 --> 00:16:30.540
All right.

00:16:30.540 --> 00:16:31.860
Short article I found.

00:16:32.140 --> 00:16:35.120
Things you're probably not using in Python 3 but should.

00:16:35.120 --> 00:16:37.860
This is from datawhatnow.com.

00:16:37.860 --> 00:16:42.600
So this is particularly relevant for me because I used Python legacy at four square for many years.

00:16:42.600 --> 00:16:47.420
Now I'm coming back to it, taking another look at V3 over the last couple of years.

00:16:47.420 --> 00:16:51.200
So just a couple of things it has that stood out for me.

00:16:51.200 --> 00:16:57.660
One that looks very useful is f-strings, where you can put the variable name in braces in a string and just have it replaced.

00:16:57.660 --> 00:17:01.620
So long as you remember to put the character F before the string.

00:17:01.720 --> 00:17:02.540
That's very important.

00:17:02.540 --> 00:17:05.520
So I've seen things like this in other languages.

00:17:05.520 --> 00:17:06.420
Scala has it.

00:17:06.420 --> 00:17:09.660
PHP, most front-end scripts have things like this.

00:17:09.660 --> 00:17:10.980
It makes the code very readable.

00:17:10.980 --> 00:17:12.960
Except I know myself.

00:17:12.960 --> 00:17:16.340
I know I'm going to screw up by leaving out that straight F in front of the string.

00:17:16.560 --> 00:17:19.000
So I almost feel like it should be automatic.

00:17:19.000 --> 00:17:20.880
But it is very useful.

00:17:20.880 --> 00:17:21.900
Yeah, I feel the same way.

00:17:21.900 --> 00:17:24.240
I'm always like I'm halfway through writing a string.

00:17:24.240 --> 00:17:26.220
And I'm like, oh, I should have put the F at the front.

00:17:26.220 --> 00:17:27.800
Well, now I'm just going to do a format on the end.

00:17:27.800 --> 00:17:31.800
Because with my editor, I type dot and F and it auto completes format.

00:17:31.800 --> 00:17:33.260
So it's just we're just going to keep rolling.

00:17:33.260 --> 00:17:33.820
You know what I mean?

00:17:33.820 --> 00:17:36.040
Like it's one of these things that is really nice.

00:17:36.040 --> 00:17:39.000
But you got to be a little cognizant up front, right?

00:17:39.000 --> 00:17:39.220
Yeah.

00:17:39.220 --> 00:17:41.300
If you're correct, it looks very good.

00:17:41.300 --> 00:17:44.640
And actually, we did some things at Foursquare.

00:17:44.760 --> 00:17:52.040
And this was for Scala code where we had like GitHub hooks that looked to see, hey, this is a formatted string.

00:17:52.040 --> 00:17:55.760
And if you were trying to check in code, that was a formatted string.

00:17:55.760 --> 00:18:00.240
But you didn't actually put, I think in Scala, there was an S in front of it or something.

00:18:00.240 --> 00:18:04.220
If you didn't actually format the string, it's like, okay, this is probably an error.

00:18:04.220 --> 00:18:05.780
You probably shouldn't be checking this in.

00:18:05.780 --> 00:18:06.560
Oh, interesting.

00:18:06.560 --> 00:18:07.560
That's sort of a workaround.

00:18:07.560 --> 00:18:09.120
Yeah, it was helpful.

00:18:09.120 --> 00:18:10.800
But yeah, it'd be nice to have the language.

00:18:10.800 --> 00:18:13.000
But just having the formatted strings is always helpful.

00:18:13.300 --> 00:18:17.280
Another thing I didn't know that Python 3 had is enumerations.

00:18:17.280 --> 00:18:21.660
You know, again, with the functional programming, I've been using enums for years.

00:18:21.660 --> 00:18:25.000
They tend to make code way more readable, in my opinion.

00:18:25.000 --> 00:18:28.120
And so that was good to know.

00:18:28.120 --> 00:18:30.020
I'll keep that in mind when developing in Python 3.

00:18:30.020 --> 00:18:30.280
Nice.

00:18:30.280 --> 00:18:32.920
I love the discoverability that enums give you, right?

00:18:32.920 --> 00:18:35.380
You can say enumy thing dot.

00:18:35.380 --> 00:18:36.800
And then there's a list of things.

00:18:36.800 --> 00:18:40.260
You don't have to go research like, well, what values can I pass for level?

00:18:40.260 --> 00:18:41.180
Is it one, two, three?

00:18:41.180 --> 00:18:42.840
Is it a zero to one?

00:18:42.840 --> 00:18:45.260
And it's like low, medium, high.

00:18:45.260 --> 00:18:45.800
Pick one.

00:18:45.800 --> 00:18:46.560
Yeah, yeah.

00:18:46.560 --> 00:18:47.620
And they're reusable.

00:18:47.620 --> 00:18:52.880
And oftentimes, you know, I could look at an enum and figure out, oh, I know what this,

00:18:52.880 --> 00:18:59.560
you know, I know what this code is doing without having to really read tons of comments or really work through.

00:18:59.560 --> 00:19:01.480
No, if I see your enums, I kind of know what you're doing.

00:19:01.480 --> 00:19:04.120
Yeah, I feel like that's underutilized in general.

00:19:04.120 --> 00:19:05.400
Brian, what do you think?

00:19:05.400 --> 00:19:07.200
Definitely underutilized by me.

00:19:07.700 --> 00:19:10.720
I mean, it's one of those things that I've, it's on my list to try to use more.

00:19:10.720 --> 00:19:22.460
I don't use magic numbers too much, but I mean, we do have cases where it's, I just use a string, but it really ought to be an enum instead of a set of possible strings.

00:19:22.620 --> 00:19:23.520
Yeah, for sure.

00:19:23.520 --> 00:19:24.600
Cool.

00:19:24.600 --> 00:19:33.340
Well, I think, you know, one of the themes of the show today is that modern Python is definitely making its way past legacy Python, right?

00:19:33.340 --> 00:19:34.660
Python 3 is coming on strong.

00:19:35.220 --> 00:19:41.980
And if you look at what the real challenge, I think there's a lot of things that made this move a little bit difficult.

00:19:41.980 --> 00:19:50.160
But if you look at the heart of it, really the heart of what made the Python 2 to 3 migration challenging were strings, right?

00:19:50.160 --> 00:20:00.100
So the fact that strings used to be the same as bytes and you could either treat it as like a byte list or actually an encoded string and you had to kind of know, that was a problem.

00:20:00.260 --> 00:20:10.080
But it was also an opportunity to have simpler code like requests, for example, could talk to the network differently than it has to now because it doesn't have to like do the encoding and all these changes, right?

00:20:10.080 --> 00:20:15.800
But it's important that we have emojis and support other languages that have umlauts and things like that.

00:20:15.800 --> 00:20:18.120
So having a Unicode is really important.

00:20:18.120 --> 00:20:23.000
But I do feel like if you look at all the stuff, like people say, oh, Python 3, I can't move to that.

00:20:23.000 --> 00:20:27.380
That's so, it sounds like a, you know, like a huge problem.

00:20:27.380 --> 00:20:28.360
It's going to be so hard.

00:20:28.740 --> 00:20:33.020
But then when you look at the code, like how hard is it to write Python 2 code that's compatible with 3?

00:20:33.020 --> 00:20:35.860
It's like not very different.

00:20:35.860 --> 00:20:37.720
But one of the big differences is strings.

00:20:37.720 --> 00:20:41.200
So what's interesting is that I want to cover, this comes from James Small.

00:20:41.200 --> 00:20:47.880
He sent over an episode of the CppCast, which is a C++ podcast.

00:20:47.880 --> 00:20:49.360
I think one of the bigger ones.

00:20:49.360 --> 00:20:50.820
I don't really know all of them.

00:20:50.820 --> 00:20:52.520
But I definitely know of that one.

00:20:52.740 --> 00:20:58.460
And Herb Sutter, who was instrumental in C++, he was interviewed there.

00:20:58.460 --> 00:21:06.140
And the interviewers asked, if you could go back and change C++ types, what changes would you make?

00:21:06.140 --> 00:21:06.780
And so on.

00:21:07.560 --> 00:21:11.980
And basically, the answer was almost exactly what happened going from Python 2 to 3.

00:21:11.980 --> 00:21:13.040
Yeah, that was interesting.

00:21:13.040 --> 00:21:14.080
Yeah, pretty interesting, right?

00:21:14.080 --> 00:21:20.420
So if it was possible, the C++ guys very well may have done exactly what we did to go from Python 2 to 3.

00:21:20.800 --> 00:21:26.380
And it was like, we're going to take strings and split them into Unicode characters and byte arrays and things like that.

00:21:26.380 --> 00:21:27.360
And so, I don't know.

00:21:27.360 --> 00:21:33.480
I feel like if that's really the essence of what is holding back people switching from 2 to 3, I don't know.

00:21:33.480 --> 00:21:35.580
It just doesn't seem like that's that big of a deal.

00:21:35.580 --> 00:21:43.500
I know if you're writing requests or you're writing stuff that literally is a web server and you're talking on the network, okay, that's kind of a bigger deal.

00:21:43.500 --> 00:21:45.820
But in general, it doesn't seem like it's that big of a deal.

00:21:45.820 --> 00:21:57.380
Yeah, the big deal was that the Python, I think, from my perspective, that the Python strings used in 2 matched the idea of a character array in C.

00:21:57.380 --> 00:22:04.260
And so all of the DLLs that some packages interacted with could just interact with it directly.

00:22:04.260 --> 00:22:08.520
And if you were interacting with bytes, you were already doing something funky anyway.

00:22:08.520 --> 00:22:10.620
But now you have to split that up.

00:22:10.620 --> 00:22:13.220
And sometimes, you know what it's like working with C.

00:22:13.500 --> 00:22:17.200
Sometimes you're using a character array, but it's really not characters.

00:22:17.200 --> 00:22:18.120
It's really bytes.

00:22:18.120 --> 00:22:24.840
And so separating that out of when they were really strings and when they were just byte arrays, yeah, it's messy.

00:22:24.840 --> 00:22:26.160
Yeah, it's definitely messy.

00:22:26.160 --> 00:22:30.520
So I haven't used Python for the purpose of byte arrays before.

00:22:30.520 --> 00:22:35.100
Most of my Python codes have been scripts.

00:22:35.100 --> 00:22:37.280
I haven't used it for web services.

00:22:37.280 --> 00:22:38.760
So is this something that's very common?

00:22:38.940 --> 00:22:41.200
And I have used, you know, Cython.

00:22:41.200 --> 00:22:44.340
So is that does that make use of strings as byte arrays?

00:22:44.340 --> 00:22:45.520
Or am I overthinking this?

00:22:45.520 --> 00:22:50.000
I think in Cython, they have their own types for these types of things.

00:22:50.000 --> 00:22:51.720
I'm not 100% sure, but I think so.

00:22:51.720 --> 00:22:54.540
Like you could have pointers in Cython and stuff like that.

00:22:54.540 --> 00:23:00.520
In terms of so you know, basically, now we have strings and we have lists, right?

00:23:00.520 --> 00:23:03.520
But lists are not at all like byte arrays, right?

00:23:03.520 --> 00:23:08.120
I can't pass that off to C as a contiguous block of memory of like similar data, right?

00:23:08.120 --> 00:23:10.740
But you can actually create arrays that are typed.

00:23:10.740 --> 00:23:14.220
I can say I have like arrays that hold bytes or arrays that hold integers.

00:23:14.220 --> 00:23:15.200
And there's some...

00:23:15.200 --> 00:23:16.220
You could do that in Python.

00:23:16.220 --> 00:23:20.060
I forget exactly what module you got to use to do it.

00:23:20.060 --> 00:23:24.580
But there's some way to say like I have this homogeneous thing that I'm creating.

00:23:24.580 --> 00:23:27.180
Like it's something I've extremely rarely have done.

00:23:27.180 --> 00:23:29.540
So I forgot the steps of it.

00:23:29.540 --> 00:23:32.060
But yeah, there's some mechanism in there to do that.

00:23:32.060 --> 00:23:32.280
Yeah.

00:23:32.280 --> 00:23:35.720
And you can prefix a string with the B character in it.

00:23:35.720 --> 00:23:39.920
And then you can put byte codes inside of it for constants.

00:23:39.920 --> 00:23:41.100
That doesn't sound so bad.

00:23:41.180 --> 00:23:43.200
Although the prefix strings are...

00:23:43.200 --> 00:23:44.300
There's only 26 of them.

00:23:44.300 --> 00:23:45.100
So we'll see.

00:23:45.100 --> 00:23:46.500
We know there's an F and a B.

00:23:46.500 --> 00:23:47.180
So...

00:23:47.180 --> 00:23:52.080
Oh, we could probably put an OXU114 as a prefix.

00:23:52.080 --> 00:23:52.360
Yeah.

00:23:52.360 --> 00:23:52.640
Yeah.

00:23:52.640 --> 00:23:53.840
So I don't know.

00:23:53.840 --> 00:23:57.680
I guess when I was thinking about this, like the idea is pretty straightforward.

00:23:57.680 --> 00:24:01.120
But I'm just wondering like, you know, could the PSF...

00:24:01.120 --> 00:24:03.680
It just got me thinking about the whole transition from two to three.

00:24:03.680 --> 00:24:08.120
Like could the PSF been more proactive and strategical?

00:24:08.880 --> 00:24:11.900
Like could the PSF said, hey, it's super important we make this change.

00:24:11.900 --> 00:24:20.200
It looks like these seven libraries are the foundation of all the other libraries that are all stuck on Python 2 because none of these are changing.

00:24:20.200 --> 00:24:28.340
Could we just raise $200,000, hire some people and just in three months upgrade all these libraries and just be done with it?

00:24:28.340 --> 00:24:34.140
Like how would the world look different if like there was a quick and focused response to like this challenge?

00:24:35.180 --> 00:24:35.580
Right.

00:24:35.580 --> 00:24:40.620
Because I feel like the actual problem that most people hit was the library I care about doesn't support Python 2.

00:24:40.620 --> 00:24:42.420
That library actually...

00:24:42.420 --> 00:24:42.840
Sorry, three.

00:24:42.840 --> 00:24:49.660
That library only supported Python 2 not because that's what it wanted but because the library it was based on only supported 2.

00:24:49.660 --> 00:24:54.420
It was like this sort of chain and like the lowest level pieces were getting everyone stuck.

00:24:54.420 --> 00:24:55.420
So I don't know.

00:24:55.420 --> 00:24:56.260
It's interesting.

00:24:56.400 --> 00:25:04.300
There's so many corner cases that like for instance, the hiccup for me was it was one library and it was one...

00:25:04.300 --> 00:25:14.140
It was because the DLL that the library is a thin wrapper around a DLL and that DLL interaction was all this...

00:25:14.140 --> 00:25:15.920
The different ways...

00:25:15.920 --> 00:25:16.860
This character pointer type thing, yeah.

00:25:16.860 --> 00:25:21.520
Yeah, but it's on top of that, one of the hiccups wasn't just because of this.

00:25:21.520 --> 00:25:29.980
It was also because the way that Python libraries interact with DLLs, that changed completely also from 2 to 3.

00:25:29.980 --> 00:25:30.260
Yeah.

00:25:30.260 --> 00:25:31.040
Okay.

00:25:31.040 --> 00:25:31.460
Interesting.

00:25:31.460 --> 00:25:33.140
Yeah, the C extensions and stuff like that, huh?

00:25:33.140 --> 00:25:33.420
Yeah.

00:25:33.420 --> 00:25:35.780
So the library that I needed was...

00:25:35.780 --> 00:25:43.880
That was just some complicated beast that a university in Germany finally had some people that converted it to Python 3.

00:25:44.320 --> 00:25:44.680
So...

00:25:44.680 --> 00:25:45.300
Okay.

00:25:45.300 --> 00:25:46.660
Well done.

00:25:46.660 --> 00:25:47.580
Well done, academia.

00:25:47.580 --> 00:25:48.280
Well done.

00:25:48.280 --> 00:25:49.240
Nice.

00:25:49.240 --> 00:25:49.440
All right.

00:25:49.440 --> 00:25:51.580
Well, that's our main topics today.

00:25:51.580 --> 00:25:56.620
I want to just throw out, see if you all have a couple of extras, real quick things to touch on.

00:25:56.620 --> 00:26:00.060
I do want to bring up this thing that Devo Kaplan sent over.

00:26:00.060 --> 00:26:01.940
He was listening to one of our episodes.

00:26:01.940 --> 00:26:04.380
I don't remember what we were even talking about, Brian.

00:26:04.380 --> 00:26:11.860
It was something crazy about what happens when you pip install a thing, maybe running some code as part of the setup UI and so on.

00:26:12.320 --> 00:26:18.620
And so he said, all right, well, let me see if I can create something that's kind of funny and amusing based on what we've been talking about.

00:26:18.620 --> 00:26:21.080
So he created a package called Mystery.

00:26:21.080 --> 00:26:22.000
Okay.

00:26:22.000 --> 00:26:25.540
This sounds like a Russian roulette type situation.

00:26:25.540 --> 00:26:26.820
Yes, it does to me too.

00:26:26.820 --> 00:26:34.460
So if you pip install Mystery, it will then go and randomly pick something else out of PyPI, out of the package index, and then install that.

00:26:34.460 --> 00:26:35.840
So you never know what you get.

00:26:35.840 --> 00:26:36.800
You can just pip.

00:26:36.800 --> 00:26:39.140
It's going to be a mystery.

00:26:39.260 --> 00:26:42.440
I don't actually recommend using this in production, by the way.

00:26:42.440 --> 00:26:45.180
Well, it would be fun to give a try.

00:26:45.180 --> 00:26:49.140
It could be – you could be installing NumPy or NumPy.

00:26:49.140 --> 00:26:52.120
We had – I've always thought about which one to describe.

00:26:52.120 --> 00:26:58.120
Or it could be something that totally changes the language or something that takes 10 hours to install.

00:26:58.120 --> 00:26:58.860
You never know.

00:26:58.860 --> 00:26:59.460
Yeah.

00:26:59.460 --> 00:27:01.700
Maybe do it in a virtual machine that you can erase later.

00:27:01.700 --> 00:27:01.920
Yeah.

00:27:01.920 --> 00:27:20.200
Also, I just want to give a shout out to the book that I released, the Effective PyCharm book, and point out that if people are interested in the PyCharm course and or the PyCharm book, if you go to EffectivePyCharm.com, Matt Harrison and I are running a bundle deal so you can get the course and the book discounted together.

00:27:20.200 --> 00:27:21.220
So check that out.

00:27:21.220 --> 00:27:28.480
And people, if they've already bought the course or they bought the bundle, just shoot me a note and I'll give you the discount towards as – because you maybe bought it before this existed.

00:27:28.480 --> 00:27:29.700
So check that out.

00:27:29.700 --> 00:27:29.980
That's awesome.

00:27:29.980 --> 00:27:30.920
Yeah, thanks.

00:27:30.920 --> 00:27:32.480
Brian, how about you?

00:27:32.480 --> 00:27:32.960
What you got?

00:27:32.960 --> 00:27:37.560
Just really quickly, the Python 3.8.0 beta 1 is out.

00:27:37.920 --> 00:27:47.620
So if you're a package supporter, please go test your package and make sure that – that sounded weird – but go test your code to make sure that it works with Python 3.8.

00:27:47.620 --> 00:27:49.780
That's super new.

00:27:49.780 --> 00:27:50.760
So this is beta 1, right?

00:27:50.760 --> 00:27:51.400
This is a big deal.

00:27:51.400 --> 00:27:52.820
It's like the first feature freeze.

00:27:52.820 --> 00:27:53.140
Yeah.

00:27:53.140 --> 00:27:53.380
Yeah.

00:27:53.380 --> 00:27:53.940
Cool.

00:27:53.940 --> 00:27:56.040
Max, how about you?

00:27:56.040 --> 00:27:56.620
All right.

00:27:56.620 --> 00:28:01.260
Well, thanks for letting me talk about my own podcast, which is called The Local Maximum.

00:28:01.260 --> 00:28:01.660
Of course.

00:28:01.660 --> 00:28:02.440
It's a good one.

00:28:02.440 --> 00:28:03.120
I've listened to it.

00:28:03.120 --> 00:28:04.260
It's high quality.

00:28:04.260 --> 00:28:05.320
I definitely like it.

00:28:05.320 --> 00:28:05.920
Tell people about it.

00:28:05.920 --> 00:28:06.160
Yeah.

00:28:06.160 --> 00:28:06.860
Very cool.

00:28:06.940 --> 00:28:19.900
Well, it's a weekly tech podcast, and so I cover both the theoretical issues in probability theory, philosophy, and machine learning, but then I kind of apply it in a practical way to things like current events and product development and interviews.

00:28:19.900 --> 00:28:24.340
And I do some like opinion piece type stuff as I did this week.

00:28:24.340 --> 00:28:32.180
So, for example, a few weeks ago, my co-host asked a question, how do you estimate the probability of an event that has never occurred?

00:28:32.740 --> 00:28:35.300
And so, you know, we dove into that question.

00:28:35.300 --> 00:28:39.020
And I started with, well, every event has never occurred, but what are you really asking me here?

00:28:39.020 --> 00:28:51.140
And some of the news that we've dived into recently is Apple's decision to break up iTunes, what that means in terms of product development, you know, how the internet is shaping up in places like Cuba.

00:28:51.140 --> 00:28:52.140
I find that stuff.

00:28:52.140 --> 00:28:54.140
I find that stuff really interesting.

00:28:54.140 --> 00:28:56.620
And the controversy around YouTube's recommendation algorithm.

00:28:56.620 --> 00:28:59.420
I also talk a lot about data science careers.

00:28:59.420 --> 00:29:05.180
And I interview people like Hillary Mason here in New York and Mark Senadella, who's the CEO of the ladders.

00:29:05.380 --> 00:29:08.120
He critiqued my resume on my podcast.

00:29:08.120 --> 00:29:08.920
That was very fun.

00:29:08.920 --> 00:29:10.160
That's a little stressful, huh?

00:29:10.160 --> 00:29:12.360
Yeah, he had me rewrite my resume.

00:29:12.360 --> 00:29:17.620
So, yeah, there's probably something for everybody.

00:29:17.620 --> 00:29:18.760
It's the type of thing.

00:29:18.760 --> 00:29:27.680
I don't know if it's – I don't know if there's anyone who's into it every single week or if most people kind of skip around.

00:29:27.680 --> 00:29:28.940
But either way is cool with me.

00:29:29.060 --> 00:29:29.700
Yeah, it's cool.

00:29:29.700 --> 00:29:34.200
I like that it's technical but not, you know, deeply technical.

00:29:34.200 --> 00:29:36.040
You can kind of make it casual listening too.

00:29:36.040 --> 00:29:36.800
Yeah, yeah.

00:29:36.800 --> 00:29:37.160
Nice.

00:29:37.160 --> 00:29:37.500
All right.

00:29:37.500 --> 00:29:40.280
Well, I have a quick joke for you guys.

00:29:40.280 --> 00:29:43.460
And then Brian has an idea for something completely different.

00:29:43.460 --> 00:29:47.620
So, you know, Brian, they say there's only two hard problems in computer science, right?

00:29:47.620 --> 00:29:48.100
Yeah.

00:29:48.100 --> 00:29:48.940
Tell me what they are.

00:29:48.940 --> 00:29:51.760
It's cache invalidation, naming things, and off by one errors.

00:29:51.760 --> 00:29:54.480
I love that joke.

00:29:54.480 --> 00:29:55.500
Yeah, that's a good one.

00:29:55.500 --> 00:29:56.200
All right.

00:29:56.200 --> 00:29:58.900
So, I think you need to give a short explanation.

00:29:59.140 --> 00:30:00.660
There's also off by two errors.

00:30:00.660 --> 00:30:01.840
That's right.

00:30:01.840 --> 00:30:08.200
I think you need to give an explanation for what is about to come because it actually is something completely different.

00:30:08.200 --> 00:30:09.700
Why are we going to do what we're about to do?

00:30:09.700 --> 00:30:10.100
Okay.

00:30:10.100 --> 00:30:16.400
So, the Python 3.8.0 beta 1 release notes, I was skimming down this.

00:30:16.400 --> 00:30:18.060
And there's some pretty exciting stuff there.

00:30:18.060 --> 00:30:19.860
So, I'm excited to try it out.

00:30:19.860 --> 00:30:24.440
But at the bottom, it says, and now for something completely different.

00:30:24.440 --> 00:30:32.720
And then it has like a skit from, it looks like a little snippet of an interview from some of the Monty Python people.

00:30:32.720 --> 00:30:33.080
Yeah.

00:30:33.080 --> 00:30:39.540
And just, I suspect most people know, but for those of you who don't, Python has nothing to do with a snake in its naming.

00:30:39.540 --> 00:30:41.000
It comes from Monty Python.

00:30:41.280 --> 00:30:43.160
That's what Guido got the inspiration from, right?

00:30:43.160 --> 00:30:43.500
Yeah.

00:30:43.500 --> 00:30:46.120
Even though all the logos are snakes, nobody knows why.

00:30:46.120 --> 00:30:46.220
Yes, I know.

00:30:46.220 --> 00:30:48.060
They should be cheese or something.

00:30:48.060 --> 00:30:48.380
I don't know.

00:30:48.380 --> 00:30:51.520
We should change our logos to like cheese and maybe a knight with no legs.

00:30:51.520 --> 00:30:51.820
Yeah.

00:30:51.820 --> 00:30:52.260
Yeah.

00:30:52.260 --> 00:30:52.640
Rabbit.

00:30:52.640 --> 00:30:53.240
Killer rabbit.

00:30:53.240 --> 00:30:54.080
Oh.

00:30:54.080 --> 00:30:56.860
Get the holy hand grenade out there.

00:30:56.860 --> 00:30:57.580
All right.

00:30:57.580 --> 00:30:59.440
So, now for something completely different.

00:30:59.440 --> 00:30:59.720
Yeah.

00:30:59.720 --> 00:31:01.280
I thought we could read this skit out.

00:31:01.280 --> 00:31:02.720
So, are you guys ready?

00:31:02.720 --> 00:31:03.860
Let's do it.

00:31:03.860 --> 00:31:06.780
I'll try to do it with feeling, but I'm not very good with accents.

00:31:06.780 --> 00:31:08.980
So, we'll see what happens.

00:31:08.980 --> 00:31:09.660
Okay.

00:31:09.660 --> 00:31:10.720
This is entirely in rehearsal.

00:31:10.720 --> 00:31:11.260
Let's do it.

00:31:11.260 --> 00:31:11.540
Okay.

00:31:11.540 --> 00:31:16.680
So, who'd have thought 30 years ago that we'd all be sitting here drinking Chateau de Chasselet

00:31:16.680 --> 00:31:17.160
wine?

00:31:17.160 --> 00:31:17.660
Aye.

00:31:17.660 --> 00:31:21.440
In them days, we'd be glad to have the price of a cup of tea.

00:31:21.440 --> 00:31:22.880
A cup of cold tea.

00:31:22.880 --> 00:31:24.240
With milk.

00:31:24.240 --> 00:31:25.640
Without milk or sugar.

00:31:25.640 --> 00:31:26.420
Or tea.

00:31:26.420 --> 00:31:27.800
In a filthy crack cup.

00:31:27.800 --> 00:31:28.920
We never used to have a cup.

00:31:28.920 --> 00:31:31.220
We used to drink tea out of a rolled up newspaper.

00:31:31.220 --> 00:31:35.000
The best we could manage was to suck on a piece of damp cloth.

00:31:35.000 --> 00:31:38.880
But you try and tell the young people today that they won't believe you.

00:31:38.880 --> 00:31:39.260
No.

00:31:39.260 --> 00:31:39.740
Nope.

00:31:39.740 --> 00:31:39.880
Nope.

00:31:39.880 --> 00:31:40.120
Nope.

00:31:40.120 --> 00:31:40.820
Not at all.

00:31:40.820 --> 00:31:43.440
Okay.

00:31:43.440 --> 00:31:43.940
All right, folks.

00:31:43.940 --> 00:31:47.360
That was literally at the end of the official release note for Python 3.8.

00:31:47.360 --> 00:31:48.120
So, pretty cool.

00:31:48.120 --> 00:31:49.160
Good read through, people.

00:31:49.160 --> 00:31:50.300
All right.

00:31:50.300 --> 00:31:53.100
Max, thank you for joining us, Brian, and me on the show today.

00:31:53.100 --> 00:31:54.220
It was fun to have you as a guest.

00:31:54.220 --> 00:31:55.460
Thank you so much for having me.

00:31:55.460 --> 00:31:56.040
Thanks.

00:31:56.040 --> 00:31:56.780
This was a lot of fun.

00:31:56.780 --> 00:31:57.000
Yep.

00:31:57.000 --> 00:31:57.240
You bet.

00:31:57.240 --> 00:31:58.520
Brian, thanks as always.

00:31:58.520 --> 00:31:58.800
See you later.

00:31:58.800 --> 00:31:59.100
Yep.

00:31:59.100 --> 00:31:59.480
Thank you.

00:31:59.480 --> 00:31:59.760
Bye.

00:31:59.760 --> 00:32:01.680
Thank you for listening to Python Bytes.

00:32:01.680 --> 00:32:04.200
Follow the show on Twitter via at Python Bytes.

00:32:04.200 --> 00:32:07.060
That's Python Bytes as in B-Y-T-E-S.

00:32:07.060 --> 00:32:10.300
And get the full show notes at pythonbytes.fm.

00:32:10.300 --> 00:32:14.520
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:32:14.520 --> 00:32:17.200
We're always on the lookout for sharing something cool.

00:32:17.200 --> 00:32:20.320
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:32:20.620 --> 00:32:23.740
Thank you for listening and sharing this podcast with your friends and colleagues.

