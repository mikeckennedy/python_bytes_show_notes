
00:00:00.000 --> 00:00:09.800
Hello and welcome to python bites where we deliver python news and headlines directly to your buds. This is episode 134 recorded june 3rd.


00:00:09.800 --> 00:00:14.260
2019 i'm michael kennedy and i'm brian akin this episode is brought to you by digital ocean.


00:00:14.260 --> 00:00:23.240
I feel like i've been lied to i feel like the world is not as i expected it to be i was taught about planets first in school and first i was told there were nine.


00:00:23.460 --> 00:00:28.360
And of course I was told that Mercury was the closest to the Sun and then Venus and then the Earth.


00:00:28.360 --> 00:00:32.860
And yet you're telling me Python here may be disproving this? What's the story here?


00:00:32.860 --> 00:00:35.060
So which planet is closest to Earth?


00:00:35.060 --> 00:00:40.760
Mercury. Wait, no, Venus, because it goes Mercury and then Venus and then Earth and then Mars and so on.


00:00:40.760 --> 00:00:49.460
And the orbits are farther out and if you look at it to scale, it looks like the orbit of Venus and the orbit of Earth are closer together.


00:00:49.460 --> 00:00:49.960
Yes.


00:00:49.960 --> 00:00:52.720
And that is true.


00:00:52.720 --> 00:00:55.840
However, they spend as much time, the closest.


00:00:55.840 --> 00:00:58.720
On average, if you take the average,


00:00:58.720 --> 00:01:02.280
how of the exact locations and the exact distance


00:01:02.280 --> 00:01:05.320
or exact-ish, actually all of the planets


00:01:05.320 --> 00:01:07.480
spend more time closer to the sun


00:01:07.480 --> 00:01:08.640
than they do to each other,


00:01:08.640 --> 00:01:10.960
because that's just how that works.


00:01:10.960 --> 00:01:15.960
And since Mercury is closest to the sun,


00:01:15.960 --> 00:01:19.520
it is on average closest to all the other planets.


00:01:19.520 --> 00:01:21.120
There's a nice video on this link,


00:01:21.120 --> 00:01:23.820
so I'm linking to an article called,


00:01:23.820 --> 00:01:26.640
I even did it wrong, so three scientists publish a paper


00:01:26.640 --> 00:01:28.400
proving that Mercury, not Venus,


00:01:28.400 --> 00:01:32.200
is the closest planet to the Earth using Python.


00:01:32.200 --> 00:01:35.360
It's a nice article about using the graph


00:01:35.360 --> 00:01:38.760
and they graph it all out and it's kind of neat


00:01:38.760 --> 00:01:40.400
that you just watch it and you're like,


00:01:40.400 --> 00:01:41.600
oh yeah, well of course.


00:01:41.600 --> 00:01:44.640
If as you watch these planets circle the sun,


00:01:44.640 --> 00:01:48.480
then you calculate the distance and then you do an average.


00:01:48.480 --> 00:01:50.800
- It's close, so the average,


00:01:50.800 --> 00:01:54.920
Mercury is closest to the Earth 43% of the time.


00:01:54.920 --> 00:01:59.000
Venus is closest to the Earth 37% of the time.


00:01:59.000 --> 00:02:00.600
So Mercury wins.


00:02:00.600 --> 00:02:02.120
- Wow, that's really wild.


00:02:02.120 --> 00:02:03.240
I guess that makes sense, right?


00:02:03.240 --> 00:02:05.640
Because all the planets are roughly,


00:02:05.640 --> 00:02:08.280
continuously the same distance from the Sun,


00:02:08.280 --> 00:02:11.060
but they're often out of phase with each other, right?


00:02:11.060 --> 00:02:12.680
They might be on opposite sides of the Sun,


00:02:12.680 --> 00:02:14.080
which puts them super far apart,


00:02:14.080 --> 00:02:16.440
even though their orbits could actually be close together.


00:02:16.440 --> 00:02:21.040
- Yeah, and also the orbits that are far away from the sun,


00:02:21.040 --> 00:02:22.580
those take longer time, right?


00:02:22.580 --> 00:02:25.160
So they're spending more time really far from the sun,


00:02:25.160 --> 00:02:27.480
and if you're really far on the other side of the sun


00:02:27.480 --> 00:02:30.640
from another planet, you're, yeah, it's just far.


00:02:30.640 --> 00:02:32.400
- Yeah, you're super far away, yeah, absolutely.


00:02:32.400 --> 00:02:35.400
- And they were linking the article and the video


00:02:35.400 --> 00:02:40.400
used a library called PyFM, I think, P-Y-E-P-H-E-M.


00:02:40.400 --> 00:02:44.040
Apparently, according to Andrew Diedrich


00:02:44.040 --> 00:02:46.380
that contributed this for this show,


00:02:46.380 --> 00:02:48.820
has been largely deprecated and replaced


00:02:48.820 --> 00:02:51.020
with another library called Skyfield.


00:02:51.020 --> 00:02:52.220
And I took a look at that,


00:02:52.220 --> 00:02:53.820
and it looks like a really fun library


00:02:53.820 --> 00:02:57.860
to easily get data about the solar system and stuff.


00:02:57.860 --> 00:02:58.840
- Yeah, that looks super cool.


00:02:58.840 --> 00:03:01.300
I gotta say, one of the areas that sparks


00:03:01.300 --> 00:03:04.580
the most wonder and amazement in the use of Python


00:03:04.580 --> 00:03:06.500
is astronomy, for me personally.


00:03:06.500 --> 00:03:09.120
- Yep, it's neat to even have some of these little things


00:03:09.120 --> 00:03:11.740
of like, an average person can go,


00:03:11.740 --> 00:03:13.620
"Wait, I don't think that's right,"


00:03:13.620 --> 00:03:16.900
and just map it out using some Python,


00:03:16.900 --> 00:03:19.940
and then you can come up with these different conclusions.


00:03:19.940 --> 00:03:20.780
It's great.


00:03:20.780 --> 00:03:21.700
- Yeah, super cool.


00:03:21.700 --> 00:03:23.720
Well, thanks for finding that one, that's great.


00:03:23.720 --> 00:03:26.700
Last week, I covered a couple of GitHub topics


00:03:26.700 --> 00:03:28.700
that I thought were really interesting,


00:03:28.700 --> 00:03:30.180
sponsors and the PandaBot,


00:03:30.180 --> 00:03:32.320
and I'm back this time this week


00:03:32.320 --> 00:03:36.080
with a slightly different theme that also intersects GitHub.


00:03:36.080 --> 00:03:37.820
So I feel like I have a theme this week,


00:03:37.820 --> 00:03:40.820
and the theme is understanding languages,


00:03:40.820 --> 00:03:43.060
like the internals and the inner workings of languages


00:03:43.060 --> 00:03:48.740
So the first thing I want to talk about is this library that was released called GitHub


00:03:48.740 --> 00:03:50.060
Semantics.


00:03:50.060 --> 00:03:55.340
So GitHub, they have, as you know, many different programming languages and all sorts of cool


00:03:55.340 --> 00:03:57.980
analytics and reporting and whatnot.


00:03:57.980 --> 00:04:03.740
So they built this library that will help them make comparisons across languages.


00:04:03.740 --> 00:04:08.340
Like if you wanted to ask the question of what is the average psycholimetic complexity


00:04:08.340 --> 00:04:12.880
by language, studying the top 100 repos or whatever,


00:04:12.880 --> 00:04:14.080
something like that.


00:04:14.080 --> 00:04:17.840
You could answer that across Python, TypeScript, JavaScript,


00:04:17.840 --> 00:04:20.200
Ruby, Go, and some other languages as well.


00:04:20.200 --> 00:04:21.600
- Weird, that's cool.


00:04:21.600 --> 00:04:22.440
- Isn't that cool?


00:04:22.440 --> 00:04:26.580
So it's not something in terms of digging into it


00:04:26.580 --> 00:04:28.200
that a lot of Python developers are gonna be


00:04:28.200 --> 00:04:30.400
super excited about 'cause it's written in Haskell,


00:04:30.400 --> 00:04:33.040
but you can also just use it as a command line tool


00:04:33.040 --> 00:04:35.400
for parsing and analyzing and comparing source code


00:04:35.400 --> 00:04:36.600
across languages.


00:04:36.600 --> 00:04:37.440
- Oh, neat.


00:04:37.440 --> 00:04:43.200
interesting stuff and like some of the things that you can do with it or it has


00:04:43.200 --> 00:04:48.840
in it I guess is a flow sensitive caching interpreter for imperative


00:04:48.840 --> 00:04:54.480
languages. It has an abstract interpreter for generating scope graphs within given


00:04:54.480 --> 00:04:59.080
program text so if you want to compare scope across different languages like


00:04:59.080 --> 00:05:01.760
compare two different functions that are trying to do the same thing or something


00:05:01.760 --> 00:05:06.760
in a strategic rewriting system for open syntax term.


00:05:06.760 --> 00:05:09.340
So not a whole lot of stuff that I feel like


00:05:09.340 --> 00:05:10.520
I'm gonna be doing day to day,


00:05:10.520 --> 00:05:12.680
but if you're in a computer science program,


00:05:12.680 --> 00:05:14.440
if you're trying to study languages


00:05:14.440 --> 00:05:16.920
or make generalizations or maybe even tooling,


00:05:16.920 --> 00:05:19.120
I think this would be pretty interesting to check out.


00:05:19.120 --> 00:05:20.640
- Yeah, is it written in Haskell?


00:05:20.640 --> 00:05:22.600
- Yeah, it's written in Haskell, yeah.


00:05:22.600 --> 00:05:23.440
- Okay, cool.


00:05:23.440 --> 00:05:25.640
- Yep, and this one comes from Orin Carmy,


00:05:25.640 --> 00:05:27.400
so I just wanna say thanks for sending that over.


00:05:27.400 --> 00:05:29.560
We always appreciate getting those ones passed along.


00:05:29.560 --> 00:05:30.400
What do you got next?


00:05:30.400 --> 00:05:33.120
Well, we've talked about black, I think, several times.


00:05:33.120 --> 00:05:34.440
And I like using black.


00:05:34.440 --> 00:05:36.880
One of the things that bothers me a little bit


00:05:36.880 --> 00:05:38.720
is having something change my code


00:05:38.720 --> 00:05:40.200
without me knowing about it.


00:05:40.200 --> 00:05:44.080
There's a flag called black dash dash check


00:05:44.080 --> 00:05:46.960
that will basically tell you if you ran it,


00:05:46.960 --> 00:05:48.480
this is what it would do.


00:05:48.480 --> 00:05:50.880
I also use Flake 8 to check stuff,


00:05:50.880 --> 00:05:55.720
like to sort of lint my code and help me understand what I'm,


00:05:55.720 --> 00:05:57.720
actually, I like it that it doesn't,


00:05:57.720 --> 00:05:59.080
Flake 8 doesn't change your stuff,


00:05:59.080 --> 00:06:01.260
just tells you some information.


00:06:01.260 --> 00:06:03.420
And so you can train yourself to write


00:06:03.420 --> 00:06:05.060
in a more consistent way.


00:06:05.060 --> 00:06:07.860
So this is contributed by Nathan Clayton.


00:06:07.860 --> 00:06:11.100
There's a Flake 8 Black plugin


00:06:11.100 --> 00:06:15.860
that can just run Black check within a Flake 8 environment


00:06:15.860 --> 00:06:18.760
and tell you if you ran Black, it would change this stuff


00:06:18.760 --> 00:06:20.940
along with all your other Flake 8 checks.


00:06:20.940 --> 00:06:22.060
I think this is pretty handy


00:06:22.060 --> 00:06:24.580
and I'll try to include this into my workflow.


00:06:24.580 --> 00:06:25.940
- Yeah, and that probably makes it pretty easy


00:06:25.940 --> 00:06:28.420
to plug in to continuous integration pipelines


00:06:28.420 --> 00:06:30.800
'cause Flake 8 may already be part of some


00:06:30.800 --> 00:06:32.160
continuous integration check, right?


00:06:32.160 --> 00:06:33.640
- A lot of people are hooking Black


00:06:33.640 --> 00:06:36.280
into a pre-commit hook, which is great.


00:06:36.280 --> 00:06:38.600
You can also hook, if you're already hooking Flake 8 up


00:06:38.600 --> 00:06:41.000
in a pre-commit hook, you can do this as well.


00:06:41.000 --> 00:06:43.520
But having it, you can still slip stuff in,


00:06:43.520 --> 00:06:45.220
and merges might muck things up.


00:06:45.220 --> 00:06:46.560
So yeah, this is cool.


00:06:46.560 --> 00:06:47.380
- Yeah, yeah, super cool.


00:06:47.380 --> 00:06:51.020
And you can't necessarily be sure everyone is running


00:06:51.020 --> 00:06:53.060
all the same tooling or whatever, right?


00:06:53.060 --> 00:06:55.080
So maybe they've changed it somehow.


00:06:55.080 --> 00:06:56.040
So this'll check it.


00:06:56.040 --> 00:06:57.280
Very cool, that's a good one.


00:06:57.280 --> 00:06:58.640
All right, now before we get to the next one,


00:06:58.640 --> 00:07:00.880
I want to tell you all about DigitalOcean.


00:07:00.880 --> 00:07:03.480
They're sponsoring this episode as they do many of them


00:07:03.480 --> 00:07:06.880
and make this show certainly possible in some way.


00:07:06.880 --> 00:07:07.720
So thank you to them


00:07:07.720 --> 00:07:10.640
and they are doing all sorts of cool stuff.


00:07:10.640 --> 00:07:13.040
You know, we use them for our infrastructure.


00:07:13.040 --> 00:07:15.780
They have great virtual machine support,


00:07:15.780 --> 00:07:17.760
but one of the things they recently rolled out


00:07:17.760 --> 00:07:21.560
was managed Postgres servers or as a service.


00:07:21.560 --> 00:07:24.680
So if you want to create something on Linux


00:07:24.680 --> 00:07:26.800
and get it up and running fast, affordable,


00:07:26.800 --> 00:07:29.860
simply, but you don't wanna also become a DBA


00:07:29.860 --> 00:07:32.420
and manage your own database, your own backups and all that,


00:07:32.420 --> 00:07:35.640
you can just plug into their managed database service


00:07:35.640 --> 00:07:38.080
for Postgres over there, and that's one less thing


00:07:38.080 --> 00:07:41.460
to own as a puppy or to have to babysit all the time


00:07:41.460 --> 00:07:43.000
and patch and whatnot.


00:07:43.000 --> 00:07:45.360
So definitely recommend checking them out.


00:07:45.360 --> 00:07:46.380
They're doing cool stuff.


00:07:46.380 --> 00:07:49.880
So visit them over at pythonbytes.fm/digitalocean


00:07:49.880 --> 00:07:52.700
and you'll get a $50 credit for new users.


00:07:52.700 --> 00:07:56.320
Now, back onto my theme here for understanding languages.


00:07:56.320 --> 00:07:58.480
If you look at the popular editors these days, Brian,


00:07:58.480 --> 00:08:03.320
we have PyCharm and we have VS Code as the two front runners,


00:08:03.320 --> 00:08:04.840
I would say, these days.


00:08:04.840 --> 00:08:06.840
It's kind of like, if you want a big ID that's


00:08:06.840 --> 00:08:08.500
going to do everything for you, PyCharm.


00:08:08.500 --> 00:08:11.240
If you have a lighter weight preference,


00:08:11.240 --> 00:08:14.480
then maybe VS Code seems to be what a lot of folks


00:08:14.480 --> 00:08:16.160
are trending towards.


00:08:16.160 --> 00:08:19.800
So there's this cool extension for VS Code


00:08:19.800 --> 00:08:21.560
called Python Preview.


00:08:21.560 --> 00:08:24.000
If you're a computer science student,


00:08:24.000 --> 00:08:25.960
or if you're getting into Python and you


00:08:25.960 --> 00:08:28.640
want to have a good understanding of what's


00:08:28.640 --> 00:08:30.920
happening as you're writing code,


00:08:30.920 --> 00:08:32.960
I think using this extension is awesome.


00:08:32.960 --> 00:08:34.680
So click on the link there and just


00:08:34.680 --> 00:08:36.600
look at the little picture that gets


00:08:36.600 --> 00:08:39.600
drawn if you scroll down to the second picture


00:08:39.600 --> 00:08:40.840
or something like that there.


00:08:40.840 --> 00:08:41.320
OK.


00:08:41.320 --> 00:08:41.920
This is neat.


00:08:41.920 --> 00:08:44.040
So what happens is you write some Python code.


00:08:44.040 --> 00:08:45.400
You maybe create a list, and then you're


00:08:45.400 --> 00:08:46.440
going to loop over it, and you're


00:08:46.440 --> 00:08:48.640
going to change the variable or something like that.


00:08:48.640 --> 00:08:52.320
And it'll create a visualization of what the objects look


00:08:52.320 --> 00:08:55.320
like in memory, what the call stack looks like,


00:08:55.320 --> 00:08:57.040
the global frame is and all that.


00:08:57.040 --> 00:09:00.080
And it will actually show all the pointer references


00:09:00.080 --> 00:09:02.000
between the variables and how they're changing


00:09:02.000 --> 00:09:03.200
and what type they are.


00:09:03.200 --> 00:09:05.880
All sorts of interesting stuff as it just sort of like


00:09:05.880 --> 00:09:09.520
explains what your code is doing visually


00:09:09.520 --> 00:09:10.360
if you were to run it.


00:09:10.360 --> 00:09:11.560
- Oh, this is really cool.


00:09:11.560 --> 00:09:12.400
I like it.


00:09:12.400 --> 00:09:13.220
- Yeah, it's really cool.


00:09:13.220 --> 00:09:15.120
It's free because it's just part of VS Code.


00:09:15.120 --> 00:09:16.240
So that's really nice.


00:09:16.240 --> 00:09:19.200
So if you're either a student or trying to learn


00:09:19.200 --> 00:09:21.820
the language or if you're a teacher, right?


00:09:21.820 --> 00:09:24.120
Like this is exactly the kind of stuff you're like,


00:09:24.120 --> 00:09:25.520
well, let's look at this code,


00:09:25.520 --> 00:09:27.640
and now I'm gonna go over and draw it out on the whiteboard.


00:09:27.640 --> 00:09:30.640
Like, or you could just let this thing draw it perfectly.


00:09:30.640 --> 00:09:31.480
You know what I mean?


00:09:31.480 --> 00:09:32.960
So I think this would actually be really good


00:09:32.960 --> 00:09:35.840
for a intro language course,


00:09:35.840 --> 00:09:38.000
if you do any teaching or something like that.


00:09:38.000 --> 00:09:39.480
- Yeah, I like it.


00:09:39.480 --> 00:09:41.280
It reminds me of Python Tutor.


00:09:41.280 --> 00:09:42.860
- It should remind you of Python Tutor,


00:09:42.860 --> 00:09:47.520
because if you look at the GitHub repo for this extension,


00:09:47.520 --> 00:09:51.040
it actually says, I would like to thank a couple of projects


00:09:51.040 --> 00:09:53.480
for at least conceptually inspiring me.


00:09:53.480 --> 00:09:56.220
I don't know that there's any code sharing or anything like that.


00:09:56.220 --> 00:10:00.520
And the first one is Philip Guo's PythonTutor.com site.


00:10:00.520 --> 00:10:01.020
So--


00:10:01.020 --> 00:10:01.520
OK.


00:10:01.520 --> 00:10:02.440
Well, that makes sense.


00:10:02.440 --> 00:10:03.780
Yeah, it definitely makes sense.


00:10:03.780 --> 00:10:05.920
If you've played with Python Tutor before,


00:10:05.920 --> 00:10:08.560
that's a place to go explore Python, and you type it in there.


00:10:08.560 --> 00:10:11.240
And what's cool about this is it just explores the code


00:10:11.240 --> 00:10:13.680
that you have open in your editor in a similar way.


00:10:13.680 --> 00:10:15.480
You can't step through it, I don't believe.


00:10:15.480 --> 00:10:16.640
But yeah, it's pretty cool.


00:10:16.640 --> 00:10:17.140
Yeah, neat.


00:10:17.140 --> 00:10:17.640
Awesome.


00:10:17.640 --> 00:10:18.760
All right, what's next?


00:10:18.760 --> 00:10:20.640
Something we haven't talked about before, huh?


00:10:20.640 --> 00:10:21.200
Packaging?


00:10:21.200 --> 00:10:23.080
Packaging and poetry.


00:10:23.080 --> 00:10:25.920
This is a nice article called Create and Publish


00:10:25.920 --> 00:10:29.600
a Python Package with Poetry by John Franey.


00:10:29.600 --> 00:10:32.440
There's been occasionally people will say poetry


00:10:32.440 --> 00:10:34.480
is more for projects or something.


00:10:34.480 --> 00:10:36.920
But this is dealing with a Python package.


00:10:36.920 --> 00:10:39.640
And it walks through creating a new project


00:10:39.640 --> 00:10:44.560
and then customizing the pyproject.toml file,


00:10:44.560 --> 00:10:46.720
and then all the different settings within the toml,


00:10:46.720 --> 00:10:49.280
and what do they mean, and why you pick different ones.


00:10:49.280 --> 00:10:52.560
And then carries you through to if it's something


00:10:52.560 --> 00:10:53.940
we're going to share with the rest of the world.


00:10:53.940 --> 00:10:55.900
I mean, one of the great things about all this


00:10:55.900 --> 00:10:58.100
is you don't have to share your code with the world.


00:10:58.100 --> 00:11:00.700
You might be just sharing it with your team members


00:11:00.700 --> 00:11:04.040
or just even making modularizing your own stuff.


00:11:04.040 --> 00:11:05.740
But if you do want to share it,


00:11:05.740 --> 00:11:08.940
does show you how to use the test server at PyPI


00:11:08.940 --> 00:11:11.100
to try everything out and make sure it works.


00:11:11.100 --> 00:11:14.380
And then finally to publish directly to PyPI.


00:11:14.380 --> 00:11:16.260
- Yeah, it looks like a really nice little write-up.


00:11:16.260 --> 00:11:20.540
And yeah, it's just typing poetry space publish.


00:11:20.540 --> 00:11:21.580
That's not terrible.


00:11:22.460 --> 00:11:25.720
Yeah, it doesn't talk about testing or integrating testing


00:11:25.720 --> 00:11:29.780
and talks into a project, which, and PyTest, of course.


00:11:29.780 --> 00:11:31.480
But so that maybe that's an extension,


00:11:31.480 --> 00:11:33.400
but yeah, this is the packaging part.


00:11:33.400 --> 00:11:34.880
- Yeah, cool, maybe a follow-up article.


00:11:34.880 --> 00:11:35.880
That'd be great.


00:11:35.880 --> 00:11:36.940
Very nice one.


00:11:36.940 --> 00:11:38.600
So the last one that I wanna cover


00:11:38.600 --> 00:11:41.920
is a realpython.com article by Logan Jones.


00:11:41.920 --> 00:11:43.960
We got to hang out with him a little bit at PyCon.


00:11:43.960 --> 00:11:44.780
That was fun.


00:11:44.780 --> 00:11:47.960
But this one is, I think, an interesting,


00:11:47.960 --> 00:11:52.160
sort of thought-provoking one about Python and the language.


00:11:52.160 --> 00:11:55.000
So I think there's a lot to learn here for many folks.


00:11:55.000 --> 00:11:57.080
And it's called Python Pointers,


00:11:57.080 --> 00:11:59.160
or Pointers in Python, What's the Point?


00:11:59.160 --> 00:12:02.020
So I mean, first of all, like the question is,


00:12:02.020 --> 00:12:03.720
like outside of C extensions,


00:12:03.720 --> 00:12:06.620
and maybe like inside the CPython runtime,


00:12:06.620 --> 00:12:09.700
but you know, in Python, the language itself,


00:12:09.700 --> 00:12:11.800
does Python even have pointers, right?


00:12:11.800 --> 00:12:12.720
Like, what do you think?


00:12:12.720 --> 00:12:13.800
How would you answer that question


00:12:13.800 --> 00:12:14.640
if somebody asked you that?


00:12:14.640 --> 00:12:16.960
- It's mostly hidden from users.


00:12:16.960 --> 00:12:17.780
- Exactly, yeah.


00:12:17.780 --> 00:12:19.120
If someone asked me, does Python have pointers?


00:12:19.120 --> 00:12:20.880
I would say, yeah, of course it has pointers.


00:12:20.880 --> 00:12:24.840
But it really hinges on whether or not you define that as,


00:12:24.840 --> 00:12:27.800
I can put a ampersand in front and then like plus plus it


00:12:27.800 --> 00:12:31.400
and move along in like a string or move along in an array.


00:12:31.400 --> 00:12:33.040
Like can I do pointer arithmetic


00:12:33.040 --> 00:12:35.440
and can I actually work at that level?


00:12:35.440 --> 00:12:39.000
Or is it I have variables that point out


00:12:39.000 --> 00:12:41.280
to things on the heap, like pointers, right?


00:12:41.280 --> 00:12:43.120
Like which of those has to pass the bar


00:12:43.120 --> 00:12:44.800
to be like it's a pointer, right?


00:12:44.800 --> 00:12:47.920
- Yeah, and generally a new person at Python


00:12:47.920 --> 00:12:50.160
and programming all together wouldn't even notice them


00:12:50.160 --> 00:12:51.960
and would say no, but I mean, like,


00:12:51.960 --> 00:12:53.900
names are all pointing to stuff, so.


00:12:53.900 --> 00:12:56.020
- Exactly, so what's really interesting is


00:12:56.020 --> 00:12:58.120
that could be a big misconception, right?


00:12:58.120 --> 00:13:01.680
Because if you think what you're passing around are values,


00:13:01.680 --> 00:13:02.880
but you actually have pointers,


00:13:02.880 --> 00:13:05.280
anytime you change one of those things,


00:13:05.280 --> 00:13:06.640
you're changing it everywhere, right?


00:13:06.640 --> 00:13:10.360
You have pass by reference, not pass by values semantics.


00:13:10.360 --> 00:13:12.420
And so if you think I can pass this over,


00:13:12.420 --> 00:13:15.360
that thing can change it, and it doesn't affect me


00:13:15.360 --> 00:13:16.600
like a normal value would, right?


00:13:16.600 --> 00:13:19.160
Like, whoops, that's a bit of a problem, right?


00:13:19.160 --> 00:13:23.080
We've seen weird edge cases where the default value of an empty list


00:13:23.080 --> 00:13:26.480
in a function can be all sorts of badness for reasons like that.


00:13:26.480 --> 00:13:27.800
So it's pretty interesting.


00:13:27.800 --> 00:13:33.480
I think actually Python is more pointer heavy than most languages,


00:13:33.480 --> 00:13:37.200
more so than C#, more so than C++.


00:13:37.200 --> 00:13:39.480
Because in those languages, you at least have the option


00:13:39.480 --> 00:13:42.800
to define stuff on the stack and define value types like integers


00:13:42.800 --> 00:13:45.120
versus in pointers in C++.


00:13:45.120 --> 00:13:46.480
In Python, you really don't.


00:13:46.480 --> 00:13:49.160
everything, even numbers and Booleans and stuff


00:13:49.160 --> 00:13:50.000
are pointers, right?


00:13:50.000 --> 00:13:52.400
- I didn't know that, but okay.


00:13:52.400 --> 00:13:55.800
- Yeah, so like true is a pointer out on the heap.


00:13:55.800 --> 00:13:57.960
The number seven is a pointer on the heap.


00:13:57.960 --> 00:13:59.520
So what it means is like all sorts,


00:13:59.520 --> 00:14:01.320
you know, it really helps you,


00:14:01.320 --> 00:14:03.240
if you look, and the article goes through a lot of this,


00:14:03.240 --> 00:14:06.840
if you look deeply at like the memory structure


00:14:06.840 --> 00:14:09.640
of what you get, you know, each reference type,


00:14:09.640 --> 00:14:13.080
which I'll call them, you know, thing in Python,


00:14:13.080 --> 00:14:16.360
each object, so everything, has a reference count.


00:14:16.360 --> 00:14:24.120
has to keep track of. It has a type like so in the pi object that actually gets


00:14:24.120 --> 00:14:29.880
allocated when you say the number one or whatever that has actually a field up


00:14:29.880 --> 00:14:33.400
there that says this is an integer right now this pi object that is pointing at


00:14:33.400 --> 00:14:38.320
is supposed to be an integer and it has a value. So if you think of I've got this


00:14:38.320 --> 00:14:44.480
simple little piece of data like the number one or the character C it's not


00:14:44.480 --> 00:14:50.720
just one byte or four bytes or whatever it's many of those I don't know 20 25 28


00:14:50.720 --> 00:14:54.120
I'm not sure exactly what the number is but there's a lot of stuff coming along


00:14:54.120 --> 00:14:58.600
with that what would otherwise look like a really simple little value yeah okay


00:14:58.600 --> 00:15:03.240
okay there's some nice drawings in there about like that names are pointing to


00:15:03.240 --> 00:15:07.520
objects and objects all have types and values and reference counts and yeah


00:15:07.520 --> 00:15:10.920
this is good probably needed yeah I think people should read this who


00:15:10.920 --> 00:15:14.240
haven't deeply thought about this whole reference type


00:15:14.240 --> 00:15:17.000
scenario and what that means.


00:15:17.000 --> 00:15:18.080
It's pretty cool.


00:15:18.080 --> 00:15:20.640
My takeaway is Python has pointers.


00:15:20.640 --> 00:15:22.320
All the variables in Python are pointers.


00:15:22.320 --> 00:15:25.760
But they're like these safe reference type, wrapper type


00:15:25.760 --> 00:15:28.880
things that you don't directly have to worry about, allocate,


00:15:28.880 --> 00:15:29.960
whatever, right?


00:15:29.960 --> 00:15:30.680
So pretty cool.


00:15:30.680 --> 00:15:32.640
There's one interesting little thing


00:15:32.640 --> 00:15:36.000
that I saw in the article that Logan talked about,


00:15:36.000 --> 00:15:38.640
and that was about interning objects.


00:15:38.640 --> 00:15:41.760
So when I said earlier before, when I say the number one,


00:15:41.760 --> 00:15:45.320
it actually allocates a Pi object on the heap, sort of.


00:15:45.320 --> 00:15:47.160
There was a Pi object allocated on the heap


00:15:47.160 --> 00:15:51.080
that corresponds to one, but the first 256,


00:15:51.080 --> 00:15:53.920
something like that, numbers are what are called interned,


00:15:53.920 --> 00:15:56.280
and so are certain strings.


00:15:56.280 --> 00:15:58.720
And that means like if you allocate a one over here


00:15:58.720 --> 00:16:00.480
and you allocate a one over there,


00:16:00.480 --> 00:16:04.520
those are actually reusing the same object, right?


00:16:04.520 --> 00:16:08.320
So they pre-allocate like the basic numbers and strings,


00:16:08.320 --> 00:16:11.320
and then you just change where your pointer points.


00:16:11.320 --> 00:16:13.560
Like, that's just part of Python startup.


00:16:13.560 --> 00:16:14.400
- Okay.


00:16:14.400 --> 00:16:15.360
- Right, so that's called interning.


00:16:15.360 --> 00:16:18.000
And the interesting bit is that you can


00:16:18.000 --> 00:16:19.640
manually intern things.


00:16:19.640 --> 00:16:21.400
Like, I can go to the system and say,


00:16:21.400 --> 00:16:22.720
this thing I want to intern it,


00:16:22.720 --> 00:16:24.720
so if someone else tries to create one of them,


00:16:24.720 --> 00:16:26.820
just, you know, don't reallocate it,


00:16:26.820 --> 00:16:30.640
just share this sort of global one-off thing I've created.


00:16:30.640 --> 00:16:33.280
And so it says, you can intern strings,


00:16:33.280 --> 00:16:35.160
and this can be useful for the performance


00:16:35.160 --> 00:16:36.600
on dictionary lookups.


00:16:36.600 --> 00:16:40.160
because if the strings that are the keys of the dictionary


00:16:40.160 --> 00:16:43.340
are interned, then a dictionary lookup


00:16:43.340 --> 00:16:47.400
is a pointer comparison versus a string comparison.


00:16:47.400 --> 00:16:48.800
(laughing)


00:16:48.800 --> 00:16:49.700
- Okay.


00:16:49.700 --> 00:16:50.800
- Okay, isn't that cool?


00:16:50.800 --> 00:16:54.920
So basically it's an is versus a double equal, right?


00:16:54.920 --> 00:16:56.080
And if you've got a big dictionary


00:16:56.080 --> 00:16:58.120
and you're like going crazy on it


00:16:58.120 --> 00:16:59.880
and the keys are kind of complicated,


00:16:59.880 --> 00:17:02.460
that could potentially make it quite a bit faster.


00:17:02.460 --> 00:17:03.480
Like much, much faster.


00:17:03.480 --> 00:17:05.420
It's like are these two integers


00:17:05.420 --> 00:17:08.280
or longs the same versus I gotta go through


00:17:08.280 --> 00:17:10.020
like 20 characters and compare them.


00:17:10.020 --> 00:17:11.220
- Well, so there must be some reason


00:17:11.220 --> 00:17:12.860
why we don't just intern everything.


00:17:12.860 --> 00:17:14.660
- If you intern it, it won't expire.


00:17:14.660 --> 00:17:15.500
It won't be cleaned up.


00:17:15.500 --> 00:17:16.500
- Oh, okay.


00:17:16.500 --> 00:17:17.340
- Yeah, yeah.


00:17:17.340 --> 00:17:18.740
So, I mean, like if you're not gonna keep it around


00:17:18.740 --> 00:17:21.560
and share it, you would basically be doing manually


00:17:21.560 --> 00:17:23.100
memory management stuff.


00:17:23.100 --> 00:17:24.460
All right, so all of that is, I think,


00:17:24.460 --> 00:17:26.300
super interesting and worth people checking out.


00:17:26.300 --> 00:17:27.580
But now the question comes down,


00:17:27.580 --> 00:17:30.900
like can I have ampersand X?


00:17:30.900 --> 00:17:33.980
Can I get my actual pointer or star X, right?


00:17:33.980 --> 00:17:37.860
Can I do real pointer stuff in Python?


00:17:37.860 --> 00:17:39.580
And of course, Python has to interact with C,


00:17:39.580 --> 00:17:42.060
and C functions often take this type pointer,


00:17:42.060 --> 00:17:44.780
that type of pointer, so how does that work, right?


00:17:44.780 --> 00:17:46.460
So in-- - I don't know.


00:17:46.460 --> 00:17:49.100
- Yeah, so in C++, we have inline assembly.


00:17:49.100 --> 00:17:51.100
You can kinda drop down to a lower bit.


00:17:51.100 --> 00:17:52.940
In C#, you have unsafe mode,


00:17:52.940 --> 00:17:55.260
'cause C# has reference types just like Python,


00:17:55.260 --> 00:17:57.300
but there's a way to say, turn that off


00:17:57.300 --> 00:17:59.760
and let me actually do pointer arithmetic on it.


00:17:59.760 --> 00:18:02.820
So the question is, can we have that in Python?


00:18:02.820 --> 00:18:06.200
And actually, if you use Cython, you can.


00:18:06.200 --> 00:18:08.540
Like in Python code, you can say this is a pointer


00:18:08.540 --> 00:18:10.000
and you can dereference its address


00:18:10.000 --> 00:18:12.520
by saying ampersand and stuff like that.


00:18:12.520 --> 00:18:13.380
That's one way.


00:18:13.380 --> 00:18:15.900
And you can also work with the C types library.


00:18:15.900 --> 00:18:19.020
So I can create like an integer pointer


00:18:19.020 --> 00:18:21.340
by allocating a C type and then pass it around


00:18:21.340 --> 00:18:22.500
and share it and stuff.


00:18:22.500 --> 00:18:23.340
- Okay.


00:18:23.340 --> 00:18:25.960
- So yes, if you need to dig down


00:18:25.960 --> 00:18:27.720
and you need to like truly simulate


00:18:27.720 --> 00:18:30.800
what pointers really, really are,


00:18:30.800 --> 00:18:32.480
you can actually do that in Python as well.


00:18:32.480 --> 00:18:34.600
And there's two ways to do it there.


00:18:34.600 --> 00:18:37.960
One requires Cython, and one is just straight CPython.


00:18:37.960 --> 00:18:40.640
All right, have you had enough language lessons for today,


00:18:40.640 --> 00:18:41.140
Ryan?


00:18:41.140 --> 00:18:45.400
-Or you could just not worry about it so much.


00:18:45.400 --> 00:18:46.120
-Exactly.


00:18:46.120 --> 00:18:48.880
I do think it's worth thinking about this question


00:18:48.880 --> 00:18:51.880
and what it looks like in Python if you haven't thought about it


00:18:51.880 --> 00:18:52.480
before.


00:18:52.480 --> 00:18:55.280
And I think the thing before, the preview Python


00:18:55.280 --> 00:18:57.160
plug-in or extension for VS Code,


00:18:57.160 --> 00:18:58.680
I think would also help with this.


00:18:58.680 --> 00:19:00.520
Because it has little lines that are really


00:19:00.520 --> 00:19:01.800
the references and so on.


00:19:01.800 --> 00:19:03.600
- So that's it for all of our topics today.


00:19:03.600 --> 00:19:06.200
Anything else, any extra stuff you want to just throw out


00:19:06.200 --> 00:19:07.040
there real quick?


00:19:07.040 --> 00:19:09.680
- Well, I was gonna talk about the PSF fundraiser,


00:19:09.680 --> 00:19:12.860
but you've got it on your list too, so.


00:19:12.860 --> 00:19:15.280
- Yeah, it looks like I, in terms of writing it down,


00:19:15.280 --> 00:19:16.120
I beat you to it.


00:19:16.120 --> 00:19:17.740
So I guess I'll say something about it.


00:19:17.740 --> 00:19:20.000
So the PSF is doing a fundraiser.


00:19:20.000 --> 00:19:21.000
I've linked over to it.


00:19:21.000 --> 00:19:21.960
You should definitely check it out.


00:19:21.960 --> 00:19:24.280
On the previous episode, we also sort of talked about


00:19:24.280 --> 00:19:26.000
that you can buy a PyCharm license,


00:19:26.000 --> 00:19:28.640
and some of that money, like 30% or something,


00:19:28.640 --> 00:19:30.560
goes towards the PSF.


00:19:30.560 --> 00:19:32.560
or you can just directly contribute to it.


00:19:32.560 --> 00:19:35.080
So I've linked to the blog post that they just posted.


00:19:35.080 --> 00:19:39.000
Now, the deadline was supposed to be June 1st, I believe,


00:19:39.000 --> 00:19:41.540
but they didn't raise enough money,


00:19:41.540 --> 00:19:44.040
which is mind-blowing to me.


00:19:44.040 --> 00:19:45.800
But they didn't raise enough money,


00:19:45.800 --> 00:19:48.400
so they've extended it till June 30th.


00:19:48.400 --> 00:19:51.740
So please click on the link, donate something,


00:19:51.740 --> 00:19:53.680
and more importantly, maybe,


00:19:53.680 --> 00:19:55.960
try to get your company to donate, right?


00:19:55.960 --> 00:19:58.160
If your company deeply depends on Python


00:19:58.160 --> 00:20:00.000
having a vibrant ecosystem,


00:20:00.000 --> 00:20:02.360
These are tax deductible if you pay taxes in the US,


00:20:02.360 --> 00:20:03.600
so definitely check it out.


00:20:03.600 --> 00:20:05.540
- People don't know that PSF money


00:20:05.540 --> 00:20:08.400
goes to help fund workshops and conferences,


00:20:08.400 --> 00:20:10.740
and they help pay meetup fees around


00:20:10.740 --> 00:20:12.480
so that a lot of the local Python meetups


00:20:12.480 --> 00:20:14.260
don't have to pay their own fees.


00:20:14.260 --> 00:20:15.520
They do a lot of sponsorship


00:20:15.520 --> 00:20:17.680
and financial aid of different projects


00:20:17.680 --> 00:20:20.320
that should be funded but aren't otherwise.


00:20:20.320 --> 00:20:21.660
So it's a good thing.


00:20:21.660 --> 00:20:22.500
Donate to it.


00:20:22.500 --> 00:20:23.320
- Absolutely.


00:20:23.320 --> 00:20:25.000
All right, I think it's time for a joke.


00:20:25.000 --> 00:20:25.840
- Yeah.


00:20:25.840 --> 00:20:26.680
- Quick little one here at the end.


00:20:26.680 --> 00:20:28.400
This one comes from Jay Miller,


00:20:28.400 --> 00:20:34.800
And the question is, what did the developer name his newborn son?


00:20:34.800 --> 00:20:36.560
Of course, Jason.


00:20:36.560 --> 00:20:38.480
Jason, that's right.


00:20:38.480 --> 00:20:39.360
Oh, dear.


00:20:39.360 --> 00:20:39.880
Oh, well.


00:20:39.880 --> 00:20:40.320
Yeah.


00:20:40.320 --> 00:20:41.000
Yeah, that's a good one.


00:20:41.000 --> 00:20:42.560
Thank you, Jay and Brian.


00:20:42.560 --> 00:20:43.760
Thanks for being here.


00:20:43.760 --> 00:20:44.640
All right, thank you.


00:20:44.640 --> 00:20:44.840
Bye.


00:20:44.840 --> 00:20:45.640
Yep, see you.


00:20:45.640 --> 00:20:47.360
Thank you for listening to Python Bytes.


00:20:47.360 --> 00:20:49.840
Follow the show on Twitter via @PythonBytes.


00:20:49.840 --> 00:20:52.880
That's Python Bytes as in B-Y-T-E-S.


00:20:52.880 --> 00:20:56.080
And get the full show notes at PythonBytes.fm.


00:20:56.080 --> 00:20:57.680
If you have a news item you want featured,


00:20:57.680 --> 00:21:00.140
just visit pythonbytes.fm and send it our way.


00:21:00.140 --> 00:21:03.020
We're always on the lookout for sharing something cool.


00:21:03.020 --> 00:21:04.860
On behalf of myself and Brian Okken,


00:21:04.860 --> 00:21:06.180
this is Michael Kennedy.


00:21:06.180 --> 00:21:08.200
Thank you for listening and sharing this podcast


00:21:08.200 --> 00:21:09.860
with your friends and colleagues.

