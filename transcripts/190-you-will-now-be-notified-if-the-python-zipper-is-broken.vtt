WEBVTT

00:00:00.001 --> 00:00:04.160
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to

00:00:04.160 --> 00:00:11.180
your earbuds. This is episode 190, recorded July 8, 2020. At least it's the 8th year.

00:00:11.180 --> 00:00:14.280
I'm not sure what it is in Australia. Is it tomorrow already?

00:00:14.280 --> 00:00:14.960
It's the 9th.

00:00:14.960 --> 00:00:19.360
Oh my God, you're from the future. Anthony Shaw is here and he is from the future.

00:00:19.360 --> 00:00:20.480
That's awesome.

00:00:20.480 --> 00:00:25.100
I'm Michael, as everyone knows. And Anthony, thank you for joining the two of us here on

00:00:25.100 --> 00:00:26.280
the show. Happy to have you.

00:00:26.280 --> 00:00:27.140
Yeah, I'm glad to be here.

00:00:27.140 --> 00:00:31.760
I want to kick this off with, I think, an interesting article. It's by Tom Christie,

00:00:31.760 --> 00:00:39.680
titled Python Async Frameworks Beyond Developer Tribalism. And I think it's a, and Tom Christie,

00:00:39.680 --> 00:00:45.240
if you don't know who he is, he's done some things like the Django REST framework and HTTPX. Of course,

00:00:45.240 --> 00:00:50.800
other people are on those projects as well, but bright guy. And I think it's in part to a reaction.

00:00:50.800 --> 00:00:56.520
We didn't cover this article, but we noticed it prior. An article called Async Python is Not

00:00:56.520 --> 00:01:03.280
Faster. But all of us had some issues with the article itself. And so this isn't a direct rebuttal,

00:01:03.280 --> 00:01:10.260
but it's an interesting read. One of the things Tom Christie's pointing out is just that I think

00:01:10.260 --> 00:01:16.340
that we need to move the Python community beyond polarizing discussions. And I think that Async

00:01:16.340 --> 00:01:23.320
Python is Not Faster was not a helpful discussion, but it's part of it anyway. A little bit of a quote,

00:01:23.320 --> 00:01:27.900
we could probably benefit from a bit more recognition of where there is shared ground

00:01:27.900 --> 00:01:32.900
and in the areas where there's less clarity, have constructive conversations around those.

00:01:32.900 --> 00:01:39.660
And so some of the shared ground Tom points out is kind of one of the things is you really shouldn't

00:01:39.660 --> 00:01:44.520
really care about performance too much when you start a project. The success of a project is more

00:01:44.520 --> 00:01:50.500
related to developer experience and the strengths surrounding the ecosystem of the framework you're

00:01:50.500 --> 00:01:56.940
using, not just whether or not it's faster. And you should care. But we as the Python community do need

00:01:56.940 --> 00:02:03.420
to care about web performance, partly because new projects starting off might decide to go with

00:02:03.420 --> 00:02:07.380
non-Python solution because they fear Python might be too slow.

00:02:07.380 --> 00:02:11.540
And Anthony, how often have either of you heard, oh, we decided to rewrite that and go.

00:02:11.540 --> 00:02:18.200
So we have proper async or we decided to use JavaScript here because it supports async through

00:02:18.200 --> 00:02:20.560
node or something like that. Like I've heard that a lot.

00:02:20.560 --> 00:02:22.160
Yeah, definitely. Lots of projects.

00:02:22.160 --> 00:02:26.820
Yeah. And I'm not sure. I don't know anything about those other languages though. So

00:02:26.820 --> 00:02:33.300
at least I haven't used them, but for me, it would be a mistake because I know Python. I don't know

00:02:33.300 --> 00:02:37.560
those other ones. Okay. So that's one of the points is that maybe we should care a little bit,

00:02:37.560 --> 00:02:42.900
but also we should be careful about the word performance because if you measure performance

00:02:42.900 --> 00:02:51.440
of just a single async function calls with, or a single function call, an async call is going to be

00:02:51.440 --> 00:02:57.460
slightly slower because there's a little bit of async overhead, but we don't use async because we

00:02:57.460 --> 00:03:03.940
want single threaded applications to be faster. We use it because especially IO bound concurrent

00:03:03.940 --> 00:03:11.540
tasks are, they scale better with async. The other aspect we wanted to talk about was there's just

00:03:11.540 --> 00:03:17.440
really, you have to be careful with looking at benchmark data because benchmarks are often geared

00:03:17.440 --> 00:03:24.400
selected to tell the story that the person writing the article wants to convey.

00:03:24.400 --> 00:03:27.800
Or the situation that they're trying to solve, right? They're like, oh, I thought this would help.

00:03:27.800 --> 00:03:30.760
I tried to solve with this. Turns out it doesn't. It must be bad.

00:03:30.760 --> 00:03:31.360
Yeah. Right.

00:03:31.360 --> 00:03:36.400
Okay. So there's some things that they're just reasonable statements and there are some valid

00:03:36.400 --> 00:03:41.380
differences. Like for instance, should web frameworks, the web frameworks we have now,

00:03:41.540 --> 00:03:48.440
should they start converting to async or should we just leave them as they are and develop new frameworks

00:03:48.440 --> 00:03:52.820
that are async native? Those are some differences. There's also different approaches,

00:03:52.820 --> 00:03:58.140
which is part of the confusion and part of the discussion is there's asyncio. There's also trio

00:03:58.140 --> 00:04:04.620
and twisted and curio and you know how to decide which one there is some confusion there. And I think that's

00:04:04.620 --> 00:04:09.980
valid. So the discourse and the discussion is important, but I think it's important Tom points

00:04:09.980 --> 00:04:16.300
out to say, basically we need to keep it. The benefits of adopting genuine collaborative mindset

00:04:16.300 --> 00:04:22.100
are good rather than a competitive mindset. So let's not fight with each other. There may be

00:04:22.100 --> 00:04:28.100
different or everybody's working on different little corners of the landscape, but we're still trying to

00:04:28.100 --> 00:04:35.160
appreciate move the move async and move web forward for Python. So stay positive, be happy.

00:04:35.160 --> 00:04:41.960
Be happy, man. Well, I didn't want to just call this other article out and criticize it because I don't think

00:04:41.960 --> 00:04:47.620
that adds a lot of value. I don't think we want to cover items just to criticize them, except for their rare moments

00:04:47.620 --> 00:04:52.940
where it's getting a ton of attention. And if you think there's an inaccuracy, you probably should call it.

00:04:52.940 --> 00:04:57.460
I'm glad Tom wrote this article. I think Tom wrote it, right? I mean, it's not attributed, but it's from

00:04:57.460 --> 00:05:00.580
basically his organization. So I'm pretty sure.

00:05:00.580 --> 00:05:07.220
Yeah, I had to go look at the GitHub repo to see who did the push, the commits for this article. So, yep, it was Tom.

00:05:07.220 --> 00:05:13.480
What an interesting way to attribute it. Very cool. I honestly believe that other article, which you're linking to,

00:05:13.480 --> 00:05:20.620
is inaccurate. I think it's trying to apply async to a situation where it's not very warranted. It's like,

00:05:20.620 --> 00:05:26.300
this hammer is really bad at unscrewing this nail or this unscrewing the screw. Hammers are bad, right?

00:05:26.360 --> 00:05:31.480
Well, hammers aren't for that. Async stuff is for scaling when there is a waiting period,

00:05:31.480 --> 00:05:36.180
when there's a latency when you're waiting on something. And the setup there was the DB was

00:05:36.180 --> 00:05:41.240
100% maxed out. So there was no way to push that waiting and get more out of the database.

00:05:41.240 --> 00:05:46.280
And there was almost no waiting, like a few milliseconds anyway. And so the overhead didn't

00:05:46.280 --> 00:05:50.320
make any sense. Somebody wrote me and said, Michael, please, I've got to know your thoughts on this.

00:05:50.320 --> 00:05:55.660
So I went ahead and did a little quick test. I've got in my async course, I've got some stuff where

00:05:55.660 --> 00:06:00.540
we go and talk to things on the internet, where there's like ping time latency and stuff. And it

00:06:00.540 --> 00:06:05.060
goes and gets 10 items off a web server. Ping time is like 100 milliseconds or something.

00:06:05.480 --> 00:06:12.540
It was 750% faster to use the async version than not the async version. I changed that number to get

00:06:12.540 --> 00:06:18.740
100 of them. And it went from 50 seconds, almost one minute down to two and a half seconds.

00:06:18.740 --> 00:06:25.080
1,750% faster. Async is about scaling the waiting part. If there's no waiting,

00:06:25.080 --> 00:06:27.120
there's no benefit. There's just overhead.

00:06:27.120 --> 00:06:30.320
The one thing I have to, I guess I'm going to be on the other side a little bit.

00:06:30.320 --> 00:06:35.320
The async is not faster article. One of the things he did point out was a lot of the async

00:06:35.320 --> 00:06:43.040
framework benchmarks are in the benchmark numbers are not really that fair because there's other ways

00:06:43.040 --> 00:06:49.880
you can speed up the other platforms by, for instance, adding processors or CPUs, adding more

00:06:49.880 --> 00:06:56.700
cores to different applications. And that maybe the original application was just misconfigured.

00:06:56.700 --> 00:07:00.720
I think that's valid, but it doesn't mean that async is bad.

00:07:00.720 --> 00:07:02.900
Yeah, it definitely adds some complexity. Go ahead, Nat.

00:07:02.900 --> 00:07:07.040
If you're comparing it with multi-threading, I think that's the comparison. I think if you're

00:07:07.040 --> 00:07:12.680
just looking at, I've got single sequential code, does adding async make it faster? If it's something

00:07:12.680 --> 00:07:17.360
that's IO bound, yes is the answer. But if you're comparing it to multi-threading, so using the

00:07:17.360 --> 00:07:22.140
threading module to spawn threads, then I think that's where you see the performance improvement.

00:07:22.400 --> 00:07:29.600
So I've got some micro benchmarks doing TCP port scanning across all the different ways you can do

00:07:29.600 --> 00:07:36.880
concurrency and parallelism in Python. And async was the fastest of all those options. And it cuts down a

00:07:36.880 --> 00:07:42.420
lot of the overhead from threading because the way that the threads work in Python, they've kind of got

00:07:42.420 --> 00:07:52.380
this bootstrap module that kind of has to load some of the stuff that it needs for context. Whereas async doesn't need that. So it kind of cuts down a lot of that.

00:07:52.380 --> 00:07:58.620
overhead. I think one of the challenges I've had with async in the earlier versions where it got released was the amount of

00:07:58.620 --> 00:08:13.180
boilerplate code and kind of like infrastructure you needed to put in just to do something really simple, which is like, I want to run this function asynchronously. Like I don't care about what how the event loops and all that kind of stuff. Like I've used other languages.

00:08:13.180 --> 00:08:18.460
I want to kick it off and forget it. It's like, why can't I just call this function and let it go? What is all this stuff I'm doing?

00:08:18.460 --> 00:08:33.720
Yeah, exactly. So I've used other languages where the async is a bit more fluent. I've been using the Kotlin async last week, and I've used .NET, C Sharp, the task API, which is really, really nice to use.

00:08:33.720 --> 00:08:50.900
The other challenge is which bit of code owns the event loop? And that's like an anti-pattern where you end up with a god class that's kind of doing everything. And you've kind of then got to think about how you factor the application so that, okay, which bit owns the event loop? How do I construct that? Where does it end?

00:08:51.400 --> 00:09:10.480
We were helping on the RealPython community group. Somebody was asking some questions. They'd async, or is it multi-threading into their code? And we were just trying to get them to refactor it to take all the logic out of the function that was being multi-threaded and put it into the master and just put the minimal amount of code in the threaded function.

00:09:10.540 --> 00:09:26.340
I think there's still a whole bunch of stuff like that, which people need some good learning on and they need to get used to. It's like a different way of writing code. It's not just something that you can sprinkle on top and it suddenly makes your code faster. I think that's part of the misunderstanding.

00:09:26.340 --> 00:09:36.240
Yeah, especially in Python, where it takes that extra step of you've got to manage the loop and then you've got to run it. And it's not like kind of I've kicked off a bunch of stuff and now it's all just happening.

00:09:36.240 --> 00:09:52.500
Yeah, they made that simpler in 3.7 and 3.8. They've kind of got some shortcut modules that, so I think it's now like one or two lines of extra code you need as boilerplate just to get asyncio up and running. So it's a lot better than it was in the earlier versions.

00:09:52.500 --> 00:10:16.740
But even if it's not a lot of extra code, and Tom Christie points this out, multi-threading and async are more complicated than not. So that's just a reality. Whether or not the code's too much more complicated, the entire design is different. And it's a reality. That isn't to say don't do async or don't do multi-threading. It's just you don't get it for free.

00:10:16.740 --> 00:10:42.960
I think almost the opposite in a sense. I think the code is not complicated enough. On the other hand, like it looks close enough that people don't realize they have to change their mindset and like approach it in an entirely different way. And they feel like, oh, I just call it this way now. But then they run into these issues. They're like, oh, this is broken. Like, why is this not working? Or, you know, like you think you can just do it one way. But you really, if you don't have a little deeper understanding, you can just go down the wrong path also.

00:10:42.960 --> 00:10:43.220
Yeah.

00:10:43.220 --> 00:10:47.300
All right. Well, that was interesting. Thanks for bringing that up. And thanks, Tom, for writing that.

00:10:47.300 --> 00:10:55.440
Anthony, I'm glad you're here to have another opinion as well. I agree that the C-sharp, async and white stuff is, it's like the gold standard. It's really, really well done.

00:10:55.440 --> 00:11:02.420
So let's talk about something way simpler. You want to be a good citizen of your GitHub projects, right?

00:11:02.420 --> 00:11:02.760
Sure.

00:11:02.760 --> 00:11:08.880
Obviously, you want to have good commit messages. There's a major change. You want to bump the version, all those kinds of things, right?

00:11:08.880 --> 00:11:25.840
So you should use commitizen. Commitizen is a command line interface, basically, that wraps around Git. But it has like a menu option for different things. And it guides you through doing them a little bit better.

00:11:25.840 --> 00:11:50.220
So like, you can say CZ, and it'll drop down a list, you can pick commit or whatever. And then it'll ask you questions like, okay, well, what are you trying to do? Are you trying to add a feature? Are you trying to do a bug fix? Or is it a PR? And it'll ask you a couple of questions. And it'll generate interesting things like, hey, is this a breaking change? Would you like me to increment the major version as part of this? And so on.

00:11:50.420 --> 00:12:05.480
So it does all sorts of interesting things around kind of structuring your interaction with Git. So rules for projects, auto bumping versions, auto change log generation, all that kind of stuff. And it's really meant for teams. So they all like interact with Git in a consistent way.

00:12:05.480 --> 00:12:06.080
This is cool.

00:12:06.080 --> 00:12:07.000
Yeah, neat, right?

00:12:07.000 --> 00:12:13.700
Yeah. And if you go to it, it has a beautiful animated GIF showing how it works right on the GitHub repo. Gotta love that.

00:12:13.700 --> 00:12:19.020
So do you, I'm just curious, do you normally commit through command line or through something else?

00:12:19.020 --> 00:12:23.020
No, no, I commit either through PyCharm or SourceTree, depending on what I'm doing.

00:12:23.020 --> 00:12:24.180
Yeah, I do both.

00:12:24.180 --> 00:12:24.500
Yeah.

00:12:24.500 --> 00:12:35.160
If I'm in PyCharm and a project, then I'll do it through there. If I'm doing something else, so like sometimes it's like little hacks or scripts and stuff like that, then I'll do it on the command line.

00:12:35.160 --> 00:12:38.380
Like a presentation that's in, say, PowerPoint or something.

00:12:38.380 --> 00:12:41.060
Yeah, yeah, I'm committing my PowerPoint presentation in.

00:12:43.140 --> 00:12:49.180
Then I'd use the command line, but I've got a whole bunch of aliases to do because you should always sign your commits and stuff like that.

00:12:49.180 --> 00:12:50.540
So put some aliases.

00:12:50.540 --> 00:12:59.140
And something else would be really helpful that a lot of people don't know is that, you know how if you do Git commit on the command line, it uses Vim as the message editor by default.

00:12:59.320 --> 00:13:13.140
You can actually change that. So if you wanted to use another editor like Emacs or Notepad++ or maybe even Microsoft Word, then you can change the configuration in the command line and you never have to use Vim ever again.

00:13:13.280 --> 00:13:13.900
I like that.

00:13:13.900 --> 00:13:19.080
I think a great prank that people should all do.

00:13:19.080 --> 00:13:21.060
Maybe not all.

00:13:21.060 --> 00:13:27.160
Sneak into your co-worker's computer if they run away for lunch and don't lock it and set Word as the editor.

00:13:27.160 --> 00:13:31.580
So next time they go to do something and there's a merge error, like it pops up Word.

00:13:31.580 --> 00:13:33.120
You're like, what in the world is going on here?

00:13:33.120 --> 00:13:36.460
But your commit messages are going to be like 10,000 lines of XML.

00:13:36.460 --> 00:13:38.980
Exactly.

00:13:38.980 --> 00:13:39.660
Exactly.

00:13:39.660 --> 00:13:41.160
Now, that's cool.

00:13:41.660 --> 00:13:44.960
This thing, this commit is in, also comes with a Git pre-commit hook.

00:13:44.960 --> 00:13:47.600
So you can set it up there as well.

00:13:47.600 --> 00:13:56.180
And you can ask it for things like, you just say, run the bump or generate the changelog or validate the schema of a message or whatever.

00:13:56.180 --> 00:13:57.480
So pretty cool.

00:13:57.480 --> 00:13:59.100
It generates a changelog.

00:13:59.100 --> 00:14:01.560
Like I've been looking for something to do that for ages.

00:14:01.560 --> 00:14:11.000
Like I've got projects in Git and when I make a release, I had to like remember what got merged, which PRs got merged, who did them so you could attribute them.

00:14:11.000 --> 00:14:20.920
I don't know what the output is, but it says, you know, CZ space changelog or CH for the shortness is what it will do.

00:14:20.920 --> 00:14:25.040
And it says generates changelog by overriding an existing file if it's already there.

00:14:25.040 --> 00:14:27.980
I don't know how it knows how far back to go.

00:14:28.560 --> 00:14:32.260
Maybe from like a major version bump or something like that.

00:14:32.260 --> 00:14:35.380
But anyway, give it a try and give us a report.

00:14:35.380 --> 00:14:37.180
We'll find out if it's actually useful for you.

00:14:37.180 --> 00:14:37.700
All right.

00:14:37.700 --> 00:14:39.360
Well, that's it for commit is in.

00:14:39.360 --> 00:14:41.180
It seems like a cool little shortcut.

00:14:41.180 --> 00:14:46.160
I don't know if I'll use it or not because I don't work in large teams that really need this very much.

00:14:46.160 --> 00:14:47.820
So it's just like one more thing.

00:14:47.820 --> 00:14:49.520
But if I did, it would be cool.

00:14:49.780 --> 00:14:52.140
Next up, I've got around PyCon.

00:14:52.140 --> 00:14:55.680
Weren't we supposed to meet at PyCon in Pittsburgh and share a beer, the three of us?

00:14:55.680 --> 00:14:57.120
And like, no?

00:14:57.120 --> 00:14:57.980
Didn't happen?

00:14:57.980 --> 00:14:58.820
It didn't happen.

00:14:58.820 --> 00:15:00.380
It was touch and go as well.

00:15:00.380 --> 00:15:05.220
Like I remember even a few weeks before whether or not it was going to happen.

00:15:05.220 --> 00:15:07.900
I mean, I think cancelling, it was definitely the right decision.

00:15:07.900 --> 00:15:09.640
Oh, and it wasn't really cancelled.

00:15:09.800 --> 00:15:20.420
I mean, it was moved online and that's what I wanted to talk about was, you know, with all the PyCons happening all around the world, like I've been looking at which ones have made the move to go online.

00:15:20.420 --> 00:15:23.720
I mean, there's, I guess there's like pros and cons to this.

00:15:23.720 --> 00:15:31.840
I know some people miss out on meeting people and chatting to people and the hallway track and like, you're never going to replace that with an online conference.

00:15:31.840 --> 00:15:37.940
And I think set your expectations low when it comes to interaction with other people.

00:15:38.300 --> 00:15:45.020
But the one big upside is that I think it makes the talks more accessible.

00:15:45.020 --> 00:15:56.320
So if I go to a big PyCon, I'd probably say I watch maybe like 10 talks over the PyCon and there's probably like 100 that I could have watched if I just sat in the talk rooms.

00:15:56.320 --> 00:15:59.540
But like, that's not half the reason I'm there is not to watch the talks.

00:15:59.540 --> 00:16:00.940
Like I watch a lot of them afterwards.

00:16:00.940 --> 00:16:06.280
So I think what's been happening is quite a few PyCons have just cancelled altogether.

00:16:06.640 --> 00:16:22.680
PyCon Israel, Odessa and Ukraine, EuroCyPi, Brazil, PyCon UK, PyCon Thailand, PyCon Spain, DragonPy, which is Slovenia, PyLatam, PyCon DE, which is Germany, and PyCon CZ, which I assume is the Czech Republic.

00:16:22.680 --> 00:16:25.060
They've all been cancelled altogether.

00:16:26.040 --> 00:16:29.220
And then a number of PyCon conferences have said we're going to go online.

00:16:29.220 --> 00:16:34.060
And the cool thing about these is that anywhere in the world, you can go and watch the talks.

00:16:34.660 --> 00:16:53.940
And I think something that's kind of happened as part of this is that some of the big PyCons like US and like Europe, they had like video crews to film the talks and like, you know, write all the subtitles and figure out how all the AV to get the sound nice and stuff like that.

00:16:54.280 --> 00:16:58.240
But other than the really big conferences, the smaller ones couldn't really figure that out.

00:16:58.240 --> 00:17:03.260
So some of them had the talks online, but like the quality was really not watchable.

00:17:03.260 --> 00:17:12.120
But a big change with moving all the talks online is that people are recording at home in lockdown and the quality tends to be a lot better.

00:17:12.120 --> 00:17:15.180
Like you can hear what they're saying and the audio is better.

00:17:15.180 --> 00:17:21.500
And so there's more focus on getting the online experience better.

00:17:21.500 --> 00:17:35.480
And as an added bonus, just as a Python enthusiast even or a PyCon enthusiast, you can just sit and watch PyCon talks from all over the world in your slippers or in your boots if you're in Australia.

00:17:36.780 --> 00:17:37.680
And it's great.

00:17:37.680 --> 00:17:51.380
Like I, you know, beam it onto the TV using Google Chromecast and you can just sit in your living room and watch like PyCon talks from us watching some from Japan, some from like the some of the US conferences, some of the European conferences.

00:17:51.380 --> 00:18:00.360
And there's some really good talks that would have made great talks, you know, the bigger conferences that are in the smaller regional ones that are in there.

00:18:00.360 --> 00:18:06.200
So some of the ones that I found which are online, like on US, obviously, the Python web conference.

00:18:06.200 --> 00:18:14.840
FlaskCon SciPy and PyHEP, which is high energy physics, I think, will be online.

00:18:14.840 --> 00:18:16.200
Europython will be online.

00:18:16.200 --> 00:18:20.660
PyCon Japan, they released a whole bunch of talks this week.

00:18:20.660 --> 00:18:22.340
PyCon AU will be online.

00:18:22.340 --> 00:18:24.820
And I've submitted a talk for that.

00:18:24.820 --> 00:18:25.440
Fingers crossed.

00:18:25.440 --> 00:18:27.360
PyCon Bolivia will be online.

00:18:27.360 --> 00:18:30.420
PyCon ZE, which is South Africa, will be online.

00:18:30.420 --> 00:18:32.900
PyCon APAC in Malaysia will be online.

00:18:33.400 --> 00:18:39.500
Hong Kong PyBay, which is in the US and California and PyCon Africa will all be online.

00:18:39.500 --> 00:18:45.800
So there's at least, from what I could find, at least 15 PyCons around the world.

00:18:45.800 --> 00:18:48.080
So let's say each one has like 50 talks.

00:18:48.080 --> 00:18:49.880
That's like a lot of talks.

00:18:49.880 --> 00:18:51.700
That is a ton of talks.

00:18:51.700 --> 00:18:56.040
And you can just drop into some of these places that you might have a really hard time visiting.

00:18:56.040 --> 00:19:02.660
Like, you know, maybe Malaysia is far away or Africa is far away, but you would love to experience what the community is like there.

00:19:02.660 --> 00:19:03.960
Yeah, a lot of great stuff.

00:19:03.960 --> 00:19:08.940
There are actually a few PyCons that, from what I can tell, are happening in person.

00:19:08.940 --> 00:19:14.160
Around the world, I guess the lockdown situation is very different depending on the country.

00:19:14.580 --> 00:19:21.300
So PyCon Taiwan, PyCon Italia and PyCon Russia, from what I can tell, are still happening.

00:19:21.300 --> 00:19:24.480
So yeah, I know the situation in Taiwan is much better.

00:19:24.480 --> 00:19:27.400
Italy, I think, is late in the year.

00:19:27.400 --> 00:19:29.860
So they're probably hoping that that's going to calm down.

00:19:29.860 --> 00:19:31.940
And Russia, I don't know what's going on there.

00:19:31.940 --> 00:19:36.160
But I picked out a few talks as well that I really liked from some of the regional conferences.

00:19:36.160 --> 00:19:40.840
Deceptive Security Using Python by Kajendra Deshpande.

00:19:40.840 --> 00:19:45.300
If Statements Are a Code Smell by Ali from Chippy.

00:19:45.300 --> 00:19:47.500
That was the PyCon US talk.

00:19:47.500 --> 00:19:50.440
Stop Using Mox by Harry Percival.

00:19:50.440 --> 00:19:51.420
That's a great talk.

00:19:51.420 --> 00:19:54.640
This one is in Japanese and there are no subtitles.

00:19:54.640 --> 00:20:01.720
But if you speak Japanese, Network Analysis and Text PEP in Analysis, which is like an analysis of all the PEPs.

00:20:01.720 --> 00:20:03.380
By Tomoko Faruqi.

00:20:03.380 --> 00:20:07.640
Using Python to Detect Vulnerabilities and Binaries by Terry Oda.

00:20:07.640 --> 00:20:08.420
That was a good talk.

00:20:08.420 --> 00:20:17.580
And Optimize Python and Django with Postgres Superpowers by Louise Graniank, which was a PyCon US talk.

00:20:17.580 --> 00:20:22.320
So yeah, I made a little playlist of stuff that I really enjoyed from some of the regional conferences.

00:20:22.320 --> 00:20:24.480
And the links will be in the show notes.

00:20:24.480 --> 00:20:25.420
These are all great.

00:20:25.420 --> 00:20:26.380
Yeah, love it.

00:20:26.380 --> 00:20:31.700
And you talked about the smaller conferences not necessarily having the AV setup.

00:20:31.700 --> 00:20:33.280
put things online properly.

00:20:33.280 --> 00:20:38.540
You know, all these talks that went online, they were made digitally native, right?

00:20:38.540 --> 00:20:40.880
They were made first for this experience, right?

00:20:40.880 --> 00:20:45.040
They weren't like, oh, there's a camera way back there and we'll just zoom in and we'll try to show it, right?

00:20:45.040 --> 00:20:46.460
It was like yours.

00:20:46.460 --> 00:20:47.640
You had sort of an introduction.

00:20:47.640 --> 00:20:49.720
It was like the video we got here.

00:20:49.720 --> 00:20:51.540
You came back and talking.

00:20:51.720 --> 00:20:54.740
Then it would just focus in on the screen and whatnot.

00:20:54.740 --> 00:20:56.000
So a little bit different there.

00:20:56.000 --> 00:20:56.580
Yeah, definitely.

00:20:56.580 --> 00:21:00.520
And you should definitely watch Brian's talk from PyCon US.

00:21:00.520 --> 00:21:01.560
I did watch your talk, Brian.

00:21:01.560 --> 00:21:07.980
And you should watch mine as well if you're interested, which is on the wise Python slow and Brian's was on parameter.

00:21:07.980 --> 00:21:09.320
It was on testing, wasn't it, Brian?

00:21:09.320 --> 00:21:10.380
Parameterized testing.

00:21:10.380 --> 00:21:10.980
Yeah.

00:21:10.980 --> 00:21:12.500
Parameterized testing.

00:21:13.160 --> 00:21:17.880
I was surprised to hear my name mentioned in Harry's talk, which is surprising.

00:21:17.880 --> 00:21:18.720
Oh, yeah.

00:21:18.720 --> 00:21:20.500
That's cool.

00:21:20.500 --> 00:21:21.720
Yeah, very nice.

00:21:21.720 --> 00:21:24.660
And it's, you know, it's a bummer to not go to these conferences.

00:21:24.660 --> 00:21:31.460
But at the same time, there are a bunch of people who now can experience those presentations who otherwise wouldn't have been able to.

00:21:31.460 --> 00:21:32.780
Yeah, this is a huge benefit.

00:21:32.780 --> 00:21:42.360
And I'm really excited to see, like you said, there's conferences that either had bad video or just couldn't afford a great AV crew or didn't.

00:21:42.520 --> 00:21:45.820
And some of the conferences will just do, like, the entire day video.

00:21:45.820 --> 00:21:47.620
And you have to pick it out.

00:21:47.620 --> 00:21:48.200
And that's more difficult.

00:21:48.200 --> 00:21:50.160
I'm four hours and 17 minutes into it.

00:21:50.160 --> 00:21:50.860
Like, oh, okay.

00:21:50.860 --> 00:21:51.380
Yeah.

00:21:51.380 --> 00:21:52.220
That's discoverable.

00:21:52.220 --> 00:21:55.600
I'm really excited to be able to see all these videos from all over.

00:21:55.600 --> 00:21:57.100
Although I won't be able to.

00:21:57.100 --> 00:21:58.200
I only speak English.

00:21:58.200 --> 00:22:01.000
So how many languages do you speak, Anthony?

00:22:01.000 --> 00:22:01.520
Oh, me?

00:22:01.520 --> 00:22:03.480
Oh, I'm learning Japanese.

00:22:03.480 --> 00:22:08.820
So I was watching the PyCon JP talk and catching every 10th word.

00:22:08.820 --> 00:22:09.680
Okay.

00:22:09.680 --> 00:22:11.920
And the slides definitely help.

00:22:12.120 --> 00:22:13.860
And I speak Pigeon French as well.

00:22:13.860 --> 00:22:14.180
Okay.

00:22:14.180 --> 00:22:16.940
I was impressed that you were watching the Japanese videos.

00:22:16.940 --> 00:22:21.820
That's how I discovered this, your Python testing with pytest book in Japanese.

00:22:21.820 --> 00:22:24.940
It was like part of the, it was on the slide.

00:22:24.940 --> 00:22:28.560
And I was like, it just said lots of stuff on the cover in Japanese.

00:22:28.560 --> 00:22:29.940
And then you just saw the word Brian Okken.

00:22:29.940 --> 00:22:31.200
And I was like, oh, I know that guy.

00:22:32.200 --> 00:22:32.560
Yeah.

00:22:32.560 --> 00:22:37.740
I got to try to get somebody that travels to Japan when things open up to pick up a copy

00:22:37.740 --> 00:22:38.180
for me.

00:22:38.180 --> 00:22:38.680
Yeah, definitely.

00:22:38.680 --> 00:22:39.780
Yeah, that's cool.

00:22:39.780 --> 00:22:40.500
Also cool.

00:22:40.500 --> 00:22:42.500
Speaking of your book, people want to support the show.

00:22:42.500 --> 00:22:43.320
They could get your book.

00:22:43.320 --> 00:22:44.360
Yeah, that'd be great.

00:22:44.480 --> 00:22:45.840
I wanted to do something special.

00:22:46.220 --> 00:22:50.640
I was looking at the reviews online on Amazon, but I know there's reviews other places,

00:22:50.640 --> 00:22:51.980
but this was really kind of cool.

00:22:51.980 --> 00:22:55.360
I'm going to do an expert excerpt from Patrick Kennedy's review.

00:22:55.760 --> 00:23:00.540
This book provides a gentle introduction to what the pytest framework is, how to use it,

00:23:00.540 --> 00:23:03.140
and how to develop tests using pytest.

00:23:03.140 --> 00:23:08.700
I had never understood what fixtures in pytest were prior to this book, but now they make complete

00:23:08.700 --> 00:23:09.300
sense to me.

00:23:09.300 --> 00:23:13.640
Excellent book, and I highly recommend it to anyone wanting to learn about pytest.

00:23:13.640 --> 00:23:15.120
So thanks, Patrick.

00:23:15.120 --> 00:23:15.940
That's a cool review.

00:23:15.940 --> 00:23:18.100
And I went and looked at the numbers.

00:23:18.100 --> 00:23:22.060
There's thousands of people that have read the book, and I know many of the listeners have.

00:23:22.060 --> 00:23:23.940
So I would love to hear more reviews.

00:23:23.940 --> 00:23:28.140
So if you have a review somewhere, either on Amazon or Goodreads or somewhere else,

00:23:28.140 --> 00:23:31.580
let me know where the review is, and I'd love to hear what you think.

00:23:31.580 --> 00:23:32.400
That'd be cool.

00:23:32.400 --> 00:23:32.660
Awesome.

00:23:32.660 --> 00:23:36.300
I think the timing for this will still work out, barely.

00:23:36.300 --> 00:23:40.260
Some of our courses are offered in the Humble Bundle right now.

00:23:40.260 --> 00:23:43.080
So there's a special Python Humble Bundle going on.

00:23:43.080 --> 00:23:46.780
This episode will be out in a week, so it should be wrapping up, but it should still be going

00:23:46.780 --> 00:23:48.180
if you listened soon enough.

00:23:48.180 --> 00:23:50.660
I think it ends July 22nd.

00:23:50.660 --> 00:23:56.840
So before then, if you want to get a whole bunch of Python goodies, including three courses

00:23:56.840 --> 00:23:58.520
from Talk Python, go there and check it out.

00:23:58.520 --> 00:24:01.360
And of course, check out all of our courses as well.

00:24:01.360 --> 00:24:03.640
You get a lot for your value, even without the bundle.

00:24:03.640 --> 00:24:04.680
Yeah, for sure.

00:24:04.680 --> 00:24:05.600
Thanks.

00:24:05.600 --> 00:24:06.660
You know what?

00:24:07.000 --> 00:24:12.940
What happens if you try to zip stuff together as an iter tool zip, and they don't match?

00:24:12.940 --> 00:24:14.740
Does the zipper stick at the end?

00:24:14.740 --> 00:24:16.700
Does it go all the way to the end and then come off?

00:24:16.700 --> 00:24:20.320
Is it when your sleeping bag comes apart in the middle and you're like, I'm going to be

00:24:20.320 --> 00:24:21.040
really cold tonight.

00:24:21.040 --> 00:24:21.860
I can't fix this.

00:24:21.860 --> 00:24:22.720
What happens?

00:24:22.720 --> 00:24:24.900
Whatever doesn't fit just gets cut off.

00:24:24.900 --> 00:24:26.460
Brutal.

00:24:28.060 --> 00:24:30.600
Yeah, so I wanted to highlight PEP 618.

00:24:30.600 --> 00:24:33.780
So I have actually run into this a lot.

00:24:33.780 --> 00:24:37.120
So in the normal circumstances, so zip's a cool thing.

00:24:37.120 --> 00:24:42.620
I'm sure everybody's used it, but if you haven't used it before, it just takes two iterables

00:24:42.620 --> 00:24:43.900
or more than one.

00:24:43.900 --> 00:24:48.100
It's often two in my case, but you can do more than two iterables.

00:24:48.240 --> 00:24:53.560
And then makes a new iterable with pairwise tuples of whatever's in there.

00:24:53.560 --> 00:24:59.220
So if you've got a list with 1, 2, 3, and A, B, C in another list, you can zip them up

00:24:59.220 --> 00:25:05.020
and your elements of your new list will be 1A, 2B, 3C, that sort of thing.

00:25:05.020 --> 00:25:10.280
So often they're used where you just kind of know that all the lengths are supposed to be

00:25:10.280 --> 00:25:13.480
the same because if they're not the same, it chops them off.

00:25:13.480 --> 00:25:17.660
You get a list of the shortest common list.

00:25:17.660 --> 00:25:21.520
And that's surprising and sometimes.

00:25:21.520 --> 00:25:25.320
It might be okay, but it's probably indicative of bad data.

00:25:25.320 --> 00:25:30.520
And who knows if it's off by the end or off by the beginning or they shouldn't go together.

00:25:30.520 --> 00:25:31.820
It's not a good sign.

00:25:31.820 --> 00:25:36.840
When I'm using it and it's kind of a mission critical sort of thing, I'm definitely checking

00:25:36.840 --> 00:25:37.760
the lengths first.

00:25:37.760 --> 00:25:39.360
And it annoys me that I have to.

00:25:39.540 --> 00:25:45.160
So the change is in PEP 618, it's not, you know, it has been accepted for 310.

00:25:45.160 --> 00:25:47.560
So it will go into Python 310.

00:25:47.560 --> 00:25:50.620
And the change is really, there's a new keyword.

00:25:50.620 --> 00:25:53.560
So in zip, you can add strict equals true.

00:25:53.560 --> 00:25:59.040
And that will, if the links are not the same, it'll raise a value error.

00:25:59.040 --> 00:26:02.560
So you'll get an exception if the links are not the same.

00:26:02.560 --> 00:26:05.620
So you can just instead, I think it's a good thing.

00:26:05.620 --> 00:26:07.540
It'll simplify a lot of my code.

00:26:07.540 --> 00:26:07.760
Yeah.

00:26:07.760 --> 00:26:08.460
Anthony, what do you think?

00:26:08.460 --> 00:26:09.560
I never use zip.

00:26:09.560 --> 00:26:14.260
I only use it in the answer to a stack overflow question where that's the solution.

00:26:14.260 --> 00:26:16.000
And I copy and paste it into my code.

00:26:16.000 --> 00:26:18.760
Normally about like, how do I merge two dictionaries?

00:26:18.760 --> 00:26:24.000
I think that's like, and it's like, oh, you just do star, star, list, star, star, zip, star,

00:26:24.000 --> 00:26:24.920
star, something.

00:26:24.920 --> 00:26:28.120
And you're like, okay, I don't understand how that works.

00:26:28.120 --> 00:26:30.200
You're like, star, star, maybe more explicit.

00:26:30.200 --> 00:26:33.920
So let's just stick it in and see if it works.

00:26:33.920 --> 00:26:35.020
Yeah, I never use zip.

00:26:35.020 --> 00:26:36.340
So that sounds useful.

00:26:36.340 --> 00:26:44.920
I did stumble across 3.9 has a, some new functions on the strings, remove suffix and remove prefix.

00:26:44.920 --> 00:26:45.320
Yes.

00:26:45.320 --> 00:26:46.360
Yeah.

00:26:46.360 --> 00:26:49.000
So we talked about that last time, which I don't think we've released.

00:26:49.000 --> 00:26:49.720
So you wouldn't know.

00:26:50.720 --> 00:26:55.800
But it's so confusing because string dot, like if you have the word first, the number one,

00:26:55.800 --> 00:27:00.460
then ST and you said strip ST, it's not necessarily taking away the ST.

00:27:00.460 --> 00:27:04.260
It will, but it might also take an S or a T off the front as well.

00:27:04.260 --> 00:27:05.000
Right.

00:27:05.120 --> 00:27:10.820
It's take away all the characters that are in this list, no matter what, not this exact

00:27:10.820 --> 00:27:11.680
substring.

00:27:11.680 --> 00:27:11.980
Right.

00:27:11.980 --> 00:27:13.640
And so, yeah, that's super valuable.

00:27:13.640 --> 00:27:16.100
I'm really excited to have that because it should have been there before.

00:27:16.100 --> 00:27:19.440
I think they should have come up with a more fun exception than a value error.

00:27:19.440 --> 00:27:24.720
Like it could derive from value error, but it should be like, you know, the zipper broke

00:27:24.720 --> 00:27:29.320
exception error or like, come on, opportunity missed.

00:27:29.600 --> 00:27:29.820
All right.

00:27:29.820 --> 00:27:31.460
Let's stick with the standard library.

00:27:31.460 --> 00:27:33.380
This was really interesting to me.

00:27:33.380 --> 00:27:36.320
I've had Paul Gensel on Talk Python recently.

00:27:36.320 --> 00:27:37.980
I don't know if you guys have listened to it.

00:27:37.980 --> 00:27:41.820
So I might not be able to ask you the question with you actually knowing.

00:27:41.820 --> 00:27:46.120
But this always frustrated me when I go to a time delta.

00:27:46.120 --> 00:27:50.120
I do some math, like subtracting one daytime from another.

00:27:50.120 --> 00:27:51.380
I get it back.

00:27:51.380 --> 00:27:52.060
I'm like, cool.

00:27:52.060 --> 00:27:54.140
It has a certain number of seconds.

00:27:54.140 --> 00:27:57.920
It also has days and other things on it as well.

00:27:57.920 --> 00:27:59.200
But those aren't like total days.

00:27:59.280 --> 00:28:01.120
It's not like 7.2 days.

00:28:01.120 --> 00:28:05.800
It's like eight days and then some negative seconds or something weird, right?

00:28:05.800 --> 00:28:08.000
Really weird, like negative and positive time.

00:28:08.000 --> 00:28:10.560
So those are more for like internal computation.

00:28:10.560 --> 00:28:12.800
As far as I can tell, they probably should be hidden.

00:28:12.800 --> 00:28:17.340
But anyway, if I want to know, say, how many hours has it been?

00:28:17.340 --> 00:28:18.460
How do I do that?

00:28:18.460 --> 00:28:20.680
I would go dt.totalseconds.

00:28:20.680 --> 00:28:22.380
Okay, well, there's 60 seconds.

00:28:22.380 --> 00:28:23.320
So I divide by 60.

00:28:23.320 --> 00:28:24.620
And I want to know, that's minutes.

00:28:24.620 --> 00:28:25.420
I want to know hours.

00:28:25.420 --> 00:28:26.900
So I divide by 60 again.

00:28:26.900 --> 00:28:28.020
And I never put it together.

00:28:28.160 --> 00:28:29.520
I don't divide by like 3,600.

00:28:29.520 --> 00:28:31.500
I divide by 60 and then divide by 60.

00:28:31.500 --> 00:28:35.760
So it's clear I'm trying to take away the, you know, get to minutes and then to hours.

00:28:35.760 --> 00:28:38.160
Is there a better way, right?

00:28:38.160 --> 00:28:43.700
Why is there not a total hours, a total weeks, a total months, whatever on there?

00:28:43.700 --> 00:28:46.780
Like, why do I have to always do math whenever I want to know simple things?

00:28:46.780 --> 00:28:48.100
Like how many hours have passed?

00:28:48.100 --> 00:28:48.460
Okay.

00:28:48.460 --> 00:28:49.080
Well, okay.

00:28:49.080 --> 00:28:53.440
So the people who built daytime, or sorry, time delta specifically, they didn't intend you

00:28:53.440 --> 00:28:54.080
to do math.

00:28:54.080 --> 00:28:57.600
They just didn't make it obvious or very discoverable.

00:28:58.120 --> 00:29:00.980
Because time deltas can be divided by time deltas.

00:29:00.980 --> 00:29:05.760
So if I want to know how many hours it's been, I can say like, take the total time delta and

00:29:05.760 --> 00:29:08.040
divide it by time delta where hours equals one.

00:29:08.040 --> 00:29:11.800
Or if I want blocks of six hours, I could divide it by hours equals six.

00:29:11.800 --> 00:29:17.200
If I want to know how many weeks, I would take the total time delta and divide it by time delta

00:29:17.200 --> 00:29:18.360
days equals seven.

00:29:18.360 --> 00:29:19.440
And that'll tell me how many weeks.

00:29:19.780 --> 00:29:20.760
That's pretty awesome.

00:29:20.760 --> 00:29:22.360
I had no idea that it did that.

00:29:22.360 --> 00:29:23.740
I had no idea either.

00:29:23.740 --> 00:29:26.400
And I was complaining to Paul Gansel, who works on this stuff.

00:29:26.400 --> 00:29:28.800
Like, dude, give us something more than seconds.

00:29:28.800 --> 00:29:30.480
Why are we only getting seconds?

00:29:30.480 --> 00:29:31.840
I want total hours.

00:29:31.840 --> 00:29:32.580
I want total days.

00:29:32.580 --> 00:29:33.720
He's like, just divide it.

00:29:33.720 --> 00:29:35.580
Just set the days to be one and divide it.

00:29:35.580 --> 00:29:36.080
I'm like, what?

00:29:36.080 --> 00:29:37.280
You couldn't do that?

00:29:37.280 --> 00:29:39.240
Why didn't anybody tell anybody this?

00:29:39.240 --> 00:29:41.260
Anthony, did you know this?

00:29:41.260 --> 00:29:42.500
No, but this is a podcast.

00:29:42.500 --> 00:29:45.360
So you probably can see I had my head in my hands for that explanation.

00:29:45.360 --> 00:29:48.420
But division operator would be like,

00:29:48.720 --> 00:29:50.400
with the last thing I'd ever try.

00:29:50.400 --> 00:29:50.980
I know.

00:29:50.980 --> 00:29:51.940
Yeah, me too.

00:29:51.940 --> 00:29:55.320
I really thought I'm just like, this is the official.

00:29:55.320 --> 00:29:56.540
This is really the way.

00:29:56.540 --> 00:29:56.840
Yeah.

00:29:56.840 --> 00:29:58.440
I mean, yeah, this is the way.

00:29:58.440 --> 00:30:04.300
But after this episode came out, Jeff went to, I don't know his last name, but on the comment,

00:30:04.300 --> 00:30:05.180
he said his name was Jeff.

00:30:05.180 --> 00:30:09.680
So Jeff went to the episode page and said, learning you can divide a time delta by time delta to

00:30:09.680 --> 00:30:12.200
come up with days, weeks, et cetera, is like the Python tip of the year.

00:30:12.200 --> 00:30:18.060
It's certainly going to save me a lot of pain going, wait, there's two 60s.

00:30:18.060 --> 00:30:19.080
I divide by 60 twice.

00:30:19.080 --> 00:30:26.280
Sorry, that was actually hours, not days or whatever, like weird 60th of what I wanted

00:30:26.280 --> 00:30:28.920
or 60 times as many days as I meant.

00:30:28.920 --> 00:30:35.580
So yeah, you could divide a time delta by some arbitrary time delta, like days equal five,

00:30:35.580 --> 00:30:39.200
and you'll get how many blocks of five days would have been in there as a number.

00:30:39.700 --> 00:30:44.520
I'm not saying this is how it should be, but I'm telling you, this is the way to figure

00:30:44.520 --> 00:30:49.960
out time ranges in Python standard library without doing math.

00:30:49.960 --> 00:30:51.200
Well, so I looked it up.

00:30:51.200 --> 00:30:56.500
There's, it isn't obvious that, I mean, it does say that you can do division, but there's

00:30:56.500 --> 00:30:57.700
all sorts of other stuff too.

00:30:57.800 --> 00:31:01.640
You can do like, you can do floor division, you can do modulo.

00:31:01.640 --> 00:31:03.340
Modulo?

00:31:03.340 --> 00:31:04.180
How interesting.

00:31:04.180 --> 00:31:05.720
I mean, it makes sense, I guess, but wow.

00:31:05.720 --> 00:31:06.520
And multiplication.

00:31:06.520 --> 00:31:08.640
Modulo by seven days.

00:31:08.640 --> 00:31:09.020
Yeah.

00:31:09.020 --> 00:31:12.400
It's like crazy.

00:31:12.540 --> 00:31:15.880
I had no idea all this math was available for time deltas.

00:31:15.880 --> 00:31:18.060
Can you use the matrix multiplication operator?

00:31:18.060 --> 00:31:20.600
I wouldn't do that.

00:31:20.600 --> 00:31:21.840
It'll shoot you into the future.

00:31:21.840 --> 00:31:23.860
Oh, wait, Anthony's already in the future.

00:31:23.860 --> 00:31:24.360
I don't know.

00:31:24.360 --> 00:31:24.980
It's worth trying.

00:31:24.980 --> 00:31:27.600
Is it like at star or something?

00:31:27.600 --> 00:31:28.640
Yeah, yeah, yeah.

00:31:28.640 --> 00:31:29.840
Power operator.

00:31:29.840 --> 00:31:30.460
Yeah, yeah.

00:31:30.460 --> 00:31:35.220
Anyway, I thought probably if I was as surprised about this and the other listeners were as well,

00:31:35.220 --> 00:31:38.620
and it sounds like you guys also didn't know about this, like we should at least mention,

00:31:38.620 --> 00:31:40.260
apparently this is a thing.

00:31:40.260 --> 00:31:41.480
Total tip of the year.

00:31:41.480 --> 00:31:41.940
Yeah.

00:31:42.060 --> 00:31:43.300
Yeah, well, totally.

00:31:43.300 --> 00:31:47.320
If you want to make a really tricky job interview, please don't do it.

00:31:47.320 --> 00:31:51.600
Yeah, I remember my kids recently asked me, because we were talking about like weeks and

00:31:51.600 --> 00:31:55.560
these numbers came up and they were like, why do you know how many seconds are in a week

00:31:55.560 --> 00:31:57.280
and how many seconds are in a day?

00:31:57.280 --> 00:31:59.960
Because I took math.

00:31:59.960 --> 00:32:04.800
I'm like, because I've memorized those numbers because I've been programming in languages that

00:32:04.800 --> 00:32:08.140
make you memorize how many seconds are in a week.

00:32:08.140 --> 00:32:09.660
It's because there's not a total hours.

00:32:09.660 --> 00:32:10.960
There's only a total seconds.

00:32:11.040 --> 00:32:12.600
I need to know how many hours this is.

00:32:12.600 --> 00:32:13.520
Exactly.

00:32:13.520 --> 00:32:14.720
Exactly.

00:32:14.720 --> 00:32:15.580
So here you go.

00:32:15.580 --> 00:32:16.260
Here you go.

00:32:16.260 --> 00:32:17.000
Pretty cool.

00:32:17.000 --> 00:32:20.960
So Anthony, are you a fan of Multipython?

00:32:20.960 --> 00:32:21.820
Multipython?

00:32:21.820 --> 00:32:22.380
Yes.

00:32:22.380 --> 00:32:22.820
Yeah.

00:32:22.960 --> 00:32:24.940
So apparently Microsoft is as well.

00:32:24.940 --> 00:32:25.500
Yeah.

00:32:25.500 --> 00:32:29.000
It took me a while to figure out the connection, but it was in the release notes.

00:32:29.000 --> 00:32:34.680
So they've released a new extension for VS Code and I'll explain why, but it's called PyLance

00:32:34.680 --> 00:32:40.560
and it's named after Lancelot from Monty Python and the Holy Grail, who was Sir Lancelot?

00:32:40.560 --> 00:32:41.100
It was, isn't it?

00:32:41.440 --> 00:32:41.620
Yeah.

00:32:41.620 --> 00:32:45.200
He was the first one to get across the bridge with the hard questions.

00:32:45.200 --> 00:32:50.440
So yeah, this is an extension for VS Code.

00:32:50.440 --> 00:32:53.640
So if you're already using VS Code, you should download this and check it out.

00:32:53.840 --> 00:32:57.580
It's designed to be used with the existing Python extensions.

00:32:57.580 --> 00:33:00.580
It's not a replacement for the Python extension for VS Code.

00:33:00.580 --> 00:33:06.920
And I think something about the Python extension is that if you're doing type checking, you're

00:33:06.920 --> 00:33:09.820
like type hints and stuff like that, or you're using a linter.

00:33:10.200 --> 00:33:16.840
If you use the Python extension, you can turn on a linter and it will use one of the Python

00:33:16.840 --> 00:33:23.060
linters from the extension by spawning like a process every time you edit the code and running

00:33:23.060 --> 00:33:23.740
the linter again.

00:33:23.740 --> 00:33:30.760
There's also something called the Python language server, which is written in .NET for some reason.

00:33:30.760 --> 00:33:36.960
And that is then communicated with by the VS Code to figure out like the Python code and

00:33:36.960 --> 00:33:38.900
look at the AST and stuff.

00:33:39.020 --> 00:33:43.120
And that gives some errors and code like highlights when you make mistakes in Python.

00:33:43.120 --> 00:33:51.940
So this PyLance is an extension that basically provides type hints and then does a whole bunch

00:33:51.940 --> 00:33:55.280
of like extra little features like doc string automation.

00:33:55.280 --> 00:33:57.140
It helps you on function signatures.

00:33:57.140 --> 00:33:59.700
It does like type heads.

00:33:59.700 --> 00:34:05.800
You can hover over a function call and it'll tell you the method signature and it'll extract

00:34:05.800 --> 00:34:08.100
that from the library that you're using.

00:34:08.100 --> 00:34:13.120
So if you're using VS Code, absolutely recommend that you download this and check it out.

00:34:13.120 --> 00:34:15.060
There's some cool features that I found.

00:34:15.060 --> 00:34:17.280
Like it does like code completion.

00:34:17.280 --> 00:34:19.060
It suggests parameters for you.

00:34:19.060 --> 00:34:24.960
So if you're like using a lot of libraries like Flask or Django or, you know, any kind of

00:34:24.960 --> 00:34:30.820
popular framework that's got type stubs, then this will basically make your life a lot easier

00:34:30.820 --> 00:34:33.840
because it's going to kind of fill in the gaps for you.

00:34:33.840 --> 00:34:38.220
And as you're typing, you can just press tab and just keep doing auto completion.

00:34:38.220 --> 00:34:40.600
It supports auto imports as well.

00:34:40.600 --> 00:34:46.720
So if you started using a function from a namespace in the standard library or from somewhere else,

00:34:46.720 --> 00:34:48.900
it'll be like, oh, you probably want to import that.

00:34:48.900 --> 00:34:50.580
It will add the import statement for you.

00:34:50.760 --> 00:35:00.300
It's also got go to reference and go to implementation, which if you've used the VS Code extensions in other languages like JavaScript or TypeScript,

00:35:00.300 --> 00:35:09.240
or you can right click on a function and go to go to reference or go to implementation and it will jump to where that function is actually implemented.

00:35:09.720 --> 00:35:16.240
I know you get that with Python, but this it uses, I don't know how up to date everyone is on type checkers,

00:35:16.240 --> 00:35:21.820
but basically there's mypy, which is now part of the Python GitHub organization.

00:35:21.820 --> 00:35:24.820
And then all the big tech companies have written their own.

00:35:24.820 --> 00:35:28.880
Don't know why, but they, I guess there was like, we have to write our own.

00:35:28.880 --> 00:35:29.900
It's like a rite of passage.

00:35:29.900 --> 00:35:35.880
So Facebook has Pyre, Google has PyType and Microsoft has PyWrite.

00:35:35.880 --> 00:35:39.200
They all more or less do the same thing, but in different ways.

00:35:39.200 --> 00:35:42.540
And this one uses the PyWrite type checker.

00:35:42.540 --> 00:35:46.900
So, but the confusing thing is that PyWrite was already an extension.

00:35:46.900 --> 00:35:50.900
So if you had that installed, uninstall it first, otherwise it causes issues.

00:35:50.900 --> 00:35:53.060
And then install PyLance.

00:35:53.060 --> 00:35:58.220
And a couple of other things I called out in the show notes is that there's non-default settings,

00:35:58.220 --> 00:36:01.100
which you should change to make the plugin a lot more useful.

00:36:01.100 --> 00:36:05.140
So there's diagnostic mode, change that to workspace.

00:36:05.480 --> 00:36:13.020
So they'll inspect all files, not just the ones that you happen to have open and change type checkers off by default.

00:36:13.020 --> 00:36:16.160
Change it to basic and it will give you more information.

00:36:16.160 --> 00:36:19.500
And yeah, I've been using it and playing around and stuff like that.

00:36:19.500 --> 00:36:24.300
I think there's a few bugs I still need to iron out, but this is a new release.

00:36:25.000 --> 00:36:27.960
It's not open source, so you can't contribute it.

00:36:27.960 --> 00:36:30.900
But I don't know if they'll change it in the future.

00:36:30.900 --> 00:36:34.000
And I think it's because they're planning on using it for some commercial product.

00:36:34.000 --> 00:36:35.700
But we'll see what it uses.

00:36:35.700 --> 00:36:37.920
But yeah, you should download it and check it out if you use VS Code.

00:36:37.920 --> 00:36:41.760
Yeah, it looks like it takes the Python extension and just powers it up a little.

00:36:41.760 --> 00:36:42.100
Yeah.

00:36:42.100 --> 00:36:47.280
So I'm guessing you don't, Anthony, you don't run the Vim plugin for VS Code?

00:36:49.020 --> 00:36:50.540
No, no, I don't.

00:36:50.540 --> 00:36:51.080
I use this.

00:36:51.080 --> 00:36:52.380
This is the Microsoft Word one.

00:36:52.380 --> 00:36:52.960
I use this.

00:36:52.960 --> 00:36:54.360
It's called a mouse.

00:36:54.360 --> 00:36:56.860
Oh, that's really interesting.

00:36:56.860 --> 00:36:58.900
Does it live in a cage or how do you keep it?

00:36:58.900 --> 00:37:00.200
Do you have to feed it?

00:37:00.200 --> 00:37:02.280
No, I don't do that.

00:37:02.280 --> 00:37:06.720
I was talking to Julian Sequeira from PyBytes yesterday and he was telling me how much he loves Vim.

00:37:06.720 --> 00:37:09.140
And I said, so you edit on production then?

00:37:09.140 --> 00:37:10.680
And he was like, how did you know?

00:37:13.100 --> 00:37:16.360
Actually, I'm pretty impressed with the Vim plugin for VS Code.

00:37:16.360 --> 00:37:17.560
It's really well done.

00:37:17.560 --> 00:37:18.700
Well, this looks like a cool project.

00:37:18.700 --> 00:37:23.080
And thanks for pointing out the stuff that's off, like the type checking and the diagnostics

00:37:23.080 --> 00:37:26.040
for being just file based instead of workspace based and whatnot.

00:37:26.040 --> 00:37:29.320
Another thing I think this adds is multi-root workspaces.

00:37:29.320 --> 00:37:32.200
So a lot of these things are already in PyCharm, right?

00:37:32.200 --> 00:37:38.760
But I've opened a big directory and I want two little directories to refer within themselves.

00:37:38.760 --> 00:37:42.160
Treat those at the top level for code within each.

00:37:42.160 --> 00:37:44.720
And I don't think that was possible previously, but now it is.

00:37:44.720 --> 00:37:50.720
It also says it's IntelliCode compatible, which I don't know how many people played with IntelliCode.

00:37:50.720 --> 00:37:55.180
I really haven't very much because I mostly stick with PyCharm, even though I had VS Code open

00:37:55.180 --> 00:37:55.820
while we were talking.

00:37:55.820 --> 00:38:00.100
It uses AI to predict what you're going to type and need.

00:38:00.100 --> 00:38:03.740
So instead of just showing an alphabetical list, it'll say, oh, you're doing request dot,

00:38:03.740 --> 00:38:05.860
you know, you should probably do get, right?

00:38:05.860 --> 00:38:06.940
We all just do get, don't we?

00:38:06.940 --> 00:38:07.180
Cool.

00:38:07.180 --> 00:38:08.500
You know, things like that.

00:38:08.500 --> 00:38:11.000
So apparently it's compatible with that as well.

00:38:11.220 --> 00:38:15.040
Yeah, I'm not a fan of IntelliCode, but I've used it a lot in JavaScript.

00:38:16.040 --> 00:38:21.160
And it kind of like guesses what the variable or the function is, but it gets it wrong.

00:38:21.160 --> 00:38:24.060
Or at least it did the last time I used it, which is a few years ago.

00:38:24.060 --> 00:38:30.740
But if you like, if one library made a typo or like suggest that, it's like, oh, you wanted

00:38:30.740 --> 00:38:33.260
to do get Getty or something.

00:38:33.260 --> 00:38:33.980
And it's like, oh.

00:38:33.980 --> 00:38:34.700
Yeah, yeah, yeah.

00:38:34.700 --> 00:38:38.400
Because it scans the GitHub repos and then it uses that to predict what it's going to

00:38:38.400 --> 00:38:39.000
suggest for you.

00:38:39.000 --> 00:38:39.160
Yeah.

00:38:39.160 --> 00:38:39.480
Yeah.

00:38:39.480 --> 00:38:44.540
So half the suggestions are normally invalid with a really dynamically typed language like

00:38:44.540 --> 00:38:45.680
Python or JavaScript.

00:38:45.680 --> 00:38:52.320
It's it's it needs to really import everything and properly understand the modules and how

00:38:52.320 --> 00:38:55.300
they're constructed to make sensible suggestions.

00:38:55.580 --> 00:38:58.620
Could this be a theoretical suggestion I could actually make?

00:38:58.620 --> 00:38:59.200
Let's find out.

00:38:59.200 --> 00:38:59.540
Yeah.

00:38:59.540 --> 00:39:05.560
And I think that's what PyLance kind of gives you is that it uses the type into the to figure

00:39:05.560 --> 00:39:05.980
out.

00:39:05.980 --> 00:39:08.100
And this is why PyCharm is so powerful.

00:39:08.100 --> 00:39:11.320
Like it, it has its own typing system.

00:39:11.320 --> 00:39:17.320
So it knows it like indexes all your code indexes all your dependencies, and it figures out like

00:39:17.320 --> 00:39:21.080
what the types of the responses are, even if they don't have type annotations.

00:39:21.080 --> 00:39:27.500
And that's how it knows to what's the suggest, like which functions are available, which properties

00:39:27.500 --> 00:39:28.460
are there and stuff like that.

00:39:28.460 --> 00:39:31.040
So I think this is basically a step towards that.

00:39:31.040 --> 00:39:31.360
Yeah.

00:39:31.360 --> 00:39:32.080
And it's good to see.

00:39:32.080 --> 00:39:33.420
And it will be very powerful.

00:39:33.420 --> 00:39:33.740
Yeah.

00:39:33.740 --> 00:39:34.180
Very cool.

00:39:34.180 --> 00:39:36.000
And it has a Monty Python reference.

00:39:36.000 --> 00:39:36.360
Yeah.

00:39:36.360 --> 00:39:38.060
Well, that's our six.

00:39:38.240 --> 00:39:39.920
Has anybody got any extra news?

00:39:39.920 --> 00:39:41.580
I have some, but I'll let Anthony go first.

00:39:41.580 --> 00:39:42.020
Yeah.

00:39:42.020 --> 00:39:44.640
My book is out in early release.

00:39:44.640 --> 00:39:46.160
So CPython internals.

00:39:46.160 --> 00:39:51.160
And I got an email from somebody called Guido asking if he could-

00:39:51.160 --> 00:39:51.780
Oh, I've heard of that guy.

00:39:51.780 --> 00:39:52.720
I think he does Python.

00:39:52.720 --> 00:39:57.360
I don't even supposed to be sharing this, but he was like, oh, had you read this book?

00:39:57.360 --> 00:39:58.120
Can I have a copy?

00:39:58.120 --> 00:40:02.360
Because I want to like review it and, you know, that sort of thing.

00:40:02.360 --> 00:40:06.880
And I was going to reply as a joke and say, it's quite advanced how much Python experience

00:40:06.880 --> 00:40:07.220
you have.

00:40:07.400 --> 00:40:10.620
I thought, I don't know.

00:40:10.620 --> 00:40:16.640
I know he has a sense of humor, but yeah, my kind of English sense of humor doesn't work

00:40:16.640 --> 00:40:17.160
on everybody.

00:40:17.160 --> 00:40:18.920
So no, he's got it.

00:40:18.920 --> 00:40:20.020
He's reviewing it.

00:40:20.020 --> 00:40:24.760
And he did send back a comment saying he's going to recommend it to people who want to

00:40:24.760 --> 00:40:26.440
become core developers, which is awesome.

00:40:26.440 --> 00:40:27.560
Oh, that's cool.

00:40:27.560 --> 00:40:29.840
And that's kind of why you put it together a little bit, right?

00:40:29.840 --> 00:40:30.280
Yeah.

00:40:30.280 --> 00:40:30.500
Yeah.

00:40:30.500 --> 00:40:31.480
That was definitely the reason.

00:40:31.620 --> 00:40:32.440
What's the name of it again?

00:40:32.440 --> 00:40:33.700
CPython internals.

00:40:33.700 --> 00:40:40.660
And I'm updating it for the peg parser because that got merged like in the middle of the initial

00:40:40.660 --> 00:40:41.000
release.

00:40:41.000 --> 00:40:45.400
So I do have some updates for that.

00:40:45.400 --> 00:40:49.860
So yeah, because a whole bunch of the chapters like show you how the parser works and stuff

00:40:49.860 --> 00:40:50.140
like that.

00:40:50.140 --> 00:40:51.980
So I've been redoing those.

00:40:51.980 --> 00:40:52.260
Yeah.

00:40:52.260 --> 00:40:52.700
Super cool.

00:40:52.700 --> 00:40:55.180
And you were on Talk Python 265.

00:40:55.180 --> 00:40:56.700
So pretty recently back in May.

00:40:56.700 --> 00:40:56.880
Yeah.

00:40:56.880 --> 00:40:58.100
Talk about that as well.

00:40:58.220 --> 00:41:00.080
So people can dig into that as well.

00:41:00.080 --> 00:41:01.000
Brian, how about you?

00:41:01.000 --> 00:41:03.740
Just staying out of trouble and working at a nice fort.

00:41:03.740 --> 00:41:04.620
Yeah.

00:41:04.620 --> 00:41:04.900
Yeah.

00:41:04.900 --> 00:41:05.300
Me too.

00:41:05.300 --> 00:41:07.120
Got to go out and do fireworks with the kids.

00:41:07.120 --> 00:41:07.860
That was fun.

00:41:07.860 --> 00:41:13.260
So for me, I already mentioned the Humble Bundle, but talkpython.fm/humble 2020.

00:41:13.260 --> 00:41:14.480
That's all you got to know.

00:41:14.480 --> 00:41:18.540
$1,400 worth of Python stuff for 25 bucks.

00:41:18.540 --> 00:41:19.880
It's probably worth the risk.

00:41:19.880 --> 00:41:22.400
So there's a way better than the reverse.

00:41:22.400 --> 00:41:24.760
$25 worth of stuff for a thousand.

00:41:24.760 --> 00:41:25.420
It'd be terrible.

00:41:25.420 --> 00:41:27.380
So people will try to sell that, but yeah, for sure.

00:41:27.540 --> 00:41:32.960
Speaking of Python 3.9 peg parsers, Python 3.9 beta 4 is out and ready for testing.

00:41:32.960 --> 00:41:34.980
So if that's a thing that you do.

00:41:34.980 --> 00:41:39.160
Anthony, you probably run in that in production already, given how much you're on top of it.

00:41:39.160 --> 00:41:40.880
No, I'm at 3.10 alpha 1.

00:41:40.880 --> 00:41:42.640
Of course.

00:41:42.640 --> 00:41:43.200
Of course.

00:41:43.200 --> 00:41:48.640
Also, we have a cool course coming at Talk Python training called Excel to Python.

00:41:48.640 --> 00:41:52.860
So if you've been doing a bunch of stuff with Excel and want to get into the data science

00:41:52.860 --> 00:41:57.200
tools instead and do Excel-like things, partner it up with Chris Moffitt.

00:41:57.260 --> 00:41:58.340
We're doing really cool stuff there.

00:41:58.340 --> 00:42:02.240
So people can go get notified about when that course is out, maybe in a month or so.

00:42:02.240 --> 00:42:02.900
All right.

00:42:02.900 --> 00:42:04.580
Are you all ready for a joke?

00:42:04.580 --> 00:42:05.200
Yes.

00:42:05.200 --> 00:42:09.120
Anthony, I usually make Brian play the other half of this.

00:42:09.120 --> 00:42:11.440
So you're going to have to do it.

00:42:11.440 --> 00:42:12.260
All right.

00:42:12.300 --> 00:42:13.440
So this is a cartoon.

00:42:13.440 --> 00:42:15.240
The picture is going to be in the show notes.

00:42:15.240 --> 00:42:19.480
You can even view it in your podcast player if you allow it to show images from Scott Hilburn.

00:42:19.480 --> 00:42:22.160
I couldn't find the original place to link to you.

00:42:22.160 --> 00:42:23.700
So I just put an image up here.

00:42:23.700 --> 00:42:27.240
And it's two computers, a laptop and a desktop looking at each other.

00:42:27.240 --> 00:42:31.200
There's a baseball cap on top of the laptop.

00:42:31.520 --> 00:42:33.780
And he's got little like computer arms up.

00:42:33.780 --> 00:42:34.860
And he's like, sweat.

00:42:34.860 --> 00:42:38.660
He's like, I can't get it off.

00:42:38.660 --> 00:42:40.320
Anthony, what's the problem?

00:42:40.320 --> 00:42:44.160
And the other computer says, dude, that's because your caps lock is on.

00:42:44.600 --> 00:42:46.080
Oh, it's locked on.

00:42:46.080 --> 00:42:47.600
Can't get it off.

00:42:47.600 --> 00:42:48.120
Yeah.

00:42:48.120 --> 00:42:48.940
Okay.

00:42:48.940 --> 00:42:49.380
Anyway.

00:42:49.380 --> 00:42:52.340
So I thought that that one made me laugh, especially the picture.

00:42:52.340 --> 00:42:53.080
So check it out.

00:42:53.080 --> 00:42:53.760
You're a podcast player.

00:42:53.760 --> 00:42:54.220
Yeah.

00:42:54.220 --> 00:42:56.100
I can tell why he's trying to get it off too.

00:42:56.100 --> 00:42:57.000
It looks like a red hat.

00:42:57.000 --> 00:42:57.600
It definitely.

00:42:57.600 --> 00:42:58.160
Yeah.

00:42:58.160 --> 00:42:59.080
Yeah.

00:42:59.080 --> 00:43:00.500
That's probably like Windows Vista.

00:43:00.500 --> 00:43:02.240
I got red hat on it and can't get it off.

00:43:02.240 --> 00:43:04.620
Cool.

00:43:04.620 --> 00:43:05.800
Well, thanks a lot, guys.

00:43:05.800 --> 00:43:06.200
All right.

00:43:06.200 --> 00:43:06.400
Yeah.

00:43:06.400 --> 00:43:06.760
Thanks.

00:43:06.760 --> 00:43:07.400
Great to be here.

00:43:07.400 --> 00:43:07.760
Thanks.

00:43:07.760 --> 00:43:08.840
Thanks as always.

00:43:08.840 --> 00:43:09.260
Bye, everyone.

00:43:09.260 --> 00:43:11.400
Thank you for listening to Python Bytes.

00:43:11.400 --> 00:43:13.840
Follow the show on Twitter at Python Bytes.

00:43:14.080 --> 00:43:16.880
That's Python Bytes as in B-Y-T-E-S.

00:43:16.880 --> 00:43:19.780
And get the full show notes at Python Bytes.fm.

00:43:19.780 --> 00:43:24.840
If you have a news item you want featured, just visit Python Bytes.fm and send it our way.

00:43:24.840 --> 00:43:26.880
We're always on the lookout for sharing something cool.

00:43:26.880 --> 00:43:28.060
This is Brian Okken.

00:43:28.060 --> 00:43:32.140
And on behalf of myself and Michael Kennedy, thank you for listening and sharing this podcast

00:43:32.140 --> 00:43:33.320
with your friends and colleagues.

