
00:00:00.000 --> 00:00:10.720
Hello and welcome to python bites where we deliver python news and headlines directly to your earbuds this is episode one hundred fifty five recorded october thirtieth two thousand nineteen.


00:00:10.720 --> 00:00:18.840
I'm brian and i'm michael kennedy and this episode is brought to you by data dog thanks data dog will hear more about them later absolutely at brian.


00:00:18.840 --> 00:00:24.260
Happy halloween eve over right how we need spooky i big news.


00:00:24.500 --> 00:00:26.500
It's not my big news, but I have big news to announce.


00:00:26.500 --> 00:00:28.100
I'm on pins and needles.


00:00:28.100 --> 00:00:34.740
Guido has retired officially from employment, which, you know, congratulations to him.


00:00:34.740 --> 00:00:35.700
That is awesome.


00:00:35.700 --> 00:00:41.860
The news is Guido van Rossum has left Dropbox, not for another position, but to retire.


00:00:41.860 --> 00:00:43.460
So, you know, I think that's great to hear.


00:00:43.460 --> 00:00:43.780
Okay.


00:00:43.780 --> 00:00:46.100
What does that mean about his involvement in Python?


00:00:46.100 --> 00:00:46.500
Do you know?


00:00:46.500 --> 00:00:48.180
I can only speculate.


00:00:48.180 --> 00:00:52.900
I don't know for sure yet, but my guess is actually that it will mean more Python involvement,


00:00:52.900 --> 00:00:53.540
not less.


00:00:53.540 --> 00:00:53.940
Okay.


00:00:53.940 --> 00:00:59.300
But that's just based on I've been at big companies and even when they say, yeah,


00:00:59.300 --> 00:01:03.380
you can work on whatever you want, there's meetings and there's bureaucracy and,


00:01:03.380 --> 00:01:07.220
you know, the proverbial TPS report, just like, you know what?


00:01:07.220 --> 00:01:09.420
Okay, well, we're doing nothing today.


00:01:09.420 --> 00:01:13.300
And so if he can work on whatever he wants, I have no idea what he's going to work on,


00:01:13.300 --> 00:01:15.540
but there's gotta be some cool creative projects.


00:01:15.540 --> 00:01:17.500
Maybe not next week.


00:01:17.500 --> 00:01:21.380
Maybe he needs a year just to sit on the beach and look at some sunsets, but then


00:01:21.380 --> 00:01:23.500
eventually I bet he will come back, do something.


00:01:23.540 --> 00:01:26.140
Yeah, okay. He deserves a break.


00:01:26.140 --> 00:01:29.940
And you're linking to an article or a post where he announced it also, right?


00:01:29.940 --> 00:01:32.740
Yeah, so there's a link to his announcement


00:01:32.740 --> 00:01:36.740
where he wrote sort of the goodbye and all that.


00:01:36.740 --> 00:01:40.940
His final project there at Dropbox was really to work on mypy


00:01:40.940 --> 00:01:43.340
and help them convert to 2 to 3.


00:01:43.340 --> 00:01:44.540
I think it's kind of fitting, right?


00:01:44.540 --> 00:01:48.740
Like one of his final things is to convert one of the largest Python codebases


00:01:48.740 --> 00:01:52.340
from Python 2 to Python 3 to kind of like close that gap.


00:01:52.340 --> 00:01:55.840
I mean, not globally, but at least in that realm.


00:01:55.840 --> 00:01:57.920
You have not just his announcement,


00:01:57.920 --> 00:02:00.880
but a thank you Guido from Dropbox.


00:02:00.880 --> 00:02:01.720
That's kind of cool.


00:02:01.720 --> 00:02:03.920
Yeah, so when I wrote this stuff down,


00:02:03.920 --> 00:02:05.960
it was just, I don't know, half an hour


00:02:05.960 --> 00:02:07.120
since that news came out.


00:02:07.120 --> 00:02:09.640
And it was just full of responses of so many things.


00:02:09.640 --> 00:02:11.400
So I just grabbed a couple to,


00:02:11.400 --> 00:02:15.720
I thought maybe a nice way to close out this little section


00:02:15.720 --> 00:02:17.560
is just to read some of the messages


00:02:17.560 --> 00:02:20.120
that people wrote to Guido on his Twitter announcement


00:02:20.120 --> 00:02:22.640
that link to his full post.


00:02:22.640 --> 00:02:25.960
So, Lucili says,


00:02:25.960 --> 00:02:28.920
"Thank you for Python and helping to increase diversity


00:02:28.920 --> 00:02:30.960
"in the teams that you worked with.


00:02:30.960 --> 00:02:32.400
"Enjoy your retirement."


00:02:32.400 --> 00:02:35.880
Daron Leal says, "Congratulations and best wishes.


00:02:35.880 --> 00:02:38.020
"Thanks to the many contributions to open source software


00:02:38.020 --> 00:02:39.680
"and for inspiring me."


00:02:39.680 --> 00:02:43.360
Philip Guo, "Congrats and best wishes on the next era."


00:02:43.360 --> 00:02:44.600
Someone just goes by Steve.


00:02:44.600 --> 00:02:46.420
"Thank you for your contributions to the world.


00:02:46.420 --> 00:02:49.040
"My boy was just learning how to code Python


00:02:49.040 --> 00:02:52.040
as his first programming language, as I read this, basically.


00:02:52.040 --> 00:02:58.040
And Freeman Crouch, "Best switches, I literally don't know what my teaching career would have been like without Python."


00:02:58.040 --> 00:03:02.040
I just want to say, thanks for everything, Guido, that's awesome.


00:03:02.040 --> 00:03:07.040
He's really created something special and he's put a big dent in the universe, obviously.


00:03:07.040 --> 00:03:12.040
This is a huge accomplishment of what he's done and what he's shepherded over the last 30 years


00:03:12.040 --> 00:03:17.040
and it's definitely high time for him to retire just so that he can go and just enjoy that, not stress.


00:03:17.040 --> 00:03:19.560
Like it's cool that everything is in place


00:03:19.560 --> 00:03:23.240
that basically this is not like a oh my god, now what?


00:03:23.240 --> 00:03:25.520
It's just like oh, okay, well, that's great for him.


00:03:25.520 --> 00:03:27.960
Right, like we kind of went through that last year,


00:03:27.960 --> 00:03:28.800
actually.


00:03:28.800 --> 00:03:30.480
- Yep, it's an interesting thing,


00:03:30.480 --> 00:03:32.260
and yeah, I don't know what more to add


00:03:32.260 --> 00:03:33.840
other than also thank you.


00:03:33.840 --> 00:03:34.800
Yeah, I love the language.


00:03:34.800 --> 00:03:36.760
- We both get to work on some really awesome stuff


00:03:36.760 --> 00:03:37.760
involving Python.


00:03:37.760 --> 00:03:38.600
- Yeah.


00:03:38.600 --> 00:03:40.680
- And the community because of it, so yeah, thanks.


00:03:40.680 --> 00:03:42.560
All right, well, speaking of awesome stuff


00:03:42.560 --> 00:03:44.520
built with Python, what's next?


00:03:44.520 --> 00:03:46.340
- Yeah, hard to transition away from that,


00:03:46.340 --> 00:03:48.820
but I could have swore we'd covered this,


00:03:48.820 --> 00:03:49.780
but I guess we haven't.


00:03:49.780 --> 00:03:52.640
There's a cool project called Selenium Base.


00:03:52.640 --> 00:03:56.500
And what Selenium is, I mean, most people know it


00:03:56.500 --> 00:03:59.620
because in the Python community or other places


00:03:59.620 --> 00:04:03.300
for testing websites and such.


00:04:03.300 --> 00:04:05.740
You can also test APIs with it.


00:04:05.740 --> 00:04:09.980
But the Selenium WebDriver is what people often use


00:04:09.980 --> 00:04:13.100
to access Selenium through Python.


00:04:13.100 --> 00:04:15.980
And Selenium Base is built on top of that,


00:04:15.980 --> 00:04:18.860
and it's built in conjunction to work with,


00:04:18.860 --> 00:04:20.900
it works with other things like unit test stuff,


00:04:20.900 --> 00:04:23.420
but it works best with PyTest, of course.


00:04:23.420 --> 00:04:25.980
And it's kind of a layer on top


00:04:25.980 --> 00:04:28.260
that makes it quite a lot easier to,


00:04:28.260 --> 00:04:30.080
the Selenium WebDriver right out of the box


00:04:30.080 --> 00:04:31.580
has a lot of access.


00:04:31.580 --> 00:04:34.180
You can control, basically you're driving a web browser


00:04:34.180 --> 00:04:36.460
through from Python.


00:04:36.460 --> 00:04:39.820
And the Selenium base just makes it easier.


00:04:39.820 --> 00:04:41.140
There's a lot of easier things.


00:04:41.140 --> 00:04:45.100
Like I'm gonna link to, actually in the show notes,


00:04:45.100 --> 00:05:00.860
I've got a little snippet of code and it's really easy stuff like open a web page or open with a URL and assert that a title is there and, you know, click on elements and you can use go back and click and examine things and assert stuff.


00:05:00.860 --> 00:05:07.900
It definitely makes for testing testing web pages a lot easier with all these utilities, but I also wanted to highlight.


00:05:07.900 --> 00:05:13.620
There's some I was looking through it the other day and there's some other things that it does that I thought was kind of interesting.


00:05:13.980 --> 00:05:19.740
One of the things that it has is, well, one, it has support for a lot of the major continuous integration services.


00:05:19.740 --> 00:05:23.060
It also has a plugin built into it


00:05:23.060 --> 00:05:26.020
that you can take screenshots of test results.


00:05:26.020 --> 00:05:31.940
So let's say you have a test that fails because, you know, something isn't in the title or something isn't present or something's wrong.


00:05:31.940 --> 00:05:37.540
But what is there? And it's hard to describe with code, but it's not too bad with a screenshot.


00:05:37.540 --> 00:05:40.740
So it has the ability to take a screenshot on test failures.


00:05:40.740 --> 00:05:45.620
That's pretty cool. I wonder if you could use that as an assert itself.


00:05:45.620 --> 00:05:50.140
If you had a screenshot of the way, you said, "This page looks right now,"


00:05:50.140 --> 00:05:53.880
and if something goes crazy, like the CSS won't load or something is...


00:05:53.880 --> 00:05:56.260
Could you assert that the pixels are the same?


00:05:56.260 --> 00:05:59.700
I mean, that's sort of visual testing.


00:05:59.700 --> 00:06:01.560
There is some visual testing with it.


00:06:01.560 --> 00:06:04.600
The main component that it has with it is


00:06:04.600 --> 00:06:07.600
making sure that the DOM is essentially identical.


00:06:07.600 --> 00:06:10.620
The DOM essentially reproduced the same thing.


00:06:10.620 --> 00:06:13.220
I don't think it does a pixel by pixel comparison.


00:06:13.220 --> 00:06:15.220
Maybe there's some plug-in for it.


00:06:15.220 --> 00:06:17.220
But there is some built-in stuff to do.


00:06:17.220 --> 00:06:19.220
Basically, it should be about the same.


00:06:19.220 --> 00:06:21.220
Some other cool stuff, it works with


00:06:21.220 --> 00:06:23.720
Selenium Grid, which I wasn't quite sure what this was,


00:06:23.720 --> 00:06:26.720
but Selenium has built in an ability to


00:06:26.720 --> 00:06:29.520
run Selenium tests on multiple CPUs


00:06:29.520 --> 00:06:31.520
so that you can do things in parallel.


00:06:31.520 --> 00:06:33.520
Grid computing, I want to test all these pages,


00:06:33.520 --> 00:06:35.520
and it takes a little while, so just


00:06:35.520 --> 00:06:38.520
spread it out. Okay, that's cool. I hadn't heard of that either. That's nice.


00:06:38.520 --> 00:06:40.520
The other thing is assisted QA.


00:06:40.520 --> 00:06:44.280
So sometimes it's really easy to have a manual procedure


00:06:44.280 --> 00:06:45.960
that basically says, you know,


00:06:45.960 --> 00:06:47.680
we want to throw this together quickly.


00:06:47.680 --> 00:06:50.240
Just look at this page to make sure the graph is there.


00:06:50.240 --> 00:06:52.380
Sometimes it doesn't show up, or you know, whatever,


00:06:52.380 --> 00:06:55.280
just make sure, and then pop up a little dialog box


00:06:55.280 --> 00:06:56.720
that says, yes, it's there.


00:06:56.720 --> 00:07:00.280
There is some assisted QA, so it's like partial automation.


00:07:00.280 --> 00:07:01.480
And that's kind of neat.


00:07:01.480 --> 00:07:04.200
And I think people poo-poo this too much.


00:07:04.200 --> 00:07:06.680
This is actually very powerful to have in place,


00:07:06.680 --> 00:07:10.640
and sometimes it's a matter of pragmatism of getting things done.


00:07:10.640 --> 00:07:16.060
So this is cool. Then one of the other cool things is it has onboarding demos capability.


00:07:16.060 --> 00:07:20.820
So since you're using it to drive a web browser,


00:07:20.820 --> 00:07:24.080
you can use it to highlight things and pop up messages,


00:07:24.080 --> 00:07:29.660
and you can essentially give an onboarding demo of how to use a web page.


00:07:29.660 --> 00:07:31.380
So this isn't a testing thing,


00:07:31.380 --> 00:07:36.100
this is you would create a little demo to show somebody how to use some service.


00:07:36.100 --> 00:07:37.540
So that's kind of neat.


00:07:37.540 --> 00:07:38.540
Yeah, super cool.


00:07:38.540 --> 00:07:39.660
This looks really nice.


00:07:39.660 --> 00:07:42.060
I looked at the API that you got here.


00:07:42.060 --> 00:07:45.660
If you knew the tiniest bit of programming


00:07:45.660 --> 00:07:46.940
and you knew CSS,


00:07:46.940 --> 00:07:48.260
you already understand this.


00:07:48.260 --> 00:07:50.460
Like there's no documentation needed.


00:07:50.460 --> 00:07:52.620
Obviously, you've got to have some documentation for real,


00:07:52.620 --> 00:07:54.300
but it's super clear.


00:07:54.300 --> 00:07:57.660
It takes away all of like the find item by element


00:07:57.660 --> 00:07:59.060
and all those sorts of things.


00:07:59.060 --> 00:08:01.060
You don't have to do that too much.


00:08:01.060 --> 00:08:04.180
So anyway, cool thing for if you want to automate


00:08:04.180 --> 00:08:08.740
a web browser or test a website, make sure you check this out.


00:08:08.740 --> 00:08:09.240
It's good.


00:08:09.240 --> 00:08:11.380
Yeah, it looks great. I love it. Nice find.


00:08:11.380 --> 00:08:14.380
Well, and another thing that's nice is Datadog.


00:08:14.380 --> 00:08:17.020
So this episode is sponsored by Datadog,


00:08:17.020 --> 00:08:21.320
a cloud-scale monitoring platform that unifies metrics, logs,


00:08:21.320 --> 00:08:22.980
distributed traces, and more.


00:08:22.980 --> 00:08:27.060
Trace requests across service boundaries with flame graphs,


00:08:27.060 --> 00:08:29.460
correlate traces with logs and metrics,


00:08:29.460 --> 00:08:33.260
and plot the flow of traffic across multi-cloud environments


00:08:33.260 --> 00:08:35.660
with network performance monitoring.


00:08:35.660 --> 00:08:41.260
Plus, Datadog integrates with over 350 technologies like Postgres, Redis, and Hadoop,


00:08:41.260 --> 00:08:44.460
and they're tracing client auto-instruments, common frameworks,


00:08:44.460 --> 00:08:47.860
and libraries like Django, Tornado, Flask, and AsyncIO.


00:08:47.860 --> 00:08:48.960
That's cool.


00:08:48.960 --> 00:08:54.460
Get started today with a 14-day free trial at pythonbytes.fm/datadog.


00:08:54.460 --> 00:08:57.260
Yeah, check them out. Big support as a show. Thank you, Datadog.


00:08:57.260 --> 00:08:59.760
Yeah, plus I love my purple t-shirt from them. It's good.


00:08:59.760 --> 00:09:00.460
For sure.


00:09:00.460 --> 00:09:04.140
Now, this next one, I want to start by asking you a question, Brian.


00:09:04.140 --> 00:09:05.900
You've done a lot of C, C++.


00:09:05.900 --> 00:09:07.340
We even talked about that last time, right?


00:09:07.340 --> 00:09:07.840
Yes.


00:09:07.840 --> 00:09:08.700
Is Python slow?


00:09:08.700 --> 00:09:10.260
No. People are slow.


00:09:10.260 --> 00:09:12.140
People are... Very good. That's a good question.


00:09:12.140 --> 00:09:13.460
Good response. I like it.


00:09:13.460 --> 00:09:16.700
I think the whether or not Python is slow is a really interesting question.


00:09:16.700 --> 00:09:22.140
And people sometimes say, "Well, I did a tight loop and I added x+=1,


00:09:22.140 --> 00:09:24.540
and it was slower than if I did that on C.


00:09:24.540 --> 00:09:26.540
And so Python is slow, right?"


00:09:26.540 --> 00:09:30.060
But then you could also say, "Well, I have a job.


00:09:30.060 --> 00:09:32.340
somebody told me to implement this feature.


00:09:32.340 --> 00:09:34.820
If I started in C, I would be done in 10 days.


00:09:34.820 --> 00:09:37.160
If I did it in Python, I'd be done in six hours.


00:09:37.160 --> 00:09:41.380
So, and it took one minute to run it in Python and 30 seconds in C.


00:09:41.380 --> 00:09:43.460
So Python is way faster, right?


00:09:43.460 --> 00:09:47.000
It's half a day or three quarters of a day instead of 10 days.


00:09:47.000 --> 00:09:47.340
Yes.


00:09:47.340 --> 00:09:48.700
That sort of analysis.


00:09:48.700 --> 00:09:52.980
But sometimes it's interesting just to compare like directly to these things.


00:09:52.980 --> 00:09:54.860
And we also have the C layer.


00:09:54.860 --> 00:09:55.900
So like, yeah, sure.


00:09:55.900 --> 00:09:58.860
It might be slower than some languages, but then if you call it like NumPy,


00:09:58.860 --> 00:10:01.860
then it's probably faster than most like there's all these interesting like


00:10:01.860 --> 00:10:02.580
angles, right?


00:10:02.580 --> 00:10:04.140
Scython and whatnot.


00:10:04.140 --> 00:10:07.740
But this thing that I want to talk about now is this host


00:10:07.740 --> 00:10:09.460
mortem done by Darren Moffett.


00:10:09.460 --> 00:10:14.660
So he re implemented the list users command on Solaris.


00:10:14.660 --> 00:10:19.500
It was originally written in C and he rewrote it in Python.


00:10:19.500 --> 00:10:20.460
Okay.


00:10:20.460 --> 00:10:22.140
Which is kind of an interesting thing.


00:10:22.140 --> 00:10:24.740
Couple of stats about it.


00:10:24.740 --> 00:10:30.980
So this is from like 19, the last time the C code was touched was like 1988.


00:10:30.980 --> 00:10:34.860
That's 30 years ago, 31 years ago.


00:10:34.860 --> 00:10:36.740
That's a good long while.


00:10:36.740 --> 00:10:42.380
And the implementation of this was about 800 lines.


00:10:42.380 --> 00:10:45.820
And it was written in a time when the number of users were small and


00:10:45.820 --> 00:10:46.420
things like that.


00:10:46.420 --> 00:10:49.140
So it didn't have to deal with tons of data.


00:10:49.140 --> 00:10:51.020
And it even had some bugs, right?


00:10:51.020 --> 00:10:57.020
But it turned out that a basic implementation of what List Users does is a set manipulation.


00:10:57.020 --> 00:10:57.520
Okay.


00:10:57.520 --> 00:10:59.520
You know what language has really good set implementation?


00:10:59.520 --> 00:11:00.020
Python.


00:11:00.020 --> 00:11:01.020
Indeed.


00:11:01.020 --> 00:11:05.020
So, he decided to try to rewrite it in Python.


00:11:05.020 --> 00:11:12.520
And it turns out the rewrite of List Users in Python 3 was about a tenth the number of lines of code.


00:11:12.520 --> 00:11:18.020
Instead of 800 lines of probably fairly gnarly C code, it was down to 80 lines of Python.


00:11:18.020 --> 00:11:18.520
Wow.


00:11:18.520 --> 00:11:19.520
That's pretty awesome.


00:11:19.520 --> 00:11:23.720
And a lot of the reason has to do with the fact that you don't have to reimplement set.


00:11:23.720 --> 00:11:26.720
You just say the word set and you're good.


00:11:26.720 --> 00:11:29.720
But what's really interesting is on top of that,


00:11:29.720 --> 00:11:31.720
for 100,000 users,


00:11:31.720 --> 00:11:33.720
some tests they were doing,


00:11:33.720 --> 00:11:36.920
the Python version was 17 times,


00:11:36.920 --> 00:11:40.220
1,700% faster than the C code as well.


00:11:40.220 --> 00:11:41.720
Wow, that's incredible.


00:11:41.720 --> 00:11:42.320
Pretty cool, huh?


00:11:42.320 --> 00:11:44.320
Yeah, it's actually not surprising to me.


00:11:44.320 --> 00:11:47.720
I'm glad we're covering it because it sure should surprise some people.


00:11:47.720 --> 00:11:49.820
Yeah, it doesn't surprise me all that much either.


00:11:49.820 --> 00:11:51.520
So yeah, it's pretty interesting.


00:11:51.520 --> 00:11:56.280
That turns out that the it's source open, but not open source.


00:11:56.280 --> 00:12:00.700
If you want to look at the implementation, what I mean by that is the list


00:12:00.700 --> 00:12:03.740
users command is, you know, this is from Oracle, right?


00:12:03.740 --> 00:12:04.680
Like they bought sun.


00:12:04.680 --> 00:12:05.740
So now they have Solaris.


00:12:05.740 --> 00:12:11.540
So on 11.4 SRU 9 or higher, you could just go to slash user slash bin slash


00:12:11.540 --> 00:12:13.340
users, and it's a Python file.


00:12:13.340 --> 00:12:14.500
So you just look at it, right?


00:12:14.500 --> 00:12:17.300
So you can see what they're doing and you could compare the code and


00:12:17.300 --> 00:12:19.480
and whatnot, but it's not open source


00:12:19.480 --> 00:12:22.160
and it's covered by the Oracle Solaris license.


00:12:22.160 --> 00:12:24.960
So you can check it out, but it's not open source.


00:12:24.960 --> 00:12:25.800
It's source open.


00:12:25.800 --> 00:12:26.620
- This is cool.


00:12:26.620 --> 00:12:28.880
So not only is this, somebody tried to do it


00:12:28.880 --> 00:12:32.840
and it was faster, it also is shipping now with Solaris.


00:12:32.840 --> 00:12:34.380
- Yeah, that's pretty awesome.


00:12:34.380 --> 00:12:35.260
And it's Python 3.


00:12:35.260 --> 00:12:36.100
- Of course.


00:12:36.100 --> 00:12:36.920
- Of course.


00:12:36.920 --> 00:12:38.520
I bet there's some useful tricks in that code.


00:12:38.520 --> 00:12:39.560
- There probably are.


00:12:39.560 --> 00:12:41.000
Actually, I was thinking about this


00:12:41.000 --> 00:12:43.000
when you brought it up with sets.


00:12:43.000 --> 00:12:46.960
So I admit it, I am capable of getting link baited


00:12:46.960 --> 00:12:48.960
by the occasional listicle,


00:12:48.960 --> 00:12:50.800
and this is definitely one of them.


00:12:50.800 --> 00:12:53.580
It was 20 useful Python tips and tricks


00:12:53.580 --> 00:12:55.040
that you should know.


00:12:55.040 --> 00:12:56.840
Now, there's some fluff in there


00:12:56.840 --> 00:12:58.220
that I don't think that's useful,


00:12:58.220 --> 00:12:59.480
but there's a whole bunch of,


00:12:59.480 --> 00:13:02.920
enough that are useful that I think it's a good thing


00:13:02.920 --> 00:13:04.880
to take a look at.


00:13:04.880 --> 00:13:07.360
Like for one, I'm not sure if,


00:13:07.360 --> 00:13:09.520
so change assignment is one of the first ones


00:13:09.520 --> 00:13:12.880
that I looked at, and you actually don't,


00:13:12.880 --> 00:13:15.080
I don't see this in a lot of Python code,


00:13:15.080 --> 00:13:17.900
So is it bad, Python style or something,


00:13:17.900 --> 00:13:22.060
to have like x equals y equals z equals two or something?


00:13:22.060 --> 00:13:22.900
Do you know?


00:13:22.900 --> 00:13:24.380
- I don't know, actually.


00:13:24.380 --> 00:13:27.140
But you're right, I remember seeing this a lot in C.


00:13:27.140 --> 00:13:27.980
- Yeah.


00:13:27.980 --> 00:13:29.340
- But not a lot in Python, no.


00:13:29.340 --> 00:13:31.100
- No, but it does work in Python.


00:13:31.100 --> 00:13:33.580
But I guess, make sure that you're not doing something


00:13:33.580 --> 00:13:35.180
that's too unclear.


00:13:35.180 --> 00:13:38.660
I highlighted that mostly because what I do see,


00:13:38.660 --> 00:13:41.020
what I use a lot is chain comparison.


00:13:41.020 --> 00:13:43.200
And people coming from other languages


00:13:43.200 --> 00:13:44.620
don't know you can do this.


00:13:44.620 --> 00:13:47.620
So for instance in C, if you wanted to have,


00:13:47.620 --> 00:13:50.220
make sure that X was between two and eight,


00:13:50.220 --> 00:13:52.100
you'd have to go two is less than X


00:13:52.100 --> 00:13:55.300
and X is less than eight or something.


00:13:55.300 --> 00:13:57.460
But with the Python, you can just chain them together


00:13:57.460 --> 00:13:58.300
and put them together.


00:13:58.300 --> 00:14:00.620
- Right, like two less than X less than or equal to eight.


00:14:00.620 --> 00:14:02.820
- Yeah, and you can have a whole bunch of them.


00:14:02.820 --> 00:14:05.020
So you can have a couple variables


00:14:05.020 --> 00:14:08.220
within ranges and stuff, it's nice.


00:14:08.220 --> 00:14:11.340
Multiple assignment, which I think of as unpacking, I guess.


00:14:11.340 --> 00:14:12.900
- Yeah, I think of that as tuple unpacking.


00:14:12.900 --> 00:14:14.180
Definitely that's common, right?


00:14:14.180 --> 00:14:17.060
like if you're gonna do a four, you know,


00:14:17.060 --> 00:14:20.260
index comma value in enumerate of collection,


00:14:20.260 --> 00:14:21.100
something like that.


00:14:21.100 --> 00:14:23.300
- Yeah, but the thing that I've been using a lot more lately


00:14:23.300 --> 00:14:26.620
is tuple unpacking with the star operator.


00:14:26.620 --> 00:14:29.900
So like if you put a star on one of the things


00:14:29.900 --> 00:14:33.020
you're unpacking to, it takes all the leftovers.


00:14:33.020 --> 00:14:34.680
And so if you've got a whole bunch of stuff


00:14:34.680 --> 00:14:37.100
you're unpacking but you only care about a couple of them,


00:14:37.100 --> 00:14:39.380
you can name those and then just capture


00:14:39.380 --> 00:14:43.220
all the rest of them in a star underscore or something.


00:14:43.220 --> 00:14:44.660
- Yeah, throw away.


00:14:44.660 --> 00:14:46.380
I know I have to have placeholder for this,


00:14:46.380 --> 00:14:47.260
but I just don't care.


00:14:47.260 --> 00:14:48.460
- I've seen it in a couple articles,


00:14:48.460 --> 00:14:50.860
but it listed merge dictionaries,


00:14:50.860 --> 00:14:54.080
where you do star star of both dictionaries


00:14:54.080 --> 00:14:57.320
within another dictionary in brackets,


00:14:57.320 --> 00:14:58.860
and that kind of combines them.


00:14:58.860 --> 00:15:00.720
Debate as to what you should use,


00:15:00.720 --> 00:15:02.540
but I kind of like that 'cause it's short.


00:15:02.540 --> 00:15:04.140
- I like that one, yep.


00:15:04.140 --> 00:15:07.060
- And then joining strings, people new to Python,


00:15:07.060 --> 00:15:09.180
it's one of those things that it's nice to,


00:15:09.180 --> 00:15:12.700
you just take a character or a string,


00:15:12.700 --> 00:15:16.500
and join all the elements in a list or any iterable.


00:15:16.500 --> 00:15:19.060
And this is something that, for some reason,


00:15:19.060 --> 00:15:21.500
especially the people I'm familiar with


00:15:21.500 --> 00:15:24.820
that come from C or C++ to Python,


00:15:24.820 --> 00:15:26.380
this is hard for them to get around,


00:15:26.380 --> 00:15:30.480
that strings themselves have object methods on them.


00:15:30.480 --> 00:15:32.980
- Isn't it just a character pointer or something like that?


00:15:32.980 --> 00:15:36.500
Like char star, char star, sort of?


00:15:36.500 --> 00:15:38.820
- Yeah, yeah, they don't think of them as objects.


00:15:38.820 --> 00:15:39.660
- Exactly.


00:15:39.660 --> 00:15:41.320
- This brings up, you said sets before,


00:15:41.320 --> 00:15:46.320
So if you've got a list of things and you want to get the list of unique things,


00:15:46.320 --> 00:15:50.320
well, you can just convert it to a set and then back to a list, and there you go.


00:15:50.320 --> 00:15:53.320
Yeah, I do that sometimes. It's really nice. That's your distinct, yeah.


00:15:53.320 --> 00:15:56.320
Yeah, the only thing left that I wanted to mention was using--


00:15:56.320 --> 00:16:00.320
this was something that was difficult for me to get my head around,


00:16:00.320 --> 00:16:04.320
was the zip function, mostly because I was familiar with using zip


00:16:04.320 --> 00:16:07.320
on the command line to actually zip files.


00:16:07.320 --> 00:16:09.720
So no, Zip is completely different.


00:16:09.720 --> 00:16:13.960
It kind of pair-wises up all a bunch of lists of things.


00:16:13.960 --> 00:16:16.000
And I use it all--


00:16:16.000 --> 00:16:18.200
I don't really-- it's hard to explain when you use it,


00:16:18.200 --> 00:16:20.280
but when you do need it, it's really handy.


00:16:20.280 --> 00:16:24.960
Yeah, I feel like the inner tool stuff just has so many things.


00:16:24.960 --> 00:16:27.520
It's always something new to me.


00:16:27.520 --> 00:16:28.320
You know?


00:16:28.320 --> 00:16:29.040
Yeah, so I--


00:16:29.040 --> 00:16:30.360
I don't know all this stuff.


00:16:30.360 --> 00:16:33.120
Those are the things I thought were good, and it was less than 20.


00:16:33.120 --> 00:16:36.080
The rest of the 20 wasn't that useful to me, but these were neat.


00:16:36.080 --> 00:16:39.080
Yeah, no, those are really cool.


00:16:39.080 --> 00:16:42.080
A lot of times with these listicle type things, or like this top ten,


00:16:42.080 --> 00:16:44.080
or like, I don't know, some of these are cool,


00:16:44.080 --> 00:16:46.080
like these all look really great. Yeah, I like it.


00:16:46.080 --> 00:16:49.080
Cool. So let's talk about waterfalls.


00:16:49.080 --> 00:16:52.080
Now, we've talked a little bit about code complexity


00:16:52.080 --> 00:16:55.080
on different things. I think we've covered Wiley from Anthony Shaw,


00:16:55.080 --> 00:16:58.080
which is a code complexity analysis tool.


00:16:58.080 --> 00:17:04.080
So, here's an article write-up sent over by Arem Aref.


00:17:04.080 --> 00:17:09.080
from the article is by somebody named Nikita Sobolev.


00:17:09.080 --> 00:17:11.080
And it's called Complexity Waterfalls.


00:17:11.080 --> 00:17:12.080
Pretty interesting.


00:17:12.080 --> 00:17:16.080
It kind of talks about the origins of complexity in our code


00:17:16.080 --> 00:17:18.080
and just the challenges of how that sneak in.


00:17:18.080 --> 00:17:22.080
And nobody starts out with the intention of writing like bad,


00:17:22.080 --> 00:17:24.080
hard to understand code.


00:17:24.080 --> 00:17:26.080
You may know you're going down that path.


00:17:26.080 --> 00:17:28.080
He's like, "I don't know what I'm doing here."


00:17:28.080 --> 00:17:32.080
But most of the time, it's with good intentions that everything starts out.


00:17:32.080 --> 00:17:35.600
At some point it becomes this mess, right?


00:17:35.600 --> 00:17:36.440
- Yes.


00:17:36.440 --> 00:17:38.640
Some people are really good at it too.


00:17:38.640 --> 00:17:40.480
- They do have a special skill.


00:17:40.480 --> 00:17:44.540
So this article highlights some of the types of complexity


00:17:44.540 --> 00:17:47.740
that you might find, how you might address them,


00:17:47.740 --> 00:17:51.280
some of the tools to actually automatically discover them.


00:17:51.280 --> 00:17:53.880
Two of the core ideas are things that I think


00:17:53.880 --> 00:17:55.000
will resonate with you, Brian,


00:17:55.000 --> 00:18:00.000
are continuous refactoring and architecture on demand


00:18:00.260 --> 00:18:03.060
from using things like tests and continuous integration


00:18:03.060 --> 00:18:04.200
and whatnot.


00:18:04.200 --> 00:18:06.620
So basically, instead of trying to dream up


00:18:06.620 --> 00:18:09.360
this perfect architecture, just write stuff


00:18:09.360 --> 00:18:11.260
in a simple way, and as it gets more complex,


00:18:11.260 --> 00:18:13.060
run some tools, discover the problems,


00:18:13.060 --> 00:18:15.540
use your unit tests to let you refactor,


00:18:15.540 --> 00:18:18.420
and grow the architecture out of it.


00:18:18.420 --> 00:18:19.260
What do you think of that?


00:18:19.260 --> 00:18:20.660
- Yeah, I definitely like that a lot,


00:18:20.660 --> 00:18:23.100
and more and more I'm warming to the idea


00:18:23.100 --> 00:18:28.020
of using complexity measurements as part of your tools


00:18:28.020 --> 00:18:29.500
to tell you where to refactor.


00:18:29.500 --> 00:18:33.260
Yeah, so one of the things they use in here


00:18:33.260 --> 00:18:35.420
to talk about the complexity and measure it


00:18:35.420 --> 00:18:39.980
is this thing called wemake-python-styleguide,


00:18:39.980 --> 00:18:41.640
which is actually a linter, not just a guide.


00:18:41.640 --> 00:18:43.540
Like it's a thing you could run, I believe.


00:18:43.540 --> 00:18:46.940
It actually outputs stuff, it's not just a guide.


00:18:46.940 --> 00:18:49.020
And it does pretty interesting stuff.


00:18:49.020 --> 00:18:51.740
So you can run it on your code and it'll say,


00:18:51.740 --> 00:18:53.660
you know, you're missing white space


00:18:53.660 --> 00:18:55.860
between your type definition and your type,


00:18:55.860 --> 00:18:58.820
your variable definition and your type annotation,


00:18:58.820 --> 00:19:03.820
or between a comma, or there's a bunch of different things.


00:19:03.820 --> 00:19:07.460
And it brings in some of these complexity measures.


00:19:07.460 --> 00:19:09.540
I've heard of, you've heard of psychomatic complexity.


00:19:09.540 --> 00:19:11.140
I know we've talked about that, right?


00:19:11.140 --> 00:19:11.980
- Yes.


00:19:11.980 --> 00:19:14.380
- We've definitely spoken about lines of code, right?


00:19:14.380 --> 00:19:17.540
Like when, so the article talks about, hey,


00:19:17.540 --> 00:19:21.380
here's how individual lines of code become complex.


00:19:21.380 --> 00:19:23.780
Here's how functions become complex,


00:19:23.780 --> 00:19:27.660
or classes, or modules, or packages, and so on.


00:19:27.660 --> 00:19:32.500
And obvious measures or metrics would be


00:19:32.500 --> 00:19:35.600
if your function is 5,000 lines long, it's wrong.


00:19:35.600 --> 00:19:37.060
I don't know what it does, I've never seen it,


00:19:37.060 --> 00:19:39.620
but I can tell you already, it's broken, right?


00:19:39.620 --> 00:19:43.500
These sorts of things are pretty obvious.


00:19:43.500 --> 00:19:45.940
But one that I don't know that I've ever


00:19:45.940 --> 00:19:47.980
really paid attention to is something called the,


00:19:47.980 --> 00:19:51.020
I think it's the Jones, Jones metric?


00:19:51.020 --> 00:19:52.140
Yeah, Jones complexity?


00:19:52.140 --> 00:19:53.300
- No, I've never heard of this.


00:19:53.300 --> 00:19:55.140
- Yeah, so here's the idea.


00:19:55.140 --> 00:19:57.540
If you had a line that was 80 lines long,


00:19:57.540 --> 00:19:59.640
Like says, the example they give in the,


00:19:59.640 --> 00:20:01.280
Nikita gives in the article is,


00:20:01.280 --> 00:20:04.260
by print three long variable names.


00:20:04.260 --> 00:20:06.520
Yeah, first long name with meaning,


00:20:06.520 --> 00:20:07.580
second long name with meaning,


00:20:07.580 --> 00:20:09.680
the third one, and that's 80 lines.


00:20:09.680 --> 00:20:13.520
Or if you say print three calculations, right?


00:20:13.520 --> 00:20:16.640
Like you actually compute three or four things, right?


00:20:16.640 --> 00:20:18.160
Multiply, divide, whatever,


00:20:18.160 --> 00:20:19.660
multiple things in each of those print,


00:20:19.660 --> 00:20:22.660
you're still printing three values,


00:20:22.660 --> 00:20:25.160
but somehow they feel more complex.


00:20:25.160 --> 00:20:26.960
So with the Jones complexity,


00:20:26.960 --> 00:20:30.960
What it measures is, it's like, if I were to take this line of code


00:20:30.960 --> 00:20:35.960
and parse it into an abstract syntax tree, how many nodes would there be?


00:20:35.960 --> 00:20:36.960
Oh, wow.


00:20:36.960 --> 00:20:37.960
The first one, there's four.


00:20:37.960 --> 00:20:39.960
We have print, and then there's the three things we're printing.


00:20:39.960 --> 00:20:45.960
The other one is 21 different things are participating in this one line.


00:20:45.960 --> 00:20:46.960
Yeah.


00:20:46.960 --> 00:20:50.960
The reason I bring that up is, for example, the WeMake thing, I believe,


00:20:50.960 --> 00:20:54.960
will tell you this has too high of a Jones complexity.


00:20:54.960 --> 00:20:55.960
Yeah.


00:20:55.960 --> 00:20:59.800
It's a little line that yeah, it says, it'll say things like we found a line


00:20:59.800 --> 00:21:02.000
with a high Jones complexity of 15.


00:21:02.000 --> 00:21:02.960
This is an error.


00:21:02.960 --> 00:21:03.680
What should you do?


00:21:03.680 --> 00:21:08.120
And what should you, you should break those out into different variables, right?


00:21:08.120 --> 00:21:11.340
You should take those expressions and turn them into three variables and then


00:21:11.340 --> 00:21:14.560
print them like three variables, one on each line and then print them.


00:21:14.560 --> 00:21:18.520
So there's a lot of concrete little steps about how do you go through


00:21:18.520 --> 00:21:19.980
and see this complexity?


00:21:19.980 --> 00:21:21.720
What do you do about it?


00:21:21.720 --> 00:21:24.800
And like, how do you kind of evolve your architecture through it?


00:21:24.800 --> 00:21:27.740
So I don't want to go through all the details in there,


00:21:27.740 --> 00:21:29.920
but it's a pretty interesting read,


00:21:29.920 --> 00:21:32.240
and it comes up with some good ideas,


00:21:32.240 --> 00:21:36.160
including pointing out this WeMake Python Style Guide.


00:21:36.160 --> 00:21:37.400
- One of the things I want to highlight


00:21:37.400 --> 00:21:39.320
when we're talking about this is that


00:21:39.320 --> 00:21:42.520
a lot of times it is shifting complexity.


00:21:42.520 --> 00:21:45.520
So you'll have a very complex bit of something,


00:21:45.520 --> 00:21:48.360
and that's a danger field, but to eliminate it,


00:21:48.360 --> 00:21:51.160
you're going to add complexity somewhere else.


00:21:51.160 --> 00:21:54.600
Because like the example of a 5,000 line function,


00:21:54.600 --> 00:22:01.960
that's bad, but so is 5,000 two-line functions that are 5,000 functions deep.


00:22:01.960 --> 00:22:07.240
Sure. Yeah, if you were to break it into 10 lines, you might end up with a module with 500 functions.


00:22:07.240 --> 00:22:08.520
That's also a bad thing.


00:22:08.520 --> 00:22:13.880
Right. And so that's one of the things that I like about these tools is that you can break things out


00:22:13.880 --> 00:22:16.680
the way you think it's better and then measure it again.


00:22:16.680 --> 00:22:21.640
And also, please have tests in place to make sure that you're not breaking your code while you're refactoring.


00:22:21.640 --> 00:22:38.680
Yeah. So one of the things that Nikita talks about is this iterative, continuous refactoring stuff. Like, okay, we fix the Jones complexity of this, but now we've actually changed the complexity of, say, the module. How do we fix that? Right? Like, keep doing it until it gets better. Right?


00:22:38.720 --> 00:22:47.120
Yes and I love this because the idea maybe some people can just think of the right architecture that they're going to need at the end but I never can.


00:22:47.120 --> 00:22:53.060
So starting small and building up and refactoring where needed that's the only way I know how to work.


00:22:53.060 --> 00:22:59.720
Well usually the challenges you don't have a perfect understanding of the problem you're solving until you're halfway through it.


00:22:59.720 --> 00:23:02.480
Right well usually not until I'm completely through it.


00:23:02.480 --> 00:23:17.480
Yeah, for sure. So even if you try to think like, well, maybe I should be more patient. I'm going to really think through this. Well, maybe, but the way you figure out what the solution should be is by going through that step. And then there's this iterative fixing process.


00:23:17.480 --> 00:23:22.880
I never understand why some coders and developers think that they really can


00:23:22.880 --> 00:23:25.180
architect the right solution to begin with.


00:23:25.180 --> 00:23:28.980
It's like expecting a novelist to not write a first draft.


00:23:28.980 --> 00:23:31.780
To just come up with the final draft at the end.


00:23:31.780 --> 00:23:32.680
It just doesn't work.


00:23:32.680 --> 00:23:35.580
Yeah, even if it can be done, it's probably not the most efficient


00:23:35.580 --> 00:23:37.580
way to do it, right? You just stare at the wall


00:23:37.580 --> 00:23:41.180
for a week. You're like, you know what? I wrote it badly in three hours, I fixed it in one,


00:23:41.180 --> 00:23:42.580
I went to lunch, right? We're good.


00:23:42.580 --> 00:23:43.280
Exactly.


00:23:43.280 --> 00:23:44.480
For sure. Cool, well,


00:23:44.480 --> 00:23:48.720
If you care about code complexity and this kind of stuff, this is a pretty good write-up


00:23:48.720 --> 00:23:51.360
and definitely some of the tools mentioned are interesting.


00:23:51.360 --> 00:23:55.600
There's usually advice at each level, like, "Here's what you do to make a line less complex.


00:23:55.600 --> 00:23:58.080
Here's what you do to make a function less complex."


00:23:58.080 --> 00:24:03.040
I think the advice is generally good, but it can't be taken absolute.


00:24:03.040 --> 00:24:03.920
Absolutely, right?


00:24:03.920 --> 00:24:08.880
Like, it talks about, "Well, if I have a function, fewer arguments is better.


00:24:08.880 --> 00:24:12.160
If I have a class, fewer methods and fewer fields is better."


00:24:12.160 --> 00:24:18.360
But if you push that to its extreme, you say, well, all my classes have only one field and one public function. Like, well, okay.


00:24:18.360 --> 00:24:27.420
It's kind of, you know, now you have a thousand, you can't push it to its logical extreme, right? It's kind of a give and a take, but it's, you know, it points in the right direction, I would say.


00:24:27.420 --> 00:24:32.760
I only have one argument to every function. It happens to be a variable length tuple, but...


00:24:32.760 --> 00:24:34.760
Exactly.


00:24:34.760 --> 00:24:36.600
That's called tuple complexity.


00:24:36.600 --> 00:24:39.560
Tuple complexity. Yeah. Is that in the list?


00:24:39.560 --> 00:24:41.760
No, it's not, but it is now. I'm adding it.


00:24:41.760 --> 00:24:44.400
Have we ever talked about GUIs on this podcast?


00:24:44.400 --> 00:24:48.240
We should totally cover that because Python needs to have more cool GUIs.


00:24:48.240 --> 00:24:49.080
I think so.


00:24:49.080 --> 00:24:50.960
So this one came up recently.


00:24:50.960 --> 00:24:53.120
It's-- I don't know how to pronounce it.


00:24:53.120 --> 00:24:55.120
P-L-Y-N-T-H.


00:24:55.120 --> 00:24:55.760
Plinth?


00:24:55.760 --> 00:24:56.400
Plynth?


00:24:56.400 --> 00:24:57.840
I'm going to go with Plynth.


00:24:57.840 --> 00:24:58.160
Plynth.


00:24:58.160 --> 00:24:58.680
I could be wrong.


00:24:58.680 --> 00:25:01.080
And I don't mean to make fun of you, Plynth.


00:25:01.080 --> 00:25:02.400
I think what it's cool.


00:25:02.400 --> 00:25:03.160
What it is is cool.


00:25:03.160 --> 00:25:07.920
So it's a GUI framework for building cross-platform desktop applications


00:25:07.920 --> 00:25:10.080
with HTML, CSS, and Python.


00:25:10.080 --> 00:25:11.920
"Hey, we asked for this."


00:25:11.920 --> 00:25:13.720
But it looks pretty cool.


00:25:13.720 --> 00:25:16.960
It integrates with the standard CPython implementation


00:25:16.960 --> 00:25:20.360
and the Chromium's rendering engine.


00:25:20.360 --> 00:25:23.520
And you can basically run Python,


00:25:23.520 --> 00:25:26.840
runs JavaScript and Python all together with Python.


00:25:26.840 --> 00:25:29.180
And it's kind of hard to explain without looking at it,


00:25:29.180 --> 00:25:32.960
but it's sort of a thing that's just starting out.


00:25:32.960 --> 00:25:34.700
And it's not an open source thing.


00:25:34.700 --> 00:25:36.860
It's a group doing this.


00:25:36.860 --> 00:25:39.680
They're gonna do it for money, but it's not expensive.


00:25:39.680 --> 00:25:44.000
It's free for individuals and including commercial use for individuals.


00:25:44.000 --> 00:25:46.020
And there's a bunch of tutorial videos.


00:25:46.020 --> 00:25:50.080
Now I'm watching some of the tutorial videos watch you kind of like one of them is like


00:25:50.080 --> 00:25:54.960
implementing a calculator and one of them is like implementing a spinning cubicle or


00:25:54.960 --> 00:25:55.960
cubicle.


00:25:55.960 --> 00:25:58.160
No, spinning cube, but it's spinning cubicle.


00:25:58.160 --> 00:25:59.160
That'd be cool.


00:25:59.160 --> 00:26:00.280
Somebody should do that.


00:26:00.280 --> 00:26:03.720
Now they clearly know what they're doing when they're writing this and it might be that


00:26:03.720 --> 00:26:08.320
I'm just not a JavaScript person because the code they're writing doesn't seem obvious


00:26:08.320 --> 00:26:09.320
to me.


00:26:09.320 --> 00:26:14.480
But it isn't that much, so a handful of code, a handful of little bits of code and stuff,


00:26:14.480 --> 00:26:18.680
and you can implement something like a calculator on your web browser if you want.


00:26:18.680 --> 00:26:19.680
It's pretty interesting.


00:26:19.680 --> 00:26:21.800
So yeah, there's a visual calculator.


00:26:21.800 --> 00:26:24.640
I see that, and it looks like a desktop app.


00:26:24.640 --> 00:26:28.960
But obviously, we know it's basically the Python equivalent of Electron, right?


00:26:28.960 --> 00:26:31.960
Like HTML and JavaScript and Node.


00:26:31.960 --> 00:26:38.220
What kind of surprises me here is, at least the calculator example, is integrated with


00:26:38.220 --> 00:26:47.020
view.js, which is kind of actually super cool. So you define a Python class in the Dunder


00:26:47.020 --> 00:26:53.100
init, it sets up the view class. And if you've ever done view, that looks really familiar,


00:26:53.100 --> 00:26:57.780
you would say, here's the element that is the root of the app. Here's some of the bound


00:26:57.780 --> 00:27:02.540
data, here are some of the methods. And then you just point you basically just set the


00:27:02.540 --> 00:27:06.420
function to the various Python functions like they clicked on the number they clicked in


00:27:06.420 --> 00:27:09.300
an operator. I like it. This is actually pretty cool.


00:27:09.300 --> 00:27:12.820
Yeah, I think it looks neat. And it sounds like what they're doing is


00:27:12.820 --> 00:27:15.820
they're having some way to automatically


00:27:15.820 --> 00:27:19.460
convert existing JavaScript libraries to Python modules.


00:27:19.460 --> 00:27:23.700
So you can call them from your Python or hook up to them or something.


00:27:23.700 --> 00:27:29.100
And it's available, it looks like it has development kits available right now for Python 3.6 and 3.7.


00:27:29.100 --> 00:27:32.900
And anyway, for somebody wanting to play with GUIs


00:27:32.900 --> 00:27:36.100
for Python, I think this is something to pay attention to.


00:27:36.100 --> 00:27:40.100
I wish him luck. I'm not a zealot for open source only.


00:27:40.100 --> 00:27:44.100
I make money on this by going to work, so some, these people can too as well.


00:27:44.100 --> 00:27:49.100
And I'm over here looking at the pricing. Free for individuals, for commercial use,


00:27:49.100 --> 00:27:57.100
academic it's free, company enterprise, developer license, $599 per developer per four years.


00:27:57.100 --> 00:28:03.100
Like that is, honestly, they should put another zero on that, and I think it would still be okay,


00:28:03.100 --> 00:28:05.600
because that's totally reasonable.


00:28:05.600 --> 00:28:06.600
It's not like they're saying,


00:28:06.600 --> 00:28:09.100
"Oh, it's $1,000 per year per developer," right?


00:28:09.100 --> 00:28:10.100
It's not much.


00:28:10.100 --> 00:28:11.600
So I'm happy to talk about it.


00:28:11.600 --> 00:28:12.600
It looks great to me.


00:28:12.600 --> 00:28:14.100
- Yeah, looks neat. - For sure.


00:28:14.100 --> 00:28:16.100
Well, what do you got on the extras for us, Brian?


00:28:16.100 --> 00:28:17.100
Anything else you want to throw out there?


00:28:17.100 --> 00:28:19.100
- Yeah, I want to bring up a couple of things.


00:28:19.100 --> 00:28:22.600
I wanted to thank you for the excellent search feature


00:28:22.600 --> 00:28:24.100
that we have on Python Bytes.


00:28:24.100 --> 00:28:25.100
- You're welcome.


00:28:25.100 --> 00:28:27.100
- Because every week, believe it or not,


00:28:27.100 --> 00:28:30.100
I got to come up with, like, three items to talk about,


00:28:30.100 --> 00:28:32.600
and sometimes we've already covered it,


00:28:32.600 --> 00:28:35.840
And that was the case this time. I ran across another


00:28:35.840 --> 00:28:39.040
reference to a tool called Cerberus,


00:28:39.040 --> 00:28:41.040
which is a


00:28:41.040 --> 00:28:43.040
adjacent schema validation tool.


00:28:43.040 --> 00:28:45.040
Yeah, that's a cool one. I love it. It comes from


00:28:45.040 --> 00:28:47.460
Nikola. He built that as part of the EVE framework.


00:28:47.460 --> 00:28:49.460
Okay, well, it's really pretty neat.


00:28:49.460 --> 00:28:51.460
And it has a lot of extensibility


00:28:51.460 --> 00:28:54.360
features that I haven't seen in other validation tools.


00:28:54.360 --> 00:28:56.360
But we covered it in episode 70.


00:28:56.360 --> 00:28:59.000
So, and I found that out through your search feature.


00:28:59.000 --> 00:28:59.500
Awesome.


00:28:59.500 --> 00:29:01.200
The other thing I wanted to bring up was this


00:29:01.200 --> 00:29:09.040
A funny thing happened. I put some the other day I put use data classes in some test files test modules


00:29:09.040 --> 00:29:15.440
Because we've converted to python 3 7 at least i'm using we're slowly converting to python 3 8


00:29:15.440 --> 00:29:21.680
But a colleague of mine looked at my code and said, oh these data class things look cool. How did you learn about them?


00:29:21.680 --> 00:29:23.200
I'm, like well


00:29:23.200 --> 00:29:25.200
kind of my job


00:29:25.200 --> 00:29:26.320
It's awesome


00:29:26.320 --> 00:29:31.320
I didn't say, "Well, you should listen to Python Bytes," because it seems weird to encourage my coworkers to listen to it.


00:29:31.320 --> 00:29:33.320
Send him my way. I'll tell him to listen to it.


00:29:33.320 --> 00:29:35.320
Learn on my coworkers. I can tell them.


00:29:35.320 --> 00:29:38.320
How about you? Got anything extra for us?


00:29:38.320 --> 00:29:45.320
Just something super quick. I ran across this article. It's not directly related to Python, so I didn't make it its main item.


00:29:45.320 --> 00:29:55.320
But there's this project from Google where they've been working on the upstream Linux kernel using what they have called sanitizers.


00:29:55.320 --> 00:30:01.720
And basically these are like C linter type things that go and find problems with the code.


00:30:01.720 --> 00:30:08.520
So they had an address sanitizer for finding memory corruption and undefined behavior for certain code and other issues.


00:30:08.520 --> 00:30:13.220
And then they've come up with this one called the KCSAN.


00:30:13.220 --> 00:30:14.120
I don't know.


00:30:14.120 --> 00:30:16.620
The kernel concurrency sanitizer.


00:30:16.620 --> 00:30:21.320
And they then turned it on the latest Linux kernel.


00:30:21.320 --> 00:30:28.920
And what they found is in a two day period, they found over 300 unique race conditions and deadlocks and stuff within the mainline kernel of Linux.


00:30:28.920 --> 00:30:29.320
Wow.


00:30:29.320 --> 00:30:35.520
Anyway, there's some comments and stuff about this and links back to what they're doing. And it's kind of interesting. The codes on GitHub.


00:30:35.520 --> 00:30:38.920
Are they fixing them or just, you know, pointing out problems?


00:30:38.920 --> 00:30:49.640
Well, to point out a problem like a concurrency problem like that is one thing. But to fix it, I think is a whole entirely another without, you know, causing two more deadlocks somewhere else. So I don't know.


00:30:49.640 --> 00:30:49.960
Okay.


00:30:50.000 --> 00:30:51.320
Maybe they're just making people nervous.


00:30:51.320 --> 00:30:55.680
So making people nervous, maybe this joke might a little bit, probably not.


00:30:55.680 --> 00:30:59.560
But after the one last week, I don't know, man, we're pushing the boundaries.


00:30:59.560 --> 00:31:01.560
So let me ask you a question.


00:31:01.560 --> 00:31:05.320
When you talk about a link on the internet and it's, you know, HTTP, this or that,


00:31:05.320 --> 00:31:08.280
you call it a URL or an URL.


00:31:08.280 --> 00:31:09.680
Well, I call it a URL.


00:31:09.680 --> 00:31:09.880
Yeah.


00:31:09.880 --> 00:31:11.200
Some people call it URLs.


00:31:11.200 --> 00:31:12.440
That what's the URL for that?


00:31:12.440 --> 00:31:13.400
So people say URL.


00:31:13.400 --> 00:31:14.800
I, anyway, whatever.


00:31:14.800 --> 00:31:18.080
So there's this, this joke that comes from 18 Barry.


00:31:18.080 --> 00:31:18.920
Right.


00:31:18.920 --> 00:31:21.520
What's a web developer's favorite T?


00:31:21.520 --> 00:31:25.660
- Well, it'd be Earl Gray or URL Gray.


00:31:25.660 --> 00:31:27.920
- Of course it would, of course it would.


00:31:27.920 --> 00:31:28.760
Awesome.


00:31:28.760 --> 00:31:29.580
- I love that joke.


00:31:29.580 --> 00:31:32.000
I laughed way too hard when I read that joke


00:31:32.000 --> 00:31:33.000
the first time, so.


00:31:33.000 --> 00:31:34.280
- Yeah, me too, me too.


00:31:34.280 --> 00:31:35.440
It's written, it's even better,


00:31:35.440 --> 00:31:36.800
so check out in the show notes.


00:31:36.800 --> 00:31:39.000
All right, Aiden, thank you for sending that in.


00:31:39.000 --> 00:31:39.840
That's great.


00:31:39.840 --> 00:31:40.660
- Thank you.


00:31:40.660 --> 00:31:41.500
- Yep, thanks, Brian.


00:31:41.500 --> 00:31:42.340
Catch you later.


00:31:42.340 --> 00:31:43.160
See you.


00:31:43.160 --> 00:31:44.000
- Bye.


00:31:44.000 --> 00:31:44.840
Thank you for listening to Python Bytes.


00:31:44.840 --> 00:31:46.480
Follow the show on Twitter @PythonBytes.


00:31:46.480 --> 00:31:49.560
That's Python Bytes, as in B-Y-T-E-S.


00:31:49.560 --> 00:31:52.440
And get the full show notes at pythonbytes.fm.


00:31:52.440 --> 00:31:54.640
If you have a news item you want featured,


00:31:54.640 --> 00:31:57.400
just visit pythonbytes.fm and send it our way.


00:31:57.400 --> 00:31:59.520
We're always on the lookout for sharing something cool.


00:31:59.520 --> 00:32:00.600
This is Brian Okken,


00:32:00.600 --> 00:32:02.680
and on behalf of myself and Michael Kennedy,


00:32:02.680 --> 00:32:04.780
thank you for listening and sharing this podcast


00:32:04.780 --> 00:32:06.440
with your friends and colleagues.

