WEBVTT

00:00:00.001 --> 00:00:05.020
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:05.020 --> 00:00:10.340
This is episode 155, recorded October 30th, 2019.

00:00:10.340 --> 00:00:11.800
I'm Brian Okken.

00:00:11.800 --> 00:00:12.620
And I'm Michael Kennedy.

00:00:12.620 --> 00:00:15.000
And this episode is brought to you by Datadog.

00:00:15.000 --> 00:00:15.980
Thanks, Datadog.

00:00:15.980 --> 00:00:17.260
We'll hear more about them later.

00:00:17.260 --> 00:00:17.820
Absolutely.

00:00:17.820 --> 00:00:20.360
Brian, happy Halloween Eve.

00:00:20.360 --> 00:00:21.060
Oh, right.

00:00:21.060 --> 00:00:21.820
Halloween Eve.

00:00:21.820 --> 00:00:22.940
Spooky.

00:00:22.940 --> 00:00:24.060
I have big news.

00:00:24.060 --> 00:00:26.440
It's not my big news, but I have big news to announce.

00:00:26.440 --> 00:00:28.100
I'm on pins and needles.

00:00:28.100 --> 00:00:34.880
Guido has retired officially from employment, which, you know, congratulations to him.

00:00:34.880 --> 00:00:35.480
That is awesome.

00:00:35.480 --> 00:00:41.820
The news is Guido Van Rassen has left Dropbox, not for another position, but to retire.

00:00:41.820 --> 00:00:43.460
So, you know, I think that's great to hear.

00:00:43.460 --> 00:00:43.860
Okay.

00:00:43.860 --> 00:00:46.120
What does that mean about his involvement in Python?

00:00:46.120 --> 00:00:46.500
Do you know?

00:00:46.500 --> 00:00:48.000
I can only speculate.

00:00:48.000 --> 00:00:53.480
I don't know for sure yet, but my guess is actually that it will mean more Python involvement, not less.

00:00:53.480 --> 00:00:53.880
Okay.

00:00:53.880 --> 00:00:57.700
But that's just based on, I've been at big companies.

00:00:57.700 --> 00:01:00.480
And even when they say, yeah, you can work on whatever you want.

00:01:00.480 --> 00:01:05.600
There's meetings and there's bureaucracy and, you know, the proverbial TPS report.

00:01:05.600 --> 00:01:07.220
He's just like, you know what?

00:01:07.220 --> 00:01:08.400
Okay.

00:01:08.400 --> 00:01:09.380
We're doing nothing today.

00:01:09.380 --> 00:01:13.640
And so if he can work on whatever he wants, I have no idea what he's going to work on, but

00:01:13.640 --> 00:01:15.480
there's got to be some cool creative projects.

00:01:16.260 --> 00:01:17.520
Maybe not next week.

00:01:17.520 --> 00:01:20.700
Maybe he needs a year just to sit on the beach and look at some sunsets.

00:01:20.700 --> 00:01:23.480
But then eventually, I bet he will come back, do something.

00:01:23.480 --> 00:01:24.000
Yeah.

00:01:24.000 --> 00:01:24.540
Okay.

00:01:24.540 --> 00:01:25.960
He deserves a break.

00:01:25.960 --> 00:01:29.980
And you're linking to an article or a post where he announced it also, right?

00:01:29.980 --> 00:01:30.320
Yeah.

00:01:30.320 --> 00:01:36.440
So there's a link to his announcement where he wrote, you know, sort of the goodbye and all that.

00:01:36.440 --> 00:01:42.900
You know, his final project there at Dropbox was really to work on mypy and help them convert to two to three.

00:01:42.900 --> 00:01:44.560
I think it's kind of fitting, right?

00:01:44.560 --> 00:01:52.280
Like one of his final things is to convert one of the largest Python code bases from Python 2 to Python 3 to kind of like close that gap.

00:01:52.280 --> 00:01:55.200
I mean, not globally, but at least in that realm.

00:01:55.200 --> 00:01:55.740
Right.

00:01:55.740 --> 00:02:00.420
You have a, not just his announcement, but a thank you Guido from Dropbox.

00:02:00.420 --> 00:02:01.460
That's kind of cool.

00:02:01.460 --> 00:02:01.840
Yeah.

00:02:01.840 --> 00:02:06.880
So when I wrote this stuff down, it was just, I don't know, half an hour since that news came out.

00:02:06.880 --> 00:02:09.620
And it was just full of responses of so many things.

00:02:09.620 --> 00:02:18.580
So I just grabbed a couple to, you know, I thought maybe a nice way to close out this little section is just to read some of the messages that people wrote to Guido.

00:02:18.580 --> 00:02:18.960
Okay.

00:02:18.960 --> 00:02:21.900
On his Twitter announcement that linked to his full post.

00:02:22.540 --> 00:02:30.340
So, Lucili says, thank you for Python and helping to increase diversity in the teams that you worked with.

00:02:30.340 --> 00:02:31.700
Enjoy your retirement.

00:02:31.700 --> 00:02:35.500
Dharan Liao says, congratulations and best wishes.

00:02:35.500 --> 00:02:39.200
Thanks to the many contributions to open source software and for inspiring me.

00:02:39.200 --> 00:02:43.020
Philip Guo, congrats and best wishes on the next era.

00:02:43.360 --> 00:02:44.460
Someone just goes by Steve.

00:02:44.460 --> 00:02:46.140
Thank you for your contributions to the world.

00:02:46.140 --> 00:02:51.680
My boy was just learning how to code Python as his first programming language as I read this, basically.

00:02:51.680 --> 00:02:54.440
And Freeman Croach, best wishes.

00:02:54.440 --> 00:02:57.780
I literally don't know what my teaching career would have been like without Python.

00:02:57.780 --> 00:02:58.200
Wow.

00:02:58.200 --> 00:03:00.900
I just want to say thanks for everything, Guido.

00:03:00.900 --> 00:03:01.500
That's awesome.

00:03:01.500 --> 00:03:06.400
He's really created something special and he's put a big dent in the universe, obviously.

00:03:06.400 --> 00:03:06.840
Right.

00:03:06.840 --> 00:03:11.940
This is a huge accomplishment of what he's done and what he's shepherded over the last 30 years.

00:03:11.940 --> 00:03:16.940
And it's definitely high time for him to retire just so that he can go and just enjoy that, not stress.

00:03:16.940 --> 00:03:23.040
Like, it's cool that everything is in place that basically this is not like a, oh my God, now what?

00:03:23.040 --> 00:03:25.380
It's just like, oh, okay, well, that's great for him.

00:03:25.380 --> 00:03:25.660
Right.

00:03:25.660 --> 00:03:28.220
Like, we kind of went through that last year, actually.

00:03:28.220 --> 00:03:28.600
Yeah.

00:03:28.600 --> 00:03:30.380
It's an interesting thing.

00:03:30.380 --> 00:03:33.560
And yeah, I don't know what more to add other than also thank you.

00:03:33.560 --> 00:03:33.960
Yeah.

00:03:33.960 --> 00:03:34.580
I love the language.

00:03:34.580 --> 00:03:37.420
We both get to work on some really awesome stuff involving Python.

00:03:37.420 --> 00:03:37.920
Yeah.

00:03:37.920 --> 00:03:39.360
And the community because of it.

00:03:39.360 --> 00:03:40.260
So, yeah, thanks.

00:03:40.260 --> 00:03:40.920
All right.

00:03:40.920 --> 00:03:44.320
Well, speaking of awesome stuff built with Python, what's the next?

00:03:44.320 --> 00:03:46.240
Yeah, hard to transition away from that.

00:03:46.240 --> 00:03:49.680
But I could have swear we'd covered this, but I guess we haven't.

00:03:49.680 --> 00:03:52.040
There's a cool project called Selenium Base.

00:03:52.040 --> 00:04:03.040
And what Selenium is, I mean, most people know it because in the Python community or other places for testing websites and such.

00:04:03.040 --> 00:04:05.200
You can also test APIs with it.

00:04:05.200 --> 00:04:12.200
But the Selenium WebDriver is what people often use to access Selenium through Python.

00:04:12.200 --> 00:04:15.880
And Selenium Base is built on top of that.

00:04:15.880 --> 00:04:22.680
And it's built in conjunction to work with, it works with other things like unit test stuff, but it works best with pytest, of course.

00:04:23.480 --> 00:04:31.420
And it's kind of a layer on top that makes it quite a lot easier to, the Selenium WebDriver right out of the box has a lot of access.

00:04:31.420 --> 00:04:35.700
You can control, basically, you're driving a web browser through from Python.

00:04:36.480 --> 00:04:39.340
And the Selenium Base just makes it easier.

00:04:39.340 --> 00:04:41.060
There's a lot of easier things.

00:04:41.060 --> 00:04:47.300
Like, I'm going to link to, actually, in the show notes, I've got a little snippet of code.

00:04:47.300 --> 00:04:53.960
And it's really easy stuff like open a web page or open with a URL and assert that a title is there.

00:04:53.960 --> 00:04:55.920
And, you know, click on elements.

00:04:55.920 --> 00:05:00.780
And you can use go back and click and examine things and assert stuff.

00:05:01.200 --> 00:05:03.000
It definitely makes for testing.

00:05:03.000 --> 00:05:06.360
Testing web pages is a lot easier with all these utilities.

00:05:06.360 --> 00:05:13.480
But I also wanted to highlight, there's some, I was looking through it the other day, and there's some other things that it does that I thought was kind of interesting.

00:05:13.480 --> 00:05:19.460
One of the things that it has is, well, one, it has support for a lot of the major continuous integration services.

00:05:19.460 --> 00:05:25.980
It also has a plug-in built into it that you can take screenshots of test results.

00:05:25.980 --> 00:05:31.820
So let's say you have a test that fails because, you know, something isn't in the title or something isn't present or something's wrong.

00:05:31.820 --> 00:05:33.640
But what is there?

00:05:33.640 --> 00:05:37.340
And it's hard to describe with code, but it's not too bad with a screenshot.

00:05:37.340 --> 00:05:40.600
So it has the ability to take a screenshot on test failures.

00:05:40.600 --> 00:05:41.440
That's pretty cool.

00:05:41.440 --> 00:05:44.820
I wonder if you could use that as an assert itself.

00:05:44.820 --> 00:05:50.140
If you had a screenshot of the way he said, this page looks right now.

00:05:50.140 --> 00:05:54.120
And if something goes crazy, like the CSS won't load or something is, like,

00:05:54.180 --> 00:05:56.140
could you assert that the pixels are the same?

00:05:56.140 --> 00:05:59.560
I mean, that's sort of visual testing.

00:05:59.560 --> 00:05:59.920
Yeah.

00:05:59.920 --> 00:06:01.560
There is some visual testing with it.

00:06:01.560 --> 00:06:07.200
The main component that it has with it is making sure that the DOM is essentially identical.

00:06:07.200 --> 00:06:10.160
The DOM essentially reproduced the same thing.

00:06:10.160 --> 00:06:13.000
I don't think it does a pixel by pixel comparison.

00:06:13.000 --> 00:06:15.200
Maybe there's some plug-in for it.

00:06:15.200 --> 00:06:16.880
But there is some built-in stuff to do.

00:06:16.880 --> 00:06:19.200
Basically, it should be about the same.

00:06:19.200 --> 00:06:20.720
Some other cool stuff.

00:06:20.840 --> 00:06:23.660
It works with Selenium Grid, which I wasn't quite sure what this was.

00:06:23.660 --> 00:06:31.140
But Selenium has built-in an ability to run Selenium tests on multiple CPUs so that you can do things in parallel.

00:06:31.140 --> 00:06:32.000
Grid computing.

00:06:32.000 --> 00:06:34.720
I want to test all these pages, and it takes a little while.

00:06:34.720 --> 00:06:36.300
So just spread it out.

00:06:36.300 --> 00:06:36.580
Yep.

00:06:36.580 --> 00:06:36.820
Okay.

00:06:36.820 --> 00:06:37.180
That's cool.

00:06:37.180 --> 00:06:38.020
I hadn't heard of that either.

00:06:38.020 --> 00:06:38.460
That's nice.

00:06:38.460 --> 00:06:40.460
The other thing is assisted QA.

00:06:40.460 --> 00:06:47.300
So sometimes it's really easy to have a manual procedure that basically says, you know, we want to throw this together quickly.

00:06:47.300 --> 00:06:49.860
Just look at this page to make sure the graph is there.

00:06:49.860 --> 00:06:51.420
Sometimes it doesn't show up.

00:06:51.420 --> 00:06:52.280
Or, you know, whatever.

00:06:52.280 --> 00:06:52.940
Just make sure.

00:06:52.940 --> 00:06:56.360
And then pop up a little dialog box that says, yes, it's there.

00:06:56.360 --> 00:06:58.040
There is some assisted QA.

00:06:58.040 --> 00:06:59.660
So it's like partial automation.

00:06:59.660 --> 00:07:01.400
And that's kind of neat.

00:07:01.400 --> 00:07:03.860
And I think people poo-poo this too much.

00:07:03.860 --> 00:07:06.620
This is actually very powerful to have in place.

00:07:06.620 --> 00:07:10.280
And sometimes it's a matter of pragmatism of getting things done.

00:07:10.280 --> 00:07:11.600
So this is cool.

00:07:11.600 --> 00:07:15.920
And then one of the other cool things is it has onboarding demos capabilities.

00:07:15.920 --> 00:07:23.680
So since you're using it to drive a web browser, you can use it to highlight things and pop up messages.

00:07:23.680 --> 00:07:29.480
And you can essentially give a kind of an onboarding demo of like how to use a web page.

00:07:29.480 --> 00:07:31.340
So this isn't a testing sort of thing.

00:07:31.340 --> 00:07:35.920
You would create a little demo to show somebody how to use some service.

00:07:36.420 --> 00:07:37.600
So that's kind of neat.

00:07:37.600 --> 00:07:38.340
Yeah, it's super cool.

00:07:38.340 --> 00:07:39.660
This looks really nice.

00:07:39.660 --> 00:07:41.860
I looked at the API that you got here.

00:07:41.860 --> 00:07:48.060
Like if you knew the tiniest bit of programming and you knew CSS, you already understand this.

00:07:48.060 --> 00:07:50.420
It's like there's no documentation needed.

00:07:50.420 --> 00:07:52.640
Obviously, you've got to have some documentation for real.

00:07:52.640 --> 00:07:54.220
But it's super clear.

00:07:54.220 --> 00:07:59.080
It takes away all of like the find item by element and all those sorts of things.

00:07:59.080 --> 00:08:01.100
You don't have to do that too much.

00:08:01.100 --> 00:08:08.720
So anyway, cool thing for if you want to automate a web browser or test a website, make sure you check this out.

00:08:08.720 --> 00:08:09.140
It's good.

00:08:09.140 --> 00:08:10.080
Yeah, it looks great.

00:08:10.080 --> 00:08:10.640
I love it.

00:08:10.640 --> 00:08:11.300
Nice find.

00:08:11.300 --> 00:08:14.140
Well, another thing that's nice is Datadog.

00:08:14.700 --> 00:08:22.720
So this episode is sponsored by Datadog, a cloud scale monitoring platform that unifies metrics, logs, distributed traces, and more.

00:08:22.880 --> 00:08:35.340
Trace requests across service boundaries with flame graphs, correlate traces with logs and metrics, and plot the flow of traffic across multi-cloud environments with network performance monitoring.

00:08:35.340 --> 00:08:41.020
Plus, Datadog integrates with over 350 technologies like Postgres, Redis, and Hadoop.

00:08:41.020 --> 00:08:47.500
And they're tracing client auto instruments, common frameworks, and libraries like Django, Tornado, Flask, and AsyncIO.

00:08:47.500 --> 00:08:48.660
That's cool.

00:08:48.660 --> 00:08:54.480
So get started today with a 14-day free trial at pythonbytes.fm/Datadog.

00:08:54.480 --> 00:08:55.380
Yeah, check them out.

00:08:55.380 --> 00:08:56.460
Big support of the show.

00:08:56.460 --> 00:08:57.220
Thank you, Datadog.

00:08:57.220 --> 00:08:59.260
Yeah, plus I love my purple t-shirt from them.

00:08:59.260 --> 00:08:59.800
It's good.

00:08:59.800 --> 00:09:00.160
For sure.

00:09:00.160 --> 00:09:04.100
Now, this next one, I want to start by asking you a question, Brian.

00:09:04.100 --> 00:09:05.740
You've done a lot of C, C++.

00:09:05.740 --> 00:09:07.320
We even talked about that last time, right?

00:09:07.320 --> 00:09:07.740
Yes.

00:09:07.740 --> 00:09:08.620
Is Python slow?

00:09:08.620 --> 00:09:09.020
No.

00:09:09.020 --> 00:09:10.260
People are slow.

00:09:10.260 --> 00:09:10.620
People are.

00:09:10.620 --> 00:09:11.560
Very good.

00:09:11.560 --> 00:09:12.180
That's a good question.

00:09:12.180 --> 00:09:13.040
Or a good response.

00:09:13.040 --> 00:09:13.400
I like it.

00:09:13.400 --> 00:09:16.640
I think the whether or not Python is slow is a really interesting question.

00:09:16.640 --> 00:09:22.180
And people sometimes say, well, I did a tight loop and I added x plus equals one.

00:09:22.180 --> 00:09:24.240
And it was slower than if I did that on C.

00:09:24.240 --> 00:09:26.320
And so Python is slow, right?

00:09:26.320 --> 00:09:30.040
But then you could also say, well, I have a job.

00:09:30.040 --> 00:09:32.200
Somebody told me to implement this feature.

00:09:32.440 --> 00:09:34.780
If I started in C, I would be done in 10 days.

00:09:34.780 --> 00:09:37.040
If I did it in Python, I'd be done in six hours.

00:09:37.040 --> 00:09:41.360
And it took one minute to run in Python and 30 seconds in C.

00:09:41.360 --> 00:09:43.420
So Python is way faster, right?

00:09:43.420 --> 00:09:47.000
It's half a day or three quarters of a day instead of 10 days.

00:09:47.000 --> 00:09:47.300
Yes.

00:09:47.300 --> 00:09:48.500
That sort of analysis.

00:09:48.500 --> 00:09:52.960
But sometimes it's interesting just to compare directly to these things.

00:09:52.960 --> 00:09:54.820
And we also have the C layer.

00:09:54.820 --> 00:09:57.380
So yeah, sure, it might be slower than some languages.

00:09:57.380 --> 00:10:00.420
But then if you call it NumPy, then it's probably faster than most languages.

00:10:00.420 --> 00:10:02.580
There's all these interesting angles, right?

00:10:02.580 --> 00:10:04.000
Cython and whatnot.

00:10:04.000 --> 00:10:09.440
But this thing that I want to talk about now is this host mortem done by Darren Moffat.

00:10:09.440 --> 00:10:14.540
So he re-implemented the list users command on Solaris.

00:10:14.540 --> 00:10:17.520
It was originally written in C.

00:10:17.520 --> 00:10:19.380
And he rewrote it in Python.

00:10:19.380 --> 00:10:20.400
Okay?

00:10:20.400 --> 00:10:22.100
Which is kind of an interesting thing.

00:10:22.100 --> 00:10:24.760
A couple of stats about it.

00:10:24.760 --> 00:10:26.680
So this is from like 19.

00:10:26.860 --> 00:10:30.660
The last time the C code was touched was like 1988.

00:10:30.660 --> 00:10:34.880
That's 30 years ago, 31 years ago.

00:10:34.880 --> 00:10:36.040
That's a good long while.

00:10:36.040 --> 00:10:41.320
And the implementation of this was about 800 lines.

00:10:41.320 --> 00:10:46.480
And it was written in a time when the number of users were small and things like that.

00:10:46.480 --> 00:10:48.440
So it didn't have to deal with tons of data.

00:10:48.980 --> 00:10:51.040
And it even had some bugs, right?

00:10:51.040 --> 00:10:56.700
But it turned out that the basic implementation of what list users does is a set manipulation.

00:10:56.700 --> 00:10:57.220
Okay.

00:10:57.220 --> 00:10:59.100
You know what language has a really good set implementation?

00:10:59.100 --> 00:10:59.900
Python.

00:10:59.900 --> 00:11:00.620
Indeed.

00:11:01.200 --> 00:11:04.260
So he decided to try to rewrite it in Python.

00:11:04.260 --> 00:11:12.620
And it turns out the rewrite of list users in Python 3 was about a tenth the number of lines of code.

00:11:12.620 --> 00:11:18.140
Instead of 800 lines of probably fairly gnarly C code, it was down to 80 lines of Python.

00:11:18.140 --> 00:11:18.600
Wow.

00:11:18.600 --> 00:11:19.260
That's pretty awesome.

00:11:19.600 --> 00:11:23.720
And a lot of the reason has to do with the fact that like you don't have to reimplement set.

00:11:23.720 --> 00:11:26.500
You just, you know, say the word set and you're good.

00:11:26.500 --> 00:11:33.020
But what's really interesting is on top of that, for 100,000 users, some tests they were doing,

00:11:33.020 --> 00:11:40.220
the Python version was 17 times, 1,700% faster than the C code as well.

00:11:40.220 --> 00:11:40.540
Wow.

00:11:40.540 --> 00:11:41.640
That's incredible.

00:11:41.640 --> 00:11:42.280
Pretty cool, huh?

00:11:42.280 --> 00:11:42.540
Yeah.

00:11:42.540 --> 00:11:44.220
It's actually not surprising to me.

00:11:44.220 --> 00:11:47.720
I'm glad we're covering it because it sure should surprise some people.

00:11:47.840 --> 00:11:49.720
Yeah, it doesn't surprise me all that much either.

00:11:49.720 --> 00:11:51.440
So yeah, it's pretty interesting.

00:11:51.440 --> 00:11:57.800
It turns out that it's source open but not open source if you want to look at the implementation.

00:11:57.800 --> 00:12:03.760
What I mean by that is the list users command is, you know, this is from Oracle, right?

00:12:03.760 --> 00:12:05.780
Like they bought Sun, so now they have Solaris.

00:12:05.780 --> 00:12:13.360
So on 11.4, SRU 9 or higher, you could just go to slash user slash bin slash users and it's a Python file.

00:12:13.360 --> 00:12:14.480
So you just look at it, right?

00:12:14.480 --> 00:12:17.640
So you could see what they're doing and you could compare the code and whatnot.

00:12:17.640 --> 00:12:21.860
But it's not open source and it's covered by the Oracle Solaris license.

00:12:21.860 --> 00:12:24.840
So you can check it out but it's not open source.

00:12:24.840 --> 00:12:25.480
It's sourced open.

00:12:25.480 --> 00:12:26.400
This is cool.

00:12:26.400 --> 00:12:29.800
So not only is this, somebody tried to do it and it was faster.

00:12:29.800 --> 00:12:32.680
It also is shipping now with Solaris.

00:12:32.680 --> 00:12:33.660
Yeah, that's pretty awesome.

00:12:33.660 --> 00:12:35.080
And it's Python 3.

00:12:35.080 --> 00:12:35.580
Of course.

00:12:35.580 --> 00:12:36.060
Of course.

00:12:36.060 --> 00:12:38.360
I bet there's some useful tricks in that code.

00:12:38.360 --> 00:12:39.460
There probably are.

00:12:39.580 --> 00:12:42.280
Actually, I was thinking about this when you brought it up with sets.

00:12:42.280 --> 00:12:45.000
So I admit it.

00:12:45.000 --> 00:12:48.400
I am capable of getting link baited by the occasional listicle.

00:12:48.400 --> 00:12:50.420
And this is definitely one of them.

00:12:50.420 --> 00:12:54.340
It was 20 useful Python tips and tricks that you should know.

00:12:54.340 --> 00:12:58.060
Now, there's some fluff in there that I don't think that's useful.

00:12:58.220 --> 00:13:04.700
But there's a whole bunch of enough that are useful that I think it's a good thing to take a look at.

00:13:04.700 --> 00:13:10.700
Like for one, I'm not sure if – so change assignment is one of the first ones that I looked at.

00:13:10.700 --> 00:13:15.000
And you actually don't – I don't see this in a lot of Python code.

00:13:15.000 --> 00:13:21.540
So is it like bad Python style or something to have like X equals Y equals Z equals 2 or something?

00:13:21.540 --> 00:13:22.260
Do you know?

00:13:22.260 --> 00:13:23.820
I don't know, actually.

00:13:23.820 --> 00:13:24.820
But you're right.

00:13:24.820 --> 00:13:26.540
I remember seeing this a lot in C.

00:13:26.540 --> 00:13:27.260
Yeah.

00:13:27.260 --> 00:13:29.160
But not a lot in Python, no.

00:13:29.160 --> 00:13:30.520
No, but it does work in Python.

00:13:30.520 --> 00:13:34.520
But I guess make sure that you're not doing something that's too unclear.

00:13:34.520 --> 00:13:40.680
I highlighted that mostly because what I do see, what I use a lot is chain comparison.

00:13:40.680 --> 00:13:44.240
And people coming from other languages don't know you can do this.

00:13:44.640 --> 00:13:49.640
So, for instance, in C, if you wanted to have – make sure that X was between 2 and 8,

00:13:49.640 --> 00:13:54.800
you'd have to go 2 is less than X and X is less than 8 or something.

00:13:54.800 --> 00:13:57.980
But with the Python, you can just chain them together and put them together.

00:13:57.980 --> 00:13:58.300
Right.

00:13:58.300 --> 00:14:00.500
Like 2 less than X less than or equal to 8.

00:14:00.500 --> 00:14:00.740
Yeah.

00:14:00.740 --> 00:14:02.760
And you can have a whole bunch of them.

00:14:02.760 --> 00:14:06.940
So you can have like a couple variables within ranges and stuff.

00:14:06.940 --> 00:14:07.440
It's nice.

00:14:07.440 --> 00:14:11.160
Multiple assignment, which I think of as unpacking, I guess.

00:14:11.160 --> 00:14:12.600
Yeah, I think of that as tuple unpacking.

00:14:12.600 --> 00:14:14.060
Definitely that's common, right?

00:14:14.220 --> 00:14:20.020
Like if you're going to do a 4, you know, index, comma, value, and enumerate of collection.

00:14:20.020 --> 00:14:20.840
Something like that.

00:14:20.840 --> 00:14:26.080
Yeah, but the thing that I've been using a lot more lately is tuple unpacking with the star operator.

00:14:26.080 --> 00:14:32.320
So, like if you put a star on one of the things you're unpacking to, it takes all the leftovers.

00:14:33.080 --> 00:14:43.040
And so if you've got a whole bunch of stuff you're unpacking, but you only care about a couple of them, you can name those and then just capture all the rest of them in like a star underscore or something.

00:14:43.040 --> 00:14:44.220
Yeah, then throw away.

00:14:44.220 --> 00:14:47.160
Like I know I have to have a placeholder for this, but I just don't care.

00:14:47.160 --> 00:14:57.100
I've seen it in a couple articles, but it listed merge dictionaries where you do star star of both dictionaries within another like dictionary in brackets.

00:14:57.100 --> 00:14:58.500
And that kind of combines them.

00:14:58.500 --> 00:14:58.720
Yeah.

00:14:58.720 --> 00:15:00.640
Debate as to what you should use.

00:15:00.640 --> 00:15:02.380
But I kind of like that because it's short.

00:15:02.380 --> 00:15:03.020
I like that one.

00:15:03.020 --> 00:15:03.520
Yeah.

00:15:03.600 --> 00:15:03.800
Yeah.

00:15:03.800 --> 00:15:15.980
And then joining strings, people new to Python, it's one of those things that it's nice to, you just take a character or a string and join all the elements in a list or any iterable.

00:15:15.980 --> 00:15:30.400
And this is something that for some reason, especially the people I'm familiar with that come from C or C++ to Python, this is hard for them to get around that strings themselves have object methods on them.

00:15:30.480 --> 00:15:32.960
Isn't it just a character pointer or something like that?

00:15:32.960 --> 00:15:35.820
Like car star, charge star sort of.

00:15:35.820 --> 00:15:36.760
Yeah.

00:15:36.760 --> 00:15:37.040
Yeah.

00:15:37.040 --> 00:15:38.340
They don't think of them as objects.

00:15:38.340 --> 00:15:39.000
Exactly.

00:15:39.000 --> 00:15:41.180
This brings up you said sets before.

00:15:41.180 --> 00:15:49.300
So if you've got a list of things and you want to get the list of unique things, well, you can just convert it to a set and then back to a list.

00:15:49.300 --> 00:15:50.280
And there you go.

00:15:50.280 --> 00:15:50.440
Yeah.

00:15:50.440 --> 00:15:51.160
I do that sometimes.

00:15:51.160 --> 00:15:51.820
It's really nice.

00:15:51.820 --> 00:15:52.920
That's your distinct.

00:15:52.920 --> 00:15:53.100
Yeah.

00:15:53.100 --> 00:15:53.340
Yeah.

00:15:53.340 --> 00:16:00.300
The only thing left that I wanted to mention was using this was something that was difficult for me to get to get my head around.

00:16:00.300 --> 00:16:06.780
was the zip function, mostly because I was familiar with using zip on the command line to actually zip files.

00:16:06.780 --> 00:16:09.640
So no, zip is completely different.

00:16:09.640 --> 00:16:13.440
It kind of pair-wise is up all a bunch of lists of things.

00:16:13.440 --> 00:16:15.800
And I use it all.

00:16:15.800 --> 00:16:20.180
I know really it's hard to explain when you use it, but when you do need it, it's really handy.

00:16:20.340 --> 00:16:20.480
Yeah.

00:16:20.480 --> 00:16:24.400
I feel like the inner tool stuff just has so many things.

00:16:24.400 --> 00:16:27.820
It's always something new to me, you know?

00:16:27.820 --> 00:16:28.520
Yep.

00:16:28.520 --> 00:16:30.360
I'm like, I don't know all this stuff.

00:16:30.360 --> 00:16:31.780
Those are the things I thought were good.

00:16:31.780 --> 00:16:32.960
And it was less than 20.

00:16:32.960 --> 00:16:36.080
The rest of the 20 wasn't that useful to me, but these were neat.

00:16:37.240 --> 00:16:37.560
Yeah.

00:16:37.560 --> 00:16:38.500
No, those are really cool.

00:16:38.500 --> 00:16:42.900
And a lot of times with these listicle type things are like this top 10 or like, I don't know.

00:16:42.900 --> 00:16:44.060
Some of these are cool or whatever.

00:16:44.060 --> 00:16:45.060
Like these all look really great.

00:16:45.060 --> 00:16:45.340
Yeah.

00:16:45.340 --> 00:16:45.720
I like it.

00:16:45.720 --> 00:16:45.960
Yeah.

00:16:45.960 --> 00:16:46.300
Cool.

00:16:46.580 --> 00:16:48.640
So let's talk about waterfalls.

00:16:48.640 --> 00:16:49.140
Okay.

00:16:49.140 --> 00:16:53.260
Now, we've talked a little bit about code complexity on different things.

00:16:53.260 --> 00:16:57.960
I think we've covered Wiley from Anthony Shaw, which is a code complexity analysis tool.

00:16:57.960 --> 00:17:03.980
So here's an article right up sent over by Arem Aref.

00:17:03.980 --> 00:17:08.120
The article is by somebody named Nikita Sobolev.

00:17:08.120 --> 00:17:10.160
And it's called Complexity Waterfalls.

00:17:10.160 --> 00:17:10.920
Pretty interesting.

00:17:11.080 --> 00:17:17.760
It kind of talks about the origins of complexity in our code and just the challenges of how that sneak in.

00:17:17.760 --> 00:17:23.620
And nobody starts out with the intention of writing like bad, hard to understand code.

00:17:23.620 --> 00:17:25.980
You may know you're going down that path.

00:17:25.980 --> 00:17:27.600
He's like, I don't know what I'm doing here.

00:17:27.600 --> 00:17:31.080
But most of the time, it's with good intentions that everything starts out.

00:17:31.080 --> 00:17:35.080
But at some point, it becomes this mess, right?

00:17:35.080 --> 00:17:35.880
Yes.

00:17:35.880 --> 00:17:37.760
Some people are really good at it, too.

00:17:37.760 --> 00:17:39.900
They do have a special skill.

00:17:40.300 --> 00:17:50.400
So this article highlights some of the types of complexity that you might find, how you might address them, some of the tools to actually automatically discover them.

00:17:50.400 --> 00:18:03.440
Two of the core ideas are things that I think will resonate with you, Brian, are continuous refactoring and architecture on demand from using things like tests and continuous integration and whatnot.

00:18:03.860 --> 00:18:09.980
So basically, instead of trying to dream up this perfect architecture, just write stuff in a simple way.

00:18:09.980 --> 00:18:17.960
And as it gets more complex, run some tools, discover the problems, use your unit test to let you refactor and grow the architecture out of it.

00:18:17.960 --> 00:18:18.860
What do you think of that?

00:18:18.860 --> 00:18:20.540
Yeah, I definitely like that a lot.

00:18:20.820 --> 00:18:29.320
And more and more, I'm warming to the idea of using complexity measurements as part of your tools to tell you where to refactor.

00:18:29.320 --> 00:18:29.600
Yeah.

00:18:29.680 --> 00:18:41.540
So one of the things they use in here to talk about the complexity and measure it is this thing called we make dash Python dash style guide, which is actually a linter, not just a guide.

00:18:41.640 --> 00:18:43.100
It's a thing you could run, I believe.

00:18:43.100 --> 00:18:45.260
It actually outputs stuff.

00:18:45.260 --> 00:18:46.080
It's not just a guide.

00:18:46.080 --> 00:18:48.760
And it does pretty interesting stuff.

00:18:48.760 --> 00:19:03.040
So you can run it on your code and it'll say, you know, you're missing white space between your type definition and your type, your variable definition and your type annotation or between a comma or, you know, there's a bunch of different things.

00:19:03.040 --> 00:19:03.520
Right.

00:19:03.520 --> 00:19:06.760
And it brings in some of this, these complexity measures.

00:19:06.760 --> 00:19:09.360
I've heard of, you've heard of psychomatic complexity.

00:19:09.360 --> 00:19:10.980
I know we've talked about that, right?

00:19:10.980 --> 00:19:11.300
Yes.

00:19:11.300 --> 00:19:14.260
We've definitely spoken about lines of code, right?

00:19:14.260 --> 00:19:20.980
Like when the article talks about, hey, here's how individual lines of code become complex.

00:19:20.980 --> 00:19:26.820
Here's how functions become complex or classes or modules or packages and so on.

00:19:26.820 --> 00:19:35.480
And obvious measures or metrics would be if your function is 5,000 lines long, it's wrong.

00:19:35.480 --> 00:19:36.320
I don't know what it does.

00:19:36.320 --> 00:19:39.260
I've never seen it, but I can tell you already it's broken, right?

00:19:39.260 --> 00:19:39.500
Yep.

00:19:39.500 --> 00:19:42.620
These sorts of things are pretty, pretty obvious.

00:19:42.620 --> 00:19:50.520
But one that I don't know that I've ever really paid attention to is something called the, I think it's the Jones, the Jones metric.

00:19:50.520 --> 00:19:51.100
Yeah.

00:19:51.100 --> 00:19:51.900
Jones complexity.

00:19:51.900 --> 00:19:53.180
No, I've never heard of this.

00:19:53.180 --> 00:19:53.460
Yeah.

00:19:53.460 --> 00:19:54.220
So here's the idea.

00:19:54.300 --> 00:20:03.700
Like if you had a line that was 80 lines long, like says, the example they give in the, that Keto gives in the article is by print three long variable names.

00:20:03.980 --> 00:20:04.380
Yeah.

00:20:04.380 --> 00:20:04.420
Yeah.

00:20:04.420 --> 00:20:04.420
Yeah.

00:20:04.420 --> 00:20:04.460
Yeah.

00:20:04.460 --> 00:20:04.460
Yeah.

00:20:04.460 --> 00:20:04.460
Yeah.

00:20:04.460 --> 00:20:04.460
Yeah.

00:20:04.460 --> 00:20:04.460
Yeah.

00:20:04.460 --> 00:20:08.960
So first long name with meaning, second long name with meaning, the third one, and that's 80 lines.

00:20:09.400 --> 00:20:13.400
Or if you say print three calculations, right?

00:20:13.400 --> 00:20:16.560
Like you actually compute three or four things, right?

00:20:16.560 --> 00:20:25.020
Multiply, divide, whatever, multiple things in each of those print, you're still printing three values, but somehow they feel more complex.

00:20:25.020 --> 00:20:35.960
So with the Jones complexity, what it measures is it's like, if I were to take this line of code and parse it into an abstract syntax tree, how many nodes would there be?

00:20:35.960 --> 00:20:36.480
Oh, wow.

00:20:36.480 --> 00:20:36.680
Yeah.

00:20:36.680 --> 00:20:39.920
The first one, there's like four, like we have print and then there's the three things we're printing.

00:20:39.920 --> 00:20:45.720
The other one is like 21 different things are participating in this one line.

00:20:45.720 --> 00:20:46.120
Yeah.

00:20:46.120 --> 00:20:46.420
Right.

00:20:46.420 --> 00:20:53.980
So the reason I bring that up is, for example, the we make thing, I believe will like tell you this has too high of a Jones complexity.

00:20:54.560 --> 00:20:55.040
Right.

00:20:55.040 --> 00:20:55.340
Yeah.

00:20:55.340 --> 00:20:56.040
There's too much.

00:20:56.040 --> 00:20:56.820
It's a line.

00:20:56.820 --> 00:20:57.120
Yeah.

00:20:57.120 --> 00:21:01.920
It says, it'll say things like, we found a line with a high Jones complexity of 15.

00:21:01.920 --> 00:21:02.960
This is an error.

00:21:02.960 --> 00:21:03.760
What should you do?

00:21:03.760 --> 00:21:05.340
And well, what should you do?

00:21:05.340 --> 00:21:08.200
You should break those out into different variables, right?

00:21:08.200 --> 00:21:14.600
You should take those expressions and turn them into three variables and then print them like three variables, one on each line and then print them.

00:21:14.600 --> 00:21:19.780
So there's a lot of concrete little steps about how do you go through and see this complexity?

00:21:19.780 --> 00:21:21.740
What do you do about it?

00:21:21.740 --> 00:21:24.860
And like, how do you kind of evolve your architecture through it?

00:21:24.860 --> 00:21:33.300
So, you know, I don't want to go through all the details in there, but it's a pretty interesting read and it comes up with some good ideas, including pointing out this.

00:21:33.660 --> 00:21:36.100
We make Python style guide.

00:21:36.100 --> 00:21:42.400
One of the things I want to highlight when we're talking about this is that a lot of times it is shifting complexity.

00:21:42.400 --> 00:21:46.840
So, yes, you'll have a very complex bit of something and that's a danger field.

00:21:46.840 --> 00:21:50.740
But to eliminate it, you're going to add complexity somewhere else.

00:21:50.740 --> 00:21:55.380
Because like the example of a 5,000 line function, that's bad.

00:21:55.380 --> 00:22:01.920
But so is 5,000 two line functions that are 5,000 functions deep.

00:22:01.920 --> 00:22:02.260
Sure.

00:22:02.260 --> 00:22:02.780
Yeah.

00:22:02.800 --> 00:22:07.080
If you were to break it into 10 lines, you might end up with a module with 500 functions.

00:22:07.080 --> 00:22:08.320
That's also a bad thing.

00:22:08.320 --> 00:22:08.820
Right.

00:22:08.820 --> 00:22:16.300
And so that's one of the things that I like about these tools is that you can break things out the way you think it's better and then measure it again.

00:22:16.300 --> 00:22:21.580
And also, please have tests in place to make sure that you're not breaking your code while you're refactoring.

00:22:21.720 --> 00:22:21.880
Yeah.

00:22:21.880 --> 00:22:28.180
So one of the things that Nikita talks about is this iterative, continuous refactoring stuff.

00:22:28.180 --> 00:22:34.780
Like, okay, we fixed the Jones complexity of this, but now we've actually changed the complexity of, say, the module.

00:22:34.780 --> 00:22:35.840
How do we fix that?

00:22:35.840 --> 00:22:36.040
Right.

00:22:36.040 --> 00:22:38.200
Like, keep doing it until it gets better.

00:22:38.200 --> 00:22:38.600
Right.

00:22:38.600 --> 00:22:39.120
Yes.

00:22:39.120 --> 00:22:45.680
And I love this because the idea, maybe some people can just think of the right architecture that they're going to need at the end.

00:22:45.680 --> 00:22:46.980
But I never can.

00:22:46.980 --> 00:22:53.040
And so starting small and building up and refactoring where needed, that's the only way I know how to work.

00:22:53.040 --> 00:22:59.680
Well, usually the challenge is you don't have a perfect understanding of the problem you're solving until you're halfway through it.

00:22:59.680 --> 00:23:00.020
Right.

00:23:00.020 --> 00:23:02.480
Well, usually not until I'm completely through it.

00:23:02.480 --> 00:23:03.180
Yeah.

00:23:03.180 --> 00:23:04.180
Yeah, for sure.

00:23:04.180 --> 00:23:07.360
So even if you try to think like, well, maybe I should be more patient.

00:23:07.360 --> 00:23:08.580
I'm going to really think through this.

00:23:08.580 --> 00:23:09.140
Well, maybe.

00:23:09.140 --> 00:23:14.120
But the way you figure out what the solution should be is by going through that step.

00:23:14.640 --> 00:23:17.100
And then there's this iterative fixing process.

00:23:17.100 --> 00:23:25.040
Well, I never understand why some coders and developers think that they really can architect the right solution to begin with.

00:23:25.040 --> 00:23:28.980
It's like expecting a novelist to not write a first draft.

00:23:28.980 --> 00:23:29.240
Yeah.

00:23:29.240 --> 00:23:31.660
To just come up with the final draft at the end.

00:23:31.660 --> 00:23:32.680
It just doesn't work.

00:23:32.680 --> 00:23:32.980
Yeah.

00:23:32.980 --> 00:23:36.360
Even if it can be done, it's probably not the most efficient way to do it.

00:23:36.360 --> 00:23:36.540
Right.

00:23:36.540 --> 00:23:38.320
You just stare at the wall for a week.

00:23:38.320 --> 00:23:38.840
You're like, you know what?

00:23:38.840 --> 00:23:40.280
I wrote it badly in three hours.

00:23:40.280 --> 00:23:41.080
I fixed it in one.

00:23:41.080 --> 00:23:42.020
I went to lunch.

00:23:42.020 --> 00:23:42.260
Right.

00:23:42.260 --> 00:23:42.600
We're good.

00:23:42.600 --> 00:23:43.160
Exactly.

00:23:43.380 --> 00:23:43.660
For sure.

00:23:43.660 --> 00:23:44.080
Cool.

00:23:44.080 --> 00:23:48.780
Well, if they give you care about code complexity and this kind of stuff, this is a pretty good write up.

00:23:48.780 --> 00:23:51.260
And definitely some of the tools mentioned are interesting.

00:23:51.260 --> 00:23:53.140
There's usually advice at each level.

00:23:53.140 --> 00:23:55.560
Like, here's what you do to make a line less complex.

00:23:55.560 --> 00:23:57.580
Here's what you do to make a function less complex.

00:23:57.580 --> 00:24:02.540
I think the advice is generally good, but it can't be taken absolute.

00:24:02.540 --> 00:24:03.520
Absolutely.

00:24:03.520 --> 00:24:03.940
Right.

00:24:03.980 --> 00:24:08.320
Like, it talks about, well, if I have a function, fewer arguments is better.

00:24:08.320 --> 00:24:11.840
If I have a class, fewer methods and fewer fields is better.

00:24:11.840 --> 00:24:17.420
But if you push that to its extreme, you say, well, all my classes have only one field and one public function.

00:24:17.420 --> 00:24:18.140
Like, well, okay.

00:24:18.140 --> 00:24:20.680
It's kind of, you know, now you have a thousand.

00:24:20.680 --> 00:24:22.960
Like, you can't push it to its logical extreme.

00:24:22.960 --> 00:24:23.220
Right.

00:24:23.220 --> 00:24:24.820
It's kind of a give and a take.

00:24:24.820 --> 00:24:27.380
But it's, you know, it points in the right direction, I would say.

00:24:27.380 --> 00:24:27.640
Yep.

00:24:27.640 --> 00:24:29.960
I only have one argument to every function.

00:24:29.960 --> 00:24:32.680
It happens to be a variable length tuple, but.

00:24:32.680 --> 00:24:34.240
Exactly.

00:24:34.240 --> 00:24:34.840
Yeah.

00:24:34.840 --> 00:24:35.200
Cool.

00:24:35.200 --> 00:24:36.400
That's called tuple complexity.

00:24:36.400 --> 00:24:37.460
Tuple complexity.

00:24:37.460 --> 00:24:37.880
Yeah.

00:24:37.880 --> 00:24:39.500
Is that in the list?

00:24:39.500 --> 00:24:40.940
No, it's not, but it is now.

00:24:40.940 --> 00:24:41.760
I'm adding it.

00:24:41.760 --> 00:24:44.160
Have we ever talked about GUIs on this podcast?

00:24:44.160 --> 00:24:48.140
We should totally cover that because Python needs to have more cool GUIs.

00:24:48.140 --> 00:24:48.800
I think so.

00:24:49.000 --> 00:24:50.720
So this one came up recently.

00:24:50.720 --> 00:24:52.780
It's, I don't know how to pronounce it.

00:24:52.780 --> 00:24:54.940
P-L-Y-N-T-H.

00:24:54.940 --> 00:24:55.660
Plinth?

00:24:55.660 --> 00:24:56.340
Plinth?

00:24:56.340 --> 00:24:57.480
I'm going to go with plinth.

00:24:57.480 --> 00:24:58.060
Plinth.

00:24:58.060 --> 00:24:58.600
I could be wrong.

00:24:58.600 --> 00:25:00.200
And I don't mean to make fun of you.

00:25:00.200 --> 00:25:01.000
Plinth.

00:25:01.000 --> 00:25:01.880
I think what it's cool.

00:25:01.880 --> 00:25:03.100
What it is cool.

00:25:03.100 --> 00:25:09.660
So it's a GUI framework for building cross-platform desktop applications with HTML, CSS, and Python.

00:25:09.660 --> 00:25:11.320
Hey, we asked for this.

00:25:11.320 --> 00:25:13.460
But it looks pretty cool.

00:25:13.460 --> 00:25:19.740
It integrates with the standard CPython implementation and the Chromium's rendering engine.

00:25:19.740 --> 00:25:26.300
And you can basically run Python, runs JavaScript and Python all together with Python.

00:25:26.300 --> 00:25:29.100
And it's kind of hard to explain without looking at it.

00:25:29.100 --> 00:25:32.480
But it's sort of a thing that's just starting out.

00:25:32.480 --> 00:25:34.600
And it's not an open source thing.

00:25:34.600 --> 00:25:36.280
It's a group doing this.

00:25:36.280 --> 00:25:37.920
They're going to do it for money.

00:25:37.920 --> 00:25:39.480
But it's not expensive.

00:25:39.480 --> 00:25:43.200
It's free for individuals and including commercial use for individuals.

00:25:43.200 --> 00:25:45.340
And there's a bunch of tutorial videos.

00:25:45.340 --> 00:25:48.180
Now, I'm watching some of the tutorial videos.

00:25:48.180 --> 00:25:51.320
One of them is like implementing a calculator.

00:25:51.320 --> 00:25:54.360
And one of them is like implementing a spinning cubicle.

00:25:54.360 --> 00:25:55.840
Or a cubicle.

00:25:55.840 --> 00:25:56.800
No, a spinning cube.

00:25:56.800 --> 00:25:58.720
But a spinning cubicle, that'd be cool.

00:25:58.720 --> 00:25:59.580
Somebody should do that.

00:25:59.580 --> 00:26:02.940
Now, they clearly know what they're doing when they're writing this.

00:26:02.940 --> 00:26:08.760
And it might be that I'm just not a JavaScript person because the code they're writing doesn't seem obvious to me.

00:26:08.760 --> 00:26:10.220
But it isn't that much.

00:26:10.220 --> 00:26:11.260
So a handful of code.

00:26:11.260 --> 00:26:14.380
A handful of little bits of code and stuff.

00:26:14.380 --> 00:26:18.400
And you can implement something like a calculator on your web browser if you want.

00:26:18.400 --> 00:26:19.500
It's pretty interesting.

00:26:19.500 --> 00:26:21.300
So, yeah, there's a visual calculator.

00:26:21.300 --> 00:26:22.260
I see that.

00:26:22.260 --> 00:26:24.140
And it looks like a desktop app.

00:26:24.140 --> 00:26:25.860
But obviously, we know.

00:26:25.860 --> 00:26:28.780
It's basically the Python equivalent of Electron, right?

00:26:28.780 --> 00:26:31.220
Like HTML and JavaScript and Node.

00:26:31.220 --> 00:26:31.660
Yeah.

00:26:31.820 --> 00:26:42.280
What kind of surprises me here is at least the calculator example is integrated with Vue.js, which is kind of actually super cool.

00:26:42.380 --> 00:26:45.560
So you define a Python class.

00:26:46.260 --> 00:26:50.340
In the Dunder init, it sets up the Vue class.

00:26:50.340 --> 00:26:52.720
And if you've ever done Vue, that looks really familiar.

00:26:52.720 --> 00:26:56.020
You would say, here's the element that is the root of the app.

00:26:56.020 --> 00:26:58.280
Here's some of the bound data.

00:26:58.280 --> 00:26:59.260
Here are some of the methods.

00:26:59.880 --> 00:27:04.640
And then you just point, you basically just set the function to the various Python functions.

00:27:04.640 --> 00:27:05.980
Like they clicked on a number.

00:27:05.980 --> 00:27:06.980
They clicked in an operator.

00:27:06.980 --> 00:27:08.140
I like it.

00:27:08.140 --> 00:27:09.160
This is actually pretty cool.

00:27:09.160 --> 00:27:09.580
Yeah.

00:27:09.580 --> 00:27:10.880
I think it looks neat.

00:27:10.880 --> 00:27:19.340
And it sounds like what they're doing is they're having some way to automatically convert existing JavaScript libraries to Python modules.

00:27:19.340 --> 00:27:19.660
Yeah.

00:27:19.660 --> 00:27:23.360
So you can call them from your Python or hook up to them or something.

00:27:23.360 --> 00:27:24.540
I mean, it's available.

00:27:24.540 --> 00:27:28.720
It looks like it has development kits available right now for Python 3.6 and 3.7.

00:27:29.340 --> 00:27:35.820
And anyway, for somebody wanting to play with GUIs for Python, I think this is something to pay attention to.

00:27:35.820 --> 00:27:36.880
I wish them luck.

00:27:36.880 --> 00:27:39.860
I'm not a zealot for open source only.

00:27:39.860 --> 00:27:42.320
I make money on this by going to work.

00:27:42.320 --> 00:27:44.480
So these people can too as well.

00:27:44.480 --> 00:27:46.520
And I'm over here looking at the pricing.

00:27:46.520 --> 00:27:48.940
Free for individuals for commercial use.

00:27:48.940 --> 00:27:50.020
Academic, it's free.

00:27:50.020 --> 00:27:50.960
Company enterprise.

00:27:50.960 --> 00:27:51.880
Developer license.

00:27:51.880 --> 00:27:56.900
$599 per developer per four years.

00:27:57.600 --> 00:28:00.720
Honestly, they should put another zero on that.

00:28:00.720 --> 00:28:03.180
And I think it would still be okay.

00:28:03.180 --> 00:28:05.620
Because that's totally reasonable.

00:28:05.620 --> 00:28:08.760
It's not like they're saying it's $1,000 per year per developer.

00:28:08.760 --> 00:28:10.140
It's not much.

00:28:10.140 --> 00:28:11.900
So I'm happy to talk about it.

00:28:11.900 --> 00:28:12.580
It looks great to me.

00:28:12.580 --> 00:28:12.840
Yeah.

00:28:12.840 --> 00:28:13.340
It looks neat.

00:28:13.340 --> 00:28:13.800
For sure.

00:28:13.800 --> 00:28:15.700
Well, what do you got on the extras for us, Brian?

00:28:15.700 --> 00:28:17.100
Anything else you want to throw out there?

00:28:17.220 --> 00:28:19.220
Yeah, I want to bring up a couple of things.

00:28:19.220 --> 00:28:24.240
I wanted to thank you for the excellent search feature that we have on Python Bytes.

00:28:24.240 --> 00:28:25.040
You're welcome.

00:28:25.280 --> 00:28:30.040
Because every week, believe it or not, I got to come up with like three items to talk about.

00:28:30.040 --> 00:28:32.400
And sometimes we've already covered it.

00:28:32.400 --> 00:28:34.160
And that was the case this time.

00:28:34.160 --> 00:28:42.840
I ran across another reference to a tool called Cerberus, which is a JSON schema validation tool.

00:28:42.840 --> 00:28:43.840
Yeah, that's a cool one.

00:28:43.840 --> 00:28:44.500
Yeah, I love it.

00:28:44.500 --> 00:28:45.520
It comes from Nikola.

00:28:45.520 --> 00:28:47.400
He built that as part of the EVE framework.

00:28:47.540 --> 00:28:49.440
Okay, well, it's really pretty neat.

00:28:49.440 --> 00:28:54.120
And it has a lot of extensibility features that I haven't seen in other validation tools.

00:28:54.120 --> 00:28:56.420
But we covered it in episode 70.

00:28:56.420 --> 00:28:58.980
And I found that out through your search feature.

00:28:58.980 --> 00:29:02.660
The other thing I wanted to bring up was this funny thing happened.

00:29:02.660 --> 00:29:09.020
I put some, the other day I put used data classes in some test files, test modules,

00:29:09.020 --> 00:29:12.540
because we've converted to Python 3.7 at least.

00:29:12.540 --> 00:29:15.440
I'm using, we're slowly converting to Python 3.8.

00:29:15.980 --> 00:29:18.660
But a colleague of mine looked at my code and said,

00:29:18.660 --> 00:29:20.280
oh, these data class things look cool.

00:29:20.280 --> 00:29:21.720
How did you learn about them?

00:29:21.720 --> 00:29:24.200
I'm like, well, kind of my job.

00:29:24.200 --> 00:29:26.280
It's awesome.

00:29:26.280 --> 00:29:28.460
I didn't say, well, you should listen to Python Bytes,

00:29:28.460 --> 00:29:31.320
because it seems weird to encourage my coworkers to listen to it.

00:29:31.320 --> 00:29:32.140
Send them my way.

00:29:32.140 --> 00:29:33.000
I'll tell them to listen to them.

00:29:33.000 --> 00:29:33.280
Okay.

00:29:33.280 --> 00:29:34.180
Learn about my coworkers.

00:29:34.180 --> 00:29:34.920
I can tell them.

00:29:34.920 --> 00:29:36.840
How about you?

00:29:36.840 --> 00:29:38.320
Got anything extra for us?

00:29:38.320 --> 00:29:39.680
Just something super quick.

00:29:39.680 --> 00:29:40.980
I ran across this article.

00:29:40.980 --> 00:29:43.060
It's not directly related to Python.

00:29:43.060 --> 00:29:45.260
So I didn't make a sort of main item.

00:29:45.460 --> 00:29:51.980
But there's this project from Google where they've been working on the upstream Linux kernel

00:29:51.980 --> 00:29:55.120
using what they have called sanitizers.

00:29:55.120 --> 00:30:01.560
And basically these are like C-Linter type things that go and find problems with the code.

00:30:01.560 --> 00:30:08.340
So they had an address sanitizer for finding memory corruption and undefined behavior for certain code and other issues.

00:30:08.340 --> 00:30:12.200
And then they've come up with this one called the KCSAN.

00:30:12.200 --> 00:30:13.620
I don't know.

00:30:13.620 --> 00:30:16.000
The kernel concurrency sanitizer.

00:30:16.000 --> 00:30:20.660
And they then turned it on the latest Linux kernel.

00:30:20.660 --> 00:30:28.840
And what they found is in a two-day period, they found over 300 unique race conditions and deadlocks and stuff within the mainline kernel of Linux.

00:30:28.840 --> 00:30:29.220
Wow.

00:30:29.380 --> 00:30:33.460
Anyway, there's some comments and stuff about this and links back to what they're doing.

00:30:33.460 --> 00:30:34.640
And it's kind of interesting.

00:30:34.640 --> 00:30:35.360
The code's on GitHub.

00:30:35.360 --> 00:30:38.880
Are they fixing them or just, you know, pointing out problems?

00:30:38.880 --> 00:30:42.960
Well, to point out a problem, like a concurrency problem like that is one thing.

00:30:42.960 --> 00:30:48.640
But to fix it, I think, is a whole entirely another without, you know, causing two more deadlocks somewhere else.

00:30:48.640 --> 00:30:49.620
So I don't know.

00:30:49.700 --> 00:30:51.280
Maybe they're just making people nervous.

00:30:51.280 --> 00:30:55.700
So making people nervous, maybe this joke might, a little bit, probably not.

00:30:55.700 --> 00:30:58.220
But after the one last week, I don't know, man.

00:30:58.220 --> 00:30:59.460
We're pushing the boundaries.

00:30:59.460 --> 00:31:01.460
So let me ask you a question.

00:31:01.460 --> 00:31:08.040
When you talk about a link on the internet and it's, you know, HTTP this or that, you call it a URL or an URL?

00:31:08.040 --> 00:31:09.480
Well, I call it a URL.

00:31:09.480 --> 00:31:09.900
Yeah.

00:31:09.900 --> 00:31:11.060
Some people call it URLs.

00:31:11.060 --> 00:31:12.420
What's the URL for that?

00:31:12.420 --> 00:31:13.260
Some people say URL.

00:31:13.260 --> 00:31:14.720
Anyway, whatever.

00:31:14.720 --> 00:31:17.940
So there's this joke that comes from Aiden Berry.

00:31:18.620 --> 00:31:21.240
Brian, what's a web developer's favorite T?

00:31:21.240 --> 00:31:25.360
Well, it'd be Earl Gray or URL Gray.

00:31:25.360 --> 00:31:27.240
Of course it would.

00:31:27.240 --> 00:31:27.880
Of course it would.

00:31:27.880 --> 00:31:28.180
Awesome.

00:31:28.180 --> 00:31:29.120
I love that joke.

00:31:29.120 --> 00:31:32.640
I laughed way too hard when I read that joke the first time.

00:31:32.640 --> 00:31:33.680
Yeah, me too.

00:31:33.680 --> 00:31:34.160
Me too.

00:31:34.160 --> 00:31:34.740
It's written.

00:31:34.740 --> 00:31:35.360
It's even better.

00:31:35.360 --> 00:31:36.440
So check it out in the show notes.

00:31:36.440 --> 00:31:36.980
All right.

00:31:36.980 --> 00:31:38.980
Aiden, thank you for sending that in.

00:31:38.980 --> 00:31:39.420
That's great.

00:31:39.420 --> 00:31:39.840
Thank you.

00:31:39.840 --> 00:31:40.300
Yep.

00:31:40.300 --> 00:31:40.700
Thanks, Brian.

00:31:40.700 --> 00:31:41.140
Catch you later.

00:31:41.140 --> 00:31:41.600
See you.

00:31:41.600 --> 00:31:41.920
Bye.

00:31:41.920 --> 00:31:43.820
Thank you for listening to Python Bytes.

00:31:43.820 --> 00:31:46.280
Follow the show on Twitter at Python Bytes.

00:31:46.500 --> 00:31:49.300
That's Python Bytes as in B-Y-T-E-S.

00:31:49.300 --> 00:31:52.200
And get the full show notes at Python Bytes.fm.

00:31:52.200 --> 00:31:57.260
If you have a news item you want featured, just visit Python Bytes.fm and send it our way.

00:31:57.260 --> 00:31:59.320
We're always on the lookout for sharing something cool.

00:31:59.320 --> 00:32:00.480
This is Brian Okken.

00:32:00.480 --> 00:32:04.560
And on behalf of myself and Michael Kennedy, thank you for listening and sharing this podcast

00:32:04.560 --> 00:32:05.820
with your friends and colleagues.

