WEBVTT

00:00:00.001 --> 00:00:04.940
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:04.940 --> 00:00:10.360
This is episode 288, recorded June 14th, 2022.

00:00:10.360 --> 00:00:11.460
I'm Michael Kennedy.

00:00:11.460 --> 00:00:12.680
And I am Brian Okken.

00:00:12.680 --> 00:00:13.780
Brian, how are you doing?

00:00:13.780 --> 00:00:15.180
I'm excellent today.

00:00:15.180 --> 00:00:16.440
I hear you're a little busy.

00:00:16.440 --> 00:00:21.680
But it's just, you know, being a parent and having side jobs and stuff like that.

00:00:21.680 --> 00:00:24.080
Of course. Well, it's better than the alternative.

00:00:24.080 --> 00:00:28.280
Definitely. I was talking to somebody this weekend about like their one job

00:00:28.280 --> 00:00:30.160
and trying to balance job and life.

00:00:30.160 --> 00:00:33.060
And I'm like, I don't even remember what that's like with just one job.

00:00:33.060 --> 00:00:36.580
I know. Or you have a job where you go to work and you do the work.

00:00:36.580 --> 00:00:39.820
And then when you go home, there's no real reason to do the job anymore.

00:00:39.820 --> 00:00:41.080
So you can just step away from it.

00:00:41.080 --> 00:00:41.980
It sounds glorious.

00:00:41.980 --> 00:00:45.780
And yet I continue to choose the opposite, which I also love.

00:00:45.780 --> 00:00:50.520
All right. Well, speaking of stuff people might love, you want to kick us off with your first item?

00:00:50.520 --> 00:00:52.200
Yeah, we're going to talk about polar bears.

00:00:52.200 --> 00:00:53.960
No, not polar bears.

00:00:53.960 --> 00:00:55.900
A project called Polars.

00:00:56.280 --> 00:00:59.160
And actually, it's like super fun and cool.

00:00:59.160 --> 00:01:02.840
So Polars was suggested to us by actually several listeners.

00:01:02.840 --> 00:01:05.180
We got several people sent in.

00:01:05.180 --> 00:01:07.440
And I'm sorry, I don't have their names, but thank you.

00:01:07.440 --> 00:01:09.640
Always send great stuff our way.

00:01:09.640 --> 00:01:10.480
We love it.

00:01:10.480 --> 00:01:17.620
But Polars is billed as a lightning fast data frame library for Rust and Python.

00:01:17.620 --> 00:01:21.060
And it is written in Python.

00:01:21.060 --> 00:01:23.140
No, it's written in Rust.

00:01:23.140 --> 00:01:31.600
But they have a full API is present in Python.

00:01:31.600 --> 00:01:34.820
And it's kind of neat, actually, how they've done it.

00:01:34.820 --> 00:01:39.720
So we've got up on the screen the splash screen for the Polars project.

00:01:40.540 --> 00:01:43.080
There's a user guide and API reference, of course.

00:01:43.080 --> 00:01:48.840
But one of the things I wanted to talk about is some of their why you would consider it.

00:01:48.840 --> 00:01:52.020
So Polars is lightning fast data frame library.

00:01:52.020 --> 00:01:54.360
It uses an in-memory query engine.

00:01:54.360 --> 00:01:59.340
And it says it's embarrassingly parallel in execution.

00:01:59.660 --> 00:02:04.580
And it has cache-efficient algorithms and expressive API.

00:02:04.580 --> 00:02:10.460
And they say it makes it perfect for efficient data wrangling, data pipelines, snappy APIs, and so much more.

00:02:10.460 --> 00:02:13.620
But I just also is fun.

00:02:13.620 --> 00:02:16.200
I played with it a little bit.

00:02:16.200 --> 00:02:17.400
It's zippy and fun.

00:02:17.400 --> 00:02:26.780
They have both the ability to do lazy execution and eager execution, whichever you prefer for your use.

00:02:26.780 --> 00:02:28.400
It's multi-threaded.

00:02:28.780 --> 00:02:33.800
It has a notion of single instruction, multiple data.

00:02:33.800 --> 00:02:37.260
I'm not exactly sure what that means, but makes it faster, apparently.

00:02:37.260 --> 00:02:48.040
And I was looking through the whole, the introductory user's guide is actually written like a very well-written book.

00:02:48.040 --> 00:02:53.820
And it looks like the whole guide, as far as I can tell, is written for the Python API.

00:02:53.820 --> 00:02:58.400
So I think that was part of the intent all along, is to write it quickly in Rust.

00:02:58.400 --> 00:03:03.280
expose it to Rust users also, but also run it with Python.

00:03:03.280 --> 00:03:07.980
And it's just really pretty clean and super fast.

00:03:08.120 --> 00:03:16.660
One of these benchmark results performance things was, it's like Spark was taking 332 seconds and they took 43 seconds.

00:03:18.660 --> 00:03:27.080
It's 100 million rows and it's just like, let's load up a couple of pieces of data or something.

00:03:27.080 --> 00:03:27.780
Right.

00:03:27.980 --> 00:03:41.480
So there's a lot of focus on this, making sure that it's fast, especially when you don't need everything, like doing lazy evaluation or making sure you do multiprocessing.

00:03:41.480 --> 00:03:53.920
One of the things I thought was really kind of cool about it, I was looking through the documentation, is there's a section on, that says, it was a section that was talking about parallelization.

00:03:54.060 --> 00:03:56.500
It says, do not kill the parallelization.

00:03:56.500 --> 00:04:07.460
Because with Python, we know we, there is, basically there's ways to use polars that can kill parallel processing because of the gill.

00:04:07.460 --> 00:04:16.280
If you're using, if you don't do it the way they've set it up, you can use it in a way that makes it a little slower, I guess, is what I'm saying.

00:04:16.280 --> 00:04:22.360
But, so there's a section on this talking about the polar expressions, polars expressions.

00:04:22.740 --> 00:04:33.980
And these are all set up so that you can pass these expressive queries into polars and have it run in the background and just make things really fast.

00:04:33.980 --> 00:04:41.400
And sort of skirt around the GIL because you're doing all the work in the Rust part of the world.

00:04:41.400 --> 00:04:44.620
And then collecting the data later.

00:04:44.620 --> 00:04:47.540
So there's like a set up the query and then collect the query.

00:04:47.540 --> 00:04:49.140
That's kind of cool.

00:04:49.140 --> 00:04:52.540
So, anyway, I just thought this is a really, looks fun.

00:04:52.540 --> 00:04:57.460
And it's, it's just a, there's nothing to, you don't have to do, know that it's in Rust.

00:04:57.460 --> 00:05:00.560
You just say pip install polars and it works.

00:05:00.560 --> 00:05:00.980
So.

00:05:00.980 --> 00:05:01.940
Yeah, that's great.

00:05:01.940 --> 00:05:06.080
Out in the audience, Tharab asks, why Rust and not C?

00:05:06.080 --> 00:05:10.300
Maybe an example there is Pandas versus this.

00:05:10.300 --> 00:05:12.860
Also, probably the person who wrote it just really likes Rust.

00:05:12.860 --> 00:05:17.340
And I think Rust has a little bit more thread safety than straight C does.

00:05:17.340 --> 00:05:18.460
I'm not 100% sure.

00:05:18.460 --> 00:05:22.520
But this uses threads, as you point out, whereas the other one, Pandas.

00:05:22.520 --> 00:05:24.000
And others in C don't.

00:05:24.000 --> 00:05:27.560
I also think that we're going to see a lot more of things like this.

00:05:27.560 --> 00:05:37.420
Like, because I think some of the early faster packages for Python were written in C because Rust wasn't around or it wasn't mature enough.

00:05:37.420 --> 00:05:44.940
But I think we're going to see more people saying, well, I want it to be closer to the processor for some of this stuff.

00:05:45.460 --> 00:05:46.560
Why not Rust?

00:05:46.560 --> 00:05:51.100
Because I think Rust is a cleaner development environment than C right now.

00:05:51.100 --> 00:05:52.600
Yeah, I agree.

00:05:52.600 --> 00:05:53.400
Absolutely.

00:05:53.400 --> 00:05:55.280
It's just a more modern language, right?

00:05:55.280 --> 00:05:57.740
You know, C is keeping up.

00:05:57.740 --> 00:06:00.960
C is never going to be old, I don't think.

00:06:00.960 --> 00:06:01.640
But yeah.

00:06:01.640 --> 00:06:02.160
Yeah.

00:06:02.480 --> 00:06:02.840
Yeah, yeah.

00:06:02.840 --> 00:06:06.920
I don't mean to say that C is out, not modern in the sense that people are not using it.

00:06:06.920 --> 00:06:12.600
But it doesn't embrace in its sort of natural form the most, you know, smart pointers and things like that.

00:06:12.600 --> 00:06:12.880
Yeah.

00:06:12.880 --> 00:06:14.940
And there's C++ maybe, but not C.

00:06:14.940 --> 00:06:21.520
There's safety features built into Rust to make sure you don't, just make it easier to not do dumb things.

00:06:21.820 --> 00:06:22.640
I guess.

00:06:22.640 --> 00:06:23.440
Let's put it that way.

00:06:23.440 --> 00:06:25.080
Indeed.

00:06:25.080 --> 00:06:25.740
All right.

00:06:25.740 --> 00:06:29.460
Well, let's jump on to my first item, which is a follow up from last week.

00:06:29.460 --> 00:06:31.620
Python developer survey 2021.

00:06:31.620 --> 00:06:33.100
Yes, you heard that right.

00:06:33.100 --> 00:06:33.880
I know it's 2022.

00:06:33.880 --> 00:06:36.440
These are the results from the survey that was at the end of last year.

00:06:36.440 --> 00:06:42.700
So let's, I'm going to kind of skim through this and just hit on some of the main ideas here.

00:06:42.700 --> 00:06:46.460
There's a ton of information and I encourage people to go over and scroll through it.

00:06:46.460 --> 00:06:51.620
This is done in conjunction with the folks over at JetBrains, the PyCharm team and all that.

00:06:51.620 --> 00:06:58.320
So it was collected and analyzed by the JetBrains folks, but put together independently by the PSF, right?

00:06:58.320 --> 00:07:01.540
So it's intended to not be skewed in any way towards them.

00:07:01.540 --> 00:07:02.080
All right.

00:07:02.080 --> 00:07:06.700
So first thing is if you're using Python, is it your main language or your secondary language?

00:07:06.700 --> 00:07:12.260
84% of the people say it's their main language with 16% picking up the balance of not so much.

00:07:12.260 --> 00:07:14.300
It's been pretty stable over the last four years.

00:07:14.300 --> 00:07:15.080
What do you think of this, Brian?

00:07:15.080 --> 00:07:20.380
I think that there's a lot of people like me.

00:07:20.540 --> 00:07:24.780
I think that it started out as my secondary language and now it's my main language.

00:07:24.780 --> 00:07:25.940
Yeah.

00:07:25.940 --> 00:07:26.460
Interesting.

00:07:26.460 --> 00:07:27.000
Yeah.

00:07:27.000 --> 00:07:27.960
And it got sucked in.

00:07:27.960 --> 00:07:29.760
Like, ah, maybe I'll use it to test my C stuff.

00:07:29.760 --> 00:07:30.980
Wait, actually, this is kind of nice.

00:07:30.980 --> 00:07:31.800
Maybe I'll do more of this.

00:07:31.800 --> 00:07:32.020
Yeah.

00:07:32.020 --> 00:07:39.160
There's always the next question or analysis is always fraught with weird overlaps.

00:07:39.380 --> 00:07:42.880
But I like the way they ask this a little bit better than a lot of times.

00:07:42.880 --> 00:07:45.080
It says Python usage with other languages.

00:07:45.080 --> 00:07:47.120
What other languages do you use Python with?

00:07:47.120 --> 00:07:51.820
Rather than maybe a more general one where they ask, well, what is the most popular language?

00:07:51.820 --> 00:07:54.640
And you'll see weird stuff like, well, most people code in CSS.

00:07:54.640 --> 00:07:57.360
Like, I'm a full stack CSS developer.

00:07:57.360 --> 00:07:58.080
Like, no, you're not.

00:07:58.120 --> 00:07:59.180
Just everyone has to use it.

00:07:59.180 --> 00:07:59.840
Like, what is this?

00:07:59.840 --> 00:08:00.840
It's a horrible question.

00:08:00.840 --> 00:08:01.800
Right.

00:08:01.800 --> 00:08:05.180
So this is like, if you're doing Python, what other languages do you bring into the mix?

00:08:05.180 --> 00:08:07.240
And I guess maybe just hit the top five.

00:08:07.240 --> 00:08:09.840
JavaScript, because you might be doing front and back end.

00:08:09.840 --> 00:08:11.660
HTML, CSS, same reason.

00:08:11.660 --> 00:08:14.560
Bash shell, because you're doing automation build, so on.

00:08:14.560 --> 00:08:15.020
SQL.

00:08:15.020 --> 00:08:15.720
SQL.

00:08:15.720 --> 00:08:19.260
I'm surprised there's that much direct SQL, but there it is.

00:08:19.260 --> 00:08:21.640
And then C and C++, speaking of that language.

00:08:21.640 --> 00:08:27.480
Also, to sort of address the thing that I brought up before, Rust is at 6%.

00:08:27.480 --> 00:08:28.960
Last year, it was at 5%.

00:08:28.960 --> 00:08:30.860
So it's compared to C at 30.

00:08:30.860 --> 00:08:33.240
And 29, so they both grew by 1% this year.

00:08:33.240 --> 00:08:33.800
Okay.

00:08:33.800 --> 00:08:34.340
Yeah.

00:08:34.340 --> 00:08:36.260
I think they both grew.

00:08:36.260 --> 00:08:36.900
That's interesting.

00:08:36.900 --> 00:08:37.920
Yeah, exactly.

00:08:37.920 --> 00:08:43.640
Another thing that people might want to pay attention to is you'll see year over year stuff

00:08:43.640 --> 00:08:46.240
all over the place in these reports, because they've been doing this for a while.

00:08:46.240 --> 00:08:53.160
So like the top bar that's darker or sorry, brighter is this year, but they always also

00:08:53.160 --> 00:08:54.100
put last year.

00:08:54.100 --> 00:08:56.580
So for example, people are doing less bash.

00:08:56.580 --> 00:09:00.300
You can see like it's lower bar is higher and they're doing less PHP.

00:09:00.300 --> 00:09:03.140
Probably means they love themselves a little bit more.

00:09:03.140 --> 00:09:05.860
Don't go home crying.

00:09:05.860 --> 00:09:06.120
Okay.

00:09:06.120 --> 00:09:07.780
Let's see.

00:09:07.780 --> 00:09:09.920
Languages for web and data science.

00:09:09.920 --> 00:09:13.240
This is kind of like if you're doing these things, what to use more.

00:09:13.240 --> 00:09:16.840
So if you're doing data science, you do more SQL is your most common thing.

00:09:16.840 --> 00:09:21.940
If you're doing web surprise, JavaScript and HTML is the most common other thing.

00:09:21.940 --> 00:09:22.400
Yeah.

00:09:22.400 --> 00:09:23.460
Let's see.

00:09:23.460 --> 00:09:25.380
What do you use Python for?

00:09:25.380 --> 00:09:27.200
Work and personal is 50%.

00:09:27.200 --> 00:09:30.160
Personal is 29 and work 20%.

00:09:30.160 --> 00:09:34.120
Kind of interesting that more people use it for side projects.

00:09:34.120 --> 00:09:37.500
If they use it for just one or the other of work or personal.

00:09:37.500 --> 00:09:40.200
I guess people who know Python at work, they want to go home.

00:09:40.200 --> 00:09:40.660
They're like, you know what?

00:09:40.660 --> 00:09:41.940
I could automate my house with this too.

00:09:42.020 --> 00:09:42.400
Let's do that.

00:09:42.400 --> 00:09:45.420
I think that, yeah, I would take it like that.

00:09:45.420 --> 00:09:48.020
I think more people, it isn't just even automated your house.

00:09:48.020 --> 00:09:49.560
It's just playing around with it at home.

00:09:49.560 --> 00:09:53.180
Like, yeah, I heard about this, this new web framework, FastAPI.

00:09:53.180 --> 00:09:54.180
I want to try it out.

00:09:54.180 --> 00:09:55.220
Things like that.

00:09:55.220 --> 00:09:55.480
So.

00:09:55.480 --> 00:09:56.440
Yeah, absolutely.

00:09:56.440 --> 00:09:58.980
I'm going to skip down here through a bunch of stuff.

00:09:58.980 --> 00:10:01.580
What do you use Python for the most?

00:10:01.580 --> 00:10:04.200
Web development, but that fell year over year.

00:10:04.200 --> 00:10:06.840
Data analysis stayed the same year over year.

00:10:06.840 --> 00:10:08.520
Machine learning fell year over year.

00:10:08.880 --> 00:10:09.920
And a bunch of stuff.

00:10:09.920 --> 00:10:14.860
But so sort of the growth areas year over year are education and desktop development.

00:10:14.860 --> 00:10:17.860
And then other, I think it's pretty.

00:10:17.860 --> 00:10:19.500
Also game development doubled.

00:10:19.500 --> 00:10:21.260
Doubled from one to two percent.

00:10:21.260 --> 00:10:25.260
I mean, from one to two is probably like there was, you know, that might be within the margin

00:10:25.260 --> 00:10:26.180
of error type of thing.

00:10:26.180 --> 00:10:27.180
But still, it doubled.

00:10:27.180 --> 00:10:28.780
But I think just the other.

00:10:28.780 --> 00:10:30.420
No, other didn't grow.

00:10:30.420 --> 00:10:31.840
There's just, I think it's just more spread out.

00:10:31.840 --> 00:10:32.340
I don't know.

00:10:32.380 --> 00:10:34.480
Because there's still, I think, same number of people using Python.

00:10:34.480 --> 00:10:34.980
All right.

00:10:34.980 --> 00:10:36.220
Are you a data scientist?

00:10:36.220 --> 00:10:37.660
One third, yes.

00:10:37.660 --> 00:10:38.480
Two thirds, no.

00:10:38.480 --> 00:10:42.180
That's that fits with my mental model of the Python space.

00:10:42.180 --> 00:10:47.320
One third data science, one third web and API, and one third massively diverse other.

00:10:47.320 --> 00:10:48.920
The way I see the ecosystem.

00:10:48.920 --> 00:10:50.920
Python three versus two.

00:10:51.040 --> 00:10:55.920
I think we're asymptotically as a limit approaching Python three only.

00:10:55.920 --> 00:11:03.180
But year over year, it goes 25% from 2017, then 16% Python two, then 10%, then six, then

00:11:03.180 --> 00:11:03.560
five.

00:11:03.560 --> 00:11:06.820
And then there's just huge code bases that are stuck on Python two.

00:11:06.820 --> 00:11:12.420
Like some of the big banks have like 5,000 Python developers working on Python two code bases

00:11:12.420 --> 00:11:16.380
that are so specialized and tweaked that they can't just swap out stuff.

00:11:16.380 --> 00:11:19.180
So, you know, that might represent 5% bank usage.

00:11:19.180 --> 00:11:19.660
I don't know.

00:11:19.660 --> 00:11:23.860
I just, I feel bad for you.

00:11:23.860 --> 00:11:25.320
We're rooting for you.

00:11:25.320 --> 00:11:27.320
Everybody out there using Python two.

00:11:27.320 --> 00:11:28.480
Stick in there.

00:11:28.480 --> 00:11:29.480
Let's approach that limit.

00:11:29.480 --> 00:11:30.080
Yeah, yeah.

00:11:30.080 --> 00:11:32.920
Let's divide by n factorial, not n for your limit there.

00:11:32.920 --> 00:11:33.280
Let's go.

00:11:33.280 --> 00:11:33.860
Get in there.

00:11:33.860 --> 00:11:34.440
All right.

00:11:34.440 --> 00:11:37.660
Python three nine is the most common version.

00:11:37.660 --> 00:11:42.600
Three 10 being 16% and three eight being 27% versus 35.

00:11:42.600 --> 00:11:44.360
So that's, that's pretty interesting.

00:11:44.360 --> 00:11:44.940
Yeah.

00:11:44.940 --> 00:11:47.780
I feel like this is, hey, this is what comes with my Linux.

00:11:47.780 --> 00:11:49.320
This is what comes with my Docker.

00:11:49.440 --> 00:11:51.500
So I'm using that, but maybe it's more.

00:11:51.500 --> 00:11:52.260
Yeah.

00:11:52.260 --> 00:11:56.360
It's interesting because you and I like our interesting space because we're always looking

00:11:56.360 --> 00:11:57.220
at the new stuff.

00:11:57.220 --> 00:12:00.760
So I, I'm at, I'm at three 10 and I can't wait to jump to three 11.

00:12:00.760 --> 00:12:01.940
Yeah.

00:12:01.940 --> 00:12:05.040
And actually I've switched to three 11 for some projects.

00:12:05.040 --> 00:12:09.580
So, but there's a lot of people that was like, man, Python's pretty good.

00:12:09.580 --> 00:12:11.060
And then it's been good for a while.

00:12:11.060 --> 00:12:13.380
So I don't need a lot of the new features.

00:12:13.380 --> 00:12:14.100
So.

00:12:14.100 --> 00:12:15.460
Yeah, for sure.

00:12:15.460 --> 00:12:19.980
I'm going to later talk about something that might shift that.

00:12:19.980 --> 00:12:20.460
Yeah.

00:12:20.460 --> 00:12:21.280
To the right.

00:12:22.100 --> 00:12:25.020
I've actually been thinking like, should I maybe install three 11 beta?

00:12:25.020 --> 00:12:27.200
See how stable that is on the servers.

00:12:27.200 --> 00:12:28.780
We'll see.

00:12:28.780 --> 00:12:29.660
That might be a bad choice.

00:12:29.660 --> 00:12:31.080
Might be a good choice.

00:12:31.080 --> 00:12:32.160
That's what's okay.

00:12:32.160 --> 00:12:34.120
Uh, where do you install Python from?

00:12:34.120 --> 00:12:35.080
38%?

00:12:35.080 --> 00:12:37.960
Just download the thing from Python.org and run with that.

00:12:37.960 --> 00:12:38.340
Yeah.

00:12:38.620 --> 00:12:46.240
The next most common option is, to install it via your OS package manager, apt, homebrew,

00:12:46.240 --> 00:12:46.620
whatever.

00:12:46.620 --> 00:12:47.320
Yeah.

00:12:47.320 --> 00:12:51.300
And Alvaro has a great little recommendation out there for people who are stuck on Python

00:12:51.300 --> 00:12:51.640
too.

00:12:51.640 --> 00:12:54.600
There probably is a support group for Python two users.

00:12:54.600 --> 00:12:57.140
Hi, my name is Brian and I use Python too.

00:12:57.140 --> 00:12:59.880
Hi, Brian.

00:12:59.880 --> 00:13:02.340
All right.

00:13:02.340 --> 00:13:08.520
Another one I thought was pretty interesting is, the packaging stuff, the isolation stuff,

00:13:08.600 --> 00:13:13.100
um, before we get there really quick, web frameworks, FastAPI continues to grow.

00:13:13.100 --> 00:13:13.760
Yeah.

00:13:13.760 --> 00:13:15.140
Pretty strong here.

00:13:15.140 --> 00:13:22.280
We've got Flask is now maybe within the margin error, but just edged ahead of Django, but fast

00:13:22.280 --> 00:13:25.180
API almost doubled in usage over the last year.

00:13:25.180 --> 00:13:28.060
It grew nine percentage points, but it was at 12% last year.

00:13:28.060 --> 00:13:32.360
And so now it's at 21%, which is, that's a pretty big chunk to take out of established

00:13:32.360 --> 00:13:32.740
frameworks.

00:13:32.740 --> 00:13:33.260
Yeah.

00:13:33.260 --> 00:13:36.060
Well, and it looks like the third is none.

00:13:36.060 --> 00:13:37.440
I haven't tried that yet.

00:13:38.300 --> 00:13:38.560
Yeah.

00:13:38.560 --> 00:13:42.360
It gets a lot of attribute errors, but it's, it's really efficient because it doesn't do

00:13:42.360 --> 00:13:42.760
much work.

00:13:42.760 --> 00:13:43.040
Yeah.

00:13:44.040 --> 00:13:44.400
Yeah.

00:13:44.400 --> 00:13:48.640
People, who maybe don't know FastAPI, the name would indicate it's only for building

00:13:48.640 --> 00:13:51.360
APIs, but you can build web apps with it as well.

00:13:51.360 --> 00:13:52.380
And it's pretty good at that.

00:13:52.380 --> 00:13:59.040
Especially if you check out Michael's courses, he's got like two courses on building web apps

00:13:59.040 --> 00:14:00.320
with the fast eggs.

00:14:00.500 --> 00:14:01.500
I do.

00:14:01.500 --> 00:14:01.500
I do.

00:14:01.500 --> 00:14:04.680
And I also have a, some, some sort of template extensions for it that make it easier.

00:14:04.680 --> 00:14:05.220
All right.

00:14:05.220 --> 00:14:06.360
Data science libraries.

00:14:06.360 --> 00:14:08.360
Um, I don't know how I feel about this one.

00:14:08.360 --> 00:14:09.040
Do you use NumPy?

00:14:09.040 --> 00:14:12.160
Well, yes, but if you use other libraries, then you also use NumPy.

00:14:12.160 --> 00:14:14.980
So yeah, it's like all of these are using NumPy.

00:14:14.980 --> 00:14:16.460
So exactly.

00:14:16.460 --> 00:14:17.600
Exactly.

00:14:17.600 --> 00:14:18.100
Yeah.

00:14:18.480 --> 00:14:19.840
Uh, a bunch of other stuff.

00:14:19.840 --> 00:14:21.080
Look at that for unit testing.

00:14:21.080 --> 00:14:22.700
Would it surprise you that pytest is winning?

00:14:22.700 --> 00:14:23.580
No.

00:14:23.580 --> 00:14:26.140
They just overtook Num this year, didn't it?

00:14:26.140 --> 00:14:30.940
Uh, yeah.

00:14:30.940 --> 00:14:31.880
So.

00:14:31.880 --> 00:14:32.620
All right.

00:14:32.620 --> 00:14:37.800
Uh, ORMs, SQLAlchemy is ahead and then there's, Django ORM.

00:14:37.800 --> 00:14:39.280
Django is tied to Django.

00:14:39.280 --> 00:14:40.380
SQLAlchemy is broad.

00:14:40.380 --> 00:14:41.500
So there's, there's that.

00:14:41.500 --> 00:14:45.800
And then kind of the none of the ORM world is raw SQL at 16%.

00:14:45.800 --> 00:14:46.620
That's pretty interesting.

00:14:47.060 --> 00:14:51.400
Postgres is the most common database by far at 43%.

00:14:51.400 --> 00:14:54.060
Then you have SQLite, which is a little bit of a side case.

00:14:54.060 --> 00:14:56.160
You can use it directly, but it's also used for development.

00:14:56.160 --> 00:14:59.920
And then MySQL, the MongoDB, and then Redis and Microsoft SQL Server.

00:14:59.920 --> 00:15:00.260
So.

00:15:00.260 --> 00:15:00.800
Yeah.

00:15:00.800 --> 00:15:01.320
Huh.

00:15:01.320 --> 00:15:05.260
Actually SQL Server and Oracle are higher than I would have expected, even though, you know,

00:15:05.260 --> 00:15:06.180
but it's okay.

00:15:06.180 --> 00:15:10.480
Well, I think what you're going to find is that there's like certain places, especially

00:15:10.480 --> 00:15:15.420
in the enterprise where it's like, we're a SQL Server shop or we're an Oracle shop and

00:15:15.420 --> 00:15:16.860
our DBAs manage our databases.

00:15:16.860 --> 00:15:21.220
So here you, you put in a, you file a ticket and they'll create a database for you.

00:15:21.220 --> 00:15:21.480
Yeah.

00:15:21.480 --> 00:15:25.460
Or there's a, there's already an existing database and you're connecting to it or something.

00:15:25.460 --> 00:15:25.900
Yep.

00:15:25.900 --> 00:15:26.260
Yep.

00:15:26.260 --> 00:15:26.780
Exactly.

00:15:26.780 --> 00:15:27.420
Exactly.

00:15:27.420 --> 00:15:28.020
All right.

00:15:28.020 --> 00:15:28.780
Let's keep going.

00:15:28.780 --> 00:15:29.920
Cloud platforms.

00:15:29.920 --> 00:15:31.880
AWS is at the top.

00:15:31.880 --> 00:15:36.860
Then you've got Google cloud at 50% and then GCP, Google cloud platform, then Azure, then

00:15:36.860 --> 00:15:38.100
Heroku, DigitalOcean.

00:15:38.100 --> 00:15:39.780
Linode has made it on the list here.

00:15:39.960 --> 00:15:45.280
So, you know, a former or sometimes sponsor of the show, it's good for them.

00:15:45.280 --> 00:15:48.420
And let's see, do you run, how do you run stuff in the cloud?

00:15:48.420 --> 00:15:49.200
Let's skip over this.

00:15:49.200 --> 00:15:53.160
I think a bunch of interesting, a few more interesting things and we'll, we'll call it compared to

00:15:53.160 --> 00:16:00.400
2020 Linux and macOS popularity decreased by 5% while windows usage has risen by 10%.

00:16:00.400 --> 00:16:00.920
Wow.

00:16:00.920 --> 00:16:01.500
Yeah.

00:16:01.500 --> 00:16:06.160
Where the windows people now double more than double the macOS people and are almost rivaling

00:16:06.160 --> 00:16:06.780
the Linux people.

00:16:06.780 --> 00:16:10.600
That's, I think that's just, towards the growth of Python.

00:16:10.600 --> 00:16:16.040
Uh, I think, Python's just making it more into everybody's using it sort of thing.

00:16:16.040 --> 00:16:16.440
Yeah.

00:16:16.440 --> 00:16:18.960
And there's also a windows subsystem for Linux.

00:16:18.960 --> 00:16:24.200
It's been coming along pretty strong, which makes windows a more viable, more on have, have

00:16:24.200 --> 00:16:26.300
more parity with your cloud targets.

00:16:26.300 --> 00:16:26.520
Right.

00:16:26.520 --> 00:16:27.120
Yeah.

00:16:27.120 --> 00:16:29.720
And it feels like out in the audience is because of WSL.

00:16:29.720 --> 00:16:29.940
Yeah.

00:16:29.940 --> 00:16:30.240
Maybe.

00:16:30.240 --> 00:16:30.680
Yeah.

00:16:30.680 --> 00:16:31.300
Okay.

00:16:31.300 --> 00:16:33.280
Uh, let's see a few more things.

00:16:33.280 --> 00:16:34.080
Documentation.

00:16:34.080 --> 00:16:34.440
It's cool.

00:16:34.440 --> 00:16:36.400
They're asking about like what documentation frameworks you use.

00:16:36.400 --> 00:16:38.000
This one's interesting to me.

00:16:38.000 --> 00:16:40.920
What's your main editor, VS Code or PyCharm?

00:16:40.920 --> 00:16:44.460
I asked this question a lot at the end of talk Python and it feels like VS Code, VS Code,

00:16:44.460 --> 00:16:49.140
VS Code, VS Code is what people are saying all the time, but it's 35% VS Code, 31% PyCharm

00:16:49.140 --> 00:16:50.540
and Brian right there for you.

00:16:50.540 --> 00:16:52.040
7% Vim, but.

00:16:52.040 --> 00:16:53.420
Okay.

00:16:53.420 --> 00:16:54.420
Yeah.

00:16:54.420 --> 00:16:55.860
I just teased you.

00:16:55.860 --> 00:16:56.180
Yeah.

00:16:56.180 --> 00:16:59.280
To be fair, it's both VS Code.

00:16:59.280 --> 00:17:00.220
It's, it's, it's all three.

00:17:00.220 --> 00:17:00.660
Yeah.

00:17:00.660 --> 00:17:01.340
Or top.

00:17:01.340 --> 00:17:01.700
Yeah.

00:17:01.700 --> 00:17:03.560
Top four for me, but yeah.

00:17:03.560 --> 00:17:04.420
Yeah, exactly.

00:17:04.420 --> 00:17:07.780
Well, often you probably just use Vim bindings within the other two, right?

00:17:07.780 --> 00:17:08.020
Yep.

00:17:08.020 --> 00:17:08.440
Yeah.

00:17:08.740 --> 00:17:09.640
Let's see.

00:17:09.640 --> 00:17:17.120
I think also maybe another interesting breakdown is that if you look at the usage scenarios

00:17:17.120 --> 00:17:21.620
or the type of development done with the editors, you get different answers.

00:17:21.620 --> 00:17:28.960
So like for data science, you've got more PyCharm and for web development, I think, hold on,

00:17:28.960 --> 00:17:29.420
I have that right.

00:17:29.420 --> 00:17:30.400
Oh, interesting.

00:17:30.400 --> 00:17:32.440
For data science, you have a lot more VS Code.

00:17:32.440 --> 00:17:36.860
For web development, you have more PyCharm and you have a lot less other in data science,

00:17:36.860 --> 00:17:37.920
AKA Jupyter.

00:17:38.180 --> 00:17:39.140
I suspect it.

00:17:39.140 --> 00:17:39.820
Yeah.

00:17:39.820 --> 00:17:39.900
Yeah.

00:17:39.900 --> 00:17:40.520
Okay.

00:17:40.520 --> 00:17:42.220
How did you learn about your editor?

00:17:42.220 --> 00:17:43.040
By far?

00:17:43.040 --> 00:17:45.360
Or first one here is from a friend.

00:17:45.360 --> 00:17:49.360
So basically friends like push editors, like drug dealers, like gotta get out.

00:17:49.360 --> 00:17:50.120
What are you doing on that thing?

00:17:50.120 --> 00:17:50.520
Get in here.

00:17:50.620 --> 00:17:55.880
No, I think it's like, if I'm, if I'm watching somebody do something cool, I want to do it

00:17:55.880 --> 00:17:57.220
also because it looks helpful.

00:17:57.220 --> 00:17:57.680
Yeah, exactly.

00:17:57.680 --> 00:17:59.780
You sit down next to your friend and you're like, how did you do that?

00:17:59.780 --> 00:18:00.400
That's awesome.

00:18:00.400 --> 00:18:01.440
I want that feature, right?

00:18:01.440 --> 00:18:02.460
I think you're probably right.

00:18:02.460 --> 00:18:03.080
Okay.

00:18:03.080 --> 00:18:05.080
Let's just bust down a few things better.

00:18:05.080 --> 00:18:09.700
One, do you know, or what do you think about the new developer in residence role?

00:18:09.700 --> 00:18:12.420
This is Lucas Schillinga that's going on right now.

00:18:12.420 --> 00:18:14.560
77% are like, the what?

00:18:14.560 --> 00:18:16.440
Never heard of it.

00:18:18.060 --> 00:18:23.100
Maybe like we got, we got a little more advocacy job to do here, but he's been doing a great

00:18:23.100 --> 00:18:28.680
job really speeding things up and sort of greasing the wheels of open source contributions

00:18:28.680 --> 00:18:29.280
and whatnot.

00:18:29.280 --> 00:18:35.460
I, yeah, I'm going to take it like design because if design's done well, nobody knows it's there.

00:18:35.460 --> 00:18:37.440
And yeah, I think the same thing.

00:18:37.440 --> 00:18:41.160
I think if he's doing his job really, really well, most people won't notice things will

00:18:41.160 --> 00:18:41.620
just work.

00:18:41.620 --> 00:18:42.060
Yep.

00:18:42.060 --> 00:18:43.180
Yeah.

00:18:43.180 --> 00:18:44.860
Quick real time follow up.

00:18:44.860 --> 00:18:46.940
Felix out in the audience says, I use PyCharm because of Michael.

00:18:47.660 --> 00:18:53.180
It should have been one of the options in the survey because of Michael.

00:18:53.180 --> 00:18:54.760
Oh, come on.

00:18:54.760 --> 00:18:55.220
That's awesome.

00:18:55.220 --> 00:18:57.360
But no, let's see.

00:18:57.360 --> 00:18:58.600
There's a bunch of questions about that.

00:18:58.600 --> 00:19:00.620
And the final thing I want to touch on is Python packaging.

00:19:00.620 --> 00:19:03.240
Let's see here.

00:19:03.240 --> 00:19:06.500
Which tools related to Python packaging do you use directly?

00:19:06.500 --> 00:19:08.400
And we've talked about poetry.

00:19:08.740 --> 00:19:13.560
We've talked about Flit, pipenv and so on.

00:19:13.560 --> 00:19:18.480
And 81% of the people are like, I use pip for packaging.

00:19:20.480 --> 00:19:22.200
As opposed to Flit or something.

00:19:22.200 --> 00:19:25.960
And then sort of parallel to that is for virtual environment.

00:19:25.960 --> 00:19:28.620
Do you use the, you know, what do you use for virtual environments basically?

00:19:28.620 --> 00:19:29.100
Yeah.

00:19:29.100 --> 00:19:34.580
Like 42% is like, I just use the built-in one or I use the virtual ENV wrapper.

00:19:34.580 --> 00:19:39.400
And then it's like poetry, pipenv talks and so on.

00:19:39.400 --> 00:19:39.980
There's a few.

00:19:40.080 --> 00:19:40.900
I don't know what this is.

00:19:40.900 --> 00:19:42.780
Yeah.

00:19:42.780 --> 00:19:47.760
Well, I'm glad they included that because one of the original questions didn't include

00:19:47.760 --> 00:19:49.540
like the built-in VENV.

00:19:49.540 --> 00:19:52.680
And that's, I think that's what most people use.

00:19:52.680 --> 00:19:53.820
It is.

00:19:53.820 --> 00:19:54.140
Yeah.

00:19:54.140 --> 00:19:54.680
Yeah.

00:19:54.680 --> 00:19:55.220
Absolutely.

00:19:55.220 --> 00:19:55.880
All right.

00:19:55.880 --> 00:19:58.540
Well, I think there's more in my progress bar here.

00:19:58.540 --> 00:20:00.060
This is a super detailed report.

00:20:00.060 --> 00:20:02.000
I'm linking to it in the show notes.

00:20:02.000 --> 00:20:05.180
So just go over there and check it out if you want to see all the cool graphs and play

00:20:05.180 --> 00:20:06.440
with the interactive aspects.

00:20:06.440 --> 00:20:09.300
But thanks again to the PSF and JetBrains for putting this together.

00:20:09.420 --> 00:20:13.880
It's really good to have this insight and these projections of where things are going.

00:20:13.880 --> 00:20:14.340
Yeah.

00:20:14.340 --> 00:20:15.260
Hey.

00:20:15.260 --> 00:20:15.580
All right.

00:20:15.580 --> 00:20:17.220
I'm going to grab the next one.

00:20:17.220 --> 00:20:19.200
Ooh, we did this smoothly this time.

00:20:19.200 --> 00:20:19.880
Nice.

00:20:19.880 --> 00:20:28.600
So JIN config is just JIN actually, but the project's called JIN config.

00:20:28.600 --> 00:20:32.520
And it's kind of a neat little thing.

00:20:32.520 --> 00:20:35.340
It's a different way to think about configuration files.

00:20:35.340 --> 00:20:41.180
So like you have, you have your PyProject or you have .toml files.

00:20:41.180 --> 00:20:42.780
You could have .any files.

00:20:42.780 --> 00:20:45.660
There's a lot of ways to have configuration files.

00:20:45.660 --> 00:20:53.980
But JIN takes the perspective of, oh, well, what if you just, what if you're not really

00:20:53.980 --> 00:20:57.600
into all of that stuff and you're a machine learning person and you just have a whole bunch

00:20:57.600 --> 00:21:00.080
of stuff to configure and you're changing stuff a lot?

00:21:00.400 --> 00:21:01.800
Maybe let's make it easier.

00:21:01.800 --> 00:21:10.280
So I actually came across this because of Vincent Warmerdam.

00:21:10.280 --> 00:21:15.220
He's got an excellent intro to JIN on his comcode site.

00:21:15.600 --> 00:21:22.620
And the idea is you've got this, you just have for a function that you want to, in your

00:21:22.620 --> 00:21:26.160
code, you got some code and you have like part of it that you want configurable.

00:21:26.160 --> 00:21:30.900
You just slap a JIN configurable decorator onto it.

00:21:30.900 --> 00:21:36.240
And then all of the parameters to that function are now something that can show up in a config

00:21:36.240 --> 00:21:36.540
file.

00:21:36.540 --> 00:21:38.160
And it's not in any file.

00:21:38.160 --> 00:21:41.340
I actually don't know the exact syntax, but it just kind of looks like Python.

00:21:41.340 --> 00:21:45.680
It's a, you just have names.

00:21:45.680 --> 00:21:51.260
Like in the, in this example that I'm showing, there's a, there's a file called simulate and

00:21:51.260 --> 00:21:55.540
there's actually a function called simulate and a parameter called in samples.

00:21:55.540 --> 00:22:02.300
And in your config file, you can just say simulate.insamples equals a hundred or something like that.

00:22:02.980 --> 00:22:03.400
Oh, wow.

00:22:03.400 --> 00:22:08.920
This is like, it basically sets the default parameters for all your functions you're calling.

00:22:08.920 --> 00:22:09.580
Yeah.

00:22:09.580 --> 00:22:13.060
The ones that you want to be configurable and you just do that.

00:22:13.060 --> 00:22:20.240
Now it's still where you can still set defaults within your code and, and just like you normally

00:22:20.240 --> 00:22:20.620
would.

00:22:20.620 --> 00:22:24.800
And then, and then you can configure the ones that you want to be different than the defaults.

00:22:24.800 --> 00:22:26.560
So that's a, that's a possibility.

00:22:26.560 --> 00:22:30.180
And there's a whole bunch of, I'm going to expand this a little bit.

00:22:30.520 --> 00:22:36.080
There's a whole bunch of different things that Vincent goes through like required settings.

00:22:36.080 --> 00:22:39.480
You can have a, you can specify like a dot.

00:22:39.480 --> 00:22:40.580
What is it?

00:22:40.580 --> 00:22:43.400
Gin dot required as a function.

00:22:43.400 --> 00:22:49.360
And it makes it so that, or as your parameter, and then it makes it so that your user has to

00:22:49.360 --> 00:22:50.520
put it in their config file.

00:22:50.520 --> 00:22:52.060
That's kind of cool.

00:22:52.380 --> 00:22:58.500
And then you can also, if you don't want somebody to configure something, you can, you can mark

00:22:58.500 --> 00:23:03.240
it as, oh, he's got blacklist the, the end samples.

00:23:03.240 --> 00:23:07.440
So if you want, like in this example, he's got a simulate function with two parameters, random

00:23:07.440 --> 00:23:08.540
funk and end samples.

00:23:08.540 --> 00:23:12.920
You want people to configure the random funk, but you don't want them to touch the end samples.

00:23:12.920 --> 00:23:15.480
You can, you can say, don't do that.

00:23:15.660 --> 00:23:17.460
So, it's kind of neat.

00:23:17.460 --> 00:23:19.440
There's a whole bunch of cool features around it.

00:23:19.440 --> 00:23:25.160
Like, like being able to specify different functions so you can name things and, do

00:23:25.160 --> 00:23:29.480
it around like, like to say like in his example, he's got random functions.

00:23:29.660 --> 00:23:35.600
And if you, you can specify, you know, one of the other, one of the other, like a random

00:23:35.600 --> 00:23:39.400
triangle function, you can specify a function and assign it to that.

00:23:39.400 --> 00:23:41.000
He's got, named things.

00:23:41.000 --> 00:23:48.420
Um, it's a really, it, it's a interesting way to think about configuration and the, the,

00:23:48.420 --> 00:23:55.340
the motivation section of the documentation for gin says, that often modern machine learning

00:23:55.340 --> 00:24:01.740
experiments require just configuring a whole bunch of parameters and, and then you're

00:24:01.740 --> 00:24:02.700
tweaking them and stuff.

00:24:02.700 --> 00:24:08.280
And, and, and to have that be as easy as possible and as simple as possible, because

00:24:08.280 --> 00:24:12.520
it is, and you're going to add some and take some away and things like that because some

00:24:12.520 --> 00:24:18.000
things you want configured and then you decide not to not having to go through a config parser

00:24:18.000 --> 00:24:22.180
system, and just making it as trivial as possible to add parameters.

00:24:22.180 --> 00:24:23.600
I think it's a really cool idea.

00:24:23.600 --> 00:24:24.080
So.

00:24:24.520 --> 00:24:25.160
It is a cool idea.

00:24:25.160 --> 00:24:28.440
It reminds me of like dependency injection a little bit.

00:24:28.440 --> 00:24:28.680
Yeah.

00:24:28.680 --> 00:24:33.640
Uh, you know, where you would like configure, say like if somebody asks for a function

00:24:33.640 --> 00:24:38.640
that implements this or that, that goes here, like this is the data access layer to use, or

00:24:38.640 --> 00:24:40.960
here's the ORM I want you to pick this time.

00:24:40.960 --> 00:24:45.140
It's not super common in Python, but it's pretty common in a lot of languages.

00:24:45.140 --> 00:24:46.800
And it feels a little bit like that.

00:24:46.800 --> 00:24:48.220
Can we configure stuff?

00:24:48.220 --> 00:24:53.700
So we have these parameters that we might use for testing or something, but it just, they get

00:24:53.700 --> 00:24:54.540
filled in automatically.

00:24:54.540 --> 00:24:55.040
Yeah.

00:24:55.040 --> 00:24:56.820
Even FastAPI has that for example.

00:24:56.820 --> 00:24:57.320
Yeah.

00:24:57.320 --> 00:24:57.380
Yeah.

00:24:57.380 --> 00:24:58.760
Um, so cool.

00:24:58.760 --> 00:25:03.260
Somebody in the audience says it isn't, isn't Jen used with go.

00:25:03.260 --> 00:25:09.440
Um, and I'm not sure about that, but it, Jen is, is not an officially supported Google

00:25:09.440 --> 00:25:14.400
product, but it's under the Google, like a GitHub repo group.

00:25:14.400 --> 00:25:19.560
So maybe, yeah, maybe it does look very Python like though for the config files.

00:25:19.560 --> 00:25:20.020
And that's cool.

00:25:20.020 --> 00:25:20.380
Yeah.

00:25:20.380 --> 00:25:21.040
Good one.

00:25:21.040 --> 00:25:21.400
All right.

00:25:21.400 --> 00:25:23.920
Uh, let me switch back before I swap over.

00:25:23.920 --> 00:25:24.900
Okay, here we go.

00:25:24.900 --> 00:25:30.160
Now this next one, I think universally will be well accepted.

00:25:30.160 --> 00:25:33.520
Although the comment section about it was a little bit rough and tumble.

00:25:33.520 --> 00:25:37.100
Nonetheless, I think it should be universally exciting to everyone.

00:25:37.240 --> 00:25:44.200
And this comes to us from Eduardo Orochena who sent over this article that said the, what's

00:25:44.200 --> 00:25:44.480
it called?

00:25:44.480 --> 00:25:48.500
The Python 311 performance benchmarks are looking fantastic.

00:25:48.500 --> 00:25:50.040
And oh boy, are they?

00:25:50.400 --> 00:25:54.160
So we're talking beta code six months out, right?

00:25:54.160 --> 00:25:56.680
And still, still we've got some pretty neat stuff.

00:25:56.680 --> 00:26:02.740
So this, this links over to an article with that same title by Michael Larabel basically

00:26:02.740 --> 00:26:07.900
says, look, we took a whole bunch of different performance benchmarks for Python and ran them

00:26:07.900 --> 00:26:12.360
on Python 311 beta, which this is the thing I was hinting at.

00:26:12.360 --> 00:26:17.160
Like you might really want to consider this for if you're thinking, should we upgrade from

00:26:17.160 --> 00:26:18.120
nine to 10?

00:26:18.120 --> 00:26:20.120
Maybe you want to just go straight to 11.

00:26:20.480 --> 00:26:20.660
Right.

00:26:20.660 --> 00:26:25.060
I mean, you know, sort of a side thought, Brian, isn't it awesome that the one that

00:26:25.060 --> 00:26:28.380
goes like crazy performance, this one goes to 11.

00:26:28.380 --> 00:26:33.200
All right.

00:26:33.200 --> 00:26:39.920
So they show all the stuff that they're testing on, like AMD Ryzen 16 core 32 with hyper threading

00:26:39.920 --> 00:26:41.220
the motherboard.

00:26:41.220 --> 00:26:44.800
I mean, like down to the motherboard and the chipset and the memory and all that.

00:26:44.800 --> 00:26:46.880
So a pretty decent stuff.

00:26:47.000 --> 00:26:50.480
And then also the build commands and all sorts of things here.

00:26:50.480 --> 00:26:52.620
So pretty repeatable, I think.

00:26:52.620 --> 00:26:53.100
Yeah.

00:26:53.100 --> 00:27:00.200
Rather than just like, hey, I ran it and here's a graph without, without axes or something like

00:27:00.200 --> 00:27:00.440
that.

00:27:00.640 --> 00:27:03.300
So you can kind of click through here and you see some pictures and it says, all right,

00:27:03.300 --> 00:27:07.400
well, there's the Pybench, which I think is like the standard simple one.

00:27:07.400 --> 00:27:08.520
It says, look at this.

00:27:08.520 --> 00:27:14.260
The Python 311 beta is faster than 310, which by the way, was slightly slower than the previous

00:27:14.260 --> 00:27:14.660
ones.

00:27:14.660 --> 00:27:16.480
But you know, what is that?

00:27:16.480 --> 00:27:17.740
10% or something.

00:27:17.740 --> 00:27:20.780
So already actually 16% better.

00:27:20.780 --> 00:27:22.320
So that's already pretty awesome.

00:27:22.320 --> 00:27:24.040
But there's a whole bunch of other ones.

00:27:24.040 --> 00:27:25.520
They did one called Go.

00:27:25.880 --> 00:27:27.580
I don't know what these benchmarks are.

00:27:27.580 --> 00:27:31.200
This does, I don't think this has anything to do with the language Go, just the name of

00:27:31.200 --> 00:27:31.580
the benchmark.

00:27:31.580 --> 00:27:33.780
And then there's two to three and chaos.

00:27:33.780 --> 00:27:34.860
That one sounds like the funnest.

00:27:34.860 --> 00:27:39.280
But if you look at this Go one, this one is like almost 50% faster.

00:27:39.280 --> 00:27:41.260
50% faster.

00:27:41.260 --> 00:27:42.480
That's insane, right?

00:27:42.480 --> 00:27:42.960
Yeah.

00:27:42.960 --> 00:27:43.500
Wow.

00:27:43.500 --> 00:27:49.740
And you come down to the two to three is, these are all estimates, 25, 20% faster,

00:27:49.740 --> 00:27:53.120
say 40% faster with the chaos one.

00:27:53.120 --> 00:27:57.980
Come down to the float operations and Python 310 was already better than the others.

00:27:57.980 --> 00:28:00.400
But this is again, maybe 30% faster.

00:28:00.400 --> 00:28:03.700
And let's roll into the next page.

00:28:03.700 --> 00:28:05.620
You just kind of see this across the board.

00:28:05.620 --> 00:28:06.360
Better, better.

00:28:06.360 --> 00:28:07.840
Some of them are super better.

00:28:07.840 --> 00:28:10.940
Some are like a little bit better, like Pathlib's better, but not crazy.

00:28:11.340 --> 00:28:14.720
Ray tracing is like, again, 40% better here.

00:28:14.720 --> 00:28:16.160
And you keep going.

00:28:16.160 --> 00:28:21.180
There's another one with this huge crypto IAES, some sort of encryption thing.

00:28:21.180 --> 00:28:25.260
So there's just a bunch of, a couple of these are, there's like this one at the end, you're

00:28:25.260 --> 00:28:26.620
like, oh wait, this one got way worse.

00:28:26.620 --> 00:28:30.460
Be careful because it says more is better on this composition.

00:28:30.460 --> 00:28:31.820
I guess is the results here.

00:28:31.820 --> 00:28:36.300
Like how much more computing power do you get per CPU cycle or whatever?

00:28:36.300 --> 00:28:37.440
What is that?

00:28:37.440 --> 00:28:38.800
That's a massive jump.

00:28:38.880 --> 00:28:43.480
You saw a little bit better improvements from 3.8 to 3.9, 3.9 to 3.10.

00:28:43.480 --> 00:28:50.120
But 3.10 to 11 is like a 40%, yeah, 41% better on the beta before it's even final.

00:28:50.120 --> 00:28:50.680
Wow.

00:28:50.680 --> 00:28:51.820
That's pretty exciting, right?

00:28:51.820 --> 00:28:52.920
That's very exciting.

00:28:52.920 --> 00:28:59.780
And actually, I think, I'm curious what some of these negative comments are, but the interesting

00:28:59.780 --> 00:29:06.160
thing is to run lots of different metrics and lots of different benchmarks and having them

00:29:06.160 --> 00:29:12.800
all be, it's faster kind of means that, I mean, I take it as, you know, your mileage may vary,

00:29:12.800 --> 00:29:16.560
but it's going to be better for whatever you're doing, probably.

00:29:16.560 --> 00:29:17.220
Yeah.

00:29:17.220 --> 00:29:17.660
Yeah.

00:29:17.660 --> 00:29:17.900
Yeah.

00:29:17.900 --> 00:29:20.560
It feels like this is a thing you could just install and things get better.

00:29:20.560 --> 00:29:25.160
The negative comments are mostly like, well, if Python was so slow, it could be made this

00:29:25.160 --> 00:29:26.760
faster than Python is a crappy language.

00:29:26.760 --> 00:29:29.640
It's pretty much, I've summed up like 65 comments right there.

00:29:31.640 --> 00:29:39.400
By the way, so I interviewed Guido Van Rassam and Mark Shannon a little while ago about

00:29:39.400 --> 00:29:43.780
this whole project about making Python five times, not 40%, but five times faster.

00:29:43.780 --> 00:29:47.960
And the goal is to make it a little bit faster like this, each release for five releases in

00:29:47.960 --> 00:29:48.240
a row.

00:29:48.240 --> 00:29:51.180
And because of compounding, that'll get you to like 5%.

00:29:51.180 --> 00:29:53.360
So it looks like they're delivering, which is awesome.

00:29:53.360 --> 00:29:53.920
Yeah.

00:29:53.920 --> 00:29:54.680
This is good.

00:29:54.680 --> 00:29:55.180
Yeah.

00:29:55.180 --> 00:29:55.780
Well, cool.

00:29:55.780 --> 00:29:56.400
All right.

00:29:56.400 --> 00:29:57.980
Yeah.

00:29:57.980 --> 00:29:59.760
I think that's it for all of our items.

00:29:59.760 --> 00:30:00.440
Yeah.

00:30:00.440 --> 00:30:01.100
Got any extras?

00:30:01.580 --> 00:30:06.700
Um, no, I was going to pull up the, so yeah, the, the, this one goes to 11.

00:30:06.700 --> 00:30:08.980
If people don't know that that's a spinal tap reference.

00:30:08.980 --> 00:30:12.740
Yeah, exactly.

00:30:12.740 --> 00:30:13.600
All right.

00:30:13.600 --> 00:30:15.000
I got a few extras to throw out real quick.

00:30:15.000 --> 00:30:19.120
Python three, 10, five is out with a bunch of bug fixes.

00:30:19.120 --> 00:30:23.840
Like what happens if you create an F string that doesn't have a closing curly and just a

00:30:23.840 --> 00:30:25.380
bunch of crashes and bug fixes.

00:30:25.380 --> 00:30:29.160
So if you've been running into issues, you know, maybe there's a decent amount of stuff in

00:30:29.160 --> 00:30:29.880
the changelog here.

00:30:29.880 --> 00:30:30.520
Nice.

00:30:30.840 --> 00:30:31.640
People can check that out.

00:30:31.640 --> 00:30:36.320
Also real quick, people might, if they're on a Mac, they might check out Raycast, which

00:30:36.320 --> 00:30:41.100
is a replacement for the command space spotlight thing that has like all these developer plugins.

00:30:41.100 --> 00:30:46.160
So you can do like interact with your GitHub repo through command space and stuff.

00:30:46.160 --> 00:30:48.420
You can create a lot of things.

00:30:48.420 --> 00:30:49.420
And there's a bunch of extensions.

00:30:49.420 --> 00:30:58.660
Uh, like, this thing's free, at least for not for team, if you're not on a team, but there's a bunch of different, things you can get that are full, like managing

00:30:58.660 --> 00:31:04.760
processes, doing searches, VS Code project management from command space and whatnot.

00:31:04.760 --> 00:31:05.760
So I'm going to do a lot of things.

00:31:05.760 --> 00:31:05.760
I'm going to do a lot of things.

00:31:05.760 --> 00:31:06.760
I'm going to do a lot of things.

00:31:06.760 --> 00:31:07.760
I'm going to do a lot of things.

00:31:07.760 --> 00:31:07.760
I'm going to do a lot of things.

00:31:07.760 --> 00:31:08.760
I'm going to do a lot of things.

00:31:08.760 --> 00:31:09.760
I'm going to do a lot of things.

00:31:09.760 --> 00:31:09.760
I'm going to do a lot of things.

00:31:09.760 --> 00:31:10.760
I'm going to do a lot of things.

00:31:10.760 --> 00:31:11.760
I'm going to do a lot of things.

00:31:11.760 --> 00:31:12.760
I'm going to do a lot of things.

00:31:12.760 --> 00:31:13.760
I'm going to do a lot of things.

00:31:13.760 --> 00:31:14.760
I'm going to do a lot of things.

00:31:14.760 --> 00:31:15.760
I'm going to do a lot of things.

00:31:15.760 --> 00:31:16.760
I'm going to do a lot of things.

00:31:16.760 --> 00:31:17.760
I'm going to do a lot of things.

00:31:17.760 --> 00:31:18.760
I'm going to do a lot of things.

00:31:18.760 --> 00:31:19.760
I'm going to do a lot of things.

00:31:19.760 --> 00:31:20.760
I'm going to do a lot of things.

00:31:20.760 --> 00:31:21.760
I'm going to do a lot of things.

00:31:21.760 --> 00:31:22.760
I'm going to do a lot of things.

00:31:22.760 --> 00:31:23.760
I'm going to do a lot of things.

00:31:23.760 --> 00:31:24.760
I'm going to do a lot of things.

00:31:24.760 --> 00:31:25.760
I'm going to do a lot of things.

00:31:25.760 --> 00:31:26.760
I'm going to do a lot of things.

00:31:26.760 --> 00:31:27.760
I'm going to do a lot of things.

00:31:27.760 --> 00:31:28.760
I'm going to do a lot of things.

00:31:28.760 --> 00:31:30.760
which ties really well back to the PSF survey.

00:31:30.760 --> 00:31:32.760
We talked about, well, what framework do you use?

00:31:32.760 --> 00:31:34.760
What data science framework do you use?

00:31:34.760 --> 00:31:36.760
Or what web framework do you want to use?

00:31:36.760 --> 00:31:39.760
Django or Flask or FastAPI or what?

00:31:39.760 --> 00:31:42.760
So here's one that is a pretty interesting analysis.

00:31:42.760 --> 00:31:46.760
And the title is, why wouldn't you choose Parrot for your next application?

00:31:46.760 --> 00:31:48.760
Not a framework, but literally a Parrot.

00:31:48.760 --> 00:31:51.760
And this is compared to machine learning.

00:31:51.760 --> 00:31:56.760
So it has like this breakdown of features, like a featured table.

00:31:56.760 --> 00:31:58.760
And it has a parrot, which literally just has a picture of a parrot.

00:31:58.760 --> 00:32:00.760
And this is machine learning algorithms with a neural network.

00:32:00.760 --> 00:32:02.760
And then it lists off the features.

00:32:02.760 --> 00:32:03.760
Learns random phrases.

00:32:03.760 --> 00:32:04.760
Check, check.

00:32:04.760 --> 00:32:08.760
Doesn't understand anything about what it learns.

00:32:08.760 --> 00:32:09.760
Check, check.

00:32:09.760 --> 00:32:11.760
Occasionally speaks nonsense.

00:32:11.760 --> 00:32:12.760
Check, check.

00:32:12.760 --> 00:32:13.760
It's a cute birdie parrot.

00:32:13.760 --> 00:32:15.760
Check, fail.

00:32:15.760 --> 00:32:19.760
Why wouldn't you choose this, Brian?

00:32:19.760 --> 00:32:21.760
This is funny.

00:32:21.760 --> 00:32:22.760
I love it.

00:32:22.760 --> 00:32:24.760
Yeah, it's pretty good.

00:32:24.760 --> 00:32:25.760
Pretty good stuff.

00:32:25.760 --> 00:32:28.760
I actually reminds me of like, I have to pull up this article.

00:32:28.760 --> 00:32:33.760
So I was reading about some machine learning stuff to try to get models like even closer

00:32:33.760 --> 00:32:34.760
and closer to reality.

00:32:34.760 --> 00:32:36.760
There's a whole bunch of tricks people do.

00:32:36.760 --> 00:32:42.760
And then, and then there's some analysis of like, sometimes it's actually not doing anything

00:32:42.760 --> 00:32:44.760
more than just a linear regression.

00:32:44.760 --> 00:32:45.760
So, yeah.

00:32:45.760 --> 00:32:47.760
Try simple for an if statement.

00:32:47.760 --> 00:32:48.760
Yeah.

00:32:48.760 --> 00:32:49.760
Yeah, yeah, yeah, yeah.

00:32:49.760 --> 00:32:50.760
For sure.

00:32:50.760 --> 00:32:53.760
They're using artificial intelligence to make the computer decide.

00:32:53.760 --> 00:32:54.760
No, it's an if statement.

00:32:54.760 --> 00:32:58.760
Like, it's just computers deciding things the old fashioned way.

00:32:58.760 --> 00:32:59.760
Yeah, yeah.

00:32:59.760 --> 00:32:59.760
So.

00:32:59.760 --> 00:33:00.760
Awesome.

00:33:00.760 --> 00:33:00.760
All right.

00:33:00.760 --> 00:33:01.760
Well, thanks for being here.

00:33:01.760 --> 00:33:02.760
Thank you.

00:33:02.760 --> 00:33:03.760
Thanks everyone for listening.

