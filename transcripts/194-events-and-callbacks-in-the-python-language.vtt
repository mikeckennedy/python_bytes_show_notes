
00:00:00.000 --> 00:00:05.360
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:05.360 --> 00:00:11.920
This is episode 194 recorded August 5th, 2020. I'm Brian Okken.


00:00:11.920 --> 00:00:12.960
And I'm Michael Kennedy.


00:00:12.960 --> 00:00:16.560
And this episode is brought to you by us and we'll tell you more about what we're


00:00:16.560 --> 00:00:21.520
shilling later in the day. I want to talk to you about mutants.


00:00:21.520 --> 00:00:26.240
Mutants? Like mutant ninja turtle type things or what are we looking at here?


00:00:26.240 --> 00:00:31.440
Sure, mutant Ninja Turtles. No, so mutation testing. So I really kind of, I think,


00:00:31.440 --> 00:00:36.960
in warming to mutation testing and it's kind of a neat thing. And I think we've covered it before,


00:00:36.960 --> 00:00:42.480
but this article is from Mosh Sadka and it's called an introduction to mutation testing in


00:00:42.480 --> 00:00:47.280
Python. There are a few, a handful of, I think there's like two or three different mutation


00:00:47.280 --> 00:00:54.160
testing libraries. Mutmut is one of them and that's what this article uses. And so if people


00:00:54.160 --> 00:00:59.840
are not familiar with mutation testing, here's the problem. So you can use code coverage tools like


00:00:59.840 --> 00:01:06.800
coverage.py to show how much of your code your tests are covering, but even if you get to 100%


00:01:06.800 --> 00:01:11.920
coverage it doesn't mean that you're really testing everything. And so mutation testing,


00:01:11.920 --> 00:01:18.000
what it does is it takes your code under test and it does some modification. So it modifies


00:01:18.000 --> 00:01:23.920
portions of your source code to simulate potential bugs. Like for example, it'll replace like greater


00:01:23.920 --> 00:01:29.440
than comparison with greater than equal or placing it with those sorts of edge cases and stuff are


00:01:29.440 --> 00:01:34.240
often where we muck up. If there's no boundary test around the boundary condition, you know,


00:01:34.240 --> 00:01:39.760
there'll be a problem. So every little change is considered a mutant and it generates all these


00:01:39.760 --> 00:01:45.840
different mutants and it does it in a fairly smart way. It can test your code fairly quickly


00:01:45.840 --> 00:01:52.080
with not too many mutants. So and then it runs your test suite on the mutant and the idea is


00:01:52.080 --> 00:01:54.560
your test suite should kill all of the mutants.


00:01:54.560 --> 00:02:02.160
So in this article, he shows an example of three methods and one test case and 100% code coverage.


00:02:02.160 --> 00:02:08.960
But he runs mutmut and 16 of them survive, and then talks about how to fix that.


00:02:08.960 --> 00:02:11.520
So it's really good quick article.


00:02:11.520 --> 00:02:12.560
Yeah, this is interesting.


00:02:12.560 --> 00:02:17.600
And I like the emoji legend use for the output.


00:02:17.600 --> 00:02:19.440
Yeah, it's a cute library.


00:02:19.440 --> 00:02:49.040
Yeah, it is. You know, one thing that I don't understand about mutation testing is like I understand, okay, well, we're gonna change like a value of a variable or like the way if we're doing a test to make it it was less than we're gonna make it greater than and see if your test still pass and like those kind of things that totally seems reasonable. But if it goes in, I don't know if it does, maybe, you know, if it goes in, like, says, Well, you're doing a print statement. So we changed part of the print string, like, who's testing for that, right? Like, that would seems like it would survive.


00:02:49.080 --> 00:02:50.280
Yeah, I'm not sure.


00:02:50.280 --> 00:02:53.580
So it seems like there's certain things like I would just never care to test


00:02:53.580 --> 00:02:58.180
for the output of the print statement where the static string changes.


00:02:58.180 --> 00:03:01.380
Like to me that just is not something I care to test, right?


00:03:01.380 --> 00:03:05.980
But I feel like the sort of general case of mutation testing, you go, well, here's a


00:03:05.980 --> 00:03:11.580
piece of variable that I need to change around. Let's change a string and see if the test still passed.


00:03:11.580 --> 00:03:16.980
Maybe it's just inappropriate for those types of scenarios. Maybe you only test stuff like at a lower level


00:03:16.980 --> 00:03:18.980
where you don't have a bunch of print statements.


00:03:18.980 --> 00:03:20.980
But you've got logging and all kinds of things.


00:03:20.980 --> 00:03:21.700
So I don't know.


00:03:21.700 --> 00:03:23.180
But still, I do like the idea.


00:03:23.180 --> 00:03:24.940
I think MUTMUT and some of the others


00:03:24.940 --> 00:03:30.180
have ways to specify which kinds of mutants to generate.


00:03:30.180 --> 00:03:33.060
So I don't know if it does the print statement sort of example.


00:03:33.060 --> 00:03:37.740
But I'm sure that there's ways to say, yeah, I don't really care about--


00:03:37.740 --> 00:03:39.820
don't modify string values, for instance.


00:03:39.820 --> 00:03:40.320
Yeah.


00:03:40.320 --> 00:03:42.100
Yeah.


00:03:42.100 --> 00:03:44.020
Don't modify constants or something, maybe.


00:03:44.020 --> 00:03:44.540
Who knows?


00:03:44.540 --> 00:03:45.540
Yeah.


00:03:45.540 --> 00:03:46.380
Cool.


00:03:46.380 --> 00:03:47.980
- All right, well, you know, that looks really interesting


00:03:47.980 --> 00:03:51.000
and Masha does a great job writing up these types of things.


00:03:51.000 --> 00:03:53.080
We feature him a lot, very cool.


00:03:53.080 --> 00:03:57.080
Next up, I wanna talk about asynchronous programming.


00:03:57.080 --> 00:03:57.920
- Oh, nice.


00:03:57.920 --> 00:03:59.720
- Yeah, so we, maybe we've covered this before.


00:03:59.720 --> 00:04:00.880
Now, we've covered this a lot,


00:04:00.880 --> 00:04:04.240
but I don't believe we've covered Async Queue.


00:04:04.240 --> 00:04:05.080
- I don't think so.


00:04:05.080 --> 00:04:05.900
- I don't think so either.


00:04:05.900 --> 00:04:10.320
So this is from Quora and it is not brand new.


00:04:10.320 --> 00:04:12.080
Like, so I just wanna be really upfront,


00:04:12.080 --> 00:04:15.080
like this has been around since 2016,


00:04:15.080 --> 00:04:16.900
but it's pretty interesting.


00:04:16.900 --> 00:04:20.440
And the idea is so much of what asynchronous programming,


00:04:20.440 --> 00:04:23.720
especially asyncio type of async and await programming


00:04:23.720 --> 00:04:27.080
is about is scaling while you're waiting,


00:04:27.080 --> 00:04:29.300
scaling the latencies, right?


00:04:29.300 --> 00:04:33.020
So, you know, like I'm gonna call the Stripe service


00:04:33.020 --> 00:04:36.000
and it's gonna take, you know, half a second to return.


00:04:36.000 --> 00:04:37.720
And so I want my web server to be able to go


00:04:37.720 --> 00:04:41.120
and just do stuff, you know, other requests


00:04:41.120 --> 00:04:42.440
instead of waiting for half a second


00:04:42.440 --> 00:04:45.120
while we're checking out some person or whatever, right?


00:04:45.120 --> 00:04:46.840
But they've got a different use case.


00:04:46.840 --> 00:04:49.200
What they're doing is they're running,


00:04:49.200 --> 00:04:51.040
I don't know if I said this is from Quora,


00:04:51.040 --> 00:04:52.920
they're running Quora.com,


00:04:52.920 --> 00:04:54.520
which is a really cool Q&A site.


00:04:54.520 --> 00:04:56.520
I actually think Quora does a great job


00:04:56.520 --> 00:04:59.480
of having like solid, thoughtful answers.


00:04:59.480 --> 00:05:01.720
Not always right, but thoughtful at least,


00:05:01.720 --> 00:05:02.660
which is pretty cool.


00:05:02.660 --> 00:05:05.160
But what they do is they don't talk directly


00:05:05.160 --> 00:05:08.460
to their database because that would be too slow.


00:05:08.460 --> 00:05:10.160
Don't get me started on that.


00:05:10.160 --> 00:05:13.120
But what they're doing is they're talking to memcached


00:05:13.120 --> 00:05:15.080
or which, you know, or Redis or whatever,


00:05:15.080 --> 00:05:18.800
but they're using memcached to store a bunch


00:05:18.800 --> 00:05:21.800
of pre-computed query results.


00:05:21.800 --> 00:05:23.760
So they don't have to keep going back to the database.


00:05:23.760 --> 00:05:27.080
Like for example, when you go view a question,


00:05:27.080 --> 00:05:29.120
they want to see the names of the people


00:05:29.120 --> 00:05:31.640
who upvoted the question, right?


00:05:31.640 --> 00:05:33.660
So it's kind of a complicated query, right?


00:05:33.660 --> 00:05:35.520
I need to go, here's the IDs,


00:05:35.520 --> 00:05:37.800
maybe we store the IDs of the upvoter,


00:05:37.800 --> 00:05:38.920
then we're going to do a query,


00:05:38.920 --> 00:05:42.640
to join over on the user table and get their names back.


00:05:42.640 --> 00:05:43.480
And then we're gonna show it,


00:05:43.480 --> 00:05:45.840
like that sounds expensive for lots of data.


00:05:45.840 --> 00:05:48.380
So what they do is they basically store those answers,


00:05:48.380 --> 00:05:52.740
like this user goes to this thing in memcached.


00:05:52.740 --> 00:05:54.680
But a lot of the latency around this


00:05:54.680 --> 00:05:56.720
has to do actually with the network call.


00:05:56.720 --> 00:05:58.200
Like it's pretty close.


00:05:58.200 --> 00:06:00.620
It's like, you know, one millisecond or something,


00:06:00.620 --> 00:06:03.480
but they've got to go get those names over and over, right?


00:06:03.480 --> 00:06:05.720
'Cause the way that you store stuff in memcached


00:06:05.720 --> 00:06:08.260
is this ID has this name.


00:06:08.260 --> 00:06:10.100
and you've got 50 upvoters, it's like,


00:06:10.100 --> 00:06:10.940
give me the name of this person,


00:06:10.940 --> 00:06:11.760
give me the name of that person.


00:06:11.760 --> 00:06:14.700
So there's a way to do like a batch get,


00:06:14.700 --> 00:06:15.940
like here's all these IDs,


00:06:15.940 --> 00:06:18.320
go get me all the associated names.


00:06:18.320 --> 00:06:20.340
And they've got like this dependency tree


00:06:20.340 --> 00:06:23.040
of these sorts of questions they have to answer.


00:06:23.040 --> 00:06:24.260
So what they've done is they've come up


00:06:24.260 --> 00:06:25.700
with this thing called Async Queue,


00:06:25.700 --> 00:06:29.040
and it's all about batching asynchronous requests


00:06:29.040 --> 00:06:31.400
and converting them from a bunch of individual calls


00:06:31.400 --> 00:06:33.740
into like one massive call.


00:06:33.740 --> 00:06:36.020
So they can like do what looks like


00:06:36.020 --> 00:06:37.380
asynchronous programming,


00:06:37.380 --> 00:06:38.740
say, go get me all these things.


00:06:38.740 --> 00:06:40.660
And instead of doing a bunch of individual


00:06:40.660 --> 00:06:42.400
async and await type calls,


00:06:42.400 --> 00:06:43.660
the system looks at that and goes,


00:06:43.660 --> 00:06:45.340
okay, what that means is,


00:06:45.340 --> 00:06:47.020
turn that into one giant query


00:06:47.020 --> 00:06:50.160
where it's like all of these IDs go to all those things


00:06:50.160 --> 00:06:51.140
and then return them back.


00:06:51.140 --> 00:06:51.980
- Oh, that's neat.


00:06:51.980 --> 00:06:52.800
- Yeah, it's pretty neat.


00:06:52.800 --> 00:06:54.720
So it's basically this way to write code


00:06:54.720 --> 00:06:56.860
that will take what would be a bunch


00:06:56.860 --> 00:06:58.340
of small independent requests


00:06:58.340 --> 00:07:02.180
and turn it into like a one-shot request


00:07:02.180 --> 00:07:05.020
for talking to things like caching servers and whatnot.


00:07:05.020 --> 00:07:05.860
- Yeah.


00:07:05.860 --> 00:07:09.300
Apparently this is like a core component of core's architecture.


00:07:09.300 --> 00:07:13.140
And yeah, it's all about batching up these calls.


00:07:13.140 --> 00:07:15.740
I didn't know core was Python on the backend.


00:07:15.740 --> 00:07:16.360
Oh yeah.


00:07:16.360 --> 00:07:16.620
Yeah.


00:07:16.620 --> 00:07:20.460
They've got a really interesting Python blog where they can engineering blog,


00:07:20.460 --> 00:07:21.820
where they talk about all sorts of stuff.


00:07:21.820 --> 00:07:25.620
So this was like written up on their engineering blog about sort of how they


00:07:25.620 --> 00:07:29.020
went from what they were doing before this, which was, you'd have to like


00:07:29.020 --> 00:07:32.340
write several functions that would prepare the things and then you could


00:07:32.340 --> 00:07:35.540
ask for it because they would be cashed locally and all sorts of funky stuff.


00:07:35.540 --> 00:07:39.780
So there's a great write up on sort of the whole use case of this.


00:07:39.780 --> 00:07:41.580
So this, like I said, is from 2016.


00:07:41.580 --> 00:07:44.020
So it predates async and await.


00:07:44.020 --> 00:07:50.740
And so they use the yield keyword, which is a sort of a more foundational way to get to


00:07:50.740 --> 00:07:53.100
break up functions into parts that run.


00:07:53.100 --> 00:07:57.700
So basically you decorate a function and then you yield out the various steps.


00:07:57.700 --> 00:08:01.340
And then before it executes all those, it looks at them, figures out what it has to


00:08:01.340 --> 00:08:04.380
do, and then it like batches it up and then does it all at once.


00:08:04.380 --> 00:08:05.980
- Yeah, neat.


00:08:05.980 --> 00:08:08.820
- Yeah, so I thought this was kind of interesting.


00:08:08.820 --> 00:08:10.980
I think it's a little bit,


00:08:10.980 --> 00:08:12.540
just looking at the patterns here,


00:08:12.540 --> 00:08:15.040
it feels like it's a little tiny bit limited


00:08:15.040 --> 00:08:18.220
because it's targeted at,


00:08:18.220 --> 00:08:20.300
I believe they're still at least then, right?


00:08:20.300 --> 00:08:22.820
So when they came up with it and it's still active,


00:08:22.820 --> 00:08:26.380
I think they built it for running a Python 2, right?


00:08:26.380 --> 00:08:29.320
Remember this 2016, they've been running for a while.


00:08:29.320 --> 00:08:31.820
So some of their APIs, I don't think,


00:08:31.820 --> 00:08:35.320
Like for example, they don't use the async and await keyword,


00:08:35.320 --> 00:08:38.980
I think because that didn't exist.


00:08:38.980 --> 00:08:41.860
Like they supported Python 3.4 where async I/O was,


00:08:41.860 --> 00:08:43.560
but async and await didn't come along


00:08:43.560 --> 00:08:45.300
until just a tiny bit later, I don't think.


00:08:45.300 --> 00:08:47.540
So anyway, a bit of a grain of salt,


00:08:47.540 --> 00:08:50.620
but I think this will be a pretty interesting thing


00:08:50.620 --> 00:08:54.200
that people can adopt and use for these types of scenarios.


00:08:54.200 --> 00:08:57.260
Certainly if it powers Quora, it's probably pretty good.


00:08:57.260 --> 00:08:58.940
- Yeah, neat, cool.


00:08:58.940 --> 00:09:00.060
- Absolutely, yep.


00:09:00.060 --> 00:09:02.660
- Another thing that's cool is Talk Python Training.


00:09:02.660 --> 00:09:03.500
- Thank you.


00:09:03.500 --> 00:09:04.580
We got a lot of stuff going on over there.


00:09:04.580 --> 00:09:07.040
Actually, we've got a ton of new courses coming.


00:09:07.040 --> 00:09:09.580
Course for people who generally live in Excel


00:09:09.580 --> 00:09:11.980
and should be adopting the Python data science tools.


00:09:11.980 --> 00:09:13.780
So that's coming really soon.


00:09:13.780 --> 00:09:15.220
We've got a getting started with data science.


00:09:15.220 --> 00:09:17.420
I just actually, last time we spoke, I said,


00:09:17.420 --> 00:09:18.540
hey, I'm writing this course.


00:09:18.540 --> 00:09:22.140
I started writing a course called Python Memory Management.


00:09:22.140 --> 00:09:23.540
I finished it, I recorded it.


00:09:23.540 --> 00:09:24.460
It's like a five-hour course.


00:09:24.460 --> 00:09:25.300
It's gonna be awesome.


00:09:25.300 --> 00:09:27.440
So now I'm on to writing a new course,


00:09:27.440 --> 00:09:28.620
Python Design Patterns.


00:09:28.620 --> 00:09:29.460
- Oh, nice.


00:09:29.460 --> 00:09:31.700
So that'll be out in a few weeks as well.


00:09:31.700 --> 00:09:32.700
How about you?


00:09:32.700 --> 00:09:33.700
Yeah.


00:09:33.700 --> 00:09:40.260
I just wanted to highlight again, I have the URL, pytestbook.com set up to go directly


00:09:40.260 --> 00:09:46.140
to errata because I get a lot of people asking, "Hey, your pytestBook, is it still good for


00:09:46.140 --> 00:09:47.140
it?


00:09:47.140 --> 00:09:48.940
It was like in 2017, still valid?"


00:09:48.940 --> 00:09:55.060
Yes, it's still valid, but there's a few gotchas and I list them out, very easy to read at


00:09:55.060 --> 00:10:01.700
pytestbook.com, it directs you to an errata page to show you, it's just a couple tweaks to the


00:10:01.700 --> 00:10:06.900
source code you got to make. You got to pin tinydb and a couple other things, and we'll try to get


00:10:06.900 --> 00:10:13.460
those changes out to the download link on Pragmatic as soon as possible. That's still in the works,


00:10:13.460 --> 00:10:18.340
but there's also a link to, if you have any issues, there's a link to the official Pragmatic


00:10:18.340 --> 00:10:23.700
errata page where you can ask questions, and if you have any, run into anything, I'd love to hear


00:10:23.700 --> 00:10:28.240
about it. And I'm excited to get a lot the lately a lot of the people that have


00:10:28.240 --> 00:10:31.960
been contacting me said they're excited about reading the book are machine


00:10:31.960 --> 00:10:35.440
learning people. So it's kind of neat to see data science and machine learning


00:10:35.440 --> 00:10:40.480
people add testing to their workflows. That's exciting. Absolutely. So I have a


00:10:40.480 --> 00:10:43.480
final call to action for people out there. If if you want to make sure that


00:10:43.480 --> 00:10:47.440
we have the time and energy to keep creating stuff like this podcast and the


00:10:47.440 --> 00:10:51.400
other things we're doing, you don't necessarily have to get our stuff but how


00:10:51.400 --> 00:10:52.680
about recommending it, right?


00:10:52.680 --> 00:10:55.840
If your company needs to get up to speed on Python,


00:10:55.840 --> 00:11:00.160
recommend that your company buy the courses for that team,


00:11:00.160 --> 00:11:02.680
or if a company is doing a bunch of testing,


00:11:02.680 --> 00:11:05.920
have everyone on that team or the engineering group


00:11:05.920 --> 00:11:07.200
get Brian's book.


00:11:07.200 --> 00:11:08.040
That would be great.


00:11:08.040 --> 00:11:09.640
- Yeah, and then individually too,


00:11:09.640 --> 00:11:12.960
remind people that we do have a Patreon campaign going,


00:11:12.960 --> 00:11:16.600
so people can contribute a buck or two a month.


00:11:16.600 --> 00:11:17.420
That would be great.


00:11:17.420 --> 00:11:20.420
- Yeah, now that we go anywhere, we don't buy coffee.


00:11:20.420 --> 00:11:24.420
Yeah. Next I want to talk, this sort of ties into your async thing.


00:11:24.420 --> 00:11:26.420
Yeah, for sure.


00:11:26.420 --> 00:11:30.420
That's interesting. But they use Memcached, but I wanted to talk about Redis.


00:11:30.420 --> 00:11:34.420
So I've not used Redis myself, but I know that a lot of people


00:11:34.420 --> 00:11:38.420
do for caching and for other things.


00:11:38.420 --> 00:11:42.420
So this is an article, it's actually on the Redis site,


00:11:42.420 --> 00:11:46.420
but it's an article called "Redis Beyond the Cache" in Python


00:11:46.420 --> 00:11:48.420
by Guy Royce, I think.


00:11:48.420 --> 00:11:51.420
I knew that Redis did more than just a


00:11:51.420 --> 00:11:53.420
cache for a back-end database.


00:11:53.420 --> 00:11:55.420
But this is kind of neat.


00:11:55.420 --> 00:11:58.420
These are good, clear examples of Python code


00:11:58.420 --> 00:12:01.420
using Redis for more than just caching.


00:12:01.420 --> 00:12:04.420
The first example talks about how to use it as a queue.


00:12:04.420 --> 00:12:07.420
So you can set it up as a fast queuing system.


00:12:07.420 --> 00:12:12.420
Apparently, there's a couple calls called rpush and blpop.


00:12:12.420 --> 00:12:16.420
And actually, to tell you the truth, I picked this article because of BLpop.


00:12:16.420 --> 00:12:19.420
I think that's one of the best function names ever.


00:12:19.420 --> 00:12:22.420
I don't know what it means, but maybe back of the list pop?


00:12:22.420 --> 00:12:24.420
Not sure. But it's good.


00:12:24.420 --> 00:12:27.420
I thought you picked it because of the various--


00:12:27.420 --> 00:12:31.420
from the code example about putting stuff into queues here.


00:12:31.420 --> 00:12:33.420
That felt close to home.


00:12:33.420 --> 00:12:34.420
Did it?


00:12:34.420 --> 00:12:36.420
Yeah, it's about Bigfoot sightings.


00:12:36.420 --> 00:12:38.420
We've got a sighting near the Columbia River,


00:12:38.420 --> 00:12:41.420
and people were chased by a tall, hairy creature, and so on.


00:12:41.420 --> 00:12:47.020
And so on, so like asynchronously adding Bigfoot sightings from the general Pacific Northwest.


00:12:47.020 --> 00:12:48.620
Yeah, that's good.


00:12:48.620 --> 00:12:51.660
Sorry, carry on, didn't mean to derail you.


00:12:51.660 --> 00:12:56.780
No, no, it's good. So using it as a queue, using it in a Pub/Sub model,


00:12:56.780 --> 00:13:00.940
apparently there's functions like publish and psubscribe.


00:13:00.940 --> 00:13:06.380
So you can do publish and subscribe models, data streaming, using it as a search engine.


00:13:06.380 --> 00:13:10.220
The search engine seems like a little more hardcore because it looks like they're,


00:13:10.220 --> 00:13:13.000
It's almost like SQL queries that you're using,


00:13:13.000 --> 00:13:14.640
but apparently you can do that.


00:13:14.640 --> 00:13:16.880
Of course, you can also use it as


00:13:16.880 --> 00:13:19.800
your primary in-memory database if you want to,


00:13:19.800 --> 00:13:22.240
as long as you don't need to store it somewhere,


00:13:22.240 --> 00:13:25.140
or use some later thing.


00:13:25.140 --> 00:13:26.980
I guess I'm just swinging it here.


00:13:26.980 --> 00:13:28.960
I don't know how you hook up


00:13:28.960 --> 00:13:31.500
a Redis database to a normal database,


00:13:31.500 --> 00:13:35.040
but I know you database people know how to do that.


00:13:35.040 --> 00:13:38.580
But I like the idea of using it as


00:13:38.580 --> 00:13:42.820
a queue system for like multi threads and multi processes.


00:13:42.820 --> 00:13:43.780
That sounds kind of fun.


00:13:43.780 --> 00:13:45.100
- This is a really cool article


00:13:45.100 --> 00:13:48.060
because I just often think of Redis as cache, right?


00:13:48.060 --> 00:13:50.060
But yeah, there's a bunch of neat stuff here.


00:13:50.060 --> 00:13:53.700
And so often you think like,


00:13:53.700 --> 00:13:55.140
oh, I'll just write this cool data structure


00:13:55.140 --> 00:13:56.740
and we'll just do this thing and it's great.


00:13:56.740 --> 00:13:59.180
And you're like, oh wait, but hold on.


00:13:59.180 --> 00:14:00.820
When I deploy that to the web server,


00:14:00.820 --> 00:14:04.420
it forks off like 10 copies of micro-WSGI.


00:14:04.420 --> 00:14:07.100
And so I'm gonna have like 10 separate DB copies


00:14:07.100 --> 00:14:09.100
and all this, like, there's just certain times


00:14:09.100 --> 00:14:11.020
you're like, I just need a thing to hold this stuff


00:14:11.020 --> 00:14:12.540
and like Redis seems pretty cool for that.


00:14:12.540 --> 00:14:14.180
- Yeah, and the examples used,


00:14:14.180 --> 00:14:16.420
apparently there's a bunch of different Python libraries


00:14:16.420 --> 00:14:20.540
to access Redis, and this one uses AIO Redis


00:14:20.540 --> 00:14:23.820
because there's async and await calls to access everything.


00:14:23.820 --> 00:14:24.700
- Yeah, it's beautiful.


00:14:24.700 --> 00:14:26.900
It's a real nice example of async and await as well.


00:14:26.900 --> 00:14:27.740
- Yeah.


00:14:27.740 --> 00:14:31.020
- So I'm sure Brian, you've heard of little Bobby Tables.


00:14:31.020 --> 00:14:33.420
- Yeah, of course.


00:14:33.420 --> 00:14:35.660
I think we brought it up on the show.


00:14:35.660 --> 00:14:37.020
Yeah, I don't know if we've actually,


00:14:37.020 --> 00:14:39.020
have we featured it as a proper joke?


00:14:39.020 --> 00:14:40.540
I don't know what we have.


00:14:40.540 --> 00:14:42.940
Nonetheless, this one is no joke.


00:14:42.940 --> 00:14:44.940
This is just little table.


00:14:44.940 --> 00:14:46.140
I didn't know what I was thinking.


00:14:46.140 --> 00:14:46.980
I know what I was thinking.


00:14:46.980 --> 00:14:48.060
I was curious.


00:14:48.060 --> 00:14:49.820
I didn't want to commit as much effort


00:14:49.820 --> 00:14:51.880
as it turned out to be into having


00:14:51.880 --> 00:14:54.060
like a broad discussion about this.


00:14:54.060 --> 00:14:56.300
But I thought, okay, well, we have dictionaries.


00:14:56.300 --> 00:14:58.680
And so I can go and find a single key,


00:14:58.680 --> 00:14:59.900
pass in a certain key,


00:14:59.900 --> 00:15:02.240
and then get the thing back or not, right?


00:15:02.240 --> 00:15:05.420
So if I've got like, I don't know,


00:15:05.420 --> 00:15:10.120
users, I could have the user ID and then the user object comes back.


00:15:10.120 --> 00:15:12.800
If I index the dictionary like that, totally simple, right?


00:15:12.800 --> 00:15:16.600
What if we wanted to ask that question two ways on the same data structure?


00:15:16.600 --> 00:15:22.280
What if I wanted to say, give me the user by ID and give me the user by email.


00:15:22.280 --> 00:15:26.680
So, so one possible way, I guess you could just cram all the IDs and all the


00:15:26.680 --> 00:15:32.040
emails into the dictionary, but then things like, you know, enumerate over


00:15:32.040 --> 00:15:35.840
predict.items breaks because you get, you know,


00:15:35.840 --> 00:15:39.000
every now and then it's integers or it's strings


00:15:39.000 --> 00:15:41.300
and then it's a duplicate of the users,


00:15:41.300 --> 00:15:43.840
like in.items or .values.


00:15:43.840 --> 00:15:45.040
So it's not really a great one.


00:15:45.040 --> 00:15:48.300
So I said, does Python have like a structure


00:15:48.300 --> 00:15:49.800
that is not a database?


00:15:49.800 --> 00:15:52.780
Because I do not want to do database stuff.


00:15:52.780 --> 00:15:55.760
Like if I wanted to do that, I would just use a database.


00:15:55.760 --> 00:15:58.780
A thing that is lightweight in memory and easy to use


00:15:58.780 --> 00:16:03.220
that lets me put something like a user in there,


00:16:03.220 --> 00:16:05.580
but then be able to ask, give me the user by ID,


00:16:05.580 --> 00:16:08.880
give me the user by email, that is fast, right?


00:16:08.880 --> 00:16:11.020
So dictionaries work because they're indexed


00:16:11.020 --> 00:16:14.500
and they're insanely like near, you know,


00:16:14.500 --> 00:16:17.480
a one type of performance on getting back


00:16:17.480 --> 00:16:19.020
the content that's in there, right?


00:16:19.020 --> 00:16:22.540
So I wanna be able to do that both with email and ID, not.


00:16:22.540 --> 00:16:24.680
I'm gonna go on this rant some more later.


00:16:24.680 --> 00:16:25.820
I'm actually trying to pull together


00:16:25.820 --> 00:16:26.860
all the responses I got,


00:16:26.860 --> 00:16:29.540
'cause I got a bunch of things given back to me.


00:16:29.540 --> 00:16:31.380
A lot of people suggested pandas,


00:16:31.380 --> 00:16:33.860
but I wanna store non-tabular data.


00:16:33.860 --> 00:16:37.540
So I'm not sure pandas, which is tabular-ish, makes sense.


00:16:37.540 --> 00:16:40.600
Nonetheless, one thing I did come up with that's probably


00:16:40.600 --> 00:16:42.780
the closest to what I was asking for


00:16:42.780 --> 00:16:45.620
without me doing any work, which I'm not against doing work,


00:16:45.620 --> 00:16:46.920
but if something exists, you know,


00:16:46.920 --> 00:16:48.540
let me pip install it, right?


00:16:48.540 --> 00:16:51.500
Is this thing called Lighttable by Paul McGuire.


00:16:51.500 --> 00:16:53.140
Sorry, not Lighttable, Littletable.


00:16:53.140 --> 00:16:54.100
(laughs)


00:16:54.100 --> 00:16:55.340
Littletable.


00:16:55.340 --> 00:16:59.380
And it gives you a schema-less in-memory thing


00:16:59.380 --> 00:17:01.100
that's kind of like a dictionary,


00:17:01.100 --> 00:17:04.580
but gives you ORM-like access to the objects.


00:17:04.580 --> 00:17:06.180
- Okay. - Okay, so it's like,


00:17:06.180 --> 00:17:09.100
think of like an in-memory database, basically,


00:17:09.100 --> 00:17:11.820
that you don't have to go create table,


00:17:11.820 --> 00:17:15.620
you know, set column type, name this to,


00:17:15.620 --> 00:17:17.540
you know, var char 16 type,


00:17:17.540 --> 00:17:20.140
and like, you don't have to actually define the table,


00:17:20.140 --> 00:17:22.580
like a full-on database, right?


00:17:22.580 --> 00:17:25.140
You just say it has, you know, put these things in it,


00:17:25.140 --> 00:17:26.340
like you would a dictionary,


00:17:26.340 --> 00:17:28.780
and then you can access all the elements.


00:17:28.780 --> 00:17:29.620
What do you think?


00:17:29.620 --> 00:17:32.500
- I think I'd like to try to solve your problem also.


00:17:32.500 --> 00:17:34.580
- It's a fun programming problem, right?


00:17:34.580 --> 00:17:35.620
But this thing is pretty cool


00:17:35.620 --> 00:17:38.260
'cause it lets you do like greater than queries.


00:17:38.260 --> 00:17:40.780
It has indexes on all of the columns


00:17:40.780 --> 00:17:43.500
or the columns that you say you want them on.


00:17:43.500 --> 00:17:45.300
All you do is say, it's like creating a dictionary


00:17:45.300 --> 00:17:46.840
and say, I'm gonna put in a thing by ID,


00:17:46.840 --> 00:17:48.020
I'm gonna put in a thing by email,


00:17:48.020 --> 00:17:49.300
I'm gonna put in a thing by city,


00:17:49.300 --> 00:17:51.660
and I want to index for all of those.


00:17:51.660 --> 00:17:54.120
So it's like dictionary-like speed,


00:17:54.120 --> 00:17:55.280
which is pretty cool.


00:17:55.280 --> 00:17:59.480
It even does like in-memory joins and all sorts of stuff.


00:17:59.480 --> 00:18:01.280
So yeah.


00:18:01.280 --> 00:18:02.120
- Okay.


00:18:02.120 --> 00:18:02.940
- Yeah.


00:18:02.940 --> 00:18:04.540
And the result of like a query can be


00:18:04.540 --> 00:18:06.240
like another little table.


00:18:06.240 --> 00:18:07.520
So I could like do a filter


00:18:07.520 --> 00:18:09.960
and select only a couple of columns


00:18:09.960 --> 00:18:12.000
and then out comes a little baby little table,


00:18:12.000 --> 00:18:14.080
a little even littler little table.


00:18:14.080 --> 00:18:16.280
Anyway, I thought this was a pretty cool thing


00:18:16.280 --> 00:18:20.780
because it lets you kind of do database like stuff


00:18:20.780 --> 00:18:22.440
without the effort, right?


00:18:22.440 --> 00:18:23.620
Do it dynamically.


00:18:23.620 --> 00:18:26.500
Some people said, "Hey, you should just use SQLite."


00:18:26.500 --> 00:18:28.460
I'm like, "Yeah, SQLite's cool,


00:18:28.460 --> 00:18:31.300
"but then I've got to come up with a full-on schema


00:18:31.300 --> 00:18:33.380
"for defining the thing."


00:18:33.380 --> 00:18:34.300
And that gets to be a pain.


00:18:34.300 --> 00:18:36.460
There's also some other options,


00:18:36.460 --> 00:18:38.140
but little table, it looks good.


00:18:38.140 --> 00:18:40.460
- Yeah, I'll have to get an example,


00:18:40.460 --> 00:18:43.180
get your actual problem statement again and try it,


00:18:43.180 --> 00:18:44.140
but this looks neat.


00:18:44.140 --> 00:18:45.800
- Yeah, yeah, absolutely.


00:18:45.800 --> 00:18:48.620
Yeah, well, I'll come back to that for sure as well.


00:18:48.620 --> 00:18:49.740
'Cause I wanna bring,


00:18:49.740 --> 00:18:51.900
like I got so many good recommendations


00:18:51.900 --> 00:18:53.540
and ideas that I think it's probably worth


00:18:53.540 --> 00:18:55.500
just doing a segment on that, but little table.


00:18:55.500 --> 00:18:56.340
- Nice.


00:18:56.340 --> 00:18:58.940
This is something I'm surprised we didn't talk about already


00:18:58.940 --> 00:19:01.420
and maybe we have, but I've forgotten.


00:19:01.420 --> 00:19:02.540
pytest Timeout.


00:19:02.540 --> 00:19:04.500
This was a listener suggestion


00:19:04.500 --> 00:19:07.540
and I think it's pretty much an essential plugin


00:19:07.540 --> 00:19:11.460
for any test suite that you're running,


00:19:11.460 --> 00:19:13.380
especially if it's not something you're running


00:19:13.380 --> 00:19:14.380
where you're watching it.


00:19:14.380 --> 00:19:16.620
So if it's something running on a server


00:19:16.620 --> 00:19:18.780
or continuous integration or something,


00:19:18.780 --> 00:19:21.740
or if it's a long running test suite,


00:19:21.740 --> 00:19:24.500
It's a very simple to use plugin.


00:19:24.500 --> 00:19:27.340
And what you want to make sure is that none of your tests


00:19:27.340 --> 00:19:29.740
run longer than a certain number of seconds.


00:19:29.740 --> 00:19:32.220
All the people out there that are like scratching


00:19:32.220 --> 00:19:34.460
your head thinking, wow, there's a test


00:19:34.460 --> 00:19:36.460
that runs longer than a second.


00:19:36.460 --> 00:19:38.860
Yes, there are tests that run longer than a second.


00:19:38.860 --> 00:19:40.900
- Especially if they're trying to talk to hardware


00:19:40.900 --> 00:19:43.820
or external things and that thing might not be there


00:19:43.820 --> 00:19:44.740
and it's just waiting.


00:19:44.740 --> 00:19:46.780
- Yeah, there's more to testing than unit testing.


00:19:46.780 --> 00:19:48.580
There's also system testing.


00:19:48.580 --> 00:19:51.180
But anyway, this one's great 'cause you can set up


00:19:51.180 --> 00:19:55.620
configuration in the config file you can throw one number in to say like say you


00:19:55.620 --> 00:20:00.020
have like you know five minutes or something like that or or even just down


00:20:00.020 --> 00:20:03.940
to like three minutes I don't want to make I want to make sure nothing nothing


00:20:03.940 --> 00:20:08.380
runs longer than this and just to make sure that the server doesn't just sit


00:20:08.380 --> 00:20:13.220
spinning all night long and then well let's say you even tighten it closer to


00:20:13.220 --> 00:20:17.140
try to kill off a test if it's running longer than a certain amount but there


00:20:17.140 --> 00:20:21.500
there's like maybe two of your tests that are longer or a few of them that are longer,


00:20:21.500 --> 00:20:26.100
you can put a decorator on those particular tests and give them more time and then the


00:20:26.100 --> 00:20:27.620
rest of them shorter.


00:20:27.620 --> 00:20:32.500
It's very easy to operate and just kind of a must-have for long test suites.


00:20:32.500 --> 00:20:33.500
Yeah, that's super cool.


00:20:33.500 --> 00:20:38.540
Yeah, I mean, sometimes you just rather have the test fail if it's taking way, way, way


00:20:38.540 --> 00:20:41.860
too long and you're like, "I'm pretty sure this is going to fail," but not right away.


00:20:41.860 --> 00:20:46.460
I would recommend just trying it out and kind of like look at the time of your tests and


00:20:46.460 --> 00:20:53.100
stuff and then set it so that it actually kills one of your tests in the middle or stick a spin


00:20:53.100 --> 00:20:57.580
in there or something like that just to verify it does because it is sort of operating system


00:20:57.580 --> 00:21:03.580
dependent and there's some configuration allowed in the plugin to be able to use either signals or


00:21:03.580 --> 00:21:11.100
kill commands or process killing. There's different ways to stop a test that's going too long and


00:21:11.100 --> 00:21:13.860
and that's so test it before you deploy it,


00:21:13.860 --> 00:21:15.140
but it's a good thing.


00:21:15.140 --> 00:21:15.980
- Do a meta test.


00:21:15.980 --> 00:21:17.620
- Yeah, test of your test.


00:21:17.620 --> 00:21:18.780
- Exactly.


00:21:18.780 --> 00:21:19.620
Super cool.


00:21:19.620 --> 00:21:20.440
Okay, that's a great one.


00:21:20.440 --> 00:21:23.380
And you know, use case is super straightforward.


00:21:23.380 --> 00:21:25.500
I have got one for you that has got me


00:21:25.500 --> 00:21:26.820
really, really excited.


00:21:26.820 --> 00:21:27.940
It's called events.


00:21:27.940 --> 00:21:31.900
So in Python, we have functions as first class objects,


00:21:31.900 --> 00:21:32.740
right?


00:21:32.740 --> 00:21:35.740
You can pass a function around super easy, right?


00:21:35.740 --> 00:21:39.260
Like if there's some part of your program is gonna run


00:21:39.260 --> 00:21:41.220
you want to get a function called when it's done,


00:21:41.220 --> 00:21:42.780
you can pass that function,


00:21:42.780 --> 00:21:44.420
it'll do its work, you can call it, right?


00:21:44.420 --> 00:21:45.700
You have this kind of,


00:21:45.700 --> 00:21:48.620
this observer style programming, right?


00:21:48.620 --> 00:21:51.460
What requires programming on your behalf


00:21:51.460 --> 00:21:53.980
is to have that happen for more than one thing.


00:21:53.980 --> 00:21:57.780
Like I would like parts of my program to subscribe


00:21:57.780 --> 00:21:59.820
to being notified about events,


00:21:59.820 --> 00:22:03.940
and one or more of them get called when this thing happens.


00:22:03.940 --> 00:22:06.940
So a friend of mine, Nicola Aroshi,


00:22:06.940 --> 00:22:11.300
put together a really cool project called events.


00:22:11.300 --> 00:22:13.780
And the idea is that it adds event subscription


00:22:13.780 --> 00:22:16.180
and callback to the Python language.


00:22:16.180 --> 00:22:17.580
In like a super simple way.


00:22:17.580 --> 00:22:20.920
So go to a function that is an event.


00:22:20.920 --> 00:22:22.700
If I want my function to be called by it,


00:22:22.700 --> 00:22:26.060
I would say like, if I want the event on change,


00:22:26.060 --> 00:22:29.420
I would say my class dot on change


00:22:29.420 --> 00:22:32.740
plus equals some function to call.


00:22:32.740 --> 00:22:33.860
And if there's already one there,


00:22:33.860 --> 00:22:35.940
it's just gonna add it to the list of all the functions


00:22:35.940 --> 00:22:37.940
that'll be called when that event fires.


00:22:37.940 --> 00:22:39.180
And if at some point I decide


00:22:39.180 --> 00:22:40.300
I don't wanna hear about it anymore,


00:22:40.300 --> 00:22:43.900
I just go to my class dot or my object dot on change


00:22:43.900 --> 00:22:46.260
minus equals the function I wanna take out of that


00:22:46.260 --> 00:22:47.700
subscription list.


00:22:47.700 --> 00:22:48.540
And that's it.


00:22:48.540 --> 00:22:49.360
- Oh, that's neat.


00:22:49.360 --> 00:22:50.240
- Isn't that slick?


00:22:50.240 --> 00:22:53.620
And then to call it, you just say object dot on change


00:22:53.620 --> 00:22:54.720
and you pass the arguments


00:22:54.720 --> 00:22:56.700
and then all those functions get called in order.


00:22:56.700 --> 00:22:57.540
- Oh, this is cool.


00:22:57.540 --> 00:23:00.660
- Yeah, so it's, if you have to do any sort of


00:23:00.660 --> 00:23:03.940
observer design pattern, event subscription stuff,


00:23:03.940 --> 00:23:05.460
like this is super, super nice.


00:23:05.460 --> 00:23:09.260
- And it's inspired on the C# language base event keyword,


00:23:09.260 --> 00:23:12.280
which is based on delegates, basically function pointers.


00:23:12.280 --> 00:23:13.880
It doesn't really matter if you know about that


00:23:13.880 --> 00:23:16.080
or care about it, but if you know about the C# version,


00:23:16.080 --> 00:23:18.260
this basically brings that to the Python language.


00:23:18.260 --> 00:23:19.480
- Yeah, I kind of want to build up


00:23:19.480 --> 00:23:21.720
a finite state machine using this.


00:23:21.720 --> 00:23:22.560
- It's cool, right?


00:23:22.560 --> 00:23:25.560
- Yeah, I mean, and it could make it really readable.


00:23:25.560 --> 00:23:28.440
- Yeah, I have a gist that I'm working on,


00:23:28.440 --> 00:23:29.560
or I have some code I'm working on,


00:23:29.560 --> 00:23:31.720
I'll post as a gist that people can check out


00:23:31.720 --> 00:23:34.320
that is like a lot better than what they have


00:23:34.320 --> 00:23:35.760
in the documentation.


00:23:35.760 --> 00:23:38.520
So the documentation takes like this raw event source


00:23:38.520 --> 00:23:40.920
and shows you how you can subscribe and unsubscribe to it.


00:23:40.920 --> 00:23:42.920
But what I've got is something that's like,


00:23:42.920 --> 00:23:44.920
here's how you have a class, right?


00:23:44.920 --> 00:23:47.140
Like, you know, a thing on the screen,


00:23:47.140 --> 00:23:48.900
and then you could have like subscribe


00:23:48.900 --> 00:23:51.280
to when the location changes or the size changes,


00:23:51.280 --> 00:23:52.880
or, you know, those kinds of things.


00:23:52.880 --> 00:23:56.600
And it's more of like a natural programming analogy.


00:23:56.600 --> 00:23:58.060
So I'll put up the gist for that.


00:23:58.060 --> 00:23:59.280
I'm just working on a few things


00:23:59.280 --> 00:24:01.280
to see if I can make it even slightly better.


00:24:01.280 --> 00:24:02.840
I'm seeing if I can use descriptors


00:24:02.840 --> 00:24:06.640
so that the event triggering happens behind the scenes


00:24:06.640 --> 00:24:08.360
without you even have to program it as well.


00:24:08.360 --> 00:24:11.060
So like right now, from the outside,


00:24:11.060 --> 00:24:12.260
using it is really easy,


00:24:12.260 --> 00:24:15.680
but you do have to sort of like know when something's changed


00:24:15.680 --> 00:24:17.360
and then call that, raise that event.


00:24:17.360 --> 00:24:18.560
I think I can use descriptors


00:24:18.560 --> 00:24:20.560
to maybe make it seamless on both sides,


00:24:20.560 --> 00:24:23.080
but I'm still playing with that.


00:24:23.080 --> 00:24:25.640
- Now, do you know if all of the events


00:24:25.640 --> 00:24:27.360
get called by the thing changing,


00:24:27.360 --> 00:24:29.520
the making the event happen?


00:24:29.520 --> 00:24:30.360
- Yes. - They do?


00:24:30.360 --> 00:24:31.180
- Yeah. - Okay.


00:24:31.180 --> 00:24:33.820
- They get called by the thing that,


00:24:33.820 --> 00:24:36.340
whatever decides to raise the event,


00:24:36.340 --> 00:24:38.420
that's the thing that's doing the calling.


00:24:38.420 --> 00:24:41.260
The events just basically manage


00:24:41.260 --> 00:24:43.700
what are the functions to be called in what order,


00:24:43.700 --> 00:24:46.940
and then you call it and it just delegates onto them.


00:24:46.940 --> 00:24:49.860
Also, you get to just arbitrarily pick the parameters


00:24:49.860 --> 00:24:52.140
that get passed along.


00:24:52.140 --> 00:24:53.620
But it seems like a good idea to say,


00:24:53.620 --> 00:24:56.540
this event always takes these kinds of arguments


00:24:56.540 --> 00:24:59.660
and whatever, there's not a lot of structure there.


00:24:59.660 --> 00:25:03.060
You do get the only real safety is you can say,


00:25:03.060 --> 00:25:04.220
when you create it, you can say,


00:25:04.220 --> 00:25:06.020
these are the only allowed events


00:25:06.020 --> 00:25:09.900
because it's kind of just full on dynamic programming.


00:25:09.900 --> 00:25:11.700
But you can say these three things,


00:25:11.700 --> 00:25:14.200
you can subscribe and unsubscribe and call.


00:25:14.200 --> 00:25:16.140
Anything else, we're gonna say it doesn't exist.


00:25:16.140 --> 00:25:17.580
So that's pretty nice.


00:25:17.580 --> 00:25:18.700
- Yeah, yeah.


00:25:18.700 --> 00:25:19.860
- Yeah, it provides a little safety.


00:25:19.860 --> 00:25:20.700
- Cool. - Yeah.


00:25:20.700 --> 00:25:22.260
- Well, that's our six items.


00:25:22.260 --> 00:25:23.780
Do you have any extras for us?


00:25:23.780 --> 00:25:24.620
- Not really.


00:25:24.620 --> 00:25:25.700
Just, I sort of talked about it.


00:25:25.700 --> 00:25:26.820
I was gonna talk about it here,


00:25:26.820 --> 00:25:28.220
but I talked about it in the,


00:25:28.220 --> 00:25:29.340
where we talked about what we're doing,


00:25:29.340 --> 00:25:30.700
how people can support us.


00:25:30.700 --> 00:25:32.620
I finished the Python memory management course.


00:25:32.620 --> 00:25:34.240
The thing is so cool.


00:25:34.240 --> 00:25:35.860
It's a five hour course,


00:25:35.860 --> 00:25:37.460
just diving into the internals


00:25:37.460 --> 00:25:39.580
of like Python memory management algorithms.


00:25:39.580 --> 00:25:41.900
And what I thought I would create


00:25:41.900 --> 00:25:43.060
was something that was like


00:25:43.060 --> 00:25:44.860
understanding Python memory management,


00:25:44.860 --> 00:25:47.140
but there's actually a ton of techniques I discovered


00:25:47.140 --> 00:25:49.740
that actually let you run your code in a way


00:25:49.740 --> 00:25:51.820
that's like, well, now it uses half as much memory


00:25:51.820 --> 00:25:54.060
and it's 30% faster and stuff like that.


00:25:54.060 --> 00:25:56.340
So I didn't think there would be a lot of actionable stuff


00:25:56.340 --> 00:25:57.900
coming out of it, but there is,


00:25:57.900 --> 00:25:59.900
which I think is pretty cool, actually.


00:25:59.900 --> 00:26:01.340
- Oh, nice. - Yeah. How about you?


00:26:01.340 --> 00:26:04.640
I'm pretty excited that pytest 6 is out.


00:26:04.640 --> 00:26:09.680
A couple weeks ago, we talked about the 6 being in sort of a beta release,


00:26:09.680 --> 00:26:10.780
but it's out now.


00:26:10.780 --> 00:26:15.660
And I wanted to mention that episode 125 of Testing Code


00:26:15.660 --> 00:26:16.960
walks through those changes.


00:26:16.960 --> 00:26:20.020
This is due to the miracles of time travel.


00:26:20.020 --> 00:26:21.500
This has not been recorded yet,


00:26:21.500 --> 00:26:25.260
but it will be recorded and released by last week.


00:26:25.260 --> 00:26:26.860
[laughs]


00:26:26.860 --> 00:26:29.420
- Perfect, time travel, I love it.


00:26:29.420 --> 00:26:31.740
You've chosen the perfect joke.


00:26:31.740 --> 00:26:35.300
So the only question I have for you before we do the joke


00:26:35.300 --> 00:26:39.140
is am I the school administrator IT person or am I the mom?


00:26:39.140 --> 00:26:40.300
- Oh, you be the mom.


00:26:40.300 --> 00:26:41.220
- Okay. - Okay.


00:26:41.220 --> 00:26:42.580
- So the phone rings, I pick it up.


00:26:42.580 --> 00:26:45.020
- Yeah, hi, this is your son's school.


00:26:45.020 --> 00:26:46.700
We're having some computer trouble.


00:26:46.700 --> 00:26:48.860
- Oh dear, did he break something?


00:26:48.860 --> 00:26:53.620
- In a way, did you really name your son Robert,


00:26:53.620 --> 00:26:57.620
- Robert, single quote, parentheses, semicolon,


00:26:57.620 --> 00:27:01.420
drop table, students, semicolon, minus minus.


00:27:01.420 --> 00:27:03.740
- Oh yes, little Bobby Tables, we call him.


00:27:03.740 --> 00:27:06.080
- Well, we've lost this year's student records.


00:27:06.080 --> 00:27:07.020
I hope you're happy.


00:27:07.020 --> 00:27:07.980
- And I hope you've learned


00:27:07.980 --> 00:27:10.420
to sanitize your database inputs.


00:27:10.420 --> 00:27:12.820
Be on the lookout for that SQL injection, baby.


00:27:12.820 --> 00:27:15.460
I love it, this is so good.


00:27:15.460 --> 00:27:17.460
This is absolutely one of the most classic


00:27:17.460 --> 00:27:19.420
computer jokes there is.


00:27:19.420 --> 00:27:20.660
- Yeah, I love it.


00:27:20.660 --> 00:27:23.420
- Because it probably would actually work.


00:27:23.420 --> 00:27:29.820
It reminds me of the guy who said that his, he got his license plate to be


00:27:29.820 --> 00:27:32.900
the, the characters in U L L no.


00:27:32.900 --> 00:27:33.340
Yeah.


00:27:33.340 --> 00:27:34.260
I heard about that.


00:27:34.260 --> 00:27:34.580
Yeah.


00:27:34.580 --> 00:27:38.860
And he ended up getting all the like automated, you know, you drove through a


00:27:38.860 --> 00:27:43.460
traffic light sort of thing, tickets for all the records that were no.


00:27:43.460 --> 00:27:44.740
Yeah.


00:27:44.740 --> 00:27:48.940
Or any time you didn't have data with them, any police officer that forgot to


00:27:48.940 --> 00:27:51.060
enter the license plate, it would go to him.


00:27:53.300 --> 00:27:56.500
He thought he would get out of it because they wouldn't be able to listen to him, but oh no.


00:27:56.500 --> 00:27:58.500
[laughter]


00:27:58.500 --> 00:28:00.500
- That's hilarious. - Awesome, awesome.


00:28:00.500 --> 00:28:02.900
All right, well, great to chat with you as always.


00:28:02.900 --> 00:28:04.900
- All right, you too. Bye. - Bye.


00:28:04.900 --> 00:28:09.100
Thank you for listening to Python Bytes. Follow the show on Twitter @PythonBytes.


00:28:09.100 --> 00:28:12.100
That's Python Bytes as in B-Y-T-E-S.


00:28:12.100 --> 00:28:15.100
And get the full show notes at PythonBytes.fm.


00:28:15.100 --> 00:28:20.100
If you have a news item you want featured, just visit PythonBytes.fm and send it our way.


00:28:20.100 --> 00:28:22.100
We're always on the lookout for sharing something cool.


00:28:22.100 --> 00:28:26.180
This is Brian Okken, and on behalf of myself and Michael Kennedy, thank you for listening


00:28:26.180 --> 00:28:28.620
and sharing this podcast with your friends and colleagues.


00:28:28.620 --> 00:28:38.620
[BLANK_AUDIO]

