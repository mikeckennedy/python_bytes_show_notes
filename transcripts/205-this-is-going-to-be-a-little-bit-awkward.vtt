WEBVTT

00:00:00.001 --> 00:00:03.940
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly

00:00:03.940 --> 00:00:09.480
to your earbuds. This is episode 205, recorded October 21st. I'm Michael Kennedy.

00:00:09.480 --> 00:00:10.480
And I'm Brian Okken.

00:00:10.480 --> 00:00:15.660
And this episode is brought to you by us. More about that later, how you can support what we're

00:00:15.660 --> 00:00:20.260
doing right now. Brian, I'm really sorry, man, but I've got something a little bit awkward to

00:00:20.260 --> 00:00:20.700
talk about.

00:00:20.700 --> 00:00:21.880
Well, this is awkward.

00:00:21.880 --> 00:00:25.280
I know, but luckily it's just you and me, so you don't mind if I just sort of

00:00:25.280 --> 00:00:26.500
tell it to you straight?

00:00:26.500 --> 00:00:27.300
Yeah, just tell me.

00:00:27.300 --> 00:00:32.920
Okay. All right. Well, sometimes I have an array and it's perfectly tabular. Like it's,

00:00:32.920 --> 00:00:39.140
it's maybe just a linear array or sometimes the array goes across like every entry is like 20.

00:00:39.140 --> 00:00:43.480
It's like a list with like 20 length, 20 lists in it. It's all the right size, but sometimes,

00:00:43.480 --> 00:00:48.380
you know, maybe it's, it's the wrong shape and it's awkward and it's hard to deal with in Python.

00:00:48.380 --> 00:00:55.760
You know, a lot of array processing happens in NumPy, but NumPy is all about rectangular like

00:00:55.760 --> 00:01:00.580
things. And so if you've got data, that's kind of like an array, multi-dimensional array, but it

00:01:00.580 --> 00:01:02.380
doesn't fit that shape. What do you do?

00:01:02.380 --> 00:01:08.520
So, Simon Thor sent us a message and said, you all should talk about awkward arrays.

00:01:08.520 --> 00:01:16.040
So awkward arrays, this is a, it's actually a pretty advanced library. So it's a little bit

00:01:16.040 --> 00:01:23.320
like NumPy and it has NumPy like idioms and so on, but it's a library for nested variable size data,

00:01:23.580 --> 00:01:30.020
including arbitrary length lists, records, mixed data types, missing data, and all those things and

00:01:30.020 --> 00:01:37.000
dealing with those with NumPy like idioms. So it's better for handling, you know, like at what I

00:01:37.000 --> 00:01:42.440
described, not the same shaped data. It's kind of the same dimensions, but it's not always the same

00:01:42.440 --> 00:01:49.160
length on the various parts. And you could even use it with things like Numba to JIT compile the code to

00:01:49.160 --> 00:01:55.660
make it even faster. And they just announced version 1.0 of this library, which was originally

00:01:55.660 --> 00:02:01.640
written in Python. So it was good, but not super, super fast. And they rewrote the core in C++.

00:02:01.640 --> 00:02:08.420
So now it's like a lot of the data science stuff, C++ at where the, in the business end of the

00:02:08.420 --> 00:02:10.820
library. So it's super fast. Nice.

00:02:10.820 --> 00:02:12.760
Yeah. Pretty cool. And what do you think about the logo?

00:02:12.760 --> 00:02:20.660
The logo is actually great. It's awkward array, but the second array is below awkward and the A is

00:02:20.660 --> 00:02:26.140
capitalized. So it sort of runs into the K and the W and the F to squish out of the way. It's very

00:02:26.140 --> 00:02:26.460
clever.

00:02:26.460 --> 00:02:31.600
Yeah. Kind of bent and awkward looking. Yeah. It's pretty clever. I like it as well. Another thing

00:02:31.600 --> 00:02:35.260
that I thought was interesting, if you open up the link over there, you don't have to, but if you were

00:02:35.260 --> 00:02:39.960
to go there, like right on the page, it says, here's the Python quickstart. Oh, and here's the C++

00:02:40.020 --> 00:02:46.140
quickstart. So this library, the internals of it are written in C++, right? Okay. So that it's fast

00:02:46.140 --> 00:02:52.500
from Python, but also you can go straight to the template library side of C++ and use it directly.

00:02:52.500 --> 00:02:57.720
If you are say building some stuff in C++ and also want to use this library, or maybe you're building a

00:02:57.720 --> 00:03:04.000
library that does data sciencey things and you have a big C++ C component aspect of it, you could use the

00:03:04.000 --> 00:03:09.720
C side of it directly there. Nice. Yeah. So that's actually something I don't see almost ever is here's

00:03:09.720 --> 00:03:15.440
the Python library and the C++ API that corresponds to it. Yeah, that's pretty cool. Also, it's,

00:03:15.440 --> 00:03:20.040
I have a lot of cases for this. I'm going to definitely check this out. This is great.

00:03:20.040 --> 00:03:24.960
Yeah, it's pretty cool. So thank you, Simon, for sending that in. Last quick note is when you install

00:03:24.960 --> 00:03:32.020
it, you pip install awkward, the number one, not just awkward. I think awkward, which my gosh,

00:03:32.020 --> 00:03:39.420
it's just so weird to have a package called awkward, but it's great. Anyway, I think awkward is the older

00:03:39.420 --> 00:03:45.140
version and awkward one is this new 1.0 release. I think it's the same library. I wasn't sure if like,

00:03:45.140 --> 00:03:49.760
I was like, okay, if this is awkward one, what is just awkward by itself? It's got to even be more

00:03:49.760 --> 00:03:54.980
awkward, but I think it's the same library. It's just a different API version. Okay. Okay. Yeah.

00:03:54.980 --> 00:03:58.520
You might be surprised by it, but nonetheless, it's, it's pretty good library.

00:03:58.520 --> 00:04:03.320
You want to check it out. Yeah. You got any surprises for us? Yeah. The surprises came from Ned

00:04:03.320 --> 00:04:10.000
Batchelder. So, Ned surprised us with, some surprising order dict, ordered dict surprises.

00:04:10.000 --> 00:04:15.800
So I think we've covered this, but in Python three, six dictionaries changed a little bit. So normal

00:04:15.800 --> 00:04:20.560
dictionary, just, if you just say dict or just declare one, they retain their insertion order.

00:04:20.560 --> 00:04:26.700
If you list them out again, or just, you know, say, you know, if you have X equals some dictionary

00:04:26.700 --> 00:04:31.700
and print X on the, the REPL, it'll just print it in the same order it arrived in.

00:04:31.700 --> 00:04:38.660
Right. And if you do like four K comma V in, you know, dictionary dot items, you'll get them in the

00:04:38.660 --> 00:04:44.340
same order now, which is nice. I think probably one of the most annoying things was if you are saving

00:04:44.340 --> 00:04:49.560
a dictionary, if you're going back and forth between a JSON file into a dictionary and then you save it

00:04:49.560 --> 00:04:55.340
again, right? Like that could just randomly be changing before. Whereas you'll be getting like,

00:04:55.340 --> 00:04:59.140
yeah. Diffs on that file. Anyway, like this stability is nice.

00:04:59.140 --> 00:05:03.800
I really like it, but I just sort of assumed I knew there may have been some differences. There's

00:05:03.800 --> 00:05:10.320
still a collections dot ordered dict that is, around it's still around and there's a few reasons

00:05:10.320 --> 00:05:15.860
for it. And then one of them is just because it's a class that some other stuff derives from and it

00:05:15.860 --> 00:05:21.960
would break backwards compatibility to, to remove it. So I'm glad it's still there, but Ned brings up a

00:05:21.960 --> 00:05:25.200
couple of surprising things around it. The first actually wasn't that

00:05:25.200 --> 00:05:30.340
surprising to me. What the, they're ordered, but you can't get access them by order. You can't say,

00:05:30.340 --> 00:05:36.040
give me the first one by like saying like brackets zero or something. Does it surprise you? It doesn't

00:05:36.040 --> 00:05:36.860
really surprise me.

00:05:36.860 --> 00:05:43.100
Not really. I mean, I would just do, maybe just get the, yeah, just get the first thing out of items

00:05:43.100 --> 00:05:48.300
and then just be happy with that. I don't know. But yeah, there's no way to like index like bracket zero

00:05:48.300 --> 00:06:14.800
Right. That's okay. The thing that actually I didn't really think about before was that, Ned brings up is that how equality and order mix. So in the dictionaries for Python 3.6 and above now, if you declare two dictionaries with the same content, but they have, they've, they've, they're created in the different order. They're still going to be equal. So two dictionaries are equal if they have equal contents.

00:06:14.940 --> 00:06:28.500
It would super bug me. Like if I have a equals one, B equals two, or B equals two, A equals one. Like if the dictionary contents are the same, but the order changes and you're, they, they say they're not equal. That would, I mean, that would bug me. I think.

00:06:28.500 --> 00:06:36.320
Right. But order dict, apparently it does matter. So if you, if you care about order, you can use order dict to make sure they're in the same order.

00:06:36.460 --> 00:06:41.520
Yeah. I guess you're explicitly saying I super care about order. So if the order changes, they're not the same.

00:06:41.520 --> 00:06:46.940
Yeah. Yeah. So just a little surprise, surprise, surprise, but thanks Ned.

00:06:46.940 --> 00:06:50.000
Yeah, that's cool. I, I wouldn't have known that. That's pretty neat.

00:06:50.000 --> 00:07:01.460
Speaking of knowing stuff, you and I work on a few things. We've got some Patreon stuff going on. A lot of ways people can support us. I'll just really quick shout out. As a lot of people know, if you want to get better at Python, learn some things,

00:07:01.460 --> 00:07:11.600
check out training.talkpython.fm. We've got a ton of classes coming up on almost 200 hours of polished Python content over there, which is pretty crazy.

00:07:11.600 --> 00:07:27.080
Yeah. And I love the content there. We now have 55 supporters on Patreon, which is super cool. And if you go to any of our show notes, there's a Patreon link on the side. You can click on it. And, and a lot of people are just sending a buck a month and it's just awesome, but it adds up and it helps out.

00:07:27.080 --> 00:07:27.640
Yeah.

00:07:27.640 --> 00:07:27.960
Thank you.

00:07:28.400 --> 00:07:33.040
Yeah. It definitely helps out covers operating expenses like editing and transcripts and whatnot.

00:07:33.040 --> 00:07:36.060
Yeah. So what'd you got next for us?

00:07:36.060 --> 00:07:42.040
I have a follow on to a follow on to a follow on. How about that?

00:07:42.040 --> 00:07:42.600
That's great.

00:07:42.600 --> 00:07:54.780
Yes. So we spoke about black cell magic, which is a way to type a thing into a cell in Jupyter and have black formatted. And a bunch of people said, Oh, and there's this and there's that. And there's all these great things.

00:07:56.080 --> 00:07:59.560
And you covered, I think it was NB, NB QA.

00:07:59.560 --> 00:08:00.340
QA. Yeah.

00:08:00.340 --> 00:08:03.060
I wasn't sure the last letter QA, which is cool.

00:08:03.160 --> 00:08:08.560
So that's kind of like a bigger set of tooling and other libraries along with black on top of that.

00:08:08.560 --> 00:08:21.500
But one of the things that bugs me about Jupyter notebooks is they just seem to lack some of this like proper editor support and black like format code is one of those, but it's not the only one that bugs me.

00:08:22.000 --> 00:08:24.860
And it took me a while to kind of get the Zen of notebooks.

00:08:24.860 --> 00:08:27.240
Like, why do I create one of those instead of something else?

00:08:27.240 --> 00:08:28.060
And what's the flow?

00:08:28.060 --> 00:08:36.640
And I really do find them valuable, but it drives me crazy that if I type, you know, class object library dot, I just have to know.

00:08:36.640 --> 00:08:38.100
Like, there's no help.

00:08:38.180 --> 00:08:39.800
I have to know what I'm supposed to type.

00:08:39.800 --> 00:08:42.740
And then when I type it out, I say parentheses.

00:08:43.380 --> 00:08:47.080
And there's some number of arguments that go into this function call or whatever.

00:08:47.080 --> 00:08:50.840
I have to just know the order, the type, the name, everything.

00:08:50.840 --> 00:08:58.280
Now, before someone mails in, I know I can type thing dot and then press tab and it'll come up in a list.

00:08:58.280 --> 00:09:02.860
But like this, like, please help me out on request.

00:09:02.860 --> 00:09:03.360
I don't know.

00:09:03.360 --> 00:09:08.320
It's like just typing dot should just I should be able to just flow and not have to like, OK, type.

00:09:08.320 --> 00:09:11.060
And then, OK, now what's the documentation again for the signature?

00:09:11.900 --> 00:09:12.980
Where is it defined?

00:09:12.980 --> 00:09:13.880
All those kinds of things.

00:09:13.880 --> 00:09:26.640
So there's this cool project that was sent in by Anders Kalmer called JupyterLab LSP for Language Server Protocol Integration or more.

00:09:26.640 --> 00:09:29.140
It rolls right off the tongue.

00:09:29.140 --> 00:09:35.220
Language Server Protocol Integration for JupyterLab is its official name, but it's super cool.

00:09:35.220 --> 00:09:41.260
It brings a lot of these things that I felt were missing from the Jupyter experience.

00:09:41.260 --> 00:09:46.240
So if you go there, you'll see that there's a bunch of examples, example code, which shows Python.

00:09:46.240 --> 00:09:49.860
It actually works in R, Bash, TypeScript and a bunch of other languages.

00:09:49.860 --> 00:09:52.220
So here are some of the things that are supported.

00:09:52.220 --> 00:10:01.540
One, if I hover over a piece of code, if an underline appears, you can press control to get a tooltip with a function and function or class signature.

00:10:02.000 --> 00:10:06.380
You can get documentation and other information about it just by hovering.

00:10:06.980 --> 00:10:09.360
It'll show you, like, if you write code that's bad.

00:10:09.360 --> 00:10:14.120
Like in Jupyter, if I write code that's bad, it just looks like code that's good, except for it won't run.

00:10:14.120 --> 00:10:17.860
Whereas here, it'll put little squigglies under it and say, there's something wrong with this.

00:10:17.860 --> 00:10:19.580
Or there's a warning here.

00:10:19.580 --> 00:10:20.880
You're doing something wrong.

00:10:21.000 --> 00:10:22.460
So editor stuff like that.

00:10:22.460 --> 00:10:23.700
Jump to definition.

00:10:23.700 --> 00:10:29.800
So you can right click and say, take me to where this variable or this function is defined, which is pretty awesome.

00:10:29.800 --> 00:10:31.360
It'll highlight your references.

00:10:31.360 --> 00:10:38.320
If you place it on a variable like in PyCharm, you've got a variable and you put your cursor on it.

00:10:38.380 --> 00:10:41.440
Like all the places where it's used or defined light up.

00:10:41.440 --> 00:10:42.300
So like that.

00:10:42.300 --> 00:10:43.080
Yeah.

00:10:43.080 --> 00:10:45.520
And, ta-da, auto-completion.

00:10:45.520 --> 00:10:51.420
If I type the character dot, it will know that I want auto-complete so I don't have to keep typing stuff.

00:10:51.420 --> 00:10:52.840
That's pretty cool.

00:10:52.840 --> 00:10:56.360
And then on top of that, it has rename refactorings.

00:10:56.360 --> 00:11:00.860
So you can rename stuff across your cells and things like that.

00:11:00.860 --> 00:11:01.420
Oh, that's great.

00:11:01.420 --> 00:11:02.340
As well as files.

00:11:02.940 --> 00:11:11.020
So, you know, not groundbreaking, world-changing, but it definitely seems like it will take it up a notch in your Jupyter experience, right?

00:11:11.020 --> 00:11:14.460
Just to bring it a little closer to editors like PyCharm and VS Code.

00:11:14.460 --> 00:11:18.260
And it proves the point that the hardest thing in computer science is naming.

00:11:18.260 --> 00:11:18.820
That's right.

00:11:18.820 --> 00:11:22.380
We have a whole function when you get that wrong.

00:11:22.380 --> 00:11:23.340
That's what you do.

00:11:23.340 --> 00:11:23.600
Yeah.

00:11:23.600 --> 00:11:26.120
But I mean the name Jupyter.

00:11:26.120 --> 00:11:26.620
Jupyter.

00:11:26.620 --> 00:11:28.220
Jupyter.

00:11:28.220 --> 00:11:28.800
Jupyter dash.

00:11:28.800 --> 00:11:30.520
Jupyter lab dash LSP.

00:11:30.520 --> 00:11:31.060
Yes.

00:11:31.060 --> 00:11:31.740
Indeed.

00:11:31.740 --> 00:11:32.240
Right.

00:11:32.240 --> 00:11:34.420
All right.

00:11:34.420 --> 00:11:35.340
What's this next one you got?

00:11:35.340 --> 00:11:38.380
Well, speaking of Jupyter, I guess it's a little related.

00:11:38.380 --> 00:11:42.760
This is a project that is implemented as a Jupyter book.

00:11:42.760 --> 00:11:49.020
I'm not sure if we covered Jupyter books, the Jupyter book project before, but it's a pretty neat documentation system.

00:11:49.020 --> 00:11:54.020
This is open source tools and data for music source separation.

00:11:54.020 --> 00:11:59.660
I was researching music, Python music tools recently, came across this.

00:11:59.660 --> 00:12:01.980
And it's really cool.

00:12:01.980 --> 00:12:05.320
So what it is, it's an online book powered by Jupyter book.

00:12:05.320 --> 00:12:11.780
The authors are Ethan Manilow, Prem Sutherman, and Justin Solomon, I think.

00:12:12.320 --> 00:12:24.120
And it's a tutorial intended to guide people through modern open source tooling and data sets for running, evaluating, researching, and deploying source separation approaches and focuses on music.

00:12:24.340 --> 00:12:25.340
Now, that's a mouthful.

00:12:25.340 --> 00:12:26.400
Now, that's a mouthful.

00:12:26.400 --> 00:12:28.520
And maybe that's a limited set of people.

00:12:28.520 --> 00:12:29.520
But it's really neat.

00:12:29.520 --> 00:12:29.520
It uses Python.

00:12:29.520 --> 00:12:30.520
It uses Python.

00:12:30.520 --> 00:12:31.520
It uses Python.

00:12:31.520 --> 00:12:33.520
And it has interactive demos.

00:12:33.520 --> 00:12:39.560
Things with things with audio are way easier to visualize if you have a waveform in front of you.

00:12:39.560 --> 00:12:41.760
And this uses waveforms and stuff.

00:12:41.760 --> 00:12:42.340
It's beautiful.

00:12:42.340 --> 00:12:46.440
One of the things I want to highlight is there's a basics of source separation section.

00:12:46.860 --> 00:12:50.820
And that includes a primer on digitizing audio signals.

00:12:50.820 --> 00:12:58.020
And it looks at frequency, time frequency representations, what phases, some evaluations and measurements.

00:12:58.200 --> 00:13:04.580
Anyway, I think this is the best reference for understanding digitizing signals that I've seen so far.

00:13:04.580 --> 00:13:05.420
It's really great.

00:13:05.420 --> 00:13:06.340
Oh, this is super cool.

00:13:06.340 --> 00:13:14.940
I think maybe the most generally useful thing at all, this is the whole Jupyter book way to create something like this for any knowledge base.

00:13:14.940 --> 00:13:16.600
Yeah, I'd love to see how they do it.

00:13:16.600 --> 00:13:18.740
And it's a creative commons sort of thing.

00:13:18.740 --> 00:13:22.160
They got links to their GitHub repo so anybody can see how they do this.

00:13:22.160 --> 00:13:23.740
So it's really cool.

00:13:23.740 --> 00:13:24.520
I like it.

00:13:24.520 --> 00:13:24.820
Yeah.

00:13:24.820 --> 00:13:25.760
Yeah, it's super cool.

00:13:25.760 --> 00:13:26.780
And they do have it on.

00:13:26.780 --> 00:13:27.920
It's open source on GitHub.

00:13:28.100 --> 00:13:28.860
So that's pretty sweet.

00:13:28.860 --> 00:13:30.680
I do have a complaint, though.

00:13:30.680 --> 00:13:31.060
Okay.

00:13:31.060 --> 00:13:31.920
This is a big deal.

00:13:31.920 --> 00:13:39.520
So there's a section in here on the basics of phase and phase trend, like waveforms and what phases and so on.

00:13:39.520 --> 00:13:44.160
There's some formulas in here where they define J to be the square root of negative one.

00:13:44.160 --> 00:13:46.740
We all know that I is the square root of negative one.

00:13:46.740 --> 00:13:47.100
Come on.

00:13:47.100 --> 00:13:52.340
I mean, it's an imaginary number.

00:13:52.340 --> 00:13:53.420
It doesn't start with J.

00:13:53.420 --> 00:13:54.280
There's an I.

00:13:54.280 --> 00:13:55.900
Sorry, carry on.

00:13:57.280 --> 00:13:59.020
That phase thing is gorgeous.

00:13:59.020 --> 00:14:00.340
It's got, anyway.

00:14:00.340 --> 00:14:02.500
Yeah, the animations and phase is actually really nice.

00:14:02.500 --> 00:14:02.700
Yeah.

00:14:02.700 --> 00:14:05.140
To tell you the truth, I deal with like signals all the time.

00:14:05.140 --> 00:14:08.340
And if you want to get into the math, the math is here.

00:14:08.340 --> 00:14:12.780
So this is, this actually would be a great actual textbook for a university course.

00:14:12.780 --> 00:14:17.520
But I just skip over the math part and read the explanations and stuff.

00:14:17.520 --> 00:14:18.400
It's still useful.

00:14:18.400 --> 00:14:18.760
Yeah.

00:14:18.760 --> 00:14:19.360
Quite neat.

00:14:19.360 --> 00:14:19.780
All right.

00:14:19.780 --> 00:14:20.580
Let me ask you a question.

00:14:20.580 --> 00:14:21.220
Okay.

00:14:21.220 --> 00:14:22.980
You've done C++ ton.

00:14:22.980 --> 00:14:24.440
You still do it every now and then, right?

00:14:24.440 --> 00:14:25.400
I do it every day.

00:14:25.760 --> 00:14:25.940
Yeah.

00:14:25.940 --> 00:14:26.360
Right on.

00:14:26.360 --> 00:14:28.040
Python have pointers.

00:14:28.040 --> 00:14:28.760
Somewhere.

00:14:28.760 --> 00:14:29.820
I guess.

00:14:29.820 --> 00:14:30.920
It's got to.

00:14:30.920 --> 00:14:32.140
Does it have value types?

00:14:32.140 --> 00:14:33.480
Like non-pointers?

00:14:33.480 --> 00:14:35.680
Can I have a thing that doesn't behave like a pointer?

00:14:35.680 --> 00:14:37.300
I think of it more like references.

00:14:37.300 --> 00:14:37.760
Yeah.

00:14:37.760 --> 00:14:39.360
All of Python seems like a reference.

00:14:39.360 --> 00:14:44.000
I want to cover an article, Passed by Reference in Python, Background and Best Practices from

00:14:44.000 --> 00:14:45.100
the Real Python crew.

00:14:45.100 --> 00:14:48.640
And also, I just apparently failed this job interview.

00:14:48.640 --> 00:14:53.420
By Marius Mogiarosi.

00:14:53.420 --> 00:14:55.540
Hopefully, I got that somewhat close.

00:14:55.540 --> 00:15:02.300
So, Marius wrote this article over there on Real Python, which is pretty interesting.

00:15:02.300 --> 00:15:05.420
And it sort of compares languages that have explicit.

00:15:05.420 --> 00:15:11.540
You can explicitly work with things as references or pointers, or you can work with them as local

00:15:11.540 --> 00:15:12.240
value types.

00:15:12.740 --> 00:15:16.640
And then sort of compare that, like there are certain types of problems you might solve

00:15:16.640 --> 00:15:20.560
or address or algorithms over there that don't necessarily make a lot of sense in Python.

00:15:20.560 --> 00:15:23.720
So, how would you simulate some of those behaviors?

00:15:23.720 --> 00:15:28.120
So, Python's interesting because in the guts, like everything is a pointer.

00:15:28.120 --> 00:15:30.000
Even the number four.

00:15:30.000 --> 00:15:33.420
If you ask, like the number four in C.

00:15:33.420 --> 00:15:36.120
If I said four, how many bytes would you think that would take?

00:15:36.260 --> 00:15:37.720
It depends on the, in C?

00:15:37.720 --> 00:15:38.620
Yeah.

00:15:38.620 --> 00:15:40.280
It's the machine type.

00:15:40.280 --> 00:15:40.800
Right.

00:15:40.800 --> 00:15:42.680
So, probably four or eight, something like that, right?

00:15:42.680 --> 00:15:43.320
How many bytes?

00:15:43.320 --> 00:15:43.540
Yeah.

00:15:43.540 --> 00:15:43.820
Yeah.

00:15:43.820 --> 00:15:44.300
Yeah, exactly.

00:15:44.300 --> 00:15:50.240
And when you create one, it would be associated with the stack, unless you did some funky stuff

00:15:50.240 --> 00:15:53.660
to like allocate it and like, you do it in like an amper to get the address.

00:15:53.660 --> 00:15:57.380
But by default, it's like, it comes on the stack and you pass it around and makes a copy

00:15:57.380 --> 00:15:57.660
of it.

00:15:57.660 --> 00:16:01.360
In Python, the number four is a pointer.

00:16:02.280 --> 00:16:07.060
It's a C, it's a pi long object out in the heap.

00:16:07.060 --> 00:16:08.900
And it takes like 28 bytes.

00:16:08.900 --> 00:16:11.600
Like the number four takes 28 bytes, which is pretty interesting.

00:16:11.600 --> 00:16:16.560
But so, everything, like even basic numbers that seem like they just might be values are

00:16:16.560 --> 00:16:19.500
like in the guts, these sort of reference types.

00:16:19.500 --> 00:16:26.100
But the function passing behavior is, they say it's something called pass by assignment,

00:16:26.100 --> 00:16:28.200
which I'll go with that.

00:16:28.360 --> 00:16:34.220
So, when I pass in, like if I create a variable, say x equals four, and then I pass the x to

00:16:34.220 --> 00:16:38.720
a function and that function changes the value of x, it's changed for the function, but not

00:16:38.720 --> 00:16:41.160
for the global thing that had it before, right?

00:16:41.160 --> 00:16:41.480
Yes.

00:16:41.480 --> 00:16:47.060
Well, in C or C++ or C#, like all the examples here, actually C#, you can say,

00:16:47.060 --> 00:16:47.560
no, no, no.

00:16:47.560 --> 00:16:52.980
Pass it so that if the function changes the variable, the one where it came from also changes,

00:16:52.980 --> 00:16:53.460
right?

00:16:53.560 --> 00:16:59.240
I can pass the, I guess in C, that would be the pointer to the pointer, and you would

00:16:59.240 --> 00:17:00.300
make a change to the pointer.

00:17:00.300 --> 00:17:06.040
In C#, you would say ref or out or something like that, and it would make a change on the

00:17:06.040 --> 00:17:06.460
other side.

00:17:06.460 --> 00:17:08.860
So, how do we do that in Python?

00:17:08.860 --> 00:17:11.560
And like, what are some of the interesting things that you might do?

00:17:11.560 --> 00:17:16.480
I said, well, Python doesn't have value type, so it doesn't, one of the problems with the

00:17:16.480 --> 00:17:22.160
value type world is like, maybe if I created a class, let's say a class in C++, and I create

00:17:22.160 --> 00:17:27.120
it on the stack and I pass it, it's, I think it can make a copy of that, is that right?

00:17:27.120 --> 00:17:31.920
Anyway, it's definitely, if you don't use the new keyword, like these pass by values are

00:17:31.920 --> 00:17:35.020
making copies of the data that's passed around, that can make things slow.

00:17:35.020 --> 00:17:39.880
Python, everything at some level being a pointer, doesn't have that problem, so that

00:17:39.880 --> 00:17:41.020
doesn't apply.

00:17:41.160 --> 00:17:43.120
But how do you implement these algorithms?

00:17:43.120 --> 00:17:49.480
So, it says, well, if you want to actually have the function make a change, you can do

00:17:49.480 --> 00:17:50.860
a couple of interesting things.

00:17:50.860 --> 00:17:55.980
Like, you could, suppose I want to pass in a variable, maybe have that variable change,

00:17:55.980 --> 00:18:00.100
but also get like a true false back, like it worked or it didn't work or something along

00:18:00.100 --> 00:18:00.580
those lines.

00:18:00.580 --> 00:18:07.820
So, they said, look, you can use tuple unpacking to return multiple values, the return value

00:18:07.820 --> 00:18:09.540
and then the modified value, which is one.

00:18:09.700 --> 00:18:13.980
Another thing is you could pass in a mutable data type, like I create an object and change

00:18:13.980 --> 00:18:15.360
a field on the object, right?

00:18:15.360 --> 00:18:17.160
So, that would have this.

00:18:17.160 --> 00:18:17.880
Or list.

00:18:17.880 --> 00:18:20.340
Or list, or yeah, anything that is mutable, basically.

00:18:20.340 --> 00:18:20.680
Right.

00:18:20.680 --> 00:18:25.080
Or another interesting one would be returning optional value types.

00:18:25.080 --> 00:18:29.360
So, if I had like a function that would say, like they would say, okay, we're going to

00:18:29.360 --> 00:18:34.900
try to parse a string into an integer and I either want to tell you, here's the number, the

00:18:34.900 --> 00:18:36.740
integer you got, or it didn't work.

00:18:37.020 --> 00:18:41.080
Forget that you might throw an exception, but suppose for some reason, this example, you

00:18:41.080 --> 00:18:42.360
don't want to throw an exception, right?

00:18:42.360 --> 00:18:43.340
What do you do?

00:18:43.340 --> 00:18:48.260
Well, you could return the value and whether or not it worked as a tuple.

00:18:48.260 --> 00:18:49.000
And that's one thing.

00:18:49.000 --> 00:18:55.620
Like in C#, the example they say is as a tripars takes a string and an out integer,

00:18:55.620 --> 00:18:58.820
which is like a one way ref type of thing.

00:18:59.160 --> 00:19:00.380
So, how do we do that in Python?

00:19:00.380 --> 00:19:05.880
Well, you could do just this multi-value, multi-return value, tuple unpacking, like it

00:19:05.880 --> 00:19:10.660
worked and here's the value, or it didn't work and there's no value, which is, I don't really

00:19:10.660 --> 00:19:11.220
love that one.

00:19:11.220 --> 00:19:14.880
One that kind of is interesting is like, you could use optional types.

00:19:14.880 --> 00:19:18.760
So, you could return an integer and if it's not parsable, you return none.

00:19:19.000 --> 00:19:24.220
And then use the walrus operator to say like, value colon equals, try to parse it.

00:19:24.220 --> 00:19:25.860
If that's not none, then you're good to go.

00:19:25.860 --> 00:19:27.600
That one's kind of okay with me.

00:19:27.600 --> 00:19:29.040
How do you feel about this, Brian?

00:19:29.040 --> 00:19:34.700
I feel like people are trying to force non-Python programming styles into Python.

00:19:34.700 --> 00:19:35.000
Yeah.

00:19:35.000 --> 00:19:36.060
It's interesting.

00:19:36.060 --> 00:19:40.120
It was reading through, it just made me think about, think back to my C++ days and all these

00:19:40.120 --> 00:19:46.440
patterns of passing variables and changes and, you know, passing by reference, copy, copying

00:19:46.440 --> 00:19:47.380
values and all that stuff.

00:19:47.380 --> 00:19:51.400
It's probably worth reading, I think, even if you don't necessarily need to do it that much.

00:19:51.400 --> 00:19:51.760
Yeah.

00:19:51.760 --> 00:19:57.800
I actually like to be more explicit and have either do functional programming where you're,

00:19:57.800 --> 00:20:02.920
I like the functional model where you, you pass in data and you return the, return the

00:20:02.920 --> 00:20:03.520
modified.

00:20:03.520 --> 00:20:04.460
Yeah, exactly.

00:20:04.460 --> 00:20:09.960
The other approaches to, that I like is to know, I mean, you have a shared data that

00:20:09.960 --> 00:20:15.660
you're pointing to, that they're, you know, you're past a modifiable data, like a list

00:20:15.660 --> 00:20:20.420
or something and say, hey, this function, and it needs to be obvious, like fill out the

00:20:20.420 --> 00:20:24.480
data, you know, it needs to be obvious that the thing you're calling is going to change

00:20:24.480 --> 00:20:28.960
that or use a database to reference changeable stuff.

00:20:28.960 --> 00:20:31.400
Yeah, a lot can be done with data structures.

00:20:31.400 --> 00:20:35.300
Anyway, I thought it was interesting to compare these other styles of programming to how you

00:20:35.300 --> 00:20:37.060
might compare, get them done in Python.

00:20:37.060 --> 00:20:38.600
And I think I'll go for the optional.

00:20:38.920 --> 00:20:42.940
If I had to pick one of these to write, I think I would go for the optional try pars that

00:20:42.940 --> 00:20:43.640
returns none.

00:20:43.640 --> 00:20:46.120
If, you know, if it doesn't work.

00:20:46.120 --> 00:20:48.120
Assuming that you don't want exceptions, right?

00:20:48.120 --> 00:20:48.720
Right.

00:20:48.720 --> 00:20:51.220
And I mean, that's also like the default.

00:20:51.220 --> 00:20:59.540
If you've got like the return of a value in, in some nested data or logic and you don't

00:20:59.540 --> 00:21:02.140
return anything, otherwise you're going to return none.

00:21:02.140 --> 00:21:02.500
So.

00:21:02.500 --> 00:21:02.800
Yeah.

00:21:03.380 --> 00:21:03.660
Yeah.

00:21:03.660 --> 00:21:07.780
You know, when I first started learning Python, that's something that was strange to me is

00:21:07.780 --> 00:21:09.820
that every function returns a value.

00:21:09.820 --> 00:21:13.560
Even if the word return doesn't appear in the function, it just happens to be none.

00:21:13.560 --> 00:21:16.920
Like the fall through case sort of in there is return none.

00:21:16.920 --> 00:21:18.480
If nothing happens.

00:21:18.480 --> 00:21:19.800
I kind of forgot that that's not obvious.

00:21:19.800 --> 00:21:20.380
Yeah.

00:21:20.380 --> 00:21:21.040
Yeah.

00:21:21.100 --> 00:21:25.220
But that's, that takes some getting used to because all the other languages you say

00:21:25.220 --> 00:21:26.580
it returns one of these things.

00:21:26.580 --> 00:21:30.580
If you want to return something, you say return none at the end or something.

00:21:30.580 --> 00:21:31.280
Anyway.

00:21:31.280 --> 00:21:31.600
Yeah.

00:21:31.660 --> 00:21:35.600
A lot of interesting ways to think about passing variables and some of the patterns

00:21:35.600 --> 00:21:35.820
there.

00:21:35.820 --> 00:21:36.120
Yeah.

00:21:36.120 --> 00:21:36.760
My head hurts.

00:21:36.760 --> 00:21:40.280
So if we're going to write some, some of these down, maybe you should just put them in and

00:21:40.280 --> 00:21:41.100
get up and store them.

00:21:41.100 --> 00:21:41.260
Huh?

00:21:41.260 --> 00:21:42.340
I apologize again.

00:21:42.340 --> 00:21:46.520
I think somebody on Twitter sent us this, but I couldn't find the reference this morning.

00:21:46.520 --> 00:21:48.300
This is a really cool thing.

00:21:48.300 --> 00:21:50.620
The author is Wei Wang, I think.

00:21:50.620 --> 00:21:53.080
Goes by only Wei on GitHub.

00:21:53.080 --> 00:21:56.880
And it's a tool for visualizing Git concepts.

00:21:56.880 --> 00:21:58.700
And I absolutely love this.

00:21:59.120 --> 00:22:05.040
He actually references a Git basics page, which is, I forget where that's at, but it's a good

00:22:05.040 --> 00:22:10.360
explanation, but it's a, you know, it's a visual, not really, it's like a static thing

00:22:10.360 --> 00:22:13.720
that you read about all the different ways and all the repos and where they are and everything.

00:22:13.720 --> 00:22:17.840
And that's, you kind of have to read that once, even though if it doesn't make sense,

00:22:17.840 --> 00:22:20.100
read something about how Git goes together.

00:22:20.100 --> 00:22:23.240
But this visualizing tool is super cool.

00:22:23.240 --> 00:22:27.560
The one he's, he's put together, it says visualizing Git concepts in D3.

00:22:28.100 --> 00:22:30.700
And it just nails the things home.

00:22:30.700 --> 00:22:31.600
It's really cool.

00:22:31.600 --> 00:22:36.220
It's got these, all these different concepts like commit, branch, checkout, checkout with

00:22:36.220 --> 00:22:40.340
a B, reset, revert, merge, rebase, tag, fetch, pull, push.

00:22:40.340 --> 00:22:47.820
And you just start out with a, like a diagram of what your repo looks like with branches and

00:22:47.820 --> 00:22:48.840
everything in the dots.

00:22:49.120 --> 00:22:54.900
And then on the left side, you can type commands and you, you don't have any code you're changing.

00:22:54.900 --> 00:22:59.840
You're just, you're just typing these commands to see what it does to the, the repository tree.

00:22:59.840 --> 00:23:04.280
And it'll like add nodes and add tags and things move around.

00:23:04.680 --> 00:23:10.020
And it's like light bulbs go off in your head where you're like, oh, that's what's happening.

00:23:10.020 --> 00:23:13.840
When I do a checkout, all I'm doing is looking at a different branch and that's it.

00:23:13.840 --> 00:23:14.120
Yeah.

00:23:14.120 --> 00:23:15.040
It's pretty cool.

00:23:15.040 --> 00:23:17.440
So yeah, it's this cool interactive command thing.

00:23:17.560 --> 00:23:22.860
Like you said there, what if I type this and this, what if I do like two commits and then

00:23:22.860 --> 00:23:26.600
a branch and then a commit and then check it out the other branch and do a commit.

00:23:26.600 --> 00:23:28.060
How does that whole thing look?

00:23:28.060 --> 00:23:28.460
Yeah.

00:23:28.460 --> 00:23:29.300
It's pretty nice.

00:23:29.300 --> 00:23:35.300
And it tells you like, there's a little instructions around each little lesson to like describe what's

00:23:35.300 --> 00:23:38.240
going on and then suggest things to try.

00:23:38.240 --> 00:23:41.020
But the interactive thing, you can do whatever you want within it.

00:23:41.020 --> 00:23:45.540
You can, you can try things out and it doesn't, it doesn't handle all of the things.

00:23:45.540 --> 00:23:50.960
Like for instance, I tried to get checkout with a dash for the last branch.

00:23:50.960 --> 00:23:52.220
That's not implemented.

00:23:52.220 --> 00:23:52.840
It's not there.

00:23:52.840 --> 00:23:55.480
So, but, but it's pretty cool.

00:23:55.480 --> 00:23:57.140
You know, another thing that's nice about it.

00:23:57.140 --> 00:24:01.480
I mean, the fact that it doesn't support everything isn't necessarily ideal.

00:24:01.480 --> 00:24:07.080
But one thing that is pretty cool is you don't have to be totally accurate there to make it

00:24:07.080 --> 00:24:07.360
work.

00:24:07.360 --> 00:24:07.600
Right.

00:24:07.600 --> 00:24:13.420
You can just do a get commit and you don't just like add stuff and fake stage things and

00:24:13.420 --> 00:24:14.480
then like commit them.

00:24:14.700 --> 00:24:17.580
You just type like get commit, get commit, get branch.

00:24:17.580 --> 00:24:19.940
And it kind of just shows like there's sort of a shorthand.

00:24:19.940 --> 00:24:24.300
Like if you kind of got the sense of it, it'll do the stuff to let you, you don't have to know

00:24:24.300 --> 00:24:25.160
your get perfectly.

00:24:25.160 --> 00:24:25.620
Yeah.

00:24:25.620 --> 00:24:30.100
And the commands that involve, cause you kind of want to play with this stuff to try to get

00:24:30.100 --> 00:24:31.400
it, get your head around it.

00:24:31.400 --> 00:24:34.640
But you don't really want to muck up your own repo or your code base.

00:24:35.020 --> 00:24:40.200
The ones that involve like a, the origin remote repository, like fetch, pull and push.

00:24:40.200 --> 00:24:44.060
Those are great to be, you visualize both of them at the same time.

00:24:44.060 --> 00:24:49.180
And if there's two pictures going on and this is definitely something, a desktop sort of thing.

00:24:49.180 --> 00:24:54.560
I don't think that it would, I think it would be tricky to do this on an iPhone or something

00:24:54.560 --> 00:24:55.060
like that.

00:24:55.060 --> 00:24:55.460
But yeah.

00:24:55.460 --> 00:24:55.760
Yeah.

00:24:55.760 --> 00:24:56.400
Without a keyboard.

00:24:56.400 --> 00:24:56.660
Yeah.

00:24:56.660 --> 00:24:57.200
For sure.

00:24:57.200 --> 00:25:00.840
I'm going to definitely going to bring this to my team and say, Hey everybody, check this

00:25:00.840 --> 00:25:01.080
out.

00:25:01.080 --> 00:25:01.420
Yeah.

00:25:01.680 --> 00:25:05.200
You should do things like, I want you to build a picture that looks like this.

00:25:05.200 --> 00:25:11.780
What get commands and what order of the commands are necessary to result in this structure.

00:25:11.780 --> 00:25:12.140
Right.

00:25:12.140 --> 00:25:13.600
I think that would be a cool way to do it.

00:25:13.600 --> 00:25:14.460
Oh man.

00:25:14.460 --> 00:25:15.080
Okay.

00:25:15.080 --> 00:25:22.640
So, so the second part of the interview, I will fail at also, man, you're tough.

00:25:22.640 --> 00:25:24.060
I'm glad I'm not interviewing with you.

00:25:24.060 --> 00:25:24.660
Oh my gosh.

00:25:24.660 --> 00:25:25.400
Yeah.

00:25:25.400 --> 00:25:27.040
No, I think that would be cool though.

00:25:27.040 --> 00:25:31.260
Cause you're like, all right, well, cause I think conceptually we also have this idea of

00:25:31.260 --> 00:25:36.060
like, I, this is the picture I want, but what are the commands that like take those steps?

00:25:36.060 --> 00:25:36.280
Right.

00:25:36.280 --> 00:25:36.600
Yeah.

00:25:36.600 --> 00:25:39.300
I'm still getting over the, yeah.

00:25:39.300 --> 00:25:40.800
Quick, the integer four.

00:25:40.800 --> 00:25:42.440
How many bytes?

00:25:42.440 --> 00:25:44.080
How many bytes in Python?

00:25:44.080 --> 00:25:45.680
Four or eight or something.

00:25:45.680 --> 00:25:46.100
28.

00:25:46.100 --> 00:25:47.060
Yeah, exactly.

00:25:47.060 --> 00:25:50.000
28 is not what you would expect, but in Python it's 28.

00:25:50.000 --> 00:25:50.260
Yeah.

00:25:50.260 --> 00:25:51.260
Okay.

00:25:51.260 --> 00:25:55.780
And if you want to test, import sys, get object size, pass the number four.

00:25:55.780 --> 00:25:56.640
All right.

00:25:56.640 --> 00:26:01.240
But if here's the, here's the next question, Brian, if I have a hundred fours in a

00:26:01.240 --> 00:26:03.820
Python program, how many bytes does it take?

00:26:03.820 --> 00:26:04.280
28.

00:26:04.280 --> 00:26:04.920
Yeah, exactly.

00:26:04.920 --> 00:26:07.280
Plus the pointers that point at them, but yeah, 28.

00:26:07.280 --> 00:26:08.380
That's pretty cool.

00:26:08.380 --> 00:26:10.340
So 128, I don't know.

00:26:10.340 --> 00:26:13.440
Eight times, 828.

00:26:13.440 --> 00:26:14.180
I don't know.

00:26:14.180 --> 00:26:15.540
How big are the pointers?

00:26:15.540 --> 00:26:16.840
I think they're 64 bits.

00:26:16.840 --> 00:26:17.520
So they gotta be eight.

00:26:17.520 --> 00:26:18.340
I don't know.

00:26:18.340 --> 00:26:20.160
We've gone down a hole though.

00:26:20.160 --> 00:26:20.720
We don't need to.

00:26:20.720 --> 00:26:24.040
What I would rather talk about is, MicroPython.

00:26:24.040 --> 00:26:24.480
Yeah.

00:26:24.480 --> 00:26:25.320
So this is.

00:26:25.320 --> 00:26:26.160
Round out the extras.

00:26:26.160 --> 00:26:26.680
Oh yeah.

00:26:26.740 --> 00:26:27.440
We're in the extras.

00:26:27.440 --> 00:26:31.400
Now a micro bit announced that it's going to come out with a new version in November.

00:26:31.400 --> 00:26:34.160
It's got a whole bunch of videos showing the cool stuff.

00:26:34.160 --> 00:26:38.500
They're shooting at the same price point they had before, which I have no idea what it was,

00:26:38.500 --> 00:26:39.260
but reasonable.

00:26:39.260 --> 00:26:42.400
But micro bit now has a speaker and a microphone.

00:26:42.400 --> 00:26:48.060
So you can play sounds and, and do things like, I don't know, record your voice or something.

00:26:48.060 --> 00:26:51.100
I don't know what you want to do, but, but that's neat.

00:26:51.100 --> 00:26:51.540
Nice.

00:26:51.540 --> 00:26:51.980
Mike.

00:26:51.980 --> 00:26:52.240
Yeah.

00:26:52.240 --> 00:26:54.100
It does do a MicroPython.

00:26:54.100 --> 00:26:57.880
I think that, I think that do something else also, but why would you do something else?

00:26:57.880 --> 00:26:58.620
Use MicroPython.

00:26:58.620 --> 00:26:59.560
Yeah, exactly.

00:26:59.560 --> 00:27:00.700
Yeah.

00:27:00.700 --> 00:27:01.660
I'm looking for the price.

00:27:01.660 --> 00:27:03.900
Um, all right.

00:27:03.900 --> 00:27:04.480
Too much math.

00:27:04.480 --> 00:27:07.280
I think it's $21, but that's Australian.

00:27:07.280 --> 00:27:08.060
So I don't know.

00:27:08.060 --> 00:27:08.740
Something like that.

00:27:08.740 --> 00:27:09.260
It's not a lot.

00:27:09.260 --> 00:27:11.260
Australian.

00:27:11.980 --> 00:27:17.000
Well, the first thing I pulled up was $2,119 Australia, but that's for a hundred packs.

00:27:17.000 --> 00:27:17.300
So.

00:27:17.300 --> 00:27:18.980
Okay.

00:27:18.980 --> 00:27:20.580
All right, cool.

00:27:20.580 --> 00:27:24.160
Now that's really neat that the sound is coming in and you can interact with it.

00:27:24.160 --> 00:27:25.640
I think there'll be a lot of neat stuff you can do there.

00:27:25.640 --> 00:27:29.960
I, that's a really nice, I mean, so far, a lot of these little devices, like how do you

00:27:29.960 --> 00:27:30.520
interact with it?

00:27:30.520 --> 00:27:35.080
Well, you can kind of shake it or you can touch this button or it like has an led and sound

00:27:35.080 --> 00:27:36.340
is a whole nother level, right?

00:27:36.340 --> 00:27:37.500
You could do speech recognition.

00:27:37.500 --> 00:27:39.860
You could play like, I think it's really neat.

00:27:39.860 --> 00:27:40.140
Yeah.

00:27:40.560 --> 00:27:44.300
It looks like they've got some plans to extend what this can do in the future too.

00:27:44.300 --> 00:27:45.420
So it was pretty cool.

00:27:45.420 --> 00:27:45.620
Yeah.

00:27:45.620 --> 00:27:46.080
Absolutely.

00:27:46.080 --> 00:27:48.140
I'm a fan of the circuit playground express.

00:27:48.140 --> 00:27:51.040
That's really fun thing to play with, but this is neat also.

00:27:51.040 --> 00:27:51.920
Yeah, for sure.

00:27:51.920 --> 00:27:52.460
All right.

00:27:52.460 --> 00:27:54.620
I got two quick things to share with people.

00:27:54.620 --> 00:27:56.740
One really fast one yesterday.

00:27:57.080 --> 00:28:06.380
So eight days ago in real time, I was on the four 25 show, which is a Microsoft identity,

00:28:06.380 --> 00:28:15.040
which stream spent three hours converting a flask web app to use federated identity and like

00:28:15.040 --> 00:28:17.540
remote login and all sorts of cool stuff like that.

00:28:17.540 --> 00:28:23.340
And like just to step away from also having like social logins and whatnot using all those

00:28:23.340 --> 00:28:23.560
libraries.

00:28:23.560 --> 00:28:26.580
So if people are interested in that, I'll link to the whole show.

00:28:26.580 --> 00:28:27.620
And I just want to comment.

00:28:27.620 --> 00:28:30.540
It's kind of, it's a very different way of presenting.

00:28:30.540 --> 00:28:32.480
Like I'm used to polished presentations.

00:28:32.480 --> 00:28:34.220
Like what are we going to do in this half hour?

00:28:34.220 --> 00:28:36.100
Let's get it all down really clear.

00:28:36.100 --> 00:28:37.300
Here's the demo I'm going to write.

00:28:37.300 --> 00:28:39.140
I've already like gone through it once.

00:28:39.140 --> 00:28:39.980
So I know it's going to work.

00:28:39.980 --> 00:28:41.500
And this is like, Hey, we have this idea.

00:28:41.500 --> 00:28:43.580
Let's just work on it until we get it done.

00:28:43.580 --> 00:28:48.820
And just kind of like take input from the audience, from the people watching live.

00:28:48.820 --> 00:28:54.640
And yeah, for people who've done presentations and haven't done this style, it's, it's an interesting

00:28:54.640 --> 00:28:55.180
shift.

00:28:55.180 --> 00:28:57.880
It's a cool way to like sort of present programming to people.

00:28:57.880 --> 00:28:58.260
I think.

00:28:58.260 --> 00:28:59.400
So would you do it again?

00:28:59.400 --> 00:29:00.080
Did it, was it fun?

00:29:00.080 --> 00:29:00.740
Yeah, it was fun.

00:29:00.740 --> 00:29:06.340
It was a little stressful because I haven't done a lot with like, you know, like OAuth identity

00:29:06.340 --> 00:29:06.880
type stuff.

00:29:06.880 --> 00:29:10.180
So I'm like, I have no idea if we're going to be successful, like making this work at all.

00:29:10.180 --> 00:29:11.120
But it was fun.

00:29:11.120 --> 00:29:13.640
And you know, spoiler alert, it worked in the end.

00:29:13.640 --> 00:29:17.860
Is the 425 a joke on like, you know, five minutes after 420 or?

00:29:17.860 --> 00:29:20.460
Yeah, that's, I have no idea.

00:29:20.460 --> 00:29:21.580
No idea why.

00:29:21.580 --> 00:29:21.840
Okay.

00:29:21.840 --> 00:29:24.480
There's an about, let me see if it says what it says in the about.

00:29:24.480 --> 00:29:26.200
I have no idea.

00:29:26.200 --> 00:29:26.800
It doesn't say.

00:29:26.800 --> 00:29:27.560
Okay.

00:29:27.560 --> 00:29:29.560
But anyway, it was, it was fun.

00:29:29.620 --> 00:29:31.100
So people can check out that video.

00:29:31.100 --> 00:29:35.700
And then also I've started using something interesting that people may find interesting.

00:29:35.700 --> 00:29:40.240
So one of the things that bugs me is so much of our life is on the web, right?

00:29:40.240 --> 00:29:41.160
As you know.

00:29:41.160 --> 00:29:44.880
And how many cookies do you think your browser has in it?

00:29:44.880 --> 00:29:47.540
If you would like to sum them up across all the sites.

00:29:47.540 --> 00:29:47.920
No.

00:29:48.020 --> 00:29:49.580
Like an untold number, right?

00:29:49.580 --> 00:29:52.540
Like 100,000, 200,000, like some insane number.

00:29:52.540 --> 00:29:58.220
If it had been, you know, the same browser for years and you've used it all day, like who

00:29:58.220 --> 00:29:58.760
knows, right?

00:29:58.760 --> 00:29:59.000
Yeah.

00:29:59.040 --> 00:30:01.500
So I had a couple of thoughts.

00:30:01.500 --> 00:30:04.320
I decided, well, I want to just restart all that from scratch.

00:30:04.320 --> 00:30:09.840
So I erased every bit of history from my browser and fired it back up.

00:30:09.840 --> 00:30:12.660
I'm like, okay, now I've got to log into all these things again, which is fine.

00:30:12.780 --> 00:30:21.100
But then also realize like, do I want, like say, if I go to some random site and maybe it

00:30:21.100 --> 00:30:24.580
has some cross site vulnerability or whatever, do I want that site potentially to be able

00:30:24.580 --> 00:30:29.600
to say to get to my GitHub things or my bank or whatever, if I'm logged in.

00:30:29.600 --> 00:30:34.740
So I started using this thing called Firefox containers that let you basically create like

00:30:34.740 --> 00:30:38.260
isolated independent browsers for like categories of sites.

00:30:38.400 --> 00:30:42.780
So like, oh, like GitHub and all the, and Bitbucket and all those things are in their

00:30:42.780 --> 00:30:44.920
own like container.

00:30:44.920 --> 00:30:50.620
So only cookies they ever see in login sessions and whatnot are between say GitHub and Bitbucket

00:30:50.620 --> 00:30:56.720
like those and all the other browsing, none of them know anything about that I've ever visited

00:30:56.720 --> 00:30:57.600
GitHub, for example.

00:30:57.600 --> 00:30:58.140
Oh, cool.

00:30:58.140 --> 00:31:02.380
So anyway, if people are, if that sounds interesting, I'll link to a little, short video.

00:31:02.380 --> 00:31:03.080
Is there a limit?

00:31:03.080 --> 00:31:07.340
I mean, cause you could possibly just do a container for each site that you go to.

00:31:07.340 --> 00:31:12.240
You could, it gets a little bit annoying because if you click on, like if you're in like Google

00:31:12.240 --> 00:31:19.200
drive and you click on a link and it takes you somewhere and you did that like over, over

00:31:19.200 --> 00:31:22.340
grouping it, like you'd have to log in every time cause it wouldn't know it.

00:31:22.340 --> 00:31:24.160
There's a little bit of a juggling.

00:31:24.160 --> 00:31:27.300
So too many is, it gets annoying, but yeah.

00:31:27.300 --> 00:31:30.200
Anyway, it's kind of a cool idea to like keep all those things separated.

00:31:30.200 --> 00:31:32.180
People definitely should put Facebook in there cause.

00:31:32.380 --> 00:31:32.780
Oh yeah.

00:31:32.780 --> 00:31:38.580
I have, I have one specifically the container, like the containers are like banking, shopping,

00:31:38.580 --> 00:31:40.160
code, cloud drives.

00:31:40.160 --> 00:31:43.880
And I have one called shunned and shunned is where Facebook is.

00:31:43.880 --> 00:31:46.080
Yeah.

00:31:46.080 --> 00:31:47.540
So for example, that's a great example.

00:31:47.540 --> 00:31:50.780
So like you go to all these sites and they have like Facebook pixels and all this tracking

00:31:50.780 --> 00:31:51.080
stuff.

00:31:51.280 --> 00:31:56.120
Like, because I put Facebook over there and didn't log into it anywhere else, then it

00:31:56.120 --> 00:32:00.960
will never, those things will never trigger for me in the sense of like being tied to my

00:32:00.960 --> 00:32:01.300
account.

00:32:01.300 --> 00:32:01.760
Right.

00:32:01.760 --> 00:32:02.120
Yeah.

00:32:02.120 --> 00:32:03.080
And that makes me happy.

00:32:03.200 --> 00:32:06.760
I've got like one relative that's that the only way to get ahold of them is through

00:32:06.760 --> 00:32:07.580
Facebook messenger.

00:32:07.580 --> 00:32:10.940
And so I have to have Facebook just for that.

00:32:10.940 --> 00:32:11.400
Yeah.

00:32:11.400 --> 00:32:14.360
So you got to get one of these and like you kind of sort of don't have it.

00:32:14.360 --> 00:32:16.940
Awesome.

00:32:16.940 --> 00:32:17.460
All right.

00:32:17.460 --> 00:32:21.840
Well, that was funny, but not nearly as funny as what we got coming up here.

00:32:21.840 --> 00:32:22.300
Okay.

00:32:22.300 --> 00:32:22.620
All right.

00:32:22.620 --> 00:32:23.600
You want to do the first one?

00:32:23.600 --> 00:32:24.280
I'll do the next one.

00:32:24.280 --> 00:32:25.340
And then you've got to do the last one.

00:32:25.340 --> 00:32:27.160
Cause I don't know where we're going with it.

00:32:27.160 --> 00:32:27.680
Okay.

00:32:27.680 --> 00:32:28.820
So I'm doing the first one.

00:32:28.820 --> 00:32:29.020
Yeah.

00:32:29.020 --> 00:32:29.420
Okay.

00:32:29.420 --> 00:32:31.000
Where did developers drink?

00:32:31.000 --> 00:32:31.500
I don't know.

00:32:31.500 --> 00:32:32.080
Where do they drink?

00:32:32.080 --> 00:32:33.080
At the food bar.

00:32:33.600 --> 00:32:34.600
I had that food bar.

00:32:34.600 --> 00:32:35.140
I love it.

00:32:35.140 --> 00:32:35.440
Yeah.

00:32:35.440 --> 00:32:35.840
All right.

00:32:35.840 --> 00:32:38.080
This one, you got to do the last line for me.

00:32:38.080 --> 00:32:38.320
Okay.

00:32:38.320 --> 00:32:40.560
Cause it's a knock, knock joke where normally it's like knock, knock.

00:32:40.560 --> 00:32:41.200
Who's there?

00:32:41.200 --> 00:32:41.920
How?

00:32:41.920 --> 00:32:42.760
Which cow?

00:32:42.760 --> 00:32:43.360
Interrupting cow.

00:32:43.360 --> 00:32:43.880
That kind of thing.

00:32:43.880 --> 00:32:44.080
Right.

00:32:44.080 --> 00:32:44.420
Yeah.

00:32:44.420 --> 00:32:44.720
All right.

00:32:44.720 --> 00:32:45.900
Knock, knock.

00:32:45.900 --> 00:32:46.700
Async function.

00:32:46.700 --> 00:32:47.200
Who's there?

00:32:47.200 --> 00:32:50.940
Perfect.

00:32:50.940 --> 00:32:51.340
All right.

00:32:51.340 --> 00:32:52.280
So those are the two jokes.

00:32:52.280 --> 00:32:53.340
What's this last one?

00:32:53.340 --> 00:32:58.540
Oh, also, if anybody tells us that we've already done this async knock, knock joke before,

00:32:58.540 --> 00:32:59.800
we haven't.

00:32:59.800 --> 00:33:02.460
This is the first time we just, they somehow,

00:33:02.960 --> 00:33:03.480
asynced.

00:33:03.480 --> 00:33:04.160
That's right.

00:33:04.160 --> 00:33:04.680
Exactly.

00:33:04.680 --> 00:33:05.180
Yeah.

00:33:05.180 --> 00:33:05.240
Yeah.

00:33:05.240 --> 00:33:06.560
It's just, it's a race condition.

00:33:06.560 --> 00:33:08.020
It's not a, not a problem.

00:33:08.020 --> 00:33:08.540
Fine.

00:33:08.540 --> 00:33:08.820
Yeah.

00:33:08.820 --> 00:33:12.060
No, I just, something funny happened to me on Twitter the other day.

00:33:12.060 --> 00:33:17.660
Somebody contacted me and said, Hey Brian, what testing module would you recommend?

00:33:17.860 --> 00:33:22.320
I'm aware that there's unit test and pitest, but are there better options?

00:33:22.320 --> 00:33:25.620
Can you, can you guess which one I recommended?

00:33:25.620 --> 00:33:28.000
Well, you don't like to install stuff.

00:33:28.000 --> 00:33:29.500
So you definitely said unit tests.

00:33:29.500 --> 00:33:32.440
Yeah.

00:33:32.520 --> 00:33:33.020
That's right.

00:33:33.020 --> 00:33:33.300
Yeah.

00:33:33.300 --> 00:33:34.060
That's funny.

00:33:34.060 --> 00:33:34.460
Awesome.

00:33:34.460 --> 00:33:34.960
Cool.

00:33:34.960 --> 00:33:35.120
Cool.

00:33:35.120 --> 00:33:36.740
I thought it was a joke at first.

00:33:36.740 --> 00:33:38.040
I really thought they were joking.

00:33:38.040 --> 00:33:38.960
They were pulling your leg.

00:33:38.960 --> 00:33:40.000
They're like, let's see what you'll say.

00:33:40.000 --> 00:33:40.360
Come on.

00:33:40.360 --> 00:33:41.320
Of course you'll say pitest.

00:33:41.320 --> 00:33:41.900
Yeah.

00:33:42.080 --> 00:33:46.720
But apparently he knew of me somehow without knowing that I wrote the book.

00:33:46.720 --> 00:33:47.920
So yeah, exactly.

00:33:47.920 --> 00:33:48.860
Yeah.

00:33:48.860 --> 00:33:49.120
Cool.

00:33:49.120 --> 00:33:49.420
Cool.

00:33:49.420 --> 00:33:50.760
Well, thank you as always.

00:33:50.760 --> 00:33:51.400
Thank you.

00:33:51.400 --> 00:33:51.920
Yep.

00:33:51.920 --> 00:33:52.280
Bye.

00:33:52.280 --> 00:33:52.920
Next time.

00:33:52.920 --> 00:33:53.160
Yeah.

00:33:53.160 --> 00:33:53.660
See you next time.

00:33:53.660 --> 00:33:55.600
Thank you for listening to Python bytes.

00:33:55.600 --> 00:33:58.120
Follow the show on Twitter via at Python bytes.

00:33:58.120 --> 00:34:03.720
That's Python bytes as in B Y T E S and get the full show notes at Python bytes.

00:34:03.720 --> 00:34:03.960
Dot.

00:34:03.960 --> 00:34:04.220
F M.

00:34:04.220 --> 00:34:07.100
If you have a news item you want featured, just visit Python bytes.

00:34:07.100 --> 00:34:07.260
Dot.

00:34:07.260 --> 00:34:08.460
F M and send it our way.

00:34:08.460 --> 00:34:11.160
We're always on the lookout for sharing something cool.

00:34:11.460 --> 00:34:14.240
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:34:14.240 --> 00:34:17.680
Thank you for listening and sharing this podcast with your friends and colleagues.

