
00:00:00.000 --> 00:00:05.960
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode


00:00:05.960 --> 00:00:08.880
137 recorded June 26th


00:00:08.880 --> 00:00:13.840
2019 I'm Michael Kennedy and I'm Brian Harkin and this episode is brought to you by roll bar


00:00:13.840 --> 00:00:16.800
I'll tell you all more about them later for now Brian


00:00:16.800 --> 00:00:21.800
I always wonder about you know, you hear that Python is an efficient and expressive language


00:00:21.800 --> 00:00:25.480
And if you write code in C++, it'll be a lot longer. But you know, how can you quantify that?


00:00:25.560 --> 00:00:30.560
Well, you can set up a whole bunch of people to write the same thing in a whole bunch of languages.


00:00:30.560 --> 00:00:38.560
Well, that's awesome that people did that. It seems like a lot of work, but yeah, I guess that's cool. Tell us about it. This is your first item, right?


00:00:38.560 --> 00:00:48.560
So this is an article called "Comparing the Same Project in Rust, Haskell, C++, Python, Scala, and OCaml."


00:00:48.560 --> 00:00:49.560
Ocaml, I think, yeah.


00:00:49.560 --> 00:00:50.060
I think, yeah.


00:00:50.060 --> 00:00:54.260
So this was written up by Christian or Kristen Hume or Hume.


00:00:54.260 --> 00:00:57.860
And this is about a university project, which is kind of a neat project.


00:00:57.860 --> 00:01:03.260
Basically, they had to implement mode like a big chunk of Java.


00:01:03.260 --> 00:01:09.260
So it's a Java to x86 compiler as part of a compiler class.


00:01:09.260 --> 00:01:14.660
And they were basically had to set up get up teams, teams of people to do it.


00:01:14.660 --> 00:01:18.460
And they could pick any language they wanted, which is kind of cool because,


00:01:18.460 --> 00:01:20.760
you know, people be better at different languages.


00:01:20.760 --> 00:01:22.560
So let them use what they're good at.


00:01:22.560 --> 00:01:23.600
- Yeah, let them use what they're good at


00:01:23.600 --> 00:01:24.900
'cause then they'll do it properly


00:01:24.900 --> 00:01:27.100
and not just try to cram it one.


00:01:27.100 --> 00:01:29.100
They'll be, have the most efficient use


00:01:29.100 --> 00:01:30.080
of that language for sure.


00:01:30.080 --> 00:01:31.980
- Up to three people on a team


00:01:31.980 --> 00:01:34.020
and it was a multi-month project.


00:01:34.020 --> 00:01:35.800
And then also tests were added.


00:01:35.800 --> 00:01:38.220
So this is kind of a neat part of the process,


00:01:38.220 --> 00:01:40.580
which I think is an awesome way to teach people


00:01:40.580 --> 00:01:43.160
is have some published tests of like,


00:01:43.160 --> 00:01:44.820
you're gonna have to run these test cases


00:01:44.820 --> 00:01:45.940
and they have to pass.


00:01:45.940 --> 00:01:48.120
But then also have some secret ones


00:01:48.120 --> 00:01:50.600
where people don't, they don't know what tests


00:01:50.600 --> 00:01:53.000
are gonna be tested against it,


00:01:53.000 --> 00:01:55.920
which is kind of nice because people will,


00:01:55.920 --> 00:01:57.520
they'll have to be able to make sure


00:01:57.520 --> 00:02:00.440
their implementation is robust without knowing,


00:02:00.440 --> 00:02:01.880
without the test cases.


00:02:01.880 --> 00:02:02.720
It's kind of neat.


00:02:02.720 --> 00:02:03.540
- Yeah, that's cool.


00:02:03.540 --> 00:02:06.200
So I do love it that there's unknown tests,


00:02:06.200 --> 00:02:08.280
like these are the specifications.


00:02:08.280 --> 00:02:10.200
You can kind of get close with these tests,


00:02:10.200 --> 00:02:12.920
but to pass, you actually have to just work.


00:02:12.920 --> 00:02:14.680
- That's totally like real life, you know,


00:02:14.680 --> 00:02:17.240
you'll have to write down some specifications,


00:02:17.240 --> 00:02:20.240
And there's some specifications that are not written down.


00:02:20.240 --> 00:02:21.500
They're just supposed to be known.


00:02:21.500 --> 00:02:23.080
And then there's other things that people,


00:02:23.080 --> 00:02:25.080
once they see the implementation, they go,


00:02:25.080 --> 00:02:26.840
"Oh yeah, I wish it did this also."


00:02:26.840 --> 00:02:29.320
So I think that's a cool idea.


00:02:29.320 --> 00:02:32.100
And they weren't shooting for lines of code


00:02:32.100 --> 00:02:33.440
or anything, complexity.


00:02:33.440 --> 00:02:35.700
They were just trying to finish the project.


00:02:35.700 --> 00:02:37.920
So this analysis was done after,


00:02:37.920 --> 00:02:40.880
was they had a Rust, a baseline implementation


00:02:40.880 --> 00:02:43.940
written by two people that were familiar with Rust.


00:02:43.940 --> 00:02:46.120
And then they compared everything against that.


00:02:46.120 --> 00:02:48.160
So there was another Rust team


00:02:48.160 --> 00:02:50.240
that chose different design decisions


00:02:50.240 --> 00:02:54.000
and it took, they had like three times the code.


00:02:54.000 --> 00:02:56.780
So these are all just comparing lines of code.


00:02:56.780 --> 00:03:00.100
The Haskell implementation was about equal,


00:03:00.100 --> 00:03:01.760
but depending on how you measure it,


00:03:01.760 --> 00:03:06.760
one to 1.6 times the code, same for the OCaml.


00:03:06.760 --> 00:03:11.840
C++ was bigger, about 1.4 times the baseline,


00:03:12.120 --> 00:03:16.340
and Scala was a little bit less with about 70%


00:03:16.340 --> 00:03:17.300
the lines of code.


00:03:17.300 --> 00:03:20.620
The big outlier was Python,


00:03:20.620 --> 00:03:22.940
which had a lot of standouts.


00:03:22.940 --> 00:03:27.500
Python implementation was at half the size, approximately,


00:03:27.500 --> 00:03:29.940
plus written by one person,


00:03:29.940 --> 00:03:34.420
and had extra features past all the secret tests,


00:03:34.420 --> 00:03:35.800
plus others.


00:03:35.800 --> 00:03:38.060
Somebody excellent at programming, of course,


00:03:38.060 --> 00:03:41.120
used some of the meta-programming techniques.


00:03:41.120 --> 00:03:43.880
And anyway, kind of a fun article.


00:03:43.880 --> 00:03:45.120
One of the things I forgot to mention,


00:03:45.120 --> 00:03:48.200
one of the hindrances was they were only supposed


00:03:48.200 --> 00:03:50.840
to use standard libraries, no extra parsing,


00:03:50.840 --> 00:03:52.920
and then not any parsing libraries,


00:03:52.920 --> 00:03:55.240
even if they were part of the standard library.


00:03:55.240 --> 00:03:59.720
So even the parsing had to be kind of built up from scratch.


00:03:59.720 --> 00:04:00.560
- Yeah, how interesting.


00:04:00.560 --> 00:04:02.920
I wonder if that would make things like Python


00:04:02.920 --> 00:04:04.320
even better possible.


00:04:04.320 --> 00:04:05.740
I don't know about Rust maybe as well,


00:04:05.740 --> 00:04:08.160
but like C++ doesn't have parsing libraries built in


00:04:08.160 --> 00:04:09.760
that I know of, things like that, right?


00:04:09.760 --> 00:04:13.520
There's a lot of mini language parsing libraries around Python.


00:04:13.520 --> 00:04:18.880
So it'd be interesting to do that with Go Wild and use whatever's available.


00:04:18.880 --> 00:04:21.920
Right, like maybe take this project and then go, all right, well,


00:04:21.920 --> 00:04:25.000
what if we hit it with all the pip installable things?


00:04:25.000 --> 00:04:26.080
What happens then, right?


00:04:26.080 --> 00:04:26.840
Yeah, exactly.


00:04:26.840 --> 00:04:29.280
Yeah, it sounds like a super intense project, though, right?


00:04:29.280 --> 00:04:31.560
Like deep, deep into the language, right?


00:04:31.560 --> 00:04:34.160
I mean, on one, you're writing the compiler.


00:04:34.160 --> 00:04:35.720
You're understanding Java.


00:04:35.720 --> 00:04:37.240
You're compiling to x86.


00:04:37.240 --> 00:04:38.560
You're doing metaprogramming.


00:04:38.560 --> 00:04:39.900
There's a lot of stuff going on here.


00:04:39.900 --> 00:04:40.860
- It's a pretty cool article.


00:04:40.860 --> 00:04:41.700
- Cool.


00:04:41.700 --> 00:04:44.900
If that last one really connected with your deep geek outlets


00:04:44.900 --> 00:04:47.340
like go really hard into the language,


00:04:47.340 --> 00:04:49.420
this next one is going to connect with your,


00:04:49.420 --> 00:04:51.220
I just wanted to work really quick and easy.


00:04:51.220 --> 00:04:52.060
- Yeah.


00:04:52.060 --> 00:04:52.880
- So this one is really nice.


00:04:52.880 --> 00:04:53.900
So if I was a data scientist,


00:04:53.900 --> 00:04:56.460
I might use Matplotlib or just any kind of person


00:04:56.460 --> 00:04:58.380
who wanted some visualization of data.


00:04:58.380 --> 00:05:01.700
I might use Matplotlib for that and that's great,


00:05:01.700 --> 00:05:03.780
except for at least I personally can't make


00:05:03.780 --> 00:05:06.460
Matplotlib look super good, right?


00:05:06.460 --> 00:05:08.300
Like if I used Excel, I could put the data in there


00:05:08.300 --> 00:05:10.520
and I'd highlight the stuff and I would say, okay,


00:05:10.520 --> 00:05:12.880
insert chart and I would pick the kind


00:05:12.880 --> 00:05:15.180
and then I would go and I would like right click


00:05:15.180 --> 00:05:17.580
and edit the chart and I would like maybe drag it around


00:05:17.580 --> 00:05:20.500
to size it correctly, double click on the axes


00:05:20.500 --> 00:05:21.620
to change the axes.


00:05:21.620 --> 00:05:23.360
But in Matplotlib, you just write code


00:05:23.360 --> 00:05:24.420
and the picture comes out, right?


00:05:24.420 --> 00:05:26.580
- Yeah, and I know you can do all this stuff,


00:05:26.580 --> 00:05:29.580
but it's not obvious and you have to look everything,


00:05:29.580 --> 00:05:31.540
every little thing up and tweak it.


00:05:31.540 --> 00:05:35.020
- Yeah, so there's this project that we heard about


00:05:35.020 --> 00:05:37.860
from one of our listeners and I can't remember,


00:05:37.860 --> 00:05:39.300
I'm trying to remember who it was.


00:05:39.300 --> 00:05:40.300
Oh, here it is.


00:05:40.300 --> 00:05:42.560
I've got this is from Lee Wagner.


00:05:42.560 --> 00:05:43.760
So thank you, Lee for sending it in,


00:05:43.760 --> 00:05:44.640
'cause this is killer.


00:05:44.640 --> 00:05:49.120
So there's this project called Pyllustrator


00:05:49.120 --> 00:05:51.800
for styling your matplotlib plot.


00:05:51.800 --> 00:05:54.320
So you just do your matplotlib code,


00:05:54.320 --> 00:05:56.800
but you import Pyllustrator,


00:05:56.800 --> 00:05:59.400
and you say start at the beginning.


00:05:59.400 --> 00:06:02.480
And what it does is it pops up when you show your plot,


00:06:02.480 --> 00:06:05.200
an interactive thing much like Excel,


00:06:05.200 --> 00:06:06.960
where you can drag and drop


00:06:06.960 --> 00:06:08.640
and arrange your different plots.


00:06:08.640 --> 00:06:12.700
You can go to the properties and edit the axes


00:06:12.700 --> 00:06:14.860
and the colors and just all the kind of stuff


00:06:14.860 --> 00:06:15.980
that you might do.


00:06:15.980 --> 00:06:19.860
It even has the cool design layout stuff


00:06:19.860 --> 00:06:23.020
where it'll help you equally space stuff


00:06:23.020 --> 00:06:23.860
between each other.


00:06:23.860 --> 00:06:25.260
So put those little bars to say right there,


00:06:25.260 --> 00:06:27.100
if you drag and drop it, they'll be equally spaced


00:06:27.100 --> 00:06:28.980
or align the tops and the sides.


00:06:28.980 --> 00:06:31.440
- Yeah, and with the start thing,


00:06:31.440 --> 00:06:34.740
you can even fill it with some of your data to begin with.


00:06:34.740 --> 00:06:37.640
So if you kind of know the data you want to plot,


00:06:37.640 --> 00:06:40.340
because that's going to affect how you're going to design it.


00:06:40.340 --> 00:06:43.980
So you can pre-fill it and then drag it around and design it.


00:06:43.980 --> 00:06:45.220
It's just totally cool.


00:06:45.220 --> 00:06:46.060
- It's totally cool.


00:06:46.060 --> 00:06:48.600
- I'm glad they have, so the link we're going to show


00:06:48.600 --> 00:06:51.460
has a little embedded video.


00:06:51.460 --> 00:06:53.340
And that's where, I mean, talking about it,


00:06:53.340 --> 00:06:55.540
you're like, yeah, I think this might be useful.


00:06:55.540 --> 00:06:56.860
But you watch this video and you're like,


00:06:56.860 --> 00:06:58.860
oh my God, I need to use this right away.


00:06:58.860 --> 00:07:00.900
- Yes, I had the exact same experience.


00:07:00.900 --> 00:07:02.780
I'm like, ah, kind of interesting.


00:07:02.780 --> 00:07:03.620
Oh, look at the video.


00:07:03.620 --> 00:07:04.660
Oh my God, it's amazing.


00:07:04.660 --> 00:07:06.740
- Yeah, so this is super cool.


00:07:06.740 --> 00:07:09.740
And obviously, you don't save your changes


00:07:09.740 --> 00:07:11.300
to like an Excel workbook.


00:07:11.300 --> 00:07:13.220
What you do is you save your changes


00:07:13.220 --> 00:07:15.380
and you can actually call save in PyLustrator.


00:07:15.380 --> 00:07:18.680
And what it'll do is it'll put the configuration in Python


00:07:18.680 --> 00:07:20.900
back into the file that ran it.


00:07:20.900 --> 00:07:22.500
So that's pretty wild, actually.


00:07:22.500 --> 00:07:24.420
- Yeah, and then you uncomment the PyLustrator.


00:07:24.420 --> 00:07:26.060
You don't have to import it later


00:07:26.060 --> 00:07:29.220
because it's not a dependency on your project afterwards.


00:07:29.220 --> 00:07:30.740
- Right, it's just a little design tool.


00:07:30.740 --> 00:07:33.340
So it's super cool if anyone's doing Matplotlib


00:07:33.340 --> 00:07:35.100
and they want to have it styled.


00:07:35.100 --> 00:07:36.860
Especially if you're doing more than one plot


00:07:36.860 --> 00:07:38.420
and you want to put them side by side,


00:07:38.420 --> 00:07:40.300
this is super cool, so check that out.


00:07:40.300 --> 00:07:41.140
Definitely a fan.


00:07:41.140 --> 00:07:43.940
Another thing I'm a fan of, Brian, MongoDB.


00:07:43.940 --> 00:07:44.780
Love it.


00:07:44.780 --> 00:07:47.340
- Since you and I are paying attention to a lot of projects,


00:07:47.340 --> 00:07:49.420
there's a lot of different release cycles


00:07:49.420 --> 00:07:51.060
and we kind of decided early on


00:07:51.060 --> 00:07:54.220
that we weren't gonna try to track everybody's releases


00:07:54.220 --> 00:07:56.380
because that might get boring to people.


00:07:56.380 --> 00:07:58.740
However, we covered MongoDB 4


00:07:58.740 --> 00:08:00.900
because it came out with--


00:08:00.900 --> 00:08:01.820
- Transactions.


00:08:01.820 --> 00:08:02.660
- Transactions.


00:08:02.660 --> 00:08:05.140
which was a big thing.


00:08:05.140 --> 00:08:08.180
But 4.2 is out, and I'm kind of excited


00:08:08.180 --> 00:08:10.220
about a couple features that it came out with.


00:08:10.220 --> 00:08:12.340
So the transactions are there,


00:08:12.340 --> 00:08:16.140
but now they're distributed transactions.


00:08:16.140 --> 00:08:20.340
So they're transactions that cross sharded clusters


00:08:20.340 --> 00:08:23.900
and replica sets, and that's just really cool.


00:08:23.900 --> 00:08:24.940
- Yeah, that's super cool, yeah.


00:08:24.940 --> 00:08:27.860
I mean, you could use that cool transactional set before,


00:08:27.860 --> 00:08:28.980
but you're kind of limited, right?


00:08:28.980 --> 00:08:31.140
And now it's like, no matter what crazy cluster


00:08:31.140 --> 00:08:33.900
with scaling and sharding and replication you have set up,


00:08:33.900 --> 00:08:35.780
you can just do a transaction and it's all good.


00:08:35.780 --> 00:08:36.620
Pretty cool.


00:08:36.620 --> 00:08:37.820
- They're a good idea anyway,


00:08:37.820 --> 00:08:41.500
but with testing you can set up a complex database


00:08:41.500 --> 00:08:45.220
full of stuff and then at the beginning of your test,


00:08:45.220 --> 00:08:47.700
start a transaction and then after your test,


00:08:47.700 --> 00:08:49.740
and you roll this into a fixture,


00:08:49.740 --> 00:08:51.460
you can just roll back and your next test


00:08:51.460 --> 00:08:54.140
has the same data, it saves time.


00:08:54.140 --> 00:08:54.980
So that's cool.


00:08:54.980 --> 00:08:56.500
- Yeah, and it's probably got isolation


00:08:56.500 --> 00:08:58.540
if for some reason they ran in parallel or whatever.


00:08:58.540 --> 00:08:59.380
Yeah, it's really cool.


00:08:59.380 --> 00:09:01.780
- Yeah, the other feature that's pretty amazing


00:09:01.780 --> 00:09:04.220
is the field level encryption.


00:09:04.220 --> 00:09:08.300
And this is encryption done on a per field basis


00:09:08.300 --> 00:09:09.980
on the client side.


00:09:09.980 --> 00:09:12.060
So the server doesn't even have,


00:09:12.060 --> 00:09:15.680
it's not doing it on the server.


00:09:15.680 --> 00:09:18.560
So there's like system administration can be done


00:09:18.560 --> 00:09:22.540
without having to make sure everybody signs NDAs


00:09:22.540 --> 00:09:26.940
and all that stuff that you can manage your database


00:09:26.940 --> 00:09:29.500
without even being exposed to any of the secret stuff.


00:09:29.500 --> 00:09:30.340
- Yeah, that's awesome.


00:09:30.340 --> 00:09:33.580
Like most databases, most of what's in them is not sensitive


00:09:33.580 --> 00:09:35.820
but there's often like a little bit that is


00:09:35.820 --> 00:09:39.180
that's really, you don't want anyone to get access to.


00:09:39.180 --> 00:09:41.340
And yeah, this is really cool because like you said,


00:09:41.340 --> 00:09:45.500
it's done in the library that talks to MongoDB.


00:09:45.500 --> 00:09:49.060
So in PyMongo for the Python folks.


00:09:49.060 --> 00:09:50.740
And you just set the encryption key


00:09:50.740 --> 00:09:52.460
or decryption key over there


00:09:52.460 --> 00:09:55.460
and the server cannot decrypt it.


00:09:55.460 --> 00:09:58.400
So if somebody breaks into the server or you lose it,


00:09:58.400 --> 00:10:00.680
or it's like you set it up on the cloud for like testing


00:10:00.680 --> 00:10:01.920
and you forget that it's there,


00:10:01.920 --> 00:10:04.560
all the kind of random stuff that happens to databases,


00:10:04.560 --> 00:10:06.700
it doesn't matter in terms of this encrypted stuff


00:10:06.700 --> 00:10:08.660
because like literally the database


00:10:08.660 --> 00:10:09.760
doesn't know how to read it.


00:10:09.760 --> 00:10:12.240
It's the drivers that on the client side


00:10:12.240 --> 00:10:13.240
that have the keys.


00:10:13.240 --> 00:10:16.600
- So with GDPR stuff, if the customer says,


00:10:16.600 --> 00:10:18.260
"Hey, delete my stuff,"


00:10:18.260 --> 00:10:20.240
that's always been an issue with databases


00:10:20.240 --> 00:10:22.980
is it might be in a whole bunch of tables,


00:10:22.980 --> 00:10:25.560
but if you destroy the customer key,


00:10:25.560 --> 00:10:27.200
the data might still be there,


00:10:27.200 --> 00:10:29.000
but it's unreadable to anybody,


00:10:29.000 --> 00:10:31.120
so it may as well be garbage.


00:10:31.120 --> 00:10:33.280
- Absolutely, and it gets to be really tricky


00:10:33.280 --> 00:10:36.040
because even if you set up the right code


00:10:36.040 --> 00:10:41.040
to delete all the customer data out of your database,


00:10:41.040 --> 00:10:45.160
what about the backup that somebody made


00:10:45.160 --> 00:10:46.940
when an older admin was hired


00:10:46.940 --> 00:10:48.800
and they stored that in the S3 buckets


00:10:48.800 --> 00:10:50.760
so it was offsite, right?


00:10:50.760 --> 00:10:53.440
how do you delete the data out of there?


00:10:53.440 --> 00:10:54.280
You know what I mean?


00:10:54.280 --> 00:10:55.240
But if it's encrypted,


00:10:55.240 --> 00:10:57.620
then you can just throw away the encryption key


00:10:57.620 --> 00:10:59.560
and then it's just gobbledygook.


00:10:59.560 --> 00:11:01.140
- Yeah, cool. - Pretty cool.


00:11:01.140 --> 00:11:01.980
I like it.


00:11:01.980 --> 00:11:03.240
Speaking of cool, Rollbar,


00:11:03.240 --> 00:11:06.600
happy to have them come along and sponsor the show.


00:11:06.600 --> 00:11:09.740
We use Rollbar on PythonBytes.fm, among other things.


00:11:09.740 --> 00:11:11.480
So if anything goes wrong,


00:11:11.480 --> 00:11:14.120
and it's kind of fortuitous, I guess,


00:11:14.120 --> 00:11:18.360
I woke up this morning with a ton of Rollbar messages


00:11:18.360 --> 00:11:21.840
because there was a data center failure that


00:11:21.840 --> 00:11:27.660
caused some connectivity between MongoDB and Pythonbytes.fm.


00:11:27.660 --> 00:11:29.200
How about that for a funny thing?


00:11:29.200 --> 00:11:31.400
So some network card broke, right?


00:11:31.400 --> 00:11:35.040
And the site couldn't talk to the database server,


00:11:35.040 --> 00:11:36.520
so it was freaking out.


00:11:36.520 --> 00:11:37.240
How do I know?


00:11:37.240 --> 00:11:38.320
Nobody complained to me.


00:11:38.320 --> 00:11:39.240
They probably should.


00:11:39.240 --> 00:11:40.560
Like, Michael, your site's down.


00:11:40.560 --> 00:11:41.200
What's going on?


00:11:41.200 --> 00:11:42.840
It's really messed up.


00:11:42.840 --> 00:11:44.400
But I just opened up my email.


00:11:44.400 --> 00:11:46.940
I'm like, whoa, there's a lot of rollbar stuff going on here.


00:11:46.940 --> 00:11:51.580
If you want to be notified right away, even when users don't tell you, check them out.


00:11:51.580 --> 00:11:52.580
They have a free tier.


00:11:52.580 --> 00:11:53.940
They have some great paid tiers.


00:11:53.940 --> 00:11:56.580
Visit pythonbytes.fm/rollbar.


00:11:56.580 --> 00:11:59.540
Super easy to integrate into Python, into the web frameworks.


00:11:59.540 --> 00:12:03.460
They've just got like one or two lines you enter, or maybe a little configuration, a


00:12:03.460 --> 00:12:04.900
few settings, off you go.


00:12:04.900 --> 00:12:05.900
It's really, really nice.


00:12:05.900 --> 00:12:07.380
So check them out, pythonbytes.fm/rollbar.


00:12:07.380 --> 00:12:08.380
- Nice.


00:12:08.380 --> 00:12:13.340
- So kind of like PyLustrator, that sounds kind of useful and interesting.


00:12:13.340 --> 00:12:18.040
This next one also sounds useful and interesting, but like PyIllustrator, it's like, as you


00:12:18.040 --> 00:12:20.200
look into it, you're like, "Whoa, this thing does a lot, man.


00:12:20.200 --> 00:12:21.520
Look at it go."


00:12:21.520 --> 00:12:25.240
So there's this project that was recommended by Francois LeBlanc.


00:12:25.240 --> 00:12:27.640
Thank you for that, Francois.


00:12:27.640 --> 00:12:30.680
And it's called Deep Difference.


00:12:30.680 --> 00:12:31.680
It's just called DeepDiff.


00:12:31.680 --> 00:12:37.060
And so it does deep differences in search of any Python object graph.


00:12:37.060 --> 00:12:39.600
So I've got an object which holds a list.


00:12:39.600 --> 00:12:41.800
That list points to a bunch of objects.


00:12:41.800 --> 00:12:42.800
Those have other pointers.


00:12:42.800 --> 00:12:46.760
I want to know is this thing somehow referenced by that?


00:12:46.760 --> 00:12:48.400
Let me do a search on it.


00:12:48.400 --> 00:12:49.440
Where is it?


00:12:49.440 --> 00:12:52.280
Is this giant crazy data structure


00:12:52.280 --> 00:12:55.800
same or different than other giant crazy data structure?


00:12:55.800 --> 00:12:56.720
And you could compare them.


00:12:56.720 --> 00:12:57.600
So that's pretty cool.


00:12:57.600 --> 00:12:59.720
So it has deep diff, it has deep search,


00:12:59.720 --> 00:13:01.840
and it also has deep hash.


00:13:01.840 --> 00:13:04.600
So if I've got some giant crazy data structure,


00:13:04.600 --> 00:13:06.600
you would like to know that if the data


00:13:06.600 --> 00:13:08.800
is the same across two of those,


00:13:08.800 --> 00:13:10.920
that the hash result is identical.


00:13:10.920 --> 00:13:12.760
And if any part of the data changes,


00:13:12.760 --> 00:13:15.160
that the hash then changes.


00:13:15.160 --> 00:13:16.360
- Oh yeah. - Possibly, right?


00:13:16.360 --> 00:13:18.720
So it will do that on object graphs


00:13:18.720 --> 00:13:20.960
that are not even hashable themselves.


00:13:20.960 --> 00:13:21.960
- Really? - Yeah.


00:13:21.960 --> 00:13:22.960
- Wow.


00:13:22.960 --> 00:13:24.600
- So that's pretty wild.


00:13:24.600 --> 00:13:26.840
I have just a lot of nice touches in here


00:13:26.840 --> 00:13:29.820
that kind of made me realize like, wow, this is wild.


00:13:29.820 --> 00:13:33.880
So for example, it'll give me the differences in a list,


00:13:33.880 --> 00:13:37.340
ignoring order and duplicate, right?


00:13:37.340 --> 00:13:40.040
Just what is the essence of this data?


00:13:40.040 --> 00:13:44.040
Or you can say, is any data repeated in this list


00:13:44.040 --> 00:13:47.280
or in this dictionary or something like that?


00:13:47.280 --> 00:13:50.000
You can exclude certain types.


00:13:50.000 --> 00:13:51.800
Maybe I want to know the data is the same,


00:13:51.800 --> 00:13:53.480
but they're both using a thread object.


00:13:53.480 --> 00:13:54.720
And the thread object is different,


00:13:54.720 --> 00:13:56.260
so of course they're going to be different.


00:13:56.260 --> 00:13:58.160
But say, don't check on the thread object.


00:13:58.160 --> 00:13:59.640
Just check the other stuff.


00:13:59.640 --> 00:14:03.460
So you can explicitly opt in or out data types


00:14:03.460 --> 00:14:04.360
that you might use.


00:14:04.360 --> 00:14:06.780
You could say, I'd like to compare these things, but only


00:14:06.780 --> 00:14:09.000
to four significant digits, because I computed them


00:14:09.000 --> 00:14:10.940
slightly differently and maybe they're,


00:14:10.940 --> 00:14:14.620
you know, I can't get them like to the decimal accuracy


00:14:14.620 --> 00:14:17.760
to be exactly the same, just the way they're done, right?


00:14:17.760 --> 00:14:20.000
You can exclude parts of your object tree


00:14:20.000 --> 00:14:22.160
that you've got for comparing, I mean, isn't this insane?


00:14:22.160 --> 00:14:25.280
- They've been able to do like significant digits


00:14:25.280 --> 00:14:27.280
in a deep data structure.


00:14:27.280 --> 00:14:28.920
That's amazing, that's really cool


00:14:28.920 --> 00:14:31.240
for a lot of the stuff I work with.


00:14:31.240 --> 00:14:33.520
- Yeah, I can imagine exactly, and you know what?


00:14:33.520 --> 00:14:35.840
I bet this would be really good to mix in with testing.


00:14:35.840 --> 00:14:36.960
Like you create your test data


00:14:36.960 --> 00:14:39.160
and then you deep diff it against the result.


00:14:39.160 --> 00:14:41.640
- Yeah, exactly, 'cause there may be noise in the system


00:14:41.640 --> 00:14:44.840
and you know some of the signals are noisy,


00:14:44.840 --> 00:14:46.920
so yeah, this is awesome, cool.


00:14:46.920 --> 00:14:49.480
- It's super simple, but yeah, it's pretty cool.


00:14:49.480 --> 00:14:51.640
So if that sounds like problems that you're trying to solve,


00:14:51.640 --> 00:14:52.880
it sounds like you are, Brian,


00:14:52.880 --> 00:14:54.600
then I think it's definitely worth having a look at.


00:14:54.600 --> 00:14:55.480
- Yeah, thanks.


00:14:55.480 --> 00:14:56.600
- Yeah, you bet.


00:14:56.600 --> 00:14:58.640
See, we just do this podcast to help each other out.


00:14:58.640 --> 00:15:00.920
Like, people can listen in.


00:15:00.920 --> 00:15:01.760
- Yeah.


00:15:01.760 --> 00:15:02.580
- Speaking of testing.


00:15:02.580 --> 00:15:04.620
- Josh Peek is somebody that we,


00:15:04.620 --> 00:15:06.860
I'm sure we met him before at a previous PyCon,


00:15:06.860 --> 00:15:12.860
He stopped by at PyCon this last year and met us and really great guy.


00:15:12.860 --> 00:15:15.580
He wrote this great article called Advanced Python Testing.


00:15:15.580 --> 00:15:17.980
And it's kind of incredible.


00:15:17.980 --> 00:15:24.300
He goes through his, he got in a situation at work where he was asked to do complex tasks


00:15:24.300 --> 00:15:29.180
where he had to, he knew that testing and making sure that he was doing things properly would


00:15:29.180 --> 00:15:34.780
and do good coding practices would help the entire process and make it go smoothly.


00:15:34.780 --> 00:15:46.380
So this is sort of a start to finish summary of it, but it's not that long of a read, but he talks about his learning journey, which he includes some great podcasts, including ours.


00:15:46.380 --> 00:15:50.380
Also, an awesome book on testing, and I know the author for that one.


00:15:50.380 --> 00:15:53.880
Not just plugging our own stuff, he's got some great stuff in here.


00:15:53.880 --> 00:16:02.780
He talks about, he starts off with just a basic, for people new to testing, what a basic test function looks like and having good structure.


00:16:02.780 --> 00:16:06.380
But then he talks about he wanted to ensure,


00:16:06.380 --> 00:16:10.020
do static analysis and code style.


00:16:10.020 --> 00:16:13.060
So he uses black within his testing.


00:16:13.060 --> 00:16:15.900
When he was talking about using Pylint,


00:16:15.900 --> 00:16:17.920
I don't use Pylint every day.


00:16:17.920 --> 00:16:19.580
So I didn't know that there was,


00:16:19.580 --> 00:16:22.380
it's a very comprehensive check,


00:16:22.380 --> 00:16:25.460
but it takes some time for large codebases.


00:16:25.460 --> 00:16:29.080
I didn't know that. But he has a cool hack that he puts in


00:16:29.080 --> 00:16:35.560
place to only for like check-in tests only lint modified files. Oh that's cool


00:16:35.560 --> 00:16:38.680
yeah because of course if they're unmodified then why would they yeah


00:16:38.680 --> 00:16:44.280
different outcome yeah right and then he uses a incorporating flake 8 to do doc


00:16:44.280 --> 00:16:48.520
string testing to make sure that people are using consistent doc string styles


00:16:48.520 --> 00:16:54.800
he covers all of his toxinny configuration changes he was trying to


00:16:54.800 --> 00:16:59.560
increases code coverage, so it includes coverage.py,


00:16:59.560 --> 00:17:04.560
but then also has a covfailunder flag that he adds


00:17:04.560 --> 00:17:08.840
for testing to make sure that if code coverage


00:17:08.840 --> 00:17:11.740
drops below a certain point, it fails the test,


00:17:11.740 --> 00:17:15.640
but he, and then just generally, gradually ratchet that up,


00:17:15.640 --> 00:17:18.820
so the increase, his target was 75%.


00:17:18.820 --> 00:17:21.520
So it talks, even goes into fixtures and mocks


00:17:21.520 --> 00:17:25.520
and spies and stubs and then even a cool tool


00:17:25.520 --> 00:17:30.040
called pytestVCR which records your network interactions


00:17:30.040 --> 00:17:32.960
and then replays those for future test runs


00:17:32.960 --> 00:17:35.120
and he saw a 10x speedup in that.


00:17:35.120 --> 00:17:35.960
- That's really cool.


00:17:35.960 --> 00:17:37.200
- There's so much cool stuff in here.


00:17:37.200 --> 00:17:38.560
- pytestVCR, that's really cool.


00:17:38.560 --> 00:17:40.840
I think the only problem with it is like


00:17:40.840 --> 00:17:44.400
maybe a lot of folks using it have no idea what VCR means.


00:17:44.400 --> 00:17:46.400
- Yeah, that's true.


00:17:46.400 --> 00:17:48.240
I mean, even, yeah, so.


00:17:48.240 --> 00:17:50.520
- Yeah, but no, it's awesome that you just record


00:17:50.520 --> 00:17:52.300
and network interactions and they don't have to depend


00:17:52.300 --> 00:17:54.080
on anything at all, I love it.


00:17:54.080 --> 00:17:57.500
- And the recordings are done based on a per test basis.


00:17:57.500 --> 00:18:01.060
So if you rerun a individual test,


00:18:01.060 --> 00:18:04.620
it only plays back the recording for that portion.


00:18:04.620 --> 00:18:07.980
It doesn't have a order dependency built in, which is cool.


00:18:07.980 --> 00:18:10.080
- Yeah, super cool, I love it.


00:18:10.080 --> 00:18:13.020
Yeah, that's a really nice article, Josh, well done.


00:18:13.020 --> 00:18:14.820
The last one I wanna talk about was sent over


00:18:14.820 --> 00:18:16.200
by Kevin Bukes.


00:18:16.200 --> 00:18:19.060
Now, we've covered a few of the language,


00:18:19.060 --> 00:18:24.580
of language level learning things recently. We talked about the CPython byte compiler,


00:18:24.580 --> 00:18:28.740
either last time or the time before that, how it doesn't really optimize stuff.


00:18:28.740 --> 00:18:33.140
And maybe there's some opportunities there, but more just to understand what's going on.


00:18:33.140 --> 00:18:40.980
So Kevin sent in a message said, Hey, I'm basically a C, C++ guy. And I saw the del keyword


00:18:40.980 --> 00:18:48.660
in Python. And it threw me for a loop because del seems like delete in C++, which means free memory.


00:18:48.660 --> 00:18:52.140
but it doesn't necessarily mean that in Python.


00:18:52.140 --> 00:18:54.500
So it even seems like some of the books out there


00:18:54.500 --> 00:18:56.340
are kind of being a little misleading,


00:18:56.340 --> 00:18:59.020
at least according to Kevin's reading of them.


00:18:59.020 --> 00:19:01.500
So I thought I'd just pull up an article


00:19:01.500 --> 00:19:03.460
that he sent over and then talk a little bit


00:19:03.460 --> 00:19:05.340
over some of the uses for Dell.


00:19:05.340 --> 00:19:07.340
- Great, I don't use it, so this would be good.


00:19:07.340 --> 00:19:10.180
- Yeah, so the context where I know Dell


00:19:10.180 --> 00:19:13.540
is I want to get something out of a list,


00:19:13.540 --> 00:19:16.700
or I want to get something out of a dictionary, right?


00:19:16.700 --> 00:19:17.520
- Okay.


00:19:17.520 --> 00:19:18.360
- And it's a little bit weird.


00:19:18.360 --> 00:19:19.860
like in keyword, right?


00:19:19.860 --> 00:19:22.620
A lot of times I would expect some operator


00:19:22.620 --> 00:19:25.960
to be on the object I'm modifying, right?


00:19:25.960 --> 00:19:30.540
Like list or, you know, string.in or something


00:19:30.540 --> 00:19:31.520
and you give it the value, right?


00:19:31.520 --> 00:19:35.760
But you say string space in space, the variable, right?


00:19:35.760 --> 00:19:37.880
So it's a little bit funky that you apply it


00:19:37.880 --> 00:19:40.580
not on the object, but as a keyword in the language


00:19:40.580 --> 00:19:41.460
and Dell's like that, right?


00:19:41.460 --> 00:19:44.040
So if I have a dictionary and I want to remove a key,


00:19:44.040 --> 00:19:46.120
not set it to nothing, but make it not be


00:19:46.120 --> 00:19:47.400
in the keys collection,


00:19:47.400 --> 00:19:50.120
you can say del dictionary of bracket,


00:19:50.120 --> 00:19:51.620
like as if you're accessing that value,


00:19:51.620 --> 00:19:53.560
but putting the del there takes it out.


00:19:53.560 --> 00:19:54.400
- Oh, okay.


00:19:54.400 --> 00:19:55.440
- Yeah, and you can also do that for lists.


00:19:55.440 --> 00:19:57.540
So I can go in and remove it,


00:19:57.540 --> 00:20:00.000
remove something from a list if I want.


00:20:00.000 --> 00:20:01.600
There's a remove function on the list,


00:20:01.600 --> 00:20:06.040
but somewhat confusingly potentially, it's by value, right?


00:20:06.040 --> 00:20:08.680
So I could say remove Jeff from the list


00:20:08.680 --> 00:20:10.840
and Jeff will no longer be in that list


00:20:10.840 --> 00:20:12.440
wherever he appeared.


00:20:12.440 --> 00:20:15.040
But if I want to say remove the third thing,


00:20:15.040 --> 00:20:17.280
there's no remove at or anything like that, right?


00:20:17.280 --> 00:20:20.080
I can't pass two, that's not a value, right?


00:20:20.080 --> 00:20:22.520
So Dell will let me remove that.


00:20:22.520 --> 00:20:25.240
You can also use pop for that, I believe, on the list,


00:20:25.240 --> 00:20:26.800
but Dell's a little more general purpose,


00:20:26.800 --> 00:20:29.120
and you can also delete slices.


00:20:29.120 --> 00:20:30.960
So I could say, go to this list


00:20:30.960 --> 00:20:33.680
and take out everything from two to five.


00:20:33.680 --> 00:20:35.280
You know, two colon five, like that.


00:20:35.280 --> 00:20:38.240
All right, so these are all pretty interesting.


00:20:38.240 --> 00:20:40.320
Now, I'm linking over to the official docs


00:20:40.320 --> 00:20:41.720
that talk about it, and this article


00:20:41.720 --> 00:20:43.400
that kind of talks through some of these examples


00:20:43.400 --> 00:20:45.040
and shows you how to use it.


00:20:45.040 --> 00:20:46.440
You can also delete a variable


00:20:46.440 --> 00:20:49.120
out of a local or a global namespace.


00:20:49.120 --> 00:20:51.040
So if there's a variable that's been defined


00:20:51.040 --> 00:20:52.320
and you want it to not be defined,


00:20:52.320 --> 00:20:54.240
I can say del space variable name.


00:20:54.240 --> 00:20:57.840
And now it's as if I didn't do that line that defined it,


00:20:57.840 --> 00:20:58.480
that created it.


00:20:58.480 --> 00:21:00.080
Does it remove it from the namespace?


00:21:00.080 --> 00:21:01.000
It removes-- yeah.


00:21:01.000 --> 00:21:04.000
It doesn't free the memory necessarily,


00:21:04.000 --> 00:21:09.080
but it takes it out as a global variable or a local one.


00:21:09.080 --> 00:21:12.200
So does it actually free any memory?


00:21:12.200 --> 00:21:13.480
It depends.


00:21:13.480 --> 00:21:15.560
So if I have it in the global names--


00:21:15.560 --> 00:21:17.280
Let's say it's a global, right?


00:21:17.280 --> 00:21:20.840
It has, obviously, the thing that has a value


00:21:20.840 --> 00:21:23.320
at that variable, it's taking up some memory.


00:21:23.320 --> 00:21:26.080
If nothing else is pointing at it,


00:21:26.080 --> 00:21:26.920
it's still gonna be around


00:21:26.920 --> 00:21:28.120
'cause that global variable's pointing at it,


00:21:28.120 --> 00:21:30.080
but if you call del that variable,


00:21:30.080 --> 00:21:32.920
you'll dereference that one reference to it,


00:21:32.920 --> 00:21:35.440
putting the reference count to zero and freeing it up.


00:21:35.440 --> 00:21:38.440
So theoretically, you could free up memory using del.


00:21:38.440 --> 00:21:39.680
Similarly, if it's in a list


00:21:39.680 --> 00:21:41.560
and the only place that points to it,


00:21:41.560 --> 00:21:43.360
has a reference to it, is that list itself,


00:21:43.360 --> 00:21:45.040
and you delete it out of there, out of the dictionary,


00:21:45.040 --> 00:21:46.920
it goes away, right, memory-wise.


00:21:46.920 --> 00:21:48.620
But if something else is pointing on it,


00:21:48.620 --> 00:21:50.360
then obviously it's not going to go away.


00:21:50.360 --> 00:21:53.440
We also talked about how the CPython bytecode compiler is


00:21:53.440 --> 00:21:57.600
dumb-- dumb as in not super optimizing, maybe on purpose.


00:21:57.600 --> 00:22:00.840
And I think you could also, if you're really


00:22:00.840 --> 00:22:02.800
dealing with memory issues, and you're like,


00:22:02.800 --> 00:22:06.200
I really wish this thing would just go away sooner


00:22:06.200 --> 00:22:08.320
in this one little edge case, you could probably


00:22:08.320 --> 00:22:11.080
use Dell to put in some of the optimizations


00:22:11.080 --> 00:22:14.120
that you might hope that the compiler itself might do,


00:22:14.120 --> 00:22:14.880
but doesn't.


00:22:14.880 --> 00:22:18.260
like dereference a thing as soon as it's used


00:22:18.260 --> 00:22:20.680
within a function before you can get to the end


00:22:20.680 --> 00:22:21.520
or things like this.


00:22:21.520 --> 00:22:22.520
- Yeah, okay.


00:22:22.520 --> 00:22:23.960
- So is it for memory?


00:22:23.960 --> 00:22:27.840
Sort of, not really, but maybe as a side effect.


00:22:27.840 --> 00:22:29.600
- Yeah, this has been a long time,


00:22:29.600 --> 00:22:31.160
but I do remember it tripping me up


00:22:31.160 --> 00:22:34.800
because I was like, it seems a lot like delete,


00:22:34.800 --> 00:22:37.400
which should have a matching new to it.


00:22:37.400 --> 00:22:38.800
- Exactly, exactly.


00:22:38.800 --> 00:22:40.520
We've both done the C++ thing, right?


00:22:40.520 --> 00:22:42.360
Like where's the new that goes with Dell?


00:22:42.360 --> 00:22:43.920
I've never seen a new.


00:22:43.920 --> 00:22:44.800
Anyway, it's pretty cool.


00:22:44.800 --> 00:22:46.140
There's a couple of links here.


00:22:46.140 --> 00:22:47.680
There's a visual documentation.


00:22:47.680 --> 00:22:49.960
There's the article understanding Python's Dell.


00:22:49.960 --> 00:22:52.720
And then there's the reference to that bytecode compiler


00:22:52.720 --> 00:22:53.640
people can check out.


00:22:53.640 --> 00:22:54.280
Yeah.


00:22:54.280 --> 00:22:55.800
In C++, I don't think there's a way


00:22:55.800 --> 00:22:58.360
to remove a name from a namespace.


00:22:58.360 --> 00:22:59.960
Yeah, I don't think so either, right?


00:22:59.960 --> 00:23:00.760
Yeah.


00:23:00.760 --> 00:23:04.440
You can make it point at null, but that's about it, right?


00:23:04.440 --> 00:23:04.920
Yeah.


00:23:04.920 --> 00:23:06.600
But you've got to think about it, right?


00:23:06.600 --> 00:23:09.280
Like classes, you could delete a field out of a class, right?


00:23:09.280 --> 00:23:11.320
Because it's just a dictionary.


00:23:11.320 --> 00:23:13.920
So much of Python is built on dictionaries, right?


00:23:13.920 --> 00:23:16.000
the variables are their variable names


00:23:16.000 --> 00:23:17.480
or the keys in the dictionary


00:23:17.480 --> 00:23:19.240
and their values are their value.


00:23:19.240 --> 00:23:21.600
So you just take it out of the global dictionary effectively.


00:23:21.600 --> 00:23:22.960
Right? - Yeah, okay, cool.


00:23:22.960 --> 00:23:23.800
- Pretty sweet.


00:23:23.800 --> 00:23:25.960
So those are our main items for today.


00:23:25.960 --> 00:23:28.240
You got anything else you wanna chat about, Brian?


00:23:28.240 --> 00:23:29.840
- I'm just, I'm glad it's summer.


00:23:29.840 --> 00:23:31.000
It's starting to feel nice.


00:23:31.000 --> 00:23:31.880
Feels like summer.


00:23:31.880 --> 00:23:34.040
But other than that, not much.


00:23:34.040 --> 00:23:34.880
How about you?


00:23:34.880 --> 00:23:35.700
- Summer's awesome.


00:23:35.700 --> 00:23:36.840
It makes programming hard.


00:23:36.840 --> 00:23:38.520
'Cause programming's indoors.


00:23:38.520 --> 00:23:41.440
Although some of my friends and I who work from home,


00:23:41.440 --> 00:23:43.920
We try to get out and program in like a coffee shop


00:23:43.920 --> 00:23:45.800
or a cafe by a lake or something.


00:23:45.800 --> 00:23:48.360
And periodically, we have the weird experience


00:23:48.360 --> 00:23:50.800
of getting a sunburn while writing code.


00:23:50.800 --> 00:23:53.080
And yeah, we've dubbed it a code burn


00:23:53.080 --> 00:23:55.360
and it's kind of a badge of honor.


00:23:55.360 --> 00:23:56.440
- That's funny, cool.


00:23:56.440 --> 00:23:58.600
- Yeah, so there's actually a couple of things


00:23:58.600 --> 00:23:59.440
I wanna throw out here.


00:23:59.440 --> 00:24:02.720
We recently had Max Sklar from the local Maximum podcast


00:24:02.720 --> 00:24:05.720
and afterwards he had me on his podcast.


00:24:05.720 --> 00:24:10.720
So I'll be on episode 73, which should be out not yet,


00:24:10.780 --> 00:24:12.820
but thanks to time shifting, when this episode comes out,


00:24:12.820 --> 00:24:13.660
it should already be out.


00:24:13.660 --> 00:24:14.740
And I'll put a link to that.


00:24:14.740 --> 00:24:18.380
Josh Thurston sent over a cool video


00:24:18.380 --> 00:24:22.820
of the popularity of languages on Stack Overflow


00:24:22.820 --> 00:24:26.080
over time as a bar chart race.


00:24:26.080 --> 00:24:27.460
I didn't know about bar chart races,


00:24:27.460 --> 00:24:29.980
but these are basically animated bar charts over time.


00:24:29.980 --> 00:24:32.500
And you just watch the bars grow and shrink.


00:24:32.500 --> 00:24:33.320
And it's really cool.


00:24:33.320 --> 00:24:35.660
Python is kind of like a little tiny consideration


00:24:35.660 --> 00:24:36.500
at the bottom.


00:24:36.500 --> 00:24:38.900
And obviously we know that Python is crushing it


00:24:38.900 --> 00:24:41.220
on popularity and Stack Overflow and all those things.


00:24:41.220 --> 00:24:43.140
So it's like a minute and a half video.


00:24:43.140 --> 00:24:44.860
I think everyone will appreciate watching it


00:24:44.860 --> 00:24:46.100
if they just got a minute to kill.


00:24:46.100 --> 00:24:47.060
- No, it's a fun video.


00:24:47.060 --> 00:24:50.020
And one of the things I enjoy about it is early on,


00:24:50.020 --> 00:24:53.800
you see the Java bar going up and down


00:24:53.800 --> 00:24:56.060
based on the time of the year,


00:24:56.060 --> 00:24:58.860
because it was used in education a lot.


00:24:58.860 --> 00:25:00.020
- Yes. - That totally made sense.


00:25:00.020 --> 00:25:01.180
- Exactly, you're like,


00:25:01.180 --> 00:25:02.900
oh, there's a huge spike in September.


00:25:02.900 --> 00:25:04.820
I wonder why. (laughing)


00:25:04.820 --> 00:25:06.220
Maybe a bunch of people got a job.


00:25:06.220 --> 00:25:09.960
- No, like CS 101 is now back in session.


00:25:09.960 --> 00:25:10.800
- Yeah.


00:25:10.800 --> 00:25:11.640
- Exactly.


00:25:11.640 --> 00:25:12.820
Then the last one I want to throw out


00:25:12.820 --> 00:25:15.100
is this thing called PineSource.


00:25:15.100 --> 00:25:18.960
So what this does, this comes to us from Anders Klint.


00:25:18.960 --> 00:25:23.960
It's basically a UML diagram creation tool for Python code.


00:25:23.960 --> 00:25:26.540
So you give it some Python files,


00:25:26.540 --> 00:25:28.300
it will generate a UML diagram


00:25:28.300 --> 00:25:30.940
that shows the relationship of all the classes in there.


00:25:30.940 --> 00:25:32.020
- Oh, that's cool.


00:25:32.020 --> 00:25:32.860
- Yeah, it's pretty cool.


00:25:32.860 --> 00:25:35.940
There's a free, maybe even open source version,


00:25:35.940 --> 00:25:38.020
And then there's also a paid version.


00:25:38.020 --> 00:25:40.180
So you can buy it.


00:25:40.180 --> 00:25:43.420
I'm actually not a huge fan of UML.


00:25:43.420 --> 00:25:45.460
But if you have Python code and you


00:25:45.460 --> 00:25:48.340
think a UML diagram would help describing it,


00:25:48.340 --> 00:25:49.820
this thing's pretty cool, actually.


00:25:49.820 --> 00:25:50.980
And it's a little GUI app.


00:25:50.980 --> 00:25:51.980
There's a bunch of screenshots.


00:25:51.980 --> 00:25:53.400
You can check it out and see if it'll help you.


00:25:53.400 --> 00:25:54.900
But it looks pretty neat.


00:25:54.900 --> 00:25:57.880
And it does proper UML, not just like sort


00:25:57.880 --> 00:25:59.180
of visualization of classes.


00:25:59.180 --> 00:26:00.620
So that's kind of nice.


00:26:00.620 --> 00:26:02.740
-My favorite use of these kinds of diagrams


00:26:02.740 --> 00:26:04.480
is to print them out and pin them


00:26:04.480 --> 00:26:06.720
to your wall, your cubicle wall,


00:26:06.720 --> 00:26:08.360
so that other programmers think


00:26:08.360 --> 00:26:10.760
that you're smarter than they are.


00:26:10.760 --> 00:26:13.720
- Absolutely, put some little scriptic notes on them,


00:26:13.720 --> 00:26:16.920
like as if you're marking them up, yeah, absolutely.


00:26:16.920 --> 00:26:17.760
Love it.


00:26:17.760 --> 00:26:19.000
Yeah, so you can do this with your project.


00:26:19.000 --> 00:26:21.240
Yes, this huge thing is our project.


00:26:21.240 --> 00:26:22.240
Anyway, it's pretty cool,


00:26:22.240 --> 00:26:23.680
and there's a free version, like I said,


00:26:23.680 --> 00:26:25.360
so maybe it'll help some folks out there.


00:26:25.360 --> 00:26:27.120
All right, you ready for some jokes, Brian?


00:26:27.120 --> 00:26:28.040
- Yes, definitely.


00:26:28.040 --> 00:26:29.160
- All right, I have a,


00:26:29.160 --> 00:26:31.560
you've heard about the glass being half full and half empty,


00:26:31.560 --> 00:26:33.560
and like, oh, I'm a half empty sort of person,


00:26:33.560 --> 00:26:35.400
I kind of see the world as slightly negative.


00:26:35.400 --> 00:26:35.900
Yes.


00:26:35.900 --> 00:26:37.600
So here's the developer version.


00:26:37.600 --> 00:26:40.440
So we have an optimist who says the glass is half full.


00:26:40.440 --> 00:26:43.360
We have the pessimist who says the glass is half empty.


00:26:43.360 --> 00:26:45.480
And we have the programmer who says the glass


00:26:45.480 --> 00:26:48.000
is twice as large as necessary.


00:26:48.000 --> 00:26:50.080
Yes, definitely.


00:26:50.080 --> 00:26:53.800
So I wanted to extend that with the pragmatist that


00:26:53.800 --> 00:26:56.340
says that I'm just allowing enough room for requirements


00:26:56.340 --> 00:26:59.480
oversight, scope creep, and schedule overrun.


00:26:59.480 --> 00:27:00.040
That's right.


00:27:00.040 --> 00:27:01.080
It's perfect.


00:27:01.080 --> 00:27:01.600
I love it.


00:27:01.600 --> 00:27:04.640
- And then you have this other one about software startups.


00:27:04.640 --> 00:27:07.160
- Yeah, man, it's not really any startup,


00:27:07.160 --> 00:27:10.360
but I watched The Upside with Kevin Hart last night,


00:27:10.360 --> 00:27:13.560
and it was a joke that I couldn't help but sharing.


00:27:13.560 --> 00:27:14.640
I can't remember the characters,


00:27:14.640 --> 00:27:16.600
but Kevin's character said,


00:27:16.600 --> 00:27:19.660
"Would you invest in my business idea?"


00:27:19.660 --> 00:27:24.660
And the other guy says, "That seems too niche, Kevin."


00:27:24.660 --> 00:27:26.360
What's niche mean?


00:27:26.360 --> 00:27:28.540
Oh, it's the girl version of nephew.


00:27:28.540 --> 00:27:30.080
(laughing)


00:27:30.080 --> 00:27:30.920
It's terrible.


00:27:30.920 --> 00:27:34.920
I love it. That's bad. If you got to ask, that's a pretty good answer.


00:27:34.920 --> 00:27:35.920
Yeah. Yeah.


00:27:35.920 --> 00:27:39.920
Cool. Cool. All right. Well, thanks for putting all the cool topics together as always and


00:27:39.920 --> 00:27:40.920
being here.


00:27:40.920 --> 00:27:41.920
Yeah. Thank you. Bye.


00:27:41.920 --> 00:27:46.040
Thank you for listening to Python Bytes. Follow the show on Twitter via @PythonBytes. That's


00:27:46.040 --> 00:27:52.280
Python Bytes as in B-Y-T-E-S. And get the full show notes at PythonBytes.FM. If you


00:27:52.280 --> 00:27:56.320
have a news item you want featured, just visit PythonBytes.FM and send it our way. We're


00:27:56.320 --> 00:27:59.040
always on the lookout for sharing something cool.


00:27:59.040 --> 00:28:02.320
On behalf of myself and Brian Okken, this is Michael Kennedy.


00:28:02.320 --> 00:28:05.360
Thank you for listening and sharing this podcast with your friends and colleagues.

