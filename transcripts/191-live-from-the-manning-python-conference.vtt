
00:00:00.000 --> 00:00:04.900
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.


00:00:04.900 --> 00:00:09.400
This is episode 191, recorded July 14th, 2020.


00:00:09.400 --> 00:00:10.200
I'm Michael Kennedy.


00:00:10.200 --> 00:00:11.100
And I'm Brian Okken.


00:00:11.100 --> 00:00:12.700
And welcome, special guest, Enos.


00:00:12.700 --> 00:00:13.100
Hi.


00:00:13.100 --> 00:00:14.600
Yeah, it's great to have you here.


00:00:14.600 --> 00:00:19.700
So I want to kick this off with a cool IoT thing.


00:00:19.700 --> 00:00:23.800
Now, IoT and Python, they've got a pretty special place.


00:00:23.800 --> 00:00:28.200
'cause when I think about Python, I think of it as not being something


00:00:28.200 --> 00:00:32.600
that sort of competes with assembly language and really, really low-level type of programming


00:00:32.600 --> 00:00:38.100
for small devices, but, you know, amazing people put together MicroPython,


00:00:38.100 --> 00:00:42.900
which is a reimplementation of Python that runs on little tiny devices.


00:00:42.900 --> 00:00:46.400
And we're talking like $5 microchip-type devices, right?


00:00:46.400 --> 00:00:47.800
Have either of you all played with these?


00:00:47.800 --> 00:00:48.400
- No. - No.


00:00:48.400 --> 00:00:51.900
No, I haven't, but I've been seeing a bit of this from my brother,


00:00:51.900 --> 00:00:54.540
So he's pretty amazing. He's a bit younger than me.


00:00:54.540 --> 00:00:58.480
He's an event technician, and he recently taught himself programming and everything


00:00:58.480 --> 00:01:02.440
just so he can build stuff on these tiny raspberry Pis.


00:01:02.440 --> 00:01:04.640
And, like, I don't know, he's doing super advanced stuff.


00:01:04.640 --> 00:01:07.580
It's been really interesting to see him learn to program.


00:01:07.580 --> 00:01:09.140
And he's also incredibly good.


00:01:09.140 --> 00:01:12.140
He has amazing instincts about programming, even though he's never done it before.


00:01:12.140 --> 00:01:14.340
But, like, so I've been kind of watching this from afar,


00:01:14.340 --> 00:01:16.780
and it made me really want to build stuff.


00:01:16.780 --> 00:01:17.840
So I'm very curious.


00:01:17.840 --> 00:01:22.040
Yeah, I've done the circuit Python on some of the Adafruit stuff.


00:01:22.040 --> 00:01:25.240
Exactly. So I always just want to build these things.


00:01:25.240 --> 00:01:29.240
I'm like, what could I think of that I could build with these cool little devices?


00:01:29.240 --> 00:01:31.040
I just, in my world, I don't have it.


00:01:31.040 --> 00:01:36.940
Maybe if I had a farm, I could like automate, you know, like watering or monitoring the crops,


00:01:36.940 --> 00:01:41.940
or if I had a factory, but I just don't live in a world that allows me to automate these things.


00:01:41.940 --> 00:01:44.540
Do you have pets? Maybe you can build something for pets.


00:01:44.540 --> 00:01:48.840
We generally don't have pets, but we are fostering kittens for the summer.


00:01:48.840 --> 00:01:52.780
So I could put a little device on to one of the kittens, potentially.


00:01:52.780 --> 00:01:55.880
GPS tracker.


00:01:55.880 --> 00:01:56.440
Yeah.


00:01:56.440 --> 00:01:59.520
So in general, you have to get these little devices, right?


00:01:59.520 --> 00:02:01.580
You've got the us PyCon.


00:02:01.580 --> 00:02:05.020
We got the circuit playground express, which is that little circular thing.


00:02:05.020 --> 00:02:09.040
It's got some 10 LEDs and a bunch of buttons and other really advanced


00:02:09.040 --> 00:02:12.840
things like motion sensors and temperature and so on.


00:02:13.580 --> 00:02:18.060
Probably the earliest one of these that was a big hit was the BBC micro bit,


00:02:18.060 --> 00:02:20.820
where I think every seventh grader in the UK got it.


00:02:20.820 --> 00:02:25.100
Some grade around that scale got one of these and it really made a difference


00:02:25.100 --> 00:02:27.540
in kids seeing themselves as a programmer.


00:02:27.540 --> 00:02:32.220
And interestingly, especially women were more likely to see programming


00:02:32.220 --> 00:02:36.220
as something they might be interested in, in, in that, that group where


00:02:36.220 --> 00:02:37.100
they went through that experience.


00:02:37.100 --> 00:02:40.340
So I think there's a real value to work with these little devices, but getting


00:02:40.340 --> 00:02:42.700
ahold of them can be a challenge, right?


00:02:43.220 --> 00:02:51.460
you've got to physically get this device that means you have that idea of I want to do this thing and then I have to order it from Adafruit or somewhere else and then wait for it to come.


00:02:51.460 --> 00:02:58.260
And my experience has been I'll go there and I'm like, oh, this is really cool. I want one of these. Oh, wait, no, it's sold out right now. You can order it again in a month.


00:02:58.260 --> 00:03:05.860
Right? So getting is a challenge. And also if you're working in a group of, say, like you want to teach a high school class,


00:03:05.860 --> 00:03:10.260
or a college class or something like that, and you want everyone to have access to these,


00:03:10.260 --> 00:03:14.020
Well, then all of a sudden the fact that it maybe it costs $50


00:03:14.020 --> 00:03:17.140
wasn't a big deal, but if it's $50 times


00:03:17.140 --> 00:03:20.900
20 or 100 kids, then all of a sudden, well, maybe not.


00:03:20.900 --> 00:03:24.740
So I want to talk about this thing called device simulator express.


00:03:24.740 --> 00:03:28.500
So this is a plugin or extension or whatever the things that


00:03:28.500 --> 00:03:31.300
I think it's extensions that VS Code calls them


00:03:31.300 --> 00:03:33.140
that makes VS Code do more stuff.


00:03:33.140 --> 00:03:35.860
And it's a open source free


00:03:35.860 --> 00:03:40.260
device simulator. So what you can do is you just go to the Visual Studio Code


00:03:40.260 --> 00:03:45.060
extensions thing and you type device, probably is sufficient, but device simulator express.


00:03:45.060 --> 00:03:46.860
And it'll let you install this


00:03:46.860 --> 00:03:52.560
extra thing inside of VS Code that is really quite legit. So


00:03:52.560 --> 00:03:54.860
it gives you a simulated


00:03:54.860 --> 00:03:57.760
Circuit Playground Express, a simulated


00:03:57.760 --> 00:04:00.260
BBC micro bit and the most


00:04:00.260 --> 00:04:05.760
impressive to me is the clue from Adafruit which actually has a screen that you can put graphics on.


00:04:05.760 --> 00:04:11.260
So really, really cool way to get these little IoT devices


00:04:11.260 --> 00:04:17.260
with CircuitPython, so Adafruit's fork of MicroPython on there.


00:04:17.260 --> 00:04:19.260
What do you guys think? See that picture? Look how cool that is.


00:04:19.260 --> 00:04:22.960
Yeah, so you can write Python in one tab


00:04:22.960 --> 00:04:25.660
and then just have the visualization in the other.


00:04:25.660 --> 00:04:26.560
That's pretty cool, yeah.


00:04:26.560 --> 00:04:29.060
Yeah, exactly. And it's very similar to, say,


00:04:29.060 --> 00:04:31.860
what you might do with Xcode and iPhones,


00:04:31.860 --> 00:04:35.060
where you have an emulator that looks quite a bit like it,


00:04:35.060 --> 00:04:37.660
or what you would do on the Android equivalent.


00:04:37.660 --> 00:04:39.660
I actually think this is a little bit better than the device


00:04:39.660 --> 00:04:41.160
because it's actually larger.


00:04:41.160 --> 00:04:43.960
Right? Like the device is really small, but here's like a, you know,


00:04:43.960 --> 00:04:47.360
it could be like a huge thing on your 4K monitor with a little


00:04:47.360 --> 00:04:51.660
Clue device. So you can simulate CircuitPlayground Express, BBC Microbit, and the Clue


00:04:51.660 --> 00:04:54.460
in here, and we just say new project,


00:04:54.460 --> 00:04:57.860
and it'll actually write the boilerplate code


00:04:57.860 --> 00:05:01.260
for the main.py or code.py or whatever it's called that


00:05:01.260 --> 00:05:03.260
the various thing is going to run.


00:05:03.260 --> 00:05:07.960
And like you said, Enos, on one half it's got the code and the other half it has the device that you can interact with.


00:05:07.960 --> 00:05:12.060
I was thinking that a couple of cases that would be great is,


00:05:12.060 --> 00:05:14.060
like you were saying, trying to get a hold of it, but


00:05:14.060 --> 00:05:17.260
you might not even know if the concept that you're going to use


00:05:17.260 --> 00:05:19.960
is really going to work for the device you're thinking of. So


00:05:19.960 --> 00:05:22.660
this would be a good way to try it out, to try out


00:05:22.660 --> 00:05:26.060
whether the thing you're thinking of trying in your house or whatever


00:05:26.060 --> 00:05:28.060
would actually work for this device.


00:05:28.060 --> 00:05:29.560
The other thing was,


00:05:29.560 --> 00:05:31.860
you brought up education,


00:05:31.860 --> 00:05:33.260
and that it's big.


00:05:33.260 --> 00:05:37.260
I was thinking about a couple of conferences where they tried to do the display


00:05:37.260 --> 00:05:40.460
and sometimes try to have like a camera or something.


00:05:40.460 --> 00:05:43.060
Sometimes it works and sometimes it doesn't.


00:05:43.060 --> 00:05:47.460
This way you could just do like a tutorial or in a teaching scenario


00:05:47.460 --> 00:05:51.860
and everybody could see it because it's just going to be displayed on your monitors.


00:05:51.860 --> 00:05:55.060
Right, your standard screen sharing would totally work here. That's a good point as well.


00:05:55.060 --> 00:05:57.060
And it doesn't have to be all or nothing.


00:05:57.060 --> 00:06:01.260
Actually, what's really interesting is this thing isn't just an emulator, but you can do debugging.


00:06:01.260 --> 00:06:05.100
you can set like a breakpoint and like step through it running on the device,


00:06:05.100 --> 00:06:08.780
simulate it, or you can actually run it, if you had a real device plugged in,


00:06:08.780 --> 00:06:10.380
you can run it on there as well.


00:06:10.380 --> 00:06:13.580
And then do debugging and breakpoints and stuff on the actual device.


00:06:13.580 --> 00:06:14.940
So that's like you tested here.


00:06:14.940 --> 00:06:18.460
I always admire people who actually use like the proper debugging features.


00:06:18.460 --> 00:06:20.540
I know VS Code has like so much of this,


00:06:20.540 --> 00:06:23.820
and I'm always like, I should use this more, but I'm like, okay, print.


00:06:23.820 --> 00:06:25.820
Print, print.


00:06:25.820 --> 00:06:29.340
Yeah, there's some really cool libraries that will actually do that.


00:06:29.340 --> 00:06:30.740
that I can't remember what it's called,


00:06:30.740 --> 00:06:32.300
but Brian and I recently covered one


00:06:32.300 --> 00:06:35.380
that would actually print out a little bit of your code


00:06:35.380 --> 00:06:36.820
and the variables as they change over time.


00:06:36.820 --> 00:06:39.900
It was like the height of the print debugging world.


00:06:39.900 --> 00:06:40.780
It was really, really cool.


00:06:40.780 --> 00:06:41.620
I wish I could remember.


00:06:41.620 --> 00:06:42.460
Do you remember, Brian?


00:06:42.460 --> 00:06:44.540
- No, we actually covered a couple of them.


00:06:44.540 --> 00:06:46.380
- I know, I know.


00:06:46.380 --> 00:06:47.220
That's the problem.


00:06:47.220 --> 00:06:49.460
We cover thousands of things in here.


00:06:49.460 --> 00:06:51.220
So another thing that's interesting is like,


00:06:51.220 --> 00:06:52.580
okay, so you see the device.


00:06:52.580 --> 00:06:54.220
Some of them have buttons and they have lights,


00:06:54.220 --> 00:06:56.180
and you can imagine maybe you could touch the button,


00:06:56.180 --> 00:06:58.180
but they also have things like temperature,


00:06:58.180 --> 00:07:00.180
gyrometer type things, or like you're moving it,


00:07:00.180 --> 00:07:03.540
or motion sensing, or even like if you shake it,


00:07:03.540 --> 00:07:07.140
this thing has little ways to simulate all that stuff.


00:07:07.140 --> 00:07:08.860
So you can like have a temperature slider


00:07:08.860 --> 00:07:10.460
that freaks it out and says,


00:07:10.460 --> 00:07:11.900
hey, the temperature's actually this


00:07:11.900 --> 00:07:13.260
on your temperature sensor, and so on.


00:07:13.260 --> 00:07:15.540
So all the stuff that the devices simulate


00:07:15.540 --> 00:07:16.380
are available here.


00:07:16.380 --> 00:07:17.260
- Oh, that's cool. - Yeah.


00:07:17.260 --> 00:07:20.420
So I actually had the team over on Talk Python not long ago,


00:07:20.420 --> 00:07:24.260
so people can check that over at talkpython.fm.


00:07:24.260 --> 00:07:26.420
And yeah, I'm also really excited


00:07:26.420 --> 00:07:28.260
about what you got coming here next, Brian.


00:07:28.260 --> 00:07:29.100
What is that?


00:07:29.100 --> 00:07:32.020
- Yeah, well, speaking of, I guess debugging versus test,


00:07:32.020 --> 00:07:33.600
we didn't really talk about testing.


00:07:33.600 --> 00:07:34.440
Anyway, I'm really excited about--


00:07:34.440 --> 00:07:35.940
- We should have talked about testing.


00:07:35.940 --> 00:07:38.780
- Yeah, so I was thinking,


00:07:38.780 --> 00:07:42.660
and I was thinking that I hardly ever use a debugger


00:07:42.660 --> 00:07:44.580
for my source code,


00:07:44.580 --> 00:07:46.060
but I use a debugger all the time


00:07:46.060 --> 00:07:48.340
when I'm debugging my tests.


00:07:48.340 --> 00:07:50.820
I don't know, it's just something different about it.


00:07:50.820 --> 00:07:52.220
But I've been running a lot of tests


00:07:52.220 --> 00:07:53.460
and debugging a lot of tests lately


00:07:53.460 --> 00:07:57.760
because pytest 6, the candidate release is out.


00:07:57.760 --> 00:08:00.160
Now, by the time this episode airs,


00:08:00.160 --> 00:08:04.320
I don't know if the release candidate will be released


00:08:04.320 --> 00:08:05.920
or just the release candidate is still,


00:08:05.920 --> 00:08:08.000
but you can install it.


00:08:08.000 --> 00:08:09.480
We'll have instructions in the show notes,


00:08:09.480 --> 00:08:14.420
but essentially you just have to say 6.0.0 RC1,


00:08:14.420 --> 00:08:15.900
and you'll get it.


00:08:15.900 --> 00:08:17.240
So there's a whole bunch of stuff


00:08:17.240 --> 00:08:18.800
that I'm really excited about.


00:08:18.800 --> 00:08:20.240
There's a lot of configuration


00:08:20.240 --> 00:08:22.960
that you used to be able to put in lots of places


00:08:22.960 --> 00:08:27.260
into your pytest.ini or your setup config or tox.ini or something,


00:08:27.260 --> 00:08:30.460
pytest 6 will support pyproject.toml now.


00:08:30.460 --> 00:08:32.960
So if you jumped on the toml bandwagon,


00:08:32.960 --> 00:08:35.660
you can stick your pytest configuration in there too.


00:08:35.660 --> 00:08:38.260
There's a lot of people excited about the type annotations.


00:08:38.260 --> 00:08:41.460
So the 6.0 is going to support type annotations.


00:08:41.460 --> 00:08:43.460
So it actually was a lot of work.


00:08:43.460 --> 00:08:47.660
There was a volunteer that went through and added type annotations to a bunch of it,


00:08:47.660 --> 00:08:50.160
especially the user-facing API.


00:08:50.160 --> 00:08:53.960
And why this is important is if you're type checking, you're


00:08:53.960 --> 00:08:56.160
running mypy or something over


00:08:56.160 --> 00:08:58.560
your source and everything,


00:08:58.560 --> 00:09:00.960
your project, and you're,


00:09:00.960 --> 00:09:02.720
why not include your tests?


00:09:02.720 --> 00:09:04.960
But if pytest doesn't support


00:09:04.960 --> 00:09:06.760
types, it doesn't really help you much.


00:09:06.760 --> 00:09:10.080
So it will now, so that's really, really cool addition.


00:09:10.080 --> 00:09:11.520
What this is, is basically


00:09:11.520 --> 00:09:13.920
the API of pytest itself


00:09:13.920 --> 00:09:15.440
is now annotated with types?


00:09:15.440 --> 00:09:18.240
Yes, and well, a lot of the internal code as well.


00:09:18.240 --> 00:09:21.200
So they actually went through and did a lot. There was a lot of work.


00:09:21.200 --> 00:09:25.040
And if you look at the conversation chain, it went on for,


00:09:25.040 --> 00:09:27.520
it was a month, several month project.


00:09:27.520 --> 00:09:30.400
Wow. What does that mean for compatibility?


00:09:30.400 --> 00:09:33.440
Does that make pytest like 3.6 only and above?


00:09:33.440 --> 00:09:37.680
I think the modern versions of pytest really already are 3.6 and above.


00:09:37.680 --> 00:09:39.440
I'm not sure about that.


00:09:39.440 --> 00:09:42.320
Right. So then the door was opened, is that because otherwise it would...


00:09:42.320 --> 00:09:43.920
I mean, it would be a vain,


00:09:43.920 --> 00:09:47.060
we'd move to release a completely new version


00:09:47.060 --> 00:09:50.460
with Python 2 backwards compatibility.


00:09:50.460 --> 00:09:52.120
Like, that's...


00:09:52.120 --> 00:09:53.800
– Yeah, why not do that? – You wouldn't do that, right?


00:09:53.800 --> 00:09:54.860
I mean, it's...


00:09:54.860 --> 00:09:57.500
I think the message it sends is not great.


00:09:57.500 --> 00:09:58.660
I totally agree.


00:09:58.660 --> 00:10:02.820
There is a pinned version of pytest, I don't remember which one it is,


00:10:02.820 --> 00:10:06.120
that still supports 2.7 if you're on it,


00:10:06.120 --> 00:10:08.800
but no new features are going in there.


00:10:08.800 --> 00:10:13.120
The thing I'm really excited about is a little flag they've added


00:10:13.200 --> 00:10:15.980
called no header. So don't use this.


00:10:15.980 --> 00:10:17.980
Most people don't use this. When you run


00:10:17.980 --> 00:10:20.140
pytest, it prints out some stuff like


00:10:20.140 --> 00:10:22.140
the version of python, the version of pytest,


00:10:22.140 --> 00:10:24.140
all the plugins you're using,


00:10:24.140 --> 00:10:26.140
a bunch of information about it. All


00:10:26.140 --> 00:10:28.140
this stuff is really important for


00:10:28.140 --> 00:10:30.140
logging if you're capturing


00:10:30.140 --> 00:10:32.140
the output to save somewhere or do


00:10:32.140 --> 00:10:34.140
a bug report or something.


00:10:34.140 --> 00:10:36.140
That information is great to help other people


00:10:36.140 --> 00:10:38.140
understand it. What I don't like


00:10:38.140 --> 00:10:40.140
about that is that


00:10:40.140 --> 00:10:42.140
it's not helpful if you're writing


00:10:42.140 --> 00:10:47.660
tutorials or if you're writing code to put on a slide or something all that extra stuff just


00:10:47.660 --> 00:10:53.740
takes up space and it distracts. Yeah like I've had students say like I ran it I think pytest in


00:10:53.740 --> 00:10:58.940
PyCharm and it has like some kind of output just stating where it is and what it's doing they're


00:10:58.940 --> 00:11:03.180
like this didn't work for me I'm like well that was just random output from the tool you're not


00:11:03.180 --> 00:11:06.860
actually supposed to try to run that part you know what I mean but it's it's I mean I saw why they


00:11:06.860 --> 00:11:11.100
saw that but at the same time like to ability to just say like these details don't matter in the


00:11:11.100 --> 00:11:13.100
in the long term is great.


00:11:13.100 --> 00:11:15.100
Yeah, so I'm excited about that,


00:11:15.100 --> 00:11:17.100
to trim it down. There was a plugin


00:11:17.100 --> 00:11:19.100
called TLDR, too long,


00:11:19.100 --> 00:11:21.100
didn't read, but it


00:11:21.100 --> 00:11:23.100
actually didn't take enough of the header off


00:11:23.100 --> 00:11:25.100
than I wanted, so I had my own


00:11:25.100 --> 00:11:27.100
tool that would do this, but


00:11:27.100 --> 00:11:29.100
now I've got this, which is great.


00:11:29.100 --> 00:11:31.100
So a lot of the configuration,


00:11:31.100 --> 00:11:33.100
there is a chance for human error


00:11:33.100 --> 00:11:35.100
if you type something wrong and you


00:11:35.100 --> 00:11:37.100
type a variable name wrong, and


00:11:37.100 --> 00:11:39.100
so I really like this new


00:11:39.100 --> 00:11:43.600
called strict config, which will throw an error


00:11:43.600 --> 00:11:46.500
if you have the pytest section of your configuration


00:11:46.500 --> 00:11:48.900
has something that it doesn't recognize.


00:11:48.900 --> 00:11:52.800
And it probably is just you misspelled some variable or something.


00:11:52.800 --> 00:11:54.200
- Yeah, that's good to know. - And then...


00:11:54.200 --> 00:11:55.800
Not to... I can't remember the version,


00:11:55.800 --> 00:11:57.800
but it was... I think it was in pytest 5.


00:11:57.800 --> 00:12:00.160
They added some code highlighting stuff that...


00:12:00.160 --> 00:12:02.500
Yeah, that's super cool. I discovered that just the other day.


00:12:02.500 --> 00:12:05.800
I, like, just somehow updated all my dependencies in some environment,


00:12:05.800 --> 00:12:08.300
and suddenly pytest output was colored.


00:12:08.360 --> 00:12:10.360
And I was like, whoa, this is amazing. Yeah.


00:12:10.360 --> 00:12:12.360
Yeah, the syntax highlighting, I love it.


00:12:12.360 --> 00:12:15.360
But there's times where you don't want that, I guess.


00:12:15.360 --> 00:12:18.360
So there's a new flag to turn it off.


00:12:18.360 --> 00:12:21.360
And then a little tiny detail that I really like is


00:12:21.360 --> 00:12:24.360
the diff comparisons on pytest are wonderful.


00:12:24.360 --> 00:12:27.360
But apparently they didn't do recursive comparisons


00:12:27.360 --> 00:12:29.360
of data classes and adder classes.


00:12:29.360 --> 00:12:32.360
But now they do. So that's neat.


00:12:32.360 --> 00:12:35.360
There's a whole bunch of new features, fixes.


00:12:35.360 --> 00:12:37.360
I ran through some of the features I really liked.


00:12:37.360 --> 00:12:42.800
There are deprecations, and it's a large list of breaking changes and deprecations.


00:12:42.800 --> 00:12:44.800
That's why they went to a new number, pytest6.


00:12:44.800 --> 00:12:48.800
But I went through the whole list and I didn't see anything that was like,


00:12:48.800 --> 00:12:51.200
"Oh, that's going to stop me. I'm going to have to change something."


00:12:51.200 --> 00:12:52.400
Okay, that's good to know.


00:12:52.400 --> 00:12:55.920
I mean, if you say, "Oh, there was nothing that we're using,"


00:12:55.920 --> 00:12:58.320
I feel confident that maybe there's nothing in my code either.


00:12:58.320 --> 00:13:02.720
And I knew that somebody was going to ask, "Is my pytest book still valid?"


00:13:02.720 --> 00:13:05.200
Yes, it is. I'm going through it right now.


00:13:05.200 --> 00:13:07.200
I haven't gone through the whole thing yet to make sure.


00:13:07.200 --> 00:13:10.200
The side that is not compatible is not the book.


00:13:10.200 --> 00:13:12.200
The book's fine.


00:13:12.200 --> 00:13:14.800
I have a plugin that now is broken.


00:13:14.800 --> 00:13:17.300
So pytest check still works,


00:13:17.300 --> 00:13:19.300
but if you depend on XFail,


00:13:19.300 --> 00:13:22.200
pytest, this is a, wow, this is a corner case,


00:13:22.200 --> 00:13:24.500
but if you depend on pytest check


00:13:24.500 --> 00:13:26.500
and the XFail feature of it,


00:13:26.500 --> 00:13:28.100
it doesn't work right now.


00:13:28.100 --> 00:13:29.100
So I'll have to fix that.


00:13:29.100 --> 00:13:31.400
So you would say XFail fails temporarily.


00:13:31.400 --> 00:13:33.400
Yeah.


00:13:33.400 --> 00:13:38.840
It actually marks everything as a pass. So if you mark x fail, wow, that's like x fail section. Yeah


00:13:38.840 --> 00:13:47.160
It's really bad anyway, I'll have to get back to that. Yeah, this is really exciting that pytest 6 is out super cool


00:13:47.160 --> 00:13:49.000
I know that there were some


00:13:49.000 --> 00:13:54.840
Waves some uncertainty in the ecosystem. So it sounds like that got ironed out things are going strong new versions coming out


00:13:54.840 --> 00:13:57.240
I even saw that guido


00:13:57.240 --> 00:14:02.520
Had tweeted the announce retweeted the announcement and said yay type annotations coming in pytest


00:14:02.600 --> 00:14:05.360
Of course, he's been all about type annotations these days.


00:14:05.360 --> 00:14:07.520
We'll come back to that later in the show, actually.


00:14:07.520 --> 00:14:09.440
So, Ines, I know you work a lot with text,


00:14:09.440 --> 00:14:10.640
but are you frustrated with it?


00:14:10.640 --> 00:14:12.160
What's the story of this name here?


00:14:12.160 --> 00:14:14.520
Oh, my point of the day.


00:14:14.520 --> 00:14:16.400
Yeah, text attack.


00:14:16.400 --> 00:14:19.160
- What does text attack do? - Yeah, no, I thought I'd present something


00:14:19.160 --> 00:14:21.520
- for MySpace, obviously. - Yeah, awesome.


00:14:21.520 --> 00:14:23.520
Yeah, there's this new framework that I came across,


00:14:23.520 --> 00:14:25.440
and it's called TextAttack, yay?


00:14:25.440 --> 00:14:28.600
And it's a framework for adversarial attacks


00:14:28.600 --> 00:14:31.320
and data augmentation for natural language processing.


00:14:31.320 --> 00:14:33.960
So what are adversarial attacks?


00:14:33.960 --> 00:14:37.200
You've probably, you might have actually seen a lot of examples of it.


00:14:37.200 --> 00:14:42.560
For instance, an image classifier that predicts a cat or some other image,


00:14:42.560 --> 00:14:46.040
even though you show it complete noise and you somehow trick the model.


00:14:46.040 --> 00:14:50.920
Or you might have seen people at protests wearing like funny shirts or masks


00:14:50.920 --> 00:14:53.120
to trick facial recognition technology.


00:14:53.120 --> 00:14:57.120
So really to trick the model into to like, you know, not recognize them.


00:14:57.400 --> 00:15:03.160
Or the famous example of Google Translate suddenly hallucinating these crazy Bible texts.


00:15:03.160 --> 00:15:08.280
If you just put in some complete gibberish, like just "ga ga ga ga" and then it would go like,


00:15:08.280 --> 00:15:11.240
"The Lord has spoken to the people," stuff like that.


00:15:11.240 --> 00:15:13.400
That's amazing.


00:15:13.400 --> 00:15:20.120
I'll include a link to an article by a researcher who explains why this happened and shows the


00:15:20.120 --> 00:15:25.080
example. But it's pretty fascinating. But I think it all comes down to the fundamental problem of


00:15:25.080 --> 00:15:29.320
of like, how do you understand a model that you train?


00:15:29.320 --> 00:15:32.640
And what does it mean to understand your model?


00:15:32.640 --> 00:15:34.620
And how does it behave in situations


00:15:34.620 --> 00:15:36.060
when it suddenly gets to see something


00:15:36.060 --> 00:15:37.440
that it doesn't expect at all, like,


00:15:37.440 --> 00:15:39.240
ga, ga, ga, what does it do?


00:15:39.240 --> 00:15:40.760
And the thing with neural network models


00:15:40.760 --> 00:15:43.220
is you can't just look at the weights.


00:15:43.220 --> 00:15:44.240
They're not linear.


00:15:44.240 --> 00:15:47.280
They're like, you can't just look at what your model is.


00:15:47.280 --> 00:15:48.760
You have to actually run it.


00:15:48.760 --> 00:15:51.200
And so that library takes attack


00:15:51.200 --> 00:15:55.280
that lets you actually try out different types of attacks


00:15:55.280 --> 00:15:58.680
from the academic literature and different types of inputs


00:15:58.680 --> 00:16:01.760
that you can give a model to see whether it produces


00:16:01.760 --> 00:16:03.600
something that you're like not happy with,


00:16:03.600 --> 00:16:04.960
or that's like really weird,


00:16:04.960 --> 00:16:07.900
and exposes some problems in your model.


00:16:07.900 --> 00:16:09.600
And it also lets you then,


00:16:09.600 --> 00:16:10.820
because normally what's the goal?


00:16:10.820 --> 00:16:13.400
The goal is, well, you do that and then you find out,


00:16:13.400 --> 00:16:16.260
oh, damn, like if I suddenly feed it this complete nonsense,


00:16:16.260 --> 00:16:17.900
or if I feed it Spanish text,


00:16:17.900 --> 00:16:20.360
it like goes completely in the wrong direction


00:16:20.360 --> 00:16:22.200
and suddenly predict stuff that's not there.


00:16:22.200 --> 00:16:26.240
And if you deployed that model into like a context


00:16:26.240 --> 00:16:28.460
where it's actually used, that would be pretty terrible.


00:16:28.460 --> 00:16:30.480
And there are much worse things that can be happening.


00:16:30.480 --> 00:16:33.200
So you can also create more robust training data


00:16:33.200 --> 00:16:36.720
by like replacing words with synonyms.


00:16:36.720 --> 00:16:41.200
You can swap out characters and just see how the model does.


00:16:41.200 --> 00:16:42.320
So I thought that was very cool.


00:16:42.320 --> 00:16:45.660
And yeah, in general, I think adversarial attacks,


00:16:45.660 --> 00:16:48.160
it's a pretty interesting topic and yeah.


00:16:48.160 --> 00:16:49.080
- Yeah, it's super interesting.


00:16:49.080 --> 00:16:51.480
So the idea is basically you've trained up a model


00:16:51.480 --> 00:16:53.380
on some text and for what you've given it,


00:16:53.380 --> 00:16:54.840
it's probably working,


00:16:54.840 --> 00:16:57.420
but if you give it something you weren't expecting,


00:16:57.420 --> 00:16:59.000
you want to try that to make sure


00:16:59.000 --> 00:17:01.560
that it doesn't go insane at least.


00:17:01.560 --> 00:17:02.400
- Yeah, exactly.


00:17:02.400 --> 00:17:04.200
And it can expose very unexpected things


00:17:04.200 --> 00:17:06.000
like the Bible text, for example.


00:17:06.000 --> 00:17:08.700
That sounds really bizarre when you first hear it,


00:17:08.700 --> 00:17:10.880
but one explanation for that would be that,


00:17:10.880 --> 00:17:13.440
well, especially it happens in low resource languages


00:17:13.440 --> 00:17:15.520
where we don't have much text


00:17:15.520 --> 00:17:17.560
and especially not much text translated


00:17:17.560 --> 00:17:18.400
into other languages.


00:17:18.400 --> 00:17:21.460
but there's one type of text that has a lot


00:17:21.460 --> 00:17:24.140
of translations available and that's the Bible.


00:17:24.140 --> 00:17:26.420
And so, and they're parallel corpora


00:17:26.420 --> 00:17:28.320
where you have one text, one line in English,


00:17:28.320 --> 00:17:30.540
one line in Somali, for example.


00:17:30.540 --> 00:17:32.580
And then people train their models on that.


00:17:32.580 --> 00:17:34.700
But one thing that also is very specific


00:17:34.700 --> 00:17:37.640
about Bible texts is that Bible texts has some words


00:17:37.640 --> 00:17:40.380
that like really only occur in the Bible texts.


00:17:40.380 --> 00:17:42.540
It uses some really weird words.


00:17:42.540 --> 00:17:44.760
So what your model might be learning is,


00:17:44.760 --> 00:17:47.060
if I come across a super unexpected word


00:17:47.060 --> 00:17:50.100
that's really, really rare, that must be Bible.


00:17:50.100 --> 00:17:52.580
And also the objective is you want your model


00:17:52.580 --> 00:17:54.140
to output a reasonable sentence.


00:17:54.140 --> 00:17:55.900
So the model's like, well, okay,


00:17:55.900 --> 00:17:58.060
if that's the rare word, then the next word


00:17:58.060 --> 00:17:59.740
needs to be something that matches,


00:17:59.740 --> 00:18:02.500
and then you have this bizarre sentence from the Bible,


00:18:02.500 --> 00:18:05.060
even though you typed in "ga ga ga."


00:18:05.060 --> 00:18:05.900
And it happens.


00:18:05.900 --> 00:18:06.740
- Yeah, how funny.


00:18:06.740 --> 00:18:07.560
- Yeah.


00:18:07.560 --> 00:18:10.300
- Yeah, so it looks like they have actually


00:18:10.300 --> 00:18:13.500
a bunch of trained models already at the Text Attack


00:18:13.500 --> 00:18:15.780
Model Zoo, they call it, I guess.


00:18:15.780 --> 00:18:17.780
- Yeah, everything's called the Model 2.


00:18:17.780 --> 00:18:19.520
- Yeah, cute.


00:18:19.520 --> 00:18:23.060
And so you can just take these and run it against it,


00:18:23.060 --> 00:18:26.680
like the movie reviews from Rotten Tomatoes or IMDb


00:18:26.680 --> 00:18:28.940
or the news set or Yelp,


00:18:28.940 --> 00:18:31.120
and just give it that kind of data


00:18:31.120 --> 00:18:32.140
and see how it comes out, right?


00:18:32.140 --> 00:18:33.140
- Exactly, yeah.


00:18:33.140 --> 00:18:33.980
I think that's pretty cool.


00:18:33.980 --> 00:18:35.020
And yeah, and then you can actually,


00:18:35.020 --> 00:18:37.220
you can also generate your own data


00:18:37.220 --> 00:18:40.140
or load in your data and generate data


00:18:40.140 --> 00:18:42.540
that maybe produces a better model


00:18:42.540 --> 00:18:45.220
or like covers things that your model previously


00:18:45.220 --> 00:18:46.300
couldn't handle at all.


00:18:46.300 --> 00:18:48.040
So that's the data augmentation part.


00:18:48.040 --> 00:18:49.020
Yeah, that's all very important.


00:18:49.020 --> 00:18:51.100
And I think it's also very important to understand


00:18:51.100 --> 00:18:54.280
the models that we train and really try them out


00:18:54.280 --> 00:18:55.820
and think about like, what do they do


00:18:55.820 --> 00:18:58.220
and how are they going to behave in like a real world


00:18:58.220 --> 00:19:00.020
scenario that we care about?


00:19:00.020 --> 00:19:00.860
Because yeah, the consequences--


00:19:00.860 --> 00:19:03.660
- As soon as you're making decisions on this data, right?


00:19:03.660 --> 00:19:04.500
On these models.


00:19:04.500 --> 00:19:05.340
- Yeah.


00:19:05.340 --> 00:19:07.920
- I guess as soon as a human is convinced


00:19:07.920 --> 00:19:11.020
that the model works and they start making decisions on it,


00:19:11.020 --> 00:19:14.740
right, that could go bad if the situation changes


00:19:14.740 --> 00:19:41.780
the type of data. And especially if the model is bad, like I'm always saying, like, well, people are always scared of these dystopian futures where like, we have AI that can, I don't know, know anything about us and predict anything, and works. But the real dystopia is, if we have models that kind of don't work, and I really shit, but people believe that they work, that's much more. It's not even about whether they work. It's about whether people believe it. And then, you know, that's where it gets really bad. And yeah, yeah,


00:19:41.940 --> 00:19:43.780
Yeah, and that's way more likely.


00:19:43.780 --> 00:19:45.580
- Sorry, Brian. - Yeah, yes.


00:19:45.580 --> 00:19:49.340
It's a more difficult world to test this sort of stuff,


00:19:49.340 --> 00:19:52.180
to figure out what does it mean for a model to be bad?


00:19:52.180 --> 00:19:53.740
How do you tell if it's bad?


00:19:53.740 --> 00:19:57.620
And models can be both working with some datasets


00:19:57.620 --> 00:20:00.020
and produce gibberish with...


00:20:00.020 --> 00:20:04.340
Or, yeah, I guess in this case, the reverse.


00:20:04.340 --> 00:20:07.180
Not produce gibberish if you pass in gibberish.


00:20:07.180 --> 00:20:09.740
Yeah, actually, yeah, I just realized it ties in very well


00:20:09.740 --> 00:20:12.620
with a pytest point earlier and just like, yep,


00:20:12.620 --> 00:20:15.620
machine learning is quite special in a way that it's code plus data.


00:20:15.620 --> 00:20:17.940
Code you can test, you can have a function and you're like,


00:20:17.940 --> 00:20:21.820
"Yay, that comes in. That's what I expect out. Easy. Write a test for it."


00:20:21.820 --> 00:20:25.780
You know, it's not that easy. Testing is hard, but like, fundamentally, yeah.


00:20:25.780 --> 00:20:28.180
It's somewhat deterministic, I think.


00:20:28.180 --> 00:20:32.460
Yeah. And even if it's not, there's like something you can, you know, test around it.


00:20:32.460 --> 00:20:33.940
And it's much harder with the model.


00:20:33.940 --> 00:20:36.140
Yeah. Yeah, for sure.


00:20:36.140 --> 00:20:37.980
All right, before we get to the next item,


00:20:37.980 --> 00:20:42.120
Just want to let you know this episode is brought to you all by us.


00:20:42.120 --> 00:20:44.620
Over at Talk Python Training, we have a bunch of courses.


00:20:44.620 --> 00:20:45.760
You can check them out.


00:20:45.760 --> 00:20:47.760
And we're actually featured in the Humble Bundle


00:20:47.760 --> 00:20:49.760
that's running the Python Humble Bundle right now.


00:20:49.760 --> 00:20:54.060
So if you go to talkpython.fm/humble2020,


00:20:54.060 --> 00:20:59.260
you can get $1,400 worth of Python training tools and whatnot for 25 bucks.


00:20:59.260 --> 00:21:01.260
So that's a pretty decent deal.


00:21:01.260 --> 00:21:03.620
And, Brian, you mentioned your book before.


00:21:03.620 --> 00:21:04.660
Tell people about your book real quick.


00:21:04.660 --> 00:21:06.780
Yeah, so Python Testing with pytest.


00:21:06.780 --> 00:21:08.880
is a book I wrote, and it's still very valid,


00:21:08.880 --> 00:21:11.340
even though it was written a few years ago.


00:21:11.340 --> 00:21:14.140
The intent was the 80% of pytests


00:21:14.140 --> 00:21:18.020
that you will always need to know for any version of pytest.


00:21:18.020 --> 00:21:20.720
And I've had a lot of feedback from people saying


00:21:20.720 --> 00:21:23.020
a weekend of skimming this


00:21:23.020 --> 00:21:25.420
makes it so that they understand how to test.


00:21:25.420 --> 00:21:26.480
It's a weekend worthwhile.


00:21:26.480 --> 00:21:28.640
Yeah, absolutely. And Enos, you want to talk a little bit


00:21:28.640 --> 00:21:30.520
about Explosion, just so that people know?


00:21:30.520 --> 00:21:33.620
Yeah, so, I mean, some of you who are listening to this


00:21:33.680 --> 00:21:38.800
might know me from my work on spaCy, which is an open source library for NLP and Python,


00:21:38.800 --> 00:21:43.200
which I'm one of the co-developers of. And yeah, that's all free open source. And we're


00:21:43.200 --> 00:21:49.200
actually just working on the nightly version or the pre-release of spaCy 3, which is going


00:21:49.200 --> 00:21:55.160
to have a lot of exciting features that might also mention a few more things later on. And


00:21:55.160 --> 00:22:00.160
yeah, so that's maybe that's already going to be out by the time this podcast officially


00:22:00.160 --> 00:22:04.100
comes out, maybe not, I don't want to over promise, but yeah, you can definitely try


00:22:04.100 --> 00:22:09.060
that out. And we also recently released a new version of our annotation tool, Prodigy,


00:22:09.060 --> 00:22:14.020
which comes with a lot of new features for annotating relations, audio, video. And the


00:22:14.020 --> 00:22:17.800
idea here is, well, once you get serious about training your own models, you usually want


00:22:17.800 --> 00:22:22.260
to create your own data sets for your very specific problems that solve your problems.


00:22:22.260 --> 00:22:26.100
And often the first idea you have might not be the best one. It's a continuous process.


00:22:26.100 --> 00:22:27.180
you want to develop your data.


00:22:27.180 --> 00:22:31.260
And Prodigy was really designed as a developer tool


00:22:31.260 --> 00:22:33.380
that lets you create your own datasets


00:22:33.380 --> 00:22:36.300
with a web app, a Python backend, you can script.


00:22:36.300 --> 00:22:38.460
That's our commercial tool, that's how we make money.


00:22:38.460 --> 00:22:42.220
And it's very cool to see a growing community around this.


00:22:42.220 --> 00:22:43.780
So yeah, that's what we're doing.


00:22:43.780 --> 00:22:45.700
We have some cool stuff planned for the future.


00:22:45.700 --> 00:22:47.180
So stay tuned.


00:22:47.180 --> 00:22:48.100
- Yeah, people should check it out.


00:22:48.100 --> 00:22:51.180
Actually, you and I talked on Talk Python 202


00:22:51.180 --> 00:22:53.500
about building a software business and entrepreneurship.


00:22:53.500 --> 00:22:54.460
You had a bunch of great advice.


00:22:54.460 --> 00:22:56.020
So people might want to check that out as well.


00:22:56.020 --> 00:22:59.860
Do you actually know these episode numbers by heart or did you look that up before?


00:22:59.860 --> 00:23:02.140
Some of them I know, but that one I used the search.


00:23:02.140 --> 00:23:03.900
I remember you were on there.


00:23:03.900 --> 00:23:05.820
I remember what it was about, but not the number.


00:23:05.820 --> 00:23:08.660
I just put together that I know two people from Explosion.


00:23:08.660 --> 00:23:09.660
So that's interesting.


00:23:09.660 --> 00:23:10.660
Yeah, and Sebastian.


00:23:10.660 --> 00:23:11.660
Absolutely.


00:23:11.660 --> 00:23:12.660
Sebastian.


00:23:12.660 --> 00:23:15.820
Yeah, he was on your podcast recently, which I feel really bad.


00:23:15.820 --> 00:23:19.060
I need to listen to, I wanted to listen to this because he advertised it with like, it


00:23:19.060 --> 00:23:23.740
will tell the story, true story behind his moustache, which I really wanted to know.


00:23:23.740 --> 00:23:26.660
And then I was like, I'll need to listen to this on the weekend. And I forgot. So yeah,


00:23:26.660 --> 00:23:30.180
if he's listening, I'm sorry, I will definitely I need I need to know this. So I will listen.


00:23:30.180 --> 00:23:31.180
Excellent.


00:23:31.180 --> 00:23:32.180
So don't spoil it.


00:23:32.180 --> 00:23:37.540
Do a great work on FastAPI. All right, speaking of people that have been on all the podcasts


00:23:37.540 --> 00:23:42.660
as well as Brett Cannon, he recently wrote an interesting article called what is the


00:23:42.660 --> 00:23:49.660
core of the Python programming language. And he's legitimately asking as a core developer,


00:23:49.660 --> 00:23:55.260
is not the maybe lowest level, but what is the essence, I guess, is maybe the way to


00:23:55.260 --> 00:23:56.260
think about it.


00:23:56.260 --> 00:23:57.260
Oh, wow.


00:23:57.260 --> 00:23:59.020
I only just got the core, core pun.


00:23:59.020 --> 00:24:01.420
Like it did not occur to me when I first read the article.


00:24:01.420 --> 00:24:03.260
I'm really, I feel really embarrassed now.


00:24:03.260 --> 00:24:07.540
To be fair, English is not my first language, but still, it's not about that.


00:24:07.540 --> 00:24:09.580
Anyway, sorry for interrupting.


00:24:09.580 --> 00:24:12.460
Yeah, when I first read it, I was thinking like, okay, we're going to talk about what


00:24:12.460 --> 00:24:19.060
is the lowest level and yeah, okay, it's probably C and C of L dot H, C of L dot C and so on.


00:24:19.060 --> 00:24:23.060
But really the thing is, Brett has been thinking a lot about web assembly


00:24:23.060 --> 00:24:27.060
and what does that mean for Python in the broad sense.


00:24:27.060 --> 00:24:31.060
He and I talked about it on Talk Python, I think at the very last


00:24:31.060 --> 00:24:35.060
PyCon event we did a live conversation there about that.


00:24:35.060 --> 00:24:39.060
And it's important because there's a few


00:24:39.060 --> 00:24:43.060
areas where Python is not the first choice, maybe not the second choice,


00:24:43.060 --> 00:24:47.060
sometimes not even the tenth choice of what you might use to


00:24:47.060 --> 00:24:52.340
program, some very important things like maybe mobile, maybe


00:24:52.340 --> 00:24:55.740
the web, the front end part of the web, importantly, I mean,


00:24:55.740 --> 00:25:00.020
so there's a few really important parts of technology


00:25:00.020 --> 00:25:03.180
where Python doesn't have much reach, but all of those areas


00:25:03.180 --> 00:25:07.020
support WebAssembly these days, right? And if you have something


00:25:07.020 --> 00:25:11.180
in C, you can compile it to WebAssembly. So there's some


00:25:11.180 --> 00:25:15.340
thought about like, well, what can we do potentially to make a


00:25:15.700 --> 00:25:20.800
WebAssembly runtime for Python so that Python magically,


00:25:20.800 --> 00:25:25.800
almost instantly gets access to what was just JavaScript front-end frameworks,


00:25:25.800 --> 00:25:30.800
space, what is mobile, iOS and Android,


00:25:30.800 --> 00:25:34.400
and all those things allow you to directly run JavaScript as part of your app.


00:25:34.400 --> 00:25:36.700
So how would we make that happen?


00:25:36.700 --> 00:25:38.600
So it's pretty important, right?


00:25:38.600 --> 00:25:41.600
If we could solve that problem, like Python is already so popular


00:25:41.600 --> 00:25:43.400
and its growth is so incredible,


00:25:43.400 --> 00:25:46.660
Like, what if we could say, oh yeah, and now it's an important language on mobile,


00:25:46.660 --> 00:25:49.040
and it's an important front-end language framework?


00:25:49.040 --> 00:25:51.360
Like, that would just take it to the next level,


00:25:51.360 --> 00:25:53.360
or maybe a couple levels up if you do them both.


00:25:53.360 --> 00:25:57.440
And WebAssembly seems to be one of the keys to kind of bridge that gap.


00:25:57.440 --> 00:26:00.440
Right? So, Brett talks about in this article how


00:26:00.440 --> 00:26:03.440
for so long, we've just had CPython


00:26:03.440 --> 00:26:05.700
is what we think of when we have Python.


00:26:05.700 --> 00:26:08.700
Sometimes people use PyPy, P-Y-P-Y,


00:26:08.700 --> 00:26:12.600
as a partially JIT compiled version.


00:26:12.600 --> 00:26:16.600
sometimes faster version of Python, but not always because the


00:26:16.600 --> 00:26:18.600
the way it interacts maybe with C,


00:26:18.600 --> 00:26:21.900
libraries that you might be using through packages and so on.


00:26:21.900 --> 00:26:27.200
And really it's a lot of Python's dynamic nature makes it hard to do outside of an interpreter.


00:26:27.200 --> 00:26:29.700
Where to be clear, WebAssembly is a


00:26:29.700 --> 00:26:34.500
compiled language, right? So if you're going to put it over there, maybe it's going to require it to be compiled.


00:26:34.500 --> 00:26:38.200
So this is a really interesting thing to go through and read and think about with Brett.


00:26:38.200 --> 00:26:43.160
He talks about things like, well, how much of the Python language would you have to implement


00:26:43.160 --> 00:26:45.360
and still consider it to be valid Python?


00:26:45.360 --> 00:26:49.040
Like we talked about MicroPython, and usually when people look at, they don't look at that


00:26:49.040 --> 00:26:50.360
and go, "That's not Python.


00:26:50.360 --> 00:26:51.360
That's fake."


00:26:51.360 --> 00:26:52.360
Right?


00:26:52.360 --> 00:26:53.820
No, like, it's Python, but it's not as much Python, right?


00:26:53.820 --> 00:26:59.640
You don't have the same, all the APIs on MicroPython as you do on regular Python.


00:26:59.640 --> 00:27:02.520
So questions like, do you still need a REPL?


00:27:02.520 --> 00:27:03.800
Could you live without locals?


00:27:03.800 --> 00:27:04.800
Right?


00:27:04.800 --> 00:27:07.580
The ability to ask what the local variables are and so on.


00:27:07.580 --> 00:27:11.180
So he said he didn't really have a great bunch of great answer.


00:27:11.180 --> 00:27:14.460
It's more of a philosophical like we need to solve this.


00:27:14.460 --> 00:27:16.740
But I do want to share some of my thoughts on this.


00:27:16.740 --> 00:27:22.680
And I feel like maybe what we could do is we could come up with like a standard Python


00:27:22.680 --> 00:27:27.580
language definition that is a subset of full Python, right?


00:27:27.580 --> 00:27:30.580
Here's the essence like, okay, we have to be able to create classes, we have to be able


00:27:30.580 --> 00:27:34.820
to create functions, you have to define strings, probably you want type annotations.


00:27:34.820 --> 00:27:36.500
But do you need a val?


00:27:36.500 --> 00:27:38.220
Maybe, maybe not, right?


00:27:38.220 --> 00:27:40.860
So like that, if you could have a subset of the language


00:27:40.860 --> 00:27:44.340
that was smaller, as well as the standard library,


00:27:44.340 --> 00:27:49.340
'cause do you really need to like parse CSS hex colors?


00:27:49.340 --> 00:27:50.700
Everywhere?


00:27:50.700 --> 00:27:51.520
Probably not.


00:27:51.520 --> 00:27:53.260
It's a very underused part of the library,


00:27:53.260 --> 00:27:55.020
but it's in there, right?


00:27:55.020 --> 00:27:56.420
So if we could narrow it down,


00:27:56.420 --> 00:27:57.740
maybe it would be easier to think about


00:27:57.740 --> 00:27:59.100
how does it go to WebAssembly?


00:27:59.100 --> 00:28:02.420
How does it go to like some kind of JavaScript runtime


00:28:02.420 --> 00:28:03.260
or something like that?


00:28:03.260 --> 00:28:04.740
And if it sounds crazy, you know,


00:28:04.740 --> 00:28:05.980
the .NET people did this.


00:28:05.980 --> 00:28:09.540
They have a .NET standard class library language.


00:28:09.540 --> 00:28:11.040
They got it running on WebAssembly.


00:28:11.040 --> 00:28:13.540
So there's an example of it out there


00:28:13.540 --> 00:28:15.680
and something that's kind of sort of similar.


00:28:15.680 --> 00:28:18.680
Right, so I think this would just open stuff up


00:28:18.680 --> 00:28:21.440
if you could get Python in these places.


00:28:21.440 --> 00:28:22.280
What do you guys think?


00:28:22.280 --> 00:28:24.140
- Initially, I was never so sold on WebAssembly


00:28:24.140 --> 00:28:26.680
and especially WebAssembly and Python


00:28:26.680 --> 00:28:30.140
until I watched Dave Beasley life code a compiler


00:28:30.140 --> 00:28:33.340
at PyCon India, I think it was.


00:28:33.340 --> 00:28:35.440
And I was like, "Oh, this is kind of fun."


00:28:35.440 --> 00:28:40.240
I mean, it was just also fun to watch Dave Beasley live code a compiler.


00:28:40.240 --> 00:28:42.320
- Yeah, for sure. - Classic.


00:28:42.320 --> 00:28:44.920
But so that did get me thinking.


00:28:44.920 --> 00:28:48.720
I do think one question I think we should ask ourselves is,


00:28:48.720 --> 00:28:53.620
well, do we really need Python to do all of the things in the browser?


00:28:53.620 --> 00:28:57.980
Like, does this really have a benefit that actually makes a difference?


00:28:57.980 --> 00:28:59.040
A.


00:28:59.040 --> 00:29:00.120
B.


00:29:00.120 --> 00:29:03.820
There are a lot of things people use Python for that just wouldn't work in that way.


00:29:03.880 --> 00:29:07.400
And that's also, I think, part of what made Python so popular in the first place.


00:29:07.400 --> 00:29:10.920
Like, for instance, you know, all the interactive computing environments.


00:29:10.920 --> 00:29:13.960
That's why people want to use Python for data science.


00:29:13.960 --> 00:29:17.160
It is, you know, IPython, Jupyter Notebooks, that sort of stuff.


00:29:17.160 --> 00:29:19.640
That's why, you know, Python as a dynamic language


00:29:19.640 --> 00:29:21.080
made so much sense to people.


00:29:21.080 --> 00:29:22.920
And that's what made it popular.


00:29:22.920 --> 00:29:26.440
And large-scale processing, like a lot of the type of stuff we're working on.


00:29:26.440 --> 00:29:29.240
It's like, yeah, there's stuff that you can run in the browser,


00:29:29.240 --> 00:29:33.000
but it's never going to be viable to run large-scale information extraction


00:29:33.640 --> 00:29:37.640
in the browser because you want to run that on a machine for like a few hours.


00:29:37.640 --> 00:29:41.480
But I think there are a lot of opportunities also in the machine learning space for privacy


00:29:41.480 --> 00:29:46.280
preserving technologies that already exist. I think from what I understand, Mozilla is working


00:29:46.280 --> 00:29:52.440
on some features built into the browser where you can have models predicting things without


00:29:52.440 --> 00:29:55.800
it being sent to someone's server. And I think that's obviously very powerful.


00:29:55.800 --> 00:30:00.360
That's an interesting idea. Right. Yeah. Yeah. Because if you could have a little bit of machine


00:30:00.360 --> 00:30:04.360
learning. But you don't have to give up the data privacy aspect of it. That's pretty cool.


00:30:04.360 --> 00:30:07.880
Yeah. So I think for that, there's a lot of potential here for running Python in a browser.


00:30:07.880 --> 00:30:08.120
Yeah.


00:30:08.120 --> 00:30:14.280
Well, we start getting used to saying, what is Python is, what is the CPython implementation?


00:30:14.280 --> 00:30:21.000
And we got to remember CPython is the reference implementation for the language spec. And I think,


00:30:21.000 --> 00:30:28.040
I guess we're kind of getting at, maybe we need to split it up and have a core language spec


00:30:28.040 --> 00:30:30.900
and an extended one or something, I don't know.


00:30:30.900 --> 00:30:32.600
Where would you divide the line?


00:30:32.600 --> 00:30:35.980
Because we've seen, like you said, we've seen things like CircuitPython and


00:30:35.980 --> 00:30:39.080
and other things, and we actually talked about several


00:30:39.080 --> 00:30:41.840
smaller languages based on Python that


00:30:41.840 --> 00:30:43.840
just try to be the same syntax.


00:30:43.840 --> 00:30:45.840
But at which point is it,


00:30:45.840 --> 00:30:48.460
when is it not Python anymore?


00:30:48.460 --> 00:30:51.920
And there's at least some of the stuff. Like I could totally see


00:30:51.920 --> 00:30:55.520
having a distribution of Python that doesn't have a REPL


00:30:55.520 --> 00:30:56.760
still count.


00:30:56.760 --> 00:31:00.540
I could totally see not having idle, for instance,


00:31:00.540 --> 00:31:03.340
if something doesn't ship with idle, is it still Python?


00:31:03.340 --> 00:31:04.480
I think so.


00:31:04.480 --> 00:31:09.980
And because of idle, then you need TK stuff in there.


00:31:09.980 --> 00:31:13.300
There's a lot of stuff that maybe I would be in like,


00:31:13.300 --> 00:31:15.100
could you live without locals?


00:31:15.100 --> 00:31:16.820
Most of the time, probably.


00:31:16.820 --> 00:31:18.820
I actually think this would be


00:31:18.820 --> 00:31:21.820
since the web and since mobile is so


00:31:21.820 --> 00:31:24.540
such a big part of our lives, and it will be for a while,


00:31:24.540 --> 00:31:27.180
this might be a decent dividing line to say,


00:31:27.180 --> 00:31:29.900
whether or not it's for WebAssembly or not,


00:31:29.900 --> 00:31:35.820
maybe we should split the division at whatever we need to implement a WebAssembly version of Python.


00:31:35.820 --> 00:31:38.420
And anything above that line


00:31:38.420 --> 00:31:40.940
is an extended version of Python.


00:31:40.940 --> 00:31:41.820
Yeah.


00:31:41.820 --> 00:31:43.140
Yeah, that's a good point.


00:31:43.140 --> 00:31:47.180
All right, I don't want to go too long in this section because I want to make sure we get the others.


00:31:47.180 --> 00:31:48.940
But I do want to leave you with just some thoughts.


00:31:48.940 --> 00:31:50.780
What if shipping Python


00:31:50.780 --> 00:31:52.860
was just shipping a single binary


00:31:52.860 --> 00:31:54.220
and a thing that ran it?


00:31:54.220 --> 00:31:55.900
you could do that with WebAssembly.


00:31:55.900 --> 00:31:58.860
Maybe two WebAssemblies, the runtime plus the code.


00:31:58.860 --> 00:32:00.940
What if all the browsers


00:32:00.940 --> 00:32:04.420
had capability to plug in alternate runtimes


00:32:04.420 --> 00:32:05.420
through WebAssembly?


00:32:05.420 --> 00:32:07.420
So right now you have a JavaScript engine, but what if


00:32:07.420 --> 00:32:09.100
like say Firefox


00:32:09.100 --> 00:32:10.740
in Edge and whatnot


00:32:10.740 --> 00:32:13.820
came up with a way to say here's a WebAssembly


00:32:13.820 --> 00:32:16.820
API to plug in alternate runtimes,


00:32:16.820 --> 00:32:20.380
Python, Ruby, .NET, Java, you name it,


00:32:20.380 --> 00:32:21.820
and then shipped


00:32:21.820 --> 00:32:24.060
with the latest version of each of those runtimes.


00:32:24.060 --> 00:32:25.260
So you just don't have to down...


00:32:25.260 --> 00:32:27.060
Like, the big problem now is you can do it,


00:32:27.060 --> 00:32:31.100
but you still got to download like 10 megs per page,


00:32:31.100 --> 00:32:32.460
which is not a good idea.


00:32:32.460 --> 00:32:34.460
So anyway, I think there's a ton of interesting


00:32:34.460 --> 00:32:36.060
things that open up


00:32:36.060 --> 00:32:37.660
if this were possible.


00:32:37.660 --> 00:32:39.420
So I'm glad Brett's still on this,


00:32:39.420 --> 00:32:41.060
and hopefully he keeps thinking about it.


00:32:41.060 --> 00:32:43.580
Brian, I still need to learn PathLab.


00:32:43.580 --> 00:32:44.700
- You got any ideas on how I can do that? - Really?


00:32:44.700 --> 00:32:46.460
Really? You're not using PathLab?


00:32:46.460 --> 00:32:48.940
I'm such a...


00:32:48.940 --> 00:32:51.500
I'm just stuck in the OS.path world.


00:32:51.500 --> 00:32:55.660
I just really need to get with the time. Help me out. Okay, so pathlib is I know


00:32:55.660 --> 00:32:59.660
Like oh


00:32:59.660 --> 00:33:07.900
So I have no offense to always stop path, but you know, no, I really love pathlib a lot and


00:33:07.900 --> 00:33:13.900
But there is I gotta tell you that the documentation for pathlib doesn't cut it as an introduction


00:33:13.900 --> 00:33:19.020
You can find what you're looking for, but if you know what you're looking for, but I agree with chris may


00:33:19.100 --> 00:33:22.460
So Chris May wrote a post called getting started with pathlib.


00:33:22.460 --> 00:33:30.220
I guess it's kind of he's got a little pdf field guide that you can download, but he has a little bit of a blog post introducing it.


00:33:30.220 --> 00:33:33.340
But I downloaded it's like nine or ten pages and


00:33:33.340 --> 00:33:37.020
It's actually a really good introduction to pathlib. So I really like it


00:33:37.020 --> 00:33:42.380
The big thing with os path versus pathlib is pathlib creates path objects


00:33:42.380 --> 00:33:45.820
So there's a class that represents a path that you have methods on


00:33:46.300 --> 00:33:49.580
And it makes it different for when you're dealing with this.


00:33:49.580 --> 00:33:52.300
With os.path, it's just strings.


00:33:52.300 --> 00:33:55.180
So it's manipulating strings that represent paths.


00:33:55.180 --> 00:33:57.180
So the object's different. I like it.


00:33:57.180 --> 00:33:59.820
Actually, I switched just for the ability to


00:33:59.820 --> 00:34:03.660
add buildup paths with just having the slash operator.


00:34:03.660 --> 00:34:06.140
Yeah, it's really interesting how they've overridden division.


00:34:06.140 --> 00:34:06.620
Yeah.


00:34:06.620 --> 00:34:09.580
But I think it's a good example of where this makes sense.


00:34:09.580 --> 00:34:12.620
It's a reasonable use case. It looks good. It's defensible.


00:34:12.620 --> 00:34:15.260
There are other cases where you're like, "Oh, did you really have to


00:34:15.260 --> 00:34:19.100
overload these operators, but they're fine. I think that's very valid.


00:34:19.100 --> 00:34:23.420
Yeah, and things like how do you find parts of a path?


00:34:23.420 --> 00:34:27.580
When you have to parse paths, that's where Pathlib really shines for me.


00:34:27.580 --> 00:34:32.220
So if you want to find the parent of something or the parent of the second level parent,


00:34:32.220 --> 00:34:35.660
there's ways to do that in Pathlib and in os.path,


00:34:35.660 --> 00:34:39.740
you're stuck with like trying to split things and stuff and it's gross.


00:34:39.740 --> 00:34:43.580
I mean, there are operations to do it, but it's very good to have this


00:34:44.540 --> 00:34:47.980
relative, I don't know, just all these operators like parent.


00:34:47.980 --> 00:34:51.780
And then one of the things that it took me a while to figure out was


00:34:51.780 --> 00:34:54.780
I was used to trying to find the absolute path of something.


00:34:54.780 --> 00:34:58.860
And in Pathlib, finding the absolute path is the resolve method.


00:34:58.860 --> 00:35:02.540
So you say resolve and it finds the absolute path for you.


00:35:02.540 --> 00:35:04.540
You can find the current working directory,


00:35:04.540 --> 00:35:07.340
you can go up and down folders, you can use globs,


00:35:07.340 --> 00:35:09.820
you can find parts of path names and stuff.


00:35:09.820 --> 00:35:12.220
And it's just a really comfortable thing.


00:35:12.220 --> 00:35:14.620
So I think you should give it a whirl.


00:35:14.620 --> 00:35:18.080
And it's not like it's going to change your life a lot.


00:35:18.080 --> 00:35:20.180
But the next time you come up with...


00:35:20.180 --> 00:35:23.240
The next time you're programming, you're like, "Okay, I got to figure out...


00:35:23.240 --> 00:35:25.840
I got to have a base directory and some other directory."


00:35:25.840 --> 00:35:28.980
I'll reach for pathlib instead of os.path.


00:35:28.980 --> 00:35:32.140
Yeah, I guess it has been there since 3.4, so I should get the times.


00:35:32.140 --> 00:35:34.880
Yeah, so I mean, now, before I could see the objection of, like,


00:35:34.880 --> 00:35:36.320
"Oh, you have to backport it."


00:35:36.320 --> 00:35:39.480
And also, I think what I like as well is a lot of integrations


00:35:39.540 --> 00:35:43.420
that automatically can perform checks where the path exists,


00:35:43.420 --> 00:35:44.180
stuff like that.


00:35:44.180 --> 00:35:48.020
Or for me as a library author, you're writing stuff for users


00:35:48.020 --> 00:35:49.260
and you want to give them feedback.


00:35:49.260 --> 00:35:52.820
And for instance, in a library like Click or Typer,


00:35:52.820 --> 00:35:56.220
which is the modern type hint version CLI interface,


00:35:56.220 --> 00:35:58.540
which was also built by my colleague Sebastian,


00:35:58.540 --> 00:36:01.620
you can just say, "Hey, this argument is a path.


00:36:01.620 --> 00:36:03.780
What you get back from the command line is a path.


00:36:03.780 --> 00:36:07.460
It will check that the path exists via pathlib."


00:36:07.460 --> 00:36:10.140
So it does like, you know, a whole bunch of magic there.


00:36:10.140 --> 00:36:11.700
Yeah, that is super cool.


00:36:11.700 --> 00:36:14.180
Yeah. Or you can say it's not, it can't be a directory.


00:36:14.180 --> 00:36:19.860
And then you write your CLI user passes in an invalid path, and you don't even have to do any error handling.


00:36:19.860 --> 00:36:24.180
It will automatically before it even runs your code say, Nope, that argument is bad.


00:36:24.180 --> 00:36:25.180
So that's pretty cool.


00:36:25.180 --> 00:36:25.740
That's awesome.


00:36:25.740 --> 00:36:30.140
And you don't have to care about Unix versus Mac or PC or something.


00:36:30.140 --> 00:36:37.260
Yeah, I mean, Windows, I mean, no offense to Windows, but it's always the handling paths and Windows is always the classic


00:36:37.280 --> 00:36:39.800
story also as a library author, where you just,


00:36:39.800 --> 00:36:41.760
probably supporting all operating systems,


00:36:41.760 --> 00:36:43.960
but like, well, Windows just does it a bit differently


00:36:43.960 --> 00:36:47.760
and you cannot assume that a slash means a slash.


00:36:47.760 --> 00:36:49.000
- Yeah, for sure.


00:36:49.000 --> 00:36:51.680
All right, well, the final item is yours, Ines,


00:36:51.680 --> 00:36:53.640
and it's definitely interesting.


00:36:53.640 --> 00:36:55.720
So if you're working in the machine learning,


00:36:55.720 --> 00:36:57.880
data science side of things,


00:36:57.880 --> 00:37:01.040
it might not be enough to just back up your algorithms


00:37:01.040 --> 00:37:01.880
and your code, right?


00:37:01.880 --> 00:37:03.160
- Yeah, you also have, yeah,


00:37:03.160 --> 00:37:05.160
machine learning is code and data.


00:37:05.160 --> 00:37:08.160
So yeah, so this is something we discovered a while ago


00:37:08.160 --> 00:37:10.500
and that we're now using internally.


00:37:10.500 --> 00:37:11.740
So we currently, as I mentioned before,


00:37:11.740 --> 00:37:13.880
we're working on version three of spaCy.


00:37:13.880 --> 00:37:15.880
And one of the big features is going to be


00:37:15.880 --> 00:37:18.040
a completely new optimized way


00:37:18.040 --> 00:37:19.840
for training your custom models,


00:37:19.840 --> 00:37:22.260
managing the whole end-to-end workflows


00:37:22.260 --> 00:37:25.340
from pre-processing to training to packaging,


00:37:25.340 --> 00:37:27.880
and also making the experiments more reproducible.


00:37:27.880 --> 00:37:29.060
You want to train a core model


00:37:29.060 --> 00:37:30.600
and then send it over to your colleague


00:37:30.600 --> 00:37:32.900
and your colleague should be able to run the same thing


00:37:32.900 --> 00:37:34.140
and get the same results.


00:37:34.140 --> 00:37:37.540
Sounds really basic, but it's pretty hard in general in machine learning.


00:37:37.540 --> 00:37:41.780
So, HelloSpacey stuff will also integrate with a tool called DVC,


00:37:41.780 --> 00:37:44.120
which is short for Data Version Control,


00:37:44.120 --> 00:37:47.420
and which we've started using internally for our models.


00:37:47.420 --> 00:37:51.220
And DVC is basically an open source tool for version control,


00:37:51.220 --> 00:37:54.060
specifically for machine learning and for data.


00:37:54.060 --> 00:37:58.440
So, you know, you can check your code into a Git repo as you're working on it,


00:37:58.440 --> 00:38:02.940
but you can't just check your datasets and models and artifacts into Git,


00:38:02.940 --> 00:38:07.340
or your model weights. So it's very, very difficult normally to keep track of changes


00:38:07.340 --> 00:38:11.900
and your files. Most people just end up with this directory of files somewhere,


00:38:11.900 --> 00:38:17.260
and it can be very frustrating. And so you could think of DVC as Git for data. And the command


00:38:17.260 --> 00:38:22.780
line usage is actually pretty similar. So you type Git in it and DVC in it to initialize it,


00:38:22.780 --> 00:38:28.460
and then you can do DVC add to start tracking your assets and add them. So it's like, I think,


00:38:28.460 --> 00:38:32.420
Yeah, if you're familiar with Git as abstract it can be at times,


00:38:32.420 --> 00:38:36.100
you will also find it easy to get into DPC.


00:38:36.100 --> 00:38:41.500
And it basically lets you track any assets like datasets, models, whatever,


00:38:41.500 --> 00:38:44.340
by adding meta files to your repository.


00:38:44.340 --> 00:38:46.780
So you always have the checksum in there,


00:38:46.780 --> 00:38:49.080
and you always have these checkpoints of the asset,


00:38:49.080 --> 00:38:52.680
even though you're not actually checking that file into your repo.


00:38:52.680 --> 00:38:54.380
And that means you can always go back,


00:38:54.380 --> 00:38:59.620
fetch whatever it was from your cache and rerun your experiments.


00:38:59.620 --> 00:39:02.180
And it also builds this really cool dependency graph.


00:39:02.180 --> 00:39:06.780
So you can really have these complex pipelines with different steps.


00:39:06.780 --> 00:39:12.580
And then you only have to rerun one step if some of the inputs to it have changed.


00:39:12.580 --> 00:39:15.780
So, you know, in machine learning, you'd often have a pipeline,


00:39:15.780 --> 00:39:19.420
like you start, you download your data, then you pre-process it,


00:39:19.420 --> 00:39:22.260
then you convert it to something, then you train,


00:39:22.260 --> 00:39:26.860
then you run an evaluation step and everything sort of depends on each other.


00:39:26.860 --> 00:39:28.360
And that can make things like really hard.


00:39:28.360 --> 00:39:30.900
And you never know, you usually have to run everything,


00:39:30.900 --> 00:39:34.160
make, you know, clean from scratch, because yeah,


00:39:34.160 --> 00:39:36.040
if something changes, your whole results change.


00:39:36.040 --> 00:39:39.300
So if you set up your pipelines with DVC,


00:39:39.300 --> 00:39:42.380
it can actually decide whether something needs to be rerun,


00:39:42.380 --> 00:39:45.580
or it can also know what needs to be rerun to reproduce


00:39:45.580 --> 00:39:47.180
exactly what you're trying to do.


00:39:47.180 --> 00:39:48.220
So that's pretty cool.


00:39:48.220 --> 00:39:51.720
Yeah, that could save you a ton of time and money if you're doing it in the cloud.


00:39:51.720 --> 00:39:56.600
Yes, exactly. Yeah. And you know, you can share it with other people. It's like, it's, it's, I think


00:39:56.600 --> 00:40:01.480
it definitely solves a problem that's very real. And yeah, the people making DVC, they've also


00:40:01.480 --> 00:40:05.080
recently released a new tool that I have not personally checked out yet. But it looks very


00:40:05.080 --> 00:40:09.720
interesting. It's called CML, which is short for continuous machine learning. And that's really


00:40:09.720 --> 00:40:14.120
more of the CI, which kind of is logically the next step, right? You manage everything in your


00:40:14.120 --> 00:40:20.440
repo. And then you obviously want to run automated tests and continuous integration. So the previous


00:40:20.440 --> 00:40:21.440
And it just looked really cool.


00:40:21.440 --> 00:40:26.360
Like it showed kind of a GitHub action where you can submit a PR with like some changes


00:40:26.360 --> 00:40:28.440
to your code and your data.


00:40:28.440 --> 00:40:33.280
And then you have the bot commenting on it and it shows like accuracy results and a little


00:40:33.280 --> 00:40:34.560
graph and how stuff changes.


00:40:34.560 --> 00:40:39.760
So it's really like these code coverage bots that you've probably seen where like you change


00:40:39.760 --> 00:40:44.320
some lines and then it tells you, oh, coverage has gone up or down and you know, the new


00:40:44.320 --> 00:40:46.120
view of your code.


00:40:46.120 --> 00:40:47.440
So that's what it looks like.


00:40:47.440 --> 00:40:49.320
So I think, yeah, I'm really excited about this.


00:40:49.320 --> 00:40:50.800
- It definitely, it solves a problem.


00:40:50.800 --> 00:40:53.040
It's already been solving a problem for us and yeah.


00:40:53.040 --> 00:40:54.520
- How does it store the large files?


00:40:54.520 --> 00:40:55.520
I know it has this cache.


00:40:55.520 --> 00:40:56.860
Is that a thing that you host?


00:40:56.860 --> 00:40:59.640
Does it have a hosted thing that's kind of like GitHub?


00:40:59.640 --> 00:41:00.480
Or where's the--


00:41:00.480 --> 00:41:01.320
- I'm not sure if you could,


00:41:01.320 --> 00:41:02.480
you probably connect it to some cloud,


00:41:02.480 --> 00:41:04.040
but like normally you have that locally.


00:41:04.040 --> 00:41:05.000
It also has a cool thing


00:41:05.000 --> 00:41:07.960
where you can actually download files via the tool.


00:41:07.960 --> 00:41:09.960
And then depending on where you're fetching it from,


00:41:09.960 --> 00:41:13.680
if it's a Google storage bucket or S3 bucket or something,


00:41:13.680 --> 00:41:16.240
you can actually also tell if the file has changed


00:41:16.240 --> 00:41:17.920
and whether it needs to be redownloaded.


00:41:17.920 --> 00:41:20.720
And so, for example, internally, what we're doing is we're using,


00:41:20.720 --> 00:41:24.680
we're mounting a Google storage, Google Cloud Storage bucket,


00:41:24.680 --> 00:41:27.440
or however they call it, locally as like, you know,


00:41:27.440 --> 00:41:30.440
so it's like kind of a drive you have access to locally,


00:41:30.440 --> 00:41:33.400
and then you can just sort of type GS, blah, blah, blah,


00:41:33.400 --> 00:41:36.960
and then the path and really work with it like a local file system.


00:41:36.960 --> 00:41:38.040
And that's pretty nice.


00:41:38.040 --> 00:41:41.040
So you can, you know, you can work with private assets,


00:41:41.040 --> 00:41:43.880
because the thing is, a lot of toy examples assume that,


00:41:43.880 --> 00:41:45.720
oh, you just download a public data set,


00:41:45.720 --> 00:41:47.840
and then you train your model, and then you upload it somewhere.


00:41:47.840 --> 00:41:50.340
But that's not very realistic, because most of the time,


00:41:50.340 --> 00:41:53.580
the data you have can't just go in the cloud publicly.


00:41:53.580 --> 00:41:56.720
So, but yeah, I think I don't even know exactly how it works in detail,


00:41:56.720 --> 00:42:00.380
but it can basically fetch, I think, from the headers or something,


00:42:00.380 --> 00:42:03.780
it can tell whether the file you're downloading has changed


00:42:03.780 --> 00:42:05.780
and whether there's something new.


00:42:05.780 --> 00:42:08.080
With a normal version control, one of the reasons we use it


00:42:08.080 --> 00:42:09.840
is to try to find what's different.


00:42:09.840 --> 00:42:12.280
Do you do diffs on data?


00:42:12.280 --> 00:42:14.020
I don't know, maybe.


00:42:14.020 --> 00:42:16.740
I mean, I'm not sure if there's...


00:42:16.740 --> 00:42:21.500
I think the main diff is more like around the results that you get,


00:42:21.500 --> 00:42:25.140
because I mean, diffing large data sets, diffing weights, you kind of can't.


00:42:25.140 --> 00:42:27.820
That's really where we have the other problem,


00:42:27.820 --> 00:42:30.780
where you need to run the model to find out what it does,


00:42:30.780 --> 00:42:34.100
and then you're diffing accuracies rather than weights.


00:42:34.100 --> 00:42:36.300
I don't know if it does actual diffing of the data sets,


00:42:36.300 --> 00:42:38.740
but often the thing that changes is really the models.


00:42:38.740 --> 00:42:43.820
Like you have your raw data, and then you change things about your code.


00:42:43.820 --> 00:42:48.860
Yeah, and something changes and you want to keep track of what it is or how it manifests.


00:42:48.860 --> 00:42:50.940
Yeah, it's really cool to see them working on this.


00:42:50.940 --> 00:42:55.660
Yeah, and also we'll be in spaCy 3. We'll hopefully have a pretty neat integration


00:42:55.660 --> 00:42:59.180
where, you know, if you want, it's not like mandatory, but if you say, "Hey, that's cool.


00:42:59.180 --> 00:43:03.740
That's how I want to manage my assets." You can just run that in your spaCy project,


00:43:03.740 --> 00:43:07.900
and then it just automatically tracks everything. And, you know, you can take that into


00:43:07.900 --> 00:43:13.420
Git and share it and other people can download it. So that's, yeah, I'm pretty excited about that.


00:43:13.420 --> 00:43:15.420
It works pretty well so far.


00:43:15.420 --> 00:43:20.060
Everything you can do to make it a little easier to work with spaCy and just make it reproducible.


00:43:20.060 --> 00:43:22.060
Yeah, and it's just that things are hard.


00:43:22.060 --> 00:43:25.660
I'm not a fan of these, "Oh, one click, everything just magically works."


00:43:25.660 --> 00:43:30.460
It looks nice and it's a nice demo, but once you actually get down to the real work,


00:43:30.460 --> 00:43:33.980
things need to be a bit modular, things need to be customizable.


00:43:33.980 --> 00:43:37.740
Otherwise, you're always hitting edge cases or you have these leaky abstractions.


00:43:37.740 --> 00:43:41.640
So, yeah, I think things should be easy to use,


00:43:41.640 --> 00:43:45.740
but you can't just magically cover everything by just providing one button.


00:43:45.740 --> 00:43:47.040
That's just not going to work.


00:43:47.040 --> 00:43:49.340
Yeah, because when it doesn't work, it's not good anymore.


00:43:49.340 --> 00:43:50.640
Yeah, exactly.


00:43:50.640 --> 00:43:55.740
Yeah. Alright, well, that's our six items that we go in depth into.


00:43:55.740 --> 00:43:58.540
But at the end, we always just throw out a couple of really quick things


00:43:58.540 --> 00:44:01.740
that maybe we didn't have time to fit into the main section.


00:44:01.740 --> 00:44:05.440
And I want to talk about two things that are pretty exciting.


00:44:05.440 --> 00:44:09.880
One is, if you care about podcasts as a


00:44:09.880 --> 00:44:13.180
catalog of a whole bunch of things, I don't know how many podcasts there are.


00:44:13.180 --> 00:44:15.440
There's probably over a million podcasts these days.


00:44:15.440 --> 00:44:18.180
One of our listeners, Anton Zyanov,


00:44:18.180 --> 00:44:20.440
wrote a cool Python package


00:44:20.440 --> 00:44:23.580
that will let you search the iTunes directory and


00:44:23.580 --> 00:44:29.440
query it. It's basically a Python API into iTunes podcasting directory.


00:44:29.440 --> 00:44:32.980
You know, some people think that you've got to be part of the


00:44:32.980 --> 00:44:39.680
Apple ecosystem don't care about iTunes, but really that's just the biggest like directory kind of Yahoo circa 1995


00:44:39.680 --> 00:44:45.960
Style of listing of podcast. So if you care about digging in and researching podcasts, check that out. That's pretty cool


00:44:45.960 --> 00:44:52.360
And then yeah, and then I've also I'm such a big fan of f-strings. How about you - yes. Yes


00:44:52.360 --> 00:44:55.080
F


00:44:55.080 --> 00:44:59.360
I'm finally working in like Python 3 only I remember I think last time I was on the podcast


00:44:59.360 --> 00:45:04.400
I was basically I was saying how like, oh, all these modern things. They're so nice. I wish I could use them more but


00:45:04.400 --> 00:45:12.640
We're still supporting python2 but like no everything I write now 3.6. Yes, and I've talked previously about a tool called flint


00:45:12.640 --> 00:45:20.660
flynt which lets you run against an old code base and convert all the various python2 and 3 styles of formatting


00:45:20.660 --> 00:45:24.880
Magically into python3. I think that was actually really nice the episode I was


00:45:24.880 --> 00:45:28.560
Yeah, you might have been right like I wish I could run this right? Yeah


00:45:28.880 --> 00:45:31.520
And I ran that against like 20,000 lines of Python.


00:45:31.520 --> 00:45:33.160
I found like just a couple errors,


00:45:33.160 --> 00:45:34.480
reported them, they got fixed.


00:45:34.480 --> 00:45:35.480
So that's nice.


00:45:35.480 --> 00:45:37.160
But the thing that's bugged me


00:45:37.160 --> 00:45:38.520
endlessly about fstrings


00:45:38.520 --> 00:45:40.360
is I'll be halfway through writing the string


00:45:40.360 --> 00:45:42.480
and I'm like, oh yeah, I want to put data here.


00:45:42.480 --> 00:45:44.120
So I got to go back to the front of the string,


00:45:44.120 --> 00:45:46.120
not necessarily back to the front of the line,


00:45:46.120 --> 00:45:47.520
but maybe back to like


00:45:47.520 --> 00:45:49.240
the string is being passed to a function.


00:45:49.240 --> 00:45:51.120
So I go back to the first quote,


00:45:51.120 --> 00:45:53.080
put the f, go back forward,


00:45:53.080 --> 00:45:54.480
and then start typing out


00:45:54.480 --> 00:45:55.880
the thing I actually wanted, right?


00:45:55.880 --> 00:45:57.440
Or maybe I'll fstring something


00:45:57.440 --> 00:45:59.680
and when I really, I'm not gonna put data, right?


00:45:59.680 --> 00:46:01.040
So it's like you're halfway through


00:46:01.040 --> 00:46:02.920
and you want it to become an F string.


00:46:02.920 --> 00:46:04.880
Well, PyCharm is coming with a new feature


00:46:04.880 --> 00:46:07.680
where if you start writing a regular string


00:46:07.680 --> 00:46:09.120
and pretend like it's an F string,


00:46:09.120 --> 00:46:11.640
it'll automatically upgrade it to f-strings.


00:46:11.640 --> 00:46:13.260
- Yes, thank you. - Halfway through.


00:46:13.260 --> 00:46:14.200
Yes, without leaving.


00:46:14.200 --> 00:46:15.680
So you just say curly variable.


00:46:15.680 --> 00:46:17.160
It's like, oh, okay, that means that's F string


00:46:17.160 --> 00:46:18.760
and the F appears at the front.


00:46:18.760 --> 00:46:19.680
Yes. - Oh, nice.


00:46:19.680 --> 00:46:21.120
- So that is pretty awesome.


00:46:21.120 --> 00:46:23.240
Anyway, those are my two quick items.


00:46:23.240 --> 00:46:24.960
Ines, I'm also excited about the one you got here.


00:46:24.960 --> 00:46:25.780
- Yeah. - This is awesome.


00:46:25.780 --> 00:46:29.020
- Yeah, I had one which is something coming to 3.9


00:46:29.020 --> 00:46:32.300
or in 3.9, which is PEP 585.


00:46:32.300 --> 00:46:35.700
And you can use, when you use type annotations,


00:46:35.700 --> 00:46:39.200
you can now use the built-in types like list


00:46:39.200 --> 00:46:40.780
and dict as generic types.


00:46:40.780 --> 00:46:44.860
So that means no more from typing import list


00:46:44.860 --> 00:46:46.460
with a capital L.


00:46:46.460 --> 00:46:47.280
- Yes.


00:46:47.280 --> 00:46:48.120
(laughing)


00:46:48.120 --> 00:46:48.940
- Yes.


00:46:48.940 --> 00:46:50.900
So you just literally, I mean, when I first saw it,


00:46:50.900 --> 00:46:53.900
I'm like, that looks strange, but like, yes.


00:46:53.900 --> 00:46:55.100
I'm so excited about this.


00:46:55.100 --> 00:46:58.740
It'd probably be years until I can just like use it all across my codebases because...


00:46:58.740 --> 00:46:59.740
True, true.


00:46:59.740 --> 00:47:01.100
Yeah, but like, yay.


00:47:01.100 --> 00:47:02.100
That's in 3.9?


00:47:02.100 --> 00:47:03.100
Yeah.


00:47:03.100 --> 00:47:04.100
Yeah, it's in 3.9.


00:47:04.100 --> 00:47:06.220
I'm already using 3.9 and I didn't know this.


00:47:06.220 --> 00:47:07.220
You can do this.


00:47:07.220 --> 00:47:08.220
Yeah.


00:47:08.220 --> 00:47:12.740
Yeah, and Guido is one of the guys on the PEP making this happen.


00:47:12.740 --> 00:47:14.220
Like I said, he's really into typing.


00:47:14.220 --> 00:47:15.220
Oh, that's great.


00:47:15.220 --> 00:47:18.420
So this is really cool because it was super annoying to say, "Oh, you have this new import


00:47:18.420 --> 00:47:20.860
just because you want to use type annotations on a collection."


00:47:20.860 --> 00:47:21.860
Right?


00:47:21.860 --> 00:47:22.860
Now you don't have to.


00:47:22.860 --> 00:47:24.860
There's actually a bunch of the collection stuff


00:47:24.860 --> 00:47:28.860
and iterators and whatnot, like the collections module,


00:47:28.860 --> 00:47:30.860
like that, a bunch of stuff in there.


00:47:30.860 --> 00:47:32.860
- That's pretty neat. - It's really nice.


00:47:32.860 --> 00:47:35.860
And they're compatible, like, lowercase list of str


00:47:35.860 --> 00:47:38.860
is the same as capital list of str, I believe.


00:47:38.860 --> 00:47:40.860
All right, Brian, what you got?


00:47:40.860 --> 00:47:42.860
- Oh, I just wanted to-- I'll drop a link in the show notes.


00:47:42.860 --> 00:47:46.860
Testing code 120 is where I interviewed Sebastian Ramirez


00:47:46.860 --> 00:47:48.860
from Explosion, also,


00:47:48.860 --> 00:47:51.860
and talking about FastAPI and Typer


00:47:51.860 --> 00:47:55.060
because I'm kind of in love with both of those. They're really cool.


00:47:55.060 --> 00:47:56.260
Yeah, absolutely.


00:47:56.260 --> 00:47:59.660
All right. Well, that's a cool one. Definitely going to check that out.


00:47:59.660 --> 00:48:02.260
And you can find out why he has the cool mustache.


00:48:02.260 --> 00:48:04.260
[laughter]


00:48:04.260 --> 00:48:05.260
That's right.


00:48:05.260 --> 00:48:07.760
All right. So we always end the show with a joke.


00:48:07.760 --> 00:48:10.760
And I thought we could do two jokes today.


00:48:10.760 --> 00:48:13.460
So I think, Enos, do you want to talk about this first one?


00:48:13.460 --> 00:48:16.460
Oh, yeah. I mean, I'm not even sure it counts as a joke per se, but like...


00:48:16.460 --> 00:48:19.660
It's more of a humorous situation, I guess, right?


00:48:19.660 --> 00:48:26.560
Yeah, it ties in. Well, it's Sebastian again, like he had this very viral tweet the other


00:48:26.560 --> 00:48:31.220
day, where he posted about some experience. I could just read it out because I think it


00:48:31.220 --> 00:48:36.020
needs to kind of stand on its own. So he's writes, I saw a job post the other day, it


00:48:36.020 --> 00:48:40.740
required four plus years of experience in FastAPI. I couldn't apply as I only have


00:48:40.740 --> 00:48:45.900
1.5 plus years of experience since I created that thing. And then he says, maybe it's time


00:48:45.900 --> 00:48:52.660
to reevaluate that years of experience equals skill level. So this was like, it resonated


00:48:52.660 --> 00:48:56.580
with people so much. I was actually surprised to see, like, everyone was like, oh, yeah,


00:48:56.580 --> 00:49:01.700
HR, like, apparently, this seems to be this huge, huge issue, obviously, that like, well,


00:49:01.700 --> 00:49:06.540
most job ads not written by the people who actually worked with the technologies and


00:49:06.540 --> 00:49:07.540
where you have, yeah, you.


00:49:07.540 --> 00:49:12.140
Actually, yeah, this is awesome. And this tweet actually just got covered on DTNS, the


00:49:12.140 --> 00:49:15.440
the Daily News Tech Show, Daily Tech News Show, I guess it is.


00:49:15.440 --> 00:49:18.840
Alongside another posting that said you needed


00:49:18.840 --> 00:49:21.640
eight years of Kubernetes experience for another job.


00:49:21.640 --> 00:49:24.440
But of course, Kubernetes has only been around for four years.


00:49:24.440 --> 00:49:29.940
Yeah, when you say this went viral, it had 46,000 retweets and 174,000 likes.


00:49:29.940 --> 00:49:33.240
That's got some traction. I feel like this might be a problem.


00:49:33.240 --> 00:49:37.240
Yeah, I was surprised that so many people were like, "Yeah, that's a big deal."


00:49:37.240 --> 00:49:42.440
It's like, I mean, it is true, like, kind of tech hiring sort of seems to be broken.


00:49:42.440 --> 00:49:50.200
And it's also, it's like, it's a bit different in my case, I guess, but like, I don't qualify for most roles using the tech that I write.


00:49:50.200 --> 00:49:56.640
And in some cases, that's justified, because I'm not a data scientist, just because I write developer tools for data scientists doesn't mean I can do the job.


00:49:56.640 --> 00:50:03.480
But in other cases, I'm like, there's kind of a ridiculous amount of arbitrary stuff you're asking for in this job ad, maybe that's needed, maybe not.


00:50:03.480 --> 00:50:07.620
but it centers around a piece of software that I happen to have written,


00:50:07.620 --> 00:50:11.120
and I do not qualify for your job at all.


00:50:11.120 --> 00:50:12.180
That's insane.


00:50:12.180 --> 00:50:14.180
The last time I wrote a job description,


00:50:14.180 --> 00:50:18.780
I intentionally left off the college degree requirement


00:50:18.780 --> 00:50:22.180
because all of the other requirements I was listing in there,


00:50:22.180 --> 00:50:24.740
either they had it from college plus experience,


00:50:24.740 --> 00:50:28.020
or they had it just from experience, so I was fine with that.


00:50:28.020 --> 00:50:30.040
By the time it actually went live,


00:50:30.040 --> 00:50:33.880
somebody in HR had added a college degree requirement to it.


00:50:33.880 --> 00:50:36.920
I just couldn't get away with not listing that, I guess.


00:50:36.920 --> 00:50:37.720
Yeah, but that's the problem.


00:50:37.720 --> 00:50:39.880
Master's degree in space is preferred.


00:50:39.880 --> 00:50:40.760
In space is preferred.


00:50:40.760 --> 00:50:43.160
Yeah, but I guess another problem is like, well, look, if you ask,


00:50:43.160 --> 00:50:47.160
if HR writes these job ads with these bullshit requirements,


00:50:47.160 --> 00:50:49.240
then, well, who applies?


00:50:49.240 --> 00:50:51.480
Like, it's either people who are like, yeah, whatever,


00:50:51.480 --> 00:50:52.680
or people who are full of shit.


00:50:52.680 --> 00:50:54.920
And then that's the sort of culture you're fostering.


00:50:54.920 --> 00:50:56.840
And it might not even be the engineer's fault


00:50:56.840 --> 00:50:58.840
who wrote a very honest job description,


00:50:58.840 --> 00:51:01.000
But like, yep, who applies to that?


00:51:01.000 --> 00:51:04.140
You're going to make me lie about my FastAPI experience.


00:51:04.140 --> 00:51:05.940
Yeah, people just apply to anything.


00:51:05.940 --> 00:51:08.400
Like, "Yep, I have 10 years experience in everything. Great."


00:51:08.400 --> 00:51:10.640
And they're like, "Perfect. That's what we're looking for. You're hired."


00:51:10.640 --> 00:51:14.040
And then you wonder, "Why is our company culture so terrible?"


00:51:14.040 --> 00:51:18.200
Well, I actually did have somebody apply to a job


00:51:18.200 --> 00:51:23.240
and say they have multiple years of experience in any new language coming up.


00:51:23.240 --> 00:51:27.400
Nice.


00:51:27.400 --> 00:51:29.560
All right, guys, well, it looks like we're just about out of time.


00:51:29.560 --> 00:51:32.040
Let me give you one more joke for it.


00:51:32.040 --> 00:51:35.400
Brian, will you describe this picture and then I'll read what it says?


00:51:35.400 --> 00:51:39.480
There's a poorly drawn horse, I think, zebra.


00:51:39.480 --> 00:51:43.880
Horse that has white on the back end and black on the front end.


00:51:43.880 --> 00:51:46.280
And the text says, "I defragged my zebra."


00:51:46.280 --> 00:51:48.840
I don't even know if people defrag drives anymore.


00:51:48.840 --> 00:51:51.800
So this is only going to resonate with the folks that have been around for a while.


00:51:51.800 --> 00:51:54.040
I saw that there was this great video I came across on YouTube


00:51:54.040 --> 00:51:56.760
where you can actually watch like a live defrag session.


00:51:56.760 --> 00:52:01.160
I don't know, Windows 95. And it's like, I don't know, it takes a few hours. And you know, you can


00:52:01.160 --> 00:52:04.680
kind of bring back that nostalgia and just put it on your TV and just sit there and you're like,


00:52:04.680 --> 00:52:10.200
yeah, oh, that's, it's like the aquarium you would put on your TV. Like before tech,


00:52:10.200 --> 00:52:16.680
follow the show on Twitter via at Python bites. That's Python bites as in b y t e s, and get the


00:52:16.680 --> 00:52:21.800
full show notes at pythonbytes.fm. If you have a news item you want featured, just visit Python


00:52:21.800 --> 00:52:23.600
ThumbBytes.fm and send it our way.


00:52:23.600 --> 00:52:26.480
We're always on the lookout for sharing something cool.


00:52:26.480 --> 00:52:28.320
On behalf of myself and Brian Auchin,


00:52:28.320 --> 00:52:29.640
this is Michael Kennedy.


00:52:29.640 --> 00:52:31.640
Thank you for listening and sharing this podcast


00:52:31.640 --> 00:52:33.280
with your friends and colleagues.

