WEBVTT

00:00:00.001 --> 00:00:04.060
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to

00:00:04.060 --> 00:00:10.860
your earbuds. This is episode 179, recorded April 21st, 2020. I'm Michael Kennedy.

00:00:10.860 --> 00:00:11.820
And I'm Brian Okken.

00:00:11.820 --> 00:00:17.340
And Brian, I'm super honored to have Guido von Rossum on the show. Guido, welcome to Python Bytes.

00:00:17.340 --> 00:00:18.840
Hello, glad to be here.

00:00:18.840 --> 00:00:23.020
Yeah, it's really great to have you here. It's going to be wonderful to hear your opinion,

00:00:23.020 --> 00:00:26.820
your perspective on some of these things that we're sharing this week. So welcome to the show.

00:00:26.820 --> 00:00:30.680
All right. And this episode is brought to you by Datadog. Check them out at pythonbytes.fm

00:00:30.680 --> 00:00:34.580
slash Datadog. More on that later. Brian, what do you got? What's up first?

00:00:34.580 --> 00:00:38.800
Well, I've been thinking a lot about community lately, actually. And one of the things that

00:00:38.800 --> 00:00:44.660
came out recently, this was a little bit ago, but it's still fairly new, is the Django project

00:00:44.660 --> 00:00:49.600
announced a new governance model. It's been going on. I mean, I think they've been working on it for

00:00:49.600 --> 00:00:56.080
a couple of years since at least 2018. Some of the specifics are interesting. They had like a core

00:00:56.080 --> 00:01:01.700
team that they dissolved the core team and they mainly kind of have a new role called a merger

00:01:01.700 --> 00:01:07.840
person, which they have commit access, but they only merge pull requests. So most of the changes

00:01:07.840 --> 00:01:14.380
could happen in the pull requests and the discussion that happens there. There is a technical board also

00:01:14.380 --> 00:01:20.980
that was kept to kind of make some technical decisions if it's necessary, but apparently it hasn't

00:01:20.980 --> 00:01:26.220
been necessary for a while. I think it's interesting that they switched the governance model midstream.

00:01:26.220 --> 00:01:32.580
And then also the rationale around it, I think is interesting. And the rationale is around trying

00:01:32.580 --> 00:01:38.440
to get more people contributing to it. So they had like their core team and that hadn't really changed

00:01:38.440 --> 00:01:44.040
for a long time. And people that were set up as core people really weren't contributing much anymore.

00:01:44.600 --> 00:01:50.340
Anyway, I just thought that was interesting that they, the reason around changing the governance was

00:01:50.340 --> 00:01:52.620
around trying to get new people in.

00:01:52.620 --> 00:01:57.020
Yeah, I think that's a great idea because, you know, Django has been around for a long time and it's a

00:01:57.020 --> 00:02:01.680
fairly stable project. So I think it's kind of hard to jump in. I mean, it's a little bit like Python

00:02:01.680 --> 00:02:02.540
itself, Weido.

00:02:02.840 --> 00:02:09.820
Right. I'm thinking that sort of maybe five years in the future, Python could consider a similar move

00:02:09.820 --> 00:02:15.580
or maybe we'll know that this was not the right move by then from Django's experience. And of course,

00:02:15.580 --> 00:02:22.540
the situation for the two projects is somewhat different, but we definitely also feel the pain

00:02:22.540 --> 00:02:30.900
of sort of not getting enough new contributors. But we only fairly recently, like early last year,

00:02:30.900 --> 00:02:36.960
we changed our governance structure completely. So it's a little early to start considering changing

00:02:36.960 --> 00:02:37.880
it again, probably.

00:02:37.880 --> 00:02:42.820
Right. Of course, we're just starting to see the outcome of the decisions and the releases that

00:02:42.820 --> 00:02:44.220
are actually going through that model, right?

00:02:44.220 --> 00:02:49.780
Yeah. I've been working with the steering council model for say 16 months now.

00:02:49.780 --> 00:02:52.800
Yeah, I guess so. 3.8 definitely came out under that model.

00:02:52.800 --> 00:02:53.540
Yeah.

00:02:53.540 --> 00:02:57.740
The thing that Python did, I think is kind of interesting. And I don't know if you started it,

00:02:57.740 --> 00:03:04.360
but the notion of having more core mentors to try to mentor new core developers, I think that's an

00:03:04.360 --> 00:03:10.020
interesting thing that you can't really like make people be mentors, but that's an interesting way to

00:03:10.020 --> 00:03:11.440
get more core developers on.

00:03:11.440 --> 00:03:17.520
We have a few people who are very active as mentors, in addition to being active as core devs.

00:03:17.680 --> 00:03:19.680
And it really does make a difference.

00:03:19.680 --> 00:03:20.560
Yeah.

00:03:20.560 --> 00:03:20.860
Yeah.

00:03:20.860 --> 00:03:27.060
We don't have enough mentors to mentor everyone who wants to become a core dev.

00:03:27.060 --> 00:03:31.940
Yeah. Yeah. So I think that's really great. I mean, it's one thing to write web apps in Django

00:03:31.940 --> 00:03:38.400
or to write Python code. It's an entirely different thing to write Django or write Python, right?

00:03:38.400 --> 00:03:43.440
It's a very different skill set. And so I think that mentor model is really a great bridge.

00:03:43.580 --> 00:03:48.900
Yeah. So speaking of things, I think are going to be really helpful, but in a much simpler way,

00:03:48.900 --> 00:03:55.020
this is sort of a data science topic for everyone out there. And one of the problems in data science

00:03:55.020 --> 00:04:01.860
is you can end up with very large data sets, complicated data, but every now and then there

00:04:01.860 --> 00:04:07.400
might be a none where you expected an integer, or there might be a empty string where you expected

00:04:07.400 --> 00:04:13.720
a date or something like that. And understanding how that data is for how completed it is, where

00:04:13.720 --> 00:04:19.820
is it more incomplete than less complete, right? Or less, more or less, and so on. So there's this

00:04:19.820 --> 00:04:25.080
cool project called missing no, which I think is missing number, right? Shortened. And the idea is

00:04:25.080 --> 00:04:31.280
it's a missing data visualization module for Python. And you too can see the picture in the show notes and

00:04:31.280 --> 00:04:37.060
folks who listen to this, they can go back and see it in the show notes as well. But it's a really cool

00:04:37.060 --> 00:04:41.940
and simple little library, but it's not just show me a quick graph. It actually does some pretty

00:04:41.940 --> 00:04:47.760
powerful analysis. So what you can do is if you've got like some pandas data, you can just go to it and

00:04:47.760 --> 00:04:53.640
say msno.matrix and give it a sample of your data. And it gives you these really cool graphs of like

00:04:53.640 --> 00:04:59.540
vertical, either black or white bars or bars that are like kind of zebra stripe, depending on whether or not

00:04:59.540 --> 00:05:05.540
there's missing data. It shows you which parts, which columns are more complete or incomplete.

00:05:05.540 --> 00:05:12.500
And even as a little graph on the side, that tells you the likelihood or the correlation of a row being

00:05:12.500 --> 00:05:17.380
incomplete, right? Like you might have a missing address on one line, but in another one has a missing

00:05:17.380 --> 00:05:21.540
phone number, or it could be more likely that those are both missing at the same time. There's like a

00:05:21.540 --> 00:05:23.960
little graph to visualize that kind of stuff. What do you guys think?

00:05:24.100 --> 00:05:32.580
I think it's very cool. I'm not a data anything person myself. So yeah, to indicate how much I am

00:05:32.580 --> 00:05:39.060
not in the target audience for this module. The whole time I read your modules, I had the grouping

00:05:39.060 --> 00:05:47.280
wrong. I thought it was the missing data visualization module. And I thought, well, that's kind of cool that

00:05:47.280 --> 00:05:53.200
that they're sort of, they say there's something missing. And this clearly is the one that now it's

00:05:53.200 --> 00:05:59.600
turned up, but it's actually visualizing missing data, which actually I understand what that is. I've seen

00:05:59.600 --> 00:06:07.280
a spreadsheet or two, and I can actually even understand the little example chart that you pasted into

00:06:07.280 --> 00:06:12.240
through the notes without understanding anything else around it.

00:06:12.240 --> 00:06:16.320
Yeah, it's so wonderful because that's why I actually think I like this and I chose it as you

00:06:16.320 --> 00:06:20.240
could just look at that picture and go, oh, I basically get a sense for what this data is like.

00:06:20.240 --> 00:06:25.600
It's complete. It's not complete. It's mostly incomplete on this column or whatever. And yeah,

00:06:25.600 --> 00:06:31.920
it's really nice. And I suspect you could, if you had data, say, in like a database or a file or

00:06:31.920 --> 00:06:35.360
something, you could probably just read that into a pandas data frame and then throw it out here and

00:06:35.360 --> 00:06:39.360
visualize like database missing data or file missing data or whatever. But it's really nice.

00:06:39.360 --> 00:06:43.680
Yeah. For large data sets, one of the things you got to do is to decide when you're cleaning it up,

00:06:43.680 --> 00:06:48.400
what to do with the missing data. And there's, I mean, there's some nones or whatever. There's some

00:06:48.400 --> 00:06:56.080
strategies to either fill it in with interleaved data or something or, or just throw those rows

00:06:56.080 --> 00:07:00.720
completely away. But you, I mean, you don't really know how much data you're throwing away if you,

00:07:00.720 --> 00:07:04.480
without visualizing it. So this is pretty cool. I think this is great.

00:07:04.480 --> 00:07:08.800
Yeah. And it has other visualizations as well. It has heat maps, which are like correlations,

00:07:08.800 --> 00:07:13.200
you know, so like address and phone number correlated kind of things I was talking about.

00:07:13.200 --> 00:07:19.200
It has bar charts and the most interesting or unique visualization is the dendogram,

00:07:19.200 --> 00:07:23.760
which I had never heard of, but this is the hierarchical clustering algorithm from SciPy actually.

00:07:23.760 --> 00:07:30.320
And it creates this kind of like hierarchical tree of relationships of missing data.

00:07:30.320 --> 00:07:34.160
There's just, if you are worried about like cleaning up data or stuff like that,

00:07:34.160 --> 00:07:38.160
or visualizing how good your data is, you could throw it at this real quick and get some great

00:07:38.160 --> 00:07:38.480
answers.

00:07:38.480 --> 00:07:39.440
Yeah, that's cool.

00:07:39.440 --> 00:07:44.160
Yeah. All right. Well, Guido, you have been busy with the language summit recently, right?

00:07:44.160 --> 00:07:45.040
What's the news there?

00:07:45.040 --> 00:07:52.720
Yes. Well, normally the language summit basically is in-person meeting where about 50 people who are

00:07:52.720 --> 00:07:59.360
mostly, but not exclusively core devs get together a day or two before the actual Python conference.

00:07:59.360 --> 00:08:01.760
Since the conference was canceled.

00:08:01.760 --> 00:08:03.840
This would have been in Pittsburgh, right?

00:08:03.840 --> 00:08:06.480
It would have been in Pittsburgh this year, right?

00:08:06.480 --> 00:08:10.640
Obviously the conference was canceled and the language summit was two.

00:08:10.640 --> 00:08:16.000
And then the two organizers thought, well, okay, this sounds like the kind of meeting that we can

00:08:16.000 --> 00:08:21.760
actually try to do on Zoom. You can't have a whole conference on Zoom, but you can probably have a

00:08:21.760 --> 00:08:28.960
meeting with 50 people on Zoom. And they tweaked the format a bit so that, I mean, you can't be on

00:08:28.960 --> 00:08:36.240
Zoom for an entire day. I find Zoom incredibly intense. And after an hour of Zooming,

00:08:36.240 --> 00:08:38.960
I'm usually ready for a break.

00:08:38.960 --> 00:08:41.760
Yeah. All the virtual stuff takes a lot more attention. Yeah.

00:08:41.760 --> 00:08:50.560
Yeah. User interface sucks. Privacy probably sucks, but it clearly serves its purpose. So we had it

00:08:50.560 --> 00:08:56.480
spread over two different days. And then in addition, because nobody was traveling to Pittsburgh,

00:08:56.480 --> 00:09:03.600
we spread it out in time. One day it was really early for me so that we could also have participants from

00:09:03.600 --> 00:09:10.480
Europe. And one day it was really late for me so that we could have some people from Australia join us.

00:09:10.480 --> 00:09:18.320
One of the organizers lives in Poland and he was there till the end on both days. So I didn't, I don't know.

00:09:18.320 --> 00:09:21.040
That's commitment.

00:09:21.040 --> 00:09:27.600
So as usual, the format wasn't actually all that different. It's typically like half hour slots for

00:09:27.600 --> 00:09:36.800
various topics that are important to either get information to core devs and usually also get

00:09:36.800 --> 00:09:43.040
feedback from core devs. And we pretty much stuck to that format. The one big thing that you miss,

00:09:43.040 --> 00:09:49.040
of course, is all the whispering to the guy who was sitting next to you or during the break,

00:09:49.040 --> 00:09:53.760
quickly grabbing three other people and having a little huddle about a topic.

00:09:53.760 --> 00:09:56.560
Yeah. That's what's so powerful about in-person conferences.

00:09:56.560 --> 00:10:04.160
Yeah. We missed the entire hallway track, but it was still good to have sort of short presentations and

00:10:04.160 --> 00:10:11.040
Q&A sessions. And the Q&A sessions actually worked really well. There was a little tool that you can

00:10:11.040 --> 00:10:19.200
use to sort of moderate questions. And Lukasz was like running the moderation tool and nobody was asking

00:10:19.200 --> 00:10:23.760
spam questions. So all he had to do was just click OK for every question, I think.

00:10:23.760 --> 00:10:31.520
Yeah. That tool is much more structured than the chat channel on Zoom could be. And sort of raising

00:10:31.520 --> 00:10:37.360
your hand on Zoom and waving doesn't really work if there are 50 people, because there's no way to see

00:10:37.360 --> 00:10:39.920
more than 16 people or so at a time. Yeah.

00:10:39.920 --> 00:10:47.440
So anyway, the first day, each day, there were like maybe five topics and a few miscellaneous things.

00:10:47.440 --> 00:10:53.200
Shall I just go over each day briefly, see if I can sort of run them all off?

00:10:53.200 --> 00:10:58.800
Yeah, I would say just maybe touch really quickly on just the things that you felt like really might

00:10:58.800 --> 00:11:01.120
make an impact going forward, potentially.

00:11:01.120 --> 00:11:08.560
Just a one-liner guy who originally implemented F-strings gave a talk about whether maybe all

00:11:08.560 --> 00:11:16.400
strings should become F-strings. And the general sentiment was that that would have been nice

00:11:16.400 --> 00:11:21.280
in Python 1.0 or so, but there is no way that it would just break too much code.

00:11:21.280 --> 00:11:25.440
It's going to break too much. I totally hear that though, because I'm so often I'm typing in a

00:11:25.440 --> 00:11:29.680
string. I'm like, oh, I need to put a variable here, but I've typed 20 characters in that I got

00:11:29.680 --> 00:11:33.360
to go back to the beginning, but not the beginning of the line, because maybe that's what I got to get

00:11:33.360 --> 00:11:37.280
to the beginning of the string and then go. Maybe we could even put the F at the end. Who knows?

00:11:37.280 --> 00:11:41.360
But yeah, I would love to see it. But it's I totally understand. You can't do that without

00:11:41.360 --> 00:11:45.120
breaking stuff. There are downsides to automatically doing it, too, because

00:11:45.120 --> 00:11:50.000
curly braces are useful for all sorts of things besides formatting.

00:11:50.000 --> 00:12:05.920
So that was sort of the opening salvo. Then my two co-conspirators on the peg parsing project gave a talk about how we're going to hopefully introduce a new parser in Python 3.9.

00:12:06.880 --> 00:12:11.520
And we've been coding for like almost a year now, probably.

00:12:11.760 --> 00:12:18.980
It started out as a little hobby project of mine and gradually became more serious and more people started helping out.

00:12:18.980 --> 00:12:26.880
And the last few months, we've been doing heavy engineering work to actually prepare for the integration.

00:12:26.880 --> 00:12:29.480
But we didn't have steering council approval yet.

00:12:29.640 --> 00:12:43.140
We made it a PEP and we sort of said, well, this is a nice thing, but we're not going to do this unless there is sort of clear consensus or at least general agreement that we are going to do this.

00:12:43.140 --> 00:12:53.020
And so very soon after the summit, the steering council actually had a meeting and approved a bunch of peps and ours was one of them.

00:12:53.020 --> 00:13:01.720
And then the last two days, I've been stressing out because we wanted to get the new parser in the alpha 6 release, which is going out tomorrow.

00:13:01.720 --> 00:13:08.840
And so we're now in the last, the very last stretches of preparing for alpha 6.

00:13:08.840 --> 00:13:15.940
And we're just deleting or disabling tests that are still failing that we know how to fix them, but we just don't have the time.

00:13:16.100 --> 00:13:18.580
Right. That's exciting that this project is going to be in there. That's great.

00:13:18.580 --> 00:13:23.520
Yeah. So that's the new parser. And if all goes well, nobody will notice a thing.

00:13:23.520 --> 00:13:24.360
Ideally.

00:13:24.360 --> 00:13:29.300
What are the effects? Is it going to speed things up or make things more maintainable?

00:13:29.300 --> 00:13:42.200
It's going to sort of open up the grammar for future changes to the language that we currently can't do because the old LL1 parser holds us back.

00:13:42.200 --> 00:13:42.540
Okay.

00:13:42.540 --> 00:13:45.940
That's sort of the main motivation.

00:13:45.940 --> 00:13:46.300
Super.

00:13:46.300 --> 00:14:02.260
There was one interesting talk about something called HPy, which is a proposal for a new, more portable API and in particular focused on other Python implementations besides CPython.

00:14:02.260 --> 00:14:09.780
As you may know, PyPy has been struggling for over a decade with compatibility with extension modules.

00:14:10.180 --> 00:14:18.680
And the HPy proposal is basically instead of pointers to objects, you have handles, which is a pointer to a pointer to an object.

00:14:19.280 --> 00:14:28.380
And there's a whole API around handles that is equivalent to the existing API, but it allows different styles of garbage collection.

00:14:28.380 --> 00:14:34.240
For example, you could implement a garbage collector that moves objects behind your back occasionally.

00:14:34.240 --> 00:14:42.440
Right. You might get a generational compacting garbage collector because you could update the value of the pointer pointer without changing the actual pointer.

00:14:42.440 --> 00:14:42.740
Right.

00:14:42.820 --> 00:14:42.960
Yeah.

00:14:42.960 --> 00:14:43.320
Yeah.

00:14:43.320 --> 00:14:43.460
Yeah.

00:14:43.460 --> 00:14:43.620
Yeah.

00:14:43.620 --> 00:14:44.720
That's actually really exciting.

00:14:44.720 --> 00:14:45.100
Yeah.

00:14:45.100 --> 00:14:49.580
And it's still in early stages, I believe, but it looks pretty promising.

00:14:50.380 --> 00:15:01.380
Eric Snow gave a lightning talk about sort of a retrospective of all his work on multi-core support, which is now beginning to conclude.

00:15:01.380 --> 00:15:11.640
Well, maybe it's too soon to call it the conclusion, but we're going to have sub-interpreters with a much better API, either in 3.9 or in 3.10.

00:15:11.640 --> 00:15:23.680
There's a PEP around that 5.5.4, which will definitely be moving forward, but whether it's considered mature enough to land in 3.9 is not entirely clear.

00:15:23.680 --> 00:15:24.020
Yeah.

00:15:24.020 --> 00:15:25.840
Eric's work is very interesting there.

00:15:25.840 --> 00:15:26.040
Yeah.

00:15:26.040 --> 00:15:26.480
Yeah.

00:15:26.480 --> 00:15:31.600
And in 3.10, we will probably have separate gills per sub-interpreter.

00:15:31.600 --> 00:15:35.180
That is going to be a major new thing.

00:15:35.180 --> 00:15:35.740
Let's see.

00:15:35.740 --> 00:15:37.140
What else do we have?

00:15:37.580 --> 00:15:43.640
Well, so the next day, I gave a talk about the future of typing, which, oh, yeah, there's one detail.

00:15:43.640 --> 00:15:54.880
You might remember that we introduced something called from-dunder-future-import-annotations, which made it so that annotations are no longer evaluated at runtime.

00:15:54.880 --> 00:16:01.080
You can still introspect them, but you'll just get the string containing the annotation expression back.

00:16:01.080 --> 00:16:05.920
Well, that's going to be the default in 3.9, most likely.

00:16:06.300 --> 00:16:14.240
There's still a little debate about that, but there was like a two-thirds preference for just making that the default in 3.9.

00:16:14.240 --> 00:16:19.800
And various people argued effectively that nobody should notice any difference.

00:16:19.800 --> 00:16:23.680
I'm really excited or happy to have typing in the language.

00:16:23.680 --> 00:16:33.400
It makes such a difference for the right use case, you know, on defining the boundary of APIs or making the editor understand something better when it otherwise wouldn't.

00:16:33.400 --> 00:16:40.820
If you're maintaining tens of thousands of lines of Python code or more, type annotations really make a difference.

00:16:40.820 --> 00:16:41.740
Yeah, for sure.

00:16:41.740 --> 00:16:44.620
I still don't recommend teaching them to beginners, though.

00:16:44.620 --> 00:16:45.120
Oh, really?

00:16:45.120 --> 00:16:45.500
Okay.

00:16:45.500 --> 00:16:47.620
It depends on what kind of beginners you have.

00:16:47.620 --> 00:16:52.580
If they're sort of recuperating Java programmers, maybe you should introduce them.

00:16:52.720 --> 00:16:57.740
But if they're like actually blank slate, this is the first time they're programming ever.

00:16:57.740 --> 00:17:00.500
I wouldn't bother with them with annotations.

00:17:00.500 --> 00:17:00.820
Yeah.

00:17:00.820 --> 00:17:02.060
I kind of agree with that.

00:17:02.060 --> 00:17:02.260
Yeah.

00:17:02.260 --> 00:17:13.320
What's sort of still missing for the data science world is extensions to the type system for NumPy and Pandas and stuff like that.

00:17:13.320 --> 00:17:22.800
There is a design, but there are not enough people with available time to actually implement the design.

00:17:22.960 --> 00:17:30.260
And I'm sure that when you're halfway through implementation, all sorts of interesting issues with the design will prop up.

00:17:30.260 --> 00:17:33.740
So the design is not final until it's been implemented.

00:17:33.740 --> 00:17:34.780
Okay.

00:17:34.780 --> 00:17:36.180
Last two topics.

00:17:36.180 --> 00:17:44.180
Zach Hatfield Dodds gave a very good talk about what he calls property-based testing,

00:17:44.180 --> 00:18:02.600
and which really is about a tool named Hypothesis that introduces testing approach that I think was first developed in academia for Haskell that works in a completely different way than your typical unit test-based testing.

00:18:02.600 --> 00:18:02.960
Right.

00:18:02.960 --> 00:18:05.680
The tool decides, right, instead of examples.

00:18:05.680 --> 00:18:16.640
The tool generates test cases, and I've never played with it myself, but the talk sort of made me very excited to play around with it more.

00:18:16.640 --> 00:18:25.780
And it actually, even though it's a very different approach than unit test or pytest-based testing, it will still integrate with that.

00:18:25.780 --> 00:18:32.220
I mean, you can write a unit test and then put some decorator on top of it that produces test data.

00:18:32.520 --> 00:18:45.480
And Hypothesis has all kinds of really advanced stuff for exploring enormous spaces of possible input data and quickly finding bugs.

00:18:45.480 --> 00:18:52.020
Do you think we'll get to a place where we are able to use Hypothesis for some of the testing for the standard library?

00:18:52.020 --> 00:18:56.640
That was one of the propositions that Zach made.

00:18:56.640 --> 00:18:59.980
I think it's still early for that.

00:18:59.980 --> 00:19:00.420
Okay.

00:19:00.520 --> 00:19:18.040
I think it's much easier to introduce Hypothesis in sort of a new project where you haven't yet written all the code in all the tests than it is to retrofit it in a large, mature, or maybe even somewhat dementing project.

00:19:18.040 --> 00:19:18.380
Yeah.

00:19:18.380 --> 00:19:29.160
I think it'll be a while before we'll have hypothesis-based testing for the standard library, just like it'll be a while before we'll have annotations in the standard library,

00:19:29.160 --> 00:19:34.300
rather than annotations sort of separate from the standard library.

00:19:34.300 --> 00:19:47.040
The last talk I want to highlight, and then I'm really done with this, is also a very good talk by Russell Keith McGee about the state of Bware and Python for Mobile.

00:19:47.040 --> 00:20:06.020
And one of his suggestions was that we adopt some of his mega patches that he's currently being maintaining for several Python releases that would make Python at least compile out of the box or nearly out of the box for the important mobile platforms.

00:20:06.020 --> 00:20:06.800
That'd be cool.

00:20:06.920 --> 00:20:10.300
Yeah, it'd be so wonderful to have Python as an option for mobile.

00:20:10.300 --> 00:20:13.740
It really would bust open the doors and create even more growth.

00:20:13.740 --> 00:20:22.220
Many people believe that sort of mobile platforms are obviously continuing to grow in importance and to grow in power.

00:20:22.220 --> 00:20:26.760
And we'd be crazy if we didn't support Python on those.

00:20:26.760 --> 00:20:30.200
And it may be very important for Python's very survival.

00:20:30.200 --> 00:20:30.520
Yeah.

00:20:30.520 --> 00:20:31.040
Yeah.

00:20:31.040 --> 00:20:34.880
I saw the Block Swan talk that Russell Keith McGee gave, and it was compelling.

00:20:34.880 --> 00:20:36.680
He is an amazing speaker, for sure.

00:20:36.680 --> 00:20:37.020
Yeah.

00:20:37.020 --> 00:20:37.640
Yeah, yeah.

00:20:37.640 --> 00:20:38.300
That's what I have.

00:20:38.300 --> 00:20:38.600
Great.

00:20:38.660 --> 00:20:40.000
Thank you so much for that insight.

00:20:40.000 --> 00:20:41.180
That was awesome.

00:20:41.180 --> 00:20:44.060
A lot of people don't get to see the behind the scenes.

00:20:44.060 --> 00:20:45.900
They just see what's announced when it comes out, right?

00:20:45.900 --> 00:20:46.360
Mm-hmm.

00:20:46.360 --> 00:20:48.700
Before we move on, let me tell you about our sponsor, Datadog.

00:20:48.700 --> 00:20:51.780
This episode is brought to you by Datadog.

00:20:51.780 --> 00:20:52.960
So let me ask you a question.

00:20:52.960 --> 00:20:55.700
Do you have an app in production that's slower than you like?

00:20:55.700 --> 00:20:58.620
Is its performance all over the place, sometimes fast, sometimes slow?

00:20:58.620 --> 00:21:00.480
Now, here's the important question.

00:21:00.480 --> 00:21:01.400
Do you know why?

00:21:01.400 --> 00:21:02.900
With Datadog, you will.

00:21:02.900 --> 00:21:08.000
You can troubleshoot your app's performance with Datadog's end-to-end tracing, use detailed flame graphs,

00:21:08.140 --> 00:21:10.660
identify bottlenecks and latency in that finicky app of yours.

00:21:10.660 --> 00:21:13.680
So be the hero that got the app back on track at your company.

00:21:13.680 --> 00:21:17.580
Get started with a free trial over at pythonbytes.fm/Datadog.

00:21:17.580 --> 00:21:19.040
Get a cool t-shirt as well.

00:21:19.040 --> 00:21:22.200
Brian, you've got another one that kind of ties into your first one, right?

00:21:22.200 --> 00:21:24.100
But it's sort of the other side of the coin, maybe?

00:21:24.100 --> 00:21:29.180
I don't know what's been happening in the Python world that you sort of orbit in that might make

00:21:29.180 --> 00:21:30.920
you think about these things, but tell us about it.

00:21:30.920 --> 00:21:36.960
No, I've just been thinking about community and codes of contact and enforcement for codes of

00:21:36.960 --> 00:21:37.400
conduct.

00:21:37.400 --> 00:21:38.640
No reason, really.

00:21:38.640 --> 00:21:40.100
Just kind of an interesting topic.

00:21:40.100 --> 00:21:44.800
One of the things I've been thinking about is, especially when researching this, the codes

00:21:44.800 --> 00:21:48.540
of conduct and enforcement of it and how we treat people.

00:21:48.540 --> 00:21:52.860
I first thought it was really important for open source projects, and it definitely is because

00:21:52.860 --> 00:21:55.940
people have the option to just leave and get out of the project.

00:21:56.100 --> 00:22:01.560
So you really want to treat people well so they stick around and have it be welcoming to

00:22:01.560 --> 00:22:02.020
other people.

00:22:02.020 --> 00:22:04.660
But I don't think industry is really that different.

00:22:04.660 --> 00:22:09.680
I think that people have the ability to just get another job or work on a different project.

00:22:09.680 --> 00:22:12.100
So I think these are important for industry as well.

00:22:12.540 --> 00:22:16.800
I took a look at two sets of codes of conduct and the enforcement of those.

00:22:16.800 --> 00:22:19.500
So the PSF has a code of conduct.

00:22:19.500 --> 00:22:23.800
I'm not going to read them all out, but there's things like being open and being friendly.

00:22:23.800 --> 00:22:28.260
And in there, there's a list of inappropriate behaviors as well that's covered.

00:22:28.600 --> 00:22:33.840
Now, also the Django code of conduct, they also have all of these when you read them, there

00:22:33.840 --> 00:22:36.560
are differences, but when you read them, they kind of sound the same.

00:22:36.560 --> 00:22:44.640
One of the things they highlight in the Django one is be careful with your choice, choice of

00:22:44.640 --> 00:22:50.820
words, including, and they include examples of harassment, speech, and exclusionary behavior

00:22:50.820 --> 00:22:51.860
that's not appropriate.

00:22:51.860 --> 00:22:54.900
One of the big differences I saw was the enforcement.

00:22:54.900 --> 00:23:02.300
So the PSF is a two-third majority vote enforcement sort of thing to make sure if something happens,

00:23:02.300 --> 00:23:05.080
like if they want to kick somebody out or put them on probation or something.

00:23:05.080 --> 00:23:10.580
I think that's really important because if you require 100% majority and somebody who is

00:23:10.580 --> 00:23:15.800
on the team that decides is potentially part of the problem, then what do you do, right?

00:23:15.800 --> 00:23:17.160
It's really tricky.

00:23:17.160 --> 00:23:22.520
I mean, if people are just going to abandon a project, right, you would rather have just a

00:23:22.520 --> 00:23:24.640
strong majority make a decision.

00:23:24.640 --> 00:23:29.540
I also think that PSF has probably got a larger, possibly has a larger working group on this

00:23:29.540 --> 00:23:33.940
and is more, I guess, maybe harder to get a hold of people.

00:23:33.940 --> 00:23:38.620
Maybe it's easier to get a two-thirds than maybe you can't even reach all 100% of the group.

00:23:38.620 --> 00:23:45.280
But anyway, the other interesting difference is the PSF code of conduct seems to, I know it

00:23:45.280 --> 00:23:52.360
does cover online interaction as well as events like the conferences and meetups and stuff.

00:23:52.360 --> 00:24:03.100
But I possibly, at least I think that maybe its focus might be more on events, whereas the Django code of conduct is specifically targeted towards online interactions.

00:24:03.100 --> 00:24:13.180
I would say for the PSF that sort of historically, events were the first place where codes of conduct were introduced.

00:24:13.640 --> 00:24:19.920
But we've been using them for online forums more and more in the past few years.

00:24:19.920 --> 00:24:20.320
Okay.

00:24:20.680 --> 00:24:29.780
One of the interesting things with the Django one is that a single person on the committee can act without collaborating with anybody else.

00:24:29.780 --> 00:24:37.840
If it's an ongoing problem or if there's a threat involved or something, they still have to go through the process of notifying everybody else.

00:24:38.080 --> 00:24:42.540
But there is an interesting thing that one person on the committee can intervene right away.

00:24:42.540 --> 00:24:53.260
I'm not saying one is better than the other, or I just think it's interesting and I think it's important for new projects to think about, not just their code of conduct, but how they're going to enforce it.

00:24:53.360 --> 00:24:54.620
And what the timeline.

00:24:54.620 --> 00:24:57.640
So the Django one also includes some timelines, which is interesting.

00:24:57.640 --> 00:25:11.240
And I would really like to make sure that projects kind of practice, maybe figure out what they're going to do if they need to enact one of these things without, you know, before it becomes a problem, they know what they're going to do.

00:25:11.500 --> 00:25:14.200
Yeah, there's a lot of stuff going on with some projects out there.

00:25:14.200 --> 00:25:18.380
So having a couple of examples and side-by-side comparisons, I think is great.

00:25:18.380 --> 00:25:26.900
I was interested to find out our meetup, like the Python meetup that we started, which is on hold right now, unfortunately, because of the virus and quarantine and stuff.

00:25:26.900 --> 00:25:37.980
But because we were getting support from the Python Software Foundation to help pay for the meetup fees and stuff, we had to list a code of conduct on our meetup page and stuff like that.

00:25:37.980 --> 00:25:39.840
Yeah, that makes a lot of sense, but I didn't realize that.

00:25:39.840 --> 00:25:40.440
Yeah, yeah.

00:25:40.500 --> 00:25:43.260
The PSF has been doing that for a few years now.

00:25:43.260 --> 00:25:44.120
Yeah, that's really great.

00:25:44.120 --> 00:25:45.900
All right, this next one I want to cover.

00:25:45.900 --> 00:25:48.460
It goes back a ways, but I think it's really fun.

00:25:48.460 --> 00:25:53.000
And it's something that also, I think, ties together well with our special guest here.

00:25:53.000 --> 00:25:57.280
And this is an article about myths about indentation.

00:25:57.280 --> 00:26:01.220
And Guido, I picked this one because you were talking about this on Twitter just the other day.

00:26:01.220 --> 00:26:03.280
What was the motivation to throw that out there?

00:26:03.280 --> 00:26:04.520
That is a good question.

00:26:04.520 --> 00:26:10.480
I was just going to volunteer the answer because apparently I had a link to that.

00:26:10.480 --> 00:26:14.940
I had a link to that article on my homepage in some odd corner.

00:26:14.940 --> 00:26:18.440
And I have a very, very sort of ready old homepage.

00:26:18.440 --> 00:26:22.300
It's moved it to GitHub pages, but it looks like web 1.0.

00:26:22.300 --> 00:26:25.460
And because it really is, I just added raw HTML.

00:26:25.720 --> 00:26:26.200
Blinden, right?

00:26:26.200 --> 00:26:26.960
With Netscape, huh?

00:26:26.960 --> 00:26:35.820
So someone reported to me a broken link, which happens like, I don't know, once every four years or so.

00:26:35.820 --> 00:26:38.420
Someone reported a broken link.

00:26:38.420 --> 00:26:40.100
Oh, wait, it wasn't even on my homepage.

00:26:40.100 --> 00:26:44.400
It was on an old blog that I can no longer edit at artema.com.

00:26:44.480 --> 00:26:46.520
I'm very glad that that blog is still online.

00:26:46.520 --> 00:26:57.600
But so because I got the report of the broken link, I decided, oh, I'm sure I can still find on archive.org where that link used to point.

00:26:57.600 --> 00:26:59.580
And sure enough, it was there.

00:26:59.580 --> 00:27:02.840
And I thought, oh, that's actually still a neat little article.

00:27:02.840 --> 00:27:05.660
So I thought, okay, tweet of the day or tweet of the week.

00:27:05.660 --> 00:27:06.280
Yeah, I agree.

00:27:06.340 --> 00:27:07.620
And I think it's interesting as well.

00:27:07.620 --> 00:27:20.680
And just to give you a sense of why it might have disappeared, it was one of those types of sites where the domain or the URL included a tilde username path, like, you know, like used to get in university or whatever way back when.

00:27:20.680 --> 00:27:24.680
So anyway, this one is myths about indentation for Python.

00:27:24.680 --> 00:27:32.120
And for people who come from a C-oriented language, I think Python could come across a little bit funky.

00:27:32.120 --> 00:27:36.100
I actually want to share a little story of just sort of my journey with it.

00:27:36.100 --> 00:27:38.120
And how I came to love this.

00:27:38.120 --> 00:27:43.520
But I think this is really interesting for people having the debate about is significant white space useful?

00:27:43.520 --> 00:27:44.040
Is it weird?

00:27:44.040 --> 00:27:44.540
Is it good?

00:27:44.540 --> 00:27:48.100
I did a ton of C++ and then C# development.

00:27:48.100 --> 00:27:49.920
So it was all, and then JavaScript development.

00:27:49.920 --> 00:27:52.840
It was all about the curly brace languages, lots of symbols.

00:27:52.840 --> 00:27:54.700
And then I came to learn Python.

00:27:54.700 --> 00:27:56.320
And I'd love Python right away.

00:27:56.320 --> 00:27:57.700
But it was weird to me.

00:27:57.700 --> 00:27:58.580
I felt kind of naked.

00:27:58.580 --> 00:28:03.160
Like if I'd write an if statement, I'm like, I need some little parentheses to kind of hold the code in place.

00:28:03.160 --> 00:28:04.320
And why don't they need to be there?

00:28:04.320 --> 00:28:08.500
And I need a curly brace to like say when this block of code is done and whatnot.

00:28:08.500 --> 00:28:10.500
It just took a little bit of getting used to.

00:28:10.500 --> 00:28:12.740
But I knew that it was the right thing for me.

00:28:12.740 --> 00:28:17.740
Because when I went back to work on some older projects, I'm like, why are there symbols everywhere?

00:28:17.740 --> 00:28:19.600
What is all this stuff I have to keep typing?

00:28:19.600 --> 00:28:21.000
This is like a broken language.

00:28:21.000 --> 00:28:26.680
And it just took a couple of weeks for me to like make that switch to feel like it was broken to go back to work in languages.

00:28:26.680 --> 00:28:28.180
And I've been doing for like 10 years.

00:28:28.600 --> 00:28:30.620
So well done with the white space, Guido.

00:28:30.620 --> 00:28:31.080
Thanks.

00:28:31.080 --> 00:28:31.440
Yeah.

00:28:31.440 --> 00:28:34.960
But so let's cover some of the things mentioned really quick in the article.

00:28:34.960 --> 00:28:38.360
One is that white space is significant in Python source code.

00:28:38.360 --> 00:28:41.820
And actually, no, not in general is the answer.

00:28:41.820 --> 00:28:44.380
It's significant on the left.

00:28:44.380 --> 00:28:46.160
Right.

00:28:46.280 --> 00:28:49.160
So as much as you indent stuff, that really means things.

00:28:49.160 --> 00:28:56.000
But between variables, like whether you have like a equals seven or a space equals space seven, doesn't matter.

00:28:56.000 --> 00:28:57.380
You can have tons of spaces in there.

00:28:57.380 --> 00:28:57.520
Right.

00:28:57.520 --> 00:29:01.720
Like any other language of spaces kind of don't matter except for on the left.

00:29:01.720 --> 00:29:03.780
So that's cool.

00:29:03.840 --> 00:29:06.300
And also the amount of indentation doesn't really matter.

00:29:06.300 --> 00:29:06.820
Right.

00:29:06.820 --> 00:29:13.040
You could have five spaces or any code suite that you want, or you could have 18 or you could go with a standard four.

00:29:13.040 --> 00:29:14.880
I recommend the four, but you know.

00:29:14.880 --> 00:29:25.560
And then also, if you have something that defines like a list comprehension or an array creation or a dictionary, then all of a sudden the spacing doesn't matter anymore.

00:29:25.560 --> 00:29:25.940
Right.

00:29:25.940 --> 00:29:30.920
As soon as you have like an open square bracket and then you have a bunch of stuff and then close square bracket spacing doesn't matter in there.

00:29:30.920 --> 00:29:35.460
So I think this is interesting to think about as folks debate that maybe within their teams.

00:29:35.460 --> 00:29:39.180
It also, you could say it forces you to use a certain indentation style.

00:29:39.180 --> 00:29:40.520
Well, yes and no.

00:29:40.520 --> 00:29:54.240
If you wanted to write it single statement per line, then yeah, there's a cool example that they gave in the article is like if one plus one equals two, then new line print food, new line print bar, new line print, or just say X equals 42.

00:29:54.240 --> 00:29:57.200
You can also put them on multiple lines with semicolons.

00:29:57.200 --> 00:29:59.920
If you're really missing your semicolons from your language, you could do that.

00:30:00.560 --> 00:30:07.100
The thing that's interesting here, I think this is probably the most significant part of this article or this write-up is if you look at it, it looks right.

00:30:07.100 --> 00:30:09.840
And when it gets parsed, it is right.

00:30:09.840 --> 00:30:18.100
There's an example of some C code that looks visually wrong because it's intended differently, but it's going to parse.

00:30:18.500 --> 00:30:23.080
But the way you see it when you read it is not what's actually happening.

00:30:23.080 --> 00:30:25.020
And I think there was a problem like this.

00:30:25.020 --> 00:30:31.220
Well, I think it was in some, you know, Objective-C or something with Apple in there.

00:30:31.220 --> 00:30:32.660
It was really bad.

00:30:32.660 --> 00:30:35.240
There was an infamous Apple vulnerability.

00:30:35.680 --> 00:30:44.420
I think it might even have been on the iPhone where someone had added a second statement to a block, but it wasn't a block because there were no curlies.

00:30:44.420 --> 00:30:45.100
Right.

00:30:45.100 --> 00:30:50.820
Then it started out with a single conditional line, like if something indent, do the thing.

00:30:51.420 --> 00:30:54.280
And then they just indented, but they didn't put the curly braces in.

00:30:54.280 --> 00:31:01.700
And it was, yeah, it was, it took so long for people to find it because visually it looked like what Python would look actually mean.

00:31:01.700 --> 00:31:01.900
Right.

00:31:01.900 --> 00:31:06.480
It looked like those two things are part of the if block, but because the white space didn't matter, it actually didn't.

00:31:06.540 --> 00:31:08.100
And so that's really interesting.

00:31:08.100 --> 00:31:09.580
I'm not going to go through everything.

00:31:09.580 --> 00:31:10.700
I'll put it in the show notes.

00:31:10.700 --> 00:31:13.240
But another one that I thought is like, I just don't like it.

00:31:13.240 --> 00:31:13.800
And that's fine.

00:31:13.800 --> 00:31:16.700
People can not like it, but it has a lot of advantages.

00:31:16.700 --> 00:31:21.420
Like in that example before, if you had that wrongly indented Python code, it would not parse.

00:31:21.420 --> 00:31:25.580
It's an error to have it not look right and rather than just not be right.

00:31:25.580 --> 00:31:31.780
So it has a lot of advantages and people can really quickly get used to not having to write all those symbols.

00:31:31.780 --> 00:31:34.360
And then you go back and you're like, this code is hard to read.

00:31:34.380 --> 00:31:37.640
It's just full of curly braces, semicolons, parentheses everywhere.

00:31:37.640 --> 00:31:41.880
I always thought we used to, those were just, that is what builds programming languages.

00:31:41.880 --> 00:31:43.960
To have a programming language, you had to have that.

00:31:43.960 --> 00:31:49.440
And then once I experienced Python and I went back, it kind of, it broke my mental model of the world.

00:31:49.440 --> 00:31:51.240
I'm like, you don't actually have to have those things.

00:31:51.240 --> 00:31:52.120
So why are they there?

00:31:52.120 --> 00:31:54.200
Anyway, what do you think about this article?

00:31:54.200 --> 00:31:57.200
You must like it somewhat because you hunted it down and tweeted it, right?

00:31:57.200 --> 00:32:02.180
It's old news for me because I didn't even invent the white space thing for Python.

00:32:02.180 --> 00:32:08.560
That was sort of handed to me on a silver platter by one of my mentors in the early 80s.

00:32:08.560 --> 00:32:08.820
Yeah.

00:32:08.820 --> 00:32:09.260
Yeah.

00:32:09.260 --> 00:32:10.220
Back in the ABC days.

00:32:10.220 --> 00:32:12.740
And in those days, it was an innovation.

00:32:12.740 --> 00:32:16.300
There was like one other language that had this.

00:32:16.300 --> 00:32:26.800
And Knuth had once said that he thought it would be a good idea, but he had never actually implemented the language or even experienced the language that implemented it.

00:32:26.860 --> 00:32:28.920
He just thought that it would be a good idea.

00:32:28.920 --> 00:32:29.320
Right.

00:32:29.320 --> 00:32:29.680
Right.

00:32:29.680 --> 00:32:39.820
The only thing that was a stumbling block for me was when I first started looking at Python, the editor I was using, I think it was, I think it was an Emacs something at the time.

00:32:39.820 --> 00:32:50.380
I'm not sure what I was using, but with the C++ code I was using, I had it set up so that if I double clicked on the closing bracket, it would jump to the top of the block.

00:32:50.760 --> 00:32:52.600
And I really liked that feature.

00:32:52.600 --> 00:32:56.420
And for some reason, that's the reason why I didn't like the white space thing at first.

00:32:56.420 --> 00:32:57.340
Like, how do I get back?

00:32:57.340 --> 00:33:04.420
But then I just went, okay, I'm going to like beginner's mind, just open mind, just embrace it and learn it as a new thing.

00:33:04.700 --> 00:33:07.320
And I didn't, like a week later, I didn't even miss it.

00:33:07.320 --> 00:33:07.980
Yeah.

00:33:07.980 --> 00:33:17.400
And of course, the new editors, the newer editors like PyCharm and stuff, at the bottom, they have little breadcrumbs of, you know, here's the class, here's the function, here's the if, here's the while, whatever.

00:33:17.400 --> 00:33:23.180
And you can jump between them, just like you were talking about, but like the entire hierarchy of, I don't know, the tokens or whatever.

00:33:23.320 --> 00:33:27.720
Yeah, and I just, I tend to write smaller functions now, so it's not as much of a deal.

00:33:27.720 --> 00:33:30.440
This is probably a good thing that it was hard.

00:33:30.440 --> 00:33:37.400
I was thinking, truly, that if you needed the attitude to help you find the top of the block, it must be pretty far away.

00:33:37.400 --> 00:33:37.760
Yeah.

00:33:37.760 --> 00:33:40.080
It's 4,000 lines.

00:33:40.080 --> 00:33:41.220
I hate scrolling so much.

00:33:41.220 --> 00:33:42.300
These functions are hard.

00:33:42.300 --> 00:33:43.260
Ah, yeah.

00:33:43.260 --> 00:33:44.440
How interesting.

00:33:44.440 --> 00:33:44.820
All right.

00:33:44.820 --> 00:33:46.540
Guido, do you have one more you want to share with us?

00:33:46.540 --> 00:33:48.080
Well, yeah, you gave me some homework.

00:33:48.080 --> 00:33:52.840
I didn't really do it, but there's like, and of course, this has to do with parsing.

00:33:52.840 --> 00:33:55.680
And so this may be a fairly esoteric library.

00:33:55.680 --> 00:34:09.180
But if you're writing a program that sort of does some manipulation of your code, and maybe it converts four space indents to two space indents or three space indents or whatever.

00:34:09.180 --> 00:34:20.060
Or maybe you're writing something like Black, which is the sort of Python code reformatting tool, but you don't like the way Black handles certain things.

00:34:20.060 --> 00:34:26.920
Or maybe you're writing some other thing that does analysis of source code.

00:34:26.920 --> 00:34:28.340
Maybe you're writing a linter.

00:34:28.340 --> 00:34:35.780
There are a couple of tools that you can use, and it turns out that one of them is in the standard library.

00:34:35.780 --> 00:34:40.020
There's something called lib223, which is a little hard to pronounce.

00:34:40.020 --> 00:34:45.240
It has the digit two and then the word T-O and then the digit three in the name.

00:34:45.240 --> 00:34:45.980
That is tricky.

00:34:45.980 --> 00:34:56.180
That is something I wrote probably over 15 years ago, or at least the core of it, which is yet another LL1 parser.

00:34:56.180 --> 00:35:00.140
But this one's written in Python rather than in C, like the original one.

00:35:00.540 --> 00:35:11.380
And actually Black ended up using lib223, except I think Lukasz had one issue that he couldn't figure out how to do with Black.

00:35:11.380 --> 00:35:17.240
And so he ended up vendoring a copy of lib223 and then butchering it a little bit.

00:35:17.240 --> 00:35:19.380
Which is how these things happen.

00:35:19.380 --> 00:35:24.420
I mean, if you look at what pip vendors, that's pretty scary, but there are good reasons for that too.

00:35:24.420 --> 00:35:33.860
So, but if you're writing your own, you should probably not use lib223 and not just because it's going to go out of style once the peg parser arrives.

00:35:33.860 --> 00:35:36.060
There are much better tools.

00:35:36.060 --> 00:35:44.440
And the one that I discovered a few months ago is actually written by some folks at Facebook mostly.

00:35:44.660 --> 00:35:46.460
It's called libcst.

00:35:46.460 --> 00:35:49.840
And they have unique capitalization.

00:35:49.840 --> 00:35:56.500
It's a capital L lib and then lowercase ib and then cst is all uppercase.

00:35:56.500 --> 00:36:00.480
And so it's a library for manipulating concrete syntax trees.

00:36:00.940 --> 00:36:06.260
And like lib223, it actually shares some code with lib223.

00:36:06.260 --> 00:36:15.660
I think the underneath is a parsing library called Parso, which itself is a butchered version of lib223.

00:36:15.660 --> 00:36:17.060
At least that's how it started.

00:36:17.060 --> 00:36:26.500
These tools are things that can parse Python code, but they produce a syntax tree that is the opposite of an abstract syntax tree.

00:36:26.500 --> 00:36:28.580
It's a very concrete syntax tree.

00:36:28.580 --> 00:36:43.740
And that means that every space, every comment, every bit of indentation is preserved or at least can be recovered from the information in that syntax tree.

00:36:43.740 --> 00:36:52.820
And oppose that with the typical abstract syntax tree, which in the end doesn't even remember where the parentheses are.

00:36:52.820 --> 00:36:53.720
Right, right.

00:36:53.720 --> 00:36:54.600
It just takes us up.

00:36:54.600 --> 00:36:55.880
Well, here's some conditional statement.

00:36:55.880 --> 00:36:57.280
Here's the two things we're testing.

00:36:57.280 --> 00:36:57.620
Yeah.

00:36:57.620 --> 00:36:57.860
Right.

00:36:57.860 --> 00:37:07.000
So this sounds much more useful if you want to do like a code analysis type of thing to say this thing you're doing here, you should do it in this other way or transform it over.

00:37:07.000 --> 00:37:09.420
But kind of preserve things like comments and style.

00:37:09.420 --> 00:37:09.840
Yeah.

00:37:10.200 --> 00:37:33.320
So lib223 itself started out that way as well is you read your source code using this customized parser.

00:37:33.320 --> 00:37:35.840
It gives you a concrete syntax tree.

00:37:35.840 --> 00:37:40.280
Then in that syntax tree, you're actually going to make changes.

00:37:40.280 --> 00:37:47.320
You're going to systematically rename a parameter or move things around or insert.

00:37:47.320 --> 00:37:54.160
In the 223 world, of course, it's used to turn things like iter items into items and iter keys into keys.

00:37:54.320 --> 00:37:56.520
And you can make that kind of changes.

00:37:56.520 --> 00:38:10.740
And so libCST also supports that, but it sort of has a slightly better API because 15 years ago when I started lib223, I didn't realize what an important tool it was going to be.

00:38:10.740 --> 00:38:20.360
And some of the way the white space is attached to nodes is exactly backwards from the way that is the most convenient to think about it and work with it.

00:38:20.360 --> 00:38:20.640
All right.

00:38:20.640 --> 00:38:21.040
Cool.

00:38:21.040 --> 00:38:25.760
Well, this sounds like it'll be really helpful for people building tools like Black or looking at code analysis and stuff.

00:38:25.760 --> 00:38:26.380
Right.

00:38:26.380 --> 00:38:36.260
Lukash had, I think it was the 2019 talk, PyCon talk, where he described how Black uses both concrete syntax trees and the abstract syntax tree.

00:38:36.920 --> 00:38:42.940
It's a pretty fascinating talk for a very low level depth into these concepts.

00:38:42.940 --> 00:38:53.860
It wasn't until I watched that talk that I realized that Black compares the before and after abstract syntax tree to make sure that your code is guaranteed to run the same.

00:38:53.860 --> 00:38:56.220
So you don't really have to test for that.

00:38:56.220 --> 00:38:57.600
He's already testing for it.

00:38:57.600 --> 00:38:59.360
So that's pretty interesting.

00:38:59.360 --> 00:39:00.180
Yeah, that's very cool.

00:39:00.180 --> 00:39:01.840
That is a very neat feature.

00:39:01.840 --> 00:39:06.660
And it's actually an important trick in general for people who are doing transformation.

00:39:06.660 --> 00:39:16.060
to have some abstract way of double checking that your transformation left things in a decent state.

00:39:16.060 --> 00:39:16.740
Yeah, it's cool.

00:39:16.740 --> 00:39:17.340
Yeah, very cool.

00:39:17.340 --> 00:39:17.880
All right.

00:39:17.880 --> 00:39:19.000
Well, thanks for libcst.

00:39:19.000 --> 00:39:20.000
Guido, that's a great one.

00:39:20.000 --> 00:39:21.580
Now, that's it for our main topic.

00:39:21.580 --> 00:39:24.780
So just really quick things at the end that I just want to throw out there for people.

00:39:25.160 --> 00:39:29.640
One, Adam, who goes by Codependent Coder on Twitter, sent a message over and said,

00:39:29.640 --> 00:39:43.440
Hey, Django no longer supports Python 2 at all, which is pretty awesome because 1.11 has left long-term support, leaving only 2.2.12 onward, which has only Python 3 support.

00:39:43.440 --> 00:39:46.420
So yay for modern Python making its way through.

00:39:46.420 --> 00:39:47.040
That's good.

00:39:47.380 --> 00:39:53.480
And then last time we talked about 90% of coding is Googling and that's okay, or it's not.

00:39:53.480 --> 00:39:56.240
And we didn't really feel like that was our experience, right?

00:39:56.240 --> 00:39:57.980
As people have been around for a while.

00:39:57.980 --> 00:40:06.060
But I got to tell you, this last week I've been doing nothing but Pandas, Altair visualization, Jupyter notebook, and graphics.

00:40:06.620 --> 00:40:11.480
Because I'm building a whole set of dashboards for the Talk Python courses and whatnot.

00:40:11.480 --> 00:40:14.480
And basically the dashboards that I should have built a while ago.

00:40:14.480 --> 00:40:15.980
I Googled a lot.

00:40:15.980 --> 00:40:17.100
A whole lot.

00:40:17.100 --> 00:40:18.640
But that's the thing.

00:40:18.640 --> 00:40:27.420
It was like a two or three day blip of like, wow, I'm Googling like 25, 30% of my time because I don't know anything about these things.

00:40:27.420 --> 00:40:29.520
And how do I get this thing to line up with that bar?

00:40:29.520 --> 00:40:33.820
But now I'm back to just kind of mostly not doing that anymore, even after a few days.

00:40:33.820 --> 00:40:38.800
So I think generally what we said is true, but I do think there's like these blips of like, wow, I'm diving into something new.

00:40:38.800 --> 00:40:40.500
It's like mad search scrambling.

00:40:40.500 --> 00:40:44.160
But then I'm back to sort of using like more memory coding.

00:40:44.160 --> 00:40:45.700
I don't know what you call not Google coding.

00:40:45.700 --> 00:40:48.200
You've got to understand what you're doing.

00:40:48.200 --> 00:40:59.320
And that means you can't just Google for examples and copy and paste them in because then you can combine the examples and you have no idea what you're doing.

00:40:59.320 --> 00:41:00.520
And of course it doesn't work.

00:41:00.520 --> 00:41:02.040
At best it's frustrating, right?

00:41:02.040 --> 00:41:04.420
You're like, this worked, that worked, but together they don't work.

00:41:04.420 --> 00:41:05.740
And you just don't even know why, right?

00:41:05.740 --> 00:41:05.960
Yeah.

00:41:05.960 --> 00:41:06.780
So for sure.

00:41:06.780 --> 00:41:08.160
But yeah.

00:41:08.160 --> 00:41:11.020
So anyway, it's a follow up on our conversation last week, right?

00:41:11.020 --> 00:41:12.180
What do you got to throw out there for everyone?

00:41:12.180 --> 00:41:15.480
I'm going to say this on this show just to make sure I do it.

00:41:15.480 --> 00:41:18.340
There's like three days left for me to record my talk.

00:41:18.340 --> 00:41:18.720
Yeah.

00:41:18.720 --> 00:41:21.520
This is like forcing yourself to commit to it.

00:41:21.520 --> 00:41:22.220
So you're going to do it.

00:41:22.220 --> 00:41:22.780
Okay.

00:41:22.940 --> 00:41:23.760
Yes, definitely.

00:41:23.760 --> 00:41:25.040
So PyCon talk.

00:41:25.040 --> 00:41:26.360
I really do want to get it online.

00:41:26.360 --> 00:41:27.860
It's important stuff.

00:41:27.860 --> 00:41:29.260
It's about parameterization.

00:41:29.260 --> 00:41:37.200
I talked a couple episodes ago about having trouble switching back and forth at home with all this working from home stuff between Mac and Windows.

00:41:37.420 --> 00:41:40.560
I finally figured out the whole using command and control.

00:41:40.560 --> 00:41:42.620
So thank you to everybody.

00:41:42.620 --> 00:41:44.540
But apparently there's this really simple thing.

00:41:44.540 --> 00:41:47.400
Apple lets you just swap them on a keyboard.

00:41:47.400 --> 00:41:48.520
So that's what I'm doing.

00:41:48.520 --> 00:41:49.620
And it works great.

00:41:50.160 --> 00:41:58.000
And then also I had promised that I was going to have my cards project be able to work and publish to PyPI or the test PyPI.

00:41:58.000 --> 00:42:01.880
It doesn't work with setup tools SCM because I'm using Flit.

00:42:01.880 --> 00:42:12.340
So if somebody's got a way to figure out how to just somehow change the version string or bump that every time you merge or something like that, that'd be great.

00:42:12.340 --> 00:42:19.020
But otherwise, right now, I don't think there's a way to automatically push to PyPI if you're using Flit.

00:42:19.620 --> 00:42:21.580
Yeah, because it says that one's already uploaded.

00:42:21.580 --> 00:42:24.380
Maybe there's a GitHub action that will just randomize that or something.

00:42:24.380 --> 00:42:27.140
Because the version is embedded in the source code.

00:42:27.140 --> 00:42:33.180
And the trick that people are using with setup tools is the version is based on the version in GitHub.

00:42:33.180 --> 00:42:35.460
And you can't do that with Flit.

00:42:35.460 --> 00:42:37.480
So at least I haven't figured it out.

00:42:37.480 --> 00:42:38.620
But that's okay.

00:42:38.620 --> 00:42:40.260
I'll probably do something else.

00:42:40.260 --> 00:42:41.300
That's my extras.

00:42:41.300 --> 00:42:42.620
Guido, anything else?

00:42:42.620 --> 00:42:48.360
Even though I said it's hard to imagine Python going online, it actually is going online.

00:42:49.000 --> 00:42:50.240
At least some of it is.

00:42:50.240 --> 00:42:58.080
The first talk by the conference chair, Emily Morehouse, has been posted and many more will follow.

00:42:58.080 --> 00:42:59.400
Yeah, her welcome was really nice.

00:42:59.400 --> 00:43:04.820
The other thing, and as you mentioned, Django no longer supports Python 2 at all.

00:43:04.820 --> 00:43:13.360
Well, that's just fine because the very last release of Python 2, 2.7.18, was released a few days ago.

00:43:13.500 --> 00:43:14.460
Yeah, that's great.

00:43:14.460 --> 00:43:18.720
That must be kind of a load off of your shoulders to finally have that in the rearview mirror.

00:43:18.720 --> 00:43:19.880
I'm very happy.

00:43:19.880 --> 00:43:26.520
And I'm sad, of course, that we can't have an absolutely wild and crazy party in Pittsburgh like we were planning.

00:43:26.520 --> 00:43:28.400
Yeah, a big celebration on Zoom.

00:43:28.400 --> 00:43:29.320
It's just not the same.

00:43:29.320 --> 00:43:31.780
Just have to have a bigger one next year.

00:43:31.780 --> 00:43:33.800
That's one I don't know how to pull off.

00:43:33.800 --> 00:43:34.180
Yeah.

00:43:34.180 --> 00:43:35.440
Well, that's really good.

00:43:36.160 --> 00:43:36.480
All right.

00:43:36.480 --> 00:43:38.200
You guys ready for a really quick joke?

00:43:38.200 --> 00:43:39.280
All right.

00:43:39.280 --> 00:43:43.080
So here's a quick joke sent to us by Derek Chambers.

00:43:43.080 --> 00:43:45.960
And he may have even made this up for us.

00:43:45.960 --> 00:43:51.380
And this goes back to the sub interpreters and the multiple gills and all that.

00:43:51.380 --> 00:43:56.720
So you guys know how you can borrow money concurrently with asyncioUs?

00:43:57.280 --> 00:43:58.500
It's a terrible joke.

00:43:58.500 --> 00:43:59.380
That's a bad joke.

00:43:59.380 --> 00:44:02.080
Oh, that is very groan worthy.

00:44:02.080 --> 00:44:02.860
Very groan worthy.

00:44:02.860 --> 00:44:03.240
Excellent.

00:44:03.240 --> 00:44:06.680
Most of our jokes actually are around here, but that's how it goes.

00:44:06.680 --> 00:44:06.860
Yeah.

00:44:06.860 --> 00:44:07.840
And keep them coming.

00:44:07.840 --> 00:44:09.520
Keep sending us your bad jokes.

00:44:09.520 --> 00:44:10.360
Yeah.

00:44:10.360 --> 00:44:11.320
That's right.

00:44:11.320 --> 00:44:11.780
That's right.

00:44:11.780 --> 00:44:13.100
Python dad jokes.

00:44:13.100 --> 00:44:15.620
That should be a whole separate category.

00:44:15.620 --> 00:44:17.060
They absolutely should.

00:44:17.060 --> 00:44:17.580
They should.

00:44:17.580 --> 00:44:20.620
Well, Guido, it was really an honor to have you on the show.

00:44:20.620 --> 00:44:22.700
Thanks for coming and sharing your perspective on all this.

00:44:22.700 --> 00:44:23.480
Glad to be back.

00:44:23.480 --> 00:44:23.700
Yeah.

00:44:23.700 --> 00:44:25.560
And Brian, thanks as always.

00:44:25.560 --> 00:44:26.220
Good to be here with you.

00:44:26.220 --> 00:44:26.820
Cheers.

00:44:27.140 --> 00:44:27.300
Yep.

00:44:27.300 --> 00:44:28.060
Bye, everyone.

00:44:28.060 --> 00:44:28.400
Bye.

00:44:28.400 --> 00:44:29.260
Thanks, both of you.

00:44:29.260 --> 00:44:31.360
Thank you for listening to Python Bytes.

00:44:31.360 --> 00:44:33.900
Follow the show on Twitter via at Python Bytes.

00:44:33.900 --> 00:44:36.760
That's Python Bytes as in B-Y-T-E-S.

00:44:36.760 --> 00:44:39.980
And get the full show notes at pythonbytes.fm.

00:44:39.980 --> 00:44:44.200
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:44:44.200 --> 00:44:46.900
We're always on the lookout for sharing something cool.

00:44:46.900 --> 00:44:50.020
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:44:50.020 --> 00:44:53.440
Thank you for listening and sharing this podcast with your friends and colleagues.

