
00:00:00.000 --> 00:00:05.000
Hello and welcome to Python Bytes,


00:00:05.000 --> 00:00:06.840
where we deliver Python news and headlines


00:00:06.840 --> 00:00:08.480
directly to your earbuds.


00:00:08.480 --> 00:00:09.640
This is episode 179, recorded April 21st, 2020.


00:00:09.640 --> 00:00:15.120
I'm Michael Kennedy.


00:00:15.120 --> 00:00:16.000
And I'm Brian Okken.


00:00:16.000 --> 00:00:17.000
And Brian, I'm super honored to have Guido van Rossum on the show.


00:00:17.000 --> 00:00:20.920
Guido, welcome to Python Bytes.


00:00:20.920 --> 00:00:22.440
Hello, glad to be here.


00:00:22.440 --> 00:00:24.000
Yeah, it's really great to have you here.


00:00:24.000 --> 00:00:26.200
It's going to be wonderful to hear your opinion,


00:00:26.200 --> 00:00:28.080
your perspective on some of these things


00:00:28.080 --> 00:00:29.560
that we're sharing this week.


00:00:25.640 --> 00:00:30.640
So welcome to the show.


00:00:30.640 --> 00:00:31.960
And this episode is brought to you by Datadog.


00:00:31.960 --> 00:00:34.160
Check them out at pythonbytes.fm/datadog.


00:00:34.160 --> 00:00:36.760
More on that later.


00:00:36.760 --> 00:00:38.180
Brian, what do you got?


00:00:38.180 --> 00:00:39.060
What's up first?


00:00:39.060 --> 00:00:39.720
Well, I've been thinking a lot about community lately, actually.


00:00:39.720 --> 00:00:42.880
And one of the things that came out recently,


00:00:42.880 --> 00:00:45.240
this was a little bit ago, but it's still fairly new,


00:00:45.240 --> 00:00:48.400
is the Django project announced a new governance model.


00:00:48.400 --> 00:00:51.680
It's been going on,


00:00:51.680 --> 00:00:52.940
I mean, I think they've been working on it for a couple years,


00:00:50.760 --> 00:00:53.080
since at least 2018.


00:00:53.080 --> 00:00:54.760
Some of the specifics are interesting.


00:00:54.760 --> 00:00:58.560
They had like a core team that they dissolved the core team


00:00:58.560 --> 00:01:00.920
and they mainly kind of have a new role


00:01:00.920 --> 00:01:04.580
called a merger person, which they have commit access


00:01:04.580 --> 00:01:06.680
but they only merge pull requests.


00:01:06.680 --> 00:01:10.000
So most of the changes could happen in the pull requests


00:01:10.000 --> 00:01:11.980
and the discussion that happens there.


00:01:11.980 --> 00:01:15.580
There is a technical board also that was kept


00:01:15.580 --> 00:01:18.380
to kind of make some technical decisions


00:01:18.380 --> 00:01:19.960
if it's necessary,


00:01:19.960 --> 00:01:22.360
but apparently it hasn't been necessary for a while.


00:01:22.360 --> 00:01:26.340
I think it's interesting that they switched the governance model midstream.


00:01:26.340 --> 00:01:30.240
And then also the rationale around it, I think is interesting.


00:01:30.240 --> 00:01:35.480
And the rationale is around trying to get more people contributing to it.


00:01:35.480 --> 00:01:39.080
So they had like their core team and that hadn't really changed for a long time.


00:01:39.080 --> 00:01:44.140
And people that were set up as core people really weren't contributing much anymore.


00:01:44.140 --> 00:01:48.360
Anyway, I just thought that was interesting that they, the reason around,


00:01:48.700 --> 00:01:52.700
changing the governance was around the trying to get new people in.


00:01:52.700 --> 00:01:58.300
Yeah, I think that's a great idea because, you know, Django has been around for a long time and it's a fairly stable project.


00:01:58.300 --> 00:02:00.500
So I think it's kind of hard to jump in.


00:02:00.500 --> 00:02:02.800
I mean, it's a little bit like Python itself, Guido.


00:02:02.800 --> 00:02:09.900
Right. I'm thinking that sort of maybe five years in the future, Python could consider a similar move,


00:02:09.900 --> 00:02:15.200
or maybe we'll know that this was not the right move by then from Django's experience.


00:02:15.200 --> 00:02:21.200
And of course, the situation for the two projects is somewhat different, but we definitely also


00:02:21.200 --> 00:02:26.840
feel the pain of sort of not getting enough new contributors.


00:02:26.840 --> 00:02:32.840
But we only fairly recently, like early last year, we changed our governance structure


00:02:32.840 --> 00:02:33.840
completely.


00:02:33.840 --> 00:02:37.960
So it's a little early to start considering changing it again, probably.


00:02:37.960 --> 00:02:42.640
Right, of course, we're just starting to see the outcome of the decisions and the releases


00:02:42.640 --> 00:02:44.840
that are actually going through that model, right?


00:02:44.840 --> 00:02:49.840
We've been working with the steering council model for, say, 16 months now.


00:02:49.840 --> 00:02:53.140
Yeah, I guess so, 3.8 definitely came out under that model.


00:02:53.140 --> 00:02:58.240
The thing that Python did that I think is kind of interesting, and I don't know if you started it, but


00:02:58.240 --> 00:03:03.240
the notion of having more core mentors to try to mentor new core developers,


00:03:03.240 --> 00:03:05.640
I think that's an interesting thing that,


00:03:05.640 --> 00:03:08.740
you can't really make people be mentors, but


00:03:08.740 --> 00:03:11.440
that's an interesting way to get more core developers on.


00:03:11.440 --> 00:03:17.560
We have a few people who are very active as mentors in addition to being active as core devs.


00:03:17.560 --> 00:03:19.840
And it really does make a difference.


00:03:19.840 --> 00:03:27.080
Yeah, we don't have enough mentors to mentor everyone who wants to become a core dev.


00:03:27.080 --> 00:03:27.760
Yeah, yeah.


00:03:27.760 --> 00:03:38.400
So I think that's a really great, I mean, it's one thing to write web apps in Django, or to write Python code, it's an entirely different thing to write Django or write Python, right?


00:03:38.400 --> 00:03:40.360
It's a very different skill set.


00:03:40.360 --> 00:03:43.560
And so I think that mentor model is really a great bridge.


00:03:43.560 --> 00:03:44.400
- Yeah, that'd be cool.


00:03:44.400 --> 00:03:46.160
- Yeah, so speaking of things


00:03:46.160 --> 00:03:47.560
I think are going to be really helpful,


00:03:47.560 --> 00:03:49.240
but in a much simpler way,


00:03:49.240 --> 00:03:52.780
this is sort of a data science topic for everyone out there.


00:03:52.780 --> 00:03:55.040
And one of the problems in data science


00:03:55.040 --> 00:03:58.600
is you can end up with very large data sets,


00:03:58.600 --> 00:04:01.700
complicated data, but every now and then


00:04:01.700 --> 00:04:05.240
there might be a none where you expected an integer,


00:04:05.240 --> 00:04:07.960
or there might be a empty string where you expected a date,


00:04:07.960 --> 00:04:08.780
or something like that.


00:04:08.780 --> 00:04:11.780
and understanding how that data is,


00:04:11.780 --> 00:04:13.440
or how complete it is,


00:04:13.440 --> 00:04:16.520
where is it more incomplete than less complete,


00:04:16.520 --> 00:04:19.320
right, or more or less, and so on.


00:04:19.320 --> 00:04:21.800
So there's this cool project called Missing No,


00:04:21.800 --> 00:04:24.500
which I think is missing number, right, shortened.


00:04:24.500 --> 00:04:27.720
And the idea is it's a missing data visualization module


00:04:27.720 --> 00:04:28.640
for Python.


00:04:28.640 --> 00:04:31.160
And you too can see the picture in the show notes


00:04:31.160 --> 00:04:32.880
and folks who listen to this,


00:04:32.880 --> 00:04:35.900
they can go back and see it in the show notes as well.


00:04:35.900 --> 00:04:38.880
But it's a really cool and simple little library,


00:04:38.880 --> 00:04:40.900
but it's not just show me a quick graph.


00:04:40.900 --> 00:04:43.460
It actually does some pretty powerful analysis.


00:04:43.460 --> 00:04:46.740
So what you can do is if you've got some pandas data,


00:04:46.740 --> 00:04:49.620
you can just go to it and say msno.matrix


00:04:49.620 --> 00:04:51.500
and give it a sample of your data.


00:04:51.500 --> 00:04:53.420
And it gives you these really cool graphs


00:04:53.420 --> 00:04:56.100
with vertical, either black or white bars,


00:04:56.100 --> 00:04:58.500
or bars that are kind of zebra striped,


00:04:58.500 --> 00:05:01.100
depending on whether or not there's missing data.


00:05:01.100 --> 00:05:02.980
It shows you which parts,


00:05:02.980 --> 00:05:05.780
which columns are more complete or incomplete.


00:05:05.780 --> 00:05:08.100
And even as a little graph on the side


00:05:08.100 --> 00:05:09.900
that tells you the likelihood


00:05:09.900 --> 00:05:13.620
or the correlation of a row being incomplete, right?


00:05:13.620 --> 00:05:16.380
Like you might have a missing address on one line


00:05:16.380 --> 00:05:18.300
but then another one has a missing phone number


00:05:18.300 --> 00:05:19.660
or it could be more likely


00:05:19.660 --> 00:05:21.220
that those are both missing at the same time.


00:05:21.220 --> 00:05:23.500
There's like a little graph to visualize that kind of stuff.


00:05:23.500 --> 00:05:24.340
What do you guys think?


00:05:24.340 --> 00:05:25.380
- I think it's very cool.


00:05:25.380 --> 00:05:29.500
I'm not a data anything person myself.


00:05:29.500 --> 00:05:34.420
So to indicate how much I am not in the target audience


00:05:34.420 --> 00:05:39.340
for this module. The whole time I read your modules I had the grouping wrong.


00:05:39.340 --> 00:05:46.220
I thought it was the missing data visualization module. And I thought well


00:05:46.220 --> 00:05:50.100
that's kind of cool that they say there's something missing and


00:05:50.100 --> 00:05:55.180
this clearly is the one that's... now it's turned up but it's actually


00:05:55.180 --> 00:05:59.620
visualizing missing data which actually I understand what that is. I've seen a


00:05:59.620 --> 00:06:06.100
spreadsheet or two and I can actually even understand the little example chart that you


00:06:06.100 --> 00:06:12.260
pasted into the notes without understanding anything else around it.


00:06:12.260 --> 00:06:16.020
Yeah, it's so wonderful because that's why I actually think I like this and I chose it


00:06:16.020 --> 00:06:19.940
is you can just look at that picture and go, "Oh, I basically get a sense for what this data is


00:06:19.940 --> 00:06:24.900
like. It's complete, it's not complete, it's mostly incomplete on this column or whatever."


00:06:24.900 --> 00:06:39.420
And yeah, it's really nice. And I suspect you could, if you had data, say, in like a database or a file or something, you could probably just read that into a pandas data frame and then throw it out here and visualize like database missing data or file missing data or whatever. But it's really nice.


00:06:39.420 --> 00:06:53.740
Yeah, for large data sets, one of the things you got to do is to decide when you're cleaning it up what to do with the missing data. And there's I mean, there's some nones or whatever. There's some strategies to either fill it in with interleaved data or something or,


00:06:54.060 --> 00:06:57.060
or just throw those rows completely away.


00:06:57.060 --> 00:07:00.860
But you don't really know how much data you're throwing away


00:07:00.860 --> 00:07:02.460
without visualizing it.


00:07:02.460 --> 00:07:03.560
So this is pretty cool.


00:07:03.560 --> 00:07:04.560
I think this is great.


00:07:04.560 --> 00:07:06.560
Yeah, and it has other visualizations as well.


00:07:06.560 --> 00:07:08.960
It has heat maps, which are like correlations.


00:07:08.960 --> 00:07:13.260
So like address and phone number correlated kind of things I was talking about.


00:07:13.260 --> 00:07:14.560
It has bar charts.


00:07:14.560 --> 00:07:19.660
And the most interesting or unique visualization is the dendogram,


00:07:19.660 --> 00:07:20.760
which I had never heard of,


00:07:20.760 --> 00:07:23.860
but this is a hierarchical clustering algorithm from SciPy, actually.


00:07:23.860 --> 00:07:30.860
and it creates this kind of like hierarchical tree of relationships of missing data.


00:07:30.860 --> 00:07:35.860
If you are worried about cleaning up data or stuff like that, or visualizing how good your data is,


00:07:35.860 --> 00:07:38.860
you could throw it at this real quick and get some great answers.


00:07:38.860 --> 00:07:39.860
Yeah, that's cool.


00:07:39.860 --> 00:07:43.860
Guido, you have been busy with the Language Summit recently, right?


00:07:43.860 --> 00:07:44.860
What's the news there?


00:07:44.860 --> 00:07:49.860
Yes, well, normally the Language Summit basically is an in-person meeting


00:07:49.860 --> 00:07:55.500
meeting where about 50 people who are


00:07:55.500 --> 00:07:57.900
mostly but not exclusively core devs get


00:07:57.900 --> 00:08:00.900
together a day or two before the actual


00:08:00.900 --> 00:08:03.020
Python conference. Since the conference was


00:08:03.020 --> 00:08:05.020
canceled... This would have been in


00:08:05.020 --> 00:08:07.380
Pittsburgh, right? It would have been in


00:08:07.380 --> 00:08:09.300
Pittsburgh this year, right. Obviously the


00:08:09.300 --> 00:08:11.900
conference was canceled and the language


00:08:11.900 --> 00:08:14.220
summit was too and then the two


00:08:14.220 --> 00:08:16.020
organizers thought, well, okay, this


00:08:16.020 --> 00:08:18.660
sounds like the kind of meeting that we can


00:08:16.020 --> 00:08:21.180
actually try to do on Zoom. You can't have a whole conference on Zoom, but you


00:08:21.180 --> 00:08:25.220
can probably have a meeting with 50 people on Zoom. And they tweak the


00:08:25.220 --> 00:08:32.580
format a bit so that, I mean, you can't be on Zoom for an entire day. I find


00:08:32.580 --> 00:08:38.660
Zoom incredibly intense and after an hour of Zooming I'm usually ready for a


00:08:38.660 --> 00:08:43.220
break. Yeah, all the virtual stuff takes a lot more attention. Yeah. Yeah. User


00:08:43.220 --> 00:08:49.860
user interface sucks, privacy probably sucks, but it clearly serves its purpose.


00:08:49.860 --> 00:08:55.300
So we had it spread over two different days and then in addition, because nobody was traveling


00:08:55.300 --> 00:08:58.600
to Pittsburgh, we spread it out in time.


00:08:58.600 --> 00:09:04.700
One day it was really early for me so that we could also have participants from Europe


00:09:04.700 --> 00:09:10.380
and one day it was really late for me so that we could have some people from Australia join


00:09:10.380 --> 00:09:11.940
us.


00:09:11.940 --> 00:09:16.740
of the organizers lives in Poland and he was there till the end on both days.


00:09:16.740 --> 00:09:19.780
So I didn't know who slept.


00:09:19.780 --> 00:09:25.140
Yeah, so as usual, the format wasn't actually all that different.


00:09:25.140 --> 00:09:33.740
It's typically like half hour slots for various topics that are important to either get information


00:09:33.740 --> 00:09:39.180
to core devs and usually also get feedback from core devs.


00:09:39.180 --> 00:09:41.500
And we pretty much stuck to that format.


00:09:41.500 --> 00:09:46.080
The one big thing that you miss, of course, is all the whispering to the guy who was sitting


00:09:46.080 --> 00:09:52.960
next to you or during the break, quickly grabbing three other people and having a little huddle


00:09:52.960 --> 00:09:53.960
about a topic.


00:09:53.960 --> 00:09:56.880
Yeah, that's what's so powerful about in-person conferences.


00:09:56.880 --> 00:10:02.500
Yeah, we missed the entire hallway track, but it was still good to have sort of short


00:10:02.500 --> 00:10:05.820
presentations and Q&A sessions.


00:10:05.820 --> 00:10:09.440
And the Q&A sessions actually worked really well.


00:10:09.440 --> 00:10:14.800
was a little tool that you can use to sort of moderate questions and Lukáš


00:10:14.800 --> 00:10:20.160
was like running the moderation tool and nobody was asking spam questions


00:10:20.160 --> 00:10:25.680
so all you had to do was just click OK for every question I think.


00:10:25.680 --> 00:10:31.200
That tool is much more structured than the chat channel on Zoom could be and sort of


00:10:31.200 --> 00:10:35.440
raising your hand on Zoom and waving doesn't really work if there are 50


00:10:35.440 --> 00:10:39.640
people because there's no way to see more than 16 people or so at the time.


00:10:39.640 --> 00:10:39.960
Yeah.


00:10:39.960 --> 00:10:45.960
So anyway, the first day, each day there were like maybe five topics and a few


00:10:45.960 --> 00:10:47.400
miscellaneous things.


00:10:47.400 --> 00:10:51.320
Shall I just go over each day briefly?


00:10:51.320 --> 00:10:53.280
See if I can sort of run them all off.


00:10:53.280 --> 00:10:53.680
Yeah.


00:10:53.680 --> 00:10:57.760
I would say just maybe touch really quickly on just the things that you felt


00:10:57.760 --> 00:11:00.480
like really might make an impact going forward.


00:11:00.480 --> 00:11:01.280
Potentially.


00:11:01.360 --> 00:11:06.000
Just a one-liner guy who originally implemented f-strings


00:11:06.000 --> 00:11:10.800
gave a talk about whether maybe all strings should become f-strings


00:11:10.800 --> 00:11:14.720
and the general sentiment was that


00:11:14.720 --> 00:11:18.720
that would have been nice in Python 1.0 or so


00:11:18.720 --> 00:11:21.280
but there is no way, it would just break too much code.


00:11:21.280 --> 00:11:22.400
It's gonna break too much.


00:11:22.400 --> 00:11:25.600
I totally hear that though because I'm so often I'm typing in a string


00:11:25.600 --> 00:11:27.440
I'm like, oh I need to put a variable here


00:11:27.440 --> 00:11:29.280
but I've typed 20 characters in


00:11:29.280 --> 00:11:32.280
and then I got to go back to the beginning, but not the beginning of the line,


00:11:32.280 --> 00:11:34.960
because maybe that's what I got to get to the beginning of the string and then go,


00:11:34.960 --> 00:11:36.920
maybe we could even put the F at the end.


00:11:36.920 --> 00:11:37.360
Who knows?


00:11:37.360 --> 00:11:40.440
But yeah, I would love to see it, but it's, I totally understand.


00:11:40.440 --> 00:11:42.000
You can't do that without breaking stuff.


00:11:42.000 --> 00:11:46.680
There are downsides to automatically doing it too, because curly braces are.


00:11:46.680 --> 00:11:50.080
Useful for all sorts of things besides formatting.


00:11:50.080 --> 00:11:53.520
So that was sort of the opening salvo.


00:11:53.560 --> 00:12:01.200
Then my two co-conspirators on the PEG parsing project gave a talk about how


00:12:01.200 --> 00:12:06.000
we're going to hopefully introduce a new parser in Python 3.9.


00:12:06.000 --> 00:12:11.640
And we've been coding for like almost a year now, probably.


00:12:11.640 --> 00:12:17.160
It started out as a little hobby project of mine and gradually became more serious


00:12:17.160 --> 00:12:19.000
and more people started helping out.


00:12:19.700 --> 00:12:24.420
and the last few months we've been doing heavy engineering work


00:12:24.420 --> 00:12:28.740
to actually prepare for the integration but we didn't have steering council


00:12:28.740 --> 00:12:31.140
approval yet we made it a pep and we sort of


00:12:31.140 --> 00:12:34.820
said well this is a nice thing but we're not going to do this


00:12:34.820 --> 00:12:41.300
unless there is sort of clear consensus or at least general agreement


00:12:41.300 --> 00:12:47.860
that we are going to do this and so very soon after the summit the steering


00:12:47.860 --> 00:12:53.060
council actually had a meeting and approved a bunch of peps and ours was one of them.


00:12:53.060 --> 00:12:58.500
And then the last two days I've been stressing out because we wanted to get the new parts


00:12:58.500 --> 00:13:01.940
or in the alpha six release, which is going out tomorrow.


00:13:01.940 --> 00:13:09.020
And so we're now in the last, the very last stretches of preparing for alpha six, and


00:13:09.020 --> 00:13:14.060
we're just deleting or disabling tests that are still failing that we, we know how to


00:13:14.060 --> 00:13:15.940
fix them, but we just don't have the time.


00:13:15.940 --> 00:13:16.300
Right.


00:13:16.340 --> 00:13:18.660
That's exciting that this project is going to be in there. That's great.


00:13:18.660 --> 00:13:23.540
Yeah, so that's the new parser and if all goes well, nobody will notice a thing.


00:13:23.540 --> 00:13:24.540
Ideally.


00:13:24.540 --> 00:13:29.580
What are the effects? Is it going to speed things up or make things more maintainable?


00:13:29.580 --> 00:13:37.140
It's going to sort of open up the grammar for future changes to the language


00:13:37.140 --> 00:13:42.220
that we currently can't do because the old LL1 parser holds us back.


00:13:42.220 --> 00:13:43.020
Okay.


00:13:43.020 --> 00:13:46.060
That's sort of the main motivation.


00:13:46.060 --> 00:13:46.560
Super.


00:13:46.560 --> 00:13:50.740
There was one interesting talk about something called HPy,


00:13:50.740 --> 00:13:56.540
which is a proposal for a new, more portable API,


00:13:56.540 --> 00:14:02.280
and in particular focused on other Python implementations besides CPython.


00:14:02.280 --> 00:14:03.340
As you may know,


00:14:03.340 --> 00:14:10.420
PyPy has been struggling for over a decade with compatibility with extension modules.


00:14:10.420 --> 00:14:15.320
And the HPy proposal is basically, instead of pointers to objects,


00:14:15.320 --> 00:14:18.840
you have handles, which is a pointer to a pointer to an object.


00:14:18.840 --> 00:14:25.720
And there's a whole API around handles that is equivalent to the existing API,


00:14:25.720 --> 00:14:28.400
but it allows different styles of garbage collection.


00:14:28.400 --> 00:14:34.360
For example, you could implement a garbage collector that moves objects behind your back occasionally.


00:14:34.360 --> 00:14:37.440
Right, you might get a generational compacting garbage collector,


00:14:37.440 --> 00:14:42.760
because you could update the value of the pointer, pointer without changing the actual pointer, right?


00:14:42.760 --> 00:14:44.800
Yeah, yeah, that's actually really exciting.


00:14:44.840 --> 00:14:50.240
Yeah, and it's still in early stages I believe, but it looks pretty promising.


00:14:50.240 --> 00:14:57.400
Eric Snow gave a lightning talk about a sort of a retrospective of all his work on multi-core support


00:14:57.400 --> 00:15:04.040
which is now beginning to conclude, well maybe it's too soon to call it a conclusion


00:15:04.040 --> 00:15:11.640
but we're going to have sub-interpreters with a much better API either in 3.9 or in 3.10


00:15:11.640 --> 00:15:17.400
There's a pep around that 554, which will definitely be moving forward,


00:15:17.400 --> 00:15:23.760
but whether it's considered mature enough to go to land in 3.9 is not entirely clear.


00:15:23.760 --> 00:15:25.800
>> Yeah. Eric's work is very interesting there.


00:15:25.800 --> 00:15:27.880
>> Yeah. In 3.10,


00:15:27.880 --> 00:15:31.880
we will probably have separate gills per sub-interpreter.


00:15:31.880 --> 00:15:35.200
That is going to be a major new thing.


00:15:35.200 --> 00:15:37.560
Let's see, what else do we have?


00:15:37.560 --> 00:15:43.520
Well, so the next day I gave a talk about the future of typing, which oh, yeah, there's one detail


00:15:43.520 --> 00:15:50.120
You might remember that we introduced something called from Dunder future import annotations


00:15:50.120 --> 00:15:55.840
Which made it so that annotations are no longer evaluated at runtime. You can still


00:15:55.840 --> 00:16:01.020
Introspect them, but you'll get just get the string containing the annotation expression back


00:16:01.020 --> 00:16:03.340
Well, that's going to be the default in


00:16:04.320 --> 00:16:10.960
3.9 most likely. There's still a little debate about that, but there was like a two-thirds


00:16:10.960 --> 00:16:17.120
preference for just making that the default in 3.9. And various people argued effectively


00:16:17.120 --> 00:16:19.880
that nobody should notice any difference.


00:16:19.880 --> 00:16:26.680
I'm really excited or happy to have typing in the language. It makes such a difference


00:16:26.680 --> 00:16:31.120
for the right use case, you know, on defining the boundary of APIs or making the editor


00:16:31.120 --> 00:16:33.640
understand something better when it otherwise wouldn't.


00:16:33.640 --> 00:16:39.320
If you're maintaining tens of thousands of lines of Python code or more, type annotations


00:16:39.320 --> 00:16:40.920
really make a difference.


00:16:40.920 --> 00:16:41.920
Yeah, for sure.


00:16:41.920 --> 00:16:44.680
I still don't recommend teaching them to beginners though.


00:16:44.680 --> 00:16:45.680
Oh really?


00:16:45.680 --> 00:16:46.680
Okay.


00:16:46.680 --> 00:16:47.800
It depends on what kind of beginners you have.


00:16:47.800 --> 00:16:52.800
If they're sort of recuperating Java programmers, maybe you should introduce them.


00:16:52.800 --> 00:16:57.320
But if they're like actually blank slate, this is the first time they're programming


00:16:57.320 --> 00:17:00.160
ever, I wouldn't bother with them with annotations.


00:17:00.160 --> 00:17:02.680
Yeah, I kind of agree with that.


00:17:02.680 --> 00:17:10.200
What's sort of still missing for the data science world is extensions to the type system


00:17:10.200 --> 00:17:14.480
for NumPy and Pandas and stuff like that.


00:17:14.480 --> 00:17:22.200
There's a design, but there are not enough people with available time to actually implement


00:17:22.200 --> 00:17:23.200
the design.


00:17:23.200 --> 00:17:28.800
And I'm sure that when you're halfway through implementation, all sorts of interesting issues


00:17:28.800 --> 00:17:30.400
with the design will prop up.


00:17:30.400 --> 00:17:35.160
So the design is not final until it's been implemented.


00:17:35.160 --> 00:17:36.520
Last two topics.


00:17:36.520 --> 00:17:44.520
Zach Hatfield Dodds gave a very good talk about what he calls property-based testing


00:17:44.520 --> 00:17:52.800
and which really is about a tool named Hypothesis that introduces testing approach that I think


00:17:52.800 --> 00:18:00.220
was first developed in academia for Haskell that works in a completely different way than


00:18:00.220 --> 00:18:02.700
your typical unit test based testing.


00:18:02.700 --> 00:18:05.900
Right, the tool decides, right? Instead of examples.


00:18:05.900 --> 00:18:11.820
The tool generates test cases and I've never played with it myself,


00:18:11.820 --> 00:18:16.860
but the talk sort of made me very excited to play around with it more.


00:18:16.860 --> 00:18:21.740
And it actually, even though it's a very different approach than unit test or


00:18:21.740 --> 00:18:25.740
pytest based testing, it will still integrate with that.


00:18:25.740 --> 00:18:29.500
I mean, you can write a unit test and then put some decorator on top of it


00:18:29.500 --> 00:18:38.700
that produces test data and Hypothesis has all kinds of really advanced stuff for exploring


00:18:38.700 --> 00:18:46.780
enormous spaces of possible input data and quickly finding bugs. Do you think we'll get to a place


00:18:46.780 --> 00:18:53.180
where we are able to use Hypothesis for some of the testing for the standard library? That was


00:18:53.180 --> 00:18:59.820
one of the propositions that Zach made. I think it's still early for that.


00:18:59.820 --> 00:19:07.340
I think it's much easier to introduce hypothesis in sort of a new project where you haven't yet


00:19:07.340 --> 00:19:15.820
written all the code and all the tests than it is to retrofit it in a large mature or maybe even


00:19:15.820 --> 00:19:21.980
somewhat dementing project. I think it'll be a while before we'll have testing it for the


00:19:21.980 --> 00:19:26.940
hypothesis-based testing for the standard library, just like it'll be a while before we'll have


00:19:26.940 --> 00:19:33.820
annotations in the standard library rather than annotations sort of separate from the standard


00:19:33.820 --> 00:19:40.860
library. The last talk I want to highlight and then I'm really done with this is also a very


00:19:40.860 --> 00:19:49.180
good talk by Russell Keith McGee about the state of Beware and Python for Mobile. And one of his


00:19:49.180 --> 00:19:54.980
suggestions was that we adopt some of his mega patches that he's currently


00:19:54.980 --> 00:19:59.900
being maintaining for several Python releases that would make Python at


00:19:59.900 --> 00:20:05.280
least compile out of the box or nearly out of the box for the important mobile


00:20:05.280 --> 00:20:06.180
platforms.


00:20:06.180 --> 00:20:06.780
That'd be cool.


00:20:06.780 --> 00:20:10.420
Yeah, it'd be so wonderful to have Python as an option for mobile. It


00:20:10.420 --> 00:20:13.740
would really would bust open the doors and create even more growth.


00:20:13.760 --> 00:20:22.400
Many people believe that sort of mobile platforms are obviously continuing to grow in importance and to grow in power.


00:20:22.400 --> 00:20:26.760
And we'd be crazy if we didn't support Python on those.


00:20:26.760 --> 00:20:30.280
And it may be very important for Python's very survival.


00:20:30.280 --> 00:20:30.780
Yeah.


00:20:30.780 --> 00:20:34.960
Yeah, I saw the block swan talk that Russell Keith McGee gave and it was compelling.


00:20:34.960 --> 00:20:36.720
He is an amazing speaker, for sure.


00:20:36.720 --> 00:20:37.260
Yeah.


00:20:37.260 --> 00:20:38.320
Yeah, that's what I have.


00:20:38.320 --> 00:20:38.600
Great.


00:20:38.600 --> 00:20:40.040
And thank you so much for that insight.


00:20:40.040 --> 00:20:41.320
That was, that was awesome.


00:20:41.400 --> 00:20:44.120
A lot of people don't get to see the behind the scenes.


00:20:44.120 --> 00:20:46.520
They just see what's announced when it comes out, right?


00:20:46.520 --> 00:20:48.280
Before we move on, let me tell you about our sponsor,


00:20:48.280 --> 00:20:49.240
Datadog.


00:20:49.240 --> 00:20:52.040
This episode is brought to you by Datadog.


00:20:52.040 --> 00:20:53.280
So let me ask you a question.


00:20:53.280 --> 00:20:55.240
Do you have an app in production that's slower


00:20:55.240 --> 00:20:56.080
than you like?


00:20:56.080 --> 00:20:57.280
Is its performance all over the place?


00:20:57.280 --> 00:20:59.320
Sometimes fast, sometimes slow.


00:20:59.320 --> 00:21:00.580
Now here's the important question.


00:21:00.580 --> 00:21:01.760
Do you know why?


00:21:01.760 --> 00:21:03.400
With Datadog, you will.


00:21:03.400 --> 00:21:04.920
You can troubleshoot your app's performance


00:21:04.920 --> 00:21:06.840
with Datadog's end-to-end tracing,


00:21:06.840 --> 00:21:09.120
use detailed flame graphs, identify bottlenecks


00:21:09.120 --> 00:21:10.720
and latency in that finicky app of yours.


00:21:10.720 --> 00:21:13.120
So be the hero that got the app back on track


00:21:13.120 --> 00:21:14.200
at your company.


00:21:14.200 --> 00:21:15.680
Get started with a free trial over at


00:21:15.680 --> 00:21:18.000
pythonbytes.fm/datadog.


00:21:18.000 --> 00:21:19.440
Get a cool t-shirt as well.


00:21:19.440 --> 00:21:21.120
Brian, you've got another one that kind of


00:21:21.120 --> 00:21:22.280
ties into your first one, right?


00:21:22.280 --> 00:21:24.320
But it's sort of the other side of the coin, maybe?


00:21:24.320 --> 00:21:26.620
I don't know what's been happening in the Python world


00:21:26.620 --> 00:21:29.320
that you sort of orbit in that might make you


00:21:29.320 --> 00:21:31.040
think about these things, but tell us about it.


00:21:31.040 --> 00:21:33.000
- No, I've just been thinking about community


00:21:33.000 --> 00:21:37.960
and codes of contact and enforcement for codes of contact.


00:21:37.960 --> 00:21:40.960
No reason really, just kind of an interesting topic.


00:21:40.960 --> 00:21:44.480
One of the things I've been thinking about is, especially when researching this, the


00:21:44.480 --> 00:21:48.680
codes of conduct and enforcement of it and how we treat people.


00:21:48.680 --> 00:21:52.480
I first thought it was really important for open source projects, and it definitely is


00:21:52.480 --> 00:21:56.480
because people have the option to just leave and get out of the project.


00:21:56.480 --> 00:22:01.380
So you really want to treat people well so they stick around and have it be welcoming


00:22:01.380 --> 00:22:02.380
to other people.


00:22:02.380 --> 00:22:04.760
But I don't think industry is really that different.


00:22:04.760 --> 00:22:07.760
I think that people have the ability to just get another job,


00:22:07.760 --> 00:22:09.760
so or work on a different project.


00:22:09.760 --> 00:22:12.160
So I think these are important for industry as well.


00:22:12.160 --> 00:22:16.860
I took a look at two sets of codes of conduct and the enforcement of those.


00:22:16.860 --> 00:22:19.560
So the PSF has a code of conduct.


00:22:19.560 --> 00:22:23.960
I'm not going to read them all out, but there's things like being open, being friendly.


00:22:23.960 --> 00:22:28.360
And in there, there's a list of inappropriate behaviors as well that's covered.


00:22:28.360 --> 00:22:30.960
Now, also the Django code of conduct.


00:22:30.960 --> 00:22:33.560
They also have all of these when you read them.


00:22:33.560 --> 00:22:36.560
There are differences, but when you read them, they kind of sound the same.


00:22:36.560 --> 00:22:42.040
One of the things they highlight in the Django one is be careful with your choice.


00:22:42.040 --> 00:22:48.600
Choice of words, including, and they include examples of harassment,


00:22:48.600 --> 00:22:51.900
speech and exclusionary behavior that's not appropriate.


00:22:51.900 --> 00:22:55.000
One of the big differences I saw was the enforcement.


00:22:55.000 --> 00:23:03.400
So the PSF is a two third majority vote enforcement sort of thing to like make sure if something happens, like if they want to kick somebody


00:23:03.400 --> 00:23:08.400
or put them on probation or something.


00:23:08.400 --> 00:23:10.400
I think that's really important,


00:23:10.400 --> 00:23:11.400
because if you require 100% majority


00:23:11.400 --> 00:23:14.400
and somebody who is on the team that decides


00:23:14.400 --> 00:23:17.400
is potentially part of the problem,


00:23:17.400 --> 00:23:19.400
then what do you do?


00:23:19.400 --> 00:23:21.400
It's really tricky.


00:23:21.400 --> 00:23:23.400
If people are just going to abandon a project,


00:23:23.400 --> 00:23:25.400
you would rather have just a strong majority


00:23:25.400 --> 00:23:28.400
make a decision.


00:23:28.400 --> 00:23:29.400
I also think that PSF has probably got a larger,


00:23:29.400 --> 00:23:32.400
possibly is a larger working group on this,


00:23:29.400 --> 00:23:33.900
and is more, I guess, maybe harder to get a hold of people.


00:23:33.900 --> 00:23:38.900
Maybe it's easier to get a two-thirds than, maybe you can't even reach all 100% of the group.


00:23:38.900 --> 00:23:44.900
But anyway, the other interesting difference is the PSF code of conduct seems to,


00:23:44.900 --> 00:23:52.400
I know it does cover online interaction as well as events like the conferences and meetups and stuff.


00:23:52.400 --> 00:23:57.900
But I'd possibly, at least I think that maybe it's focus might be more on events.


00:23:57.900 --> 00:24:03.140
whereas the Django code of conduct is specifically targeted towards online interactions.


00:24:03.140 --> 00:24:07.020
I would say for the PSF that sort of historically,


00:24:07.020 --> 00:24:13.420
events were the first place where codes of conduct were introduced,


00:24:13.420 --> 00:24:19.940
but we've been using them for online forums more and more in the past few years.


00:24:19.940 --> 00:24:23.780
Okay. One of the interesting things with the Django one is that


00:24:23.780 --> 00:24:27.780
a single person on the committee can act without


00:24:27.780 --> 00:24:31.780
collaborating with anybody else if it's an ongoing problem


00:24:31.780 --> 00:24:35.780
or if there's a threat involved or something. They still have to go


00:24:35.780 --> 00:24:39.780
through the process of notifying everybody else, but there is an interesting thing


00:24:39.780 --> 00:24:43.780
that one person on the committee can intervene right away. I'm not saying one


00:24:43.780 --> 00:24:47.780
is better than the other, or I just think it's interesting and I think it's important


00:24:47.780 --> 00:24:51.780
for new projects to think about, not just their code of conduct


00:24:51.780 --> 00:24:56.780
but how they're going to enforce it, and what the timeline.


00:24:56.780 --> 00:24:59.780
The Django one also includes some timelines,


00:24:59.780 --> 00:25:01.780
which is interesting.


00:25:01.780 --> 00:25:03.780
I would really like to make sure that projects


00:25:03.780 --> 00:25:06.780
practice, maybe figure out what they're going to do


00:25:06.780 --> 00:25:09.780
if they need to enact one of these things.


00:25:09.780 --> 00:25:13.780
Before it becomes a problem, they know what they're going to do.


00:25:13.780 --> 00:25:16.780
There's a lot of stuff going on with some projects out there,


00:25:16.780 --> 00:25:18.780
so having a couple of examples and side-by-side comparisons


00:25:16.780 --> 00:25:21.780
comparisons, I think is great.


00:25:21.780 --> 00:25:23.460
I was interested to find out our meetup,


00:25:23.460 --> 00:25:25.460
like the Python meetup that we started,


00:25:25.460 --> 00:25:27.260
which is on hold right now, unfortunately,


00:25:27.260 --> 00:25:29.300
because of the virus and quarantine and stuff.


00:25:29.300 --> 00:25:31.900
But because we were getting support


00:25:31.900 --> 00:25:34.740
from the Python Software Foundation


00:25:34.740 --> 00:25:36.480
to help pay for the meetup fees and stuff,


00:25:36.480 --> 00:25:38.860
we had to list a code of conduct


00:25:38.860 --> 00:25:41.140
on our meetup page and stuff like that.


00:25:41.140 --> 00:25:42.940
Yeah, that makes a lot of sense,


00:25:42.940 --> 00:25:43.980
but I didn't realize that.


00:25:43.980 --> 00:25:44.860
Yeah, the PSF has been doing that for a few years now.


00:25:43.380 --> 00:25:47.220
That's really great. All right, this next one I want to cover. It goes back a ways,


00:25:47.220 --> 00:25:52.260
but I think it's really fun. And it's something also I think ties together well with our special


00:25:52.260 --> 00:25:58.580
guest here. And this is an article about myths about indentation. And Guido, I picked this one


00:25:58.580 --> 00:26:02.580
because you were talking about this on Twitter just the other day. What was the motivation to


00:26:02.580 --> 00:26:07.700
throw that out there? That is a good question. I was just going to volunteer the answer because


00:26:07.700 --> 00:26:14.980
Apparently, I had a link to that article on my homepage in some odd corner.


00:26:14.980 --> 00:26:18.500
And I have a very, very sort of ready old homepage.


00:26:18.500 --> 00:26:22.300
It's moved it to GitHub pages, but it looks like web 1.0.


00:26:22.300 --> 00:26:25.580
And because it really is, I just added raw HTML.


00:26:25.580 --> 00:26:26.980
It blends in right with Netscape, huh?


00:26:26.980 --> 00:26:36.580
So someone reported to me a broken link, which happens like, I don't know, once every four years or so.


00:26:36.580 --> 00:26:41.700
someone reported a broken link. Oh wait, it wasn't even on my homepage. It was on an old blog that


00:26:41.700 --> 00:26:46.900
I can no longer edit at artema.com. I'm very glad that that blog is still online. But so,


00:26:46.900 --> 00:26:54.820
because I got the report of the broken link, I decided, oh, I'm sure I can still find on archive.org


00:26:54.820 --> 00:27:01.300
where that link used to point. And sure enough, it was there. And I thought, oh, that's actually


00:27:01.300 --> 00:27:05.620
still a neat little article. So I thought, okay, tweet of the day or tweet of the week.


00:27:05.620 --> 00:27:07.980
- Yeah, I agree, and I think it's interesting as well.


00:27:07.980 --> 00:27:08.980
And just to give you a sense


00:27:08.980 --> 00:27:10.260
of why it might have disappeared,


00:27:10.260 --> 00:27:12.460
it was one of those types of sites


00:27:12.460 --> 00:27:17.460
where the domain or the URL included a tilde username path,


00:27:17.460 --> 00:27:19.740
like you used to get in university


00:27:19.740 --> 00:27:21.420
or whatever way back when.


00:27:21.420 --> 00:27:24.940
So anyway, this one is myths about indentation for Python.


00:27:24.940 --> 00:27:29.220
And for people who come from a C-oriented language,


00:27:29.220 --> 00:27:32.940
I think Python could come across a little bit funky.


00:27:32.940 --> 00:27:34.340
I actually want to share a little story


00:27:34.340 --> 00:27:38.140
just sort of my journey with it, and how I came to love this.


00:27:38.140 --> 00:27:40.180
But I think this is really interesting for people


00:27:40.180 --> 00:27:43.660
having the debate about, is significant white space useful?


00:27:43.660 --> 00:27:44.220
Is it weird?


00:27:44.220 --> 00:27:44.780
Is it good?


00:27:44.780 --> 00:27:48.900
I did a ton of C++ and then C# development,


00:27:48.900 --> 00:27:50.220
and then JavaScript development.


00:27:50.220 --> 00:27:53.540
It was all about the curly brace languages, lots of symbols.


00:27:53.540 --> 00:27:55.100
And then I came to learn Python.


00:27:55.100 --> 00:27:56.460
And I loved Python right away.


00:27:56.460 --> 00:27:57.700
But it was weird to me.


00:27:57.700 --> 00:27:58.660
I felt kind of naked.


00:27:58.660 --> 00:27:59.780
Like if I'd write an if statement,


00:27:59.780 --> 00:28:01.460
I'm like, I need some little parentheses


00:28:01.460 --> 00:28:03.200
to kind of hold the code in place.


00:28:03.200 --> 00:28:04.320
and why don't they need to be there?


00:28:04.320 --> 00:28:07.760
And I need a curly brace to say when this block of code


00:28:07.760 --> 00:28:08.880
is done and whatnot.


00:28:08.880 --> 00:28:10.480
It just took a little bit of getting used to,


00:28:10.480 --> 00:28:12.760
but I knew that it was the right thing for me,


00:28:12.760 --> 00:28:16.040
'cause when I went back to work on some older projects,


00:28:16.040 --> 00:28:17.920
I'm like, why are there symbols everywhere?


00:28:17.920 --> 00:28:19.720
What is all this stuff I have to keep typing?


00:28:19.720 --> 00:28:21.040
This is like a broken language.


00:28:21.040 --> 00:28:22.560
And it just took a couple of weeks for me


00:28:22.560 --> 00:28:25.200
to make that switch to feel like it was broken


00:28:25.200 --> 00:28:26.880
to go back to work in languages


00:28:26.880 --> 00:28:28.600
that I've been doing for like 10 years.


00:28:28.600 --> 00:28:30.800
So, well done with the white space, Guido.


00:28:30.800 --> 00:28:32.080
- Thanks. - Yeah.


00:28:32.080 --> 00:28:35.080
But so let's cover some of the things mentioned really quick in the article.


00:28:35.080 --> 00:28:38.380
One is that whitespace is significant in Python source code.


00:28:38.380 --> 00:28:41.900
And actually, no, not in general, is the answer.


00:28:41.900 --> 00:28:44.400
It's significant on the left.


00:28:44.400 --> 00:28:46.240
Right?


00:28:46.240 --> 00:28:51.080
So as much as you indent stuff, that really means things, but between variables,


00:28:51.080 --> 00:28:55.760
like whether you have like a equals seven or a space equals space seven, doesn't


00:28:55.760 --> 00:28:57.500
matter, you can have tons of spaces in there, right?


00:28:57.500 --> 00:29:01.760
Like any other language of spaces kind of don't matter except for on the left.


00:29:01.760 --> 00:29:03.920
So that's cool.


00:29:03.920 --> 00:29:06.720
And also the amount of indentation doesn't really matter.


00:29:06.720 --> 00:29:10.840
You could have five spaces for any code suite that you want


00:29:10.840 --> 00:29:13.360
or you could have 18 or you could go with a standard four.


00:29:13.360 --> 00:29:15.440
I recommend the four, but you know.


00:29:15.440 --> 00:29:19.280
And then also if you have something that defines


00:29:19.280 --> 00:29:23.100
like a list comprehension or an array creation


00:29:23.100 --> 00:29:24.420
or a dictionary, then all of a sudden


00:29:24.420 --> 00:29:26.000
the spacing doesn't matter anymore.


00:29:26.000 --> 00:29:27.760
As soon as you have like an open square bracket


00:29:27.760 --> 00:29:28.760
and then you have a bunch of stuff


00:29:28.760 --> 00:29:29.900
and then close square bracket,


00:29:29.900 --> 00:29:31.000
spacing doesn't matter in there.


00:29:31.000 --> 00:29:33.240
So I think this is interesting to think about


00:29:33.240 --> 00:29:36.000
as folks debate that maybe within their teams.


00:29:36.000 --> 00:29:37.600
It also, you could say it forces you


00:29:37.600 --> 00:29:39.720
to use a certain indentation style.


00:29:39.720 --> 00:29:41.040
Well, yes and no.


00:29:41.040 --> 00:29:44.200
If you wanted to write it single statement per line,


00:29:44.200 --> 00:29:46.280
then yeah, there's a cool example


00:29:46.280 --> 00:29:47.120
that they gave in the article.


00:29:47.120 --> 00:29:48.960
It's like if one plus one equals two,


00:29:48.960 --> 00:29:51.880
then new line print food, new line print bar,


00:29:51.880 --> 00:29:54.520
new line print, or just say X equals 42.


00:29:54.520 --> 00:29:57.320
You can also put them on multiple lines with semicolons.


00:29:57.320 --> 00:29:58.840
If you're really missing your semicolons


00:29:58.840 --> 00:30:00.560
from your language, you could do that.


00:30:00.560 --> 00:30:01.680
The thing that's interesting here,


00:30:01.680 --> 00:30:03.880
I think this is probably the most significant part


00:30:03.880 --> 00:30:05.680
of this article or this write-up is,


00:30:05.680 --> 00:30:07.520
if you look at it, it looks right.


00:30:07.520 --> 00:30:10.560
And when it gets parsed, it is right.


00:30:10.560 --> 00:30:14.500
There's an example of some C code that looks visually wrong


00:30:14.500 --> 00:30:18.400
because it's intended differently, but it's going to parse.


00:30:18.400 --> 00:30:21.060
But the way you see it when you read it


00:30:21.060 --> 00:30:23.240
is not what's actually happening.


00:30:23.240 --> 00:30:25.600
And I think there was a problem like this,


00:30:25.600 --> 00:30:29.440
well, I think it was in some either Objective-C


00:30:29.440 --> 00:30:31.880
There was something with Apple in there.


00:30:31.880 --> 00:30:32.960
It was really bad.


00:30:32.960 --> 00:30:35.560
There was an infamous Apple vulnerability.


00:30:35.560 --> 00:30:41.080
I think it might even have been on the iPhone where someone had added a second statement


00:30:41.080 --> 00:30:44.560
to a block, but it wasn't a block because there were no curlies.


00:30:44.560 --> 00:30:45.560
Right.


00:30:45.560 --> 00:30:51.500
Then it started out with a single conditional line, like if something indent, do the thing.


00:30:51.500 --> 00:30:54.240
And then they just indented, but they didn't put the curly braces in.


00:30:54.240 --> 00:30:57.920
And it was, yeah, it was, it took so long for people to find it because visually it


00:30:57.920 --> 00:31:02.920
it looked like what Python would actually mean.


00:31:02.920 --> 00:31:07.000
It looked like those two things were part of the if block,


00:31:07.000 --> 00:31:08.760
but because the white space didn't matter,


00:31:08.760 --> 00:31:10.640
it actually didn't.


00:31:10.640 --> 00:31:11.540
That's really interesting.


00:31:11.540 --> 00:31:13.660
I'm not going to go through everything.


00:31:13.660 --> 00:31:14.920
I'll put it in the show notes,


00:31:14.920 --> 00:31:15.880
but another one that I thought was like,


00:31:15.880 --> 00:31:17.380
I just don't like it.


00:31:17.380 --> 00:31:18.320
That's fine, people can not like it,


00:31:18.320 --> 00:31:20.440
but it has a lot of advantages.


00:31:20.440 --> 00:31:21.900
Like in that example before,


00:31:21.900 --> 00:31:23.320
if you had that wrongly indented Python code,


00:31:23.320 --> 00:31:25.720
it would not parse.


00:31:25.720 --> 00:31:26.560
It's an error to have it not look right


00:31:23.520 --> 00:31:26.240
rather than just not be right.


00:31:26.240 --> 00:31:27.520
So it has a lot of advantages,


00:31:27.520 --> 00:31:30.140
and people can really quickly get used


00:31:30.140 --> 00:31:32.440
to not having to write all those symbols,


00:31:32.440 --> 00:31:33.540
and then you go back and you're like,


00:31:33.540 --> 00:31:34.460
this code is hard to read,


00:31:34.460 --> 00:31:35.900
it's just full of curly braces,


00:31:35.900 --> 00:31:38.380
semi-colons, parentheses, everywhere.


00:31:38.380 --> 00:31:39.680
I always thought we used to,


00:31:39.680 --> 00:31:42.040
those were just, that is what builds programming languages.


00:31:42.040 --> 00:31:44.100
To have a programming language, you had to have that,


00:31:44.100 --> 00:31:46.580
and then once I experienced Python,


00:31:46.580 --> 00:31:47.920
and I went back, it kind of,


00:31:47.920 --> 00:31:49.520
it broke my mental model of the world.


00:31:49.520 --> 00:31:51.340
I'm like, you don't actually have to have those things,


00:31:51.340 --> 00:31:52.320
so why are they there?


00:31:52.320 --> 00:31:54.560
Anyway, what do you think about this article?


00:31:54.560 --> 00:31:55.560
You must like it somewhat,


00:31:55.560 --> 00:31:57.320
'cause you hunted it down and tweeted it, right?


00:31:57.320 --> 00:31:58.640
- It's old news for me,


00:31:58.640 --> 00:32:02.400
because I didn't even invent the whitespace thing for Python.


00:32:02.400 --> 00:32:05.920
That was sort of handed to me on a silver platter


00:32:05.920 --> 00:32:08.680
by one of my mentors in the early '80s.


00:32:08.680 --> 00:32:10.440
- Yeah, yeah, back in the ABC days.


00:32:10.440 --> 00:32:13.560
- And in those days, it was an innovation.


00:32:13.560 --> 00:32:16.400
There was like one other language that had this,


00:32:16.400 --> 00:32:18.680
and Knuth had once said


00:32:18.680 --> 00:32:20.480
that he thought it would be a good idea,


00:32:20.480 --> 00:32:26.780
but he had never actually implemented the language or even experienced the language that implemented it.


00:32:26.780 --> 00:32:28.980
He just thought that it would be a good idea.


00:32:28.980 --> 00:32:29.480
Right.


00:32:29.480 --> 00:32:29.980
Right.


00:32:29.980 --> 00:32:34.480
The only thing that was a stumbling block for me was when I first started looking at Python,


00:32:34.480 --> 00:32:39.980
the editor I was using, I think it was an Emacs something at the time.


00:32:39.980 --> 00:32:41.480
I'm not sure what I was using.


00:32:41.480 --> 00:32:47.980
But with the C++ code I was using, I had it set up so that if I double-clicked on the closing bracket,


00:32:47.980 --> 00:32:52.980
it would jump to the top of the block.


00:32:52.980 --> 00:32:55.980
And I really liked that feature.


00:32:55.980 --> 00:32:57.980
For some reason, that's the reason


00:32:57.980 --> 00:32:58.980
why I didn't like the whitespace thing at first.


00:32:58.980 --> 00:33:00.980
How do I get back?


00:33:00.980 --> 00:33:01.980
But then I just went, "Okay."


00:33:01.980 --> 00:33:03.980
I'm a beginner's mind, just open mind,


00:33:03.980 --> 00:33:05.980
just embrace it and learn it as a new thing.


00:33:05.980 --> 00:33:09.980
And a week later, I didn't even miss it.


00:33:09.980 --> 00:33:12.980
And of course, the new editors,


00:33:12.980 --> 00:33:14.980
the newer editors like PyCharm and stuff,


00:33:14.980 --> 00:33:16.980
at the bottom they have little breadcrumbs


00:33:13.980 --> 00:33:18.980
of here's the class, here's the function,


00:33:18.980 --> 00:33:20.900
here's the if, here's the while, whatever.


00:33:20.900 --> 00:33:22.580
You can jump between them,


00:33:22.580 --> 00:33:23.740
just like you were talking about,


00:33:23.740 --> 00:33:24.740
but the entire hierarchy of the tokens or whatever.


00:33:24.740 --> 00:33:28.380
- Yeah, I tend to write smaller functions now


00:33:28.380 --> 00:33:30.920
so it's not as much of a deal.


00:33:30.920 --> 00:33:33.920
- This is probably a good thing that it was hard.


00:33:33.920 --> 00:33:35.780
- I was thinking that if you needed the attitude


00:33:35.780 --> 00:33:38.900
to help you find the top of the block,


00:33:38.900 --> 00:33:41.020
it must be pretty far away.


00:33:39.180 --> 00:33:42.380
It's 4,000 lines. I hate scrolling so much. These functions are hard.


00:33:42.380 --> 00:33:43.880
Ah, yeah.


00:33:43.880 --> 00:33:46.580
How interesting. All right. Guido, do you have one more you want to share with us?


00:33:46.580 --> 00:33:50.780
Well, yeah, you gave me some homework. I didn't really do it, but there's like...


00:33:50.780 --> 00:33:53.180
And of course, this has to do with parsing.


00:33:53.180 --> 00:33:58.480
And so this may be a fairly esoteric library, but if you're writing a program


00:33:58.480 --> 00:34:02.080
that sort of does some manipulation of your code,


00:34:02.080 --> 00:34:07.280
and maybe it converts 4-space indents to 2-space indents


00:34:07.280 --> 00:34:09.280
or 3-space indents or whatever.


00:34:09.280 --> 00:34:12.960
Or maybe you're writing something like Black,


00:34:12.960 --> 00:34:17.080
which is the sort of Python code reformatting tool,


00:34:17.080 --> 00:34:20.720
but you don't like the way Black handles certain things.


00:34:20.720 --> 00:34:23.560
Or maybe you're writing some other thing


00:34:23.560 --> 00:34:26.980
that does analysis of source code.


00:34:26.980 --> 00:34:29.000
Maybe you're writing a linter.


00:34:29.000 --> 00:34:31.840
There are a couple of tools that you can use,


00:34:31.840 --> 00:34:34.400
and it turns out that one of them


00:34:34.400 --> 00:34:35.840
is in the standard library.


00:34:35.840 --> 00:34:40.100
There's something called lib223, which is a little hard to pronounce.


00:34:40.100 --> 00:34:45.260
It has the digit two and then the word T O and then the digit three in the name.


00:34:45.260 --> 00:34:46.020
That is tricky.


00:34:46.020 --> 00:34:52.220
That is something I wrote probably over 15 years ago, or at least the core of it.


00:34:52.220 --> 00:34:58.120
Which is yet another LL one parser, but this, this one's written in Python


00:34:58.120 --> 00:35:00.180
rather than in C like the original one.


00:35:00.900 --> 00:35:12.060
And actually Black ended up using Lib223 except I think Lukasz had one issue that he couldn't figure out how to do with Black.


00:35:12.060 --> 00:35:17.620
And so he ended up vendoring a copy of Lib223 and then butchering it a little bit.


00:35:17.620 --> 00:35:22.580
Which is how these things happen. I mean if you look at what pip vendors, that's pretty scary.


00:35:22.580 --> 00:35:24.580
But there are good reasons for that too.


00:35:24.580 --> 00:35:28.940
But if you're writing your own, you should probably not use lib223


00:35:28.940 --> 00:35:34.060
and not just because it's going to go out of style once the PEG parser arrives.


00:35:34.060 --> 00:35:40.820
There are much better tools, and the one that I discovered a few months ago


00:35:40.820 --> 00:35:44.660
is actually written by some folks at Facebook mostly.


00:35:44.660 --> 00:35:46.820
It's called libcst.


00:35:46.820 --> 00:35:50.020
And they have a unique capitalization.


00:35:50.020 --> 00:35:56.580
It's a capital L lib and then lowercase ib and then cst is all uppercase.


00:35:56.580 --> 00:36:00.660
And so it's a library for manipulating concrete syntax trees.


00:36:00.660 --> 00:36:06.300
And like lib223, it actually shares some code with lib223.


00:36:06.300 --> 00:36:13.480
I think the underneath is a parsing library called Parso, which itself is a


00:36:13.480 --> 00:36:15.740
butchered version of lib223.


00:36:15.740 --> 00:36:17.220
At least that's how it started.


00:36:17.820 --> 00:36:26.560
These tools are things that can parse Python code, but they produce a syntax tree that is the opposite of an abstract syntax tree.


00:36:26.560 --> 00:36:36.460
It's a very concrete syntax tree, and that means that every space, every comment, every bit of indentation is preserved,


00:36:36.460 --> 00:36:43.860
or at least can be recovered from the information in that syntax tree.


00:36:43.860 --> 00:36:48.780
and oppose that with the typical abstract syntax tree,


00:36:48.780 --> 00:36:51.340
which in the end doesn't even remember


00:36:51.340 --> 00:36:52.940
where the parentheses are.


00:36:52.940 --> 00:36:53.780
- Right, right.


00:36:53.780 --> 00:36:55.980
It just takes us, well, here's some conditional statement,


00:36:55.980 --> 00:36:57.420
and here's the two things we're testing.


00:36:57.420 --> 00:36:58.260
- Yeah. - Right?


00:36:58.260 --> 00:36:59.580
So this sounds much more useful


00:36:59.580 --> 00:37:03.220
if you want to do like a code analysis type of thing


00:37:03.220 --> 00:37:04.700
to say this thing you're doing here,


00:37:04.700 --> 00:37:07.060
you should do it in this other way or transform it over,


00:37:07.060 --> 00:37:09.600
but kind of preserve things like comments and style.


00:37:09.600 --> 00:37:10.440
- Yeah.


00:37:10.440 --> 00:37:15.440
And so libcst has a really sort of solid underlying model


00:37:15.440 --> 00:37:20.680
and they thought a lot about various transformations


00:37:20.680 --> 00:37:24.380
they want to apply because the typical way these tools work


00:37:24.380 --> 00:37:28.680
and lib223 itself started out that way as well


00:37:28.680 --> 00:37:33.640
is you read your source code using this customized parser.


00:37:33.640 --> 00:37:36.000
It gives you a concrete syntax tree.


00:37:36.000 --> 00:37:38.360
Then in that syntax tree,


00:37:38.360 --> 00:37:40.820
you're actually going to make changes.


00:37:40.820 --> 00:37:43.900
You're going to systematically rename a parameter


00:37:43.900 --> 00:37:47.640
or move things around or insert.


00:37:47.640 --> 00:37:49.460
In the 2-2-3 world, of course,


00:37:49.460 --> 00:37:52.760
it's used to turn things like iter items into items


00:37:52.760 --> 00:37:54.260
and iter keys into keys.


00:37:54.260 --> 00:37:57.020
And you can make that kind of changes.


00:37:57.020 --> 00:37:59.720
And so libcst also supports that,


00:37:59.720 --> 00:38:02.580
but it sort of has a slightly better API


00:38:02.580 --> 00:38:07.340
because 15 years ago when I started lib 2-2-3,


00:38:07.340 --> 00:38:10.900
I didn't realize what an important tool it was going to be.


00:38:10.900 --> 00:38:17.220
And some of the way the whitespace is attached to nodes is exactly backwards from the way


00:38:17.220 --> 00:38:20.380
that is the most convenient to think about it and work with it.


00:38:20.380 --> 00:38:21.380
All right, cool.


00:38:21.380 --> 00:38:24.420
Well, this sounds like it'd be really helpful for people building tools like Black or looking


00:38:24.420 --> 00:38:26.100
at code analysis and stuff.


00:38:26.100 --> 00:38:27.100
Right.


00:38:27.100 --> 00:38:32.220
Lukasz had a, I think it was the 2019 talk, PyCon talk, where he described how Black uses


00:38:32.220 --> 00:38:37.020
both concrete syntax trees and the abstract syntax tree.


00:38:37.020 --> 00:38:43.260
It's a pretty fascinating talk for a very low level depth into these concepts.


00:38:43.260 --> 00:38:46.960
It wasn't until I watched that talk that I realized that


00:38:46.960 --> 00:38:51.460
Black compares the before and after abstract syntax tree to make sure that


00:38:51.460 --> 00:38:54.160
your code is guaranteed to run the same.


00:38:54.160 --> 00:38:58.260
So you don't really have to test for that. He's already testing for it.


00:38:58.260 --> 00:38:59.460
That's pretty interesting.


00:38:59.460 --> 00:39:00.220
Yeah, that's pretty cool.


00:39:00.220 --> 00:39:02.020
That is a very neat feature.


00:39:02.020 --> 00:39:07.020
And it's actually important trick in general for people who are doing transformations


00:39:07.020 --> 00:39:16.020
to have some abstract way of double checking that your transformation left things in a decent state.


00:39:16.020 --> 00:39:17.020
Yeah, it's cool.


00:39:17.020 --> 00:39:18.020
Yeah, very cool.


00:39:18.020 --> 00:39:20.020
All right, well, thanks for Libcst. Guido, that's a great one.


00:39:20.020 --> 00:39:25.020
Now, that's it for our main topics. So just really quick things at the end that I just want to throw out there for people.


00:39:25.020 --> 00:39:30.020
One, Adam, who goes by codependent coder on Twitter, sent a message over and said,


00:39:30.020 --> 00:39:33.700
"Hey, Django no longer supports Python 2 at all,"


00:39:33.700 --> 00:39:37.020
which is pretty awesome because 1.11 has left


00:39:37.020 --> 00:39:41.140
long-term support, leaving only 2.2.12 onward,


00:39:41.140 --> 00:39:43.460
which has only Python 3 support.


00:39:43.460 --> 00:39:46.540
So yay for modern Python making its way through.


00:39:46.540 --> 00:39:47.380
That's good.


00:39:47.380 --> 00:39:50.940
And then last time we talked about 90% of coding


00:39:50.940 --> 00:39:53.460
is Googling, and that's okay, or it's not.


00:39:53.460 --> 00:39:55.940
And we didn't really feel like that was our experience,


00:39:55.940 --> 00:39:58.380
right, as people have been around for a while.


00:39:58.380 --> 00:40:03.380
But I got to tell you, this last week,


00:40:03.380 --> 00:40:05.700
I've been doing nothing but Pandas,


00:40:05.700 --> 00:40:07.760
Altair visualization, Jupyter Notebook, and graphics,


00:40:07.760 --> 00:40:11.880
because I'm building a whole set of dashboards


00:40:11.880 --> 00:40:14.080
for the Dock Python courses and whatnot.


00:40:14.080 --> 00:40:17.080
Basically, the dashboards that I should have built


00:40:17.080 --> 00:40:19.040
a while ago.


00:40:19.040 --> 00:40:20.200
I Googled a lot, a whole lot.


00:40:20.200 --> 00:40:22.800
But that's the thing, it was like a two or three day blip


00:40:22.800 --> 00:40:26.080
of wow, I'm Googling 25, 30% of my time


00:40:25.320 --> 00:40:27.480
because I don't know anything about these things


00:40:27.480 --> 00:40:30.120
and how do I get this thing to line up with that bar?


00:40:30.120 --> 00:40:32.080
But now I'm back to just kind of mostly


00:40:32.080 --> 00:40:33.860
not doing that anymore, even after a few days.


00:40:33.860 --> 00:40:35.920
So I think generally what we said is true,


00:40:35.920 --> 00:40:37.520
but I do think there's like these blips of like,


00:40:37.520 --> 00:40:38.840
wow, I'm diving into something new.


00:40:38.840 --> 00:40:40.640
It's like mad search scrambling,


00:40:40.640 --> 00:40:44.200
but then I'm back to sort of using like more memory coding.


00:40:44.200 --> 00:40:46.200
I don't know what you call not Google coding.


00:40:46.200 --> 00:40:48.320
- You got to understand what you're doing.


00:40:48.320 --> 00:40:52.920
And that means you can't just Google for examples


00:40:52.920 --> 00:40:55.060
and copy and paste them in


00:40:55.060 --> 00:40:57.580
because then you combine the examples


00:40:57.580 --> 00:40:59.420
and you have no idea what you're doing


00:40:59.420 --> 00:41:00.660
and of course it doesn't work.


00:41:00.660 --> 00:41:02.100
- At best it's frustrating, right?


00:41:02.100 --> 00:41:03.540
You're like, this worked, that worked,


00:41:03.540 --> 00:41:04.500
but together they don't work


00:41:04.500 --> 00:41:05.820
and you just don't even know why, right?


00:41:05.820 --> 00:41:07.020
Yeah, so for sure.


00:41:07.020 --> 00:41:09.580
Yeah, so anyway, I don't know.


00:41:09.580 --> 00:41:11.100
A follow up on our conversation last week, Brian,


00:41:11.100 --> 00:41:12.500
what do you got to throw out there for everyone?


00:41:12.500 --> 00:41:14.140
- I'm going to say this on this show


00:41:14.140 --> 00:41:15.620
just to make sure I do it.


00:41:15.620 --> 00:41:18.600
There's like three days left for me to record my talk.


00:41:18.600 --> 00:41:21.560
- Yeah, this is like forcing yourself to commit to it


00:41:21.560 --> 00:41:22.940
so you're going to do it, okay.


00:41:22.940 --> 00:41:24.020
- Yes, definitely.


00:41:24.020 --> 00:41:26.940
So PyCon talk, I really do want to get it online.


00:41:26.940 --> 00:41:28.220
It's important stuff.


00:41:28.220 --> 00:41:29.860
It's about parameterization.


00:41:29.860 --> 00:41:32.960
I talked a couple episodes ago about having trouble


00:41:32.960 --> 00:41:34.740
switching back and forth at home


00:41:34.740 --> 00:41:36.140
with all this working from home stuff


00:41:36.140 --> 00:41:37.740
between Mac and Windows.


00:41:37.740 --> 00:41:41.260
I finally figured out the whole using command and control.


00:41:41.260 --> 00:41:42.780
So thank you to everybody,


00:41:42.780 --> 00:41:44.820
but apparently there's this really simple thing.


00:41:44.820 --> 00:41:47.780
Apple lets you just swap them on a keyboard.


00:41:47.780 --> 00:41:50.140
So that's what I'm doing and it works great.


00:41:50.140 --> 00:41:52.940
And then also I had promised that I was going to have


00:41:52.940 --> 00:41:57.100
my cards project be able to work and publish to PyPI


00:41:57.100 --> 00:42:00.820
or the test PyPI, it doesn't work with setup tools SCM


00:42:00.820 --> 00:42:02.340
because I'm using Flit.


00:42:02.340 --> 00:42:05.880
So if somebody's got a way to figure out how to just


00:42:05.880 --> 00:42:09.540
somehow change the version string or bump that


00:42:09.540 --> 00:42:11.860
every time you merge or something like that,


00:42:11.860 --> 00:42:14.700
that'd be great, but otherwise, right now I don't think


00:42:14.700 --> 00:42:18.140
there's a way to automatically push to PyPI


00:42:18.140 --> 00:42:19.700
if you're using Flit.


00:42:19.700 --> 00:42:21.660
- Yeah, because it says that one's already uploaded.


00:42:21.660 --> 00:42:24.460
Maybe there's a GitHub action that will just randomize that or something.


00:42:24.460 --> 00:42:27.180
Because the version is embedded in the source code.


00:42:27.180 --> 00:42:30.300
And the trick that people are using with setup tools is


00:42:30.300 --> 00:42:33.740
the version is based on the version in GitHub.


00:42:33.740 --> 00:42:35.740
And you can't do that with Flit.


00:42:35.740 --> 00:42:37.740
At least I haven't figured it out.


00:42:37.740 --> 00:42:40.380
But that's okay. I'll probably do something else.


00:42:40.380 --> 00:42:41.500
That's my extras.


00:42:41.500 --> 00:42:42.700
Guido, anything else?


00:42:42.700 --> 00:42:46.900
Even though I said it's hard to imagine Python going online,


00:42:46.900 --> 00:42:48.900
it actually is going online.


00:42:48.900 --> 00:42:50.380
At least some of it is.


00:42:50.380 --> 00:42:58.140
The first talk by the conference chair, Emily Morehouse has been posted and many more will follow.


00:42:58.140 --> 00:42:59.500
Yeah, her welcome was really nice.


00:42:59.500 --> 00:43:05.020
The other thing, and as you mentioned, Django no longer supports Python 2 at all.


00:43:05.020 --> 00:43:13.420
Well, that's just fine because the very last release of Python 2, 2.7.18, was released a few days ago.


00:43:13.420 --> 00:43:18.860
Yeah, that's great. That must be kind of a load off of your shoulders to finally have that in the rearview mirror.


00:43:18.860 --> 00:43:24.380
I'm very happy and I'm sad of course that we can't have an absolutely wild and crazy


00:43:24.380 --> 00:43:26.700
party in Pittsburgh like we were planning.


00:43:26.700 --> 00:43:30.460
Yeah, a big celebration on Zoom is just not the same.


00:43:30.460 --> 00:43:32.060
Just have to have a bigger one next year.


00:43:32.060 --> 00:43:34.940
That's one I don't know how to pull off.


00:43:34.940 --> 00:43:35.940
That's really good.


00:43:35.940 --> 00:43:38.700
All right, you guys ready for a really quick joke?


00:43:38.700 --> 00:43:39.860
All right.


00:43:39.860 --> 00:43:43.780
So here's a quick joke sent to us by Derek Chambers.


00:43:43.780 --> 00:43:46.880
And he may have even made this up for us.


00:43:46.880 --> 00:43:51.480
And this goes back to the sub-interpreters and the multiple gills and all that.


00:43:51.480 --> 00:43:55.180
So you guys know how you can borrow money concurrently?


00:43:55.180 --> 00:43:56.180
With async IOUs.


00:43:56.180 --> 00:43:57.180
That's a terrible joke.


00:43:57.180 --> 00:43:58.180
That's a bad joke.


00:43:58.180 --> 00:44:04.080
Oh, that is very groan-worthy.


00:44:04.080 --> 00:44:07.080
Most of our jokes actually are around here, but that's how it goes.


00:44:07.080 --> 00:44:08.160
And keep them coming.


00:44:08.160 --> 00:44:11.080
Keep sending us your bad jokes.


00:44:11.080 --> 00:44:12.080
That's right.


00:44:12.080 --> 00:44:13.080
That's right.


00:44:13.080 --> 00:44:15.960
Python dad jokes, that should be a whole separate category.


00:44:15.960 --> 00:44:17.960
They absolutely should.


00:44:17.960 --> 00:44:19.960
Well, Guido, it was really an honor to have you on the show.


00:44:19.960 --> 00:44:21.960
Thanks for coming and sharing your perspective on all this.


00:44:21.960 --> 00:44:23.960
Glad to be back.


00:44:23.960 --> 00:44:25.960
Yeah, and Brian, thanks as always. Good to be here with you.


00:44:25.960 --> 00:44:27.960
Cheers.


00:44:27.960 --> 00:44:29.960
Bye, everyone.


00:44:29.960 --> 00:44:31.960
Thanks, both of you.


00:44:31.960 --> 00:44:33.960
Thank you for listening to Python Bytes.


00:44:33.960 --> 00:44:35.960
Follow the show on Twitter via @PythonBytes.


00:44:35.960 --> 00:44:37.960
That's Python Bytes as in B-Y-T-E-S.


00:44:37.960 --> 00:44:39.960
And get the full show notes at PythonBytes.fm.


00:44:39.960 --> 00:44:41.960
If you have a news item you want featured,


00:44:41.960 --> 00:44:43.960
just visit PythonBytes.fm and send it our way.


00:44:43.960 --> 00:44:50.040
We're always on the lookout for sharing something cool. On behalf of myself and Brian Okken, this is Michael Kennedy


00:44:50.040 --> 00:44:53.440
Thank you for listening and sharing this podcast with your friends and colleagues

