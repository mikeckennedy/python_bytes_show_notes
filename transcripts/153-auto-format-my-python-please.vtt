
00:00:00.000 --> 00:00:05.120
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.


00:00:05.120 --> 00:00:11.200
This is episode 153, recorded October 16, 2019. I'm Brian Okken.


00:00:11.200 --> 00:00:12.000
And I'm Michael Kennedy.


00:00:12.000 --> 00:00:16.160
This week's episode is sponsored by DigitalOcean. We'll talk more about them later.


00:00:16.160 --> 00:00:19.120
But first, Michael, could you extend my knowledge a bit?


00:00:19.120 --> 00:00:23.120
Yeah, by extending the entire Python ecosystem, maybe?


00:00:23.120 --> 00:00:24.080
Yeah.


00:00:24.080 --> 00:00:30.880
Yeah, so there's actually a cool real Python article called "Building a C, Python C Extension Module."


00:00:30.880 --> 00:00:33.480
So, Brian, you know how to write C code, right?


00:00:33.480 --> 00:00:36.280
Yes, or at least that's the theory. I used to know how.


00:00:36.280 --> 00:00:40.680
Yeah, I have this really awesome former self of mine that was super good at C++.


00:00:40.680 --> 00:00:43.280
I kind of remember that person that I was.


00:00:43.280 --> 00:00:44.680
I used to be able to write a lot of C.


00:00:44.680 --> 00:00:50.080
That was my main job is to write C and 3D stuff and OpenGL and things like that, right?


00:00:50.080 --> 00:00:55.080
So it's definitely the main way to extend Python these days.


00:00:55.080 --> 00:00:58.080
And there's other options, like there's some cool Rust options and whatnot.


00:00:58.080 --> 00:01:03.080
But primarily people know C, it runs everywhere, has light runtime requirements.


00:01:03.080 --> 00:01:08.080
You're already running CPython probably, so you already have those requirements met, right?


00:01:08.080 --> 00:01:14.080
So extending your code with some kind of C extension gives you a couple of options.


00:01:14.080 --> 00:01:16.080
One is clearly performance.


00:01:16.080 --> 00:01:19.840
I love to talk about Python performance because one, it always surprises me.


00:01:19.840 --> 00:01:21.840
And two, like people are usually wrong about it.


00:01:21.840 --> 00:01:23.120
They say Python is slow.


00:01:23.120 --> 00:01:26.400
Like I was just reading something on Quora about why,


00:01:26.400 --> 00:01:29.600
like compare C# to Python.


00:01:29.600 --> 00:01:31.440
And somebody's like, "Well, you can't even compare them.


00:01:31.440 --> 00:01:33.440
C# is 50 times faster."


00:01:33.440 --> 00:01:35.760
Well, it's true for certain operations,


00:01:35.760 --> 00:01:37.440
unless maybe part of that it's done in C,


00:01:37.440 --> 00:01:38.880
and then probably Python is faster,


00:01:38.880 --> 00:01:41.120
because like now it's down in like NumPy and doing it in C,


00:01:41.120 --> 00:01:42.320
which is actually faster, right?


00:01:42.320 --> 00:01:44.080
There's just, it gets really interesting.


00:01:44.080 --> 00:01:47.680
And so one reason you might care about writing a C module is just for performance.


00:01:47.680 --> 00:01:49.620
And I think that's what most people think of.


00:01:49.620 --> 00:01:56.620
But there's also like low-level operating system APIs or other C APIs, like some library


00:01:56.620 --> 00:02:02.720
you can get, you might want to use, that happens to be written in C and doesn't have a Python


00:02:02.720 --> 00:02:04.000
way to talk to it, right?


00:02:04.000 --> 00:02:08.640
Yeah, there's lots of stuff with DLLs that are available with C header files, but you


00:02:08.640 --> 00:02:10.080
don't have a Python binding.


00:02:10.080 --> 00:02:11.080
Exactly.


00:02:11.080 --> 00:02:15.480
You have a lot of experience with that with all of your devices and stuff like that.


00:02:15.480 --> 00:02:16.480
Yep.


00:02:16.480 --> 00:02:17.480
Yeah.


00:02:17.480 --> 00:02:18.480
Okay.


00:02:18.480 --> 00:02:20.040
So those are the two main reasons I can think of writing C extensions.


00:02:20.040 --> 00:02:24.320
I mean, obviously throw some Cython at it if it's a performance thing to give it a try,


00:02:24.320 --> 00:02:28.760
but there's a cool tutorial on real Python and it talks about how you can, you know,


00:02:28.760 --> 00:02:33.580
like things you'll be able to do is like import C functions within Python, pass arguments


00:02:33.580 --> 00:02:39.000
from Python to C, raise correct exceptions in your C code so they surface bubble back


00:02:39.000 --> 00:02:43.560
into your Python code as a proper like value error type exception or


00:02:43.560 --> 00:02:46.200
something like that, all sorts of cool things and even how to test and


00:02:46.200 --> 00:02:46.880
distribute it.


00:02:46.880 --> 00:02:50.460
So let me just sort of talk through the process and then people really care.


00:02:50.460 --> 00:02:52.240
They can go read the big long article, right?


00:02:52.240 --> 00:02:58.420
So if you want to basically get access to some C functionality, or if you want


00:02:58.420 --> 00:03:02.300
to just like write your implementation and see for some degree, first thing


00:03:02.300 --> 00:03:05.720
you got to do is go and figure out, let's suppose you want to call like a


00:03:05.880 --> 00:03:06.880
some C function.


00:03:06.880 --> 00:03:11.800
So the article uses FPUTS, which puts a string into a file pointer, right?


00:03:11.800 --> 00:03:15.280
Like basically writes a string to a file in C.


00:03:15.280 --> 00:03:20.720
So you have to write a function, which is pretty interesting because it returns, you


00:03:20.720 --> 00:03:24.880
have to start talking in the CPython language, not Python, right?


00:03:24.880 --> 00:03:29.760
So everything that gets passed around is a Python object pointer, or the return value


00:03:29.760 --> 00:03:33.280
is like a Py object pointer, right?


00:03:33.280 --> 00:03:38.720
So you pass these things around and first of all you declare whatever inbound arguments


00:03:38.720 --> 00:03:43.560
you're really expecting and you get basically passed a single pointer that is the arguments


00:03:43.560 --> 00:03:45.200
to your function but it's really a tuple.


00:03:45.200 --> 00:03:50.360
So there's a pyarg parse tuple, give you the arguments, a format thing, and you give it


00:03:50.360 --> 00:03:54.400
the address of the pointers, you pass them by reference basically.


00:03:54.400 --> 00:03:55.920
And then you just do your CPython code.


00:03:55.920 --> 00:04:01.820
In this case the function that they're wrapping FPUTs returns the number of bytes copied when


00:04:01.820 --> 00:04:02.960
it does that.


00:04:02.960 --> 00:04:05.960
And so this function wants to return the bytes copied,


00:04:05.960 --> 00:04:08.960
but you can't just return an integer or a long, no, no, no,


00:04:08.960 --> 00:04:11.960
because everything in Python is a py object at the C level,


00:04:11.960 --> 00:04:15.960
py object star, even numbers, so you have to convert


00:04:15.960 --> 00:04:18.960
from a long to a py long from long,


00:04:18.960 --> 00:04:22.960
which is a function that you get from the python.h C header file.


00:04:22.960 --> 00:04:24.960
It's actually pretty simple.


00:04:24.960 --> 00:04:28.960
There's some weird non-obvious structure at the beginning of the function


00:04:28.960 --> 00:04:31.960
so that it can be called by Python, and the return value is weird,


00:04:31.960 --> 00:04:34.360
But everything else in the middle is like straight C.


00:04:34.360 --> 00:04:37.080
So you don't really have to think about what's going on.


00:04:37.080 --> 00:04:40.440
The GIL will protect you from race conditions, all that kind of stuff.


00:04:40.440 --> 00:04:40.940
Yeah.


00:04:40.940 --> 00:04:43.320
And actually, one of the things I love about this article


00:04:43.320 --> 00:04:46.600
is that it's using a fairly simple example so that you're not


00:04:46.600 --> 00:04:48.360
distracted by the example.


00:04:48.360 --> 00:04:50.720
It's just the boilerplate junk that you've got to learn about.


00:04:50.720 --> 00:04:51.520
Yeah, absolutely.


00:04:51.520 --> 00:04:54.680
Which is probably the thing you don't know, even if you know C, right?


00:04:54.680 --> 00:04:55.160
Yeah.


00:04:55.160 --> 00:04:58.080
It says also there's a few other things that are necessary if you actually


00:04:58.080 --> 00:05:02.720
want to use this code and not just write it and compile it in C, is you have to


00:05:02.720 --> 00:05:08.240
write a definition for your module in C and the methods that it contains. So


00:05:08.240 --> 00:05:11.200
there's a few C functions that you call there and then you have to build it for


00:05:11.200 --> 00:05:17.160
Python which you basically create a setup.py file and use just utils and it


00:05:17.160 --> 00:05:20.640
will compile and create the right base library and install it for you.


00:05:20.640 --> 00:05:24.400
Okay. Pretty cool, huh? Pretty cool, yeah. One of the issues with this is that


00:05:24.400 --> 00:05:27.040
the people that have to, a lot of times


00:05:27.040 --> 00:05:32.040
when you need to do this, it isn't a hardcore C compiler


00:05:32.040 --> 00:05:35.680
person or a hardcore Python, CPython person


00:05:35.680 --> 00:05:37.960
that needs to do this, it's just your casual user


00:05:37.960 --> 00:05:39.560
that happens to have a use case that they need


00:05:39.560 --> 00:05:41.240
to connect Python to C.


00:05:41.240 --> 00:05:43.080
And so this is great.


00:05:43.080 --> 00:05:44.640
- Yeah, and it's super approachable,


00:05:44.640 --> 00:05:47.400
and like you said, the examples are pretty straightforward.


00:05:47.400 --> 00:05:49.960
Obviously you're writing C, which puts you


00:05:49.960 --> 00:05:51.840
in a different category of hard, right?


00:05:51.840 --> 00:05:55.360
I mean, free malloc pointers, pointers by reference,


00:05:55.360 --> 00:05:56.200
like all that kind of stuff


00:05:56.200 --> 00:05:57.840
that you learn when you learn C,


00:05:57.840 --> 00:05:59.500
but that's the world you gotta live in


00:05:59.500 --> 00:06:02.320
when you go down and you take the blue pill


00:06:02.320 --> 00:06:03.160
or whatever it is.


00:06:03.160 --> 00:06:05.880
(laughing)


00:06:05.880 --> 00:06:06.880
- Is the blue one the good one?


00:06:06.880 --> 00:06:07.720
I think--


00:06:07.720 --> 00:06:08.760
- You know, I always forget.


00:06:08.760 --> 00:06:10.120
I know that there's a pill that's good


00:06:10.120 --> 00:06:11.400
and there's a pill that's bad


00:06:11.400 --> 00:06:14.280
and it keeps the facade, but yeah.


00:06:14.280 --> 00:06:16.080
Probably the red, I don't know.


00:06:16.080 --> 00:06:17.220
- Do you know what else is good?


00:06:17.220 --> 00:06:18.060
- Documentation.


00:06:18.060 --> 00:06:18.880
- Documentation.


00:06:18.880 --> 00:06:20.560
- No, Python 3.8.


00:06:20.560 --> 00:06:22.200
- Python 3.8 is good.


00:06:22.200 --> 00:06:23.520
- But also Python 3.8.


00:06:23.520 --> 00:06:24.680
- Read the URL, sorry.


00:06:24.680 --> 00:06:29.100
- Python 3.8 dropped just this week.


00:06:29.100 --> 00:06:32.000
So it is no longer beta, it is final,


00:06:32.000 --> 00:06:34.240
and you can download it from the front page.


00:06:34.240 --> 00:06:38.160
The default is Python 3.8.0 now when you download it.


00:06:38.160 --> 00:06:39.800
So yay. - Yes, that's awesome.


00:06:39.800 --> 00:06:41.420
- We have talked about a lot of stuff.


00:06:41.420 --> 00:06:44.680
On this podcast, we've talked about things going into 3.8.


00:06:44.680 --> 00:06:46.660
Like the walrus operator, of course,


00:06:46.660 --> 00:06:48.320
that's come up a lot of times.


00:06:48.320 --> 00:06:50.080
Those are assignment expressions.


00:06:50.080 --> 00:06:53.440
positional only parameters and f strings.


00:06:53.440 --> 00:06:55.200
f-strings have the little equal sign


00:06:55.200 --> 00:06:56.480
so you can debug with them easier.


00:06:56.480 --> 00:06:58.240
- Right, f strings have been here since 3.6


00:06:58.240 --> 00:07:00.660
but now they have this like self-documenting


00:07:00.660 --> 00:07:02.240
short print statement thing, right?


00:07:02.240 --> 00:07:04.920
- Yeah, and it takes longer to describe than to show


00:07:04.920 --> 00:07:06.040
and it's cool.


00:07:06.040 --> 00:07:07.760
What I wanted to highlight is the


00:07:07.760 --> 00:07:11.420
what's new in Python 3.8 document that came out from,


00:07:11.420 --> 00:07:13.960
that's at docs.python.org.


00:07:13.960 --> 00:07:15.560
And it's a really great summary


00:07:15.560 --> 00:07:17.760
of all the stuff that's in 3.8.


00:07:17.760 --> 00:07:19.720
It does have all of those new things


00:07:19.720 --> 00:07:21.720
that all those big hitters,


00:07:21.720 --> 00:07:24.760
but it also has some stuff that I was surprised by


00:07:24.760 --> 00:07:26.800
that I hadn't heard of before.


00:07:26.800 --> 00:07:30.380
One of them is we've talked about a lot of async stuff,


00:07:30.380 --> 00:07:34.240
and now you can type Python -m asyncio,


00:07:34.240 --> 00:07:37.640
and it launches a async native REPL.


00:07:37.640 --> 00:07:41.040
- That is so cool, and I had no idea that that was there.


00:07:41.040 --> 00:07:43.540
I guess it would have been a pain in the butt


00:07:43.540 --> 00:07:46.240
before to like work with async stuff over there


00:07:46.240 --> 00:07:47.360
in the REPL, right?


00:07:47.360 --> 00:07:48.520
So-- - Yeah, I guess.


00:07:48.520 --> 00:07:51.140
Now you can just, 'cause I often drop into the REPL


00:07:51.140 --> 00:07:51.980
to try something out,


00:07:51.980 --> 00:07:54.760
now you can try out async stuff in there, so that's cool.


00:07:54.760 --> 00:07:55.680
- Yeah, that's super cool.


00:07:55.680 --> 00:07:57.600
- A couple other things that'll just help you


00:07:57.600 --> 00:07:59.120
while writing Python,


00:07:59.120 --> 00:08:00.960
couple new warnings and messages


00:08:00.960 --> 00:08:02.400
for things that you might do wrong.


00:08:02.400 --> 00:08:04.840
So when you're not supposed to compare,


00:08:04.840 --> 00:08:08.120
use is or is not to compare non-objects,


00:08:08.120 --> 00:08:10.600
like strings or integers or something.


00:08:10.600 --> 00:08:14.120
It's just like, if x is three, don't do that.


00:08:14.120 --> 00:08:16.280
But apparently the warning wasn't very good,


00:08:16.280 --> 00:08:17.800
and so now the warning is better.


00:08:17.800 --> 00:08:20.640
it tells you to use double equal or not equal.


00:08:20.640 --> 00:08:21.480
So that's cool.


00:08:21.480 --> 00:08:23.160
And then one of the things that I often get


00:08:23.160 --> 00:08:25.840
because I do a lot of parameterized testing


00:08:25.840 --> 00:08:30.300
is if you've got a list with tuples inside


00:08:30.300 --> 00:08:33.760
or basically a list of lists or a tuple of tuples


00:08:33.760 --> 00:08:37.000
and you forget the commas between some of the things


00:08:37.000 --> 00:08:39.160
because maybe they're on a new line or something.


00:08:39.160 --> 00:08:40.880
The warning was weird before


00:08:40.880 --> 00:08:43.400
but now it is a more helpful message.


00:08:43.400 --> 00:08:45.080
So I love things like that.


00:08:45.080 --> 00:08:47.780
- Yeah, it drives me crazy if those are strings.


00:08:47.780 --> 00:08:50.580
Like if you're creating a JSON document or something like that,


00:08:50.580 --> 00:08:53.280
or a multi-line, like a list of strings, and you forget a comma,


00:08:53.280 --> 00:08:55.740
it just concatenates them, even though they're on separate lines.


00:08:55.740 --> 00:08:57.340
I'm like, oh, really?


00:08:57.340 --> 00:08:58.500
That's the default behavior?


00:08:58.500 --> 00:09:00.780
But I understand where it comes from, but it drives me crazy.


00:09:00.780 --> 00:09:02.060
- That probably is still there.


00:09:02.060 --> 00:09:02.540
- Yeah, yeah.


00:09:02.540 --> 00:09:05.540
I don't see how you would fix that without changing what that means.


00:09:05.540 --> 00:09:06.340
- Yeah.


00:09:06.340 --> 00:09:08.420
This one, it took me a while to get my head around,


00:09:08.420 --> 00:09:11.180
but I didn't know that this was an issue before.


00:09:11.180 --> 00:09:16.260
Iterable unpacking-- so if you packed a bunch of stuff into a variable,


00:09:16.260 --> 00:09:19.940
you can unpack it with star variable name.


00:09:19.940 --> 00:09:22.780
You can't return that in a return statement


00:09:22.780 --> 00:09:26.500
or you couldn't before out of a tuple.


00:09:26.500 --> 00:09:28.100
So you had to put parentheses around it


00:09:28.100 --> 00:09:29.260
before you return it.


00:09:29.260 --> 00:09:32.020
But now that's gone away, you can just return it.


00:09:32.020 --> 00:09:33.860
- Yeah, there's a lot of good stuff in here actually.


00:09:33.860 --> 00:09:35.620
And you just did an episode on it, didn't you?


00:09:35.620 --> 00:09:37.780
- Yep, episode 91 of Testing Code.


00:09:37.780 --> 00:09:39.460
I just read through the entire article


00:09:39.460 --> 00:09:42.100
and it's still just 20 minutes.


00:09:42.100 --> 00:09:43.240
I didn't read through everything,


00:09:43.240 --> 00:09:45.900
but I highlighted all the stuff that I thought was cool.


00:09:45.900 --> 00:09:46.740
- Super.


00:09:46.740 --> 00:09:48.940
- You know, something else that's cool is DigitalOcean.


00:09:48.940 --> 00:09:49.820
- I love DigitalOcean.


00:09:49.820 --> 00:09:52.380
- This episode is sponsored by DigitalOcean


00:09:52.380 --> 00:09:55.260
and Python Bytes infrastructure runs on DigitalOcean,


00:09:55.260 --> 00:09:57.780
thanks to Michael putting that all together.


00:09:57.780 --> 00:10:00.380
And it's quite solid and we're super happy with it.


00:10:00.380 --> 00:10:02.740
But did you know that not all web applications


00:10:02.740 --> 00:10:05.540
and services have the same memory and CPU demands?


00:10:05.540 --> 00:10:06.460
- It's shocking, isn't it?


00:10:06.460 --> 00:10:07.340
- Shocking.


00:10:07.340 --> 00:10:10.420
Anyway, so DigitalOcean has embraced this diversity


00:10:10.420 --> 00:10:12.820
in their droplet structure, which is cool.


00:10:12.820 --> 00:10:16.660
with the ratio of memory to CPU powers in droplets.


00:10:16.660 --> 00:10:19.180
The general purpose droplets have a ratio


00:10:19.180 --> 00:10:21.780
of four gigabytes of memory per CPU,


00:10:21.780 --> 00:10:23.460
and you can scale those up.


00:10:23.460 --> 00:10:25.760
They added, not too long, a couple years ago, I think,


00:10:25.760 --> 00:10:29.260
CPU optimized ones, so they doubled the number of CPUs


00:10:29.260 --> 00:10:30.860
per the amount of memory,


00:10:30.860 --> 00:10:33.260
and that's great for CPU bound tasks.


00:10:33.260 --> 00:10:36.600
But there's some applications like high performance databases


00:10:36.600 --> 00:10:40.280
or in-memory caches or data processing of large sets


00:10:40.280 --> 00:10:43.560
that a lot of memory might be a really great thing.


00:10:43.560 --> 00:10:46.960
So there's now a memory optimized droplet


00:10:46.960 --> 00:10:48.600
that reverses that structure


00:10:48.600 --> 00:10:51.840
and makes it like eight gigabytes of memory per CPU.


00:10:51.840 --> 00:10:52.680
It's pretty cool.


00:10:52.680 --> 00:10:53.500
- Yeah, very cool.


00:10:53.500 --> 00:10:54.880
- Yeah, use the right kind of droplet


00:10:54.880 --> 00:10:56.720
for the right service that you're using


00:10:56.720 --> 00:11:00.520
and try it out at pythonbytes.fm/digitalocean


00:11:00.520 --> 00:11:02.880
and they'll give you a $50 credit for new users.


00:11:02.880 --> 00:11:06.320
- You and I have mentioned that folks should


00:11:06.320 --> 00:11:08.800
put legacy Python where it belongs in the past.


00:11:08.800 --> 00:11:13.840
Last time we spoke about 35 million lines of Python code at JPMorgan Chase


00:11:13.840 --> 00:11:16.000
and their journey to work on that.


00:11:16.000 --> 00:11:20.680
And that's all interesting, but we just recently got this announcement


00:11:20.680 --> 00:11:25.840
from the UK's NCSC, the National Cyber Security Center.


00:11:25.840 --> 00:11:26.400
Wow.


00:11:26.400 --> 00:11:26.720
Yeah.


00:11:26.720 --> 00:11:30.040
And they're warning developers of the risk of sticking with Python


00:11:30.040 --> 00:11:32.200
too, particularly library writers.


00:11:32.200 --> 00:11:32.600
Okay.


00:11:32.600 --> 00:11:33.880
That's interesting, right?


00:11:33.880 --> 00:11:38.240
That they actually go so far as to call that out as a thing.


00:11:38.440 --> 00:11:42.320
So they say, look, this could be like basically the companies that continue


00:11:42.320 --> 00:11:47.600
to use Python two past its end of life could be like tempting or setting the


00:11:47.600 --> 00:11:52.080
environment for another WannaCry or even an Equifax incident.


00:11:52.080 --> 00:11:55.200
So Equifax was a horrible data breach.


00:11:55.200 --> 00:12:00.080
Basically it's one of these companies that gathers up so much private data.


00:12:00.080 --> 00:12:02.400
Like they know stuff about my financial past that I have


00:12:02.400 --> 00:12:03.760
forgotten and don't even know.


00:12:03.760 --> 00:12:04.120
Right.


00:12:04.120 --> 00:12:06.360
They go, did you know you had this account in California?


00:12:06.360 --> 00:12:07.000
Like I did.


00:12:07.000 --> 00:12:07.660
Oh, okay.


00:12:07.660 --> 00:12:12.700
well, I guess I do. Right. They know all of that. And it was broken into why


00:12:12.700 --> 00:12:16.620
because there was a vulnerability in Apache struts, which is an open source


00:12:16.620 --> 00:12:20.100
framework, people stress are like, guys, this is super bad. You just have to


00:12:20.100 --> 00:12:24.180
send like a special a super p request to the server and it's owned, right?


00:12:24.180 --> 00:12:27.840
Well, the folks at Equifax got that message, but they didn't really want to


00:12:27.840 --> 00:12:32.380
get around to like upgrading it to the new version, because hey, it's kind of


00:12:32.380 --> 00:12:35.180
hard to upgrade this thing. It's like a new version, which probably was old and


00:12:35.220 --> 00:12:37.460
was slightly incompatible or something.


00:12:37.460 --> 00:12:39.340
Anyway, that's where Equifax came from,


00:12:39.340 --> 00:12:41.620
is running an old version of one of these frameworks,


00:12:41.620 --> 00:12:44.600
not Java itself, but like the web framework on top of it.


00:12:44.600 --> 00:12:47.700
Anyway, there's some cool quotes in here.


00:12:47.700 --> 00:12:50.860
They say, "If you're still using Python 2.x,


00:12:50.860 --> 00:12:53.220
"it's time to port your code to Python 3.


00:12:53.220 --> 00:12:55.440
"If you continue to use unsupported modules,


00:12:55.440 --> 00:12:58.240
"you are risking the security of your organization


00:12:58.240 --> 00:13:01.340
"and data as vulnerabilities will sooner or later appear,


00:13:01.340 --> 00:13:02.580
"which nobody's fixing."


00:13:02.580 --> 00:13:03.980
Okay, that's one.


00:13:03.980 --> 00:13:05.420
One interesting quote, another one is,


00:13:05.420 --> 00:13:08.600
if you maintain a library that other developers depend upon,


00:13:08.600 --> 00:13:11.460
you may be preventing them from updating to three,


00:13:11.460 --> 00:13:13.100
and by holding back other developers,


00:13:13.100 --> 00:13:15.560
you're indirectly and likely unintentionally


00:13:15.560 --> 00:13:17.120
increasing the security risk


00:13:17.120 --> 00:13:19.580
of basically all the computers in the world.


00:13:19.580 --> 00:13:20.420
- Yeah. - Yeah.


00:13:20.420 --> 00:13:21.980
So, I mean, we've said this before, right?


00:13:21.980 --> 00:13:23.260
You and I have said this,


00:13:23.260 --> 00:13:28.260
but if the NSA or the NCSC,


00:13:28.260 --> 00:13:31.820
they come out and publicly call out Python 2 like this,


00:13:31.820 --> 00:13:35.540
well, that maybe carries more weight than Python bytes.


00:13:35.540 --> 00:13:37.100
Not that we don't carry some weight, I'm sure.


00:13:37.100 --> 00:13:38.500
- Yeah, it actually makes me think, though.


00:13:38.500 --> 00:13:40.620
Like, let's say you have a library


00:13:40.620 --> 00:13:44.660
that now works on both Python 2 and 3,


00:13:44.660 --> 00:13:46.500
and somebody else is depending on it,


00:13:46.500 --> 00:13:49.020
and they're also depending on another library


00:13:49.020 --> 00:13:50.700
that is 2 only.


00:13:50.700 --> 00:13:52.580
They're gonna stick with 2,


00:13:52.580 --> 00:13:54.700
but if, like, for instance, you could push them


00:13:54.700 --> 00:13:58.540
if you stopped supporting Python 3 or Python 2.


00:13:58.540 --> 00:13:59.380
- That's a good question.


00:13:59.380 --> 00:14:03.100
In six months, do we have a obligation


00:14:03.100 --> 00:14:06.220
to actually cut Python 2 out of our libraries?


00:14:06.220 --> 00:14:08.100
I mean, I don't have any libraries people care about, but--


00:14:08.100 --> 00:14:10.980
- Maybe to force people to upgrade.


00:14:10.980 --> 00:14:12.220
Maybe you could do some help.


00:14:12.220 --> 00:14:15.020
- Yeah, most of these changes have been more self-serving


00:14:15.020 --> 00:14:16.260
or self-centered, right?


00:14:16.260 --> 00:14:19.940
Like NumPy and Django, all those folks dropped Python 2,


00:14:19.940 --> 00:14:21.940
not because they're like, "We're gonna fix the world,"


00:14:21.940 --> 00:14:23.820
but like, "We don't wanna maintain this stuff.


00:14:23.820 --> 00:14:25.940
"We wanna just move forward and use the cool features,


00:14:25.940 --> 00:14:26.980
"and we can't right now."


00:14:26.980 --> 00:14:28.300
- Yeah. - Yeah, pretty cool.


00:14:28.300 --> 00:14:32.620
I guess one other kind of interesting thing to call out from this report, article, whatever


00:14:32.620 --> 00:14:39.300
you call it, is that they said that Python's popularity makes updating the code imperative,


00:14:39.300 --> 00:14:40.460
which I thought was pretty interesting.


00:14:40.460 --> 00:14:42.160
It's like Python is so successful.


00:14:42.160 --> 00:14:43.740
It's so broadly deployed.


00:14:43.740 --> 00:14:45.700
We can't just ignore this.


00:14:45.700 --> 00:14:47.340
It's not like Adobe Flash.


00:14:47.340 --> 00:14:48.500
It's now running an old version.


00:14:48.500 --> 00:14:49.500
We should deal with it.


00:14:49.500 --> 00:14:54.540
It's like this is one of the really important parts of the computer infrastructure that


00:14:54.540 --> 00:14:55.540
they called out.


00:14:55.540 --> 00:14:59.140
Yeah, I mean, there's got to be other places where we get this kind of news, right?


00:14:59.140 --> 00:15:06.820
So I got a notification from a guy called Sebastian Steins, and he put up a, it's


00:15:06.820 --> 00:15:13.540
basically a Hacker News lookalike site called news.python.sc. I don't know what sc stands for.


00:15:13.540 --> 00:15:17.220
Yeah, it looks a lot like Hacker News, but it's just got Python stuff on it.


00:15:17.220 --> 00:15:22.420
And it's pretty neat. So I thought, oh, that's cool. We should talk about it.


00:15:22.420 --> 00:15:27.460
But one of the neat things about it is you put it all together relatively quickly in like a week or so


00:15:27.460 --> 00:15:30.100
And it's built on django


00:15:30.100 --> 00:15:35.060
And all of its open source so you can take it and look at how it's done


00:15:35.060 --> 00:15:39.540
And everything plus it's up and it's live and you can post stuff. It's neat


00:15:39.540 --> 00:15:44.020
And I thought yeah, maybe we'll cover this and then while I was thinking about covering it


00:15:44.020 --> 00:15:49.060
We got like two or three other people say tell us about this new news site


00:15:49.140 --> 00:15:50.900
So I think people are using it.


00:15:50.900 --> 00:15:51.700
It's kind of fun.


00:15:51.700 --> 00:15:52.420
What do you think?


00:15:52.420 --> 00:15:52.900
I like it.


00:15:52.900 --> 00:15:56.100
It definitely looks like Hacker News, but more Python at colors.


00:15:56.100 --> 00:16:00.260
And, you know, looking through this, this is these are all legitimately


00:16:00.260 --> 00:16:01.060
interesting things.


00:16:01.060 --> 00:16:03.140
I'm like, yeah, oh, yeah, I read about that.


00:16:03.140 --> 00:16:03.780
That was cool.


00:16:03.780 --> 00:16:05.140
And, oh, I didn't know about that.


00:16:05.140 --> 00:16:05.860
But interesting.


00:16:05.860 --> 00:16:07.060
Yeah, I feel like this is great.


00:16:07.060 --> 00:16:10.260
And even if it doesn't take off, I think it's cool to have an example of


00:16:10.260 --> 00:16:15.140
a working model of simple with, like, people being able to vote things up


00:16:15.140 --> 00:16:20.620
and down and that's kind of a neat model to say there's a working


00:16:20.620 --> 00:16:25.780
website, a working user model, how can I emulate that in Python? Yeah, it's


00:16:25.780 --> 00:16:29.180
super cool. I'm definitely gonna start checking it out as one of my new


00:16:29.180 --> 00:16:32.860
sources in addition to Redis and Twitter and other places. Yeah, like we don't have


00:16:32.860 --> 00:16:37.660
enough to do. I know, now you just gave me work man, come on, it's homework. So you've


00:16:37.660 --> 00:16:42.180
heard that most people are moving to the cloud and data science is moving to the


00:16:42.180 --> 00:16:46.300
cloud, there's all sorts of interesting stuff happening up there. But you know a


00:16:46.300 --> 00:16:49.380
lot of times this type of work, especially training like machine


00:16:49.380 --> 00:16:54.180
learning models and stuff, is super super intensive. So if you've got like a


00:16:54.180 --> 00:16:58.400
laptop, some of the GPU processing and other really interesting things are


00:16:58.400 --> 00:17:03.780
inaccessible to you. Like for example my MacBook is super killer but it's got you


00:17:03.780 --> 00:17:06.980
know like 12 cores if you count the hyper threads and it's got 32 gigs of


00:17:06.980 --> 00:17:11.340
RAM, but it has a ATI, not a NVIDIA graphics card.


00:17:11.340 --> 00:17:13.980
So you can't use CUDA on it, for example, right?


00:17:13.980 --> 00:17:15.020
So what do I do?


00:17:15.020 --> 00:17:16.260
I go to the cloud.


00:17:16.260 --> 00:17:19.380
Well, if you're really into deep learning


00:17:19.380 --> 00:17:23.340
and you really want to do like data science with GPUs,


00:17:23.340 --> 00:17:24.900
there's this place called Lambda,


00:17:24.900 --> 00:17:27.700
this company called Lambda that is creating


00:17:27.700 --> 00:17:31.100
these deep learning workstation servers and laptops.


00:17:31.100 --> 00:17:32.540
Have you heard about this?


00:17:32.540 --> 00:17:33.380
- No.


00:17:33.380 --> 00:17:35.300
- Just to be clear, this is like a super commercial product.


00:17:35.300 --> 00:17:39.620
These are like servers that you buy and we have no this is not like a product placement


00:17:39.620 --> 00:17:44.820
I just ran across this and thought dang. This is interesting. So I thought I would just talk about it. So they're selling


00:17:44.820 --> 00:17:47.140
gpu accelerated


00:17:47.140 --> 00:17:49.860
tensorflow pytorch keras and other types of


00:17:49.860 --> 00:17:55.780
Pre-configured machines just they say just plug in and start training. You're good to go


00:17:55.780 --> 00:18:00.500
And they talk about how you can save a bunch of money, right? You don't run on the cloud


00:18:00.500 --> 00:18:02.820
The cloud can save you money for short work


00:18:02.820 --> 00:18:05.820
but if you got to do it over a long time it can get expensive.


00:18:05.820 --> 00:18:10.820
So they offer a TensorBook, which is a GPU training available laptop,


00:18:10.820 --> 00:18:15.820
capable laptop, for $2,900. That's a pricey laptop, right?


00:18:15.820 --> 00:18:16.820
Yeah.


00:18:16.820 --> 00:18:20.820
Actually, it's less expensive than my MacBook, but still.


00:18:20.820 --> 00:18:22.820
But if you were going to do GPU stuff,


00:18:22.820 --> 00:18:26.820
this is a really cool option to be able to do it on the go or be mobile.


00:18:26.820 --> 00:18:30.820
Then they also have a workstation, which is called LambdaQuad,


00:18:30.820 --> 00:18:33.460
quad which has four GPUs in it.


00:18:33.460 --> 00:18:35.700
And this one is $21,000.


00:18:35.700 --> 00:18:36.540
- Okay.


00:18:36.540 --> 00:18:37.360
- Okay, that's a lot.


00:18:37.360 --> 00:18:40.140
But if you go and like grab like a second tier


00:18:40.140 --> 00:18:43.300
GPU enabled EC2 instance,


00:18:43.300 --> 00:18:46.260
specifically a P3 8X large,


00:18:46.260 --> 00:18:49.200
that's over $12 an hour,


00:18:49.200 --> 00:18:52.940
which comes out to close to $9,000 a month in cloud bills.


00:18:52.940 --> 00:18:54.620
If you were to like run it all the time,


00:18:54.620 --> 00:18:55.980
obviously probably not all the time.


00:18:55.980 --> 00:18:58.660
But so you know, like $21,000 is a lot,


00:18:58.660 --> 00:19:01.940
but a $9,000 monthly bill for AWS is also a lot.


00:19:01.940 --> 00:19:03.620
- Yeah, it's something to pay attention to.


00:19:03.620 --> 00:19:05.900
As your bill starts getting bigger,


00:19:05.900 --> 00:19:08.180
maybe a dedicated hardware makes sense.


00:19:08.180 --> 00:19:09.900
- Anytime I run across something like this,


00:19:09.900 --> 00:19:12.220
if it were Alienware for gaming laptops


00:19:12.220 --> 00:19:14.220
or like the Apple MacBook Pro or whatever,


00:19:14.220 --> 00:19:16.420
it's like, all right, well, what if you're all in?


00:19:16.420 --> 00:19:17.940
What if you turn all the knobs to 11?


00:19:17.940 --> 00:19:19.300
What could you get?


00:19:19.300 --> 00:19:22.940
So they have this thing called the Lambda Hyperplane,


00:19:22.940 --> 00:19:25.980
which has eight Tesla V100 GPUs,


00:19:25.980 --> 00:19:27.800
and it starts at, it's not the final price,


00:19:27.800 --> 00:19:30.000
It starts at $114,000.


00:19:30.000 --> 00:19:31.080
- Nice.


00:19:31.080 --> 00:19:32.440
That's without the pinstriping.


00:19:32.440 --> 00:19:33.280
- Yeah, exactly.


00:19:33.280 --> 00:19:36.000
That's not even the leather-bound keyboard


00:19:36.000 --> 00:19:38.000
or whatever, I don't know.


00:19:38.000 --> 00:19:41.100
Anyway, if you're into deep learning


00:19:41.100 --> 00:19:43.920
and you need GPUs for computational stuff,


00:19:43.920 --> 00:19:46.240
data science and whatnot, this is actually pretty cool.


00:19:46.240 --> 00:19:48.520
- Yeah, also, I'm sure there's applications


00:19:48.520 --> 00:19:49.960
where you really don't wanna use the cloud.


00:19:49.960 --> 00:19:52.700
You wanna use in-house computers and not go out,


00:19:52.700 --> 00:19:53.920
or the connection's bad.


00:19:53.920 --> 00:19:56.820
You're sticking some data in the middle of nowhere


00:19:56.820 --> 00:19:58.740
or something and you can't get to the end of it.


00:19:58.740 --> 00:20:00.260
- Right, right, if you got terabytes of data,


00:20:00.260 --> 00:20:02.680
like that takes days to upload.


00:20:02.680 --> 00:20:05.420
So maybe it's better to just run it locally, who knows.


00:20:05.420 --> 00:20:06.780
Black has been a big hit.


00:20:06.780 --> 00:20:08.500
- Yeah, I like black.


00:20:08.500 --> 00:20:09.340
- Yeah, for sure.


00:20:09.340 --> 00:20:10.700
- A lot of people do.


00:20:10.700 --> 00:20:11.540
- Oh yeah.


00:20:11.540 --> 00:20:13.860
- One of the things, so I ran across an article,


00:20:13.860 --> 00:20:16.320
it's not a new article, but it's all still relevant.


00:20:16.320 --> 00:20:18.500
It's auto formatters in Python.


00:20:18.500 --> 00:20:20.500
And big shock, black's in there.


00:20:20.500 --> 00:20:23.380
But one of the things I liked about it is they talked,


00:20:23.380 --> 00:20:25.620
they spent a little bit of time talking about


00:20:25.620 --> 00:20:28.580
why you want to use black or something else.


00:20:28.580 --> 00:20:32.320
And I'm finding this more and more as a team lead


00:20:32.320 --> 00:20:35.060
that just it's not great to have,


00:20:35.060 --> 00:20:36.980
like if you're doing code reviews,


00:20:36.980 --> 00:20:38.660
you don't want to have like style


00:20:38.660 --> 00:20:40.300
be part of the code review.


00:20:40.300 --> 00:20:44.560
It's way better to have a tool just dictate the style.


00:20:44.560 --> 00:20:46.540
And so people can argue with the tool


00:20:46.540 --> 00:20:47.740
instead of arguing with each other.


00:20:47.740 --> 00:20:49.340
- Yeah, it's like if the code review,


00:20:49.340 --> 00:20:50.780
the people there, I'm sure they feel like,


00:20:50.780 --> 00:20:52.860
well, I have to make a constructive


00:20:52.860 --> 00:20:55.180
or critical comment about something.


00:20:55.180 --> 00:20:59.320
shouldn't be "why are you indenting like that?" or "why is there not a space by


00:20:59.320 --> 00:21:02.640
those commas?" Like that's the stuff machines can agree upon and just do for


00:21:02.640 --> 00:21:06.680
us, right? Like have architectural or algorithmic conversations, right? Yeah, you


00:21:06.680 --> 00:21:10.520
should be using three double quotes there instead of one. So get off the


00:21:10.520 --> 00:21:14.720
style police and use an auto formatter instead. I love black, a lot of people do,


00:21:14.720 --> 00:21:20.360
but there's reasons for some people like an established code base or other


00:21:20.360 --> 00:21:24.660
predefined style guide that maybe it's too much.


00:21:24.660 --> 00:21:27.680
It does do things that sometimes I don't like it to do.


00:21:27.680 --> 00:21:30.440
So there's a couple other options,


00:21:30.440 --> 00:21:35.380
and this article talks about AutoPep8 and YAPF.


00:21:35.380 --> 00:21:39.220
Now AutoPep8 is essentially just, it just does Pep8,


00:21:39.220 --> 00:21:42.200
or uses PyCode style, the utility,


00:21:42.200 --> 00:21:45.340
to detect Pep8 violations and just change the code.


00:21:45.340 --> 00:21:47.180
You can do both with it.


00:21:47.180 --> 00:21:50.500
It does less than black, but it doesn't do much more.


00:21:50.500 --> 00:21:53.420
So if really you're just trying to stick to PEP8,


00:21:53.420 --> 00:21:56.660
maybe that'd be better to use.


00:21:56.660 --> 00:21:58.980
And the other end of it is YAPF,


00:21:58.980 --> 00:22:01.700
which is a tool out of, I don't know how to say that.


00:22:01.700 --> 00:22:02.940
Yap-oof? - Yap-oof.


00:22:02.940 --> 00:22:05.180
- It's probably yet another Python formatter.


00:22:05.180 --> 00:22:06.100
- Yeah, it probably is.


00:22:06.100 --> 00:22:07.300
- It's a Google tool.


00:22:07.300 --> 00:22:08.260
I think it's Google.


00:22:08.260 --> 00:22:09.260
I think it's good if you want,


00:22:09.260 --> 00:22:12.100
it's got a lot of knobs and dials, a lot of customization.


00:22:12.100 --> 00:22:15.120
So if black doesn't have enough controls for you


00:22:15.120 --> 00:22:19.620
and you really want to tweak it to be your personal company's code style,


00:22:19.620 --> 00:22:21.620
this might be great for you.


00:22:21.620 --> 00:22:27.420
In the documentation it says it takes away some of the drudgery in maintaining your code


00:22:27.420 --> 00:22:30.820
and what just ultimate goal is to code


00:22:30.820 --> 00:22:36.120
is that it produces as good a code as that a programmer would write if they were following the style guide.


00:22:36.120 --> 00:22:37.320
That sounds pretty good, honestly.


00:22:37.320 --> 00:22:43.320
One of the interesting things, I was researching this story is I didn't know this about Black.


00:22:43.320 --> 00:22:46.720
after it's changed your code, it does a check


00:22:46.720 --> 00:22:49.000
to see if the reformatted code


00:22:49.000 --> 00:22:51.320
still produces a valid


00:22:51.320 --> 00:22:53.320
abstract syntax tree


00:22:53.320 --> 00:22:55.320
that is equivalent to the original.


00:22:55.320 --> 00:22:57.160
That's pretty cool. I didn't know it did that.


00:22:57.160 --> 00:23:00.680
Yeah, that is cool. So run it through the Python parser


00:23:00.680 --> 00:23:05.600
and turn it into bytecode and then just see if the essence is the same, which


00:23:05.600 --> 00:23:06.440
yeah, I mean,


00:23:06.440 --> 00:23:10.880
because you don't actually want to change the meaning of the way the code actually gets interpreted, it's just formatting, right?


00:23:10.880 --> 00:23:13.560
So the meaning changes like, well, that might be a problem.


00:23:13.560 --> 00:23:14.400
- Yeah.


00:23:14.400 --> 00:23:16.280
The other thing I wanted to highlight this article for


00:23:16.280 --> 00:23:19.220
is it took a few code examples and just did the,


00:23:19.220 --> 00:23:20.680
what does black change it into?


00:23:20.680 --> 00:23:22.880
And what does YAPF change it into?


00:23:22.880 --> 00:23:24.680
And what does AutoPIP change it into?


00:23:24.680 --> 00:23:25.500
- Oh, that's sweet.


00:23:25.500 --> 00:23:26.340
I like that.


00:23:26.340 --> 00:23:27.160
- Yeah. - Very, very cool.


00:23:27.160 --> 00:23:28.840
All right, well, that's all of our main items.


00:23:28.840 --> 00:23:30.280
You got anything else you want to throw out there


00:23:30.280 --> 00:23:31.120
while we're here?


00:23:31.120 --> 00:23:32.440
- No, you?


00:23:32.440 --> 00:23:33.840
- Yes, a couple of things.


00:23:33.840 --> 00:23:35.760
I'm getting excited for PyCon US.


00:23:35.760 --> 00:23:39.460
It's earlier this year in April at some point, I'm guessing.


00:23:39.460 --> 00:23:41.940
But the announcement I want to make is that


00:23:41.940 --> 00:23:45.260
the applications for financial aid are open


00:23:45.260 --> 00:23:48.340
and they'll be accepting them through January 31st, 2020.


00:23:48.340 --> 00:23:52.340
So 30 days into a world with only Python 3.


00:23:52.340 --> 00:23:54.220
The Python Software Foundation and PyLadies


00:23:54.220 --> 00:23:57.020
are making this financial aid possible and check it out.


00:23:57.020 --> 00:24:00.980
Yeah, so like PSF is contributing $130,000 towards that.


00:24:00.980 --> 00:24:02.420
And yeah, it's pretty good.


00:24:02.420 --> 00:24:04.380
So if you're thinking, hey, I would really love


00:24:04.380 --> 00:24:06.660
to go to PyCon and make some connections,


00:24:06.660 --> 00:24:08.940
head into this world, use some networking


00:24:08.940 --> 00:24:11.060
and learn more about it, but I just can't justify


00:24:11.060 --> 00:24:13.180
the expense or afford it, maybe do that.


00:24:13.180 --> 00:24:14.020
- Yeah, nice.


00:24:14.020 --> 00:24:15.140
- Indeed, indeed.


00:24:15.140 --> 00:24:16.820
And I'm working on some new courses.


00:24:16.820 --> 00:24:18.500
I got one that's all done and recorded,


00:24:18.500 --> 00:24:19.420
just getting edited.


00:24:19.420 --> 00:24:23.020
Another one, I spent like six contiguous hours


00:24:23.020 --> 00:24:24.380
recording videos yesterday.


00:24:24.380 --> 00:24:25.660
That doesn't sound like a lot of time


00:24:25.660 --> 00:24:27.360
if you haven't done it, but six straight hours recording,


00:24:27.360 --> 00:24:28.900
that's a lot, so I'm really, really excited


00:24:28.900 --> 00:24:29.740
about what's coming out.


00:24:29.740 --> 00:24:31.380
We'll share more with it when I can.


00:24:31.380 --> 00:24:32.300
- Very exciting.


00:24:32.300 --> 00:24:33.620
- Oh yeah.


00:24:33.620 --> 00:24:36.100
Now, sometimes we have really short jokes.


00:24:36.100 --> 00:24:37.140
I see that you have one.


00:24:37.140 --> 00:24:40.360
- We got a short joke that was contributed by Eric Nelson.


00:24:40.360 --> 00:24:41.400
Thanks, Eric.


00:24:41.400 --> 00:24:42.680
It is a math joke.


00:24:42.680 --> 00:24:46.860
The joke is, "I is as complex as it gets."


00:24:46.860 --> 00:24:50.700
- I love it, I love it.


00:24:50.700 --> 00:24:53.360
Studied a bunch of complex analysis and things like that


00:24:53.360 --> 00:24:55.300
when I was doing math and yeah, I like it.


00:24:55.300 --> 00:24:57.560
- Yeah, we have another one too that it's long.


00:24:57.560 --> 00:25:00.440
- It's long and I'm not gonna be able to do justice to it,


00:25:00.440 --> 00:25:02.160
so you have to check this out.


00:25:02.160 --> 00:25:04.440
So you know the song "American Pie," right?


00:25:04.440 --> 00:25:05.280
- Yes.


00:25:05.280 --> 00:25:07.380
"Heavy to the levy, but the levy was dry."


00:25:07.380 --> 00:25:08.220
That sort of song.


00:25:08.220 --> 00:25:09.240
- Yeah, you can sing it.


00:25:09.240 --> 00:25:10.320
- No, no, I can't sing it.


00:25:10.320 --> 00:25:12.220
I could recite it.


00:25:12.220 --> 00:25:13.800
If I sing it, it's not gonna be singing.


00:25:13.800 --> 00:25:14.960
It's gonna be something else.


00:25:14.960 --> 00:25:15.920
There's another one.


00:25:15.920 --> 00:25:20.600
One of our listeners, I only know his username on Reddit,


00:25:20.600 --> 00:25:22.800
I'm afraid, I can't even find the tweet in time.


00:25:22.800 --> 00:25:26.080
Wait, said, "Hey, you inspired me to write this song


00:25:26.080 --> 00:25:28.640
"called 'American Pie, American P-Y'."


00:25:28.640 --> 00:25:33.180
And it's basically the story of Legacy Python


00:25:33.180 --> 00:25:35.500
done to American Pie the song.


00:25:35.500 --> 00:25:37.020
- Yeah, it's pretty awesome.


00:25:37.020 --> 00:25:38.180
- It's really, really well done.


00:25:38.180 --> 00:25:40.540
I'll just like recite a little bit here,


00:25:40.540 --> 00:25:41.460
one of the verses.


00:25:41.460 --> 00:25:44.460
So, "Bye bye to your legacy pies.


00:25:44.460 --> 00:25:47.660
"Made decisions about division, so you'll have to revise.


00:25:47.660 --> 00:25:50.820
"And UDecode's official, it's not a bunch of bite lies.


00:25:50.820 --> 00:25:52.400
"Singing that'll be the day it dies.


00:25:52.400 --> 00:25:53.400
"That'll be the day it dies."


00:25:53.400 --> 00:25:54.240
It's really good, yeah.


00:25:54.240 --> 00:25:55.060
People should check it out.


00:25:55.060 --> 00:25:57.980
If somebody can perform this and give it to us,


00:25:57.980 --> 00:25:59.740
he's given us permission to take that


00:25:59.740 --> 00:26:00.580
and put it on the air.


00:26:00.580 --> 00:26:01.940
If it's good enough, man, we'd love it.


00:26:01.940 --> 00:26:02.780
That'd be awesome.


00:26:02.780 --> 00:26:03.620
- I cannot do this.


00:26:03.620 --> 00:26:04.780
- I want somebody to sing it.


00:26:04.780 --> 00:26:06.260
'Cause it includes the phrase,


00:26:06.260 --> 00:26:08.680
"I was a crusty old fart coding guy."


00:26:08.680 --> 00:26:11.300
(laughing)


00:26:11.300 --> 00:26:13.460
- You could be a YouTube sensation


00:26:13.460 --> 00:26:16.480
if you just take this chance here.


00:26:16.480 --> 00:26:17.320
Jump on it.


00:26:17.320 --> 00:26:18.980
- Yes, and if you do, let us know.


00:26:18.980 --> 00:26:19.940
- Yeah, for sure, let us know.


00:26:19.940 --> 00:26:20.940
That'd be awesome.


00:26:20.940 --> 00:26:24.140
All right, well, yeah, this really nice song


00:26:24.140 --> 00:26:26.020
and a nice job there.


00:26:26.020 --> 00:26:27.620
Well done on that.


00:26:27.620 --> 00:26:29.700
And Brian, thanks for everything.


00:26:29.700 --> 00:26:30.540
Thanks for being here. - Thank you.


00:26:30.540 --> 00:26:31.360
- And sharing this.


00:26:31.360 --> 00:26:32.200
Yep, you bet.


00:26:32.200 --> 00:26:36.600
Thank you for listening to Python Bytes. Follow the show on Twitter @PythonBytes.


00:26:36.600 --> 00:26:41.320
That's Python Bytes as in B-Y-T-E-S. And get the full show notes at


00:26:41.320 --> 00:26:45.680
PythonBytes.fm. If you have a news item you want featured, just visit


00:26:45.680 --> 00:26:49.200
PythonBytes.fm and send it our way. We're always on the lookout for sharing


00:26:49.200 --> 00:26:53.000
something cool. This is Brian Okken, and on behalf of myself and Michael Kennedy,


00:26:53.000 --> 00:26:58.280
thank you for listening and sharing this podcast with your friends and colleagues.

