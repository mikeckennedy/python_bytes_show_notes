
00:00:00.000 --> 00:00:06.880
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode


00:00:06.880 --> 00:00:10.920
100 very exciting very exciting episode 100


00:00:10.920 --> 00:00:17.200
Recorded October 10th 2018. I'm Michael Kennedy and I'm Brian Arkin. Hey Brian. It's not just us this time is it?


00:00:17.200 --> 00:00:20.200
No, we've got some wonderful guests. Yeah, so I want to welcome


00:00:20.200 --> 00:00:23.800
Anthony Shaw Dan Bader Brett Cannon and Nina


00:00:24.360 --> 00:00:29.240
to the show, all of whom have been on the show before,


00:00:29.240 --> 00:00:31.080
but have come here to help us celebrate.


00:00:31.080 --> 00:00:31.920
Hello everyone.


00:00:31.920 --> 00:00:33.160
- Hey, and congratulations.


00:00:33.160 --> 00:00:34.120
- Hi.


00:00:34.120 --> 00:00:35.000
- Hi.


00:00:35.000 --> 00:00:36.480
Thank you, thank you, Dan.


00:00:36.480 --> 00:00:38.460
It's great to have you all here to celebrate


00:00:38.460 --> 00:00:41.320
this big episode and go a little bit deeper


00:00:41.320 --> 00:00:42.160
on some of the topics.


00:00:42.160 --> 00:00:43.480
It's gonna be a lot of fun.


00:00:43.480 --> 00:00:45.060
So before we get to the first topic,


00:00:45.060 --> 00:00:47.320
really quickly wanna say thank you to DigitalOcean


00:00:47.320 --> 00:00:49.200
who helped us reach this milestone.


00:00:49.200 --> 00:00:51.960
Check them out at pythonbytes.fm/digitalocean.


00:00:51.960 --> 00:00:54.560
get a $100 credit for new users.


00:00:54.560 --> 00:00:56.440
Brian, you wanna kick off our first item


00:00:56.440 --> 00:00:58.800
with something poetic?


00:00:58.800 --> 00:01:00.280
- Yeah, definitely.


00:01:00.280 --> 00:01:04.960
Poetry is a Python project that a lot of people have,


00:01:04.960 --> 00:01:07.600
since we've talked about packaging quite a few times,


00:01:07.600 --> 00:01:08.440
a lot of people have said,


00:01:08.440 --> 00:01:10.400
"Hey, you should check out Poetry."


00:01:10.400 --> 00:01:13.960
And I just finally got a chance to.


00:01:13.960 --> 00:01:15.680
I've been taking a look at it this week,


00:01:15.680 --> 00:01:19.800
and it's kinda cool, but it's a big,


00:01:19.800 --> 00:01:22.180
This topic is actually kind of a can of worms.


00:01:22.180 --> 00:01:25.120
There's essentially Poetry on its tagline.


00:01:25.120 --> 00:01:28.560
It says Poetry is a tool to handle dependency installation


00:01:28.560 --> 00:01:32.500
as well as building and packaging of Python packages.


00:01:32.500 --> 00:01:34.500
And it all does it with one file,


00:01:34.500 --> 00:01:37.160
the pyproject.toml file.


00:01:37.160 --> 00:01:40.600
So that replaces the setup.py, the requirements.txt,


00:01:40.600 --> 00:01:44.520
setup.cfg, manifests, and even pip file.


00:01:44.520 --> 00:01:47.040
And that's where the can of worms comes in.


00:01:47.040 --> 00:01:53.840
So this is sort of like pipenv, but with a completely different file structure behind it.


00:01:53.840 --> 00:01:56.280
It does do virtual environment support as well.


00:01:56.280 --> 00:01:58.080
So it does a lot.


00:01:58.080 --> 00:01:59.240
I'm not sure.


00:01:59.240 --> 00:02:06.480
I was surprised that you can build packages and put them up on PyPI without a setup.py file anymore.


00:02:06.480 --> 00:02:09.080
Those aren't required, I don't think.


00:02:09.080 --> 00:02:15.320
And I was surprised that, so these are also related to PEP 517 and 518.


00:02:15.880 --> 00:02:18.560
And surprisingly enough, I was surprised to find


00:02:18.560 --> 00:02:22.240
that Brett Cannon was part of those as well.


00:02:22.240 --> 00:02:25.600
So I actually, I'd like to get Brett


00:02:25.600 --> 00:02:28.720
or somebody else's opinion or information about this.


00:02:28.720 --> 00:02:31.640
- Yeah, so the peps that Brian's talking about,


00:02:31.640 --> 00:02:35.580
pep 517, 518, 518 actually got finished first.


00:02:35.580 --> 00:02:38.760
And that's what's defined the pyproject.toml file,


00:02:38.760 --> 00:02:43.040
which is originally written to provide a structured file


00:02:43.040 --> 00:02:47.160
for information required to build a package.


00:02:47.160 --> 00:02:48.840
So something you would upload to PyPI.


00:02:48.840 --> 00:02:51.860
It was not originally intended for projects,


00:02:51.860 --> 00:02:56.340
so not like your website or web app or something like that.


00:02:56.340 --> 00:02:58.860
And then subsequently, PEP 517 standardized


00:02:58.860 --> 00:03:00.840
what could go in the pyproject.toml


00:03:00.840 --> 00:03:03.800
to specify how to build your package.


00:03:03.800 --> 00:03:06.960
So this is why, Brian, you don't need setup.py anymore.


00:03:06.960 --> 00:03:10.160
These two PEPs basically supersede the need for that


00:03:10.160 --> 00:03:13.280
by standardizing because setup.py has a problem


00:03:13.280 --> 00:03:16.200
of being executable code and being fairly tied


00:03:16.200 --> 00:03:17.280
to setup tools.


00:03:17.280 --> 00:03:18.840
This completely makes it independent,


00:03:18.840 --> 00:03:22.100
which lets you use projects such as flit or poetry


00:03:22.100 --> 00:03:23.520
to actually build your libraries.


00:03:23.520 --> 00:03:25.000
- That's really interesting because when you do


00:03:25.000 --> 00:03:29.080
a pip install, Brett, you're basically executing


00:03:29.080 --> 00:03:31.380
the setup.py, which like you said,


00:03:31.380 --> 00:03:33.240
it could just be, here are my dependencies,


00:03:33.240 --> 00:03:34.080
please register them.


00:03:34.080 --> 00:03:36.320
It could be, install this horrible thing


00:03:36.320 --> 00:03:38.000
and format my hard drive, right?


00:03:38.000 --> 00:03:42.400
So now we have a safe way to pick up and install a thing.


00:03:42.400 --> 00:03:45.880
Do you foresee a thing marking a package


00:03:45.880 --> 00:03:48.400
as having no executable code on install?


00:03:48.400 --> 00:03:50.040
- Well, so you actually already have that


00:03:50.040 --> 00:03:51.960
anytime you install a wheel.


00:03:51.960 --> 00:03:53.860
So wheels are specifically designed


00:03:53.860 --> 00:03:55.960
that it's essentially a unzipping


00:03:55.960 --> 00:03:57.080
and copying some files around.


00:03:57.080 --> 00:04:00.200
There is no actual code executed as part of the build.


00:04:00.200 --> 00:04:03.760
So only source distributions are the only time


00:04:03.760 --> 00:04:06.960
you ever actually are executing code like that.


00:04:06.960 --> 00:04:08.960
And you are right, there is a potential security risk.


00:04:08.960 --> 00:04:12.960
Honestly though, the really big benefit of moving away from executable code


00:04:12.960 --> 00:04:15.960
in a setup.py to something like a pyproject.toml


00:04:15.960 --> 00:04:17.960
is it allows for better introspection.


00:04:17.960 --> 00:04:20.960
Because before this, if you wanted to take a package


00:04:20.960 --> 00:04:23.960
as this file, for instance, and figure out what dependencies it had,


00:04:23.960 --> 00:04:26.960
if you had the wheel, that's in a metadata file, it doesn't make a big deal.


00:04:26.960 --> 00:04:31.960
But if you only had the setup.py, you basically had to shim out setup tools,


00:04:31.960 --> 00:04:34.960
or run setup tools, and not have it run its install step


00:04:34.960 --> 00:04:37.080
to find out what dependencies were programmatically.


00:04:37.080 --> 00:04:40.360
But with PyProject.toml and this sort of specification,


00:04:40.360 --> 00:04:41.640
it allows you to get away from that.


00:04:41.640 --> 00:04:42.280
Interesting.


00:04:42.280 --> 00:04:44.520
And one of the things I wanted to mention was just that


00:04:44.520 --> 00:04:48.360
if people are considering whether to use pipenv or


00:04:48.360 --> 00:04:50.800
in that route or poetry,


00:04:50.800 --> 00:04:52.640
they're just, they're different workflows.


00:04:52.640 --> 00:04:55.720
And I would recommend people just try both of them out


00:04:55.720 --> 00:04:58.240
and see which workflow fits better for you.


00:04:58.240 --> 00:05:01.120
As far as I can tell from Brett's comments offline


00:05:01.120 --> 00:05:03.560
is that both of these peps are provisional,


00:05:03.560 --> 00:05:05.560
but they're probably not going to go away.


00:05:05.560 --> 00:05:08.040
Is it safe for me to convert my project


00:05:08.040 --> 00:05:10.760
to away from setup.py and use


00:05:10.760 --> 00:05:14.320
pyproject.toml now or is there a risk that that'll go away?


00:05:14.320 --> 00:05:16.560
>> No, there's absolutely no risk it's going to go away.


00:05:16.560 --> 00:05:19.840
This is the future of packaging in Python to the point that I


00:05:19.840 --> 00:05:23.240
actually updated pet518 maybe two months ago to take


00:05:23.240 --> 00:05:26.280
away the specification that it was meant for libraries,


00:05:26.280 --> 00:05:27.920
and just to say it's a configuration file.


00:05:27.920 --> 00:05:31.520
Because actually when Poetry started using pyproject.toml,


00:05:31.520 --> 00:05:37.120
it kind of did it against the recommendation of the PEP because the PEP originally said it was designed for libraries and packages,


00:05:37.120 --> 00:05:40.560
not for applications. And they started to use it that way.


00:05:40.560 --> 00:05:47.760
And other people such as Black, which I believe we'll maybe touch on later, also started to integrate with it and such.


00:05:47.760 --> 00:05:50.640
And various other projects have. So we actually took away that wording.


00:05:50.640 --> 00:05:57.200
But the provisional just basically means we reserve the right to maybe tweak some of the wording requirements.


00:05:57.200 --> 00:06:00.720
but this is very squarely the future of Python packaging,


00:06:00.720 --> 00:06:02.560
so they're definitely not going anywhere.


00:06:02.560 --> 00:06:03.600
Okay, wonderful.


00:06:03.600 --> 00:06:04.320
Yeah, very cool.


00:06:04.320 --> 00:06:08.720
Does that mean that the person installing the package


00:06:08.720 --> 00:06:10.880
needs to have a specific version of pip?


00:06:10.880 --> 00:06:14.560
Like, to support the...


00:06:14.560 --> 00:06:18.240
Because setup.py is cool because it can work with a really,


00:06:18.240 --> 00:06:20.320
really old version of pip, which is pretty common.


00:06:20.320 --> 00:06:24.080
So the new Toml file, does it need the users


00:06:24.080 --> 00:06:26.080
to actually have a newer version of pip to work?


00:06:27.040 --> 00:06:30.880
Yes, only though, once again, if you're installing from a source distribution,


00:06:30.880 --> 00:06:33.400
which is once again, why wheels are so important,


00:06:33.400 --> 00:06:36.080
that if you had a wheel, all of this is completely mute.


00:06:36.080 --> 00:06:38.360
I mean, basically, this is just how to build a wheel.


00:06:38.360 --> 00:06:41.400
And even the way Pip's workflow now is structured,


00:06:41.400 --> 00:06:45.160
is pip basically takes the SDist, builds a wheel, and then installs that wheel.


00:06:45.160 --> 00:06:49.800
And that's actually what pip 5.17 specifies is an API to call into Python code


00:06:49.800 --> 00:06:54.280
of how to ask a build tool such as Flit, for instance, or Poetry,


00:06:54.280 --> 00:06:55.980
"Hey, can you build me a wheel?"


00:06:55.980 --> 00:06:57.120
"Okay, now that you have a wheel,


00:06:57.120 --> 00:06:59.080
can you help me install a potential?"


00:06:59.080 --> 00:07:00.080
Or what have you.


00:07:00.080 --> 00:07:03.800
So it is only in the newer PIPs.


00:07:03.800 --> 00:07:07.240
I believe it was pip either 10 or 18,


00:07:07.240 --> 00:07:09.480
'cause they changed their numbering scheme recently.


00:07:09.480 --> 00:07:10.300
They added the support,


00:07:10.300 --> 00:07:12.000
so it's only within the last two versions


00:07:12.000 --> 00:07:13.000
that they've had it.


00:07:13.000 --> 00:07:14.880
But once again, if you have wheels,


00:07:14.880 --> 00:07:17.760
it's completely unnecessary technical detail.


00:07:17.760 --> 00:07:18.720
- Dan, you were trying to jump in there.


00:07:18.720 --> 00:07:20.680
- You know, I've never really heard before


00:07:20.680 --> 00:07:24.200
of the TOML format, and even the name is hilarious.


00:07:24.200 --> 00:07:26.880
I think it's like, isn't it like Tom's format or something like that?


00:07:26.880 --> 00:07:29.720
It has like the name of the inventor in there somewhere.


00:07:29.720 --> 00:07:34.080
And this is curious if this is something, I don't know, established or where, for


00:07:34.080 --> 00:07:36.680
me, it's sort of like out of the left field kind of format.


00:07:36.680 --> 00:07:39.720
And I was just wondering, you know, if this is something, what makes it so


00:07:39.720 --> 00:07:44.960
awesome by comparison to JSON or YAML or whatever the other options were, I guess


00:07:44.960 --> 00:07:46.760
a plain any file or something like that.


00:07:46.760 --> 00:07:50.840
I will say that there's a very long section in the PEP explaining


00:07:50.840 --> 00:07:52.360
all the reasons we did this.


00:07:53.160 --> 00:07:55.740
- So we actually don't-- - I was going to ask.


00:07:55.740 --> 00:07:58.360
Sorry, have you seen a Toml file?


00:07:58.360 --> 00:08:02.440
I just started using Black more heavily, pretty much everywhere,


00:08:02.440 --> 00:08:04.880
and it required me to set up a Toml file.


00:08:04.880 --> 00:08:07.480
I was like, "Yeah, okay, it's pretty nice, pretty straightforward.


00:08:07.480 --> 00:08:10.380
Feels like an .ini file, but it seems like it's a little bit different."


00:08:10.380 --> 00:08:11.580
So I was just curious.


00:08:11.580 --> 00:08:15.480
Yeah, I mean, compared to JSON with all the extra curly brackets


00:08:15.480 --> 00:08:18.220
or even YAML gets pretty messy,


00:08:18.220 --> 00:08:21.060
I think it's a really nice format for configuration.


00:08:21.060 --> 00:08:26.060
Yeah, and one of the reasons we chose it is Rust has standardized on TOML for all their packaging details.


00:08:26.060 --> 00:08:31.260
So we actually reached out to them before we did this and said, "Hey, we noticed you've been using TOML,"


00:08:31.260 --> 00:08:36.060
which some people called the only markup language to take the creator's name out of it.


00:08:36.060 --> 00:08:40.360
And they said they had no regrets. They really liked using it.


00:08:40.360 --> 00:08:47.060
And it was basically readable without any ambiguous corner cases.


00:08:47.060 --> 00:08:50.620
And that was basically it, really.


00:08:50.620 --> 00:08:55.820
It was, as Nina said, JSONs can be really messy to read if you don't format it well.


00:08:55.820 --> 00:09:00.700
YAML is decent, but there's also some execution problems if you're not careful.


00:09:00.700 --> 00:09:05.420
INI files are underspecified and really not specified in any way other than


00:09:05.420 --> 00:09:10.820
what the module in the standard library happens to say in INI files, at least in the Python community.


00:09:10.820 --> 00:09:14.620
And then Toml just happens to be more well established and specified.


00:09:14.620 --> 00:09:21.620
I for one am excited about a new text format that doesn't let you execute Python code just by putting exclamation marks or something in it.


00:09:21.620 --> 00:09:25.620
Safe load. Safe load all the way.


00:09:25.620 --> 00:09:26.620
Yes, exactly.


00:09:26.620 --> 00:09:27.620
Or load safe.


00:09:27.620 --> 00:09:36.620
Nina, do you use pip, inf, or poetry, or are you just a straight pip and virtual environments person?


00:09:36.620 --> 00:09:41.620
I actually have not heard about poetry before today, so I'll definitely be checking it out.


00:09:41.620 --> 00:09:47.620
But I use a mix of requirements.txt for simpler projects and pipenv when things get more complex.


00:09:47.620 --> 00:09:53.620
Yeah, cool. I still haven't got my mind around pipenv, so I'm starting to wonder if maybe I should just learn poetry instead.


00:09:53.620 --> 00:09:55.620
So I'm pretty excited about this, actually.


00:09:55.620 --> 00:10:01.620
There's a pipenv integration in VS Code, and it's pretty nice. It takes a lot of the thinking out of it.


00:10:01.620 --> 00:10:03.620
Oh, that's awesome. Yeah, very cool.


00:10:03.620 --> 00:10:09.060
Anthony, so you found a way to relate llamas to Python, is this correct?


00:10:09.060 --> 00:10:16.260
Yeah, so I've been looking into tools for measuring code complexity.


00:10:16.260 --> 00:10:23.700
So I guess the idea is that less is more. So as an application grows, as a code base grows over


00:10:23.700 --> 00:10:30.180
time, you end up adding all these edge cases and unique customer requirements and stuff like that.


00:10:30.180 --> 00:10:34.820
and the code can get more and more unmaintainable and complicated.


00:10:34.820 --> 00:10:40.180
So there's a few ways of measuring the complexity of your code.


00:10:40.180 --> 00:10:43.460
And one tool that I came across was called Radon.


00:10:43.460 --> 00:10:48.020
And it's a Python tool that leverages the AST,


00:10:48.020 --> 00:10:51.380
I guess the thing which is built into Python,


00:10:51.380 --> 00:10:55.700
which turns your code into a tree that it then executes.


00:10:55.700 --> 00:10:59.300
And one of the stats is called cyclomatic complexity,


00:10:59.300 --> 00:11:05.220
which is not unique to Python. It's used in other languages as well, but it kind of measures the


00:11:05.220 --> 00:11:11.060
number of decisions within your code base by iterating through the tree, which is really cool.


00:11:11.060 --> 00:11:14.180
That's cool. One way I like to think of cyclomatic complexity is like,


00:11:14.180 --> 00:11:18.340
if I'm going to test this code, what is the minimum number of unit tests I have to have


00:11:18.340 --> 00:11:23.300
to actually test all the parts? It's not exactly true, but it's sort of true because you got to go


00:11:23.300 --> 00:11:24.340
go down each path, right?


00:11:24.340 --> 00:11:26.500
- Yeah, the way I always think of it


00:11:26.500 --> 00:11:29.620
is when you go driving somewhere,


00:11:29.620 --> 00:11:31.220
how you always try and pick the route


00:11:31.220 --> 00:11:34.220
which requires the fewest number of left or right turns.


00:11:34.220 --> 00:11:37.420
So just going, even if it takes longer,


00:11:37.420 --> 00:11:40.420
just it's an easier drive if you can just pick one road


00:11:40.420 --> 00:11:43.300
and stick to it rather than taking all these back roads


00:11:43.300 --> 00:11:45.100
and having to remember all the paths and stuff.


00:11:45.100 --> 00:11:48.340
So that's how I kind of think of cyclomatic complexity.


00:11:48.340 --> 00:11:49.940
And the other one that they've got


00:11:49.940 --> 00:11:51.620
is a maintainability index,


00:11:51.620 --> 00:11:54.620
which is a combination of the number of lines of code


00:11:54.620 --> 00:11:57.300
that you have, and also something called the Halsted,


00:11:57.300 --> 00:12:01.100
which is the number of operations in your AST.


00:12:01.100 --> 00:12:03.100
So yeah, basically Radon is a tool


00:12:03.100 --> 00:12:04.580
that you can run over your code base,


00:12:04.580 --> 00:12:08.180
and it'll tell you how complex the code is,


00:12:08.180 --> 00:12:11.300
or a part of your code, by adding a special visitor


00:12:11.300 --> 00:12:12.780
to the AST, which is really cool.


00:12:12.780 --> 00:12:14.100
- And that's really cool.


00:12:14.100 --> 00:12:15.820
So I have no experience with the Radon.


00:12:15.820 --> 00:12:18.700
I know it as a gas that leaks out of the ground,


00:12:18.700 --> 00:12:19.780
that can be radioactive,


00:12:19.780 --> 00:12:21.340
but that doesn't have anything to do with llamas.


00:12:21.340 --> 00:12:22.340
- What's the PyLlama?


00:12:22.340 --> 00:12:27.340
- The Llama, so the Llama is another tool that I found


00:12:27.340 --> 00:12:30.700
which brings together Radon and a whole bunch


00:12:30.700 --> 00:12:33.780
of other tools used for looking at the quality


00:12:33.780 --> 00:12:35.900
of your code in air quotes.


00:12:35.900 --> 00:12:38.560
So PyCode style, PyFlakes.


00:12:38.560 --> 00:12:43.160
It also includes GJS Lint, which is a fork of JS Lint,


00:12:43.160 --> 00:12:45.140
which is a JavaScript linter.


00:12:45.140 --> 00:12:48.180
I'm not sure why it includes a JavaScript linter.


00:12:48.180 --> 00:12:53.260
I think the idea is that you run it over Django and other projects where you've got sort of


00:12:53.260 --> 00:12:58.420
nested JavaScript in your code, and it can basically go and give you linting in your


00:12:58.420 --> 00:13:03.060
web applications on not just the Python, but on the JavaScript as well.


00:13:03.060 --> 00:13:08.220
And it also includes another tool called McCabe, which is a project that Ned Batchelder put


00:13:08.220 --> 00:13:13.600
together, which is another way of measuring complexity by looking at the number of branches.


00:13:13.600 --> 00:13:15.220
So that's pretty cool.


00:13:15.220 --> 00:13:20.420
Yeah, my sort of final goal was to actually write a pytest plugin


00:13:20.420 --> 00:13:25.220
that kind of benchmarks the complexity of your code in order to pass the tests.


00:13:25.220 --> 00:13:29.620
And then the idea was that you could make the code, the tests fail


00:13:29.620 --> 00:13:34.020
if someone has basically made the behavior the same but the code more complicated.


00:13:34.020 --> 00:13:35.220
That's really cool. I love it.


00:13:35.220 --> 00:13:39.220
So like if cyclomatic complexity of any function gets above 10,


00:13:39.220 --> 00:13:41.620
just boom, fail the build. That's what you're thinking?


00:13:41.620 --> 00:13:45.420
I feel like it's more than it was before.


00:13:45.420 --> 00:13:49.980
It would be really funny to plug this into a pre-commit hook where you just can't even


00:13:49.980 --> 00:13:50.980
commit your code.


00:13:50.980 --> 00:13:55.800
We reject it, it's too complicated.


00:13:55.800 --> 00:13:59.380
So have you run this on one of your existing code bases?


00:13:59.380 --> 00:14:03.280
I have done on previous tools and some other code bases.


00:14:03.280 --> 00:14:07.620
It's kind of, yeah, how about you, Nina?


00:14:07.620 --> 00:14:09.620
Oh, throwing it back.


00:14:09.620 --> 00:14:10.620
I have not.


00:14:10.620 --> 00:14:15.380
Kind of just spews out a number and you're like, okay, that's interesting.


00:14:15.380 --> 00:14:16.700
Is that good or bad?


00:14:16.700 --> 00:14:22.180
So it doesn't really mean anything unless you look at it historically, is what I found.


00:14:22.180 --> 00:14:28.180
And I've run a similar tool like this on .NET code bases and Java code bases, which can


00:14:28.180 --> 00:14:33.080
get extremely complicated, especially because like every feature that ends up getting added


00:14:33.080 --> 00:14:37.820
is basically just adding another if statement somewhere to deal with some weird edge case.


00:14:37.820 --> 00:14:40.100
Yeah, this is a really interesting one.


00:14:40.100 --> 00:14:42.920
I would like to propose another measure of complexity


00:14:42.920 --> 00:14:44.280
is the number of types involved


00:14:44.280 --> 00:14:47.000
in any particular function as well.


00:14:47.000 --> 00:14:49.080
But yeah, it's cool.


00:14:49.080 --> 00:14:51.200
Brett, have you got any experience with any of this?


00:14:51.200 --> 00:14:53.360
- Not beyond the fact that PyLama is supported


00:14:53.360 --> 00:14:55.240
by the Python extension for VS Code.


00:14:55.240 --> 00:14:58.040
- Ooh, nice, yeah, so built right into the editor there.


00:14:58.040 --> 00:14:58.880
That's cool.


00:14:58.880 --> 00:15:01.160
Nice.


00:15:01.160 --> 00:15:04.280
So Nina, the topic you wanna cover


00:15:04.280 --> 00:15:05.800
is around teaching Python,


00:15:05.800 --> 00:15:07.800
which I think everybody on this call


00:15:07.800 --> 00:15:10.080
in some way or another is pretty actively


00:15:10.080 --> 00:15:14.080
involved in that. So tell us about your thing.


00:15:14.080 --> 00:15:18.080
Yeah, I'm going to be teaching a two-day workshop in spring of next year.


00:15:18.080 --> 00:15:22.080
And I was having a hard time deciding on what tool I wanted to use and what


00:15:22.080 --> 00:15:26.080
workflow I wanted to use because when someone's just getting started with Python,


00:15:26.080 --> 00:15:30.080
it comes with a lot of hurdles like the virtual environments,


00:15:30.080 --> 00:15:34.080
installing Python 3, explaining why the Python that comes with your system


00:15:34.080 --> 00:15:38.080
isn't good enough, and pip, and working with the command line and all this stuff.


00:15:38.080 --> 00:15:43.080
I put out a call on Twitter asking what software and tools people use to teach Python.


00:15:43.080 --> 00:15:48.080
I will link to that in the show notes, but there were about 50 responses, 414 votes,


00:15:48.080 --> 00:15:53.080
and I learned about a lot of new tools from that thread.


00:15:53.080 --> 00:15:56.080
Of the 414 votes, 27% said they use Python or iPython in a Ruple.


00:15:56.080 --> 00:16:03.080
Another 13% use the built-in IDLE, which I feel like a lot of people don't even know about.


00:16:04.080 --> 00:16:06.080
Yeah, that's true.


00:16:06.080 --> 00:16:10.080
There is a tool, it's janky, and it's baked into Python.


00:16:10.080 --> 00:16:15.080
39% said they use an IDE or some other editor, Visual Studio Code, PyCharm, Atom.


00:16:15.080 --> 00:16:23.080
And then 21% used other, so a mix of local and hosted Jupyter notebooks, and a handful of other responses.


00:16:23.080 --> 00:16:30.080
So I just want to cover a few tools that I learned about and a few tools that I got reminded of.


00:16:30.080 --> 00:16:32.080
The first is the mu editor


00:16:32.080 --> 00:16:34.480
Uh, have any of you used it?


00:16:34.480 --> 00:16:36.400
Yeah, it's really cool


00:16:36.400 --> 00:16:41.600
Yeah, so it's just like a really simple python editor really great for those who are completely new to programming


00:16:41.600 --> 00:16:46.160
It's just an editor and then really large buttons at the top with some common actions


00:16:46.160 --> 00:16:52.320
It's got support for a bunch of educational platforms like the adafruit circuit playground the micro bit pi game


00:16:52.320 --> 00:16:54.720
There's a lot of really awesome tutorials


00:16:55.200 --> 00:16:57.640
On the other side of the complexity scale,


00:16:57.640 --> 00:17:01.740
a few people clued me into the Neuron plugin for VS Code


00:17:01.740 --> 00:17:03.840
and the Hydrogen plugin for Atom.


00:17:03.840 --> 00:17:08.880
It makes this really cool interactive coding environment in your editor.


00:17:08.880 --> 00:17:11.140
Little bits of Jupyter Notebooks,


00:17:11.140 --> 00:17:14.560
you can interactively run commands and see the output.


00:17:14.560 --> 00:17:18.440
You can have interactive charts and graphs displayed in your editor,


00:17:18.440 --> 00:17:21.280
import to and from Jupyter Notebooks.


00:17:21.280 --> 00:17:24.320
That one is geared a little bit more towards data scientists.


00:17:24.320 --> 00:17:25.440
- I really like that one.


00:17:25.440 --> 00:17:26.840
I had never heard of Neuron.


00:17:26.840 --> 00:17:29.920
I've heard of Hydrogen for Atom,


00:17:29.920 --> 00:17:31.720
and I was excited about it, but I didn't do anything.


00:17:31.720 --> 00:17:32.900
It's like, "I don't really use Atom,"


00:17:32.900 --> 00:17:34.320
but I do use VS Code sometimes,


00:17:34.320 --> 00:17:35.920
and I'm like, "Oh, this is pretty cool."


00:17:35.920 --> 00:17:38.640
So it's like, it's sort of the general editing,


00:17:38.640 --> 00:17:41.040
the standard editing you have in a regular text editor,


00:17:41.040 --> 00:17:44.680
but then Jupyter-like things pop out of it, right?


00:17:44.680 --> 00:17:45.920
Like a graph or something.


00:17:45.920 --> 00:17:48.440
- Yeah, and like a lot of interactivity.


00:17:48.440 --> 00:17:49.400
It looks really good.


00:17:49.400 --> 00:17:50.240
- Yeah, it does.


00:17:50.240 --> 00:17:51.160
Nice.


00:17:51.160 --> 00:17:52.000
What else?


00:17:52.840 --> 00:17:54.840
Someone else told me about REPL.IT,


00:17:54.840 --> 00:17:56.840
REPL.IT.


00:17:56.840 --> 00:17:58.840
And they have a project goal for zero effort setup.


00:17:58.840 --> 00:18:00.840
And they actually sent me a really interesting tweet that I liked.


00:18:00.840 --> 00:18:02.840
So I'll read it out to you.


00:18:02.840 --> 00:18:04.840
They said that we believe that the initial experience of programming


00:18:04.840 --> 00:18:06.840
should be the joy of writing and running code.


00:18:06.840 --> 00:18:08.840
And delaying the setup pain is a good way to hook people


00:18:08.840 --> 00:18:10.840
and retain them to want to install locally.


00:18:10.840 --> 00:18:12.840
Because after all, setup is merely accidental complexity


00:18:12.840 --> 00:18:14.840
that we accept it as reality.


00:18:14.840 --> 00:18:16.840
That is cool.


00:18:16.840 --> 00:18:18.840
Yeah, very cool.


00:18:18.840 --> 00:18:20.840
That is good.


00:18:20.840 --> 00:18:21.840
That is cool.


00:18:21.840 --> 00:18:22.840
Yeah, very cool.


00:18:22.840 --> 00:18:23.840
It's good, right?


00:18:23.840 --> 00:18:25.840
Open source hosted cloud REPL.


00:18:25.840 --> 00:18:27.840
The free tier is pretty reasonable.


00:18:27.840 --> 00:18:29.840
You don't have to log in or do anything.


00:18:29.840 --> 00:18:32.840
You can go to this site and get started right away.


00:18:32.840 --> 00:18:33.840
There's three vertical panes.


00:18:33.840 --> 00:18:38.840
There's one for files, one's your editor, and the next is your REPL.


00:18:38.840 --> 00:18:41.840
And then it's got some other really cool stuff built in.


00:18:41.840 --> 00:18:44.840
Visual package installation, so you don't have to use pip.


00:18:44.840 --> 00:18:48.840
You can search in a little text box and just click install, which is really nice.


00:18:48.840 --> 00:18:50.840
- Great for new users. - Once that happens,


00:18:50.840 --> 00:18:54.840
right? It automatically generates a requirements.txt.


00:18:54.840 --> 00:18:58.840
Like, that's pretty cool. And then it also includes a debugger,


00:18:58.840 --> 00:19:02.840
which, I don't know. I don't know how they make it work, but


00:19:02.840 --> 00:19:06.840
I love it. - It's nice. Wow. Very cool. - Yeah. And the last one is


00:19:06.840 --> 00:19:10.840
bpython. So it's a different kind of command line interactive


00:19:10.840 --> 00:19:14.840
REPL. I used it years ago, and I was surprised to hear that


00:19:14.840 --> 00:19:17.020
that it was still an active project.


00:19:17.020 --> 00:19:20.800
But what BPython is, is a fancy curses interface


00:19:20.800 --> 00:19:22.420
to the Python interpreter.


00:19:22.420 --> 00:19:25.100
So you can get little pop-up boxes in your terminal


00:19:25.100 --> 00:19:28.500
and a lot of kind of really fancy UI elements,


00:19:28.500 --> 00:19:30.400
which is nice.


00:19:30.400 --> 00:19:34.040
It also supports type hints, expected parameter lists,


00:19:34.040 --> 00:19:36.220
and then you can do things like really easily


00:19:36.220 --> 00:19:38.020
reload imported modules.


00:19:38.020 --> 00:19:40.940
You can also rewind your session.


00:19:40.940 --> 00:19:43.320
And what that does is it pops the last line


00:19:43.320 --> 00:19:47.460
and then reruns the entire session and reevaluates it.


00:19:47.460 --> 00:19:49.320
But those are really cool features


00:19:49.320 --> 00:19:50.840
that I haven't seen anywhere else.


00:19:50.840 --> 00:19:51.960
- That's a super cool one.


00:19:51.960 --> 00:19:54.040
Then you have some honorable mentions as well, right?


00:19:54.040 --> 00:19:54.880
- I do.


00:19:54.880 --> 00:19:59.140
So I saw a talk at EuroPython from Joshua Lowe.


00:19:59.140 --> 00:20:00.320
Have any of you met him?


00:20:00.320 --> 00:20:01.640
- I've not met him.


00:20:01.640 --> 00:20:03.920
- Yeah, we met him at the last PyCon.


00:20:03.920 --> 00:20:04.760
- Nice.


00:20:04.760 --> 00:20:05.580
- Okay.


00:20:05.580 --> 00:20:09.520
Yeah, he is 14 years old, which is amazing,


00:20:09.520 --> 00:20:11.160
but he's a brilliant developer


00:20:11.160 --> 00:20:14.200
and he made this open source tool called EdgyBlocks,


00:20:14.200 --> 00:20:17.680
which is kind of a Python version of Scratch.


00:20:17.680 --> 00:20:21.760
It's a tool for kids that lets you drag and drop code blocks


00:20:21.760 --> 00:20:24.380
and see it executed instantly.


00:20:24.380 --> 00:20:27.360
Open source, contribute to it, check out his website.


00:20:27.360 --> 00:20:28.800
I really love that project.


00:20:28.800 --> 00:20:30.280
- Yeah, that's very cool, very cool.


00:20:30.280 --> 00:20:32.640
All right, before we get to the next one, Dan,


00:20:32.640 --> 00:20:35.800
I wanna just tell you all about our sponsor, DigitalOcean.


00:20:35.800 --> 00:20:38.920
Thank you to DigitalOcean for making this show possible.


00:20:38.920 --> 00:20:42.600
Like I said, previously, they've sponsored this entire show


00:20:42.600 --> 00:20:43.720
for the rest of the year.


00:20:43.720 --> 00:20:44.760
So thank you to them.


00:20:44.760 --> 00:20:45.760
That's great.


00:20:45.760 --> 00:20:48.300
And one of the features I want to tell you about that they're


00:20:48.300 --> 00:20:51.920
promoting these days is to bring your own image


00:20:51.920 --> 00:20:52.920
to DigitalOcean.


00:20:52.920 --> 00:20:54.280
You've heard about bringing your own device.


00:20:54.280 --> 00:20:56.760
Well, in the cloud world, that's bringing your own image.


00:20:56.760 --> 00:20:59.260
So you can go and create a virtual machine,


00:20:59.260 --> 00:21:01.680
some kind of Linux distribution, exactly like you want it,


00:21:01.680 --> 00:21:04.100
and then just upload that image, and then press a button


00:21:04.100 --> 00:21:06.320
and create new droplets based on that.


00:21:06.320 --> 00:21:07.080
So really cool.


00:21:07.080 --> 00:21:09.960
Check them out at pythonbytes.fm/digitalocean.


00:21:09.960 --> 00:21:11.920
Get $100 credit from the users.


00:21:11.920 --> 00:21:13.440
And yeah, it's great.


00:21:13.440 --> 00:21:17.160
It's been working well for us, and definitely recommend them.


00:21:17.160 --> 00:21:19.840
So Dan, the one that you'd like to bring up


00:21:19.840 --> 00:21:22.960
has already got a little bit of a cameo earlier, right?


00:21:22.960 --> 00:21:24.440
Yeah, I just love this tool.


00:21:24.440 --> 00:21:28.360
So I've become a huge fan of the Black Code Formatter


00:21:28.360 --> 00:21:30.280
by Lukas Lange.


00:21:30.280 --> 00:21:32.520
And well, what's a code formatter?


00:21:32.520 --> 00:21:35.840
It's basically a tool you run on a Python source file,


00:21:35.840 --> 00:21:40.840
and it reformats it according to a built-in code style.


00:21:40.840 --> 00:21:42.840
It's sort of like PEP 8,


00:21:42.840 --> 00:21:46.640
but PEP 8 isn't super comprehensive,


00:21:46.640 --> 00:21:49.040
so it's ambiguous to a certain degree.


00:21:49.040 --> 00:21:52.120
So Black just makes a decision for you


00:21:52.120 --> 00:21:53.840
and reformats your code.


00:21:53.840 --> 00:21:54.980
You know, with this sort of tool,


00:21:54.980 --> 00:21:58.520
it's always like a love and hate relationship, I think,


00:21:58.520 --> 00:22:00.760
because if you agree with the reformatting,


00:22:00.760 --> 00:22:02.240
then it can be great, right?


00:22:02.240 --> 00:22:03.080
It's awesome.


00:22:03.080 --> 00:22:04.720
You just write your code however you like,


00:22:04.720 --> 00:22:08.560
and then you reformat it, boom, it looks consistent at least.


00:22:08.560 --> 00:22:11.360
But if you don't like it or you have other idiosyncrasies


00:22:11.360 --> 00:22:14.360
that you want to keep, then that doesn't work out so great.


00:22:14.360 --> 00:22:18.040
And so with Black, I found that it's actually the first tool


00:22:18.040 --> 00:22:21.820
that I have sort of developed this blind trust for.


00:22:21.820 --> 00:22:24.980
So I pretty much started using it for everything now.


00:22:24.980 --> 00:22:27.840
And I like the way it formats my code.


00:22:27.840 --> 00:22:30.560
It pretty much always figures out


00:22:30.560 --> 00:22:32.800
some formatting solution that I like.


00:22:32.800 --> 00:22:35.960
And it's just a really, really cool tool.


00:22:35.960 --> 00:22:37.880
And I think it just came out in 2018.


00:22:37.880 --> 00:22:42.400
I actually heard about it on Python Bytes earlier this year.


00:22:42.400 --> 00:22:45.680
And I think Brian, you found it in episode 73.


00:22:45.680 --> 00:22:47.120
Got my notes here.


00:22:47.120 --> 00:22:49.960
And it's, yeah, it's just an amazing tool.


00:22:49.960 --> 00:22:51.320
And the nice thing is,


00:22:51.320 --> 00:22:53.800
besides all of the auto-formatting business,


00:22:53.800 --> 00:22:57.040
you can also use it to check the formatting


00:22:57.040 --> 00:22:59.800
of an existing project or just a single file.


00:22:59.800 --> 00:23:01.160
So where this is nice,


00:23:01.160 --> 00:23:05.960
and this kind of touches on some of the code quality tools that we had talked about earlier,


00:23:05.960 --> 00:23:09.800
is that you can integrate that with your continuous integration pipeline,


00:23:09.800 --> 00:23:19.040
and then make sure that any new code that gets committed is consistent with the formatting that Black generates.


00:23:19.040 --> 00:23:23.040
So if you have multiple developers working on a code base,


00:23:23.040 --> 00:23:25.960
this just takes away all of the formatting back and forth,


00:23:25.960 --> 00:23:30.280
you know, it's so easy to get sucked into a conversation of like, "Oh, I'm reviewing your code here."


00:23:30.280 --> 00:23:34.040
Actually, I think this works really well. You know, your 5000 line change, it's awesome. But


00:23:34.040 --> 00:23:38.760
I would really change all of these, the single quote strings to double quotes or something like


00:23:38.760 --> 00:23:44.600
that. It just gets rid of all of these non productive conversations. And just make sure


00:23:44.600 --> 00:23:48.360
everybody uses the same formatting. I love it. Yeah, that's awesome. Another one of the problems


00:23:48.360 --> 00:23:51.880
you have in these teams is if you have different formatting rules, and you can run, you know,


00:23:51.880 --> 00:23:56.280
like format my code options, like VS code or PyCharm or something, and you have different ones,


00:23:56.280 --> 00:23:58.280
they can fight inversion control, right?


00:23:58.280 --> 00:24:00.280
Like this one changes, this one changes it back,


00:24:00.280 --> 00:24:02.280
this one changes it, this one changes it back.


00:24:02.280 --> 00:24:04.280
So I can just hear Nina's voice say,


00:24:04.280 --> 00:24:05.280
"That should be a pre-commit hook."


00:24:05.280 --> 00:24:07.280
And then everyone's is the same, right?


00:24:07.280 --> 00:24:08.280
What do you think, Nina?


00:24:08.280 --> 00:24:09.280
Should it be a pre-commit hook?


00:24:09.280 --> 00:24:11.280
Yeah, I love pre-commit hooks.


00:24:11.280 --> 00:24:12.280
Absolutely.


00:24:12.280 --> 00:24:13.280
That's awesome.


00:24:13.280 --> 00:24:15.280
Brett, I wanted to ask you,


00:24:15.280 --> 00:24:18.280
what do you guys do on the core dev team


00:24:18.280 --> 00:24:19.280
for this problem?


00:24:19.280 --> 00:24:22.280
Lots of handwork.


00:24:22.280 --> 00:24:23.280
It's all manual.


00:24:23.280 --> 00:24:28.280
Well, basically, we don't have any tools specifically to actually maintain this.


00:24:28.280 --> 00:24:33.080
More or less, all the core devs have just internalized Pep8 almost as much as you possibly


00:24:33.080 --> 00:24:34.080
can.


00:24:34.080 --> 00:24:38.280
You can just spot code that doesn't quite meet it, even though Pep8 is not as rigorously


00:24:38.280 --> 00:24:40.760
defined as it potentially could be.


00:24:40.760 --> 00:24:45.400
The idea has come up about actually adopting Black as an official formatter, but due to


00:24:45.400 --> 00:24:49.200
the current governance situation, that hasn't really gone anywhere.


00:24:49.200 --> 00:24:53.040
But I wouldn't be shocked if Lukasz, who is a core dev, brings that up in the future


00:24:53.040 --> 00:24:57.600
as a way to kind of make black more or less official formatter for language somehow.


00:24:57.600 --> 00:25:01.500
Yeah, that's cool, especially since Lukasz is actually, you know, he created black and


00:25:01.500 --> 00:25:03.860
he's a core developer, he's very active.


00:25:03.860 --> 00:25:07.680
It would be not unreasonable to say we just run black against everything.


00:25:07.680 --> 00:25:14.080
Yeah, it's just the trick of can you get enough core developers to say blacks output is pretty


00:25:14.080 --> 00:25:15.760
instead of ugly.


00:25:15.760 --> 00:25:17.360
And you can probably pull that off.


00:25:17.360 --> 00:25:19.780
But obviously formatting, much like naming,


00:25:19.780 --> 00:25:21.640
is a very opinionated subject,


00:25:21.640 --> 00:25:23.800
and it's hard to get agreement on that.


00:25:23.800 --> 00:25:26.900
- It's like asking everybody to use the same editor.


00:25:26.900 --> 00:25:28.020
- Mm-hmm, exactly.


00:25:28.020 --> 00:25:29.440
- Somebody will be happy, but you know,


00:25:29.440 --> 00:25:31.240
somebody's gonna be really unhappy about that.


00:25:31.240 --> 00:25:32.840
- One really nice thing about these tools like Black


00:25:32.840 --> 00:25:35.640
is because they're external to specific editors,


00:25:35.640 --> 00:25:38.160
being able to standardize them does help allow people


00:25:38.160 --> 00:25:40.600
to use whatever tool or editor that they want.


00:25:40.600 --> 00:25:42.320
- Yeah, absolutely, absolutely.


00:25:42.320 --> 00:25:43.160
Very cool.


00:25:43.160 --> 00:25:45.180
Well, one of the themes of the last PyCon, Brett,


00:25:45.180 --> 00:25:48.540
was one of the places where Python belongs,


00:25:48.540 --> 00:25:51.460
but is not really, is on the web,


00:25:51.460 --> 00:25:52.820
on the client side of the web, right?


00:25:52.820 --> 00:25:55.100
- Yeah, Dan Callahan had a whole keynote


00:25:55.100 --> 00:25:58.100
kind of talking about Python and where it's been


00:25:58.100 --> 00:25:59.500
and where it could potentially go,


00:25:59.500 --> 00:26:02.460
and one of his key points was Python was not really


00:26:02.460 --> 00:26:05.300
on the web as I think some of us wish it could be.


00:26:05.300 --> 00:26:08.900
- Yeah, but you have, your next item is about


00:26:08.900 --> 00:26:11.180
trying to make that a bit more of a reality, right?


00:26:11.180 --> 00:26:14.460
- Yeah, so at PyCon Australia, Russell Keith-Magee,


00:26:14.460 --> 00:26:19.460
who heads up the P-Ware project gave a whole talk


00:26:19.460 --> 00:26:22.260
entitled "A Web Without JavaScript,"


00:26:22.260 --> 00:26:25.140
where Russell basically points out that JavaScript


00:26:25.140 --> 00:26:27.340
more or less has a monopoly on client-side programming,


00:26:27.340 --> 00:26:31.040
which is always a not great thing


00:26:31.040 --> 00:26:33.620
because you never want a specific monopoly


00:26:33.620 --> 00:26:35.420
because it's highly restrictive.


00:26:35.420 --> 00:26:37.060
It makes innovation and growth hard


00:26:37.060 --> 00:26:39.580
in various other usual regions you don't want it.


00:26:39.580 --> 00:26:42.220
So Russell gave a whole talk about


00:26:39.860 --> 00:26:44.860
the various approaches that currently exist for trying to get Python into the browser.


00:26:44.860 --> 00:26:49.860
And he did it by using an example all the way through his talk where he implemented what's called


00:26:49.860 --> 00:26:54.860
I think you pronounce it the Loon algorithm. It's basically a way to check some credit card numbers.


00:26:54.860 --> 00:26:59.860
And when he implemented it, it was only like 0.4 kilobytes. So really small.


00:26:59.860 --> 00:27:04.860
And then he just subsequently wrote it in Python and ran through all the ways you can do it.


00:27:04.860 --> 00:27:08.700
and it ranged from 32 kilobytes for transcript,


00:27:08.700 --> 00:27:11.880
which transpels Python into JavaScript,


00:27:11.880 --> 00:27:15.340
to Brython, which is a Python compiler


00:27:15.340 --> 00:27:19.980
written in JavaScript, which had 0.5 kilobytes for source,


00:27:19.980 --> 00:27:21.120
'cause it's just Python,


00:27:21.120 --> 00:27:23.860
but it had a 646 kilobyte bootstrap.


00:27:23.860 --> 00:27:26.300
Batavia, which is Russell's project


00:27:26.300 --> 00:27:29.020
that basically implements the eval loop for Python,


00:27:29.020 --> 00:27:31.780
which had a 1.2 kilobyte bytecode size,


00:27:31.780 --> 00:27:33.440
'cause it literally executes Python bytecode,


00:27:33.440 --> 00:27:35.800
but it has a five megabyte bootstrap.


00:27:35.800 --> 00:27:38.880
And then PyOdyed, which is the CPython


00:27:38.880 --> 00:27:41.240
compiled down to Wasm, which is WebAssembly,


00:27:41.240 --> 00:27:43.200
which is kind of being viewed by some


00:27:43.200 --> 00:27:45.800
as the future way of handling this kind of problem.


00:27:45.800 --> 00:27:47.240
- I'm very excited about PyOdyed.


00:27:47.240 --> 00:27:48.920
- Yeah, well, it's a really cool idea.


00:27:48.920 --> 00:27:52.080
Unfortunately, while the code was still just 0.5 kilobytes


00:27:52.080 --> 00:27:54.840
for the Python code, the bootstrap's three megabytes,


00:27:54.840 --> 00:27:56.840
so it's still kind of large.


00:27:56.840 --> 00:28:00.160
But it is a nice way to short circuit getting going,


00:28:00.160 --> 00:28:01.760
because if you can just take CPython


00:28:01.760 --> 00:28:04.520
is literally compile it straight to WebAssembly.


00:28:04.520 --> 00:28:06.520
There's no reimplementation of anything, right?


00:28:06.520 --> 00:28:10.000
Like Vitavia and Brython and Transcript are all big projects


00:28:10.000 --> 00:28:11.720
that are having to basically reimplement Python


00:28:11.720 --> 00:28:14.240
in one way or the other, while Pyotr just said like,


00:28:14.240 --> 00:28:16.320
well, let's just take CPython and just make it work.


00:28:16.320 --> 00:28:18.720
- Right, compile it to Wasm and then ship it.


00:28:18.720 --> 00:28:22.520
- Exactly, which I think is why some people at least


00:28:22.520 --> 00:28:24.120
are hopeful Wasm could somehow do this,


00:28:24.120 --> 00:28:26.960
whether that's writing a Python compiler straight to Wasm


00:28:26.960 --> 00:28:29.400
so we can maybe ditch the bootstrap situation


00:28:29.400 --> 00:28:30.820
or what, I don't know.


00:28:30.820 --> 00:28:37.740
The other thing for me is my interest in this is as a VS Code extension developer, because


00:28:37.740 --> 00:28:38.900
that's all in TypeScript.


00:28:38.900 --> 00:28:42.000
So this and VS Code is an Electron app.


00:28:42.000 --> 00:28:46.880
So for situations where download size isn't quite as critical, something like Pyodide


00:28:46.880 --> 00:28:51.460
actually starts to become potentially feasible because shipping three megs as part of a hundreds


00:28:51.460 --> 00:28:53.700
of megabyte app is not a big deal.


00:28:53.700 --> 00:28:54.840
Yeah, that's where you're right.


00:28:54.840 --> 00:28:56.680
That's where it gets super exciting.


00:28:56.680 --> 00:28:59.780
Because these things were like you say, where you say, oh, that's three megs, that's five


00:28:59.780 --> 00:29:02.260
of JavaScript, that's way too much.


00:29:02.260 --> 00:29:05.060
That's true when you're getting it off the web per request,


00:29:05.060 --> 00:29:09.040
at least per session, but if it's, like you said, shipped,


00:29:09.040 --> 00:29:13.900
and it just runs in the Chrome that powers


00:29:13.900 --> 00:29:16.340
the whole Electron system, well then it's no big deal, right?


00:29:16.340 --> 00:29:18.620
- Exactly, and then at that point, it's a question of


00:29:18.620 --> 00:29:21.900
which one gives the best Python to JavaScript bridge


00:29:21.900 --> 00:29:25.260
and vice versa, and they all have different levels


00:29:25.260 --> 00:29:27.340
for that based on how they're implemented,


00:29:27.340 --> 00:29:30.780
But for me, I think there's an opportunity here


00:29:30.780 --> 00:29:34.600
to not only come up with a solution that has good bridging,


00:29:34.600 --> 00:29:37.620
that can work in a Electron or Node situation


00:29:37.620 --> 00:29:39.480
to get Python there,


00:29:39.480 --> 00:29:41.820
but then also to potentially look at WebAssembly


00:29:41.820 --> 00:29:43.680
and see if there's a way to do a Python compiler


00:29:43.680 --> 00:29:44.700
straight to WebAssembly,


00:29:44.700 --> 00:29:48.180
and then have that be the way we target Python


00:29:48.180 --> 00:29:50.260
on client side and try to keep that number down.


00:29:50.260 --> 00:29:51.600
- Yeah, that's super cool.


00:29:51.600 --> 00:29:54.420
Have you heard about Python Electron, Electron Python?


00:29:54.420 --> 00:29:55.420
I can't remember which way it goes.


00:29:55.420 --> 00:29:58.500
- Yes, I have passively seen it


00:29:58.500 --> 00:30:00.700
'cause I've asked on Twitter a couple times,


00:30:00.700 --> 00:30:02.180
like, I really want this.


00:30:02.180 --> 00:30:04.980
Like, I want to write the Python extension


00:30:04.980 --> 00:30:07.020
of VS Code in Python someday.


00:30:07.020 --> 00:30:10.780
So, Eric Snow, who's the core dev and also a teammate of mine,


00:30:10.780 --> 00:30:12.740
we occasionally bounce this idea back and forth


00:30:12.740 --> 00:30:14.540
and it sometimes leaks onto Twitter


00:30:14.540 --> 00:30:17.620
and we dream in blue skies.


00:30:17.620 --> 00:30:21.300
And yeah, people have brought up Python Electron before.


00:30:21.300 --> 00:30:22.180
- Very cool.


00:30:22.180 --> 00:30:23.500
How about the rest of you folks?


00:30:23.500 --> 00:30:27.900
Have you heard about Pyodide or people doing interesting things with some of these others?


00:30:27.900 --> 00:30:29.140
What are your thoughts?


00:30:29.140 --> 00:30:33.340
We recently added interactive coding exercises to real Python.


00:30:33.340 --> 00:30:36.680
So there's quizzes and parts of them are, you know, solve this, like implement this


00:30:36.680 --> 00:30:38.540
little loop or whatever.


00:30:38.540 --> 00:30:41.140
And that's actually implemented in Brython.


00:30:41.140 --> 00:30:46.940
And so it compiles your Python code to JavaScript locally on the client and then runs that.


00:30:46.940 --> 00:30:49.980
And it's actually been a pretty cool experience.


00:30:49.980 --> 00:30:56.940
not 100% compatible. So it's sort of like Python 3.7-ish. And so you run into these funny edge


00:30:56.940 --> 00:31:01.180
cases, which is interesting because, well, people are trying to learn Python and what are they


00:31:01.180 --> 00:31:07.260
really learning with these exercises? But for the most part, it's pretty accurate. And performance


00:31:07.260 --> 00:31:11.580
wise, it works pretty well too. So on a fast connection, when that bootstrap doesn't hit you


00:31:11.580 --> 00:31:16.700
that hard, it works quite well on mobile too. The only thing I found where it's really starting to


00:31:17.420 --> 00:31:22.940
just churn the CPU is when you load in a bunch of stuff from their standard library. So we have the


00:31:22.940 --> 00:31:30.140
option to validate your code using regexis. And when you import RE, then it can take, I don't know,


00:31:30.140 --> 00:31:36.540
you know, five seconds on even on a notebook. And that's not ideal. But I think for a use case like


00:31:36.540 --> 00:31:40.860
that, where you have to user type in code, for us, it works really quite well. I'm not sure if I


00:31:40.860 --> 00:31:45.660
would want to rewrite like, all of the front end JavaScript, just a part of that's part of the


00:31:45.660 --> 00:31:50.820
the website but for a code runner or code exercise tool I think it works quite well.


00:31:50.820 --> 00:31:53.880
Yeah that sounds like a really cool use and you don't have to worry about the security


00:31:53.880 --> 00:31:58.120
it's not like I'm taking their code and running it and trying to do that in Docker or something


00:31:58.120 --> 00:32:01.180
like just hope my server doesn't get messed up from this we'll try it.


00:32:01.180 --> 00:32:03.220
The only thing you can break is your browser.


00:32:03.220 --> 00:32:06.460
I've hacked myself I'm a hacker.


00:32:06.460 --> 00:32:08.020
How about the rest of you?


00:32:08.020 --> 00:32:12.140
No I've not checked it out but there's a couple of other links that I'd recommend people look


00:32:12.140 --> 00:32:18.380
at. One is Scott Hanselman's blog post on JavaScript as the assembly of the web, which


00:32:18.380 --> 00:32:24.700
is really interesting and paints some good context. And then also from Scott, there's


00:32:24.700 --> 00:32:30.060
an interview on Hanselman, it's podcast between him and Patricia Oss. And that kind of covers


00:32:30.060 --> 00:32:35.980
off like the history of JavaScript engines and runtimes and also helps kind of explain


00:32:35.980 --> 00:32:40.380
why things the way are the way they are, which is really interesting to give you context


00:32:40.380 --> 00:32:41.380
as well.


00:32:41.380 --> 00:32:43.780
- That's cool, and speaking of Scott Hanselman,


00:32:43.780 --> 00:32:46.180
they're doing really interesting stuff with WebAssembly


00:32:46.180 --> 00:32:48.120
and the .NET CLR with Blazor.


00:32:48.120 --> 00:32:50.820
I mean, if the Python community could just


00:32:50.820 --> 00:32:52.980
do that same thing, and it looks like Pyodite


00:32:52.980 --> 00:32:55.480
is very close, but that's more focused on data science


00:32:55.480 --> 00:32:58.040
instead of Spah's front-end JavaScript stuff.


00:32:58.040 --> 00:33:00.220
So there's definitely some interesting stuff


00:33:00.220 --> 00:33:01.060
happening there.


00:33:01.060 --> 00:33:02.860
- I'd also recommend, if you haven't watched


00:33:02.860 --> 00:33:05.780
Dan Callahad's keynote from PyCon, that you do.


00:33:05.780 --> 00:33:06.660
It's really good.


00:33:06.660 --> 00:33:08.740
- Yeah, that's a great recommendation.


00:33:08.740 --> 00:33:11.640
All right, WebAssembly, it's gonna make things amazing.


00:33:11.640 --> 00:33:13.520
I'm looking forward to it.


00:33:13.520 --> 00:33:15.560
All right, so we're down to our last item,


00:33:15.560 --> 00:33:18.840
and this one is mine, so I'll kick it off.


00:33:18.840 --> 00:33:20.800
So you all have heard of Selenium, right?


00:33:20.800 --> 00:33:23.760
You can automate browsers and do web testing


00:33:23.760 --> 00:33:24.720
and stuff with it? - Yeah.


00:33:24.720 --> 00:33:28.160
- Yeah, so if I wanted to use that in an async and await,


00:33:28.160 --> 00:33:30.200
in an async method, as in async def,


00:33:30.200 --> 00:33:31.580
I'm gonna call a Selenium thing,


00:33:31.580 --> 00:33:33.960
there is no async option for that.


00:33:33.960 --> 00:33:35.160
And they actually talked about it on GitHub


00:33:35.160 --> 00:33:36.420
and decided they weren't going to do it


00:33:36.420 --> 00:33:38.160
because there's this other project,


00:33:38.160 --> 00:33:42.180
which I had never heard of, called Arsenic, I guess,


00:33:42.180 --> 00:33:43.400
something like that.


00:33:43.400 --> 00:33:47.380
And it's an async version of, well, basically, Selenium.


00:33:47.380 --> 00:33:49.840
So if you're writing any async code,


00:33:49.840 --> 00:33:51.960
code that you're interacting with a bunch of sites,


00:33:51.960 --> 00:33:53.520
you're testing them or something like this,


00:33:53.520 --> 00:33:56.580
you could do it in an async IO event loop


00:33:56.580 --> 00:33:58.560
very easily with this other project.


00:33:58.560 --> 00:33:59.720
So it's quite cool.


00:33:59.720 --> 00:34:01.260
- I'm gonna definitely have to check that out.


00:34:01.260 --> 00:34:02.200
That is interesting.


00:34:02.200 --> 00:34:03.440
- Yeah, so I come in here,


00:34:03.440 --> 00:34:04.880
like I could create one of these sessions,


00:34:04.880 --> 00:34:08.160
and say I'd like to use the Firefox browser to do this,


00:34:08.160 --> 00:34:10.280
and then I'm going to await getting a page,


00:34:10.280 --> 00:34:12.260
and then I could actually say like,


00:34:12.260 --> 00:34:16.080
await session.waitForElement, like h1.


00:34:16.080 --> 00:34:17.240
And so you can say, you know,


00:34:17.240 --> 00:34:20.100
sort of put your part of the event loop to sleep


00:34:20.100 --> 00:34:22.360
until the element, you know, h1 appears,


00:34:22.360 --> 00:34:23.680
and you can get the title from it and stuff.


00:34:23.680 --> 00:34:24.920
It's really quite neat.


00:34:24.920 --> 00:34:25.800
Yeah.


00:34:25.800 --> 00:34:28.180
So they say, you know, this is good for load testing,


00:34:28.180 --> 00:34:29.760
good for automated testing websites.


00:34:29.760 --> 00:34:32.080
You know, if you wanna say like, well, we have the CMS,


00:34:32.080 --> 00:34:33.560
and people can just type stuff into it,


00:34:33.560 --> 00:34:35.720
but let's make sure there's no broken links, right?


00:34:35.720 --> 00:34:36.640
Something like that.


00:34:36.640 --> 00:34:38.240
And it uses real web browsers,


00:34:38.240 --> 00:34:41.680
so it's really using Firefox in a hidden form to do this.


00:34:41.680 --> 00:34:44.040
So it's pretty cool, very nice for testing, I think.


00:34:44.040 --> 00:34:45.800
- Yeah, headless browsers are awesome.


00:34:45.800 --> 00:34:48.120
And it has a PyTest, it works with PyTest, that's cool.


00:34:48.120 --> 00:34:50.680
- Yeah, it has a special PyTest support, which is cool.


00:34:50.680 --> 00:34:52.620
So I guess this is an interesting thing


00:34:52.620 --> 00:34:53.960
for people who wanna automate the web


00:34:53.960 --> 00:34:55.360
and they're doing it asynchronously,


00:34:55.360 --> 00:34:57.000
and often that's one of the times


00:34:57.000 --> 00:34:58.920
where AsyncIO is really helpful


00:34:58.920 --> 00:35:01.000
because you're just waiting on other servers anyway,


00:35:01.000 --> 00:35:02.960
so you can blaze through that.


00:35:02.960 --> 00:35:04.560
But maybe just throw it out to you all.


00:35:04.560 --> 00:35:06.180
What are your thoughts on async these days?


00:35:06.180 --> 00:35:08.280
Async and await and all that stuff.


00:35:08.280 --> 00:35:11.120
Brett, maybe start with you 'cause you're on the inside.


00:35:11.120 --> 00:35:12.160
And I know you've blogged on this.


00:35:12.160 --> 00:35:13.000
- Yeah, I was gonna say,


00:35:13.000 --> 00:35:15.560
which makes me obviously extremely biased on the topic.


00:35:15.560 --> 00:35:18.400
So I think async's great.


00:35:18.400 --> 00:35:21.240
I appreciate personally how we designed it


00:35:21.240 --> 00:35:25.400
because we haven't tied ourselves to a specific event loop,


00:35:25.400 --> 00:35:27.200
which has allowed some experimentation,


00:35:27.200 --> 00:35:29.320
such as Trio and Curio.


00:35:29.320 --> 00:35:30.160
- And UVL, yeah.


00:35:30.160 --> 00:35:31.420
- Yeah. - Async.io has continued


00:35:31.420 --> 00:35:33.740
to evolve and learn from them.


00:35:33.740 --> 00:35:37.440
Like I know Yuri Slyanov has pulled a lot of ideas


00:35:37.440 --> 00:35:40.440
from Nathaniel Smith, a trio, into Async.io.


00:35:40.440 --> 00:35:43.260
So there's been a nice feedback loop


00:35:43.260 --> 00:35:45.280
on that level of experimentation.


00:35:45.280 --> 00:35:46.900
So I'm very positive on it.


00:35:46.900 --> 00:35:51.000
I wrote an entire GitHub API library based on Async


00:35:51.000 --> 00:35:52.400
because I thought it was so great.


00:35:52.400 --> 00:35:53.480
- Yeah, that's right, and we've covered that


00:35:53.480 --> 00:35:55.520
in the show before, but I don't remember the number,


00:35:55.520 --> 00:35:56.360
I'm afraid.


00:35:56.360 --> 00:35:58.240
- I don't know, I think Dan brought it up.


00:35:58.240 --> 00:35:59.080
- Oh yeah, that's right. - That's right,


00:35:59.080 --> 00:35:59.900
Dan did bring it up.


00:35:59.900 --> 00:36:02.540
I can't remember the number either though, but man, so many episodes.


00:36:02.540 --> 00:36:04.140
I'll tell you it's less than 100.


00:36:04.140 --> 00:36:05.980
It's either 99 or below that.


00:36:05.980 --> 00:36:06.980
We should bound on it.


00:36:06.980 --> 00:36:07.980
How's this?


00:36:07.980 --> 00:36:09.980
What do you think the rest of you guys?


00:36:09.980 --> 00:36:10.980
No, nothing.


00:36:10.980 --> 00:36:17.500
I still find Async in a way very confusing and the attempts that I've had at using it,


00:36:17.500 --> 00:36:21.980
I've just ended up making a mess and causing bugs that I don't understand and can't debug.


00:36:21.980 --> 00:36:25.540
So I just kind of gave up, which is pretty sad, but I'm going to watch your course, Mike,


00:36:25.540 --> 00:36:26.540
at some point.


00:36:26.540 --> 00:36:27.540
Thanks.


00:36:27.540 --> 00:36:28.540
I need to allocate the time.


00:36:28.540 --> 00:36:29.540
There you go.


00:36:29.540 --> 00:36:32.580
threading world, there's a phrase for the bugs


00:36:32.580 --> 00:36:34.900
that are like race condition stuff called Heisenbugs,


00:36:34.900 --> 00:36:36.980
and I just love that terminology.


00:36:36.980 --> 00:36:38.580
- I've run into a few of those.


00:36:38.580 --> 00:36:42.500
So for those who don't know, a Heisenbug


00:36:42.500 --> 00:36:45.020
only appears when you're not looking at it.


00:36:45.020 --> 00:36:46.740
- That's right, you absorb it, it changes it too.


00:36:46.740 --> 00:36:47.580
- Yeah.


00:36:47.580 --> 00:36:48.400
- Yeah, very cool.


00:36:48.400 --> 00:36:49.420
All right, well, people out there,


00:36:49.420 --> 00:36:52.180
if you need to do some sort of automation


00:36:52.180 --> 00:36:53.420
and you were gonna use selenium,


00:36:53.420 --> 00:36:56.580
definitely check out arsenic because you can do it


00:36:56.580 --> 00:36:58.460
more in parallel if you're doing more than one


00:36:58.460 --> 00:37:00.060
that sort of flow through your tests.


00:37:00.060 --> 00:37:01.220
It does say be careful though,


00:37:01.220 --> 00:37:04.260
because while you can asynchronously start calling functions


00:37:04.260 --> 00:37:07.380
you're interacting with like a hidden real browser,


00:37:07.380 --> 00:37:10.300
which itself can't do more than one thing at a time.


00:37:10.300 --> 00:37:13.140
And so, you know, it's more for I wanna test


00:37:13.140 --> 00:37:14.760
a bunch of links or a bunch of paths,


00:37:14.760 --> 00:37:17.500
not I'm trying to make this one sequence of events


00:37:17.500 --> 00:37:19.100
go faster, that probably won't work so well.


00:37:19.100 --> 00:37:21.520
- Yeah, check out Selenium Grid if you wanna do that.


00:37:21.520 --> 00:37:23.100
If you wanna do multiple machines


00:37:23.100 --> 00:37:25.300
and multiple browsers at the same time.


00:37:25.300 --> 00:37:27.140
- Is that grid computing for Selenium?


00:37:27.140 --> 00:37:27.980
- Kind of, yeah.


00:37:27.980 --> 00:37:28.820
(laughing)


00:37:28.820 --> 00:37:30.780
- Oh man, that's pretty awesome.


00:37:30.780 --> 00:37:33.180
All right, well, let's leave it there for our main topic.


00:37:33.180 --> 00:37:35.220
So thank you everyone for bringing these


00:37:35.220 --> 00:37:36.300
and sharing them with everyone.


00:37:36.300 --> 00:37:37.780
They were super interesting.


00:37:37.780 --> 00:37:40.260
Normally, I just ask Brian if he has anything else to share,


00:37:40.260 --> 00:37:42.340
but I know we got more than that.


00:37:42.340 --> 00:37:43.940
So we'll just go down the list here.


00:37:43.940 --> 00:37:45.780
I'll throw mine out first.


00:37:45.780 --> 00:37:49.940
So hopefully this is not out too late to make this useful,


00:37:49.940 --> 00:37:53.060
but the PSF and JetBrains last year teamed up


00:37:53.060 --> 00:37:55.500
to do the most comprehensive survey


00:37:55.500 --> 00:37:57.340
of the Python community they could.


00:37:57.340 --> 00:38:00.500
And that is now happening again this year.


00:38:00.500 --> 00:38:05.500
So just visit talkbython.fm/survey2018 and take that.


00:38:05.500 --> 00:38:07.660
But if you hear this, do that as soon as possible


00:38:07.660 --> 00:38:10.220
'cause there's only a week or two left of it being open.


00:38:10.220 --> 00:38:12.300
So, all right, Anthony, you got one you'd like to share.


00:38:12.300 --> 00:38:14.900
- Yeah, 3.7.1 is around the corner.


00:38:14.900 --> 00:38:18.660
And the first release candidate came out a week ago.


00:38:18.660 --> 00:38:23.020
So if you're running on 3.7 and you wanna try to see


00:38:23.020 --> 00:38:24.840
if any of the bugs that you may have come across


00:38:24.840 --> 00:38:27.960
have been fixed, take a look through the release notes.


00:38:27.960 --> 00:38:30.520
And then the next one is that on the topic


00:38:30.520 --> 00:38:32.640
of Python packaging, there's a great article


00:38:32.640 --> 00:38:34.720
that I've linked to in the notes,


00:38:34.720 --> 00:38:37.120
and talking about the whole landscape


00:38:37.120 --> 00:38:40.240
and the comparisons with Flit and Poetry and Pipend


00:38:40.240 --> 00:38:41.640
and the reasons behind them.


00:38:41.640 --> 00:38:43.040
It's a really in-depth piece,


00:38:43.040 --> 00:38:44.600
and I think it's worth a good read.


00:38:44.600 --> 00:38:47.120
- That's awesome, I definitely think some comparison


00:38:47.120 --> 00:38:49.560
and exploration is needed, 'cause there's just so many ways


00:38:49.560 --> 00:38:51.600
to start solving this problem these days.


00:38:51.600 --> 00:38:52.880
But I think something will emerge,


00:38:52.880 --> 00:38:54.720
and I'm kind of hopeful for Poetry, actually.


00:38:54.720 --> 00:38:55.560
Nina, how about you?


00:38:55.560 --> 00:38:56.560
- I have a few things as well.


00:38:56.560 --> 00:39:00.240
We brought up VS Code a few times during the podcast


00:39:00.240 --> 00:39:02.180
and there's a new September release


00:39:02.180 --> 00:39:04.640
of the Python extension for VS Code


00:39:04.640 --> 00:39:06.600
and there are lots of new features,


00:39:06.600 --> 00:39:09.340
automatic environment activation in the terminal,


00:39:09.340 --> 00:39:11.800
some debugging improvements and a lot more.


00:39:11.800 --> 00:39:14.300
So you can check out the blog post in the show notes


00:39:14.300 --> 00:39:15.940
for some more information.


00:39:15.940 --> 00:39:18.140
Brett, I don't know why you're being so shy.


00:39:18.140 --> 00:39:20.720
- Tootie layout, all right.


00:39:20.720 --> 00:39:22.720
- You should be the one bringing this up.


00:39:22.720 --> 00:39:24.400
That's fine.


00:39:24.400 --> 00:39:26.520
And then there's one more thing I wanted to mention.


00:39:26.520 --> 00:39:30.560
PyCascades is a really nice, smaller Python conference


00:39:30.560 --> 00:39:34.280
that's happening February of 2019 in Seattle.


00:39:34.280 --> 00:39:37.040
And right now the call for proposals is open.


00:39:37.040 --> 00:39:39.540
It closes on October 21st,


00:39:39.540 --> 00:39:42.800
so you should still hopefully have a little bit of time.


00:39:42.800 --> 00:39:44.320
And they're doing something great


00:39:44.320 --> 00:39:47.000
that I haven't seen from too many conferences before,


00:39:47.000 --> 00:39:48.600
which is offering mentorship.


00:39:48.600 --> 00:39:50.160
- Yeah, this is for like new speakers and stuff


00:39:50.160 --> 00:39:51.840
who maybe wanna speak, but they're like,


00:39:51.840 --> 00:39:53.560
eh, I've never done this, I'm a little unsure


00:39:53.560 --> 00:39:55.200
that this is actually a good idea,


00:39:55.200 --> 00:39:57.040
could really use some help, that type of thing?


00:39:57.040 --> 00:39:57.880
- Yeah.


00:39:57.880 --> 00:39:58.700
- Yeah, that's awesome.


00:39:58.700 --> 00:39:59.540
- Yeah, it's really great.


00:39:59.540 --> 00:40:00.960
I've been volunteering as a mentor


00:40:00.960 --> 00:40:03.560
and it's been a really rewarding experience


00:40:03.560 --> 00:40:05.940
to kind of coach people through all their fears


00:40:05.940 --> 00:40:07.400
because at the end of the day,


00:40:07.400 --> 00:40:09.440
we can all speak at a Python conference.


00:40:09.440 --> 00:40:10.280
- Yeah, absolutely.


00:40:10.280 --> 00:40:11.920
That's awesome, I'm glad you brought those up.


00:40:11.920 --> 00:40:14.280
I've already booked my travel and submitted three talks


00:40:14.280 --> 00:40:15.560
and I even put Brian's name on one,


00:40:15.560 --> 00:40:16.840
so he has to come now too.


00:40:16.840 --> 00:40:19.000
(laughing)


00:40:19.000 --> 00:40:19.840
- I'll send my channel policy.


00:40:19.840 --> 00:40:22.640
- I'll say last year was my favorite conference,


00:40:22.640 --> 00:40:25.680
probably, potentially ever, was the Inaugural Pike Cascades.


00:40:25.680 --> 00:40:27.560
So you should definitely go if you can make it.


00:40:27.560 --> 00:40:29.160
- I agree, that was up in Vancouver,


00:40:29.160 --> 00:40:30.600
where you and Dan are,


00:40:30.600 --> 00:40:32.160
but this time it's moving down to Seattle,


00:40:32.160 --> 00:40:34.360
and then later it comes to visit us here in Portland.


00:40:34.360 --> 00:40:36.560
So I think it's a great one as well, Brett.


00:40:36.560 --> 00:40:38.320
- That's right, 2020.


00:40:38.320 --> 00:40:40.800
- That's right, it'll be here, I'll drive.


00:40:40.800 --> 00:40:42.440
We'll have to stay at a hotel, it'll be great.


00:40:42.440 --> 00:40:44.920
All right, the rest of you, anything else?


00:40:44.920 --> 00:40:47.000
Dan, Brian, you wanna share anything before we hit the road?


00:40:47.000 --> 00:40:48.960
- Just wanna say the upcoming,


00:40:48.960 --> 00:40:52.440
I've got a recording with a guy named Anthony Shaw.


00:40:52.440 --> 00:40:54.320
- Oh, that guy, yeah, I've heard he's good on the podcast.


00:40:54.320 --> 00:40:57.960
- Yeah, we're gonna talk about flaky tests on Testing Code,


00:40:57.960 --> 00:40:58.800
so that should be fun.


00:40:58.800 --> 00:40:59.640
- Right on.


00:40:59.640 --> 00:41:00.680
Dan, anything?


00:41:00.680 --> 00:41:01.880
- No, I got nothing.


00:41:01.880 --> 00:41:03.880
I hope you invite me back for episode 200.


00:41:03.880 --> 00:41:06.360
- Yeah, you all already have an invite.


00:41:06.360 --> 00:41:07.880
We'll be there in just about two years,


00:41:07.880 --> 00:41:10.320
so you all hang in there, and we'll do this again.


00:41:10.320 --> 00:41:12.440
Thank you all for coming, this was really great,


00:41:12.440 --> 00:41:14.280
and thanks for help with the show


00:41:14.280 --> 00:41:17.080
throughout the last two years, and today, of course.


00:41:17.080 --> 00:41:18.400
- Thanks for having us.


00:41:18.400 --> 00:41:19.240
- Yeah, thanks for doing this.


00:41:19.240 --> 00:41:20.920
- And congrats again.


00:41:20.920 --> 00:41:21.760
- Thanks, bye, everyone.


00:41:21.760 --> 00:41:23.600
And Brian, special thanks.


00:41:23.600 --> 00:41:25.120
You've been here for all 100 of them.


00:41:25.120 --> 00:41:28.760
Well maybe 99 because we each bowed out at one or two, but that's all good.


00:41:28.760 --> 00:41:29.760
Yeah.


00:41:29.760 --> 00:41:30.760
All right.


00:41:30.760 --> 00:41:31.760
Thanks, man.


00:41:31.760 --> 00:41:32.760
Bye, everyone.


00:41:32.760 --> 00:41:33.760
Thanks.


00:41:33.760 --> 00:41:34.760
Bye.


00:41:34.760 --> 00:41:35.760
Bye.


00:41:35.760 --> 00:41:36.760
Bye.


00:41:36.760 --> 00:41:37.760
Thank you for listening to Python Bytes.


00:41:37.760 --> 00:41:39.560
Follow the show on Twitter via @PythonBytes.


00:41:39.560 --> 00:41:42.680
That's Python Bytes as in B-Y-T-E-S.


00:41:42.680 --> 00:41:45.980
And get the full show notes at PythonBytes.fm.


00:41:45.980 --> 00:41:49.680
If you have a news item you want featured, just visit PythonBytes.fm and send it our


00:41:49.680 --> 00:41:50.680
way.


00:41:50.680 --> 00:41:53.180
the lookout for sharing something cool.


00:41:53.180 --> 00:41:56.640
On behalf of myself and Brian Aukin, this is Michael Kennedy.


00:41:56.640 --> 00:41:59.680
Thank you for listening and sharing this podcast with your friends and colleagues.

