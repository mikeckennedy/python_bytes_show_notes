WEBVTT

00:00:00.001 --> 00:00:03.180
I am pulling off a very, very cool trick.

00:00:03.180 --> 00:00:04.860
I just want to point out before we get started.

00:00:04.860 --> 00:00:05.440
Okay.

00:00:05.440 --> 00:00:07.100
On the Talk Python channel,

00:00:07.100 --> 00:00:10.500
I'm doing a podcast with Anthony Shaw and Shane from Microsoft

00:00:10.500 --> 00:00:14.900
about Azure and Python and some CLI stuff they built and FastAPI.

00:00:14.900 --> 00:00:17.720
And at the exact same time, I'm doing this one here.

00:00:17.720 --> 00:00:18.700
They're both streaming live.

00:00:18.700 --> 00:00:21.900
I don't know how that's happening.

00:00:21.900 --> 00:00:25.120
The other one was recorded two months ago,

00:00:25.120 --> 00:00:27.840
and we couldn't release it because some of the things weren't finished yet.

00:00:27.840 --> 00:00:29.380
So I hit go on that.

00:00:29.680 --> 00:00:32.580
The real one, if you're bouncing around, the real one is here.

00:00:32.580 --> 00:00:33.200
Okay.

00:00:33.200 --> 00:00:34.440
So a joint is here.

00:00:34.440 --> 00:00:36.680
Anyway, with that, you ready to start a podcast?

00:00:36.680 --> 00:00:37.760
Yeah, definitely.

00:00:37.760 --> 00:00:39.560
Hello, and welcome to Python Bytes,

00:00:39.560 --> 00:00:42.780
where we deliver Python news and headlines directly to your earbuds.

00:00:42.780 --> 00:00:47.260
This is episode 294, recorded July 12th, 2022.

00:00:47.260 --> 00:00:48.260
I'm Michael Kennedy.

00:00:48.260 --> 00:00:49.720
And I am Brian Okken.

00:00:49.720 --> 00:00:51.920
It's just us this weekend, or this today.

00:00:51.920 --> 00:00:52.400
It's just us.

00:00:52.400 --> 00:00:52.860
Yeah.

00:00:52.860 --> 00:00:55.640
Yeah, it's, I don't know.

00:00:55.640 --> 00:00:58.780
Dean out of the audience asks, is this a daily podcast show now?

00:00:59.360 --> 00:01:01.560
I'm a little bit torn about it.

00:01:01.560 --> 00:01:03.320
I feel like we almost could do a daily show.

00:01:03.320 --> 00:01:06.200
But then I think what it might take to do a daily show,

00:01:06.200 --> 00:01:08.420
knowing how much work a weekly show is.

00:01:08.420 --> 00:01:10.540
No, it's not a daily podcast.

00:01:10.540 --> 00:01:10.800
No.

00:01:10.800 --> 00:01:12.460
It might be fun to do sometime.

00:01:12.460 --> 00:01:14.400
Just do like a full week or something.

00:01:14.400 --> 00:01:15.120
Right.

00:01:15.200 --> 00:01:15.560
Exactly.

00:01:15.560 --> 00:01:18.400
Just a super, there's so much news.

00:01:18.400 --> 00:01:20.060
We're doing it every day for the week.

00:01:20.060 --> 00:01:20.640
Cool.

00:01:20.640 --> 00:01:23.300
But just like the same topics, like six days in a row.

00:01:23.300 --> 00:01:23.900
Just do them over.

00:01:23.900 --> 00:01:25.120
Yeah.

00:01:25.120 --> 00:01:27.520
Exactly.

00:01:27.520 --> 00:01:28.060
Exactly.

00:01:28.060 --> 00:01:29.040
All right.

00:01:29.040 --> 00:01:30.500
Am I up first this week?

00:01:30.500 --> 00:01:31.340
You are.

00:01:31.340 --> 00:01:31.920
Yes.

00:01:31.920 --> 00:01:32.900
Right on.

00:01:32.900 --> 00:01:36.180
Well, let me tell you about something special.

00:01:36.180 --> 00:01:37.240
Specialist.

00:01:37.240 --> 00:01:37.760
Okay.

00:01:38.100 --> 00:01:44.080
Just last week, I believe it was, I interviewed Alex Waygood, who did the write-up for the Python

00:01:44.080 --> 00:01:44.760
Language Summit.

00:01:44.760 --> 00:01:49.660
And as part of the topics we were discovering, you know, the Python Language Summit and Python

00:01:49.660 --> 00:01:53.920
this year is focusing a lot on performance and what's called the Shannon Plan.

00:01:54.300 --> 00:01:59.140
So this is Mark Shannon's plan to make Python five times faster over five releases.

00:01:59.140 --> 00:02:01.700
It's got a ton of support at Microsoft.

00:02:01.700 --> 00:02:06.740
Peter Van Rossum is there working on it, but they've hired like five or six other people who

00:02:06.740 --> 00:02:08.920
are full-time working on making Python faster now.

00:02:08.920 --> 00:02:09.780
So awesome.

00:02:09.780 --> 00:02:10.140
Awesome.

00:02:10.140 --> 00:02:11.160
Thank you for that.

00:02:11.160 --> 00:02:18.020
However, one of the things that made Python 3.11 fast is some of the early work they did.

00:02:18.020 --> 00:02:24.740
And it comes down to PEP 659, a specializing adaptive interpreter.

00:02:24.740 --> 00:02:30.400
So let me tell you about this feature, this performance improvement first, and then we'll

00:02:30.400 --> 00:02:34.780
see what specialist is about because it's about understanding and visualizing this behavior.

00:02:34.780 --> 00:02:35.240
Okay.

00:02:35.240 --> 00:02:42.940
So one of the things that is a problem with Python, because it's dynamic and its types can change

00:02:42.940 --> 00:02:44.660
and what can be passed could vary.

00:02:44.660 --> 00:02:48.440
I mean, you could have type hints, but you can violate the type hints all day long and

00:02:48.440 --> 00:02:48.900
it's fine.

00:02:48.900 --> 00:02:54.500
So what the interpreter has to do is say, well, we're going to do all of our operations super

00:02:54.500 --> 00:02:54.920
general.

00:02:54.920 --> 00:02:59.820
So if I have a function and it's called add and it takes X and Y and it returns X plus Y

00:02:59.820 --> 00:03:02.760
seems easy, but is that string addition?

00:03:02.760 --> 00:03:05.280
Is that numerical addition?

00:03:05.280 --> 00:03:12.200
Is that some custom operator overloading with a dunder add or whatever it is in some type?

00:03:12.200 --> 00:03:14.220
If it fails in one way, you kind of got to reverse it.

00:03:14.220 --> 00:03:15.720
Like there's all this unknown, right?

00:03:15.720 --> 00:03:16.180
Yeah.

00:03:16.180 --> 00:03:22.420
What if you knew, what if you knew those were integers and not classes or not strings?

00:03:22.420 --> 00:03:24.040
You could run different code.

00:03:24.040 --> 00:03:26.400
You wouldn't have to first figure out what they are.

00:03:26.400 --> 00:03:27.060
Are they compatible?

00:03:27.060 --> 00:03:32.460
Do you do the add in low level CPython internals?

00:03:32.460 --> 00:03:34.420
Or do you go to like some Python class and do it?

00:03:34.420 --> 00:03:34.760
Right.

00:03:34.760 --> 00:03:36.260
You could be much more focused.

00:03:36.260 --> 00:03:36.800
Yeah.

00:03:37.220 --> 00:03:41.200
Additionally, if it was adding for a list, you could say, well, if I know their list,

00:03:41.200 --> 00:03:45.940
what we just do is go list dot extend and we give it the other list, right?

00:03:45.940 --> 00:03:48.040
We don't hunt around and figure out all this other stuff.

00:03:48.040 --> 00:03:54.020
So that's the general idea of the specializing interpreter is it goes through and it says, look,

00:03:54.020 --> 00:03:57.200
we don't know for sure what could be passed here.

00:03:57.380 --> 00:04:03.220
But if it looks like over and over we're running the same code and it's always the same types,

00:04:03.220 --> 00:04:07.900
is there a way we could specialize those types, right?

00:04:07.900 --> 00:04:14.140
Is there a way that we could put specific code for adding numbers or specific code for combining lists?

00:04:14.140 --> 00:04:18.900
And this is called adaptive and speculative specialization.

00:04:18.900 --> 00:04:19.760
Okay.

00:04:19.760 --> 00:04:20.400
Okay.

00:04:21.140 --> 00:04:25.220
And my favorite part of it, when it's performed, it's called the quickening.

00:04:25.220 --> 00:04:30.940
Quickening is the process of replacing slow instructions with faster variants.

00:04:30.940 --> 00:04:35.240
So kind of like I said, it has some advantages over immutable byte code.

00:04:35.240 --> 00:04:36.620
It can be changed at runtime.

00:04:36.620 --> 00:04:39.100
Like you see, we're always adding integers.

00:04:39.100 --> 00:04:43.460
It can use super instructions that span lines or take multiple operands.

00:04:43.460 --> 00:04:48.420
And it does not need to handle tracing as it can fall back to the original byte code for that.

00:04:48.420 --> 00:04:48.800
Okay.

00:04:48.800 --> 00:04:49.380
Okay.

00:04:49.380 --> 00:04:51.520
So there's a whole bunch of stuff going on here.

00:04:51.520 --> 00:04:56.060
Like the example they give is you might want to specialize load adder.

00:04:56.060 --> 00:05:00.360
So load adder is a way to say, give me the value that this thing contains.

00:05:00.360 --> 00:05:01.660
But what is the thing?

00:05:01.660 --> 00:05:05.840
One of the things you might do is you might realize it's an instance class.

00:05:05.840 --> 00:05:09.080
And then you would call load adder instance value.

00:05:09.080 --> 00:05:09.600
Okay.

00:05:09.600 --> 00:05:14.460
You might realize it's a module and you might call load adder module or slot or so on, right?

00:05:14.460 --> 00:05:17.620
But if you knew, you don't have to go through first the abstract step

00:05:17.620 --> 00:05:20.120
and then figure out which of these it is.

00:05:20.120 --> 00:05:21.460
You just do the thing that it is.

00:05:21.460 --> 00:05:22.080
Okay.

00:05:22.080 --> 00:05:24.340
So that's the idea of this PEP.

00:05:24.340 --> 00:05:27.720
This is one of the things that's making Python 3.11 faster.

00:05:27.720 --> 00:05:28.380
Awesome.

00:05:28.380 --> 00:05:30.180
So to the main topic.

00:05:30.180 --> 00:05:30.900
Okay.

00:05:30.900 --> 00:05:35.540
And I'll just, just as a note, I'm saying, okay, as if I understand what you just said,

00:05:35.540 --> 00:05:37.080
but most of it just went.

00:05:37.080 --> 00:05:38.240
It's all right.

00:05:38.240 --> 00:05:39.740
I think, well, let's, let's look at pictures.

00:05:39.740 --> 00:05:40.280
Okay.

00:05:40.280 --> 00:05:40.920
All right.

00:05:40.920 --> 00:05:46.300
So this thing by Brant Boucher is called Specialist.

00:05:46.300 --> 00:05:50.140
And it's about visualizing this specializing adaptive interpreter.

00:05:50.140 --> 00:05:50.880
Okay.

00:05:50.880 --> 00:05:51.240
Good.

00:05:51.240 --> 00:05:52.020
Okay.

00:05:52.020 --> 00:05:57.220
So it says Specialist uses fine-grained location information to create visual representations

00:05:57.220 --> 00:06:04.220
of exactly where and how CPython 3.11's new specializing adaptive interpreter optimizes

00:06:04.220 --> 00:06:04.740
your code.

00:06:04.740 --> 00:06:06.820
And it's not just interesting.

00:06:06.820 --> 00:06:08.720
It has actionable information.

00:06:08.720 --> 00:06:14.740
So for example, see here, and if you've got to pull up this, the website, if you're just

00:06:14.740 --> 00:06:17.880
listening, if you see in that website, you'll see some color.

00:06:18.140 --> 00:06:23.560
You'll see green, less green, yellow, orange, and all the way to red.

00:06:23.560 --> 00:06:24.560
So there's two aspects.

00:06:24.560 --> 00:06:27.420
There's sort of a darkness as well as a color.

00:06:27.420 --> 00:06:33.300
So the, the most, like where Python could take advantage of this feature, you see green

00:06:33.300 --> 00:06:34.960
where it can't, you see red.

00:06:34.960 --> 00:06:37.900
And imagine a spectrum.

00:06:37.900 --> 00:06:40.880
It goes like green, yellow, orange, red.

00:06:40.880 --> 00:06:42.220
So it's, it's not on or off.

00:06:42.220 --> 00:06:43.640
It's how much could it specialize?

00:06:43.640 --> 00:06:44.260
Okay.

00:06:44.260 --> 00:06:44.620
Okay.

00:06:44.620 --> 00:06:52.080
So what you see here, for example, is it's able to take some numbers and an integer and

00:06:52.080 --> 00:06:57.580
a string, and then use the fact that it knows what those are to make certain things like a

00:06:57.580 --> 00:07:02.240
pending and output and doing some character operations on it.

00:07:02.240 --> 00:07:02.740
Yeah.

00:07:02.740 --> 00:07:03.040
Right.

00:07:03.040 --> 00:07:07.080
It was able to replace that with a different runtime behavior because of this quickening.

00:07:07.080 --> 00:07:07.640
All right.

00:07:07.640 --> 00:07:08.880
So let's skip down here.

00:07:08.880 --> 00:07:10.540
I gave you a bit of the background.

00:07:10.540 --> 00:07:11.860
So it says, let's look at this example.

00:07:11.860 --> 00:07:15.680
We have F to C, which converts Fahrenheit to Celsius.

00:07:15.680 --> 00:07:20.480
And what it does is, okay, we're going to take an F and it has type hints that say float,

00:07:20.480 --> 00:07:20.780
float.

00:07:20.780 --> 00:07:21.100
Okay.

00:07:21.100 --> 00:07:22.280
So, but those don't matter.

00:07:22.280 --> 00:07:26.700
So it says, we're going to take an F and subtract 32 from it.

00:07:26.700 --> 00:07:28.420
And then we're going to do simple math.

00:07:28.420 --> 00:07:33.940
We're going to take that result, that range, that, that, size of temperature there based

00:07:33.940 --> 00:07:36.560
on zero and then multiply it by five and divide it by nine.

00:07:36.560 --> 00:07:41.520
And we all learned this in chemistry class or somewhere, or we talked about diverting different,

00:07:41.520 --> 00:07:42.840
um, measurement.

00:07:42.840 --> 00:07:43.820
Yeah, of course.

00:07:43.820 --> 00:07:44.200
Yeah.

00:07:44.200 --> 00:07:44.660
Right.

00:07:44.660 --> 00:07:50.700
So these are straightforward, but there's actually problems in here that make it slower and prohibit

00:07:50.700 --> 00:07:54.400
Python from quickening it as much as it can be quickened.

00:07:54.400 --> 00:07:55.120
Okay.

00:07:55.440 --> 00:07:59.740
So if we take this code, it just runs, F to C and C to F, and it gives it some test

00:07:59.740 --> 00:08:02.060
values and says, just do it and tell us what happened.

00:08:02.060 --> 00:08:03.760
We can run specialists on it.

00:08:03.760 --> 00:08:08.540
And it says, okay, this X here is, the green areas indicate regions of code that were

00:08:08.540 --> 00:08:13.000
successfully specialized where red areas are unsuccessful.

00:08:13.000 --> 00:08:14.520
Like it tried and it failed.

00:08:14.520 --> 00:08:20.220
So it says one of the problems is start out the X equals F minus 32.

00:08:20.220 --> 00:08:26.480
It says, well, we can quicken operations on numerical types that are the same, but for now

00:08:26.480 --> 00:08:29.560
there's not a float int and float variant of this.

00:08:29.560 --> 00:08:30.660
It's got to be float float.

00:08:30.660 --> 00:08:31.340
Oh, right.

00:08:31.340 --> 00:08:32.400
So it says, right.

00:08:32.400 --> 00:08:36.800
You, you could have gotten a faster operation there, but because the types didn't match,

00:08:36.800 --> 00:08:37.480
you won't.

00:08:37.480 --> 00:08:39.840
But then what it did get out is an X and that was great.

00:08:39.840 --> 00:08:43.020
Uh, an X, which is a float and it's going to do some stuff and it could sort of make it

00:08:43.020 --> 00:08:47.660
better, but it said, look, here's some multiplication again by an integer and a float.

00:08:47.660 --> 00:08:48.660
So that's not quickened.

00:08:48.660 --> 00:08:51.920
And this division division is apparently never quickened.

00:08:51.920 --> 00:08:52.980
So what can we do?

00:08:52.980 --> 00:08:57.180
Well, with that information to say, well, what's the problem with subtracting 32?

00:08:57.180 --> 00:08:58.360
Well, it wasn't a float.

00:08:58.360 --> 00:08:59.940
What if I said 32.0?

00:08:59.940 --> 00:09:00.920
Oh, yes.

00:09:00.920 --> 00:09:01.280
All right.

00:09:01.280 --> 00:09:02.900
That gets replaced by faster code.

00:09:02.900 --> 00:09:03.760
Oh, nice.

00:09:03.760 --> 00:09:03.960
Right.

00:09:03.960 --> 00:09:04.200
Yeah.

00:09:04.200 --> 00:09:05.260
So that's pretty nice.

00:09:05.260 --> 00:09:09.360
And if you want to return, it was adding like X plus 32 for the other direction.

00:09:09.740 --> 00:09:10.740
And now it's 32.0.

00:09:10.740 --> 00:09:11.400
That's faster.

00:09:11.400 --> 00:09:11.940
Okay.

00:09:11.940 --> 00:09:12.700
Well, what else?

00:09:12.700 --> 00:09:19.080
What if we, now you can see when we did that part of the, conversion X times five divided

00:09:19.080 --> 00:09:24.300
by nine, if we put a 5.0, that gets faster still, but the divide is never quickened.

00:09:24.300 --> 00:09:24.680
Okay.

00:09:24.680 --> 00:09:26.840
Well, what if we put the divide in parentheses?

00:09:26.840 --> 00:09:32.340
It doesn't really matter if it's X times five divided by nine or X times five divided by

00:09:32.340 --> 00:09:32.820
nine, right?

00:09:32.820 --> 00:09:36.920
It's, these are mathematically equivalent, but they're not equivalent to Python because

00:09:36.920 --> 00:09:42.820
that, that operation results in, it leverages constant folding, right?

00:09:42.820 --> 00:09:46.020
Five divided by nine is pre-computed in Python to be a float.

00:09:46.020 --> 00:09:46.640
Okay.

00:09:46.640 --> 00:09:47.120
Right.

00:09:47.120 --> 00:09:48.120
At parse time, right?

00:09:48.120 --> 00:09:49.300
That's just how it works with constants.

00:09:49.300 --> 00:09:51.880
If it says it can do math with constants ahead of time, it does it.

00:09:51.880 --> 00:09:53.040
So that becomes a float.

00:09:53.040 --> 00:09:54.780
And then float times float is now quickened.

00:09:54.780 --> 00:09:55.260
Right.

00:09:55.480 --> 00:09:59.360
Isn't this cool the way you can apply this and actually make your code faster, not just

00:09:59.360 --> 00:10:00.200
go, Oh, it's interesting.

00:10:00.200 --> 00:10:02.680
It must be quick in it there, but it's actionable.

00:10:02.680 --> 00:10:04.140
It is really pretty cool.

00:10:04.140 --> 00:10:09.420
And I'd really like to see this incorporated into an editor or something to say you, your

00:10:09.420 --> 00:10:13.300
code will be faster if you just add a point zero here or something like that.

00:10:13.300 --> 00:10:15.520
And it's going to become a float anyway.

00:10:15.520 --> 00:10:16.260
It doesn't matter.

00:10:16.260 --> 00:10:21.540
It just, why would you write 32.0 when you just meant 32 seems more precise to say 32.

00:10:22.860 --> 00:10:26.040
Cause I'm used to doing that to thinking if it's okay.

00:10:26.040 --> 00:10:30.400
Well, me personally, I, if I know it's going to be a float math, I usually do point zero,

00:10:30.400 --> 00:10:32.700
but maybe, maybe that's not a normal thing.

00:10:32.700 --> 00:10:34.340
You're such a C programmer.

00:10:34.340 --> 00:10:39.240
All right.

00:10:39.240 --> 00:10:40.820
Well, I think this is really cool.

00:10:40.820 --> 00:10:41.760
This is a specialist.

00:10:41.760 --> 00:10:47.040
And, you know, I don't know if I have any code that does math at that finer, greater level

00:10:47.040 --> 00:10:51.100
that I really care, but maybe, you know, if you're in charge of a library where you've

00:10:51.100 --> 00:10:55.720
got a tight loop or you do a lot of math science stuff where it matters, this can be really

00:10:55.720 --> 00:10:56.280
useful.

00:10:56.280 --> 00:11:02.420
And what's cool is it's not like, and switch to rust or switch to C or switch to Cython

00:11:02.420 --> 00:11:03.800
and it'll take effect.

00:11:03.800 --> 00:11:06.340
Like, no, this, this is like straight Python code.

00:11:06.340 --> 00:11:10.940
This is just, how do I take most advantage of what is already happening for performance

00:11:10.940 --> 00:11:13.200
boosts in 3.11 that we haven't had before?

00:11:13.200 --> 00:11:16.000
I think, and I think it's going to be just one more workflow step.

00:11:16.160 --> 00:11:22.220
So you've got, you profile your code, your whole thing is a little bit slower than you'd

00:11:22.220 --> 00:11:22.760
like it to be.

00:11:22.760 --> 00:11:24.440
You throw a profiler on it.

00:11:24.440 --> 00:11:27.200
You see the bottleneck areas that you could improve.

00:11:27.200 --> 00:11:32.640
And you think, should I like rewrite some of this in rust or C or, you know, what should

00:11:32.640 --> 00:11:32.980
I do?

00:11:32.980 --> 00:11:39.560
Well, first off, let's try doing this, like throw, throw, throw this at it and, and, and

00:11:39.560 --> 00:11:42.720
have the optimizer from 3.11 help you out.

00:11:42.720 --> 00:11:49.300
And, and yeah, so I think this, I can definitely see that this is going to be part of people's

00:11:49.300 --> 00:11:50.860
workflow, but yeah.

00:11:50.860 --> 00:11:52.500
I agree that you want to profile it.

00:11:52.500 --> 00:11:54.160
Yes, exactly.

00:11:54.160 --> 00:11:56.000
Cause while it's fun to do this.

00:11:56.000 --> 00:11:56.740
Yeah.

00:11:56.740 --> 00:11:57.340
Yeah.

00:11:57.340 --> 00:11:58.720
Only focus where it's going to matter.

00:11:58.720 --> 00:12:01.100
Don't, don't optimize a bunch of stuff that doesn't.

00:12:01.240 --> 00:12:06.540
So Brian out in the audience says, different Brian, is there a plan to do lossless type

00:12:06.540 --> 00:12:09.900
conversion or maybe flake eight can make this kind of suggestion?

00:12:09.900 --> 00:12:10.940
Yeah, exactly.

00:12:10.940 --> 00:12:12.100
That'd be fair.

00:12:12.100 --> 00:12:12.360
Yeah.

00:12:12.360 --> 00:12:18.020
I'm not really sure if you don't want to write the code where you get different outputs probably.

00:12:18.020 --> 00:12:18.620
Right.

00:12:18.620 --> 00:12:23.860
But everything that was happening here, you were, you ended up with the same outcome anyway.

00:12:23.860 --> 00:12:26.460
It's just like, well, do I do the division first or the multiplication?

00:12:27.000 --> 00:12:31.800
Or do I start with an ant that results after some addition subtraction with a float?

00:12:31.800 --> 00:12:33.520
Or is I just make them all floats?

00:12:33.520 --> 00:12:33.980
Right.

00:12:33.980 --> 00:12:38.280
I feel like it's, in most cases, it shouldn't be changing the outcome.

00:12:38.280 --> 00:12:38.880
So.

00:12:38.880 --> 00:12:39.520
Okay.

00:12:39.520 --> 00:12:40.220
Yeah.

00:12:40.220 --> 00:12:40.700
Yeah.

00:12:40.700 --> 00:12:41.240
Cool.

00:12:41.240 --> 00:12:43.740
Anyway, that's, that's what I got for the first one.

00:12:43.740 --> 00:12:44.120
How about you?

00:12:44.120 --> 00:12:48.800
Well, we're kind of sticking with a 3.11 theme so far.

00:12:48.800 --> 00:12:56.860
Well, we can use Toml now, but in 3.11, we are going to have a Toml that'd be part of

00:12:56.860 --> 00:13:00.040
part of Python 3.11 with PEP 6.80.

00:13:00.040 --> 00:13:02.700
And we covered that in episode 273.

00:13:02.700 --> 00:13:11.200
But I, I, one of the things we didn't mention was that, was the, the, the Toml lib is, is,

00:13:11.200 --> 00:13:15.800
and I think we did mention it, it's based on Tomly, but Tomly you can use right now.

00:13:15.800 --> 00:13:23.220
So a lot of projects are switching to use Tomly as a, as their Toml, Toml parser, to, to

00:13:23.220 --> 00:13:28.640
read, read, like pyproject.toml or, or read their own, config file.

00:13:28.980 --> 00:13:32.200
And, and so I just wanted to highlight it.

00:13:32.200 --> 00:13:36.060
It's a Tomly is the, a little Toml parser.

00:13:36.060 --> 00:13:39.300
Um, it's a cute little thing on the project.

00:13:39.300 --> 00:13:39.820
It's cute.

00:13:39.820 --> 00:13:46.780
But, but I was reminded of it because, real, the real Python people, put

00:13:46.780 --> 00:13:49.120
out actually looks like gear.

00:13:49.500 --> 00:13:51.860
Sorry, I'm not going to try to pronounce that name.

00:13:51.860 --> 00:13:58.340
Uh, real Python, wrote an article called, Python and Toml new, new best friends.

00:13:58.340 --> 00:14:02.140
And I really love it's a, it's a very comprehensive article.

00:14:02.140 --> 00:14:07.660
Um, but I really love at least the first three parts of it, using Toml as a config format,

00:14:07.660 --> 00:14:13.880
uh, getting to know key value pairs and, load Toml with Python, because this is kind

00:14:13.880 --> 00:14:15.140
of what you're going to do with it.

00:14:15.140 --> 00:14:16.780
You're going to write config files for something.

00:14:17.220 --> 00:14:21.680
And I just kind of, it's, this is a great introduction of Toml for Python.

00:14:21.680 --> 00:14:23.400
And that's kind of what we care about.

00:14:23.400 --> 00:14:23.660
Right.

00:14:23.660 --> 00:14:30.000
So, it goes through like just getting, getting used to what Toml looks like, what a

00:14:30.000 --> 00:14:35.200
config file looks like talking about how all the keys, even if you, it's like key value

00:14:35.200 --> 00:14:35.620
stuff.

00:14:35.620 --> 00:14:39.600
And even if you, you put a number there or something, it's going to be a string.

00:14:39.600 --> 00:14:42.640
All the keys get converted to strings, even if they don't look like them.

00:14:42.640 --> 00:14:46.460
Um, and they are, they're, they're UTF eight.

00:14:46.460 --> 00:14:50.700
So you can use, unit code in there as well, which is kind of neat.

00:14:50.700 --> 00:14:52.360
Um, put your emojis in there.

00:14:52.360 --> 00:14:53.020
Yeah.

00:14:53.140 --> 00:14:56.220
Well, can you, is, is our emojis UTF eight?

00:14:56.220 --> 00:15:00.880
Um, I think mostly, many of them are interesting.

00:15:00.880 --> 00:15:05.320
That'd be fun to put, put emojis in your, I don't know.

00:15:05.320 --> 00:15:06.280
What motor we were in.

00:15:06.280 --> 00:15:08.520
Are we running in cow mode or lizard mode?

00:15:08.520 --> 00:15:09.200
I'll do lizard.

00:15:09.200 --> 00:15:09.440
Yeah.

00:15:09.440 --> 00:15:09.600
Okay.

00:15:09.600 --> 00:15:11.100
Well, if you're running in lizard mode.

00:15:11.100 --> 00:15:11.980
Okay.

00:15:11.980 --> 00:15:14.580
I got to try that to see.

00:15:14.580 --> 00:15:16.180
Uh, I should have done that before.

00:15:16.180 --> 00:15:16.760
Oh my gosh.

00:15:16.760 --> 00:15:21.960
I think almost it's both horrible and amazing to imagine writing like config files to like

00:15:21.960 --> 00:15:23.320
put it and put it in lizard mode.

00:15:23.320 --> 00:15:23.660
Do it.

00:15:23.660 --> 00:15:24.360
Yeah.

00:15:24.760 --> 00:15:28.040
Um, one of the things that I didn't before reading this article, one of the things I

00:15:28.040 --> 00:15:32.820
didn't know you could do in Toml, because I just sort of cursory, I use it with pipe project

00:15:32.820 --> 00:15:40.420
at Toml and that's about it, but you can do, so, talks about, normal, how

00:15:40.420 --> 00:15:40.980
to read stuff.

00:15:40.980 --> 00:15:44.140
But one of the things is, Oh, what was I going to talk about?

00:15:44.140 --> 00:15:50.860
Arrays, and you can do arrays of things which are neat and tables and arrays of tables,

00:15:50.860 --> 00:15:56.160
uh, which is like, so you have arrays of tables or these bracket bracket things.

00:15:56.160 --> 00:15:59.300
And, and then you can do dot stuff.

00:15:59.300 --> 00:16:06.260
So if you have like, was it user and user dot player, these will show up as,

00:16:06.260 --> 00:16:09.760
as like, you know, sub dictionary key things.

00:16:10.180 --> 00:16:15.680
Um, and so one of the things that I, and I played with it this morning and, it really,

00:16:15.680 --> 00:16:20.560
I should have had a something to show, but the thing I like to do is to just read it.

00:16:20.560 --> 00:16:26.100
Uh, just like, this article talks about reading it, just read the Toml file into Python

00:16:26.100 --> 00:16:27.040
and print it.

00:16:27.040 --> 00:16:33.000
Um, and then you can, and it'll print out as a dictionary and then you can create whatever

00:16:33.000 --> 00:16:34.700
format you want for your Toml file.

00:16:34.700 --> 00:16:36.600
And then you can just see what it's going to look like.

00:16:36.600 --> 00:16:38.240
And then you know how to access it.

00:16:39.240 --> 00:16:40.980
That's one of the best ways to do that.

00:16:40.980 --> 00:16:41.600
That's awesome.

00:16:41.600 --> 00:16:42.460
Yeah.

00:16:42.460 --> 00:16:43.680
What an interesting format.

00:16:43.680 --> 00:16:45.060
That's pretty, that's pretty in depth.

00:16:45.060 --> 00:16:49.040
And, a blast from last week past Ashley.

00:16:49.040 --> 00:16:54.900
Hey, Ashley says UTF eight can encode any Unicode character emoji, your heart emoji.

00:16:54.900 --> 00:16:55.740
Heart out of it.

00:16:55.740 --> 00:16:56.000
Very.

00:16:56.000 --> 00:16:57.180
Oh yeah.

00:16:57.180 --> 00:16:59.460
You could do like, you know, is it in heart mode?

00:16:59.460 --> 00:17:00.380
Heart equals true.

00:17:00.380 --> 00:17:01.240
Heart equals false.

00:17:01.740 --> 00:17:06.540
Uh, oh, for optimize optimizer, you could do a flame emoji equals true.

00:17:06.540 --> 00:17:07.800
Um, exactly.

00:17:07.800 --> 00:17:08.860
So I love it.

00:17:08.860 --> 00:17:09.260
Yeah.

00:17:09.260 --> 00:17:13.500
I think, look, we have not leveraged the configuration as emoji sufficiently.

00:17:13.500 --> 00:17:14.480
Oh yeah.

00:17:14.480 --> 00:17:18.920
I think, I think a pie test should rewrite all of its config figs as emoji items.

00:17:18.920 --> 00:17:19.760
Just do a PR.

00:17:19.760 --> 00:17:20.640
I'm sure we'll take it.

00:17:20.640 --> 00:17:20.900
Yeah.

00:17:20.900 --> 00:17:23.500
Yeah.

00:17:23.500 --> 00:17:23.900
It'd be good.

00:17:23.980 --> 00:17:24.260
All right.

00:17:24.260 --> 00:17:24.960
Yeah.

00:17:24.960 --> 00:17:25.300
All right.

00:17:25.300 --> 00:17:27.660
Let me tell you about our sponsor for this week before we move on.

00:17:27.660 --> 00:17:31.080
So this week is brought to you by Microsoft Founders Hub.

00:17:31.080 --> 00:17:34.440
In fact, they are supporting a whole bunch of upcoming episodes.

00:17:34.440 --> 00:17:37.240
So thank you a whole bunch to Microsoft for startups here.

00:17:37.240 --> 00:17:39.360
Starting business is hard by some estimates.

00:17:39.360 --> 00:17:43.140
Over 90% of startups go out of business within their first year.

00:17:43.140 --> 00:17:47.060
With that in mind, Microsoft for startups set out to understand what startups need to be

00:17:47.060 --> 00:17:51.000
successful and to create a digital platform to help overcome those challenges.

00:17:51.000 --> 00:17:53.340
Microsoft for startups Founders Hub.

00:17:53.340 --> 00:17:58.860
Their hub provides all founders at any stage with a bunch of free resources to help solve

00:17:58.860 --> 00:17:59.300
challenges.

00:17:59.300 --> 00:18:04.880
And you get technology benefits, but also really importantly, access to experts, guidance and

00:18:04.880 --> 00:18:08.320
skilled resources, mentorship and networking connections and a bunch more.

00:18:08.320 --> 00:18:14.360
So unlike a bunch of other similar projects in the industry, Microsoft for startup founders

00:18:14.360 --> 00:18:19.680
hub does not require startups to be investor backed or third party validated to participate.

00:18:19.680 --> 00:18:21.280
It's free to apply.

00:18:21.280 --> 00:18:22.960
And if you apply, get in.

00:18:23.180 --> 00:18:24.420
Then it's you're in.

00:18:24.420 --> 00:18:25.380
It's open to all.

00:18:25.380 --> 00:18:28.080
So what do you get if you join or apply and then get accepted?

00:18:28.080 --> 00:18:32.980
So you can speed up your development with access to GitHub, Microsoft cloud, the ability to unlock

00:18:32.980 --> 00:18:38.140
credits over time, as in it gets over a hundred thousand dollars worth of credits over time over

00:18:38.140 --> 00:18:38.680
the first year.

00:18:38.680 --> 00:18:41.080
If you meet a bunch of milestones, which is fantastic.

00:18:41.080 --> 00:18:42.760
Help your startup innovate.

00:18:42.760 --> 00:18:47.540
Founders Hub is partnering with companies like OpenAI, the global leader in AI research and

00:18:47.540 --> 00:18:49.760
development to provide benefits and discounts too.

00:18:50.160 --> 00:18:50.760
Yeah.

00:18:50.760 --> 00:18:54.720
Through Microsoft startup founders hub, becoming a founder is no longer about who you know.

00:18:54.720 --> 00:19:00.620
You'll have access to the mentorship network, giving you all access to a pool of hundreds of mentors across a range of disciplines.

00:19:01.160 --> 00:19:07.580
Areas like idea, validation, fundraising, management, coaching, sales marketing, as well as specific technical technical stress points.

00:19:07.580 --> 00:19:12.400
To me, that's actually the biggest value is the networking and mentor side.

00:19:12.400 --> 00:19:17.020
So you'll be able to book a one-on-one meeting with these mentors, many of whom are founders themselves.

00:19:17.020 --> 00:19:22.160
Make your idea a reality today with the critical support you'll get from Microsoft or startups founders hub.

00:19:22.160 --> 00:19:25.460
Join the program at pythonbytes.fm/founders hub.

00:19:25.760 --> 00:19:27.220
Link will be in your player's show notes.

00:19:27.220 --> 00:19:27.840
Nice.

00:19:27.840 --> 00:19:28.340
Yeah.

00:19:28.340 --> 00:19:28.740
Cool.

00:19:28.740 --> 00:19:29.620
Indeed.

00:19:29.620 --> 00:19:30.440
All right.

00:19:30.440 --> 00:19:32.160
I guess I'm up next with this order we got.

00:19:32.160 --> 00:19:35.460
And oh my goodness, Samuel Colvin, take a bow.

00:19:35.460 --> 00:19:42.060
Because he put out a plan for what's happening with Pydantic version two.

00:19:42.600 --> 00:19:52.760
But the reason I say take a bow is this is one detailed plan that is really, really thought through, thought out, backed up with a bunch of GitHub discussions and so on.

00:19:52.760 --> 00:19:53.300
Wow.

00:19:53.440 --> 00:19:57.560
So the idea is Pydantic started out as an interesting idea.

00:19:57.560 --> 00:20:04.300
And surprise, surprise, a bunch of people glommed onto it probably more than it was originally envisioned to be so.

00:20:04.300 --> 00:20:14.440
So, for example, SQL model from Sebastian Ramirez is like, Pydantic models are now our ORM to the database with all the interesting stuff that ORMs have.

00:20:14.440 --> 00:20:16.380
And Roman Wright said, guess what?

00:20:16.380 --> 00:20:18.860
We could do that for MongoDB as well.

00:20:18.860 --> 00:20:21.740
Same with the Pydastic thing we recently spoke about.

00:20:21.740 --> 00:20:28.740
And then Sebastian Ramirez is like, also, like, hey, FastAPI, this can be both our data exchange as well as our documentation.

00:20:28.740 --> 00:20:31.900
I was like, oh my goodness, what's going on here?

00:20:31.900 --> 00:20:39.740
So there's a bunch of stuff on the insides that could be better, let's say, or maybe time to rethink this.

00:20:39.740 --> 00:20:46.380
So in this plan, it talks about what they'll add, what they'll remove, what will change, some of the ideas for how long it will take, and so on.

00:20:46.380 --> 00:20:47.720
Yeah.

00:20:47.720 --> 00:20:49.660
Here's a pretty significant thing.

00:20:49.660 --> 00:20:55.660
I'm currently taking a kind of sabbatical after leaving my last job to work on this, which goes until October.

00:20:55.660 --> 00:21:00.800
So that's a big commitment to I'm going to help make Pydantic better.

00:21:00.800 --> 00:21:01.540
Oh, wow.

00:21:01.540 --> 00:21:02.960
It sounds familiar.

00:21:02.960 --> 00:21:07.140
It sounds a bit like Rich and Textual and those types of things as well.

00:21:07.220 --> 00:21:11.920
But this is a big, big commitment from Samuel, and he's really doing a ton of work.

00:21:11.920 --> 00:21:14.120
It says, people seem to care about my project.

00:21:14.120 --> 00:21:17.380
It's downloaded 26 million times a month.

00:21:17.380 --> 00:21:18.440
Wow.

00:21:18.440 --> 00:21:19.400
Which is insane.

00:21:19.400 --> 00:21:20.440
Yeah, it's awesome.

00:21:20.440 --> 00:21:22.140
That's kind of incredible.

00:21:22.140 --> 00:21:22.920
It is.

00:21:22.920 --> 00:21:24.940
And so it says, here's the basic roadmap.

00:21:24.940 --> 00:21:28.740
Implement a few features in what's now called the Pydantic core.

00:21:28.860 --> 00:21:31.880
We just had Ashley, who, as we saw, is out in the audience.

00:21:31.880 --> 00:21:32.380
Hey, Ashley.

00:21:32.380 --> 00:21:34.500
Who give a bit of a shout out to this feature.

00:21:34.500 --> 00:21:39.500
And also, I do want to also credit a couple other people's because Douglas Nichols and John

00:21:39.500 --> 00:21:42.240
Thagan also let me know that this was big news coming.

00:21:42.240 --> 00:21:43.740
So thank you all for that.

00:21:43.740 --> 00:21:49.480
The Pydantic core is being rewritten in Rust, which doesn't mean you have to know or do anything.

00:21:49.480 --> 00:21:51.520
It just means you have to pip install something.

00:21:51.520 --> 00:21:54.440
You get a binary compiled thing that runs a lot faster.

00:21:54.820 --> 00:21:56.040
Okay, so more on that in a second.

00:21:56.040 --> 00:22:01.980
First, they're working to get 110 out and basically merge every open PR that makes sense

00:22:01.980 --> 00:22:04.940
and close every PR that doesn't make sense.

00:22:04.940 --> 00:22:09.820
And then profusely apologize to why your PR that you've spent a long time making was closed

00:22:09.820 --> 00:22:10.380
without merging.

00:22:10.380 --> 00:22:12.860
Some other bookkeeping things.

00:22:12.860 --> 00:22:17.000
Start tearing the Pydantic code apart and see how many existing tests can still be made

00:22:17.000 --> 00:22:19.300
to pass and then release eventually Pydantic.

00:22:19.300 --> 00:22:22.560
The goal is to have this done by October, probably by the end of the year for sure.

00:22:22.560 --> 00:22:24.200
A couple of things worth paying attention to.

00:22:24.320 --> 00:22:26.040
There are a bunch of breaking changes in here.

00:22:26.040 --> 00:22:31.500
A lot of things are being cleaned up, reorganized, renamed, some removed.

00:22:31.500 --> 00:22:34.800
Like from ORM, people might be using that with SQLAlchemy.

00:22:34.800 --> 00:22:37.220
That's being removed, for example, and so on.

00:22:37.220 --> 00:22:43.100
So there's, if you depend heavily on Pydantic, especially if you build a project like Beanie

00:22:43.100 --> 00:22:46.700
that depends heavily on Pydantic, you're going to need to look at this because some of the

00:22:46.700 --> 00:22:47.520
stuff won't work anymore.

00:22:47.520 --> 00:22:49.660
But let's highlight a couple of things here.

00:22:49.660 --> 00:22:50.100
Performance.

00:22:50.660 --> 00:22:57.080
This one is really important because this is the data exchange level for FastAPI.

00:22:57.080 --> 00:23:00.040
This is the database transformation level.

00:23:00.040 --> 00:23:03.760
When I do a query from the database, what comes back comes back in some raw form and then is

00:23:03.760 --> 00:23:05.000
turned into a Pydantic model.

00:23:05.380 --> 00:23:09.380
And those are computationally expensive things that happen often.

00:23:09.380 --> 00:23:17.420
And in general, Pydantic version 2 is about 17 times 1,700% faster than V1 when validating

00:23:17.420 --> 00:23:19.700
models in a standard scenario.

00:23:19.700 --> 00:23:22.900
It says between 4 to 50 times faster than Pydantic 1.

00:23:22.900 --> 00:23:23.400
Hmm.

00:23:23.400 --> 00:23:23.940
Wow.

00:23:24.040 --> 00:23:24.600
That's cool, right?

00:23:24.600 --> 00:23:25.240
Yeah.

00:23:25.240 --> 00:23:30.680
That alone should make your ears perk up and go, excuse me, my ORM just got 17 times faster.

00:23:30.680 --> 00:23:31.580
Wait a minute.

00:23:31.580 --> 00:23:32.620
I'm liking this.

00:23:32.620 --> 00:23:37.840
I know that this is not the only thing that happens at ORM level, but the ones that, the

00:23:37.840 --> 00:23:41.960
ones I called out that depend heavily on it, like that's in the transformation path.

00:23:41.960 --> 00:23:42.680
So this is important.

00:23:42.680 --> 00:23:43.100
Yeah.

00:23:43.100 --> 00:23:45.920
This is actually, I'm super impressed.

00:23:46.040 --> 00:23:51.780
I have not, I normally don't even see this sort of advanced planning in commercial projects.

00:23:51.780 --> 00:23:52.720
Yes.

00:23:52.720 --> 00:23:53.320
Oh yeah.

00:23:53.320 --> 00:23:57.400
You could do a whole business startup that doesn't have the amount of thought that went

00:23:57.400 --> 00:24:00.160
into like what's happening in the next version of Pydantic.

00:24:00.160 --> 00:24:00.880
It's ridiculous.

00:24:00.880 --> 00:24:01.740
Yeah.

00:24:01.740 --> 00:24:02.840
It's incredible.

00:24:02.840 --> 00:24:04.540
I mean, I was serious when I said take a bow.

00:24:04.540 --> 00:24:09.740
It really lays out, opens a discussion about certain things and so on.

00:24:09.740 --> 00:24:11.140
So like another one is strict mode.

00:24:11.140 --> 00:24:14.400
I think I even saw a comment in the chat about it.

00:24:14.740 --> 00:24:19.440
So one of the things I actually like about Pydantic, but under certain circumstances,

00:24:19.440 --> 00:24:23.500
I can see why you would not want it is if you have something you say is an integer field

00:24:23.500 --> 00:24:26.120
and then you pass one, two, three, the number rate.

00:24:26.120 --> 00:24:31.020
But if you also pass quote one, two, three, Pydantic will magically parse that for you.

00:24:31.020 --> 00:24:32.640
Like this happens all the time on the internet.

00:24:32.640 --> 00:24:35.580
Like a query string has a number, but query strings are always strings.

00:24:35.580 --> 00:24:37.740
There's no way to have anything but strings.

00:24:37.740 --> 00:24:38.240
Yeah.

00:24:38.240 --> 00:24:39.320
So you got to convert them.

00:24:39.320 --> 00:24:39.500
Right.

00:24:39.500 --> 00:24:41.240
So this automatically does that.

00:24:41.240 --> 00:24:44.420
But if you don't want that to happen, you say, you gave me a string.

00:24:44.440 --> 00:24:45.080
It's invalid.

00:24:45.080 --> 00:24:48.000
You can turn on strict mode, which is off by default, I believe.

00:24:48.000 --> 00:24:49.340
There's also a bunch of plain.

00:24:49.340 --> 00:24:49.820
Go ahead.

00:24:49.820 --> 00:24:53.140
So strict mode does the conversion or strict mode?

00:24:53.140 --> 00:24:54.760
Strict mode won't do the conversion.

00:24:54.760 --> 00:24:56.420
It says, you said it's an int.

00:24:56.420 --> 00:24:57.140
You gave me a string.

00:24:57.140 --> 00:24:57.960
Nope.

00:24:57.960 --> 00:25:00.140
Rather than, could it be an integer?

00:25:00.140 --> 00:25:01.580
Let's try that first.

00:25:01.580 --> 00:25:02.380
You know what I mean?

00:25:02.380 --> 00:25:03.080
Yeah.

00:25:03.140 --> 00:25:11.700
Maybe one of the things you do is, in the ORM level, one of those things, you might put it in strict mode so it doesn't do as much work trying to convert stuff.

00:25:11.700 --> 00:25:12.880
I don't know if that actually would matter.

00:25:12.880 --> 00:25:14.780
But formalizes a bunch of conversions.

00:25:15.300 --> 00:25:18.760
It has built-in JSON support and different things.

00:25:18.760 --> 00:25:26.960
Another big thing is this Pydantic core will be able to be used outside of Pydantic classes now.

00:25:27.400 --> 00:25:39.260
So you can do a significant performance to improve stuff like adding validation to data classes or validating arguments and query strings or a type dick or a function argument or whatever.

00:25:39.260 --> 00:25:39.860
Yeah.

00:25:39.860 --> 00:25:40.600
Yeah.

00:25:40.600 --> 00:25:41.680
Let's see.

00:25:41.680 --> 00:25:42.660
Next up.

00:25:42.660 --> 00:25:44.480
And let's see.

00:25:44.480 --> 00:25:45.340
This one.

00:25:45.340 --> 00:25:46.080
Strict mode.

00:25:46.080 --> 00:25:47.360
We talked about strict mode.

00:25:47.360 --> 00:25:50.040
Another one is required versus nullable.

00:25:50.040 --> 00:25:56.400
There's a little bit of ambiguity of, you know, if you said something's a string, that means it's required and it can't be none.

00:25:56.740 --> 00:26:06.180
If you say it's a string type none or it's an optional string or something like that, then basically the behaviors were a little bit different.

00:26:06.180 --> 00:26:09.980
So originally, I think this is when typing was pretty new.

00:26:09.980 --> 00:26:14.460
It said Pydantic previously had a confused idea of required versus nullable.

00:26:14.460 --> 00:26:24.680
This mostly resulted from Sam's misgivings about marking a field as optional but requiring a value to be provided to it but allowing it to be set to none or something along those lines.

00:26:25.680 --> 00:26:28.460
Anyway, there's minor changes around that.

00:26:28.460 --> 00:26:29.440
Let's see.

00:26:29.440 --> 00:26:32.060
Final one that I want to cover is namespace stuff.

00:26:32.060 --> 00:26:35.740
And this is like a whole bunch of things are now getting renamed.

00:26:36.000 --> 00:26:43.380
So for example, if you override, if you implemented or overrode validate JSON, it's now model underscore validate JSON.

00:26:43.380 --> 00:26:45.900
If you had is instance, it's now model is instance.

00:26:45.900 --> 00:26:46.520
Okay.

00:26:46.520 --> 00:26:48.380
There's a bunch of these changes all over the place.

00:26:48.380 --> 00:26:48.920
Yeah.

00:26:48.920 --> 00:26:51.140
That look like they're going to cause breaking changes.

00:26:51.140 --> 00:26:51.940
They're easy to fix.

00:26:51.940 --> 00:26:52.720
Just change the name.

00:26:52.720 --> 00:26:54.300
But, you know, it's not nothing.

00:26:54.740 --> 00:26:56.180
Also, parse file.

00:26:56.180 --> 00:26:59.040
I still love his hander here.

00:26:59.040 --> 00:27:00.040
Pars file.

00:27:00.040 --> 00:27:01.200
This was a mistake.

00:27:01.200 --> 00:27:02.700
It should have never been in Pydantic.

00:27:02.700 --> 00:27:03.640
We're removing it.

00:27:03.640 --> 00:27:04.100
Okay.

00:27:04.100 --> 00:27:04.500
Pars raw.

00:27:04.500 --> 00:27:07.680
Partially replaced by this other thing.

00:27:07.680 --> 00:27:09.160
Anything else it did was a mistake.

00:27:09.160 --> 00:27:11.680
From ORM, this has been moved somewhere else.

00:27:11.680 --> 00:27:13.040
Schema and so on.

00:27:13.040 --> 00:27:15.380
So you just, like, there's a lot of stuff that people are using here.

00:27:15.380 --> 00:27:16.800
So just have a look.

00:27:16.800 --> 00:27:17.520
Try it out.

00:27:17.520 --> 00:27:19.260
Don't just go, oh, then version 2 is out.

00:27:19.260 --> 00:27:19.900
Is this going to work?

00:27:19.980 --> 00:27:21.780
Like, this is going to have some significant changes.

00:27:21.780 --> 00:27:27.400
And another reason why it's really awesome that he goes through so much detail is because

00:27:27.400 --> 00:27:29.960
there's going to be stuff that breaks.

00:27:29.960 --> 00:27:32.920
So it's a breaking interface change.

00:27:32.920 --> 00:27:36.400
And so, yeah, it's cool that it's this detailed.

00:27:36.400 --> 00:27:38.360
And a couple things to notice.

00:27:38.360 --> 00:27:40.480
Let's see.

00:27:40.480 --> 00:27:42.680
Somebody else in the chat mentioned.

00:27:42.680 --> 00:27:44.200
Richard mentioned.

00:27:44.200 --> 00:27:46.380
And he has emojis in the headers.

00:27:46.380 --> 00:27:48.300
Yeah, there's emojis in the headers.

00:27:48.500 --> 00:27:54.740
And I got to say, like, the navigation in the table of contents, very cool.

00:27:54.740 --> 00:27:59.040
It goes to, like, light gray for areas you've already seen.

00:27:59.040 --> 00:27:59.480
And then.

00:27:59.480 --> 00:28:00.620
Oh, that's interesting.

00:28:00.620 --> 00:28:01.760
It's a cool thing.

00:28:01.760 --> 00:28:03.460
Yeah, it's quite cool.

00:28:03.460 --> 00:28:05.340
I think it went on and on.

00:28:05.340 --> 00:28:06.460
But two real quick things.

00:28:06.460 --> 00:28:10.640
One, there'll be no pure Python implementation of the core.

00:28:10.640 --> 00:28:11.560
It's always Rust.

00:28:11.560 --> 00:28:15.200
But they list out the platforms where it'll be compiled to, including WebAssembly.

00:28:15.200 --> 00:28:16.260
Oh, nice.

00:28:16.780 --> 00:28:22.080
They previously had some Cython in what was supposed to be pure Python's Pydantic.

00:28:22.080 --> 00:28:30.660
And so now a kind of bonus is the Pydantic model, the Pydantic package, becomes a pure Python package, whereas previously it wasn't.

00:28:30.660 --> 00:28:35.420
So they've taken, like, all of that behavior and put it under this core thing that ships as a Rust binary.

00:28:35.420 --> 00:28:40.000
And now instead of doing some Cython middle ground, it's pure Python again.

00:28:40.000 --> 00:28:42.460
So that's interesting refactoring, I think.

00:28:42.460 --> 00:28:43.060
Yeah.

00:28:43.060 --> 00:28:43.740
Yeah.

00:28:43.740 --> 00:28:43.940
Yeah.

00:28:43.940 --> 00:28:45.540
And finally, documentation.

00:28:45.540 --> 00:28:52.020
When you get a validation error, it gives you a link to the documentation in the JSON error message.

00:28:52.020 --> 00:28:53.260
That's pretty cool.

00:28:53.260 --> 00:28:54.260
Yeah.

00:28:54.260 --> 00:28:55.100
That's nice.

00:28:55.100 --> 00:28:56.040
All right.

00:28:56.220 --> 00:28:56.440
Yeah.

00:28:56.440 --> 00:28:58.340
Anyway, that's quite a plan, isn't it, Brian?

00:28:58.340 --> 00:28:58.940
Yeah.

00:28:58.940 --> 00:28:59.820
Quite a plan.

00:28:59.820 --> 00:29:00.300
All right.

00:29:00.300 --> 00:29:01.940
Well, I'm excited for it.

00:29:01.940 --> 00:29:03.280
Okay.

00:29:03.280 --> 00:29:07.680
Well, next topic is a little more lighthearted.

00:29:07.680 --> 00:29:09.200
It's about fish.

00:29:09.200 --> 00:29:12.540
Pike, to be specific.

00:29:12.540 --> 00:29:14.920
No, it's about PDFs.

00:29:15.140 --> 00:29:19.560
So it's just a cool project I noticed.

00:29:19.560 --> 00:29:20.820
Pike PDF.

00:29:20.820 --> 00:29:24.180
It's a Python library for reading and writing PDF files.

00:29:24.180 --> 00:29:25.280
What's the big deal?

00:29:25.280 --> 00:29:26.340
We've had these before.

00:29:26.340 --> 00:29:33.060
But this is, it's based on QPDF, which is a C++-based library.

00:29:33.060 --> 00:29:38.000
And it's presently continued being maintained.

00:29:38.000 --> 00:29:41.060
So it's kind of pretty fast.

00:29:41.060 --> 00:29:44.540
Well, actually, I'm assuming it's fast if it's C++ in the background.

00:29:44.540 --> 00:29:44.580
Yeah.

00:29:44.580 --> 00:29:51.980
But it's also pretty just nice and elegant to do things.

00:29:51.980 --> 00:29:56.020
And the documentation has this nice fish, which is good.

00:29:56.020 --> 00:29:59.460
I always like cool diagrams, cool logos.

00:29:59.460 --> 00:30:03.740
But some of the neat things that you can do with it.

00:30:03.740 --> 00:30:08.480
So it's recommending that you not use it if you're just writing PDF files.

00:30:08.480 --> 00:30:11.980
That there's other things that you can use.

00:30:12.120 --> 00:30:12.440
What was it?

00:30:12.440 --> 00:30:14.680
Like Report Lab to write PDFs.

00:30:14.680 --> 00:30:19.300
But if you're having to read or modify PDFs, then this is where it shines.

00:30:19.300 --> 00:30:22.780
You can do things like copy pages from one PDF to another.

00:30:22.780 --> 00:30:24.800
Split and merge PDFs.

00:30:24.800 --> 00:30:27.500
Extract content out of PDFs.

00:30:27.500 --> 00:30:30.920
Like if you're using it for data stuff.

00:30:30.920 --> 00:30:34.880
You get a report in PDF and you're trying to pull the information out.

00:30:34.880 --> 00:30:37.000
You can use it for that.

00:30:37.000 --> 00:30:37.580
Or images.

00:30:37.680 --> 00:30:39.600
You can pull all the images out of a PDF file.

00:30:39.600 --> 00:30:41.120
Or this is kind of cool.

00:30:41.120 --> 00:30:47.220
You can replace images in a PDF file and generate a new one without changing anything else about the file.

00:30:47.220 --> 00:30:48.900
It's kind of neat.

00:30:48.900 --> 00:30:56.760
So just kind of a neat, if people are working with reading or modifying PDF files, maybe check this one out.

00:30:57.020 --> 00:30:57.860
Yeah, this looks great.

00:30:57.860 --> 00:31:01.980
The fact that it's in C++, I'm guessing it's probably standalone.

00:31:01.980 --> 00:31:08.540
I remember I've done some PDF things before and it felt like I had to install some OS level thing that it shelled out to.

00:31:08.540 --> 00:31:09.280
So this is cool.

00:31:09.620 --> 00:31:19.820
Nice on the ReadMe, it has a comparison of some of the different PDF libraries that you could use.

00:31:19.820 --> 00:31:24.320
And some of the reasons why you might want this one, like it supports more versions.

00:31:24.320 --> 00:31:31.720
I didn't realize that one of these libraries I've heard of before, PDF-RW, doesn't support the newer versions.

00:31:31.720 --> 00:31:32.700
So bummer.

00:31:33.400 --> 00:31:39.100
And then also password-protected files, it supports that.

00:31:39.100 --> 00:31:42.900
Except for, but not public key ones, but just normal passwords.

00:31:42.900 --> 00:31:44.120
Straight passwords, yeah.

00:31:44.120 --> 00:31:44.480
Yeah.

00:31:44.480 --> 00:31:44.900
That's great.

00:31:44.900 --> 00:31:45.720
So it's kind of neat.

00:31:45.720 --> 00:31:52.420
Also like the measure of actively maintained, the commit activity per year over the year or something like that.

00:31:52.420 --> 00:31:53.120
Oh, right.

00:31:53.120 --> 00:31:54.220
That's kind of interesting.

00:31:54.220 --> 00:31:55.680
Yeah, it's an interesting metric.

00:31:55.680 --> 00:31:56.620
It seems good.

00:31:56.620 --> 00:31:58.240
I haven't really thought about it lately, but.

00:31:58.240 --> 00:31:58.680
Yeah.

00:31:58.680 --> 00:31:59.220
Yeah.

00:31:59.220 --> 00:31:59.800
Nice.

00:31:59.800 --> 00:32:01.140
All right, yeah, this is a great one.

00:32:01.740 --> 00:32:04.700
Well, so that's it for our main items.

00:32:04.700 --> 00:32:06.220
Yeah, what else you got?

00:32:06.220 --> 00:32:07.100
Any extras?

00:32:07.100 --> 00:32:13.100
Well, last week, we talked about the critical packages.

00:32:13.100 --> 00:32:14.060
Critical packages.

00:32:14.060 --> 00:32:16.080
Or at some recent.

00:32:16.080 --> 00:32:20.320
Yeah, last week, we talked about critical packages.

00:32:20.320 --> 00:32:23.440
Either yesterday or last week, depending on how you consume this material.

00:32:23.440 --> 00:32:23.500
Exactly.

00:32:23.500 --> 00:32:24.480
Yeah.

00:32:24.800 --> 00:32:31.440
So I was surprised to find out that pytestCheck, the plugin I wrote, was one of those.

00:32:31.440 --> 00:32:32.260
I'm like, really?

00:32:32.260 --> 00:32:34.620
Because it's like the top 1%.

00:32:34.620 --> 00:32:39.180
So if anybody's curious, I wanted to just highlight that a little bit.

00:32:39.180 --> 00:32:43.200
So pytestCheck is a plugin that allows multiple failures per test.

00:32:44.020 --> 00:32:49.920
And one of the best ways, it's a secondary way that one of the contributors added, is you

00:32:49.920 --> 00:32:51.380
can use it as a context manager.

00:32:51.380 --> 00:32:54.100
You can say, like, with check, and then do an assert.

00:32:54.100 --> 00:32:56.260
And then you're going to have multiple of those within a.

00:32:56.260 --> 00:32:57.640
I like the one-liner even.

00:32:57.640 --> 00:32:58.720
That's pretty nice.

00:32:58.720 --> 00:32:59.080
Yeah.

00:32:59.080 --> 00:33:03.460
And this is totally, like, black will totally reformat this if you ran it through black.

00:33:03.460 --> 00:33:04.820
But it's nice.

00:33:04.820 --> 00:33:06.120
You'd have to block it out.

00:33:06.240 --> 00:33:09.500
Anyway, I was like, how could it be?

00:33:09.500 --> 00:33:13.120
Well, I'm curious what on the list it was.

00:33:13.120 --> 00:33:18.940
So there's a place called, what, HugoVK.

00:33:18.940 --> 00:33:22.360
Has a top PyPI packages list.

00:33:22.360 --> 00:33:23.320
And it's updated.

00:33:23.320 --> 00:33:25.260
I think it's just updated once a month or something.

00:33:25.260 --> 00:33:27.260
But you can do the top 5.

00:33:27.260 --> 00:33:29.440
You can do the top 5,000.

00:33:29.440 --> 00:33:32.500
Yeah, it's the top 5,000 or 1,000 or 100.

00:33:33.440 --> 00:33:38.020
And so I was curious about where on the list I was.

00:33:38.020 --> 00:33:41.140
I'm number 1,677.

00:33:41.140 --> 00:33:43.140
So kind of far down the list.

00:33:43.140 --> 00:33:45.220
But hey, we're just talking.

00:33:45.220 --> 00:33:47.940
It's still in the top third of the top 1%.

00:33:47.940 --> 00:33:48.680
That's pretty awesome.

00:33:48.680 --> 00:33:51.380
The pytest is number 72.

00:33:51.380 --> 00:33:52.560
That was pretty neat.

00:33:52.560 --> 00:33:57.440
And Pydantic, which we covered, was, I just checked, 117.

00:33:57.440 --> 00:34:03.100
But there are 57 pytest plugins that show up in the top 3,500.

00:34:03.520 --> 00:34:04.400
So that's pretty neat.

00:34:04.400 --> 00:34:04.520
Wow.

00:34:04.520 --> 00:34:05.000
Pretty neat.

00:34:05.000 --> 00:34:05.960
That is pretty neat.

00:34:05.960 --> 00:34:07.620
That's all I got for extras.

00:34:07.620 --> 00:34:08.640
All right.

00:34:08.640 --> 00:34:09.920
Well, I have zero extras.

00:34:09.920 --> 00:34:11.420
So mine are finished as well.

00:34:11.420 --> 00:34:12.340
How about a joke?

00:34:12.340 --> 00:34:12.960
Yeah.

00:34:12.960 --> 00:34:13.500
Great.

00:34:13.500 --> 00:34:14.000
All right.

00:34:14.000 --> 00:34:15.460
I told you we're coming back to it.

00:34:15.460 --> 00:34:17.100
So this one comes from Netta.

00:34:17.100 --> 00:34:21.740
Netta Code Girl at Netta.mk.

00:34:21.740 --> 00:34:24.260
And let me just pull this one up here.

00:34:24.260 --> 00:34:24.440
Right.

00:34:24.500 --> 00:34:28.640
So this one is, there's this colleague here.

00:34:28.640 --> 00:34:29.240
Can I make this?

00:34:29.240 --> 00:34:29.620
There we go.

00:34:29.620 --> 00:34:30.080
Make it a little bigger.

00:34:30.080 --> 00:34:37.160
There's the two women who are developers, Netta and her unnamed friend who always has gotten

00:34:37.160 --> 00:34:38.980
in trouble with the elevator last time, basically.

00:34:39.320 --> 00:34:44.620
And there's this sort of weird manager looking guy that comes in and says, I tested your

00:34:44.620 --> 00:34:47.540
chat bot, but some of its replies are really messed up.

00:34:47.540 --> 00:34:50.040
Well, that's what testing is all about.

00:34:50.040 --> 00:34:52.620
I'll go through the logs later, says one of the girls.

00:34:52.620 --> 00:34:53.380
No, no, no.

00:34:53.380 --> 00:34:54.160
No, no, no.

00:34:54.160 --> 00:34:54.660
No, no.

00:34:54.660 --> 00:34:55.160
No need.

00:34:55.160 --> 00:34:56.520
Right.

00:34:56.520 --> 00:34:57.500
Check out the faces.

00:34:57.500 --> 00:34:59.160
She's like, excuse me.

00:34:59.160 --> 00:35:02.020
I'm not even sure I want to open the logs now.

00:35:02.020 --> 00:35:02.580
Yeah.

00:35:02.580 --> 00:35:02.920
Yeah.

00:35:02.920 --> 00:35:04.160
Don't look at the logs.

00:35:04.880 --> 00:35:06.000
That's what testing's for.

00:35:06.000 --> 00:35:08.660
I'll go through the logs later.

00:35:08.660 --> 00:35:13.940
Well, yeah, she's got some good ones in her list there.

00:35:13.940 --> 00:35:14.900
So love it.

00:35:14.900 --> 00:35:15.340
Yeah.

00:35:15.340 --> 00:35:16.680
I like the art too.

00:35:16.680 --> 00:35:17.940
Nice art.

00:35:17.940 --> 00:35:18.360
I do too.

00:35:18.360 --> 00:35:19.020
It is.

00:35:19.020 --> 00:35:21.120
So also nice was our podcast.

00:35:21.120 --> 00:35:22.020
Thanks for being here.

00:35:22.020 --> 00:35:22.780
Thank you.

00:35:22.780 --> 00:35:23.300
Yeah.

00:35:23.300 --> 00:35:23.680
You bet.

00:35:23.680 --> 00:35:24.700
See you next week.

