
00:00:00.000 --> 00:00:03.260
I am pulling off a very, very cool trick.


00:00:03.260 --> 00:00:05.060
I just want to point out before we get started.


00:00:05.060 --> 00:00:05.660
>> Okay.


00:00:05.660 --> 00:00:07.300
>> On the Talk Python channel,


00:00:07.300 --> 00:00:10.140
I'm doing a podcast with Anthony Shaw and Shane from


00:00:10.140 --> 00:00:15.220
Microsoft about Azure and Python and some CLI stuff they built in FastAPI.


00:00:15.220 --> 00:00:16.740
At the exact same time,


00:00:16.740 --> 00:00:19.580
I'm doing this one here and they're both streaming live.


00:00:19.580 --> 00:00:22.380
>> I don't know how that's happening.


00:00:22.380 --> 00:00:25.200
>> The other one was recorded two months ago


00:00:25.200 --> 00:00:27.940
and we couldn't release it because some of the things weren't finished yet.


00:00:27.940 --> 00:00:29.540
So I hit go on that.


00:00:29.540 --> 00:00:32.820
The real one, if you're bouncing around, the real one is here.


00:00:32.820 --> 00:00:33.140
>> Okay.


00:00:33.140 --> 00:00:36.820
>> So, Jonah's here. Anyway, with that, you're ready to start a podcast?


00:00:36.820 --> 00:00:37.780
>> Yeah, definitely.


00:00:37.780 --> 00:00:42.020
>> Hello, and welcome to Python Bytes, where we deliver Python news and headlines directly


00:00:42.020 --> 00:00:48.260
to your earbuds. This is episode 294, recorded July 12th, 2022. I'm Michael Kennedy.


00:00:48.260 --> 00:00:51.460
>> And I am Brian Okken. It's just us this weekend, or this-


00:00:51.460 --> 00:00:52.180
>> It's just us.


00:00:52.180 --> 00:00:52.660
>> Yeah.


00:00:52.660 --> 00:00:58.660
>> Yeah, it's, I don't know. Dean of the audience asks, is this a daily podcast show now?


00:00:58.660 --> 00:01:08.460
I'm a little bit torn about I feel like we almost could do a daily show, but then I think what it might take to do a daily show knowing how much work a weekly show is.


00:01:08.460 --> 00:01:09.760
I know it's not a day.


00:01:09.760 --> 00:01:10.660
It's not a daily pocket.


00:01:10.660 --> 00:01:12.760
No, might be fun to do sometime.


00:01:12.760 --> 00:01:14.560
Just do like a full week or something.


00:01:14.560 --> 00:01:15.260
Just right.


00:01:15.260 --> 00:01:15.760
Exactly.


00:01:15.760 --> 00:01:17.660
Just a super this.


00:01:17.660 --> 00:01:18.460
There's so much news.


00:01:18.460 --> 00:01:20.260
We're seeing every day for the week.


00:01:20.260 --> 00:01:20.760
Cool.


00:01:20.760 --> 00:01:23.660
Just like the same topics like six days in a row.


00:01:23.660 --> 00:01:24.060
Over.


00:01:24.060 --> 00:01:25.360
Yeah.


00:01:25.360 --> 00:01:27.660
Exactly.


00:01:27.660 --> 00:01:28.360
Exactly.


00:01:28.360 --> 00:01:30.640
>> All right. Am I up first this week?


00:01:30.640 --> 00:01:32.160
>> You are. Yes.


00:01:32.160 --> 00:01:37.400
>> Right on. Well, let me tell you about something special, specialist.


00:01:37.400 --> 00:01:37.960
>> Okay.


00:01:37.960 --> 00:01:40.040
>> Just last week, I believe it was,


00:01:40.040 --> 00:01:45.160
I interviewed Alex Waygood who did the write-up for the Python Language Summit.


00:01:45.160 --> 00:01:47.880
As part of the topics we were discovering,


00:01:47.880 --> 00:01:50.960
the Python Language Summit and Python this year is focusing a lot on


00:01:50.960 --> 00:01:54.240
performance and what's called the Shannon plan.


00:01:54.240 --> 00:01:57.200
So this is Mark Shannon's plan to make Python


00:01:57.200 --> 00:01:59.440
five times faster over five releases.


00:01:59.440 --> 00:02:02.040
It's got a ton of support at Microsoft.


00:02:02.040 --> 00:02:03.760
Hito van Rossum's there working on it,


00:02:03.760 --> 00:02:06.640
but they've hired like five or six other people


00:02:06.640 --> 00:02:08.960
who are full-time working on making Python faster now.


00:02:08.960 --> 00:02:10.440
So awesome, awesome.


00:02:10.440 --> 00:02:11.360
Thank you for that.


00:02:11.360 --> 00:02:16.120
However, one of the things that made Python 3.11 fast


00:02:16.120 --> 00:02:18.240
is some of the early work they did.


00:02:18.240 --> 00:02:22.560
And it comes down to PEP 659,


00:02:22.560 --> 00:02:24.880
a specializing adaptive interpreter.


00:02:24.880 --> 00:02:27.400
So let me tell you about this feature,


00:02:27.400 --> 00:02:30.000
this performance improvement first,


00:02:30.000 --> 00:02:32.040
and then we'll see what specialist is about,


00:02:32.040 --> 00:02:33.160
'cause it's about understanding


00:02:33.160 --> 00:02:35.640
and visualizing this behavior.


00:02:35.640 --> 00:02:40.280
So one of the things that is a problem with Python,


00:02:40.280 --> 00:02:43.040
because it's dynamic and its types can change


00:02:43.040 --> 00:02:44.760
and what can be passed could vary.


00:02:44.760 --> 00:02:46.320
I mean, you could have type hints,


00:02:46.320 --> 00:02:48.400
but you can violate the type hints all day long


00:02:48.400 --> 00:02:49.260
and it's fine.


00:02:49.260 --> 00:02:51.680
So what the interpreter has to do is say,


00:02:51.680 --> 00:02:55.080
well, we're going to do all of our operations super general.


00:02:55.080 --> 00:03:00.000
So if I have a function and it's called add and it takes X and Y and it returns X plus Y,


00:03:00.000 --> 00:03:03.200
seems easy, but is that string addition?


00:03:03.200 --> 00:03:05.680
Is that numerical addition?


00:03:05.680 --> 00:03:12.400
Is that some custom operator overloading with a dunder add or whatever it is in some type?


00:03:12.400 --> 00:03:14.200
If it fails in one way, you kind of got to reverse it.


00:03:14.200 --> 00:03:15.880
Like there's all this unknown, right?


00:03:15.880 --> 00:03:16.320
>> Yeah.


00:03:16.320 --> 00:03:17.560
>> What if you knew?


00:03:17.560 --> 00:03:21.480
What if you knew those were integers and not classes


00:03:21.480 --> 00:03:22.600
or not strings?


00:03:22.600 --> 00:03:24.440
You could run different code.


00:03:24.440 --> 00:03:26.440
You wouldn't have to first figure out what they are.


00:03:26.440 --> 00:03:27.640
Are they compatible?


00:03:27.640 --> 00:03:32.520
Do you do the add in low level CPython internals


00:03:32.520 --> 00:03:34.760
or do you go to like some Python class and do it?


00:03:34.760 --> 00:03:37.160
You could be much more focused.


00:03:37.160 --> 00:03:39.280
Additionally, if it was adding for a list,


00:03:39.280 --> 00:03:41.280
you could say, well, if I know their list,


00:03:41.280 --> 00:03:44.360
what we just do is go list.extend


00:03:44.360 --> 00:03:46.000
and we give it the other list.


00:03:46.000 --> 00:03:48.320
we don't hunt around and figure out all this other stuff.


00:03:48.320 --> 00:03:52.380
So that's the general idea of the specializing interpreter


00:03:52.380 --> 00:03:53.820
is it goes through and it says,


00:03:53.820 --> 00:03:57.680
look, we don't know for sure what could be passed here,


00:03:57.680 --> 00:04:00.380
but if it looks like over and over,


00:04:00.380 --> 00:04:03.740
we're running the same code and it's always the same types,


00:04:03.740 --> 00:04:07.980
is there a way we could specialize those types?


00:04:07.980 --> 00:04:10.700
Is there a way that we could put specific code


00:04:10.700 --> 00:04:14.580
for adding numbers or specific code for combining lists?


00:04:14.580 --> 00:04:19.580
And this is called adaptive and speculative specialization.


00:04:19.580 --> 00:04:20.420
Okay?


00:04:20.420 --> 00:04:21.560
- Okay.


00:04:21.560 --> 00:04:24.140
- And my favorite part of it when it's performed,


00:04:24.140 --> 00:04:25.880
it's called the quickening.


00:04:25.880 --> 00:04:29.780
Quickening is the process of replacing slow instructions


00:04:29.780 --> 00:04:31.460
with faster variants.


00:04:31.460 --> 00:04:32.340
So kind of like I said,


00:04:32.340 --> 00:04:35.460
it has some advantages over immutable bytecode.


00:04:35.460 --> 00:04:36.860
It can be changed at runtime.


00:04:36.860 --> 00:04:39.540
Like you see, we're always adding integers.


00:04:39.540 --> 00:04:41.900
It can use super instructions that span lines


00:04:41.900 --> 00:04:43.900
or take multiple operands.


00:04:43.900 --> 00:04:46.160
and it does not need to handle tracing


00:04:46.160 --> 00:04:49.560
as it can fall back to the original byte code for that.


00:04:49.560 --> 00:04:51.660
So there's a whole bunch of stuff going on here.


00:04:51.660 --> 00:04:53.900
Like the example they give is


00:04:53.900 --> 00:04:56.460
you might wanna specialize load adder.


00:04:56.460 --> 00:04:58.220
So load adder is a way to say,


00:04:58.220 --> 00:05:00.760
give me the value that this thing contains,


00:05:00.760 --> 00:05:02.020
but what is the thing?


00:05:02.020 --> 00:05:03.660
One of the things you might do


00:05:03.660 --> 00:05:06.180
is you might realize it's a instance class


00:05:06.180 --> 00:05:09.740
and then you would call load adder instance value.


00:05:09.740 --> 00:05:11.400
You might realize it's a module


00:05:11.400 --> 00:05:13.180
and you might call load adder module


00:05:13.180 --> 00:05:14.840
or slot or so on, right?


00:05:14.840 --> 00:05:17.020
But if you knew, you don't have to go through first


00:05:17.020 --> 00:05:20.180
the abstract step and then figure out which of these it is.


00:05:20.180 --> 00:05:21.940
You just do the thing that it is.


00:05:21.940 --> 00:05:24.680
Okay, so that's the idea of this pep.


00:05:24.680 --> 00:05:28.160
This is one of the things that's making Python 3.11 faster.


00:05:28.160 --> 00:05:30.700
Awesome, so to the main topic.


00:05:30.700 --> 00:05:33.020
- Okay, and I'll just as a note,


00:05:33.020 --> 00:05:35.660
I'm saying okay as if I understand what you just said,


00:05:35.660 --> 00:05:37.980
but most of it just went.


00:05:37.980 --> 00:05:40.100
- It's all right, I think we'll, let's look at pictures.


00:05:40.100 --> 00:05:40.940
- Okay.


00:05:40.940 --> 00:05:44.040
So this thing by Brant Boucher,


00:05:44.040 --> 00:05:46.340
it's called Specialist,


00:05:46.340 --> 00:05:50.340
and it's about visualizing this specializing adaptive interpreter.


00:05:50.340 --> 00:05:51.540
Oh, okay, good.


00:05:51.540 --> 00:05:52.540
Okay.


00:05:52.540 --> 00:05:56.040
So, it says Specialist uses fine-grained location information


00:05:56.040 --> 00:05:59.240
to create visual representations of exactly where and how


00:05:59.240 --> 00:06:04.840
CPython 3.11's new specializing adaptive interpreter optimizes your code.


00:06:04.840 --> 00:06:07.040
And it's not just interesting,


00:06:07.040 --> 00:06:08.840
it has actionable information.


00:06:08.840 --> 00:06:09.640
Okay.


00:06:09.640 --> 00:06:15.480
So for example, see here, and if you got to pull up this, the website, if you're just listening,


00:06:15.480 --> 00:06:18.040
if you see in that website, you'll see some color.


00:06:18.040 --> 00:06:23.640
You'll see green, less green, yellow, orange, and all the way to red.


00:06:23.640 --> 00:06:27.480
So there's two aspects, there's sort of a darkness as well as a color.


00:06:27.480 --> 00:06:32.160
So the most, like where Python could take advantage of this feature,


00:06:32.160 --> 00:06:35.160
you see green, where it can't, you see red.


00:06:35.160 --> 00:06:40.960
and imagine a spectrum it goes like green, yellow, orange, red.


00:06:40.960 --> 00:06:42.240
So it's not on or off,


00:06:42.240 --> 00:06:44.320
it's how much could it specialize.


00:06:44.320 --> 00:06:46.280
So what you see here, for example,


00:06:46.280 --> 00:06:49.640
is it's able to take some numbers,


00:06:49.640 --> 00:06:53.120
an integer and a string,


00:06:53.120 --> 00:06:57.480
and then use the fact that it knows what those are to make certain things like


00:06:57.480 --> 00:07:02.720
appending an output and doing some character operations on it.


00:07:02.720 --> 00:07:05.720
Right. It was able to replace that with a different runtime behavior


00:07:05.720 --> 00:07:07.220
because of this quickening.


00:07:07.220 --> 00:07:10.720
So let's skip down here, give you a bit of the background.


00:07:10.720 --> 00:07:13.220
So let's look at this example. We have F to C,


00:07:13.220 --> 00:07:16.220
which converts Fahrenheit to Celsius.


00:07:16.220 --> 00:07:19.020
And what it does is, okay, we're going to take an F,


00:07:19.020 --> 00:07:21.020
and it has type hints that say float, float.


00:07:21.020 --> 00:07:23.020
Okay, so, but those don't matter.


00:07:23.020 --> 00:07:26.720
So it says, we're going to take an F and subtract 32 from it.


00:07:26.720 --> 00:07:28.720
And then we're going to do simple math.


00:07:28.720 --> 00:07:30.720
We're going to take that result, that range,


00:07:30.720 --> 00:07:34.400
to that size of temperature there based on zero


00:07:34.400 --> 00:07:36.600
and then multiply it by five and divide it by nine.


00:07:36.600 --> 00:07:39.520
We all learned this in chemistry class or somewhere


00:07:39.520 --> 00:07:43.200
or we talked about converting different measurement.


00:07:43.200 --> 00:07:44.440
- Yeah, of course.


00:07:44.440 --> 00:07:46.840
- Right, so these are straightforward


00:07:46.840 --> 00:07:49.820
but there's actually problems in here that make it slower


00:07:49.820 --> 00:07:52.960
and prohibit Python from quickening it


00:07:52.960 --> 00:07:55.680
as much as it can be quickened, okay?


00:07:55.680 --> 00:07:58.920
So if we take this code, it just runs F to C and C to F


00:07:58.920 --> 00:08:00.120
and it gives us some test values


00:08:00.120 --> 00:08:02.240
and says just do it and tell us what happened.


00:08:02.240 --> 00:08:04.280
We can run specialists on it and it says,


00:08:04.280 --> 00:08:05.960
okay, this X here,


00:08:05.960 --> 00:08:08.480
the green areas indicate regions of code that were


00:08:08.480 --> 00:08:13.240
successfully specialized where red areas are unsuccessful.


00:08:13.240 --> 00:08:14.800
Like it tried and it failed.


00:08:14.800 --> 00:08:16.720
So it says one of the problems is,


00:08:16.720 --> 00:08:20.520
start out the X equals F minus 32.


00:08:20.520 --> 00:08:23.840
It says, well, we can quicken operations


00:08:23.840 --> 00:08:25.520
on numerical types that are the same,


00:08:25.520 --> 00:08:29.680
but for now there's not a float int and float variant of this.


00:08:29.680 --> 00:08:30.880
It's gotta be float float.


00:08:30.880 --> 00:08:31.380
Oh right.


00:08:31.380 --> 00:08:34.780
So it says, right, you could have gotten a faster operation there.


00:08:34.780 --> 00:08:37.480
But because the types didn't match, you won't.


00:08:37.480 --> 00:08:39.880
But then what it did get out is an x, and that's great.


00:08:39.880 --> 00:08:43.280
An x which is a float, and it's gonna do some stuff, and it could sort of make it better,


00:08:43.280 --> 00:08:47.680
but it said, look, here's some multiplication again by an integer and a float.


00:08:47.680 --> 00:08:48.880
So that's not quickened.


00:08:48.880 --> 00:08:52.080
And this division, division is apparently never quickened.


00:08:52.080 --> 00:08:53.180
So what can we do?


00:08:53.180 --> 00:08:57.580
Well, with that information, you can say, well, what's the problem with subtracting 32?


00:08:57.580 --> 00:09:00.080
Well, it wasn't a float. What if I said 32.0?


00:09:00.080 --> 00:09:03.080
Oh, yes. All right. That gets replaced by faster code.


00:09:03.080 --> 00:09:04.280
- Oh, nice. - Right?


00:09:04.280 --> 00:09:06.380
So that's pretty nice. And if you want to return,


00:09:06.380 --> 00:09:09.580
it was adding like x plus 32 for the other direction.


00:09:09.580 --> 00:09:11.580
And now it's 32.0. That's faster.


00:09:11.580 --> 00:09:12.880
Okay. Well, what else?


00:09:12.880 --> 00:09:13.980
What if we...


00:09:13.980 --> 00:09:16.580
Now you can see when we did that part of the


00:09:16.580 --> 00:09:20.980
conversion x times 5 divided by 9, if we put a 5.0,


00:09:20.980 --> 00:09:24.380
that gets faster still, but the divide is never quickened.


00:09:24.380 --> 00:09:27.280
Okay. Well, what if we put the divide in parentheses?


00:09:27.280 --> 00:09:32.820
It doesn't really matter if it's X times five divided by nine or X times five divided by nine, right?


00:09:32.820 --> 00:09:39.280
It's these are mathematically equivalent, but they're not equivalent to Python because that that operation results in


00:09:39.280 --> 00:09:45.980
It leverages constant folding right five divided by nine is pre-computed in Python to be a float


00:09:45.980 --> 00:09:48.120
Okay, right at parse time, right?


00:09:48.120 --> 00:09:51.440
That's just how it works with constants if it says that can do math with constants ahead of time


00:09:51.440 --> 00:09:55.240
It does it so that becomes a float and then float times float is now quickened, right?


00:09:55.240 --> 00:09:58.960
Isn't this cool the way you can apply this and actually make your code faster,


00:09:58.960 --> 00:10:00.280
not just go, "Oh, it's interesting.


00:10:00.280 --> 00:10:01.640
It must be quick in it there."


00:10:01.640 --> 00:10:02.040
>> Yeah.


00:10:02.040 --> 00:10:03.000
>> But it's actionable.


00:10:03.000 --> 00:10:05.400
>> It is really pretty cool and I'd really like to see this


00:10:05.400 --> 00:10:08.600
incorporated into an editor or something to say,


00:10:08.600 --> 00:10:13.720
"Your code will be faster if you just add a 0.0 here," or something like that.


00:10:13.720 --> 00:10:16.800
>> It's going to become a float anyway. It doesn't matter.


00:10:16.800 --> 00:10:19.920
Why would you write 32.0 when you just meant 32?


00:10:19.920 --> 00:10:22.320
Seems more precise to say 32.


00:10:22.320 --> 00:10:26.120
>> Because I'm used to doing that, to thinking if it's, okay.


00:10:26.120 --> 00:10:29.120
Well, me personally, if I know it's going to be a float math,


00:10:29.120 --> 00:10:30.480
I usually do 0.0,


00:10:30.480 --> 00:10:32.920
but maybe that's not a normal thing.


00:10:32.920 --> 00:10:35.400
>> You're such a C programmer.


00:10:35.400 --> 00:10:42.160
All right. Well, I think this is really cool, this specialist.


00:10:42.160 --> 00:10:42.880
>> It is pretty cool.


00:10:42.880 --> 00:10:45.160
>> I don't know if I have any code that


00:10:45.160 --> 00:10:48.120
does math at that fine or greater level that I really care,


00:10:48.120 --> 00:10:51.760
but maybe if you're in charge of a library where you've got a tight loop


00:10:51.760 --> 00:10:54.840
or you do a lot of math science stuff where it matters,


00:10:54.840 --> 00:10:56.400
then this can be really useful.


00:10:56.400 --> 00:10:57.920
And what's cool is it's not like,


00:10:57.920 --> 00:11:02.680
and switch to Rust or switch to C or switch to Cython


00:11:02.680 --> 00:11:03.900
and it'll take effect.


00:11:03.900 --> 00:11:06.440
Like no, this is like straight Python code.


00:11:06.440 --> 00:11:08.440
This is just how do I take most advantage


00:11:08.440 --> 00:11:11.720
of what is already happening for performance boosts


00:11:11.720 --> 00:11:13.840
in 3.11 that we haven't had before.


00:11:13.840 --> 00:11:16.080
- And I think it's gonna be just one more workflow step.


00:11:16.080 --> 00:11:20.160
So you've got, you profile your code,


00:11:20.160 --> 00:11:21.960
your whole thing is a little bit slower


00:11:21.960 --> 00:11:23.160
than you'd like it to be.


00:11:23.160 --> 00:11:24.520
You throw a profiler on it,


00:11:24.520 --> 00:11:27.660
you see the bottleneck areas that you could improve,


00:11:27.660 --> 00:11:31.320
and you think, should I like rewrite some of this in Rust


00:11:31.320 --> 00:11:33.440
or C or, you know, what should I do?


00:11:33.440 --> 00:11:35.760
Well, first off, let's try doing this,


00:11:35.760 --> 00:11:38.120
like throw this at it


00:11:38.120 --> 00:11:42.840
and have the optimizer from 3.11 help you out.


00:11:42.840 --> 00:11:46.840
And yeah, so I think this,


00:11:46.840 --> 00:11:48.880
I can definitely see that this is gonna be part


00:11:48.880 --> 00:11:50.360
of people's workflow.


00:11:50.360 --> 00:11:51.200
But yeah, profile first.


00:11:51.200 --> 00:11:52.800
- I agree that you want a profile first.


00:11:52.800 --> 00:11:54.360
Yes, exactly.


00:11:54.360 --> 00:11:56.220
'Cause while it's fun to do this,


00:11:56.220 --> 00:11:58.840
only focus where it's gonna matter.


00:11:58.840 --> 00:12:01.160
Don't optimize a bunch of stuff that doesn't.


00:12:01.160 --> 00:12:03.760
So Brian out in the audience says,


00:12:03.760 --> 00:12:04.600
different Brian,


00:12:04.600 --> 00:12:07.280
"Is there a plan to do lossless type conversion


00:12:07.280 --> 00:12:10.320
"or maybe Flake 8 can make this kind of suggestion?"


00:12:10.320 --> 00:12:11.720
- Yeah, exactly.


00:12:11.720 --> 00:12:12.560
That'd be cool.


00:12:12.560 --> 00:12:14.080
- Yeah, I'm not really sure if,


00:12:14.080 --> 00:12:16.280
you don't want to write the code


00:12:16.280 --> 00:12:18.760
where you get different outputs, probably, right?


00:12:18.760 --> 00:12:20.280
But everything that was happening here,


00:12:20.280 --> 00:12:24.040
you ended up with the same outcome anyway.


00:12:24.040 --> 00:12:25.920
It's just like, well, do I do the division first


00:12:25.920 --> 00:12:26.940
or the multiplication?


00:12:26.940 --> 00:12:29.600
Or do I start with an int that results


00:12:29.600 --> 00:12:31.920
after some addition, subtraction with a float,


00:12:31.920 --> 00:12:34.080
or as I just make them all floats?


00:12:34.080 --> 00:12:36.420
I feel like it's, in most cases,


00:12:36.420 --> 00:12:38.600
it shouldn't be changing the outcome.


00:12:38.600 --> 00:12:42.320
Yep, cool, anyway.


00:12:42.320 --> 00:12:43.800
That's what I got for the first one.


00:12:43.800 --> 00:12:44.640
How about you?


00:12:44.640 --> 00:12:49.060
- Well, kind of sticking with a 3.11 theme so far.


00:12:49.060 --> 00:12:52.180
Well, we can use Toml now,


00:12:52.180 --> 00:12:56.160
but in 3.11, we are gonna have a Tomlib


00:12:56.160 --> 00:13:00.500
be part of Python 3.11 with PEP 680.


00:13:00.500 --> 00:13:03.300
And we covered that in episode 273.


00:13:03.300 --> 00:13:06.260
But one of the things we didn't mention


00:13:06.260 --> 00:13:11.260
was that the Tomlib is,


00:13:11.260 --> 00:13:14.140
and I think we did mention it, is based on Tomly,


00:13:14.140 --> 00:13:15.900
But Tomli, you can use right now.


00:13:15.900 --> 00:13:19.660
So a lot of projects are switching to use Tomli


00:13:19.660 --> 00:13:24.660
as their Toml parser to read like pyproject.toml


00:13:24.660 --> 00:13:29.260
or read their own config file.


00:13:29.260 --> 00:13:32.300
And so I just wanted to highlight it.


00:13:32.300 --> 00:13:36.280
It's Tomli is the, a little Toml parser.


00:13:36.280 --> 00:13:39.460
It's a cute little thing on the project.


00:13:39.460 --> 00:13:40.380
- That is cute.


00:13:40.380 --> 00:13:43.020
- But I was reminded of it because


00:13:43.020 --> 00:13:48.020
The real Python people put out actually,


00:13:48.020 --> 00:13:50.580
looks like gear, Arne, sorry,


00:13:50.580 --> 00:13:52.940
I'm not gonna try to pronounce that name.


00:13:52.940 --> 00:13:55.740
Real Python wrote an article called


00:13:55.740 --> 00:13:59.020
Python and Toml New Best Friends.


00:13:59.020 --> 00:14:02.700
And I really love, it's a very comprehensive article,


00:14:02.700 --> 00:14:06.020
but I really love at least the first three parts of it.


00:14:06.020 --> 00:14:08.500
Using Toml as a config format,


00:14:08.500 --> 00:14:10.660
getting to know key value pairs,


00:14:10.660 --> 00:14:13.060
and load Toml with Python,


00:14:13.060 --> 00:14:15.220
because this is kind of what you're gonna do with it.


00:14:15.220 --> 00:14:17.340
You're gonna write config files for something.


00:14:17.340 --> 00:14:19.020
And I just kind of,


00:14:19.020 --> 00:14:21.860
this is a great introduction of Toml for Python,


00:14:21.860 --> 00:14:23.940
and that's kind of what we care about, right?


00:14:23.940 --> 00:14:26.800
So it goes through,


00:14:26.800 --> 00:14:29.780
like just getting used to what Toml looks like,


00:14:29.780 --> 00:14:31.140
what a config file looks like,


00:14:31.140 --> 00:14:33.240
talking about how all the keys,


00:14:33.240 --> 00:14:35.740
even if you, it's like key value stuff.


00:14:35.740 --> 00:14:38.740
And even if you put a number there or something,


00:14:38.740 --> 00:14:40.000
it's gonna be a string.


00:14:40.000 --> 00:14:41.600
All the keys get converted to strings,


00:14:41.600 --> 00:14:43.480
even if they don't look like them.


00:14:43.480 --> 00:14:46.600
And they are, they're UTF-8,


00:14:46.600 --> 00:14:49.940
so you can use Unicode in there as well,


00:14:49.940 --> 00:14:51.560
which is kind of neat.


00:14:51.560 --> 00:14:52.800
- Put your emojis in there.


00:14:52.800 --> 00:14:56.500
- Yeah, well, can you, is, are emojis UTF-8?


00:14:56.500 --> 00:15:00.360
- I think mostly, many of them are.


00:15:00.360 --> 00:15:03.640
- Interesting, that'd be fun to put emojis in there.


00:15:03.640 --> 00:15:05.000
(laughing)


00:15:05.000 --> 00:15:05.840
I don't know.


00:15:05.840 --> 00:15:06.660
- What mode are we running?


00:15:06.660 --> 00:15:08.600
Are we running in cow mode or lizard mode?


00:15:08.600 --> 00:15:09.440
I'll do lizard.


00:15:09.440 --> 00:15:11.080
Okay, well, if you're running in Lizard--


00:15:11.080 --> 00:15:12.960
- Lizard is true.


00:15:12.960 --> 00:15:15.280
Okay, I gotta try that to see.


00:15:15.280 --> 00:15:16.240
I should have done that before.


00:15:16.240 --> 00:15:18.000
- Oh my gosh, I think I almost,


00:15:18.000 --> 00:15:20.760
it's both horrible and amazing to imagine writing


00:15:20.760 --> 00:15:24.120
like config files to like put it in Lizard mode, do it.


00:15:24.120 --> 00:15:26.600
- Yeah, one of the things that I didn't,


00:15:26.600 --> 00:15:27.640
before reading this article,


00:15:27.640 --> 00:15:30.080
one of the things I didn't know you could do in Toml


00:15:30.080 --> 00:15:31.600
because I just started cursory,


00:15:31.600 --> 00:15:34.320
I use it with pyproject.toml and that's about it.


00:15:34.320 --> 00:15:35.680
But you can do,


00:15:37.040 --> 00:15:41.080
So talks about normal how to read stuff.


00:15:41.080 --> 00:15:43.040
But one of the things is,


00:15:43.040 --> 00:15:44.200
oh, what was I gonna talk about?


00:15:44.200 --> 00:15:45.600
Arrays.


00:15:45.600 --> 00:15:48.340
And you can do arrays of things, which are neat,


00:15:48.340 --> 00:15:53.160
and tables and arrays of tables, which is like,


00:15:53.160 --> 00:15:54.800
so you have arrays of tables


00:15:54.800 --> 00:15:56.720
or these bracket bracket things.


00:15:56.720 --> 00:15:59.400
And then you can do dot stuff.


00:15:59.400 --> 00:16:00.560
So if you have like,


00:16:00.560 --> 00:16:02.880
what was it?


00:16:02.880 --> 00:16:05.160
User and user.player,


00:16:05.160 --> 00:16:07.500
these will show up as like, you know,


00:16:07.500 --> 00:16:10.820
sub dictionary key things.


00:16:10.820 --> 00:16:12.680
And so one of the things that I,


00:16:12.680 --> 00:16:14.440
and I played with it this morning,


00:16:14.440 --> 00:16:17.920
and it really, I should have had something to show,


00:16:17.920 --> 00:16:20.900
but the thing I like to do is to just read it,


00:16:20.900 --> 00:16:23.880
just like this article talks about reading it,


00:16:23.880 --> 00:16:28.000
just read the tomo file into Python and print it.


00:16:28.000 --> 00:16:31.240
And then you can, and it'll print out as a dictionary,


00:16:31.240 --> 00:16:33.980
and then you can create whatever format you want


00:16:33.980 --> 00:16:37.160
for your Tomo file and then you can just see what it's going to look like and then you


00:16:37.160 --> 00:16:39.620
know how to access it.


00:16:39.620 --> 00:16:41.300
It's one of the best ways to do that.


00:16:41.300 --> 00:16:42.300
That's awesome.


00:16:42.300 --> 00:16:43.300
Yeah.


00:16:43.300 --> 00:16:44.300
What an interesting format.


00:16:44.300 --> 00:16:45.540
That's pretty, that's pretty in depth.


00:16:45.540 --> 00:16:48.540
And a blast from last week passed.


00:16:48.540 --> 00:16:53.460
Actually, hey, actually says UTF-8 can encode any Unicode character.


00:16:53.460 --> 00:16:55.340
Emoji your heart emoji.


00:16:55.340 --> 00:16:56.340
Heart of it.


00:16:56.340 --> 00:16:57.340
Oh yeah.


00:16:57.340 --> 00:16:59.720
You could do like, you know, is it in heart mode?


00:16:59.720 --> 00:17:02.300
Heart equals true, heart equals false.


00:17:02.300 --> 00:17:07.040
>> For optimizer, you could do a flame emoji equals true.


00:17:07.040 --> 00:17:09.000
>> Exactly. I love it.


00:17:09.000 --> 00:17:09.240
>> Yeah.


00:17:09.240 --> 00:17:13.640
>> I think we have not leveraged the configuration as emoji sufficiently.


00:17:13.640 --> 00:17:19.040
>> No. Yeah. I think PyTest should rewrite all of its configs as emoji items.


00:17:19.040 --> 00:17:20.600
>> Just do a PR. I'm sure they'll take it.


00:17:20.600 --> 00:17:21.720
>> Yeah.


00:17:21.720 --> 00:17:23.920
>> Yeah. It'll be good.


00:17:23.920 --> 00:17:25.320
>> All right. Yeah. All right.


00:17:25.320 --> 00:17:28.000
Let me tell you about our sponsor for this week before we move on.


00:17:28.000 --> 00:17:31.120
This week is brought to you by Microsoft Founders Hub.


00:17:31.120 --> 00:17:33.660
In fact, they are supporting a whole bunch


00:17:33.660 --> 00:17:34.580
of upcoming episodes.


00:17:34.580 --> 00:17:37.540
So thank you a whole bunch to Microsoft for Startups here.


00:17:37.540 --> 00:17:39.420
Starting business is hard by some estimates,


00:17:39.420 --> 00:17:42.100
over 90% of startups go out of business


00:17:42.100 --> 00:17:43.220
within their first year.


00:17:43.220 --> 00:17:44.980
With that in mind, Microsoft for Startups


00:17:44.980 --> 00:17:48.060
set out to understand what startups need to be successful


00:17:48.060 --> 00:17:49.720
and to create a digital platform


00:17:49.720 --> 00:17:51.420
to help overcome those challenges.


00:17:51.420 --> 00:17:53.660
Microsoft for Startups Founders Hub.


00:17:53.660 --> 00:17:56.360
Their hub provides all founders at any stage


00:17:56.360 --> 00:17:59.820
with a bunch of free resources to help solve challenges.


00:17:59.820 --> 00:18:02.020
and you get technology benefits,


00:18:02.020 --> 00:18:03.100
but also really importantly,


00:18:03.100 --> 00:18:05.880
access to expert guidance and skilled resources,


00:18:05.880 --> 00:18:08.620
mentorship and networking connections and a bunch more.


00:18:08.620 --> 00:18:13.320
So unlike a bunch of other similar projects in the industry,


00:18:13.320 --> 00:18:14.660
Microsoft for Startup Founders Hub


00:18:14.660 --> 00:18:17.180
does not require startups to be investor backed


00:18:17.180 --> 00:18:20.080
or third party validated to participate.


00:18:20.080 --> 00:18:23.340
It's free to apply, and if you apply, get in,


00:18:23.340 --> 00:18:25.640
then you're in, it's open to all.


00:18:25.640 --> 00:18:27.380
So what do you get if you join or apply


00:18:27.380 --> 00:18:28.440
and then get accepted?


00:18:28.440 --> 00:18:31.080
So you can speed up your development with access to GitHub,


00:18:31.080 --> 00:18:34.120
Microsoft Cloud, the ability to unlock credits over time,


00:18:34.120 --> 00:18:38.020
as in it gets over $100,000 worth of credits over time


00:18:38.020 --> 00:18:40.360
over the first year if you meet a bunch of milestones,


00:18:40.360 --> 00:18:41.560
which is fantastic.


00:18:41.560 --> 00:18:42.840
It'll help your startup innovate.


00:18:42.840 --> 00:18:45.920
FounderHub is partnering with companies like OpenAI,


00:18:45.920 --> 00:18:47.960
the global leader in AI research and development


00:18:47.960 --> 00:18:50.040
to provide benefits and discounts too.


00:18:50.040 --> 00:18:50.880
- Neat.


00:18:50.880 --> 00:18:52.600
- Yeah, through Microsoft Startup Founders Hub,


00:18:52.600 --> 00:18:55.120
becoming a founder is no longer about who you know.


00:18:55.120 --> 00:18:56.880
You'll have access to the mentorship network,


00:18:56.880 --> 00:18:59.320
giving you access to a pool of hundreds of mentors


00:18:59.320 --> 00:19:01.120
across a range of disciplines,


00:19:01.120 --> 00:19:03.560
areas like idea validation, fundraising,


00:19:03.560 --> 00:19:05.160
management coaching, sales marketing,


00:19:05.160 --> 00:19:08.000
as well as specific technical stress points.


00:19:08.000 --> 00:19:10.160
To me, that's actually the biggest value


00:19:10.160 --> 00:19:12.680
is the networking and mentor side.


00:19:12.680 --> 00:19:14.640
So you'll be able to book a one-on-one meeting


00:19:14.640 --> 00:19:17.520
with these mentors, many of whom are founders themselves.


00:19:17.520 --> 00:19:19.000
Make your idea a reality today


00:19:19.000 --> 00:19:20.420
with the critical support you'll get


00:19:20.420 --> 00:19:22.520
from Microsoft for Startups Founders Hub.


00:19:22.520 --> 00:19:25.800
Join the program at pythonbites.fm/foundershub.


00:19:25.800 --> 00:19:27.560
link will be in your player show notes.


00:19:27.560 --> 00:19:29.240
- Nice, yeah, cool.


00:19:29.240 --> 00:19:30.240
- Indeed.


00:19:30.240 --> 00:19:32.240
All right, I guess I'm up next with this order we got.


00:19:32.240 --> 00:19:35.720
And oh my goodness, Samuel Colvin, take a bow.


00:19:35.720 --> 00:19:36.560
(Samuel laughs)


00:19:36.560 --> 00:19:40.280
Because he put out a plan for what's happening


00:19:40.280 --> 00:19:42.720
with Hidantic version two.


00:19:42.720 --> 00:19:46.200
But the reason I say take a bow is this is one detailed plan


00:19:46.200 --> 00:19:49.560
that is really, really thought through, thought out,


00:19:49.560 --> 00:19:53.000
backed up with a bunch of GitHub discussions and so on.


00:19:53.000 --> 00:19:53.840
- Wow.


00:19:53.840 --> 00:19:57.840
So the idea is, Hydantic started out as an interesting idea


00:19:57.840 --> 00:20:00.960
and surprise, surprise, a bunch of people glommed onto it


00:20:00.960 --> 00:20:04.960
probably more than it was originally envisioned to be so.


00:20:04.960 --> 00:20:09.160
So for example, SQL model from Sebastian Ramirez is like,


00:20:09.160 --> 00:20:12.320
Hydantic models are now our ORM to the database


00:20:12.320 --> 00:20:14.560
with all the interesting stuff that ORMs have.


00:20:14.560 --> 00:20:16.520
And Roman Wright said, guess what?


00:20:16.520 --> 00:20:19.440
We could do that for MongoDB as well.


00:20:19.440 --> 00:20:21.920
Same with the Pydastic thing we recently spoke about.


00:20:21.920 --> 00:20:24.360
And then Sebastian Ramirez is like, also like,


00:20:24.360 --> 00:20:27.080
hey, fast API, this can be both our data exchange


00:20:27.080 --> 00:20:29.400
as well as our documentation.


00:20:29.400 --> 00:20:31.960
Sure, so I was like, oh my goodness, what's going on here?


00:20:31.960 --> 00:20:35.120
So, so there's a bunch of stuff on the insides


00:20:35.120 --> 00:20:37.280
that could be better, let's say,


00:20:37.280 --> 00:20:40.020
or, you know, maybe time to rethink this.


00:20:40.020 --> 00:20:41.740
So in this plan, it talks about what they'll add,


00:20:41.740 --> 00:20:43.400
what they'll remove, what will change,


00:20:43.400 --> 00:20:46.800
some of the ideas for how long it will take and so on.


00:20:46.800 --> 00:20:47.640
- Interesting.


00:20:47.640 --> 00:20:49.800
- Yeah, here's a pretty significant thing.


00:20:49.800 --> 00:20:54.560
I'm currently taking a kind of sabbatical after leaving my last job to work on this,


00:20:54.560 --> 00:20:56.120
which goes until October.


00:20:56.120 --> 00:21:01.160
So that's a big commitment to I'm going to help make Pydantic better.


00:21:01.160 --> 00:21:03.200
So it sounds familiar.


00:21:03.200 --> 00:21:07.280
It sounds a bit like a rich and textual and those types of things as well.


00:21:07.280 --> 00:21:12.240
But this is a big, big commitment from Samuel and he's really doing a ton of work.


00:21:12.240 --> 00:21:14.280
It says people seem to care about my project.


00:21:14.280 --> 00:21:17.640
It's downloaded 26 million times a month.


00:21:17.640 --> 00:21:18.640
>> Wow.


00:21:18.640 --> 00:21:20.680
>> It's insane. Yeah, it's awesome.


00:21:20.680 --> 00:21:22.380
>> That's incredible.


00:21:22.380 --> 00:21:25.200
>> It is. It says, "Here's the basic roadmap.


00:21:25.200 --> 00:21:29.040
Implement a few features in what's now called the Pydantic Core."


00:21:29.040 --> 00:21:31.960
We just had Ashley, who as we saw is out in the audience.


00:21:31.960 --> 00:21:34.600
Hey, Ashley, who gave a bit of a shout out to this feature.


00:21:34.600 --> 00:21:37.360
Also, I do want to also credit a couple of other people


00:21:37.360 --> 00:21:40.040
because Douglas Nichols and John Thagen


00:21:40.040 --> 00:21:42.360
also let me know that this was big news coming.


00:21:42.360 --> 00:21:43.920
So thank you all for that.


00:21:43.920 --> 00:21:46.840
The Pydantic Core is being rewritten in Rust,


00:21:46.840 --> 00:21:49.500
which doesn't mean you have to know or do anything,


00:21:49.500 --> 00:21:51.600
it just means you have to pip install something,


00:21:51.600 --> 00:21:54.700
you get a binary compiled thing that runs a lot faster.


00:21:54.700 --> 00:21:56.900
Okay, so more on that in a second.


00:21:56.900 --> 00:21:59.000
First, they're working to get 1.10 out


00:21:59.000 --> 00:22:02.040
and basically merge every open PR that makes sense


00:22:02.040 --> 00:22:05.200
and close every PR that doesn't make sense


00:22:05.200 --> 00:22:07.540
and then profusely apologize to why your PR


00:22:07.540 --> 00:22:09.240
that you spent a long time making


00:22:09.240 --> 00:22:10.600
was closed without merging.


00:22:10.600 --> 00:22:13.000
Some other bookkeeping things,


00:22:13.000 --> 00:22:14.800
start tearing the pedantic code apart


00:22:14.800 --> 00:22:17.400
and see how many existing tests can still be made to pass


00:22:17.400 --> 00:22:19.600
and then release eventually Pydantic.


00:22:19.600 --> 00:22:21.300
The goal is to have this done by October,


00:22:21.300 --> 00:22:22.800
probably by the end of year for sure.


00:22:22.800 --> 00:22:24.300
A couple of things worth paying attention to,


00:22:24.300 --> 00:22:26.400
there are a bunch of breaking changes in here.


00:22:26.400 --> 00:22:29.100
A lot of things are being cleaned up, reorganized,


00:22:29.100 --> 00:22:31.700
renamed, some removed,


00:22:31.700 --> 00:22:34.900
like from ORM, people might be using that with SQLAlchemy,


00:22:34.900 --> 00:22:37.200
that's being removed for example and so on.


00:22:37.200 --> 00:22:40.300
So there's, if you depend heavily on Pydantic,


00:22:40.300 --> 00:22:43.100
especially if you build a project like Beanie


00:22:43.100 --> 00:22:44.700
that depends heavily on Pydantic,


00:22:44.700 --> 00:22:47.700
you're going to need to look at this because some of the stuff won't work anymore.


00:22:47.700 --> 00:22:49.700
But let's highlight a couple things here.


00:22:49.700 --> 00:22:53.400
Performance. This one is really important


00:22:53.400 --> 00:22:57.400
because this is the data exchange level at for fast API.


00:22:57.400 --> 00:23:00.000
This is the data base transformation level.


00:23:00.000 --> 00:23:03.400
When I do a query from the database, what comes back comes back in some raw form


00:23:03.400 --> 00:23:05.200
and then is turned into a PyDantic model.


00:23:05.200 --> 00:23:09.600
And those are computationally expensive things that happen often.


00:23:09.600 --> 00:23:14.240
And in general, PyDandic version 2 is about 17 times


00:23:14.240 --> 00:23:19.840
1700% faster than v1 when validating models in a standard scenario.


00:23:19.840 --> 00:23:22.960
Says between 4 to 50 times faster than PyDandic 1.


00:23:22.960 --> 00:23:23.840
>> Wow.


00:23:23.840 --> 00:23:24.480
>> That's cool, right?


00:23:24.480 --> 00:23:25.360
>> Yeah.


00:23:25.360 --> 00:23:27.760
>> That alone should make your ears perk up and go,


00:23:27.760 --> 00:23:30.960
excuse me, my ORM just got 17 times faster?


00:23:30.960 --> 00:23:32.480
Wait a minute, I'm liking this.


00:23:32.480 --> 00:23:36.320
I know that this is not the only thing that happens at ORLM level,


00:23:36.320 --> 00:23:42.720
But the ones that the ones I called out that depend heavily on it, like that's in the transformation path. So this is important.


00:23:42.720 --> 00:23:51.720
Yeah, this is actually I'm super impressed. I have not I normally don't even see this sort of advanced planning in commercial projects.


00:23:51.720 --> 00:24:00.920
Yes. Oh, yeah. You could do a whole business startup that doesn't have the amount of thought that went into like what's happening in the next version of it. It's ridiculous.


00:24:00.920 --> 00:24:01.920
Incredible. Yeah.


00:24:01.920 --> 00:24:04.880
It's incredible. I was serious when I said take a bow.


00:24:04.880 --> 00:24:09.720
It really lays out, opens a discussion about certain things and so on.


00:24:09.720 --> 00:24:11.320
So like another one is strict mode.


00:24:11.320 --> 00:24:14.520
I think I even saw a comment in the chat about it.


00:24:14.520 --> 00:24:17.960
So one of the things I actually like about Pydantic,


00:24:17.960 --> 00:24:19.520
but under certain circumstances,


00:24:19.520 --> 00:24:20.800
I can see why you would not want it,


00:24:20.800 --> 00:24:23.720
is if you have something you say is an integer field,


00:24:23.720 --> 00:24:26.160
and then you pass 1, 2, 3, the number, great.


00:24:26.160 --> 00:24:28.640
But if you also pass "1, 2, 3",


00:24:28.640 --> 00:24:31.040
Pydantic will magically parse that for you.


00:24:31.040 --> 00:24:32.720
Like this happens all the time on the internet.


00:24:32.720 --> 00:24:35.660
Like a query string has a number, but query strings are always strings.


00:24:35.660 --> 00:24:37.800
There's no way to have anything but strings.


00:24:37.800 --> 00:24:38.220
Yeah.


00:24:38.220 --> 00:24:39.320
So you got to convert them.


00:24:39.320 --> 00:24:39.500
Right.


00:24:39.500 --> 00:24:41.240
And so this automatically does that.


00:24:41.240 --> 00:24:44.500
But if you don't want that to happen, you say you gave me a string.


00:24:44.500 --> 00:24:45.260
It's invalid.


00:24:45.260 --> 00:24:47.720
You can turn on strict mode, which is off by default.


00:24:47.720 --> 00:24:47.980
I believe.


00:24:47.980 --> 00:24:49.380
So there's a bunch of play.


00:24:49.380 --> 00:24:49.840
Good.


00:24:49.840 --> 00:24:54.820
So strict mode does the conversion or strict mode won't do the conversion.


00:24:54.820 --> 00:24:56.440
It says you said it's an ant.


00:24:56.440 --> 00:24:57.200
You gave me a string.


00:24:57.200 --> 00:24:58.020
Nope.


00:24:58.020 --> 00:25:00.320
Rather than could it be an integer?


00:25:00.540 --> 00:25:01.740
Let's try that first.


00:25:01.740 --> 00:25:02.640
You know what I mean?


00:25:02.640 --> 00:25:03.940
>> Yeah.


00:25:03.940 --> 00:25:06.460
>> Maybe one of the things you do is,


00:25:06.460 --> 00:25:07.860
in the ORM level,


00:25:07.860 --> 00:25:09.720
one of those things you might put it in strict mode so it


00:25:09.720 --> 00:25:11.780
doesn't do as much work trying to convert stuff.


00:25:11.780 --> 00:25:12.960
I don't know if that actually would matter,


00:25:12.960 --> 00:25:15.180
but formalizes a bunch of conversions.


00:25:15.180 --> 00:25:19.100
It has built-in JSON support and different things.


00:25:19.100 --> 00:25:23.380
Another big thing is this PyDantic core will be able to


00:25:23.380 --> 00:25:27.380
be used outside of PyDantic classes now.


00:25:27.380 --> 00:25:30.860
So you can do a significant performance


00:25:30.860 --> 00:25:33.860
to improve stuff like adding validation to data classes


00:25:33.860 --> 00:25:36.340
or validating arguments in query strings


00:25:36.340 --> 00:25:39.700
or a type DIC or a function argument or whatever.


00:25:39.700 --> 00:25:41.260
- Yeah. - Yeah.


00:25:41.260 --> 00:25:43.700
Let's see, next up.


00:25:43.700 --> 00:25:46.220
And let's see, this one, strict mode.


00:25:46.220 --> 00:25:47.860
We talked about strict mode.


00:25:47.860 --> 00:25:50.460
Another one is required versus nullable.


00:25:50.460 --> 00:25:52.620
It was a little bit of ambiguity of,


00:25:52.620 --> 00:25:54.300
if you said something's a string,


00:25:54.300 --> 00:25:56.800
that means it's required and it can't be none.


00:25:56.800 --> 00:25:59.800
If you say it's a string type none,


00:25:59.800 --> 00:26:02.200
or it's an optional string or something like that,


00:26:02.200 --> 00:26:06.680
then basically the behaviors were a little bit different.


00:26:06.680 --> 00:26:10.320
So originally, I think this is when typing was pretty new,


00:26:10.320 --> 00:26:13.080
said, "Pydenic previously had a confused idea


00:26:13.080 --> 00:26:14.760
"of required versus nullable.


00:26:14.760 --> 00:26:17.500
"This is mostly resulted from Sam's misgivings


00:26:17.500 --> 00:26:19.660
"about marking a field as optional,


00:26:19.660 --> 00:26:22.140
"but requiring a value to be provided to it,


00:26:22.140 --> 00:26:23.480
"but allowing it to be set to none."


00:26:23.480 --> 00:26:24.800
Or something along those lines.


00:26:24.800 --> 00:26:28.680
Anyway, there's minor changes around that.


00:26:28.680 --> 00:26:32.100
Let's see, final one that I want to cover is namespace stuff.


00:26:32.100 --> 00:26:36.000
This is like a whole bunch of things are now getting renamed.


00:26:36.000 --> 00:26:41.340
For example, if you implemented or overrode validateJSON,


00:26:41.340 --> 00:26:43.480
it's now model_validateJSON.


00:26:43.480 --> 00:26:46.280
If you had isInstance, it's now model isInstance.


00:26:46.280 --> 00:26:48.660
There's a bunch of these changes all over the place


00:26:48.660 --> 00:26:51.220
that look like they're going to cause breaking changes.


00:26:51.220 --> 00:26:52.820
They're easy to fix, just change the name,


00:26:52.820 --> 00:26:54.560
but it's not nothing.


00:26:54.560 --> 00:26:56.640
Also parse file.


00:26:56.640 --> 00:26:59.280
I still love his hander here.


00:26:59.280 --> 00:27:01.240
Parse file. This was a mistake.


00:27:01.240 --> 00:27:03.800
It should have never been in PyTantic or removing it.


00:27:03.800 --> 00:27:04.080
>> Okay.


00:27:04.080 --> 00:27:07.780
>> Parse raw, partially replaced by this other thing.


00:27:07.780 --> 00:27:09.360
Anything else it did was a mistake.


00:27:09.360 --> 00:27:11.860
From ORM, this has been moved somewhere else.


00:27:11.860 --> 00:27:13.360
Schema and so on.


00:27:13.360 --> 00:27:15.400
There's a lot of stuff that people were using here.


00:27:15.400 --> 00:27:17.560
So just have a look, try it out.


00:27:17.560 --> 00:27:19.240
Don't just go, "Oh, then version 2 is out.


00:27:19.240 --> 00:27:22.680
Is this going to work?" This is going to have some significant changes.


00:27:22.680 --> 00:27:25.960
>> Another reason why it's really awesome that he goes through


00:27:25.960 --> 00:27:30.560
so much detail is because there's going to be stuff that breaks.


00:27:30.560 --> 00:27:33.720
It's a breaking interface change.


00:27:33.720 --> 00:27:36.760
Yeah, it's cool that it's this detailed.


00:27:36.760 --> 00:27:39.240
A couple of things to notice.


00:27:39.240 --> 00:27:43.160
Let's see, somebody else in the chat mentioned,


00:27:43.160 --> 00:27:46.840
Richard mentioned, and he has emojis in the headers.


00:27:46.840 --> 00:27:48.640
Yeah, there's emojis in the headers.


00:27:48.640 --> 00:27:53.640
I gotta say like the navigation in the table of contents,


00:27:53.640 --> 00:27:59.640
very cool, it goes to like light gray for areas you've already seen and then--


00:27:59.640 --> 00:28:00.640
>> That's interesting.


00:28:00.640 --> 00:28:02.140
>> It's a cool thing.


00:28:02.140 --> 00:28:05.340
>> Yeah, it's quite cool. I think going on and on,


00:28:05.340 --> 00:28:06.640
but two real quick things.


00:28:06.640 --> 00:28:10.640
One, there'll be no pure Python implementation of the core.


00:28:10.640 --> 00:28:14.140
It's always Rust, but they list out the platforms where it'll be compiled to,


00:28:14.140 --> 00:28:15.640
including WebAssembly.


00:28:15.640 --> 00:28:16.640
>> Nice.


00:28:16.640 --> 00:28:22.360
they previously had some Cython in what was supposed to be pure Python's Pydantic.


00:28:22.360 --> 00:28:26.040
So now, a bonus is the Pydantic model,


00:28:26.040 --> 00:28:29.240
the Pydantic package becomes a pure Python package,


00:28:29.240 --> 00:28:30.760
whereas previously it wasn't.


00:28:30.760 --> 00:28:33.360
So they've taken all of that behavior and put it under


00:28:33.360 --> 00:28:36.320
this core thing that ships as a Rust binary and now,


00:28:36.320 --> 00:28:38.460
instead of doing some Cython middle ground,


00:28:38.460 --> 00:28:40.080
it's pure Python again.


00:28:40.080 --> 00:28:42.600
So that's interesting refactoring, I think.


00:28:42.600 --> 00:28:43.560
>> Yeah.


00:28:43.560 --> 00:28:45.880
>> Yeah. Finally, documentation.


00:28:45.880 --> 00:28:52.200
When you get a validation error, it gives you a link to the documentation in the JSON error message.


00:28:52.200 --> 00:28:53.400
That's pretty cool.


00:28:53.400 --> 00:28:54.400
Yeah.


00:28:54.400 --> 00:28:55.400
That's nice.


00:28:55.400 --> 00:28:56.400
All right.


00:28:56.400 --> 00:28:57.400
Yeah.


00:28:57.400 --> 00:28:58.400
Anyway, that's quite a plan, isn't it, Brian?


00:28:58.400 --> 00:28:59.400
Yeah, quite a plan.


00:28:59.400 --> 00:29:00.400
All right.


00:29:00.400 --> 00:29:02.400
Well, I'm excited for it.


00:29:02.400 --> 00:29:03.400
Okay.


00:29:03.400 --> 00:29:08.400
Well, next topic is a little more lighthearted.


00:29:08.400 --> 00:29:09.400
It's about fish.


00:29:09.400 --> 00:29:12.400
Pike, to be specific.


00:29:12.400 --> 00:29:15.400
No, it's about PDFs.


00:29:15.400 --> 00:29:20.400
So it's just a cool project I saw, I noticed, PycPDF.


00:29:20.400 --> 00:29:24.560
It's a Python library for reading and writing PDF files.


00:29:24.560 --> 00:29:25.380
What's the big deal?


00:29:25.380 --> 00:29:26.880
We've had these before.


00:29:26.880 --> 00:29:29.720
But this is, it's based on QPDF,


00:29:29.720 --> 00:29:33.460
which is a C++ based library,


00:29:33.460 --> 00:29:38.460
and it's presently continued being maintained.


00:29:38.460 --> 00:29:41.420
So it's kind of pretty fast.


00:29:41.420 --> 00:29:43.080
Well, actually, I'm assuming it's fast


00:29:43.080 --> 00:29:44.780
if it's C++ in the background.


00:29:44.780 --> 00:29:52.380
But it's also pretty just nice and elegant to do things.


00:29:52.380 --> 00:29:55.180
The documentation has this nice fish,


00:29:55.180 --> 00:30:00.180
which is good. I always like cool diagrams, cool logos.


00:30:00.180 --> 00:30:03.780
But some of the neat things that you can do with it,


00:30:03.780 --> 00:30:08.540
so it's recommending that you not use it if you're just writing PDF files.


00:30:08.540 --> 00:30:12.060
That there's other things that you can use,


00:30:12.060 --> 00:30:14.680
what was it, like Report Lab to write PDFs.


00:30:14.680 --> 00:30:17.620
But if you're having to read or modify PDFs,


00:30:17.620 --> 00:30:19.420
then this is where it shines.


00:30:19.420 --> 00:30:23.220
You can do things like copy pages from one PDF to another,


00:30:23.220 --> 00:30:27.500
split and merge PDFs, extract content out of PDFs.


00:30:27.500 --> 00:30:30.980
Like if you're using it for data stuff,


00:30:30.980 --> 00:30:33.900
you get a report in PDF and you're trying to pull


00:30:33.900 --> 00:30:37.060
that information out, you can use it for that.


00:30:37.060 --> 00:30:39.740
Or images, you can pull all the images out of a PDF file.


00:30:39.740 --> 00:30:42.860
Or, this is kind of cool, you can replace images


00:30:42.860 --> 00:30:45.140
in a PDF file and generate a new one


00:30:45.140 --> 00:30:47.820
without changing anything else about the file.


00:30:47.820 --> 00:30:50.800
It's neat. Just a neat,


00:30:50.800 --> 00:30:55.460
if people are working with reading or modifying PDF files,


00:30:55.460 --> 00:30:56.900
maybe check this one out.


00:30:56.900 --> 00:31:00.140
>> Yeah, this looks great. The fact that it's in C++,


00:31:00.140 --> 00:31:02.340
I'm guessing it's probably standalone.


00:31:02.340 --> 00:31:05.540
I remember I've done some PDF things before and it felt like I had to


00:31:05.540 --> 00:31:09.460
install some OS level thing that it shelled out to, so this is cool.


00:31:09.460 --> 00:31:13.340
Yeah, and the some nice on the readme.


00:31:13.340 --> 00:31:20.060
It has a comparison of some of the different PDF doc or PDF libraries that you could use.


00:31:20.060 --> 00:31:24.460
And some of the reasons why you might want this one, like it supports more versions.


00:31:24.460 --> 00:31:28.420
I didn't realize that like one of these libraries I've heard of before.


00:31:28.420 --> 00:31:31.980
PDFRW doesn't support the newer versions.


00:31:31.980 --> 00:31:33.660
So bummer.


00:31:33.660 --> 00:31:38.220
And then also password protected files.


00:31:38.220 --> 00:31:41.300
It supports that except for but not public key ones,


00:31:41.300 --> 00:31:43.040
but just normal passwords.


00:31:43.040 --> 00:31:45.100
>> Straight passwords. Yeah, that's great.


00:31:45.100 --> 00:31:45.740
>> It's going to be.


00:31:45.740 --> 00:31:49.320
>> Also like the measure of actively maintained,


00:31:49.320 --> 00:31:52.340
the commit activity per year over the years.


00:31:52.340 --> 00:31:54.540
>> All right. That's interesting.


00:31:54.540 --> 00:31:55.980
>> Yeah, it's an interesting metric.


00:31:55.980 --> 00:31:58.060
It seems good. I haven't really thought about it lately,


00:31:58.060 --> 00:31:59.420
but yeah.


00:31:59.420 --> 00:32:00.100
>> Okay.


00:32:00.100 --> 00:32:01.620
>> Yeah, this is a great one.


00:32:01.620 --> 00:32:05.220
>> Well, so that's it for our main items.


00:32:05.220 --> 00:32:07.460
>> Yeah. What else you got? Any extras?


00:32:07.460 --> 00:32:13.540
>> Well, last week we talked about the critical packages.


00:32:13.540 --> 00:32:14.180
>> Critical packages.


00:32:14.180 --> 00:32:16.780
>> Or at some recent.


00:32:16.780 --> 00:32:20.340
Yeah, last week we talked about the critical packages.


00:32:20.340 --> 00:32:21.780
>> Either yesterday or last week,


00:32:21.780 --> 00:32:23.100
depending on how you consume this.


00:32:23.100 --> 00:32:23.500
>> Exactly.


00:32:23.500 --> 00:32:24.100
>> I'm sure it really is.


00:32:24.100 --> 00:32:29.100
>> Yeah. I was surprised to find out that PyTest Check,


00:32:29.100 --> 00:32:31.500
the plugin I wrote, was one of those.


00:32:31.500 --> 00:32:32.640
I'm like, "Really?"


00:32:32.640 --> 00:32:35.260
Because it's like the top 1 percent.


00:32:35.260 --> 00:32:37.240
If anybody's curious,


00:32:37.240 --> 00:32:39.260
I wanted to just highlight that a little bit.


00:32:39.260 --> 00:32:44.060
PyTest Check is a plugin that allows multiple failures per test.


00:32:44.060 --> 00:32:46.460
One of the best ways,


00:32:46.460 --> 00:32:49.500
it's a secondary way that one of the contributors added,


00:32:49.500 --> 00:32:51.480
is you can use it as a context manager.


00:32:51.480 --> 00:32:54.180
You can say like with check and then do an assert,


00:32:54.180 --> 00:32:56.380
then you're going to have multiple of those within a test.


00:32:56.380 --> 00:32:59.020
>> I like the one-liner, that's pretty nice.


00:32:59.020 --> 00:33:00.860
>> This is totally like black,


00:33:00.860 --> 00:33:03.540
we'll totally reformat this if you ran it through black.


00:33:03.540 --> 00:33:06.140
but it's nice, you'd have to block it out.


00:33:06.140 --> 00:33:08.520
Anyway, I was like,


00:33:08.520 --> 00:33:10.100
how could it be?


00:33:10.100 --> 00:33:13.540
I'm curious what on the list it was.


00:33:13.540 --> 00:33:19.700
There's a place called HugoVK,


00:33:19.700 --> 00:33:23.420
has a top PyPI packages list and it's updated.


00:33:23.420 --> 00:33:25.540
I think it's just updated once a month or something.


00:33:25.540 --> 00:33:29.820
But you can do the top 5,000.


00:33:29.820 --> 00:33:33.420
It's the top 5,000 or 1,000 or 100.


00:33:33.420 --> 00:33:38.280
I was curious about where on the list I was.


00:33:38.280 --> 00:33:41.560
I'm number 1,677,


00:33:41.560 --> 00:33:44.320
so far down the list, but hey.


00:33:44.320 --> 00:33:48.080
>> It's still in the top third of the top 1 percent.


00:33:48.080 --> 00:33:49.120
That's pretty awesome.


00:33:49.120 --> 00:33:51.740
>> The PyTest is number 72.


00:33:51.740 --> 00:33:54.120
That was pretty neat. Pydantic, which we covered,


00:33:54.120 --> 00:33:58.040
I just checked, 117.


00:33:58.040 --> 00:34:01.240
But there are 57 PyTest plugins


00:34:01.240 --> 00:34:03.360
that show up in the top 3,500.


00:34:03.360 --> 00:34:05.400
So that's pretty neat.


00:34:05.400 --> 00:34:06.600
- That is pretty neat.


00:34:06.600 --> 00:34:08.320
- That's all I got for extras.


00:34:08.320 --> 00:34:10.200
- All right, well, I have zero extras.


00:34:10.200 --> 00:34:11.840
So mine are finished as well.


00:34:11.840 --> 00:34:12.760
How about a joke?


00:34:12.760 --> 00:34:13.680
- Yeah, great.


00:34:13.680 --> 00:34:15.680
- All right, I told you we're coming back to it.


00:34:15.680 --> 00:34:17.440
So this one comes from Netta,


00:34:17.440 --> 00:34:22.160
Netta, code girl @netta.mk.


00:34:22.160 --> 00:34:24.480
And let me just pull this one up here, right?


00:34:24.480 --> 00:34:28.760
So this one is, there's this colleague here.


00:34:28.760 --> 00:34:30.480
Can I make this, there we go, make it a little bigger.


00:34:30.480 --> 00:34:33.160
There's the two women who are developers,


00:34:33.160 --> 00:34:36.960
Netta and her unnamed friend who always has


00:34:36.960 --> 00:34:39.320
gotten in trouble with the elevator last time, basically.


00:34:39.320 --> 00:34:42.920
And there's this sort of weird manager looking guy


00:34:42.920 --> 00:34:45.240
that comes in and says, "I tested your chatbot,


00:34:45.240 --> 00:34:48.080
but some of its replies are really messed up."


00:34:48.080 --> 00:34:50.120
"Well, that's what testing's all about.


00:34:50.120 --> 00:34:52.880
I'll go through the logs later," says one of the girls.


00:34:52.880 --> 00:34:55.440
"No, no, no, no, no, no, no, no, no need."


00:34:55.440 --> 00:34:56.280
(both laughing)


00:34:56.280 --> 00:34:58.160
Right, check out the faces.


00:34:58.160 --> 00:34:59.200
She was like, "Excuse me,


00:34:59.200 --> 00:35:02.160
I'm not even sure I want to open the logs now.


00:35:02.160 --> 00:35:04.520
>> Yeah, don't look at the logs.


00:35:04.520 --> 00:35:06.880
>> That's what testing is for.


00:35:06.880 --> 00:35:09.800
>> I'll go through the logs later.


00:35:09.800 --> 00:35:14.960
>> She's got some good ones in her list there. Love it.


00:35:14.960 --> 00:35:17.960
>> Yeah. I like the art too. Nice art.


00:35:17.960 --> 00:35:18.600
>> I do too.


00:35:18.600 --> 00:35:19.600
>> Me too.


00:35:19.600 --> 00:35:22.200
>> Also nice was our podcast. Thanks for being here.


00:35:22.200 --> 00:35:23.000
>> Thank you.


00:35:23.000 --> 00:35:23.880
>> Yeah, you bet.


00:35:23.880 --> 00:35:24.920
>> See you next week.

