
00:00:00.000 --> 00:00:07.280
Hello and welcome to Python Bytes where we deliver Python news directly to your earbuds. This is episode 90 recorded August 2nd


00:00:07.280 --> 00:00:12.760
2018 I'm Michael Kennedy and I'm Brian Akin. Hey Brian. Good to be with you again. That's good to talk to you again


00:00:12.760 --> 00:00:18.500
Yeah, and it's also good to have DigitalOcean sponsoring this episode. So thank you to DigitalOcean


00:00:18.500 --> 00:00:24.440
We're both customers and they're sponsors of ours. So it's kind of this weird mix of everybody loving it


00:00:24.440 --> 00:00:30.200
So Pythonbytes.fm/digitalocean will get you $100 credit for your servers if you're a new customer.


00:00:30.200 --> 00:00:31.080
So check that out.


00:00:31.080 --> 00:00:34.440
In the meantime, we should probably talk about some data analysis.


00:00:34.440 --> 00:00:35.080
We should.


00:00:35.080 --> 00:00:39.120
And who better to talk about data analysis than Jake VanderPlas?


00:00:39.120 --> 00:00:40.080
I honestly don't know.


00:00:40.080 --> 00:00:43.920
He does awesome work over there at the eScience Institute.


00:00:43.920 --> 00:00:45.720
And I love listening to his talks.


00:00:45.720 --> 00:00:49.080
So there's a set of videos that he has on.


00:00:49.080 --> 00:00:53.000
This is actually from last year, but it didn't count.


00:00:53.000 --> 00:00:56.920
There's 11 videos and it's called reproducible data analysis in Jupyter


00:00:56.920 --> 00:01:01.920
But there I mean each of the videos is like five or six minutes, so they go pretty fast


00:01:01.920 --> 00:01:03.760
And this is a really cool thing


00:01:03.760 --> 00:01:06.360
I think everybody should check these out anyway is because there


00:01:06.360 --> 00:01:09.520
he goes through a problem of or just a


00:01:09.520 --> 00:01:15.560
Dataset that the bikes cross the bike crossings at a particular bridge in


00:01:15.560 --> 00:01:20.800
Seattle I think but it really doesn't matter the data how the data gets in there


00:01:20.880 --> 00:01:26.060
But he's using doing all this stuff live. He's doing a Jupyter notebook and


00:01:26.060 --> 00:01:31.960
Pulling data in and sometimes the tables like it the table that he ends up with doesn't look quite right


00:01:31.960 --> 00:01:35.820
so he uses a different different column to as the index or


00:01:35.820 --> 00:01:37.640
the for instance


00:01:37.640 --> 00:01:39.600
I'm one of the in the first video


00:01:39.600 --> 00:01:43.640
He puts a graph up and all the data is sort of packed together


00:01:43.640 --> 00:01:50.680
So he changes the sample rate into just weekly data and and all that stuff. I didn't even know you could do those things


00:01:50.680 --> 00:01:57.000
So it's not necessarily a complete, it's kind of a full pass through all of using


00:01:57.000 --> 00:02:01.640
all the tools you can use to do exploratory data analysis with Jupyter


00:02:01.640 --> 00:02:07.240
and doing it live. And watching a pro do it, it's a thing of beauty. And he's, like


00:02:07.240 --> 00:02:12.080
I said, each particular tool that he uses, it's not an in-depth study on


00:02:12.080 --> 00:02:16.320
exactly how to use that to its completeness, but you just get a glimpse


00:02:16.320 --> 00:02:19.280
at all the power that you can do with all these things. Yeah, I really like it.


00:02:19.280 --> 00:02:22.980
And I think this sort of view into exploring data is super interesting.


00:02:22.980 --> 00:02:25.080
It really shows the power of Jupyter notebooks.


00:02:25.080 --> 00:02:28.880
Like when I first saw them, I thought, "Oh, well, there's like a simplified programming environment


00:02:28.880 --> 00:02:33.780
for people that aren't like real programmers and don't want to work with different files and stuff like that."


00:02:33.780 --> 00:02:37.580
But the more I saw people using it and interacted with it, I realized


00:02:37.580 --> 00:02:41.980
it's just for people solving problems entirely differently than the type of problems I solve.


00:02:41.980 --> 00:02:43.180
And it's really great for that.


00:02:43.180 --> 00:02:53.180
Yeah, and working with data, when you're throwing up a graph or a plot of the data, sometimes you might be plotting it wrong.


00:02:53.180 --> 00:02:56.180
You're like, "Well, maybe I could see something if I plot it this way."


00:02:56.180 --> 00:03:00.180
And it's not interesting. It's just a bunch of points everywhere.


00:03:00.180 --> 00:03:08.180
But if you plot it a little different with a different axis, maybe, or a different type of plot, it might show you interesting information.


00:03:08.180 --> 00:03:10.140
This is actually fascinating to me,


00:03:10.140 --> 00:03:13.580
this notion of people using large data sets


00:03:13.580 --> 00:03:17.220
and then trying to figure out in real time


00:03:17.220 --> 00:03:18.740
how to use it well.


00:03:18.740 --> 00:03:20.840
And then once you've already figured that out,


00:03:20.840 --> 00:03:22.900
if you want to put some program together


00:03:22.900 --> 00:03:25.740
using some of those tools to monitor those things,


00:03:25.740 --> 00:03:26.620
that's a great idea.


00:03:26.620 --> 00:03:29.940
But the ability to just use a notebook


00:03:29.940 --> 00:03:32.820
to just explore stuff is pretty fascinating.


00:03:32.820 --> 00:03:34.980
- Yeah, and there's some really interesting use cases.


00:03:34.980 --> 00:03:37.500
Like, suppose you want to go hit a bunch of APIs


00:03:37.500 --> 00:03:39.540
and download some data and then graph it.


00:03:39.540 --> 00:03:42.180
If you did that in like a script,


00:03:42.180 --> 00:03:44.220
every time you want to view it slightly differently,


00:03:44.220 --> 00:03:45.740
you're rerunning that down,


00:03:45.740 --> 00:03:47.260
you're getting or computing the data


00:03:47.260 --> 00:03:48.640
however you do that, right?


00:03:48.640 --> 00:03:51.420
Whereas in notebooks, you can just rerun one cell at a time,


00:03:51.420 --> 00:03:52.720
change that cell, run it again,


00:03:52.720 --> 00:03:54.740
and you have to recompute or reacquire the data.


00:03:54.740 --> 00:03:57.100
So it's really, there's a lot of interesting aspects to it.


00:03:57.100 --> 00:03:59.660
- Yeah, and that's another thing he starts out with,


00:03:59.660 --> 00:04:02.140
showing how to, within the notebook,


00:04:02.140 --> 00:04:06.300
grab a URL of data and put it in a CSV file


00:04:06.300 --> 00:04:10.900
some local file so you don't have to do that network all the time.


00:04:10.900 --> 00:04:11.900
Nice.


00:04:11.900 --> 00:04:12.900
But anyway.


00:04:12.900 --> 00:04:13.900
Yeah, it's a good one.


00:04:13.900 --> 00:04:17.380
I really like the series and I'm glad you brought it up.


00:04:17.380 --> 00:04:19.860
Another thing I want to bring up, something we haven't covered very much.


00:04:19.860 --> 00:04:21.740
Have we talked about GUIs in Python yet?


00:04:21.740 --> 00:04:22.900
You know, I think they're important.


00:04:22.900 --> 00:04:25.300
We probably should start talking about it.


00:04:25.300 --> 00:04:26.300
Yes.


00:04:26.300 --> 00:04:31.500
So, because we were on our kick, of course people said, "Oh, have you heard about this?


00:04:31.500 --> 00:04:32.580
Have you tried that?"


00:04:32.580 --> 00:04:34.060
And here's another one.


00:04:34.060 --> 00:04:35.900
This one comes from Mike Barnett.


00:04:35.900 --> 00:04:41.320
He sent me a couple emails, sort of charting the progress of this project that he built.


00:04:41.320 --> 00:04:44.620
The name pretty much says it all, PySimpleGUI.


00:04:44.620 --> 00:04:47.660
So it's for simple Python GUIs.


00:04:47.660 --> 00:04:51.720
And it's just another really simple way to take what would have been like a command line


00:04:51.720 --> 00:04:54.940
program and make it a lot better.


00:04:54.940 --> 00:05:00.900
So you know, bonus points to Mike, because this not only has a screenshot, this has many


00:05:00.900 --> 00:05:02.700
screenshots and many examples.


00:05:02.700 --> 00:05:09.140
So as all the Python GUI libraries out there should have, if you want people to use them,


00:05:09.140 --> 00:05:10.140
screenshots.


00:05:10.140 --> 00:05:11.140
So check it out.


00:05:11.140 --> 00:05:12.140
It's pretty cool.


00:05:12.140 --> 00:05:17.500
What you do is you work more or less in 100% Python language API.


00:05:17.500 --> 00:05:21.980
And you don't work down at the GUI toolkit layer, which is cool, I think.


00:05:21.980 --> 00:05:25.760
So you define the UI and it has this sort of auto layout mechanism.


00:05:25.760 --> 00:05:29.700
And it has things like slide bars and text boxes and buttons.


00:05:29.700 --> 00:05:31.200
It works in all the things.


00:05:31.200 --> 00:05:32.200
So that's pretty nice.


00:05:32.200 --> 00:05:35.780
on like a razz it says one of the examples is do you have a raspberry pi


00:05:35.780 --> 00:05:40.680
with a touchscreen well you know why don't you just write this one screen


00:05:40.680 --> 00:05:45.180
full of GUI code and you've got your touchscreen GUI working in that goal


00:05:45.180 --> 00:05:50.880
honey yeah so for better or worse it's based on Tkinter which is good because


00:05:50.880 --> 00:05:54.600
it comes with Python there's no dependencies so literally you just pip


00:05:54.600 --> 00:05:58.200
install pi simple GUI or if you want there's a single Python file you can


00:05:58.200 --> 00:06:03.360
include with your code. So there's not even the pip install package stuff, you could literally


00:06:03.360 --> 00:06:09.040
just go, here's the file, pi simple GUI dot pi, but next to my my program. And that's


00:06:09.040 --> 00:06:15.640
all it needs. So that's cool. But I honestly, I think Tkinter looks a little dated, right?


00:06:15.640 --> 00:06:20.720
Like it looks like it belongs a little more in like war games than it does in 2018. But


00:06:20.720 --> 00:06:25.800
Anyway, it's still pretty nice as it is.


00:06:25.800 --> 00:06:31.160
One of the upcoming things that he lists on the upcoming goals or if anybody wants to


00:06:31.160 --> 00:06:34.240
help out is port this to other graphics engines.


00:06:34.240 --> 00:06:39.360
Because you don't work in the toolkit API directly, but this is like a translation layer,


00:06:39.360 --> 00:06:45.360
you could hook this up to say WX Python or Python for Qt, Qt for Python, things like


00:06:45.360 --> 00:06:46.360
that.


00:06:46.360 --> 00:06:51.080
one of these modern looking UIs just by if somebody's willing to do that translation.


00:06:51.080 --> 00:06:53.400
That's a neat idea. I'd like to see people working on that.


00:06:53.400 --> 00:06:56.600
Yeah, wouldn't that be sweet? Then it could actually detect if you even have them and


00:06:56.600 --> 00:07:00.500
it wouldn't even go, oh, do you have WX? Okay, great. We'll go with that. Oh, you have Qt.


00:07:00.500 --> 00:07:04.480
Let's just run that version. Don't have to get a dependency installed. That'd be best.


00:07:04.480 --> 00:07:10.120
Yeah. And yeah, you're right that the TK stuff looks dated. But you know, there's a lot of


00:07:10.120 --> 00:07:14.240
use cases where you can use a GUI that doesn't have to be pretty.


00:07:14.240 --> 00:07:17.680
Yeah, well, you know what else can look dated is the command line to a lot of people.


00:07:17.680 --> 00:07:23.280
So, you know, maybe this is a lot better interaction for non-technical people, even if it does


00:07:23.280 --> 00:07:25.720
have a little bit funky shading on the buttons or something.


00:07:25.720 --> 00:07:30.600
Yeah, I mean, I don't get it, but I do have, I fight that battle every once in a while.


00:07:30.600 --> 00:07:33.160
Tell people this, just run this command line thing.


00:07:33.160 --> 00:07:34.800
What do you mean run the command line thing?


00:07:34.800 --> 00:07:35.800
Oh dear.


00:07:35.800 --> 00:07:38.440
They're like, I studied accounting.


00:07:38.440 --> 00:07:41.200
I don't know where the terminal is on my Mac.


00:07:41.200 --> 00:07:42.200
Okay.


00:07:42.200 --> 00:07:43.200
Okay, then.


00:07:43.200 --> 00:07:47.360
Yeah, one other thing to call out for I think that's interesting.


00:07:47.360 --> 00:07:49.640
This is Python 3 only.


00:07:49.640 --> 00:07:53.240
So no Python 2 for PySimple GUI.


00:07:53.240 --> 00:07:56.900
And more and more again we're seeing things where it used to be, well, I can't switch


00:07:56.900 --> 00:07:58.700
to Python 3 because this isn't supported.


00:07:58.700 --> 00:08:02.240
Now it's like if you don't switch to Python 3, you don't get these cool libraries.


00:08:02.240 --> 00:08:05.240
And here's just one more example.


00:08:05.240 --> 00:08:08.240
Yeah, great.


00:08:08.240 --> 00:08:13.240
Well, we've got a team that is migrating to Git,


00:08:13.240 --> 00:08:15.880
and so this isn't directly Python related,


00:08:15.880 --> 00:08:17.920
but I ran across this article called


00:08:17.920 --> 00:08:21.320
"Useful Tricks You Might Not Know About Git Stash."


00:08:21.320 --> 00:08:24.540
And git stash is the stash command,


00:08:24.540 --> 00:08:26.160
is something that I actually,


00:08:26.160 --> 00:08:28.000
it took me a while to run across


00:08:28.000 --> 00:08:31.180
because it's not something you have to use,


00:08:31.180 --> 00:08:33.760
but a stash is a way to,


00:08:33.760 --> 00:08:36.400
so let's say you've got a repository


00:08:36.400 --> 00:08:40.040
where you've cloned it, now you've made some changes on it,


00:08:40.040 --> 00:08:42.720
and you're not ready to do anything with your changes,


00:08:42.720 --> 00:08:46.040
but you need to like maybe pull down a new version


00:08:46.040 --> 00:08:48.800
or you branched at the wrong point or whatever.


00:08:48.800 --> 00:08:52.020
Stash is a way to save off all of your changes,


00:08:52.020 --> 00:08:54.120
all the dirty stuff in your directory,


00:08:54.120 --> 00:08:57.240
save it away and just like hide it somewhere.


00:08:57.240 --> 00:08:59.240
And then you can reapply those changes later


00:08:59.240 --> 00:09:02.360
after you update or pull or something.


00:09:02.360 --> 00:09:06.300
And I'm still working through how to integrate Stash


00:09:06.300 --> 00:09:10.180
into a good workflow, but I wanted to highlight this article,


00:09:10.180 --> 00:09:13.680
Useful Tricks You Might Not Know About Git Stash,


00:09:13.680 --> 00:09:16.700
because I'm learning it and I wanted other people


00:09:16.700 --> 00:09:18.260
to know about it also.


00:09:18.260 --> 00:09:19.100
- Yeah, that's cool.


00:09:19.100 --> 00:09:21.880
One of the ideas that seems like it might be relevant here


00:09:21.880 --> 00:09:24.300
is suppose you've got some branch checked out


00:09:24.300 --> 00:09:26.060
and you're doing some work, you're like halfway through it


00:09:26.060 --> 00:09:27.180
and somebody comes along and says,


00:09:27.180 --> 00:09:29.700
"Hey, I'm on the same branch as you,


00:09:29.700 --> 00:09:31.860
"and we have this bug, could you just like fix this


00:09:31.860 --> 00:09:34.240
"really quick or make this quick change


00:09:34.240 --> 00:09:38.680
sure that I can carry on. And you're like, Oh, but this work I have here is like half


00:09:38.680 --> 00:09:43.680
done, it won't be done till tomorrow. So you could like stash that away, get the latest,


00:09:43.680 --> 00:09:49.220
do some work, push that in and then reapply that stash to like, get your work back without


00:09:49.220 --> 00:09:52.040
actually committing it and messing up that whole branch.


00:09:52.040 --> 00:09:58.200
Yeah, definitely. And the use case and then the use case we often use is like, like the


00:09:58.200 --> 00:10:03.920
test team is working on different different tests around. But we're sharing in utility


00:10:03.920 --> 00:10:11.840
libraries and fixtures and stuff. And somebody updates a crucial fixture or a utility communication


00:10:11.840 --> 00:10:17.840
utility. And so you want to use that but you're you're in the middle of writing your test,


00:10:17.840 --> 00:10:23.240
writing changing something new. These aren't merge conflicts at all. But get doesn't let


00:10:23.240 --> 00:10:28.720
you like pull in the new stuff on top of your old stuff. I mean, you can do a merge, right,


00:10:28.720 --> 00:10:32.840
but you still have to commit it to your local repo before you can do a pull, which you might


00:10:32.840 --> 00:10:33.840
not want to do yet.


00:10:33.840 --> 00:10:36.680
And if you're just starting out or whatever, you might not want to do that if you just


00:10:36.680 --> 00:10:37.800
want to look at stuff.


00:10:37.800 --> 00:10:42.680
So that's the case where a lot of where we're playing with this workflow is to just stash


00:10:42.680 --> 00:10:45.440
away your changes to a poll.


00:10:45.440 --> 00:10:49.440
And again, people can correct me if I'm if I'm using the term poll wrong, because I'm


00:10:49.440 --> 00:10:55.960
still learning at the right times to do polls and fetches and marriages and all that stuff.


00:10:55.960 --> 00:10:56.960
So nice.


00:10:56.960 --> 00:10:57.960
And this is really cool.


00:10:57.960 --> 00:11:00.200
Two things that you call it here that I thought were pretty cool.


00:11:00.200 --> 00:11:05.020
Well, I guess three one is you can label your stashes. So like, you know what they mean. They're not just hashes


00:11:05.020 --> 00:11:13.360
That's good. Also. I didn't know you can do a - you to include untracked files. That's pretty cool. That's pretty cool


00:11:13.360 --> 00:11:16.240
I didn't know that either before I read the article and the other one that


00:11:16.240 --> 00:11:22.880
Last one that I didn't I totally didn't know you could do is once you have your stash saved


00:11:22.880 --> 00:11:28.760
You could say well, I probably shouldn't have done it as a stash. I probably should have just put that on a branch


00:11:29.080 --> 00:11:37.000
there's a way to say get stash branch and then a name and then you can specify which stash and it just takes all those


00:11:37.000 --> 00:11:43.060
Files that you've all those changes and creates a branch. That's cool. Yeah, I really like that one


00:11:43.060 --> 00:11:47.440
Like oh I stashed it and actually what I want to do is more work and sort of parallel like break it off


00:11:47.440 --> 00:11:52.960
Split off my work without committing it to sort of convert the stash to a branch. That's cool. Yeah. Yeah, very nice


00:11:52.960 --> 00:11:58.260
I like it. So let me tell you about this new thing that digital ocean has so they have


00:11:58.260 --> 00:12:03.060
virtual machines and floating IPs and they have spaces and load balancers and


00:12:03.060 --> 00:12:07.140
all these sorts of things even domains and DNS is and if you have a lot of


00:12:07.140 --> 00:12:12.100
stuff going on at DigitalOcean well you might have like 20 virtual machines and


00:12:12.100 --> 00:12:15.300
some of them are for some project another one is for another project like


00:12:15.300 --> 00:12:19.460
how do you know which one is for which and is that one safe to delete I think


00:12:19.460 --> 00:12:21.820
we're done with it but I'm not sure I actually don't know really know what it


00:12:21.820 --> 00:12:25.780
belongs to so they came up with this new feature called projects where you can


00:12:25.780 --> 00:12:31.540
group droplets, load balancers, domains, IP addresses, all that kind of stuff into one


00:12:31.540 --> 00:12:35.940
two different projects. You can say this one is say for the training site, these three parts all


00:12:35.940 --> 00:12:41.220
fit together there. This one is for the Python bytes podcast. And these two servers and spaces


00:12:41.220 --> 00:12:45.860
all fit together over there. So pretty cool. Check that out. It's just one more way to


00:12:45.860 --> 00:12:51.300
make your hosting life easier. Yeah, and be sure to visit Python bytes.fm slash digital ocean. If


00:12:51.300 --> 00:12:53.480
And if you're a new user, you get $100 credit.


00:12:53.480 --> 00:12:55.760
So that makes it even nicer.


00:12:55.760 --> 00:12:58.580
So one of the things I'd like to see, Brian, is more async stuff.


00:12:58.580 --> 00:13:02.620
And I think the place where it's most beneficial is around the web, actually.


00:13:02.620 --> 00:13:07.580
Well, yes, last week, I said, because we can have like a bunch of different worker processes,


00:13:07.580 --> 00:13:09.940
it's not really necessary, right?


00:13:09.940 --> 00:13:13.860
You can get like, if you've got an eight core server, you could have say 16 little micro


00:13:13.860 --> 00:13:15.820
whiskey worker processes.


00:13:15.820 --> 00:13:21.100
And each one can sort of computationally chew up its stuff, like one one core and sort of


00:13:21.100 --> 00:13:25.300
get shared by the OS. But really, there's some limit where you don't want to


00:13:25.300 --> 00:13:30.820
create more because you run out of memory, right? Like I think the 16 on the


00:13:30.820 --> 00:13:35.460
training site probably take like a two gigs of RAM. So you can't have many of


00:13:35.460 --> 00:13:40.020
them or you'll run out of RAM unless you have a lot of room there. At some point,


00:13:40.020 --> 00:13:44.540
you maybe are waiting on a database call, right? You do request the request


00:13:44.540 --> 00:13:47.700
says, well, in order to process this request, I need to have a hit this


00:13:47.700 --> 00:13:51.420
database. And actually, this is a query that takes 500 milliseconds to return,


00:13:51.420 --> 00:13:56.380
that thread is really doing nothing but just waiting on a socket to return


00:13:56.380 --> 00:14:01.860
something from say, Postgres or MongoDB. And just as well could be doing other


00:14:01.860 --> 00:14:06.300
work if it could let go, but you know, maybe it doesn't, right. So if we can


00:14:06.300 --> 00:14:10.540
build this so that we could build it with async and await, anytime our code


00:14:10.540 --> 00:14:13.820
is waiting, it immediately gives up its thread, and it will go on to do more


00:14:13.820 --> 00:14:16.660
processing. And so like, for example, this is one of the ways this is


00:14:16.660 --> 00:14:21.220
basically the fundamental process concept of how like node js can do


00:14:21.220 --> 00:14:25.020
hundreds of thousands of requests on one server. All right, concurrent,


00:14:25.020 --> 00:14:28.780
because most of those are waiting on a database or something else, right?


00:14:28.780 --> 00:14:34.820
However, the problem is many of the Python popular Python frameworks don't


00:14:34.820 --> 00:14:40.860
support this concept of async. We have new frameworks, Sanic, Gepronto, others


00:14:40.860 --> 00:14:44.860
that do support it. But those are not the old frameworks, right? So there's


00:14:44.860 --> 00:14:48.380
like this, there's these new ones that are exciting and fast. And there's the old ones


00:14:48.380 --> 00:14:52.820
that everybody knows how to work with and have deployed. But bridging that gap is a


00:14:52.820 --> 00:14:59.280
challenge. So Andrew Godwin, the guy who worked on Django channels works on Django channels.


00:14:59.280 --> 00:15:04.700
He came up with a Django async roadmap. And it's pretty interesting and pretty thorough.


00:15:04.700 --> 00:15:10.860
And it talks about like the timeframe and how they might make Django support this sort


00:15:10.860 --> 00:15:13.100
a world where you can have async methods.


00:15:13.100 --> 00:15:18.260
Yeah, that's actually really cool because I mean if Django and Flask have to get there


00:15:18.260 --> 00:15:24.460
or especially Django, or it's gonna something else will take over.


00:15:24.460 --> 00:15:25.460
Right, exactly.


00:15:25.460 --> 00:15:27.980
I mean, this is one of the times you hear people say I'm switching to Go because it


00:15:27.980 --> 00:15:29.900
does better concurrency than Python.


00:15:29.900 --> 00:15:35.300
Well, if Django and the other frameworks just had it baked in like that, that whole argument


00:15:35.300 --> 00:15:36.940
would largely go away.


00:15:36.940 --> 00:15:42.140
So anyway, this is really cool. And I really like how he's put it together. He said he thinks it's


00:15:42.140 --> 00:15:46.700
time, the time has come to start seriously talking about bringing async functionality to Django.


00:15:46.700 --> 00:15:51.500
And he's shared it previously with some people internally. But this is him kind of coming out


00:15:51.500 --> 00:15:57.340
and saying I'm opening it up for public feedback. So he has some interesting goals, says the goal


00:15:57.340 --> 00:16:04.380
is to make Django a world class example of what async can enable for HTTP requests. And that means


00:16:04.380 --> 00:16:08.780
various things at different parts of the stack. So doing ORM requests in parallel, right,


00:16:08.780 --> 00:16:13.500
just waiting on the database. Instead of waiting the 500 milliseconds, you just continue doing


00:16:13.500 --> 00:16:19.660
processing and then get back to it when the ORM responds, allowing views to query external APIs


00:16:19.660 --> 00:16:25.020
without blocking. So you know, we talked about the retry stuff, if you're calling like a credit card


00:16:25.020 --> 00:16:31.100
or other sort of external API, right, then you know, that would go away faster. You could do


00:16:31.100 --> 00:16:37.020
like slow response, long polling, super easy. It's like a sort of WebSocket stand in all sorts of


00:16:37.020 --> 00:16:41.260
performance improvements. So it's that it's imperative that they keep Django backwards


00:16:41.260 --> 00:16:47.020
compatible. And to make sure that when people come to the project, this is an option they can turn on,


00:16:47.020 --> 00:16:51.660
not something they have to learn. So like part of the beauty of these frameworks is they've been


00:16:51.660 --> 00:16:56.460
really easy to get started with. Let's not throw this at people at the very first thing they ever


00:16:56.460 --> 00:17:01.460
Yeah, yeah, there's a place for it and not sometimes not a place for it.


00:17:01.460 --> 00:17:23.460
Yeah, exactly. All right. So I said, why now? Well, Django 2.1 will be the first release to support Python 3 and above and not the previous ones. And Python 3.5 and above. This is where async and await the language syntax and like it truly has become properly supported. So that's why I think now's the time to start working on this.


00:17:23.460 --> 00:17:28.180
Yeah, and then the sort of the timeline is broken out into different Django releases


00:17:28.180 --> 00:17:33.060
and and which ones what sort of goals might be for each one.


00:17:33.060 --> 00:17:34.060
That's nice.


00:17:34.060 --> 00:17:35.060
Yeah, it's pretty cool.


00:17:35.060 --> 00:17:38.780
Like, it doesn't make any sense to parallelize the web methods necessarily without paralyzing


00:17:38.780 --> 00:17:40.180
the data access.


00:17:40.180 --> 00:17:42.900
So maybe start with the ORM actually, things like that.


00:17:42.900 --> 00:17:43.980
Yeah, I love this.


00:17:43.980 --> 00:17:49.420
I think that it's also good also talking about people like there's it's not just individual


00:17:49.420 --> 00:17:52.620
developers, but companies that have applications.


00:17:52.620 --> 00:17:57.000
They might want to think about concurrency, but they don't necessarily, they don't need


00:17:57.000 --> 00:18:02.380
to do it right now, but they know that they're going to eventually do it to see this roadmap.


00:18:02.380 --> 00:18:05.700
And maybe that'll help people.


00:18:05.700 --> 00:18:07.740
In the article also talks about funding.


00:18:07.740 --> 00:18:13.140
So if a lot of companies are relying on this or looking forward to it in the future, maybe


00:18:13.140 --> 00:18:16.620
kicking in some dollars to help it go faster is a good thing.


00:18:16.620 --> 00:18:22.180
Yeah, it blows my mind how many huge companies are basically built on Python infrastructure,


00:18:22.180 --> 00:18:26.740
contribute zero to it. Yeah and that's something that we're as a society and


00:18:26.740 --> 00:18:32.220
not just the Python community but a web using community we've got to tackle


00:18:32.220 --> 00:18:37.100
that but part of this is I guess just also things like this to say hey this is


00:18:37.100 --> 00:18:40.900
where we're going and some of these problems need people focused on it not


00:18:40.900 --> 00:18:46.100
just volunteer time so some direct money to hire somebody for six months or a


00:18:46.100 --> 00:18:49.540
year would be good idea. Yeah a lot can get done with just like a few months of


00:18:49.540 --> 00:18:53.740
focus time. Yeah, definitely. Yeah, I mean that's how the new Pi-PI got launched.


00:18:53.740 --> 00:19:00.100
So this is all the way up to, looks like a mostly async Django by Django 3.2.


00:19:00.100 --> 00:19:03.620
Yeah, that's awesome. That's a ways, it's pretty conservative. It's not too wild


00:19:03.620 --> 00:19:08.380
and I really think it's a well thought out plan so I'm happy to see Andrew put


00:19:08.380 --> 00:19:13.180
it out there. Nice. Yeah, nice. So you got some music you're gonna play for us?


00:19:13.180 --> 00:19:18.240
We both actually end up processing a ton of audio files, don't we? We do and I


00:19:18.240 --> 00:19:22.920
I usually don't do it in Python, but this PyDub,


00:19:22.920 --> 00:19:25.000
plus what a great name, PyDub,


00:19:25.000 --> 00:19:27.720
but it makes me think that maybe a little bit


00:19:27.720 --> 00:19:30.840
of audio processing within Python might make sense.


00:19:30.840 --> 00:19:33.560
PyDub, the tagline is manipulate audio


00:19:33.560 --> 00:19:36.420
with a simple and easy high-level interface.


00:19:36.420 --> 00:19:38.400
But it's really actually pretty cool


00:19:38.400 --> 00:19:41.980
with just a single line, like for instance,


00:19:41.980 --> 00:19:46.480
from mp3, you can pull in a mp3 file into a variable,


00:19:46.480 --> 00:19:48.480
And then once you've got it there,


00:19:48.480 --> 00:19:51.060
you can do things like use the bracket operators


00:19:51.060 --> 00:19:52.880
to get the first 10 seconds.


00:19:52.880 --> 00:19:54.960
- It's crazy you can use the slice on it


00:19:54.960 --> 00:19:57.120
and you can use indexing operators.


00:19:57.120 --> 00:19:58.320
It's like, that's crazy.


00:19:58.320 --> 00:20:00.600
- And then adding or subtracting integers


00:20:00.600 --> 00:20:04.280
changes the volume by that number of decibels.


00:20:04.280 --> 00:20:07.200
The way that the use of operators is pretty cool.


00:20:07.200 --> 00:20:09.640
Plus, you know, so slicing and chopping,


00:20:09.640 --> 00:20:12.980
but you can do crossfade and repeat and fade.


00:20:12.980 --> 00:20:14.560
And I'm not quite sure what the difference


00:20:14.560 --> 00:20:16.020
between crossfade and fade are,


00:20:16.020 --> 00:20:19.900
But anyway, changing formats from like say,


00:20:19.900 --> 00:20:22.980
WAV to MP3 or something, adding meta tags,


00:20:22.980 --> 00:20:23.900
that's pretty cool.


00:20:23.900 --> 00:20:25.220
- That's the one that got my attention.


00:20:25.220 --> 00:20:28.820
I'm like, oh, oh, this might help


00:20:28.820 --> 00:20:30.480
on some production stuff I'm doing.


00:20:30.480 --> 00:20:32.740
- Making sure of a specific bit rates


00:20:32.740 --> 00:20:35.900
or MP3 has a quality level.


00:20:35.900 --> 00:20:38.300
You can pass all that stuff in for saving.


00:20:38.300 --> 00:20:39.980
Anyway, it's just like a really,


00:20:39.980 --> 00:20:43.540
we'll include a code snippet of a few things you can do,


00:20:43.540 --> 00:20:45.840
but it's pretty easy to maintain code


00:20:45.840 --> 00:20:47.040
once you've got it in place, I think.


00:20:47.040 --> 00:20:48.080
- Yeah, this looks really interesting.


00:20:48.080 --> 00:20:49.320
If you're doing anything with audio,


00:20:49.320 --> 00:20:50.740
people should check this out.


00:20:50.740 --> 00:20:52.920
I did talk about this trade-off


00:20:52.920 --> 00:20:55.940
and how Django solving its async problem


00:20:55.940 --> 00:20:58.540
within itself would be great,


00:20:58.540 --> 00:21:00.840
but I still think there's room for exploration


00:21:00.840 --> 00:21:02.520
on the web in the Python world.


00:21:02.520 --> 00:21:04.400
And so this next one is pretty much that.


00:21:04.400 --> 00:21:07.280
It actually describes itself as an experimental framework,


00:21:07.280 --> 00:21:10.360
but it's called Molten, a modern API framework.


00:21:10.360 --> 00:21:11.360
Have you heard of this, Brian?


00:21:11.360 --> 00:21:12.200
- No.


00:21:12.200 --> 00:21:16.500
It's a minimal, fast web framework


00:21:16.500 --> 00:21:19.460
specifically for building APIs with Python.


00:21:19.460 --> 00:21:23.600
So I don't even know if it has a template language for HTML.


00:21:23.600 --> 00:21:25.760
It's all about just building APIs.


00:21:25.760 --> 00:21:28.020
But it looks pretty awesome, actually.


00:21:28.020 --> 00:21:30.460
- Yeah, and pretty terse and small.


00:21:30.460 --> 00:21:33.260
- Yeah, one of the things that I like that it does


00:21:33.260 --> 00:21:38.260
is it uses type annotations for a whole bunch of cool things.


00:21:38.260 --> 00:21:41.940
So the other framework I saw do this was API*,


00:21:41.940 --> 00:21:44.640
but I don't think it quite used it as much.


00:21:44.640 --> 00:21:48.340
So for example, you can have an API function


00:21:48.340 --> 00:21:50.780
that has a name, which is a string,


00:21:50.780 --> 00:21:52.740
and an age, which is an integer,


00:21:52.740 --> 00:21:56.020
and it will automatically pass that data over to you,


00:21:56.020 --> 00:21:58.580
as you call it, which is pretty awesome.


00:21:58.580 --> 00:22:00.420
It also does request validation.


00:22:00.420 --> 00:22:01.660
So you can create a class,


00:22:01.660 --> 00:22:05.040
which looks very much like a data annotation,


00:22:05.040 --> 00:22:08.020
or looks like a data annotation class.


00:22:08.020 --> 00:22:11.420
And you give it a decorator and say, this is a schema.


00:22:11.420 --> 00:22:16.700
And what happens is if you say my API function takes this class as an argument,


00:22:16.700 --> 00:22:19.780
so their example has a to-do class.


00:22:19.780 --> 00:22:25.500
So if you say the input is colon to-do, right, you annotate it as a to-do,


00:22:25.500 --> 00:22:29.780
then it will actually parse all the things like the ID and the description


00:22:29.780 --> 00:22:36.500
and all the various pieces out of the input and verify that, you know,


00:22:36.500 --> 00:22:40.220
the ID is a string, or the ID is an integer, the description is a string,


00:22:40.220 --> 00:22:42.820
all that kind of stuff just by using type annotations.


00:22:42.820 --> 00:22:44.500
(laughing)


00:22:44.500 --> 00:22:45.580
- That's pretty cool.


00:22:45.580 --> 00:22:47.940
- Yeah, yeah, it's pretty sweet.


00:22:47.940 --> 00:22:48.900
Here, I'll throw out the next one,


00:22:48.900 --> 00:22:50.380
see what you think about this.


00:22:50.380 --> 00:22:53.020
They also support dependency injection


00:22:53.020 --> 00:22:57.420
for allowing you to pass different data access layers


00:22:57.420 --> 00:22:58.240
and stuff like that.


00:22:58.240 --> 00:22:59.220
So if you wanna test it,


00:22:59.220 --> 00:23:03.260
you could pass in a mocked out data layer,


00:23:03.260 --> 00:23:05.860
whereas by default, you just register it app startup


00:23:05.860 --> 00:23:08.500
and it'll create all the different pieces of infrastructure


00:23:08.500 --> 00:23:11.060
and pass them to the methods automatically.


00:23:11.060 --> 00:23:12.300
- Okay, some people like that.


00:23:12.300 --> 00:23:13.860
- Yeah, you know, I don't see that very often


00:23:13.860 --> 00:23:15.180
in the Python space.


00:23:15.180 --> 00:23:16.160
I have mixed emotions.


00:23:16.160 --> 00:23:17.600
Sometimes it's nice, sometimes it's not.


00:23:17.600 --> 00:23:19.940
But anyway, it supports that, you don't have to use it.


00:23:19.940 --> 00:23:22.740
But I do think the validation and the schema


00:23:22.740 --> 00:23:25.720
and the auto-mapping of your sort of JSON documents


00:23:25.720 --> 00:23:28.020
to and from just strong classes


00:23:28.020 --> 00:23:30.860
with Python-based declarative requirements and stuff


00:23:30.860 --> 00:23:31.700
is really cool.


00:23:31.700 --> 00:23:33.820
- Yeah, I think the extra thing that they're adding,


00:23:33.820 --> 00:23:37.980
this idea of using annotations as a schema,


00:23:37.980 --> 00:23:38.700
It's pretty cool.


00:23:38.700 --> 00:23:39.180
That's neat.


00:23:39.180 --> 00:23:39.500
Yeah.


00:23:39.500 --> 00:23:40.480
I really like it too.


00:23:40.480 --> 00:23:43.960
And the other one that I looked at, sorry if I get this a little bit wrong, but


00:23:43.960 --> 00:23:46.760
there's some other framework that also used annotations that I thought was


00:23:46.760 --> 00:23:52.760
really cool, but it used them in a way that Python itself didn't make a lot of


00:23:52.760 --> 00:23:53.200
sense of.


00:23:53.200 --> 00:23:58.760
So like you could say, like I'm getting an API key passed to me and you would say


00:23:58.760 --> 00:24:03.760
colon header to say this API key is coming out of the header, but when you


00:24:03.760 --> 00:24:06.080
actually work with it, it's not actually a header, it's a string.


00:24:06.080 --> 00:24:07.640
It just came from the header.


00:24:07.640 --> 00:24:10.380
And so things like PyCharm and stuff would freaking go,


00:24:10.380 --> 00:24:11.440
that doesn't have this method.


00:24:11.440 --> 00:24:12.800
You're like, no, I know it's a string,


00:24:12.800 --> 00:24:14.880
even though I just actually said it's a header.


00:24:14.880 --> 00:24:16.760
Like this is cool 'cause the thing you say it is


00:24:16.760 --> 00:24:19.380
actually is what it is.


00:24:19.380 --> 00:24:20.540
The framework is consistent


00:24:20.540 --> 00:24:21.640
sort of with the programming model.


00:24:21.640 --> 00:24:22.880
I like that a lot.


00:24:22.880 --> 00:24:25.080
Yep, anyway, pretty cool.


00:24:25.080 --> 00:24:28.200
And people can check that out if they're building APIs.


00:24:28.200 --> 00:24:29.720
Remember, it's in the experimental stage,


00:24:29.720 --> 00:24:32.200
but you can play with it,


00:24:32.200 --> 00:24:34.120
see if it fits your needs or make it better.


00:24:34.120 --> 00:24:35.280
- Definitely, nice.


00:24:35.280 --> 00:24:36.120
- Yeah, pretty cool.


00:24:36.120 --> 00:24:37.620
Alright, anything else you want to share with us, Brian?


00:24:37.620 --> 00:24:38.920
No, I can't believe we're already done.


00:24:38.920 --> 00:24:39.920
I know.


00:24:39.920 --> 00:24:41.600
Same for me, I covered it all last week.


00:24:41.600 --> 00:24:44.680
So just always fun to share this stuff with you.


00:24:44.680 --> 00:24:45.680
Thanks for being here.


00:24:45.680 --> 00:24:48.640
Definitely fun and everybody keep on sending us things that we should check out.


00:24:48.640 --> 00:24:50.360
I love getting tips from people.


00:24:50.360 --> 00:24:51.360
Absolutely.


00:24:51.360 --> 00:24:52.360
Same here.


00:24:52.360 --> 00:24:53.360
See you later.


00:24:53.360 --> 00:24:54.360
Bye.


00:24:54.360 --> 00:24:55.360
Thank you for listening to Python Bytes.


00:24:55.360 --> 00:24:57.760
Follow the show on Twitter via @PythonBytes.


00:24:57.760 --> 00:25:00.880
That's Python Bytes as in B-Y-T-E-S.


00:25:00.880 --> 00:25:04.200
And get the full show notes at PythonBytes.fm.


00:25:04.200 --> 00:25:07.880
If you have a news item you want featured, just visit PythonBytes.fm and send it our


00:25:07.880 --> 00:25:08.880
way.


00:25:08.880 --> 00:25:11.400
We're always on the lookout for sharing something cool.


00:25:11.400 --> 00:25:14.600
On behalf of myself and Brian Okken, this is Michael Kennedy.


00:25:14.600 --> 00:25:17.920
Thank you for listening and sharing this podcast with your friends and colleagues.

