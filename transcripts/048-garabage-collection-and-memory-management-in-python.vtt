
00:00:00.000 --> 00:00:05.520
Hello and welcome to Python bites where we deliver Python news and headlines directly to your earbuds


00:00:05.520 --> 00:00:08.220
This is episode 48 recorded October 18th


00:00:08.220 --> 00:00:14.640
2017 I'm Michael Kennedy and I'm Brian Harkin and we got a bunch of awesome stuff lined up for you


00:00:14.640 --> 00:00:18.280
we're both dialing in from Portland, Oregon, we've scoured the internet and


00:00:18.280 --> 00:00:20.480
We're gonna start with some graphs


00:00:20.480 --> 00:00:25.040
But before we do let's just say really quick a thanks to digital ocean a big thanks to digital ocean. Thanks


00:00:25.040 --> 00:00:29.260
Yeah, they totally blew s3 out of the water and they've been an awesome thing called spaces


00:00:29.260 --> 00:00:30.760
We'll tell you more about it later.


00:00:30.760 --> 00:00:32.200
Right now I want to hear about cool graphs.


00:00:32.200 --> 00:00:35.240
- Well, I came across this last week a website


00:00:35.240 --> 00:00:40.240
called Python-Graph-Gallery, the Python Graph Gallery.


00:00:40.240 --> 00:00:42.740
And it is cool.


00:00:42.740 --> 00:00:47.560
I was describing it as graph examples


00:00:47.560 --> 00:00:50.580
times your head explodes with options.


00:00:50.580 --> 00:00:52.640
But got a whole bunch of different types


00:00:52.640 --> 00:00:54.180
of graphs you want to do.


00:00:54.180 --> 00:00:56.720
There are all sorts of different types of graphs


00:00:56.720 --> 00:00:58.400
that you see around the internet


00:00:58.400 --> 00:01:00.480
and basically to help you visualize your data.


00:01:00.480 --> 00:01:04.160
>> You got the standard ones like histogram and stuff or box plot,


00:01:04.160 --> 00:01:08.280
but then you also have really cool ones like 2D density plots or bubble plots,


00:01:08.280 --> 00:01:11.000
or connected graphs, or core.


00:01:11.000 --> 00:01:14.720
Core-logram, yeah, there's amazing stuff here.


00:01:14.720 --> 00:01:19.120
They all come with IPython little scripts, right?


00:01:19.120 --> 00:01:20.600
You click on them, they get the details.


00:01:20.600 --> 00:01:23.480
>> You dive down into exactly what you want to do,


00:01:23.480 --> 00:01:26.400
and then you can go in and it shows you


00:01:26.400 --> 00:01:29.960
exactly how to make those plots within Matplotlib


00:01:29.960 --> 00:01:33.780
and in I think in IPython, but that's the same thing, right?


00:01:33.780 --> 00:01:35.880
But then also some of them have,


00:01:35.880 --> 00:01:37.920
like they'll explain how to do something


00:01:37.920 --> 00:01:39.440
and then they have alternates


00:01:39.440 --> 00:01:41.160
and there's some opinion there.


00:01:41.160 --> 00:01:42.960
Some of the graphs they don't really like


00:01:42.960 --> 00:01:45.240
and they'll tell you why they don't like them


00:01:45.240 --> 00:01:46.920
and what some good alternatives are.


00:01:46.920 --> 00:01:48.680
- Yeah, another thing that's cool about it


00:01:48.680 --> 00:01:49.840
is you go to one graph, you're like,


00:01:49.840 --> 00:01:52.640
huh, I think I need a bar chart or something like that


00:01:52.640 --> 00:01:54.560
and it pulls up and says, these are the related ones.


00:01:54.560 --> 00:01:55.960
And you're like, oh, this one is way cooler.


00:01:55.960 --> 00:01:56.800
I didn't even know about it.


00:01:56.800 --> 00:01:59.680
Like I haven't, maybe I haven't read the Tufte


00:01:59.680 --> 00:02:01.440
like visualizing information book.


00:02:01.440 --> 00:02:02.720
And I don't know of all the options, right?


00:02:02.720 --> 00:02:03.640
And you can discover them.


00:02:03.640 --> 00:02:04.480
I like that.


00:02:04.480 --> 00:02:07.100
- Yeah, and then like it includes some of the extensions.


00:02:07.100 --> 00:02:10.840
Like I just dove into seeing how to do a vertical histogram


00:02:10.840 --> 00:02:14.380
and it mentions that you need to have the Seaborn library


00:02:14.380 --> 00:02:17.640
and use it for these, so.


00:02:17.640 --> 00:02:18.640
- Yeah, it looks pretty cool.


00:02:18.640 --> 00:02:19.480
- It's great.


00:02:19.480 --> 00:02:20.920
- Yeah, and I guess there's also some R ones out there


00:02:20.920 --> 00:02:24.400
like an R part that's sort of tied to it somehow as well


00:02:24.400 --> 00:02:25.480
if you do R.


00:02:25.480 --> 00:02:27.120
But yeah, I've been thinking a lot


00:02:27.120 --> 00:02:28.920
about doing some stuff recently


00:02:28.920 --> 00:02:31.120
that would require some really cool interactive graphs.


00:02:31.120 --> 00:02:33.440
So this definitely catches my interest.


00:02:33.440 --> 00:02:34.280
- Yeah.


00:02:34.280 --> 00:02:36.160
- All right, so check out the Python graph gallery.


00:02:36.160 --> 00:02:37.120
That's cool.


00:02:37.120 --> 00:02:38.120
Moving on to the next one.


00:02:38.120 --> 00:02:40.400
Brian, do you know what Kinesis Streams are?


00:02:40.400 --> 00:02:41.220
- I don't.


00:02:41.220 --> 00:02:42.280
I do have a Kinesis keyboard,


00:02:42.280 --> 00:02:43.880
but I don't think that's related at all.


00:02:43.880 --> 00:02:45.840
- Kinesis keyboards are wild, man.


00:02:45.840 --> 00:02:49.120
I have the Sculpt Economic Mini thing from Microsoft.


00:02:49.120 --> 00:02:50.600
I used to have one of those.


00:02:50.600 --> 00:02:53.480
But Kinesis Streams are these things that AWS released.


00:02:53.480 --> 00:02:57.720
And the idea is you can like stream tons of real time data


00:02:57.720 --> 00:02:59.600
through it and apply filters and transformations


00:02:59.600 --> 00:03:03.200
and get additional sort of real time insight.


00:03:03.200 --> 00:03:05.600
So like under the description, it'll say things like


00:03:05.600 --> 00:03:08.440
you can continuously capture and store terabytes of data


00:03:08.440 --> 00:03:11.740
per hour from hundreds of thousands of sources,


00:03:11.740 --> 00:03:14.820
such as web click streams, financial transactions,


00:03:14.820 --> 00:03:17.320
social media feeds, et cetera, et cetera.


00:03:17.320 --> 00:03:18.960
So this sounds like a really cool service,


00:03:18.960 --> 00:03:20.740
you can go sign up for it, AWS.


00:03:20.740 --> 00:03:23.400
It looks like at least the folks that sent in


00:03:23.400 --> 00:03:28.360
this recommendation say, look, it really requires Java right now for the API to do it. So they


00:03:28.360 --> 00:03:34.080
felt that that was wrong. And they created this thing called Pionesis for Python, API


00:03:34.080 --> 00:03:37.160
is talking to Kinesis streams. How about that? That's great. Yeah. So if you're out there,


00:03:37.160 --> 00:03:40.960
and you got tons of data streaming in, and especially if you're already an AWS customer,


00:03:40.960 --> 00:03:44.560
you already have an account, you already work there, maybe your apps run there, then it's


00:03:44.560 --> 00:03:51.200
really cool. So this library does some cool stuff. It's worked for 27 and 36. It has a


00:03:51.200 --> 00:03:56.800
Django extension helper, it automatically detects shard changes to like this thing can


00:03:56.800 --> 00:04:03.200
do sharding and like adjust for that it'll create checkpoints and even has a dummy kinesis


00:04:03.200 --> 00:04:04.200
implementation for testing.


00:04:04.200 --> 00:04:05.200
How about that?


00:04:05.200 --> 00:04:06.200
That's great.


00:04:06.200 --> 00:04:07.200
That's cool.


00:04:07.200 --> 00:04:09.000
Yeah, and it's a this is an open source project too.


00:04:09.000 --> 00:04:11.880
So you can extend on it if you need to write on.


00:04:11.880 --> 00:04:13.720
Yeah, it's pretty new, but check it out.


00:04:13.720 --> 00:04:15.320
And thanks for recommending pinesis.


00:04:15.320 --> 00:04:17.680
I forgot the guy who sent it in over Twitter.


00:04:17.680 --> 00:04:18.680
But yeah, thank you.


00:04:18.680 --> 00:04:19.680
That's awesome.


00:04:19.680 --> 00:04:24.380
more mysterious things I think in Python relative to say other languages like C


00:04:24.380 --> 00:04:30.880
for example is how memory works right like in C I call malloc or I call free


00:04:30.880 --> 00:04:35.040
in Python I just do stuff and like I never run out of memory that's kind of


00:04:35.040 --> 00:04:39.960
cool yeah it is cool but it has some downsides a little bit I guess not


00:04:39.960 --> 00:04:43.760
really at least some complexity right yeah well it hides that complexity from


00:04:43.760 --> 00:04:48.480
the users but there's especially when you have an application or a service or


00:04:48.480 --> 00:04:51.560
something that's a long running Python application,


00:04:51.560 --> 00:04:54.440
you have to care about what's going on and


00:04:54.440 --> 00:04:57.640
make sure that you don't continually grow in memory.


00:04:57.640 --> 00:04:59.760
There's an article that we're going to link to called


00:04:59.760 --> 00:05:03.140
Things You Need to Know About Garbage Collection in Python.


00:05:03.140 --> 00:05:06.880
It just came out recently and I sat down with


00:05:06.880 --> 00:05:09.860
a cup of coffee this morning and really read it and tried to grok it.


00:05:09.860 --> 00:05:13.020
I think it helped me a lot to understand how Python does.


00:05:13.020 --> 00:05:15.060
There's two levels of garbage collection.


00:05:15.060 --> 00:05:17.300
There's the automatic stuff that's just,


00:05:17.300 --> 00:05:24.300
If an object goes out of scope, it disappears and then the Python can reclaim that memory.


00:05:24.300 --> 00:05:31.460
And there's something about like it treats small objects like under 512 bytes a little different to save time.


00:05:31.460 --> 00:05:32.960
And that's cool.


00:05:32.960 --> 00:05:44.900
But then there's this other thing to detect loops and other dead memory because reference counting you can have two objects point to each other and you can get these loops of memory that just sit around forever.


00:05:44.900 --> 00:05:56.300
And so there's this other system, the generational garbage collector that goes through and looks for all of these dead items and cleans them out and that runs periodically.


00:05:56.300 --> 00:06:06.380
But that one you can control if you need to. If you really can't handle it going off and doing its own thing, you can turn it off and call it yourself once in a while if you need to.


00:06:06.380 --> 00:06:13.820
What's really interesting about this is one of the benefits of like C or C++ really is


00:06:13.820 --> 00:06:16.700
you get total deterministic behavior.


00:06:16.700 --> 00:06:18.900
But the drawback is you got to manage it manually.


00:06:18.900 --> 00:06:23.860
With reference counting, you get also totally deterministic behavior, right?


00:06:23.860 --> 00:06:26.380
You run it many times, it's going to behave the same way exactly.


00:06:26.380 --> 00:06:29.460
So if you're doing something as timing that really matters, that's cool.


00:06:29.460 --> 00:06:34.260
The reference counting GCs or reference counting algorithm has the problem of cycles.


00:06:34.260 --> 00:06:38.460
So if I have like a parent-child relationship, they're always going to have at least one


00:06:38.460 --> 00:06:41.380
reference because parent knows a child, child knows parent.


00:06:41.380 --> 00:06:43.180
So that thing's never going to go to zero and will leak.


00:06:43.180 --> 00:06:47.540
So you have this secondary like market sweep garbage collector type thing that comes in.


00:06:47.540 --> 00:06:52.460
And I think it's really interesting how they've chosen like this combination and the market


00:06:52.460 --> 00:06:57.060
sweep garbage collector, similar to like .NET or Java, which is that's all they have over


00:06:57.060 --> 00:06:58.060
there, right?


00:06:58.060 --> 00:06:59.060
I didn't know.


00:06:59.060 --> 00:07:00.060
Yeah, yeah.


00:07:00.060 --> 00:07:02.660
Those two basically work in this generational garbage collector way very similar.


00:07:02.660 --> 00:07:05.940
I don't know that it's exactly the same, but it's similar for Java and .NET.


00:07:05.940 --> 00:07:08.940
But that's not the main way it works.


00:07:08.940 --> 00:07:11.140
So I think that that's actually pretty interesting.


00:07:11.140 --> 00:07:13.540
I mean, the article here doesn't go into too much depth,


00:07:13.540 --> 00:07:15.940
but deep enough to where you can understand it.


00:07:15.940 --> 00:07:19.340
And it's really, I thought, you know, I knew that you could mess around with


00:07:19.340 --> 00:07:23.740
stopping the garbage collector and, or the generational one,


00:07:23.740 --> 00:07:27.340
and controlling that yourself, but I didn't know how to do it.


00:07:27.340 --> 00:07:29.940
And it's really not that complicated. It's a few lines of code is all.


00:07:29.940 --> 00:07:32.340
Yeah, there's a couple of neat things about this article.


00:07:32.340 --> 00:07:35.220
One is there are some very nice specifics,


00:07:35.220 --> 00:07:38.260
like did you know the five objects that are equal to


00:07:38.260 --> 00:07:40.100
or smaller than 512 bytes


00:07:40.100 --> 00:07:43.020
have a different allocator and mechanism, right?


00:07:43.020 --> 00:07:45.760
Like knowing that cutoff and those sorts of things


00:07:45.760 --> 00:07:49.100
and knowing when the GC kicks in and when to turn off.


00:07:49.100 --> 00:07:50.800
Like there's also a lot of references,


00:07:50.800 --> 00:07:52.060
like if you don't know more about this,


00:07:52.060 --> 00:07:52.900
read about this section.


00:07:52.900 --> 00:07:55.000
You don't know more about this, read about this section.


00:07:55.000 --> 00:07:57.660
So I think this is a great place to start this exploration.


00:07:57.660 --> 00:08:00.140
- And then at the end, it talks about how to find these,


00:08:00.140 --> 00:08:01.900
you know, these cycles are bad


00:08:01.900 --> 00:08:03.540
And you kind of want to get those out of your code


00:08:03.540 --> 00:08:05.660
if you really want to care about this a lot.


00:08:05.660 --> 00:08:07.300
And it talks about how to do,


00:08:07.300 --> 00:08:10.060
how to go about looking for that stuff and visualizing it


00:08:10.060 --> 00:08:13.340
so you can try to find these cycles in your code


00:08:13.340 --> 00:08:14.440
and get rid of them.


00:08:14.440 --> 00:08:15.280
That's cool.


00:08:15.280 --> 00:08:16.320
- Yeah, the other thing to consider


00:08:16.320 --> 00:08:17.740
when you're thinking about stuff,


00:08:17.740 --> 00:08:21.080
especially if it kicks into the actual market sweep cycle,


00:08:21.080 --> 00:08:23.100
garbage collector type thing,


00:08:23.100 --> 00:08:25.540
is algorithms and data structures.


00:08:25.540 --> 00:08:27.020
So you can have a data structure


00:08:27.020 --> 00:08:30.140
that is like many, many objects that point at each other.


00:08:30.140 --> 00:08:35.660
think of like linked list type of things, there's tons of work to process those if you


00:08:35.660 --> 00:08:36.860
got ginormous ones.


00:08:36.860 --> 00:08:40.660
You got tons of work to process and determine if that's garbage, right?


00:08:40.660 --> 00:08:45.420
You might be able to like use a sparse array or something that uses almost no pointers


00:08:45.420 --> 00:08:48.580
but stores the same data and you know is more efficient.


00:08:48.580 --> 00:08:51.340
So there's a lot of interesting follow on things to explore here.


00:08:51.340 --> 00:08:56.180
And again, yeah, and this is mostly a concern with people that have long running Python


00:08:56.180 --> 00:09:00.740
applications for short-running things it's not a problem so you don't really


00:09:00.740 --> 00:09:04.460
have to care about it. Yep. Also another final thought is you said you can turn


00:09:04.460 --> 00:09:08.300
off the garbage collector. I think was it Instagram that turned off the garbage


00:09:08.300 --> 00:09:12.420
collector in their system? It was either I feel like it was Instagram or Quora.


00:09:12.420 --> 00:09:15.820
One of those people, one of those companies turned off the garbage


00:09:15.820 --> 00:09:20.420
collector and they found they were able to get much better memory use reuse on


00:09:20.420 --> 00:09:24.460
Linux across the processes and actually was better off by just letting the


00:09:24.460 --> 00:09:26.460
cycles leak in this article you can


00:09:26.460 --> 00:09:32.140
Determinate yourself you can have predetermined times where you're gonna go out and let it run. Yep pretty interesting


00:09:32.140 --> 00:09:34.620
You know what else is interesting?


00:09:34.620 --> 00:09:35.780
spaces


00:09:35.780 --> 00:09:40.140
Yeah, it is space is pretty awesome. Yeah, so like this audio you guys all are listening to you came over


00:09:40.140 --> 00:09:45.260
Digital ocean spaces and if you're familiar with s3 this is like s3 but way better so


00:09:45.260 --> 00:09:52.580
Very deterministic pricing you pay $5 a month for a terabyte of outbound traffic. No inbound traffic and


00:09:53.220 --> 00:09:55.980
Beyond that it's like 1/9 the price of


00:09:55.980 --> 00:10:02.820
Bandwidth and traffic for s3. So if you're using s3 now definitely consider digital ocean spaces


00:10:02.820 --> 00:10:10.240
They're doing really cool stuff there all the API is the libraries and the tools that work against s3 also work against spaces


00:10:10.240 --> 00:10:12.540
They've made that sort of a compatibility layer for them


00:10:12.540 --> 00:10:16.180
So I've been using it really really like it and you know


00:10:16.180 --> 00:10:20.840
I definitely encourage you to check it out at do dot co slash Python help support the show


00:10:20.840 --> 00:10:23.680
And like I said, I think it's pretty awesome.


00:10:23.680 --> 00:10:25.760
So let's talk about the web for a little bit.


00:10:25.760 --> 00:10:30.960
We've, you know, many times we've touched on asynchronous programming of one variety


00:10:30.960 --> 00:10:35.120
and other threads, multi-processing, async I/O type of things.


00:10:35.120 --> 00:10:42.660
But the truth is that on the web, almost all of the things, all the frameworks are built


00:10:42.660 --> 00:10:48.360
in a way that cannot take advantage of that at all, or very, very rarely, I guess, because


00:10:48.360 --> 00:10:50.160
they're built upon WSGI.


00:10:50.160 --> 00:10:55.760
web service gateway interface. And that basically has a single serial function call for each


00:10:55.760 --> 00:11:02.860
request. And that's that there's really not much of a way to expand or to change how the


00:11:02.860 --> 00:11:08.000
web processing works. So like, if you want to do maybe some async and await on like database


00:11:08.000 --> 00:11:13.680
calls, or against web services, like requests, you could do that with requests, for example,


00:11:13.680 --> 00:11:17.600
that's basically not going to have any effects, it's still going to be blocking somewhere


00:11:17.600 --> 00:11:23.120
along in this WSGI request. There's no way for the server to take advantage of that.


00:11:23.120 --> 00:11:27.080
Some of the servers use threads like micro WSGI, but still it's not nearly the same level


00:11:27.080 --> 00:11:32.000
of benefit. So there's this article I want to series, I guess, that's starting to come


00:11:32.000 --> 00:11:37.480
out here called WSGI is not enough anymore. I'm referencing part one and part two and


00:11:37.480 --> 00:11:42.680
part one really lays out the problem. Basically, there are two problems. One is concurrency,


00:11:42.680 --> 00:11:47.480
right, which I just described. The other problem really is that HTTP isn't the only protocol


00:11:47.480 --> 00:11:53.800
anymore. So things like web sockets and other multi bidirectional communication


00:11:53.800 --> 00:11:57.520
and binary stuff is happening. That's also not supported by WSGI.


00:11:57.520 --> 00:12:02.880
So this article and series sort of explores how do we solve


00:12:02.880 --> 00:12:06.680
this with event-driven programming and they're going to... they're not quite done.


00:12:06.680 --> 00:12:09.520
They're still working on it but I thought it was a cool thing. So the next


00:12:09.520 --> 00:12:13.320
session, the next thing that's coming out is talking about libraries to solve the


00:12:13.320 --> 00:12:14.780
a concurrency problem in Python


00:12:14.780 --> 00:12:17.020
and then onwards to the other things.


00:12:17.020 --> 00:12:17.860
So pretty cool.


00:12:17.860 --> 00:12:19.260
- Yeah, that's very interesting.


00:12:19.260 --> 00:12:21.080
- Yeah, I can't wait for the day when


00:12:21.080 --> 00:12:22.540
these things really unlock,


00:12:22.540 --> 00:12:25.260
because we talk about things like async and await,


00:12:25.260 --> 00:12:26.080
and they're pretty cool,


00:12:26.080 --> 00:12:28.420
but they're really hard to make practical use of.


00:12:28.420 --> 00:12:32.240
Like once the web server requests themselves


00:12:32.240 --> 00:12:34.420
can participate in these async event loops,


00:12:34.420 --> 00:12:36.000
then it's on, right?


00:12:36.000 --> 00:12:37.020
Like it just breaks open


00:12:37.020 --> 00:12:38.900
and all sorts of amazing stuff can happen.


00:12:38.900 --> 00:12:41.060
- So I guess I didn't realize that


00:12:41.060 --> 00:12:44.860
these frameworks couldn't take advantage of web sockets


00:12:44.860 --> 00:12:47.520
or can they with add-on libraries or something?


00:12:47.520 --> 00:12:51.660
- Yeah, you've got to set up some kind of separate server,


00:12:51.660 --> 00:12:53.280
I can't remember what it's called unfortunately,


00:12:53.280 --> 00:12:55.740
but then it can send it over, say,


00:12:55.740 --> 00:12:58.000
you know, we're going to upgrade this to a socket,


00:12:58.000 --> 00:13:00.000
so send it over to the separate process,


00:13:00.000 --> 00:13:01.460
like the separate server type of thing.


00:13:01.460 --> 00:13:03.380
There's a lot of work to juggle


00:13:03.380 --> 00:13:05.160
these different protocols right now.


00:13:05.160 --> 00:13:07.420
So yeah, it'll be nice when that's more seamless.


00:13:07.420 --> 00:13:08.760
- Well, I'll have to follow along with these,


00:13:08.760 --> 00:13:09.600
this is great.


00:13:09.600 --> 00:13:11.760
And for now, we can use things like queues even


00:13:11.760 --> 00:13:13.880
for a little asynchronous concurrency,


00:13:13.880 --> 00:13:15.560
drop off a little job and pick it back up.


00:13:15.560 --> 00:13:18.240
- I was in the looking for a queue,


00:13:18.240 --> 00:13:20.100
a last in, first out queue.


00:13:20.100 --> 00:13:23.200
I needed that for a project I was working on.


00:13:23.200 --> 00:13:24.880
I just needed it as a data structure.


00:13:24.880 --> 00:13:27.460
I didn't have different producers and consumers.


00:13:27.460 --> 00:13:29.640
I just had one part of the program


00:13:29.640 --> 00:13:31.480
where I was collecting stuff


00:13:31.480 --> 00:13:33.600
and another part where I had to get it out


00:13:33.600 --> 00:13:35.000
last in, first out.


00:13:35.000 --> 00:13:36.560
So I was looking around


00:13:36.560 --> 00:13:39.240
and there was an article from Dan Bader


00:13:39.240 --> 00:13:41.880
and it's called queues in Python.


00:13:41.880 --> 00:13:42.920
And it's a decent,


00:13:42.920 --> 00:13:45.520
I guess I'd just forgotten about a lot of this stuff.


00:13:45.520 --> 00:13:48.000
And it kind of goes over lists,


00:13:48.000 --> 00:13:51.480
using how to use queues in Python and how to use them.


00:13:51.480 --> 00:13:54.280
How to use a list, how to use the queue library.


00:13:54.280 --> 00:13:56.900
There's actually a queue built-in library.


00:13:56.900 --> 00:14:01.520
And the collections deck also is something you can use.


00:14:01.520 --> 00:14:03.960
The deck is a doubly linked list.


00:14:03.960 --> 00:14:06.200
And then it talks about pretty much how to use them.


00:14:06.200 --> 00:14:07.960
And it's a pretty good article.


00:14:07.960 --> 00:14:12.840
And it mentions that you can use all of these for last and first out, but I didn't, I didn't


00:14:12.840 --> 00:14:14.000
quite know how to use those.


00:14:14.000 --> 00:14:19.700
So I went ahead and explored all the different ways to use these three, as or just a way


00:14:19.700 --> 00:14:25.520
to use these three as a last and first out queue, and threw it in, in the show notes.


00:14:25.520 --> 00:14:27.160
So yeah, it's really cool, really simple.


00:14:27.160 --> 00:14:31.000
I think, you know, knowing about data structures, and especially knowing about the built in


00:14:31.000 --> 00:14:32.620
ones is really valuable.


00:14:32.620 --> 00:14:36.920
And I feel like we've been doing Python for a long time, but I still continuously learn


00:14:36.920 --> 00:14:37.920
about these things.


00:14:37.920 --> 00:14:41.680
>> It's good to come back when you start using the data structures you're just using all


00:14:41.680 --> 00:14:46.200
the time and you need something else, going ahead and looking what's around is neat.


00:14:46.200 --> 00:14:48.880
I was also curious about timing.


00:14:48.880 --> 00:14:54.520
So I went ahead on a sample program and timed all these to see with like some huge objects


00:14:54.520 --> 00:14:59.540
I was throwing in there to see if any of them were faster or slower.


00:14:59.540 --> 00:15:03.160
And with small objects, they're all kind of about the same.


00:15:03.160 --> 00:15:07.640
with large objects, it looks like the the collections deck is a


00:15:07.640 --> 00:15:11.680
tad bit faster for my use, but none of them are really out of


00:15:11.680 --> 00:15:15.520
the ballpark slower. So to me, the deck has the best just the


00:15:15.520 --> 00:15:18.840
best interface because you can just iterate over it when it


00:15:18.840 --> 00:15:21.960
looks cleaner. But that was my opinion. Yeah, that's really


00:15:21.960 --> 00:15:25.640
cool. Thanks for for pointing that out. All right, I want to


00:15:25.640 --> 00:15:30.040
sort of close this out with something kind of meta. So on


00:15:30.040 --> 00:15:33.340
our podcast, I want to talk about a new podcast. So a guy


00:15:33.340 --> 00:15:38.260
named Mark Weiss created a podcast called using reflection,


00:15:38.260 --> 00:15:42.280
a podcast about humans and engineering. So he started out


00:15:42.280 --> 00:15:46.700
interviewing Jesse Davis from MongoDB, one of the main Python


00:15:46.700 --> 00:15:50.700
guys in the space. So there's a really cool interview about him.


00:15:50.700 --> 00:15:53.820
And if you're thinking about you want to look at these notable


00:15:53.820 --> 00:15:57.160
people on how they've become leaders within their companies


00:15:57.160 --> 00:15:59.180
or within their industry, and you want to sort of explore that


00:15:59.180 --> 00:16:02.900
journey with him. It's a pretty cool podcast so I thought I'd give a shout out to it.


00:16:02.900 --> 00:16:08.140
I listened to a couple episodes and I like his interview style and it's very conversational


00:16:08.140 --> 00:16:09.940
and laid back. It's cool.


00:16:09.940 --> 00:16:13.060
Yeah, it's like you just kick back, grab a coffee with the two guys and you just don't


00:16:13.060 --> 00:16:14.460
say anything because they can't hear you.


00:16:14.460 --> 00:16:15.460
Yeah.


00:16:15.460 --> 00:16:16.460
You can say stuff but they still don't hear you.


00:16:16.460 --> 00:16:17.460
Yeah.


00:16:17.460 --> 00:16:22.220
Yeah, who knows? That's awesome. All right, so yeah, check out Using Reflection. It's


00:16:22.220 --> 00:16:26.180
a cool podcast. All right, so I guess that's it for our news this week, Brian. Anything


00:16:26.180 --> 00:16:28.260
else you got you want to share with the people?


00:16:28.260 --> 00:16:29.540
I got nothing this week.


00:16:29.540 --> 00:16:32.020
No more book writing, just hanging out at the zoo now, huh?


00:16:32.020 --> 00:16:32.860
That was fun.


00:16:32.860 --> 00:16:36.020
If your idea of fun is trying to herd six eight-year-olds


00:16:36.020 --> 00:16:38.660
around a zoo for a day, then it was fun.


00:16:38.660 --> 00:16:39.620
Give me a tricky bug.


00:16:39.620 --> 00:16:42.460
I'll take that instead.


00:16:42.460 --> 00:16:46.380
Yeah, so last week I talked about I announced my free MongoDB


00:16:46.380 --> 00:16:49.180
course at freemongodbcourse.com.


00:16:49.180 --> 00:16:51.020
And that thing has been going super well.


00:16:51.020 --> 00:16:53.580
Over 5,000 people have taken that course in a week.


00:16:53.580 --> 00:16:54.580
That's pretty amazing.


00:16:54.580 --> 00:16:59.580
I have to admit that I was doing your longer Mongo course,


00:16:59.580 --> 00:17:01.700
and I thought I'd watch this first,


00:17:01.700 --> 00:17:03.520
so I've started it myself.


00:17:03.520 --> 00:17:05.280
I'm one of those sign-ups.


00:17:05.280 --> 00:17:07.440
- Oh, cool, you're like,


00:17:07.440 --> 00:17:09.200
I don't know what that percent is.


00:17:09.200 --> 00:17:11.120
So, cool, very nice.


00:17:11.120 --> 00:17:12.320
Yeah, people seem to be enjoying it,


00:17:12.320 --> 00:17:14.720
so I'm glad everyone could take advantage of it.


00:17:14.720 --> 00:17:15.920
- I'm glad you put that out there.


00:17:15.920 --> 00:17:17.760
It's really cool, and people should check it out.


00:17:17.760 --> 00:17:19.000
- Yep, thanks.


00:17:19.000 --> 00:17:21.440
All right, well, I guess until next week, Brian.


00:17:21.440 --> 00:17:22.680
- Yeah, talk to you next week.


00:17:22.680 --> 00:17:24.120
- All right, talk to you next week.


00:17:24.120 --> 00:17:27.360
Thank you for listening to Python Bytes.


00:17:27.360 --> 00:17:33.000
Follow the show on Twitter via @pythonbytes, that's Python Bytes as in B-Y-T-E-S.


00:17:33.000 --> 00:17:36.280
And get the full show notes at pythonbytes.fm.


00:17:36.280 --> 00:17:40.000
If you have a news item you want featured, just visit pythonbytes.fm and send it our


00:17:40.000 --> 00:17:41.000
way.


00:17:41.000 --> 00:17:43.500
We're always on the lookout for sharing something cool.


00:17:43.500 --> 00:17:46.960
On behalf of myself and Brian Okken, this is Michael Kennedy.


00:17:46.960 --> 00:17:50.000
Thank you for listening and sharing this podcast with your friends and colleagues.

