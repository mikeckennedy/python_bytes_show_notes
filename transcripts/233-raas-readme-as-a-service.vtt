
00:00:00.000 --> 00:00:02.400
>> Hello and welcome to Python Bytes,


00:00:02.400 --> 00:00:05.680
where we deliver news and headlines directly to your earbuds.


00:00:05.680 --> 00:00:07.960
This is Episode 233,


00:00:07.960 --> 00:00:11.320
recorded May 12th, 2021, and I'm Brian Ockett.


00:00:11.320 --> 00:00:12.640
>> I'm Michael Kennedy.


00:00:12.640 --> 00:00:14.360
>> I'm Marlene Mangami.


00:00:14.360 --> 00:00:15.760
>> Well, welcome Marlene.


00:00:15.760 --> 00:00:17.100
For people who don't know you,


00:00:17.100 --> 00:00:18.600
can you introduce who you are?


00:00:18.600 --> 00:00:22.440
>> I am a Pythonista, of course.


00:00:22.440 --> 00:00:26.280
Based in Harare, Zimbabwe,


00:00:26.280 --> 00:00:30.000
I am also really involved with the Python community.


00:00:30.000 --> 00:00:34.400
So I'm currently the vice chair of the PSA board of directors.


00:00:34.400 --> 00:00:41.600
The board I think for about coming up on four years now, which is really exciting and it's


00:00:41.600 --> 00:00:45.320
been really a very cool experience for me.


00:00:45.320 --> 00:00:47.880
I'm also a software engineer.


00:00:47.880 --> 00:00:53.240
I work right now with the RAPIDS team at NVIDIA and have just been doing software engineering


00:00:53.240 --> 00:00:54.240
with them.


00:00:54.240 --> 00:00:56.140
and we'll talk a bit about that later.


00:00:56.140 --> 00:00:59.480
But yeah, I'm trying to think what else.


00:00:59.480 --> 00:01:01.780
I'm also a very avid reader


00:01:01.780 --> 00:01:05.080
and just like doing other things besides software.


00:01:05.080 --> 00:01:08.040
So yeah, that's pretty much me.


00:01:08.040 --> 00:01:08.880
- Cool.


00:01:08.880 --> 00:01:09.700
- That's awesome.


00:01:09.700 --> 00:01:10.960
You're doing a bunch of cool stuff.


00:01:10.960 --> 00:01:12.840
I think RAPID seems like a really neat project


00:01:12.840 --> 00:01:14.580
to work on as well.


00:01:14.580 --> 00:01:17.240
Of course, the Python community side is great.


00:01:17.240 --> 00:01:19.180
So super happy to have you here.


00:01:19.180 --> 00:01:21.640
Brian, you know, having a good readme


00:01:21.640 --> 00:01:23.760
is really important to a project, wouldn't you say?


00:01:23.760 --> 00:01:28.800
>> Yeah, definitely. For some reason, I don't know.


00:01:28.800 --> 00:01:30.320
Readmes are not difficult to write,


00:01:30.320 --> 00:01:31.760
but I freeze up.


00:01:31.760 --> 00:01:33.700
It's a blank page syndrome, I think.


00:01:33.700 --> 00:01:37.760
Often I've gone through and just copied from some other project.


00:01:37.760 --> 00:01:39.740
What's in there, Readme?


00:01:39.740 --> 00:01:43.600
But I don't think that that's the best way to go about it,


00:01:43.600 --> 00:01:46.680
really, because sometimes you forget stuff.


00:01:46.680 --> 00:01:49.680
We have a recommendation from Johnny Metz.


00:01:49.680 --> 00:01:53.080
It's a tool called Readme.so.


00:01:53.080 --> 00:01:56.400
This is totally fun.


00:01:56.400 --> 00:02:01.040
It's just this interactive thing where you get to add stuff.


00:02:01.040 --> 00:02:02.640
We've got the title.


00:02:02.640 --> 00:02:05.640
On the left-hand side, there's a bunch of sections where you can


00:02:05.640 --> 00:02:09.680
select what you want to go into the README.


00:02:09.680 --> 00:02:12.640
Then it shows a preview on the right,


00:02:12.640 --> 00:02:15.560
but you can also see the raw markdown.


00:02:15.560 --> 00:02:17.120
Then in the middle, there's an editor,


00:02:17.120 --> 00:02:19.280
so you can actually just edit the whole thing here.


00:02:19.280 --> 00:02:21.960
But really, I don't know if I really would.


00:02:21.960 --> 00:02:24.680
>> Project title.


00:02:24.680 --> 00:02:27.600
What I'd probably do is go through and pick


00:02:27.600 --> 00:02:30.360
out to look at what things I'd want.


00:02:30.360 --> 00:02:32.120
I'd probably maybe some acknowledgments


00:02:32.120 --> 00:02:35.060
if I got some help from somebody.


00:02:35.060 --> 00:02:39.180
Maybe an API reference if it's a library.


00:02:39.180 --> 00:02:41.360
How to contribute.


00:02:41.360 --> 00:02:43.760
Badges, definitely want badges.


00:02:43.760 --> 00:02:44.560
>> Yeah.


00:02:44.560 --> 00:02:49.720
>> Then maybe how to run tests if you want to contribute.


00:02:49.720 --> 00:02:52.360
If there's other cool projects using it,


00:02:52.360 --> 00:02:54.880
I'd want to use by all these things.


00:02:54.880 --> 00:02:57.160
The editor only selects,


00:02:57.160 --> 00:03:01.080
it only shows you the ones one at a time, which is nice.


00:03:01.080 --> 00:03:05.360
But then you've got this whole generated really nice looking,


00:03:05.360 --> 00:03:09.120
read me what tables and everything built in,


00:03:09.120 --> 00:03:10.640
and you can either just copy it or


00:03:10.640 --> 00:03:12.880
download it and just run with it.


00:03:12.880 --> 00:03:14.920
I think this is really great.


00:03:14.920 --> 00:03:16.400
I'll probably use this in the future.


00:03:16.400 --> 00:03:19.320
>> I really love this and I'm surprised about


00:03:19.320 --> 00:03:23.120
the psychological benefit of just showing the little,


00:03:23.120 --> 00:03:24.800
the section with the one heading.


00:03:24.800 --> 00:03:26.720
So for like example, acknowledgments,


00:03:26.720 --> 00:03:29.840
you just have #acknowledgements and the few things,


00:03:29.840 --> 00:03:31.360
even though you're editing the whole readme,


00:03:31.360 --> 00:03:32.760
it seems so much more like,


00:03:32.760 --> 00:03:34.260
oh, I'm gonna just work on that section.


00:03:34.260 --> 00:03:35.320
It's really cool.


00:03:35.320 --> 00:03:36.360
Marlene, what do you think?


00:03:36.360 --> 00:03:37.740
- It's really, really cool.


00:03:37.740 --> 00:03:38.580
I like it.


00:03:38.580 --> 00:03:40.160
I think I'm gonna try it out.


00:03:40.160 --> 00:03:45.160
I have put no effort at all in this.


00:03:45.960 --> 00:03:49.440
So I think it's something I need to put more effort into


00:03:49.440 --> 00:03:52.440
and this looks like a really good way to do that.


00:03:52.440 --> 00:03:53.280
- Yeah.


00:03:53.280 --> 00:03:55.360
- I think that it would also be great to just,


00:03:55.360 --> 00:03:56.760
like if you have an existing readme


00:03:56.760 --> 00:03:58.040
and you wanna add some new sections,


00:03:58.040 --> 00:03:59.860
you're not quite sure how it should look,


00:03:59.860 --> 00:04:02.040
using this as a jumping point of just


00:04:02.040 --> 00:04:04.960
to grab sections of a readme to add to an existing one too,


00:04:04.960 --> 00:04:06.360
this would be great.


00:04:06.360 --> 00:04:08.520
- Yeah, this is really, really cool.


00:04:08.520 --> 00:04:12.480
How do you, how do you, can you start with a new one?


00:04:12.480 --> 00:04:14.040
Like can I, well, sorry, let me take it back.


00:04:14.040 --> 00:04:15.520
Can I start with an existing one?


00:04:15.520 --> 00:04:17.780
Can I somehow upload an existing one?


00:04:17.780 --> 00:04:18.620
I don't see.


00:04:18.620 --> 00:04:19.620
- I don't think so.


00:04:19.620 --> 00:04:22.520
- Wait, I can go to raw, hold on.


00:04:22.520 --> 00:04:24.120
- Oh, you can probably just drop it into raw.


00:04:24.120 --> 00:04:26.620
- Maybe, yes, you can drop it into the raw, that's it.


00:04:26.620 --> 00:04:27.560
Okay, perfect.


00:04:27.560 --> 00:04:29.700
You go to raw, which it doesn't hide the sections.


00:04:29.700 --> 00:04:31.000
It's just pure markdown.


00:04:31.000 --> 00:04:31.940
And then you just throw it in there.


00:04:31.940 --> 00:04:32.880
Okay.


00:04:32.880 --> 00:04:34.480
- But you can't edit there.


00:04:34.480 --> 00:04:36.080
- No, no, but you can flip it back, I think,


00:04:36.080 --> 00:04:37.920
probably once you edit it there.


00:04:37.920 --> 00:04:39.120
- I don't think you can edit.


00:04:39.120 --> 00:04:42.000
So you can only edit in the editor part.


00:04:42.000 --> 00:04:42.840
So.


00:04:42.840 --> 00:04:44.400
- Yeah, it still looks really, really cool.


00:04:44.400 --> 00:04:46.480
I've heard of platform as a service.


00:04:46.480 --> 00:04:49.200
I've heard of infrastructure of a service.


00:04:49.200 --> 00:04:50.760
I've heard of database as a service,


00:04:50.760 --> 00:04:52.400
but I guess now we have readme as a service.


00:04:52.400 --> 00:04:54.040
I don't know, you just go to the website.


00:04:54.040 --> 00:04:55.400
(laughing)


00:04:55.400 --> 00:04:57.120
- Exactly. - That's pretty cool.


00:04:57.120 --> 00:04:59.040
- Yeah, I'm pretty excited about this.


00:04:59.040 --> 00:05:02.760
Actually, I might play around with this for my next project.


00:05:02.760 --> 00:05:06.080
I've got some stuff that may end up on PyPI soon


00:05:06.080 --> 00:05:07.360
and it'd be cool to do it.


00:05:07.360 --> 00:05:09.400
All right, so I've got the next item


00:05:09.400 --> 00:05:13.360
and it's a bit of a skateboarding dog type of thing.


00:05:13.360 --> 00:05:14.560
It's not something I think a lot of us


00:05:14.560 --> 00:05:15.520
will take advantage of,


00:05:15.520 --> 00:05:17.520
but it's something that is pretty interesting


00:05:17.520 --> 00:05:21.920
as we kind of look at how Python is finding its way


00:05:21.920 --> 00:05:23.920
into the larger computing space.


00:05:23.920 --> 00:05:26.260
Yeah, and oh, Sam Morley out there


00:05:26.260 --> 00:05:27.840
on the live stream before we move on says,


00:05:27.840 --> 00:05:29.160
"It'd be really cool if you could point this


00:05:29.160 --> 00:05:32.660
"at a GitHub repo and edit your repo directly,


00:05:32.660 --> 00:05:34.400
"the readme directly on your repo."


00:05:34.400 --> 00:05:36.660
Yes, absolutely, that's fantastic.


00:05:36.660 --> 00:05:39.880
Yeah, it's a really good idea, really good idea.


00:05:39.880 --> 00:05:41.840
All right, back to my skateboarding dog.


00:05:41.840 --> 00:05:44.840
So there's a company called Cerebras,


00:05:44.840 --> 00:05:49.720
and this was sent over to us by Galen Swint,


00:05:49.720 --> 00:05:51.120
who is a PhD researcher


00:05:51.120 --> 00:05:53.920
who does high-performance computing and stuff.


00:05:53.920 --> 00:05:57.840
So in that world, I think this may be a real thing.


00:05:57.840 --> 00:05:59.400
You look through the article here


00:05:59.400 --> 00:06:00.760
that talks about this announcement,


00:06:00.760 --> 00:06:03.120
and it's like, well, there's like these 12 customers


00:06:03.120 --> 00:06:06.160
or 15 customers of this chip.


00:06:06.160 --> 00:06:07.520
But for those of you watching,


00:06:07.520 --> 00:06:09.200
or you check out the article,


00:06:09.200 --> 00:06:11.280
there's a woman holding a chip.


00:06:11.280 --> 00:06:12.640
And normally we think of computer chips


00:06:12.640 --> 00:06:13.840
as little tiny things.


00:06:13.840 --> 00:06:17.500
This is a 12 inch by 12 inch computer chip,


00:06:17.500 --> 00:06:21.200
or you wanna go metric 30 centimeters by 30 centimeters.


00:06:21.200 --> 00:06:24.020
It is a big, big computer chip.


00:06:24.020 --> 00:06:27.640
And the idea is we've had small little chips come along


00:06:27.640 --> 00:06:29.480
to do special types of processing.


00:06:29.480 --> 00:06:32.320
We've had GPUs come along and do,


00:06:32.320 --> 00:06:35.680
be adapted, I guess, for things like machine learning,


00:06:35.680 --> 00:06:38.040
training machine learning models and so on.


00:06:38.040 --> 00:06:41.520
this thing just takes that idea to an entire new level.


00:06:41.520 --> 00:06:44.260
So for example, I'm always going on and on


00:06:44.260 --> 00:06:47.240
and raving about my Mac mini, my M1,


00:06:47.240 --> 00:06:49.880
where it's a cheap little computer


00:06:49.880 --> 00:06:53.760
relative to Apple stuff, I guess, but it's super fast.


00:06:53.760 --> 00:06:55.860
But it has four performance cores


00:06:55.860 --> 00:06:58.480
and four efficiency cores, that's it.


00:06:58.480 --> 00:07:00.300
Your GPU, if you've got a really high-end one,


00:07:00.300 --> 00:07:02.040
might have 4,000 cores.


00:07:02.040 --> 00:07:07.040
This insane little chip here has 850,000 AI cores


00:07:07.180 --> 00:07:09.220
on one chip, is that insane?


00:07:09.220 --> 00:07:10.620
What do you think?


00:07:10.620 --> 00:07:12.740
- I'm curious how they, I mean,


00:07:12.740 --> 00:07:16.100
this is some major advances in wafer technology


00:07:16.100 --> 00:07:18.300
'cause how do you get that big of a chip


00:07:18.300 --> 00:07:19.860
with no defects in it?


00:07:19.860 --> 00:07:23.340
- Yeah, and they have apparently 100% efficiency.


00:07:23.340 --> 00:07:25.300
Well, first of all, one of the ways you do it


00:07:25.300 --> 00:07:28.060
is you use the TSMC foundry,


00:07:28.060 --> 00:07:30.100
who seems to be taking over all these small,


00:07:30.100 --> 00:07:32.300
high efficiency type of things.


00:07:32.300 --> 00:07:34.300
And so they had a previous one


00:07:34.300 --> 00:07:37.060
that they've more than doubled the core count for.


00:07:37.060 --> 00:07:39.340
And another way to kind of appreciate


00:07:39.340 --> 00:07:41.420
like how much is going on in this chip,


00:07:41.420 --> 00:07:43.940
I, you know, go back to my M1,


00:07:43.940 --> 00:07:48.100
it has 0016 billion transistors.


00:07:48.100 --> 00:07:49.780
This has 2.6 trillion.


00:07:49.780 --> 00:07:51.020
Or is that another way?


00:07:51.020 --> 00:07:55.500
2,600 billion, yeah, billion transistors versus 1.6 billion.


00:07:55.500 --> 00:07:58.940
Like it's 2000 times more on this chip.


00:07:58.940 --> 00:08:00.100
So super, super cool.


00:08:00.100 --> 00:08:01.060
And now you may be wondering,


00:08:01.060 --> 00:08:03.340
all right, all this is interesting and tips are neat.


00:08:03.340 --> 00:08:05.340
What is the Python angle?


00:08:05.340 --> 00:08:08.060
Like why would I bother putting this on here?


00:08:08.060 --> 00:08:10.180
'Cause you know, we don't really talk about chips that much


00:08:10.180 --> 00:08:12.340
except for when I go on and on about my M1.


00:08:12.340 --> 00:08:13.420
Here's the deal, if you scroll down


00:08:13.420 --> 00:08:14.780
in this article a little bit,


00:08:14.780 --> 00:08:17.900
you'll see users program this insane machine


00:08:17.900 --> 00:08:20.780
transparently in machine learning frameworks


00:08:20.780 --> 00:08:24.260
such as specifically TensorFlow and PyTorch.


00:08:24.260 --> 00:08:25.220
- Sweet.


00:08:25.220 --> 00:08:26.340
- Isn't that crazy?


00:08:26.340 --> 00:08:28.220
- That's really interesting.


00:08:28.220 --> 00:08:29.060
- Isn't it?


00:08:29.060 --> 00:08:30.220
Yeah, I was just thinking about you


00:08:30.220 --> 00:08:31.060
as I'm going through this


00:08:31.060 --> 00:08:32.700
'cause you're working on the Rapids project,


00:08:32.700 --> 00:08:34.780
which is not the same thing obviously,


00:08:34.780 --> 00:08:37.320
but it's kind of in that space, right?


00:08:37.320 --> 00:08:38.440
- Yeah, it is.


00:08:38.440 --> 00:08:39.940
- Have you heard of this before?


00:08:39.940 --> 00:08:41.480
- No, I haven't heard of this.


00:08:41.480 --> 00:08:44.100
This is, yeah, this is really big


00:08:44.100 --> 00:08:46.100
and I have not heard of it.


00:08:46.100 --> 00:08:49.620
I will definitely be reading a bit more about it after.


00:08:49.620 --> 00:08:51.300
- Yeah, yeah, for sure.


00:08:51.300 --> 00:08:52.740
So there's a lot of interesting things.


00:08:52.740 --> 00:08:54.360
And one of the, I can't remember


00:08:54.360 --> 00:08:56.000
where exactly they spoke about it,


00:08:56.000 --> 00:08:59.080
but they basically say, what you do is you program


00:08:59.080 --> 00:09:01.140
in TensorFlow and PyTorch as normal.


00:09:01.140 --> 00:09:03.140
And then they have this custom compiler


00:09:03.140 --> 00:09:08.140
that rewrites, that extracts this execution graph


00:09:08.140 --> 00:09:11.980
to actually scale out to the 850,000 cores


00:09:11.980 --> 00:09:15.020
so the developers don't have to think about


00:09:15.020 --> 00:09:17.460
how they program against something like this.


00:09:17.460 --> 00:09:18.700
I don't wanna spend too much time on this


00:09:18.700 --> 00:09:20.980
'cause there's something, my next item is super amazing


00:09:20.980 --> 00:09:22.820
and I wanna take the time to dive into it.


00:09:22.820 --> 00:09:25.780
But there's another thing that's really interesting,


00:09:25.780 --> 00:09:27.020
just as you look at it,


00:09:27.020 --> 00:09:30.100
like this thing takes an insane amount of power,


00:09:30.100 --> 00:09:32.140
like oh, for this one chip,


00:09:32.140 --> 00:09:35.720
you're gonna need a four kilowatt power supply


00:09:35.720 --> 00:09:39.060
with up to a peak power of 23 kilowatts.


00:09:39.060 --> 00:09:39.900
- Yeah.


00:09:39.900 --> 00:09:40.720
- Oh wow.


00:09:40.720 --> 00:09:43.640
- I mean, when you plug in an electric car


00:09:43.640 --> 00:09:45.200
at one of the high speed home chargers,


00:09:45.200 --> 00:09:47.760
that's seven kilowatts, just to give you a sense.


00:09:47.760 --> 00:09:51.180
This is like insane amounts for one chip, right?


00:09:51.180 --> 00:09:52.280
You could think of it as a super computer,


00:09:52.280 --> 00:09:53.560
like it's one chip.


00:09:53.560 --> 00:09:54.400
So anyway.


00:09:54.400 --> 00:09:59.000
- Yeah, our entire lab doesn't draw that much, so.


00:09:59.000 --> 00:10:01.840
- So I call, the reason I said it's a skateboarding dog


00:10:01.840 --> 00:10:06.400
I don't think most of us will be able to ever even interact with one of these, much less buy one.


00:10:06.400 --> 00:10:13.640
They're going to be shipping in the later part of this year and the price is something like 3 million US dollars plus.


00:10:13.640 --> 00:10:22.440
So this is certainly super computer level, but I do think it opens the door for really interesting stuff going on in the high performance Python space.


00:10:22.440 --> 00:10:25.200
So yeah, glad that Galen sent it over.


00:10:25.200 --> 00:10:30.040
Well, I'm totally going to put 25 bucks into Dogecoin so that I can afford this later this year.


00:10:30.040 --> 00:10:31.640
- Yeah. - Speaking of which.


00:10:31.640 --> 00:10:32.840
(laughing)


00:10:32.840 --> 00:10:33.680
Exactly.


00:10:33.680 --> 00:10:35.880
Well, what about, I think maybe you get this


00:10:35.880 --> 00:10:38.360
and you create an AI that can more intelligently


00:10:38.360 --> 00:10:40.760
mine Dogecoin and then you take over the world.


00:10:40.760 --> 00:10:43.160
Just an investment.


00:10:43.160 --> 00:10:44.760
- Yeah. - Just an investment.


00:10:44.760 --> 00:10:46.720
All right, so speaking of large-scale


00:10:46.720 --> 00:10:49.800
high-performance computing, Marlene, take it away.


00:10:49.800 --> 00:10:53.400
- Sure, I have the next item, which is RAPIDS.


00:10:53.400 --> 00:10:58.040
And I wanted to speak about this because I'm working on it


00:10:58.040 --> 00:11:01.200
and it's what I've been working on for, I think, yeah,


00:11:01.200 --> 00:11:06.200
well, it's been about a year since I have been with NVIDIA,


00:11:06.200 --> 00:11:09.520
working as a software engineer there


00:11:09.520 --> 00:11:12.640
and working specifically on the Rapids project.


00:11:12.640 --> 00:11:15.400
And so Rapids, I think is really interesting


00:11:15.400 --> 00:11:19.400
because the goal of Rapids, similarly,


00:11:19.400 --> 00:11:21.680
like the last thing Michael just showed us


00:11:21.680 --> 00:11:25.440
is to speed up data science, but this is with GPUs.


00:11:25.440 --> 00:11:32.940
So I think it's been really cool to work on the RAPIDS project,


00:11:32.940 --> 00:11:37.240
and I think it's really interesting as well because it's open source.


00:11:37.240 --> 00:11:40.280
It's also there's a lot of Python involved.


00:11:40.280 --> 00:11:44.900
So it's not entirely, it's not mostly Python.


00:11:44.900 --> 00:11:49.100
Actually, there's a lot of C++ and Cuda code in there as well.


00:11:49.500 --> 00:11:53.620
But I am not, you know, personally, I'm not, I'm not,


00:11:53.620 --> 00:11:55.500
my aim is not to learn CUDA,


00:11:55.500 --> 00:11:58.480
it's to try and avoid that as much as possible.


00:11:58.480 --> 00:12:01.620
And also avoid as much C++ as possible,


00:12:01.620 --> 00:12:04.080
so that's a bit more reasonable.


00:12:04.080 --> 00:12:07.460
But one of the goals of the RAPIDS project


00:12:07.460 --> 00:12:11.160
is to allow people who are Pythonistas


00:12:11.160 --> 00:12:16.120
to work primarily with GPUs and to get those speed ups


00:12:16.120 --> 00:12:18.820
without having to know any CUDA code


00:12:18.820 --> 00:12:22.420
or to know any C++.


00:12:22.420 --> 00:12:26.380
And so I have been working primarily on the Python side


00:12:26.380 --> 00:12:29.660
of things and have really been enjoying it.


00:12:29.660 --> 00:12:34.660
I work specifically on with the QDF DataFrame library


00:12:34.660 --> 00:12:39.580
and QDF is basically a, it mirrors,


00:12:39.580 --> 00:12:43.380
it's a GPU DataFrame library that mirrors pandas.


00:12:43.380 --> 00:12:47.600
So if you have a dataset and you'd like to do computations


00:12:47.600 --> 00:12:51.760
on your dataset or do different operations on your dataset.


00:12:51.760 --> 00:12:54.280
If you can do that with pandas,


00:12:54.280 --> 00:12:58.280
you should be able hopefully to do the same thing with 3DF.


00:12:58.280 --> 00:13:03.160
But the good thing is that it will probably be faster.


00:13:03.160 --> 00:13:07.320
I actually can't definitively say that it will be faster


00:13:07.320 --> 00:13:12.040
because I remember when I first joined the project as well,


00:13:12.040 --> 00:13:17.520
I'm very enthusiastic and I really enjoy sharing


00:13:17.520 --> 00:13:19.400
when I'm learning something new.


00:13:19.400 --> 00:13:22.760
And I remember I was like going around and speaking


00:13:22.760 --> 00:13:24.600
and saying that, you know,


00:13:24.600 --> 00:13:26.780
Kudieff is so much better than Pandas


00:13:26.780 --> 00:13:29.280
because it's just so much faster.


00:13:29.280 --> 00:13:31.680
And then my manager was just like,


00:13:31.680 --> 00:13:33.280
you need to stop saying that


00:13:33.280 --> 00:13:36.560
because it's not true all of the time.


00:13:36.560 --> 00:13:38.580
It's true most, like some of the time.


00:13:38.580 --> 00:13:40.720
So for smaller data sets,


00:13:40.720 --> 00:13:44.960
it's probably better to stick with Pandas


00:13:46.240 --> 00:13:47.440
because the--


00:13:47.440 --> 00:13:49.040
- Yeah, there's always this overhead, right?


00:13:49.040 --> 00:13:51.720
Like, as you scale things out and stuff,


00:13:51.720 --> 00:13:54.040
there's probably like, well, how do we convert this over


00:13:54.040 --> 00:13:55.360
and get it onto the GPU?


00:13:55.360 --> 00:13:58.720
And if that process takes half the time of what,


00:13:58.720 --> 00:14:00.240
just doing the computation,


00:14:00.240 --> 00:14:01.760
you might as well just do the computation, right?


00:14:01.760 --> 00:14:02.600
- Exactly.


00:14:02.600 --> 00:14:05.280
Like, if you're already, if you're mainly doing,


00:14:05.280 --> 00:14:06.120
right, I agree.


00:14:06.120 --> 00:14:08.680
Like, if you're working with smaller data sets


00:14:08.680 --> 00:14:11.440
and you are fine with that and that works for you


00:14:11.440 --> 00:14:14.880
and your time is not being wasted a lot,


00:14:14.880 --> 00:14:17.960
then I would say, please go ahead and stick with Pandas.


00:14:17.960 --> 00:14:22.520
But if you are working on larger datasets,


00:14:22.520 --> 00:14:24.860
and the larger your datasets get,


00:14:24.860 --> 00:14:26.480
the more the difference is gonna be


00:14:26.480 --> 00:14:27.640
in terms of your speedup.


00:14:27.640 --> 00:14:29.720
So with very large datasets,


00:14:29.720 --> 00:14:32.520
QDF is gonna take a much shorter time


00:14:32.520 --> 00:14:34.960
to do computations and things like that.


00:14:34.960 --> 00:14:37.080
- Yeah, you actually put a really interesting example


00:14:37.080 --> 00:14:38.880
in the show notes here, right?


00:14:38.880 --> 00:14:41.140
Showing how many zeros is that?


00:14:41.140 --> 00:14:44.560
100 million items or something like that?


00:14:44.560 --> 00:14:45.760
- Yeah, it's a hundred million.


00:14:45.760 --> 00:14:49.120
I just kind of like randomly chose a number


00:14:49.120 --> 00:14:50.320
to try and make it like,


00:14:50.320 --> 00:14:53.060
I didn't also want to take a number that was too big


00:14:53.060 --> 00:14:58.060
because I didn't want to spend like a long time doing it.


00:14:58.060 --> 00:15:00.280
And I know like for a lot of data scientists,


00:15:00.280 --> 00:15:02.640
like I think increasingly people are working


00:15:02.640 --> 00:15:04.980
with larger and larger data sets,


00:15:04.980 --> 00:15:06.880
just depending which field you're in.


00:15:06.880 --> 00:15:08.800
For the example, I put it on the show notes


00:15:08.800 --> 00:15:11.080
and it's on the screen right now.


00:15:11.080 --> 00:15:13.920
But if you take a pound is sort of data frame


00:15:13.920 --> 00:15:15.800
and try and calculate the mean,


00:15:15.800 --> 00:15:18.760
and you take the same QDF dataset


00:15:18.760 --> 00:15:20.300
and try and calculate the mean,


00:15:20.300 --> 00:15:23.240
it will take, I think, I'm trying to look at the notes,


00:15:23.240 --> 00:15:27.640
it's 105 milliseconds for pandas,


00:15:27.640 --> 00:15:31.840
and it's like 1.83 milliseconds for QDF,


00:15:31.840 --> 00:15:32.680
which is just--


00:15:32.680 --> 00:15:33.520
- That's awesome.


00:15:33.520 --> 00:15:35.920
- And that's like a smaller scale, I would say,


00:15:35.920 --> 00:15:38.180
dataset compared to some people.


00:15:38.180 --> 00:15:41.720
- Yeah, just 100 million, I don't know.


00:15:41.720 --> 00:15:44.380
- It's just 100 million, so it's not a lot.


00:15:44.380 --> 00:15:47.340
I mean, it depends, but yeah,


00:15:47.340 --> 00:15:49.420
I think it's definitely significant


00:15:49.420 --> 00:15:51.140
once you get to a certain threshold,


00:15:51.140 --> 00:15:52.140
which is pretty cool.


00:15:52.140 --> 00:15:52.980
- Yeah. - Yeah.


00:15:52.980 --> 00:15:55.500
- Yeah, over on the Rapid site, it's a Rapid site AI,


00:15:55.500 --> 00:15:58.300
it says it scales out on multiple GPUs,


00:15:58.300 --> 00:16:01.180
so seamlessly scale from a GPU workstation


00:16:01.180 --> 00:16:04.620
to multi GPU servers and multi node clusters


00:16:04.620 --> 00:16:05.900
working with Dask as well.


00:16:05.900 --> 00:16:07.940
So that's, you know, Dask is also kind of


00:16:07.940 --> 00:16:09.820
about scaling pandas and combining those,


00:16:09.820 --> 00:16:10.780
that's pretty awesome.


00:16:10.780 --> 00:16:15.000
- I actually saw that you have a DOS course out,


00:16:15.000 --> 00:16:16.260
like I recently saw it.


00:16:16.260 --> 00:16:17.100
- Yes.


00:16:17.100 --> 00:16:18.260
- Definitely gonna take that.


00:16:18.260 --> 00:16:19.100
'Cause I mean--


00:16:19.100 --> 00:16:19.940
- Yeah, check it out.


00:16:19.940 --> 00:16:21.880
- I'll be diving into DOS a bit later.


00:16:21.880 --> 00:16:22.920
- Awesome, yeah, yeah.


00:16:22.920 --> 00:16:25.400
We put that together with Matthew Rocklin


00:16:25.400 --> 00:16:27.820
and team over at Coiled.


00:16:27.820 --> 00:16:28.840
Yeah, and that's actually free,


00:16:28.840 --> 00:16:30.720
so people can just drop in and take that course.


00:16:30.720 --> 00:16:32.840
I think maybe I can put it in the show notes at the end.


00:16:32.840 --> 00:16:35.520
I think it was just announced, let's see.


00:16:35.520 --> 00:16:36.440
- Very cool.


00:16:36.440 --> 00:16:37.960
- No, that was last week.


00:16:37.960 --> 00:16:38.960
But yeah, this is super cool.


00:16:38.960 --> 00:16:43.500
But this one is certainly within normal person's reach.


00:16:43.500 --> 00:16:46.260
You get a GPU and you're good to go, right?


00:16:46.260 --> 00:16:47.540
- Yeah, I think, yeah.


00:16:47.540 --> 00:16:50.540
I mean, I'm just using it on my laptop with the GPU.


00:16:50.540 --> 00:16:52.460
You can also use it like online.


00:16:52.460 --> 00:16:57.460
So there's also a Colab notebook on the rapid side,


00:16:57.460 --> 00:16:59.660
I think that you can click


00:16:59.660 --> 00:17:01.900
and then you can like kind of experiment


00:17:01.900 --> 00:17:03.540
if you just wanted to do it online,


00:17:03.540 --> 00:17:07.300
or I think you can use any sort of online GPU


00:17:07.300 --> 00:17:09.220
that you have access to.


00:17:09.220 --> 00:17:12.580
So it's very, I think it's trying to make it more accessible


00:17:12.580 --> 00:17:14.660
which is great.


00:17:14.660 --> 00:17:15.940
- Yeah, that's super cool.


00:17:15.940 --> 00:17:16.940
Yeah, very neat.


00:17:16.940 --> 00:17:18.760
Well, like I said, I think this is a cool project


00:17:18.760 --> 00:17:19.600
to be working on.


00:17:19.600 --> 00:17:21.180
So thanks for sharing it with us.


00:17:21.180 --> 00:17:24.780
Brian, is it time for the next one?


00:17:24.780 --> 00:17:26.280
- Is it time for the next one?


00:17:26.280 --> 00:17:32.260
This was a recommended by a listener, Ira Horeca, I think.


00:17:32.260 --> 00:17:35.160
So mentioned this in, it's kind of a rabbit hole.


00:17:35.160 --> 00:17:37.180
I spent a whole bunch of time playing with all this stuff.


00:17:37.180 --> 00:17:39.660
last night, he recommended DateFinder.


00:17:39.660 --> 00:17:43.980
This is a Python utility and it is amazing.


00:17:43.980 --> 00:17:46.100
It's a combination of a couple of things.


00:17:46.100 --> 00:17:50.620
He pointed us to a Comcode video,


00:17:50.620 --> 00:17:54.220
which I'm totally a fan of Comcode stuff because


00:17:54.220 --> 00:17:58.540
they go through some of the Python libraries and a lot of other things,


00:17:58.540 --> 00:18:03.260
but just have a quick demo of what it does and I really appreciate that.


00:18:03.260 --> 00:18:05.300
It actually, the demo here is better than


00:18:05.300 --> 00:18:08.900
the read me in the DateFinder read me.


00:18:08.900 --> 00:18:11.540
Maybe I guess a pull request is necessary.


00:18:11.540 --> 00:18:16.020
But anyway, what DateFinder does is it takes,


00:18:16.020 --> 00:18:18.300
I'm going to scroll down a little bit.


00:18:18.300 --> 00:18:23.780
DateFinder parses dates, it finds them.


00:18:23.780 --> 00:18:28.440
You give it a string or a bunch of list of strings or something,


00:18:28.440 --> 00:18:31.260
and it can find where the dates are in there.


00:18:31.260 --> 00:18:34.140
If you've got a sentence or a paragraph


00:18:34.140 --> 00:18:38.100
an entire page that has a whole bunch of dates in it.


00:18:38.100 --> 00:18:40.580
It'll find all of them and then return you


00:18:40.580 --> 00:18:43.900
a list of dates that it found.


00:18:43.900 --> 00:18:45.680
It actually does a whole bunch of things,


00:18:45.680 --> 00:18:47.100
but that's the default or


00:18:47.100 --> 00:18:49.380
the one that we're talking about, find dates.


00:18:49.380 --> 00:18:54.980
There's a bunch of other less documented features of Date Finder,


00:18:54.980 --> 00:18:58.360
but this is the one that is demonstrated here and it's pretty cool.


00:18:58.360 --> 00:19:03.740
What it does, it finds those dates and then it converts them to date times.


00:19:03.740 --> 00:19:06.260
so findDates will find them and convert them to date times.


00:19:06.260 --> 00:19:10.060
It does that by passing them off to the DateUtil library.


00:19:10.060 --> 00:19:12.560
This is just a really cool demo.


00:19:12.560 --> 00:19:19.500
The list, the little video is a good demo of showing how to do this.


00:19:19.500 --> 00:19:21.880
I also really liked this way to play,


00:19:21.880 --> 00:19:24.700
so the video shows this way to play with things.


00:19:24.700 --> 00:19:28.700
It just had a list of strings and then used


00:19:28.700 --> 00:19:31.340
a comprehension to convert that,


00:19:31.340 --> 00:19:33.460
to call a function on a whole bunch of strings.


00:19:33.460 --> 00:19:35.740
and I thought this was just kind of a clever way


00:19:35.740 --> 00:19:38.500
to just play with a function that translates things.


00:19:38.500 --> 00:19:40.220
This is a neat thing to do.


00:19:40.220 --> 00:19:41.620
I would have probably-- - It's usually so hard.


00:19:41.620 --> 00:19:43.580
Yeah, it's super hard normally


00:19:43.580 --> 00:19:45.140
because it's so picky, right?


00:19:45.140 --> 00:19:49.340
You've gotta go to the date, time, parsing language


00:19:49.340 --> 00:19:50.300
almost lookup.


00:19:50.300 --> 00:19:53.800
So if I put %DDDD, that might mean the year,


00:19:53.800 --> 00:19:56.260
but if it's capital D, it might mean something different.


00:19:56.260 --> 00:19:59.260
So you might say month, day, comma, year,


00:19:59.260 --> 00:20:01.620
but like there's an example here with month, day, year


00:20:01.620 --> 00:20:04.620
without the commas like March 12, 2010.


00:20:04.620 --> 00:20:06.620
But if they forget the comma, it won't parse.


00:20:06.620 --> 00:20:08.700
All those things are really annoying about working


00:20:08.700 --> 00:20:11.060
with converting strings to dates.


00:20:11.060 --> 00:20:13.820
This looks like it just doesn't care. It's nice.


00:20:13.820 --> 00:20:18.940
>> Yeah. Then it's a nice clean interface to it as well.


00:20:18.940 --> 00:20:23.140
A limited documentation is just a focus tool, which is nice.


00:20:23.140 --> 00:20:26.540
It's interesting that this is just a focus tool that apparently a lot of


00:20:26.540 --> 00:20:29.140
people need because according to GitHub,


00:20:29.140 --> 00:20:32.300
there's 662 projects using this.


00:20:32.300 --> 00:20:34.580
It's used all over the place.


00:20:34.580 --> 00:20:36.340
The behind the scenes though,


00:20:36.340 --> 00:20:39.020
it's taking the dates that it found,


00:20:39.020 --> 00:20:42.420
the strings, and passing those to DateUtil.


00:20:42.420 --> 00:20:45.240
If you want to avoid the finding part,


00:20:45.240 --> 00:20:48.020
this actually is also a good library to look at for


00:20:48.020 --> 00:20:53.540
the usage of how to use DateUtil to easily convert dates.


00:20:53.540 --> 00:20:57.220
and DateUtil is an amazing tool as well.


00:20:57.220 --> 00:21:00.980
I told you this is a rabbit hole.


00:21:00.980 --> 00:21:04.060
One of the cool things about it is it doesn't just parse dates,


00:21:04.060 --> 00:21:05.940
but you can do relative dates.


00:21:05.940 --> 00:21:09.300
You can say today plus three weeks or something,


00:21:09.300 --> 00:21:11.140
and it'll figure that out.


00:21:11.140 --> 00:21:17.260
Then you can take two dates and do date math with it really well.


00:21:17.260 --> 00:21:20.380
Also, DateUtil has an amazing time zone support,


00:21:20.380 --> 00:21:22.140
probably the best in Python.


00:21:22.140 --> 00:21:24.540
This is pretty cool.


00:21:24.540 --> 00:21:27.180
Also, I think I was looking through the test code.


00:21:27.180 --> 00:21:34.180
The test code for DateUtil is a neat mix of unit test and PyTest.


00:21:34.180 --> 00:21:37.140
Both of them are good examples of how to do both.


00:21:37.140 --> 00:21:39.380
I like some of the newer stuff is using


00:21:39.380 --> 00:21:42.300
PyTest with parameterization, but it's good.


00:21:42.300 --> 00:21:43.720
>> Yeah, I like this a lot.


00:21:43.720 --> 00:21:44.660
Marlene, what do you think?


00:21:44.660 --> 00:21:48.980
>> Yeah, I like it. I'm not actually working with dates quite often,


00:21:48.980 --> 00:21:52.460
so I'm trying to think of use cases for myself.


00:21:52.460 --> 00:21:55.380
Other than maybe converting time zones,


00:21:55.380 --> 00:21:57.720
which is a nightmare.


00:21:57.720 --> 00:22:01.540
>> You can say that again. Oh my God.


00:22:01.540 --> 00:22:05.320
>> Maybe that, but it looks like it would be really useful


00:22:05.320 --> 00:22:09.140
for people that are working with dates a lot.


00:22:09.140 --> 00:22:11.100
>> Yeah. I'm showing up some of


00:22:11.100 --> 00:22:15.140
the examples from DateUtil of how to use it.


00:22:16.020 --> 00:22:19.920
I imagine this is one of the reasons why Dave Finder is so used,


00:22:19.920 --> 00:22:23.960
because this is non-trivial even to use Dave Tilt.


00:22:23.960 --> 00:22:26.040
>> Yeah, that's cool.


00:22:26.040 --> 00:22:27.640
I got the next one.


00:22:27.640 --> 00:22:30.740
This one doesn't exactly come to us from Anthony Shaw,


00:22:30.740 --> 00:22:33.880
but I was talking to Anthony about something else and he's like,


00:22:33.880 --> 00:22:35.860
"Oh, have you heard of this?


00:22:35.860 --> 00:22:37.920
Have you heard of Cinder?"


00:22:37.920 --> 00:22:40.480
Cinder is pretty awesome.


00:22:40.480 --> 00:22:45.600
Anthony is doing interesting work around Python and performance at the CPython level,


00:22:45.600 --> 00:22:50.640
especially now, I think he's giving a talk on Pigeon or Piston, I believe it is.


00:22:50.640 --> 00:22:54.160
I'm not 100% sure, I might be remembering which one's wrong at PyCon,


00:22:54.160 --> 00:22:57.440
which is, you know, we're going to talk more about that in just a second as well.


00:22:57.440 --> 00:23:03.600
But Sender is a really interesting fork of CPython from Instagram.


00:23:03.600 --> 00:23:06.240
So it's under the Facebook Incubator Project.


00:23:06.240 --> 00:23:09.920
And I think we've mentioned it before, I definitely have talked about it before


00:23:09.920 --> 00:23:13.600
other presentations, that Instagram has done really interesting things like


00:23:13.600 --> 00:23:17.340
disable the garbage collector, just turn it off 100%


00:23:17.340 --> 00:23:20.840
and they got less memory usage, not more memory usage


00:23:20.840 --> 00:23:24.160
by just allowing the cycles to leak, which is insane.


00:23:24.160 --> 00:23:25.960
But this is like, speaking of insane,


00:23:25.960 --> 00:23:27.800
this takes it to a whole nother level.


00:23:27.800 --> 00:23:30.640
So this is, they've been doing all these low level things


00:23:30.640 --> 00:23:33.880
inside of CPython, it is based on 3.8.


00:23:33.880 --> 00:23:36.520
Hopefully some of these ideas can be brought forward


00:23:36.520 --> 00:23:38.360
and shared with everyone because there's a lot going on.


00:23:38.360 --> 00:23:40.200
So let me just cruise down here.


00:23:40.200 --> 00:23:42.560
I'll just read the little intro part


00:23:42.560 --> 00:23:44.560
because it's jam-packed,


00:23:44.560 --> 00:23:45.960
and then I'll go into some of the details.


00:23:45.960 --> 00:23:48.560
So it says, "This is the internal performance-oriented


00:23:48.560 --> 00:23:51.200
production version of CPython 3.8,


00:23:51.200 --> 00:23:53.640
and it contains a number of performance optimizations."


00:23:53.640 --> 00:23:55.520
I feel like performance is some sort of theme


00:23:55.520 --> 00:23:57.440
of this episode.


00:23:57.440 --> 00:24:00.360
It includes bytecode inline caching,


00:24:00.360 --> 00:24:02.360
eager evaluations of coroutines,


00:24:02.360 --> 00:24:04.880
a JIT, just-in-time compiler,


00:24:04.880 --> 00:24:06.580
an experimental bytecode compiler


00:24:06.580 --> 00:24:08.520
that uses type annotations


00:24:08.520 --> 00:24:11.040
in some incredibly interesting ways


00:24:11.040 --> 00:24:15.160
to emit type specialized byte code that performs better.


00:24:15.160 --> 00:24:17.080
So just to give you an example,


00:24:17.080 --> 00:24:21.580
one of the reasons that math in the pure Python layer


00:24:21.580 --> 00:24:24.560
is slower than say C++ or C#


00:24:24.560 --> 00:24:27.920
is C++ and C# work with just the value.


00:24:27.920 --> 00:24:29.200
So if you have the value seven,


00:24:29.200 --> 00:24:30.680
you might have two or four bytes


00:24:30.680 --> 00:24:32.320
that represent the value seven.


00:24:32.320 --> 00:24:34.680
In Python, you have a pyobject pointer,


00:24:34.680 --> 00:24:39.080
which is like 28 bytes pointing out to a thing on the heap


00:24:39.080 --> 00:24:40.560
that represents the number seven.


00:24:40.560 --> 00:24:43.260
and it's a whole lot more work to interact with that


00:24:43.260 --> 00:24:46.180
and set the reference count on that and so on,


00:24:46.180 --> 00:24:48.500
instead of just working with the value seven, right?


00:24:48.500 --> 00:24:53.300
So one of the things they do is they actually have typed,


00:24:53.300 --> 00:24:55.860
they use Python type annotations to understand,


00:24:55.860 --> 00:24:58.980
oh, this is an integer, this is a long and so on type


00:24:58.980 --> 00:25:00.740
of thing and actually convert those


00:25:00.740 --> 00:25:04.020
to the machine oriented numbers, right?


00:25:04.020 --> 00:25:05.840
So just the value four instead of a pointer


00:25:05.840 --> 00:25:07.860
and then it will use what's called boxing.


00:25:07.860 --> 00:25:10.380
If something else that's outside of this world needs it,


00:25:10.380 --> 00:25:13.940
it'll up level that to like a pylon object pointer


00:25:13.940 --> 00:25:15.740
type thing and hand it off.


00:25:15.740 --> 00:25:18.460
So there's all sorts of stuff like that going on.


00:25:18.460 --> 00:25:21.020
Interestingly, the first question is, is this supported?


00:25:21.020 --> 00:25:22.620
No, not supported.


00:25:22.620 --> 00:25:24.860
(laughing)


00:25:24.860 --> 00:25:28.380
But there's some interesting things going on here.


00:25:28.380 --> 00:25:32.740
And all of this has to be taken with an understanding


00:25:32.740 --> 00:25:34.620
that it's in a very specific context


00:25:34.620 --> 00:25:36.700
and that may or may not be useful for you.


00:25:36.700 --> 00:25:39.660
Brian had pointed out some articles and ideas


00:25:39.660 --> 00:25:43.340
around that you're not Instagram, you're not Facebook,


00:25:43.340 --> 00:25:44.940
you're not Netflix and so on.


00:25:44.940 --> 00:25:48.380
Most of the time people are building much smaller software


00:25:48.380 --> 00:25:49.700
with different constraints.


00:25:49.700 --> 00:25:51.820
So they start out by saying, look,


00:25:51.820 --> 00:25:55.260
Instagram uses a multi-process web server architecture


00:25:55.260 --> 00:25:58.940
where the parent process starts, performs initialization


00:25:58.940 --> 00:26:01.940
and then forks 10 worker processes to handle requests.


00:26:01.940 --> 00:26:03.140
This is super common.


00:26:03.140 --> 00:26:03.980
Like for example,


00:26:03.980 --> 00:26:06.180
TalkByThon training literally does exactly this.


00:26:06.180 --> 00:26:08.340
It uses micro-WSGI, it starts up


00:26:08.340 --> 00:26:10.300
and it creates 10 worker processes to handle


00:26:10.300 --> 00:26:11.800
like people wanting to take courses.


00:26:11.800 --> 00:26:13.520
So it's not uncommon in the web,


00:26:13.520 --> 00:26:16.340
but it's not how all Python code runs.


00:26:16.340 --> 00:26:19.100
And so the first optimization they did


00:26:19.100 --> 00:26:22.000
is they created what are called immortal instances.


00:26:22.000 --> 00:26:24.580
The reason they were so focused on the garbage collector


00:26:24.580 --> 00:26:25.980
and all those sorts of things


00:26:25.980 --> 00:26:28.300
was when you fork these processes,


00:26:28.300 --> 00:26:32.020
initially, there's a bunch of memory that can be shared,


00:26:32.020 --> 00:26:34.700
and that helps with cache locality,


00:26:34.700 --> 00:26:37.460
that helps with overall memory usage, all sorts of things.


00:26:37.460 --> 00:26:40.820
But as soon as something is changed about one of those items,


00:26:40.820 --> 00:26:43.140
it has to copy a whole page of memory.


00:26:43.140 --> 00:26:47.140
And they realized that when an object's reference count


00:26:47.140 --> 00:26:49.660
is modified in one of the processes,


00:26:49.660 --> 00:26:53.140
it has to copy, replicate, and sort of fork off


00:26:53.140 --> 00:26:55.360
a bunch of the memory that used to be shared


00:26:55.360 --> 00:26:56.860
across all those processes.


00:26:56.860 --> 00:26:59.380
So they created what they call immortal instances


00:26:59.380 --> 00:27:01.780
that cannot be, that don't participate


00:27:01.780 --> 00:27:04.060
in reference counting or garbage collection.


00:27:04.060 --> 00:27:06.500
And that prohibits their reference count number to change


00:27:06.500 --> 00:27:07.460
so they can be shared.


00:27:07.460 --> 00:27:09.700
So they can mark like a whole bunch of the startup stuff


00:27:09.700 --> 00:27:12.660
as like, just don't even look at this or change it


00:27:12.660 --> 00:27:14.140
and don't do reference counting on it.


00:27:14.140 --> 00:27:16.500
So in their world, they may, it got things faster,


00:27:16.500 --> 00:27:17.460
but it doesn't always,


00:27:17.460 --> 00:27:19.580
they said it's something a little bit slower


00:27:19.580 --> 00:27:20.940
in straight line code,


00:27:20.940 --> 00:27:22.540
but in this sort of forked world, it's better.


00:27:22.540 --> 00:27:24.880
The next one is shadow bytecode,


00:27:24.880 --> 00:27:27.940
which is an inline caching implementation.


00:27:27.940 --> 00:27:32.740
And it goes through, applies in certain optimization cases


00:27:32.740 --> 00:27:35.260
for generic Python opcodes,


00:27:35.260 --> 00:27:39.060
and it'll observe those for functions that take a lot of time


00:27:39.060 --> 00:27:43.800
and dynamically replace those with specialized opcodes


00:27:43.800 --> 00:27:45.400
that it thinks are going to be better.


00:27:45.400 --> 00:27:46.940
Another thing it does that's pretty interesting


00:27:46.940 --> 00:27:49.840
is it will eagerly evaluate coroutines.


00:27:49.840 --> 00:27:52.000
So if I say, this is an async method,


00:27:52.000 --> 00:27:55.300
and then in that method, I call await some function call,


00:27:55.300 --> 00:27:58.220
normal Python's going to create a coroutine.


00:27:58.220 --> 00:28:00.660
It's gonna schedule it on the async IO event loop,


00:28:00.660 --> 00:28:01.660
and it's gonna get to it.


00:28:01.660 --> 00:28:03.180
And that's a lot of overhead,


00:28:03.180 --> 00:28:05.500
but maybe that function says inside,


00:28:05.500 --> 00:28:07.220
the first thing is, if this case,


00:28:07.220 --> 00:28:09.340
just return the cached answer,


00:28:09.340 --> 00:28:11.580
otherwise go to the database,


00:28:11.580 --> 00:28:13.420
await the response and so on.


00:28:13.420 --> 00:28:14.900
And what they realized is,


00:28:14.900 --> 00:28:17.080
if it's going to go through that first case,


00:28:17.080 --> 00:28:19.040
it's not actually awaiting something.


00:28:19.040 --> 00:28:22.720
So they'll actually execute the awaited thing


00:28:22.720 --> 00:28:25.340
up until it actually needs to become async.


00:28:25.340 --> 00:28:26.500
So it'll like look,


00:28:26.500 --> 00:28:28.840
or effectively look inside the function and say,


00:28:28.840 --> 00:28:30.620
is the path we're going on this time


00:28:30.620 --> 00:28:32.020
gonna be async or not?


00:28:32.020 --> 00:28:35.440
and if the answer is no, it will run it without async,


00:28:35.440 --> 00:28:37.460
which means it skips all that context switching


00:28:37.460 --> 00:28:39.060
and all that stuff, which is pretty crazy.


00:28:39.060 --> 00:28:42.340
It also has the sender JIT,


00:28:42.340 --> 00:28:45.100
which is a method in time JIT compiler,


00:28:45.100 --> 00:28:49.340
I think C#, Java, maybe even JavaScript V8.


00:28:49.340 --> 00:28:52.980
So it's enabled for every function that is called.


00:28:52.980 --> 00:28:54.840
Actually, it's not, sorry.


00:28:54.840 --> 00:28:56.180
If it is, it'll make it slow.


00:28:56.180 --> 00:28:59.780
So you can basically say which functions should be optimized


00:28:59.780 --> 00:29:03.020
but they say it supports almost everything


00:29:03.020 --> 00:29:07.060
that Python can do and it has a 1.5 to four times speed up


00:29:07.060 --> 00:29:10.420
of the Python benchmarks, which is pretty interesting.


00:29:10.420 --> 00:29:12.780
They also have this thing called strict modules,


00:29:12.780 --> 00:29:15.620
which is actually a static analyzer capable


00:29:15.620 --> 00:29:18.540
of validating top-level code to see


00:29:18.540 --> 00:29:19.900
if a module has side effects


00:29:19.900 --> 00:29:21.800
and can treat it differently if it doesn't.


00:29:21.800 --> 00:29:25.560
You can have an immutable strict module type


00:29:25.560 --> 00:29:28.980
that is sort of a replacement for Python's regular module


00:29:28.980 --> 00:29:32.220
it behaves and loads differently, and so on.


00:29:32.220 --> 00:29:34.660
And then the thing I talked about, the numbers,


00:29:34.660 --> 00:29:37.480
more broadly is under this category of static Python.


00:29:37.480 --> 00:29:39.540
It's an experimental byte code compiler


00:29:39.540 --> 00:29:43.660
that makes use of type annotations to emit better things.


00:29:43.660 --> 00:29:46.000
And check this out, it can deliver performance


00:29:46.000 --> 00:29:48.820
similar to mypyC or Cython,


00:29:48.820 --> 00:29:53.180
and this thing will go up to seven times faster


00:29:53.180 --> 00:29:55.860
than regular Python for the Richards benchmarks.


00:29:55.860 --> 00:29:57.860
And I don't know if the 4x improvement before


00:29:57.860 --> 00:30:00.300
is like in addition to this, so you get 28


00:30:00.300 --> 00:30:02.660
or you just get seven, I don't really know.


00:30:02.660 --> 00:30:04.740
But there's a lot of things going on here


00:30:04.740 --> 00:30:08.180
and a lot of different ideas about how this works.


00:30:08.180 --> 00:30:10.760
So I'm just scratching the surface on the details,


00:30:10.760 --> 00:30:13.300
but I feel like I've gone on and on about it.


00:30:13.300 --> 00:30:14.460
- That's really interesting.


00:30:14.460 --> 00:30:18.940
I saw, I think, is there a talk about it at Python?


00:30:18.940 --> 00:30:21.180
I think that-- - It is coming up, yes.


00:30:21.180 --> 00:30:22.740
They're going to give a talk on this at Python.


00:30:22.740 --> 00:30:26.060
- Yeah, it was one of the talks I was looking forward to


00:30:26.060 --> 00:30:32.100
listening to. Yeah, just because I think it's super interesting to be able to kind of play


00:30:32.100 --> 00:30:39.160
around with that they were able to kind of make their own version of Python. And it might,


00:30:39.160 --> 00:30:45.800
I don't know, like, I think that there's, like you mentioned, Anthony, and I also know


00:30:45.800 --> 00:30:50.300
Victor, I think, and someone else were also working on like sub interpreters and different


00:30:50.300 --> 00:30:52.520
and things to make Python faster.


00:30:52.520 --> 00:30:55.880
So I'm really curious to see if the core devs


00:30:55.880 --> 00:30:58.880
or people will also be listening to this talk


00:30:58.880 --> 00:31:02.940
and maybe take some ideas from it.


00:31:02.940 --> 00:31:05.300
It would be really cool to kind of see


00:31:05.300 --> 00:31:08.320
and I mean it's always good to get speed ups


00:31:08.320 --> 00:31:09.880
even if they, I don't know.


00:31:09.880 --> 00:31:13.160
I don't know if it will help like general,


00:31:13.160 --> 00:31:15.040
like normal Python users,


00:31:15.040 --> 00:31:18.840
but I think it's always good to look into.


00:31:18.840 --> 00:31:20.280
- Yeah, yeah, I agree.


00:31:20.280 --> 00:31:23.880
I think some things here are absolutely convert,


00:31:23.880 --> 00:31:26.960
transferable to regular general purpose CPython,


00:31:26.960 --> 00:31:28.000
and some of them might not be.


00:31:28.000 --> 00:31:31.360
For example, the immortal, the immortal instances,


00:31:31.360 --> 00:31:33.640
that might be a thing that just, they do that,


00:31:33.640 --> 00:31:37.280
and it makes sense for their large-scale farm of servers.


00:31:37.280 --> 00:31:40.320
But the JIT that takes the type information


00:31:40.320 --> 00:31:43.120
and does math many, many times faster,


00:31:43.120 --> 00:31:44.720
that, everybody would want that.


00:31:44.720 --> 00:31:47.800
Like, we all work with numbers at some level or another.


00:31:47.800 --> 00:31:48.640
Brian?


00:31:48.640 --> 00:31:50.640
>> One of the things I love about,


00:31:50.640 --> 00:31:54.360
this applies to all of these speed-up projects.


00:31:54.360 --> 00:31:56.160
One of the things I love about Python is


00:31:56.160 --> 00:31:57.680
that just the generalness of it.


00:31:57.680 --> 00:31:59.000
You can throw it,


00:31:59.000 --> 00:32:01.720
data structures can hold anything.


00:32:01.720 --> 00:32:06.600
But there are times where you really are using


00:32:06.600 --> 00:32:09.440
a huge array of floats or a huge array of integers


00:32:09.440 --> 00:32:13.480
or a huge array of a fixed data size.


00:32:13.480 --> 00:32:17.500
Those are times where I don't need it to be generic,


00:32:17.500 --> 00:32:19.820
I just need it to be fast.


00:32:19.820 --> 00:32:23.300
Having something, that's the part where I think it'd


00:32:23.300 --> 00:32:26.420
be interesting to pull into regular Python.


00:32:26.420 --> 00:32:31.860
But don't we get that with some of the data science stuff anyway?


00:32:31.860 --> 00:32:34.380
>> With NumPy and stuff?


00:32:34.380 --> 00:32:38.220
Yeah, you do, but you can't do generic programming with it.


00:32:38.220 --> 00:32:42.100
You do matrix math type of things.


00:32:42.100 --> 00:32:43.740
The answer used to be, "Okay,


00:32:43.740 --> 00:32:45.300
well, this function is slow.


00:32:45.300 --> 00:32:48.380
this serialization deserialization section might be slow.


00:32:48.380 --> 00:32:50.580
So rewrite that in Cython, for example.


00:32:50.580 --> 00:32:53.460
And what's really cool about this is you can write


00:32:53.460 --> 00:32:57.460
regular Python and just put type annotations on it.


00:32:57.460 --> 00:32:59.620
And then it goes as fast as Cython.


00:32:59.620 --> 00:33:03.060
And you don't even have to do like a separate compiler,


00:33:03.060 --> 00:33:04.300
I believe in this world, right?


00:33:04.300 --> 00:33:06.420
Because they have the JIT just knows that.


00:33:06.420 --> 00:33:08.340
And then we'll like as you run it,


00:33:08.340 --> 00:33:09.940
it'll just compile and run it.


00:33:09.940 --> 00:33:12.840
So which is, I think it just sort of makes some of


00:33:12.840 --> 00:33:16.860
those ideas closer and more automatic for most people.


00:33:16.860 --> 00:33:24.140
>> I think I foresee a future where we have some types that affect runtime.


00:33:24.140 --> 00:33:28.900
There's this tension that I sense in the Python core people


00:33:28.900 --> 00:33:32.780
of whether or not types should be just an afterthought,


00:33:32.780 --> 00:33:36.380
or whether they should be really part of the runtime.


00:33:36.380 --> 00:33:39.740
I think there are some cases where


00:33:39.740 --> 00:33:42.060
having them be part of the runtime might be a good thing.


00:33:42.060 --> 00:33:44.780
- Yeah, this is interesting because what they do


00:33:44.780 --> 00:33:48.860
is they define these static modules


00:33:48.860 --> 00:33:51.340
and then in there they can treat them differently.


00:33:51.340 --> 00:33:52.860
- I feel like I always see on Twitter


00:33:52.860 --> 00:33:56.180
some people kind of like ranting about how


00:33:56.180 --> 00:33:59.620
they don't like that direction that Python is going in,


00:33:59.620 --> 00:34:01.300
like the idea of putting in like


00:34:01.300 --> 00:34:03.300
different annotations and things like that.


00:34:03.300 --> 00:34:07.220
I've seen some people that are not super big fans of that.


00:34:07.220 --> 00:34:09.400
I'm not really sure why.


00:34:09.400 --> 00:34:11.220
I generally would like to understand,


00:34:11.220 --> 00:34:15.020
I think most people, or not most people,


00:34:15.020 --> 00:34:17.980
but I think some people would prefer Python


00:34:17.980 --> 00:34:19.580
to maybe remain as it is,


00:34:19.580 --> 00:34:21.060
but I do think that there's like,


00:34:21.060 --> 00:34:23.380
just having it be a bit faster in a couple of cases


00:34:23.380 --> 00:34:24.620
would be helpful.


00:34:24.620 --> 00:34:27.420
So I don't know, I don't know if it's in that direction.


00:34:27.420 --> 00:34:30.060
- I'm with you, and one of the things they point out


00:34:30.060 --> 00:34:32.460
in this readme announcing the project


00:34:32.460 --> 00:34:35.020
is that you can still do gradual typing.


00:34:35.020 --> 00:34:38.140
So you can, in some places, have no types,


00:34:38.140 --> 00:34:39.900
in some places have some types,


00:34:39.900 --> 00:34:42.580
and the thing can convert and just deal with that automatically.


00:34:42.580 --> 00:34:46.540
And I think that's the reason that the types are really welcome in Python,


00:34:46.540 --> 00:34:48.940
is because you can use them if you want, but you don't have to.


00:34:48.940 --> 00:34:51.180
As opposed to places like TypeScript, which said,


00:34:51.180 --> 00:34:52.500
"Well, JavaScript doesn't have types,


00:34:52.500 --> 00:34:55.140
so we're going to add this very strict type system,


00:34:55.140 --> 00:34:56.700
and if you don't fit it exactly,


00:34:56.700 --> 00:34:58.580
we're going to not compile and complain,


00:34:58.580 --> 00:35:00.220
and it's going to be really not good."


00:35:00.220 --> 00:35:04.500
This feels like it continues that forgiving nature of Python


00:35:04.500 --> 00:35:05.980
to let you opt into it.


00:35:05.980 --> 00:35:08.380
But if you do, it can go faster.


00:35:08.380 --> 00:35:09.940
- That's the direction I'd like to see.


00:35:09.940 --> 00:35:13.340
I'd like to see, I personally would like to see


00:35:13.340 --> 00:35:16.780
types be really a full-fledged feature of Python.


00:35:16.780 --> 00:35:18.540
- Yeah, I agree.


00:35:18.540 --> 00:35:21.260
- I love that they're optional, but if they're there,


00:35:21.260 --> 00:35:22.620
let's see how much we can do


00:35:22.620 --> 00:35:24.020
and improve things with them, right?


00:35:24.020 --> 00:35:25.460
- 100%.


00:35:25.460 --> 00:35:26.420
- Yeah, all right.


00:35:26.420 --> 00:35:27.380
Marlene, you got the last one.


00:35:27.380 --> 00:35:28.380
I got it on screen for you.


00:35:28.380 --> 00:35:29.340
- Okay, yes.


00:35:29.340 --> 00:35:33.140
The last one for today is PyCon US,


00:35:33.140 --> 00:35:35.580
which I'm very excited about.


00:35:35.580 --> 00:35:39.320
It started today, which is really great.


00:35:39.320 --> 00:35:41.620
Are both you attending?


00:35:41.620 --> 00:35:43.220
I don't know if you're attending.


00:35:43.220 --> 00:35:45.900
But-- - Yes, absolutely.


00:35:45.900 --> 00:35:47.340
- Okay.


00:35:47.340 --> 00:35:48.460
Brian, are you attending? - Yes.


00:35:48.460 --> 00:35:50.060
- Yay.


00:35:50.060 --> 00:35:53.060
Yeah, I think it's such a great event


00:35:53.060 --> 00:35:55.460
in terms of the fact that I know it's PyCon US,


00:35:55.460 --> 00:36:00.460
but it is, at the moment, it's the largest Python gathering


00:36:00.460 --> 00:36:02.980
or largest PyCon on Earth, I think,


00:36:04.080 --> 00:36:07.160
which is very cool because it means that you can meet people


00:36:07.160 --> 00:36:08.520
from all around the world.


00:36:08.520 --> 00:36:12.640
Like I remember, I'm really sad that it's not in person


00:36:12.640 --> 00:36:15.840
because like last year, like I've, not last year,


00:36:15.840 --> 00:36:17.360
but the year before that,


00:36:17.360 --> 00:36:19.160
that's where I actually met you, Michael,


00:36:19.160 --> 00:36:20.000
for the first time.


00:36:20.000 --> 00:36:21.840
I think we were literally,


00:36:21.840 --> 00:36:24.680
I think we were like at a table with like you


00:36:24.680 --> 00:36:27.320
and Anthony Shaw and like Lucas Longa.


00:36:27.320 --> 00:36:29.760
And it was like, and I was just randomly there,


00:36:29.760 --> 00:36:33.040
but it was such a cool discussion.


00:36:33.040 --> 00:36:37.460
and I really love the idea of being able to


00:36:37.460 --> 00:36:41.460
be in a room with people that are contributing to Python.


00:36:41.460 --> 00:36:42.300
So very excited.


00:36:42.300 --> 00:36:43.860
- That's my favorite part of PyCon.


00:36:43.860 --> 00:36:44.700
- Yeah, it is.


00:36:44.700 --> 00:36:46.100
- It was so nice to meet you as well.


00:36:46.100 --> 00:36:48.420
That is actually my favorite part of PyCon,


00:36:48.420 --> 00:36:51.500
is the, just, you happen to end up at a table


00:36:51.500 --> 00:36:54.860
or out for a beer or coffee with this group of people


00:36:54.860 --> 00:36:57.220
and you're like, wow, I got these connections


00:36:57.220 --> 00:36:59.260
and this experience that just, I wouldn't.


00:36:59.260 --> 00:37:01.540
So I'm very much looking forward to coming back in person.


00:37:01.540 --> 00:37:04.100
but there's a bunch of great talks coming up.


00:37:04.100 --> 00:37:07.940
- Exactly, so this year it's also really,


00:37:07.940 --> 00:37:11.060
although it's online, the online platform is very cool


00:37:11.060 --> 00:37:14.020
and there's still lots of great tools to watch.


00:37:14.020 --> 00:37:16.260
In the show notes I put down a list of the tools


00:37:16.260 --> 00:37:17.500
that I'm excited to watch,


00:37:17.500 --> 00:37:20.320
but I also wanted to just put in a word


00:37:20.320 --> 00:37:23.740
for the things that I will be doing at PyCon US this year.


00:37:23.740 --> 00:37:25.580
And the first thing I'm gonna be doing


00:37:25.580 --> 00:37:26.820
is I'm gonna be hosting


00:37:26.820 --> 00:37:29.580
the diversity and inclusion work group discussion


00:37:30.460 --> 00:37:34.260
along with four other really amazing women


00:37:34.260 --> 00:37:36.940
that are part of the diversity and inclusion work group.


00:37:36.940 --> 00:37:39.260
I do wanna comment here


00:37:39.260 --> 00:37:42.620
because I thought like we got some comments about it,


00:37:42.620 --> 00:37:44.260
some feedback.


00:37:44.260 --> 00:37:46.620
I posted a picture of like our group


00:37:46.620 --> 00:37:48.300
that's gonna be having this discussion


00:37:48.300 --> 00:37:50.340
or hosting this panel and it's all women.


00:37:50.340 --> 00:37:52.420
And someone was just like, why is it all women?


00:37:52.420 --> 00:37:53.860
How is this diversity?


00:37:53.860 --> 00:37:58.020
So I do wanna throw it out there.


00:37:58.020 --> 00:38:00.380
I just wanna throw it out there that we did try,


00:38:00.380 --> 00:38:03.340
like the work group itself has a lot of,


00:38:03.340 --> 00:38:06.060
it has a good balance of men and women in it.


00:38:06.060 --> 00:38:07.740
But then when I asked people


00:38:07.740 --> 00:38:09.080
if they wanna come on the panel,


00:38:09.080 --> 00:38:11.420
it was only like women that volunteered.


00:38:11.420 --> 00:38:14.980
So it's on my halt and I am aware of that.


00:38:14.980 --> 00:38:16.380
That's just a general,


00:38:16.380 --> 00:38:18.600
or that's just general feedback there.


00:38:18.600 --> 00:38:25.020
But I think the panel will be really exciting.


00:38:25.020 --> 00:38:28.020
It's gonna be on Saturday on the main stage


00:38:28.020 --> 00:38:31.220
at 12 p.m. EST, I think.


00:38:31.220 --> 00:38:32.300
If you're gonna be there,


00:38:32.300 --> 00:38:34.300
I really would encourage you to attend.


00:38:34.300 --> 00:38:36.400
There's gonna be question and answer.


00:38:36.400 --> 00:38:38.660
And I just think it's such an important thing.


00:38:38.660 --> 00:38:41.820
I know that sometimes diversity can seem


00:38:41.820 --> 00:38:44.540
like a really tiring thing to talk about,


00:38:44.540 --> 00:38:46.540
especially like recently.


00:38:46.540 --> 00:38:49.140
I feel like sometimes people use it as like this buzzword


00:38:49.140 --> 00:38:51.340
and it can, and people can be like, oh my gosh,


00:38:51.340 --> 00:38:55.020
and just turn off when they hear the word diversity.


00:38:55.020 --> 00:38:57.180
But I really do think it's important.


00:38:57.180 --> 00:39:01.420
And particularly now as Python is growing in popularity,


00:39:01.420 --> 00:39:03.100
I think a few years ago,


00:39:03.100 --> 00:39:06.900
it was okay for the nucleus of Python


00:39:06.900 --> 00:39:10.740
to be based in the United States or based in Europe,


00:39:10.740 --> 00:39:13.340
but it's growing so quickly.


00:39:13.340 --> 00:39:16.060
Python for I don't know how many years now


00:39:16.060 --> 00:39:18.340
has been the most popular language in the world.


00:39:18.340 --> 00:39:22.340
And I know even for me, I'm in Zimbabwe right now,


00:39:22.340 --> 00:39:25.980
and it's one of the most popular languages here where I live.


00:39:25.980 --> 00:39:28.660
And so just providing the group,


00:39:28.660 --> 00:39:30.300
like our main purpose is to figure out


00:39:30.300 --> 00:39:35.300
how we can support the PSF to try and serve Pythonistas


00:39:35.300 --> 00:39:37.700
from around the world better


00:39:37.700 --> 00:39:40.480
and to connect the community better


00:39:40.480 --> 00:39:42.940
and have better representation and different things like that


00:39:42.940 --> 00:39:44.860
so very excited about that one.


00:39:44.860 --> 00:39:47.780
- That's awesome and thanks for your work here.


00:39:47.780 --> 00:39:51.420
I definitely agree that we're stronger together, right?


00:39:51.420 --> 00:39:53.300
And one thing I would really like to see


00:39:53.300 --> 00:39:54.420
and I think we're getting there


00:39:54.420 --> 00:39:57.020
is when people look at Python,


00:39:57.020 --> 00:39:58.180
and programming in general,


00:39:58.180 --> 00:39:59.680
but generally the Python space,


00:39:59.680 --> 00:40:01.120
we have influence over that.


00:40:01.120 --> 00:40:03.180
When people look at that world,


00:40:03.180 --> 00:40:04.500
I would like them to say,


00:40:04.500 --> 00:40:06.060
I can see myself being part of that.


00:40:06.060 --> 00:40:08.240
I can see that I could belong there, right?


00:40:08.240 --> 00:40:09.360
And if that's not the case,


00:40:09.360 --> 00:40:11.500
then how do we make that the case?


00:40:11.500 --> 00:40:13.540
- Exactly, absolutely.


00:40:13.540 --> 00:40:15.920
I think exactly that.


00:40:15.920 --> 00:40:18.180
And I would love to see that happening


00:40:18.180 --> 00:40:19.260
in the next few years.


00:40:19.260 --> 00:40:20.660
I would love to see,


00:40:20.660 --> 00:40:23.680
one of my things is that I'd love to see more


00:40:23.680 --> 00:40:26.800
women core developers and more like global core developers


00:40:26.800 --> 00:40:29.840
as well, and also people on the board and different things.


00:40:29.840 --> 00:40:31.880
And those are all goals that we are working towards.


00:40:31.880 --> 00:40:34.760
And obviously we don't know like the perfect way


00:40:34.760 --> 00:40:37.560
to achieve something or the perfect way to do things,


00:40:37.560 --> 00:40:40.640
but it's something that I think is really great


00:40:40.640 --> 00:40:42.280
and exciting to work on.


00:40:42.280 --> 00:40:45.640
So please attend if you are listening to this.


00:40:45.640 --> 00:40:49.440
And let me know if you like came from this podcast,


00:40:49.440 --> 00:40:51.520
it would be fantastic to see you there.


00:40:51.520 --> 00:40:53.120
Maybe just comment.


00:40:53.120 --> 00:40:53.960
- Fantastic.


00:40:53.960 --> 00:40:57.240
- And then, oh, another thing that I am doing


00:40:57.240 --> 00:41:00.600
for Python this year as well is I will be,


00:41:00.600 --> 00:41:05.120
one, I will be in the, so there's like a lounge area.


00:41:05.120 --> 00:41:07.320
Well, there's like a PSF booth,


00:41:07.320 --> 00:41:09.600
and if you would like to just,


00:41:09.600 --> 00:41:11.960
if you're gonna be there in the morning on Saturday


00:41:11.960 --> 00:41:15.520
or on Friday, I will be hanging out in the PSF booth.


00:41:15.520 --> 00:41:18.160
And so yeah, if you just wanna talk about Python


00:41:18.160 --> 00:41:20.520
or the PSF or anything, I will be there.


00:41:20.520 --> 00:41:24.520
And I will also be hosting the EMEA meeting.


00:41:24.520 --> 00:41:27.880
So if you're in Europe, the Middle East, or Africa,


00:41:27.880 --> 00:41:30.600
there's a members meeting on Saturday.


00:41:30.600 --> 00:41:34.160
I think it's at 10 a.m. Central African time.


00:41:34.160 --> 00:41:36.520
I'm not sure what time that is in other places.


00:41:36.520 --> 00:41:39.120
But I know it's at 10 a.m.


00:41:39.120 --> 00:41:40.160
- It's on the schedule, right?


00:41:40.160 --> 00:41:41.000
It's on the schedule.


00:41:41.000 --> 00:41:43.000
- Yeah, we can use the date time thing,


00:41:43.000 --> 00:41:45.120
I don't know, you remember.


00:41:45.120 --> 00:41:46.160
- Exactly.


00:41:46.160 --> 00:41:47.880
Pull up the REPL, throw it into date time.


00:41:47.880 --> 00:41:49.180
- Exactly, please do that.


00:41:49.180 --> 00:41:50.620
(laughs)


00:41:50.620 --> 00:41:52.820
So I will be hosting that,


00:41:52.820 --> 00:41:54.780
and that's gonna be in the morning.


00:41:54.780 --> 00:41:57.460
And if you would like, even if you're not a member,


00:41:57.460 --> 00:42:00.140
you can watch it on the PSA YouTube channel.


00:42:00.140 --> 00:42:01.800
It's gonna be streaming there,


00:42:01.800 --> 00:42:03.740
or you could join, there's a meetup link


00:42:03.740 --> 00:42:04.780
that I put in the show notes.


00:42:04.780 --> 00:42:06.860
So people could join that way as well.


00:42:06.860 --> 00:42:10.080
So yeah, Python is gonna be really exciting,


00:42:10.080 --> 00:42:11.500
and I'm really looking forward to it.


00:42:11.500 --> 00:42:14.860
So just encouraging people to come along, for sure.


00:42:14.860 --> 00:42:15.680
- Yeah, it should be fun.


00:42:15.680 --> 00:42:18.240
And even though it is super sad


00:42:18.240 --> 00:42:21.920
that it's not in person, it's not in Pittsburgh this year.


00:42:21.920 --> 00:42:23.880
I think in some ways it's more accessible


00:42:23.880 --> 00:42:25.200
to people around the world, right?


00:42:25.200 --> 00:42:26.760
They don't have to travel there.


00:42:26.760 --> 00:42:29.320
They can just log in and attend it.


00:42:29.320 --> 00:42:32.800
And that's so much less expensive than I flew to the US


00:42:32.800 --> 00:42:35.040
and I paid $1,000 for a hotel.


00:42:35.040 --> 00:42:36.800
So there's a little silver lining,


00:42:36.800 --> 00:42:39.200
you know, out there in the live stream.


00:42:39.200 --> 00:42:40.560
Sam Morley really says,


00:42:40.560 --> 00:42:43.160
"I really wish I could go to PyCon in person."


00:42:43.160 --> 00:42:46.240
Adam Parkin there says, "Me too, maybe in 2020."


00:42:46.240 --> 00:42:47.480
I think so.


00:42:47.480 --> 00:42:49.280
Finally, Sam is also thinks it's great


00:42:49.280 --> 00:42:52.400
that we're having this diversity conversation


00:42:52.400 --> 00:42:53.240
and paying attention to it.


00:42:53.240 --> 00:42:55.840
- One of the things I've noticed in 2020


00:42:55.840 --> 00:43:00.080
is all the regional, actually last year also though,


00:43:00.080 --> 00:43:03.820
but the 2020 and 2021,


00:43:03.820 --> 00:43:07.920
we've got all these PyCons going on all over the world.


00:43:07.920 --> 00:43:11.520
I used to think of like PyCon US as the PyCon


00:43:11.520 --> 00:43:13.280
and everything else is regional.


00:43:13.280 --> 00:43:17.440
Now I think of PyCon US as a regional conference


00:43:17.440 --> 00:43:21.560
also it's the regional one that's close to the people that are in the US.


00:43:21.560 --> 00:43:24.680
It isn't necessarily better.


00:43:24.680 --> 00:43:26.760
I love it. It's great.


00:43:26.760 --> 00:43:29.400
Anybody that's hosting it, yes, it's better.


00:43:29.400 --> 00:43:34.980
But no, I like all of them and I was


00:43:34.980 --> 00:43:39.940
excited to get to participate and watch videos from all over the world this year.


00:43:39.940 --> 00:43:42.040
That was pretty neat. But yeah,


00:43:42.040 --> 00:43:46.340
I'm on board with, I want to get back to regional stuff.


00:43:46.340 --> 00:43:49.060
I'd like to see people in person. I can't wait.


00:43:49.060 --> 00:43:51.180
>> Yeah, I will say for sure,


00:43:51.180 --> 00:43:54.580
even if people are feeling adventurous,


00:43:54.580 --> 00:43:56.380
there is a regional conference,


00:43:56.380 --> 00:43:57.860
I didn't mention it before,


00:43:57.860 --> 00:44:00.740
that I am also part of the organizing team for,


00:44:00.740 --> 00:44:02.140
which is PyCon Africa.


00:44:02.140 --> 00:44:04.340
If you would like to travel to


00:44:04.340 --> 00:44:07.420
another PyCon in a different part of the world,


00:44:07.420 --> 00:44:10.460
when we are able to travel and the world gets back


00:44:10.460 --> 00:44:14.860
to some form of free travel,


00:44:14.860 --> 00:44:19.180
Definitely recommend also hopping over to Python Africa.


00:44:19.180 --> 00:44:21.460
I think, like you said,


00:44:21.460 --> 00:44:24.020
I think Python US is fantastic.


00:44:24.020 --> 00:44:30.020
One of the unique things about that is that it's a conference that has been there for so long,


00:44:30.020 --> 00:44:32.300
so a lot of people are going to be there.


00:44:32.300 --> 00:44:37.940
But there are 100 percent are a lot of great conferences like Python Africa,


00:44:37.940 --> 00:44:40.740
which you should attend if you can.


00:44:40.740 --> 00:44:43.540
I think they're really just as exciting and there's


00:44:43.540 --> 00:44:45.900
so many cool things that you get to experience.


00:44:45.900 --> 00:44:49.060
Like I think for me, it's like whenever I go to the US,


00:44:49.060 --> 00:44:52.420
like last year, I'd never been to Ohio before.


00:44:52.420 --> 00:44:55.180
And like, I had never, like I would never,


00:44:55.180 --> 00:44:58.500
like in my, I would never have a reason


00:44:58.500 --> 00:44:59.740
that I would think to myself,


00:44:59.740 --> 00:45:02.900
let me go to America to go to Ohio.


00:45:02.900 --> 00:45:07.460
But I feel like it was such a good experience for me


00:45:07.460 --> 00:45:10.980
and I really liked it and I was really surprised by that.


00:45:10.980 --> 00:45:12.600
And so I think it's the same way,


00:45:12.600 --> 00:45:16.040
like pythons are a great way as well to like experience new places.


00:45:16.040 --> 00:45:18.320
So yeah, definitely sticking in that.


00:45:18.320 --> 00:45:21.720
Well, that's wraps up our six.


00:45:21.720 --> 00:45:24.560
anybody got any extra information to share?


00:45:24.560 --> 00:45:29.120
Nothing else for me other than the fact that if you do want to reach out to me,


00:45:29.120 --> 00:45:34.560
you can reach out to me on Twitter. I'm Marlene_Zaw there.


00:45:34.560 --> 00:45:38.480
I'm also Marlene_Zaw on, on GitHub, I think.


00:45:38.560 --> 00:45:40.600
and on my website.


00:45:40.600 --> 00:45:43.160
My website is marleenmangami.com.


00:45:43.160 --> 00:45:45.920
So if you would like to reach out to me here,


00:45:45.920 --> 00:45:47.560
feel free to.


00:45:47.560 --> 00:45:50.040
I'm always happy to like chat about Python.


00:45:50.040 --> 00:45:51.160
- Nice. - Cool.


00:45:51.160 --> 00:45:52.000
- So I got a couple.


00:45:52.000 --> 00:45:53.400
One made me really excited.


00:45:53.400 --> 00:45:55.800
This tweet from GitHub,


00:45:55.800 --> 00:45:57.240
is your fork behind?


00:45:57.240 --> 00:46:00.360
You can now sync your parent repo


00:46:00.360 --> 00:46:01.760
with just a single click.


00:46:01.760 --> 00:46:02.960
So check this out.


00:46:02.960 --> 00:46:05.000
If you go to your fork now,


00:46:05.000 --> 00:46:07.320
next to contribute for your PRs and stuff,


00:46:07.320 --> 00:46:10.060
there is now a fetch upstream button


00:46:10.060 --> 00:46:11.720
and all you have to do is click it


00:46:11.720 --> 00:46:15.020
and then automatically your fork will become in sync


00:46:15.020 --> 00:46:16.720
with whatever you forked it from.


00:46:16.720 --> 00:46:19.360
You still have to go and go check it out,


00:46:19.360 --> 00:46:22.040
add an upstream origin and then pull from that


00:46:22.040 --> 00:46:24.600
and then merge that wherever you want it to go to.


00:46:24.600 --> 00:46:26.440
Over here, you just click this button


00:46:26.440 --> 00:46:28.160
and boom, it's good to go.


00:46:28.160 --> 00:46:29.920
So I think this will just lower the bar


00:46:29.920 --> 00:46:31.480
for people working something,


00:46:31.480 --> 00:46:32.960
they wanna get the current one


00:46:32.960 --> 00:46:35.440
and then make a change to see if they could contribute back.


00:46:35.440 --> 00:46:38.200
here's one fewer steps in that process.


00:46:38.200 --> 00:46:41.600
>> Any idea if it stays in sync or if you have to-


00:46:41.600 --> 00:46:44.160
>> No, it's a one-time type of thing, I believe.


00:46:44.160 --> 00:46:45.640
It says there's this many changes,


00:46:45.640 --> 00:46:47.520
we'll pull over and it basically just automatically


00:46:47.520 --> 00:46:49.520
does the process at that time.


00:46:49.520 --> 00:46:50.040
>> Nice.


00:46:50.040 --> 00:46:51.520
>> But still pretty nice.


00:46:51.520 --> 00:46:55.960
Here, Flask 2.0 is out and that one


00:46:55.960 --> 00:46:59.600
was sent into us from Adam Parkin that,


00:46:59.600 --> 00:47:02.000
"Hey, heads up, this is now actually live."


00:47:02.000 --> 00:47:03.360
Very cool.


00:47:03.360 --> 00:47:06.360
Actually, everything from palettes has been updated.


00:47:06.360 --> 00:47:09.360
So yeah, I happen to have spoken,


00:47:09.360 --> 00:47:12.400
done a podcast recording with David Lord who runs palettes


00:47:12.400 --> 00:47:16.160
and Phil Jones who does core and contributes back to palettes as well


00:47:16.160 --> 00:47:19.760
about all the stuff coming in Flask 2.0,


00:47:19.760 --> 00:47:22.160
all the exciting stuff and their future plans as well.


00:47:22.160 --> 00:47:24.760
So yeah, you can watch the live stream of that


00:47:24.760 --> 00:47:27.040
or wait a day or two until the episode is out


00:47:27.040 --> 00:47:29.240
and just listen at Talk Python as well.


00:47:29.240 --> 00:47:30.360
But yeah, very, very cool.


00:47:30.360 --> 00:47:32.880
Yeah. And then Adam also had a live stream again,


00:47:32.880 --> 00:47:36.080
says this super sweet always find it a headache to sync with upstream.


00:47:36.080 --> 00:47:37.140
Yeah, about the GitHub thing.


00:47:37.140 --> 00:47:38.080
That's that's cool.


00:47:38.080 --> 00:47:38.640
Cool.


00:47:38.640 --> 00:47:39.680
Close it out with a joke.


00:47:39.680 --> 00:47:42.140
Well, I got a couple of things I wanted to mention.


00:47:42.140 --> 00:47:42.880
Go for it.


00:47:42.880 --> 00:47:43.340
Sorry.


00:47:43.340 --> 00:47:48.180
I had Brett Cannon on last week on testing code


00:47:48.180 --> 00:47:51.140
and huge feedback from everybody that it was a great episode.


00:47:51.140 --> 00:47:52.380
We talked about packaging.


00:47:52.380 --> 00:47:56.380
I'll have Ryan Howard on this week talking about Playwright.


00:47:56.380 --> 00:47:57.740
So that'll be fun.


00:47:57.740 --> 00:48:02.280
And I wanted to mention a thank you to the 71 patrons


00:48:02.280 --> 00:48:03.780
that we have on Patreon.


00:48:03.780 --> 00:48:05.580
So thank you for supporting the show.


00:48:05.580 --> 00:48:06.280
Thanks.


00:48:06.280 --> 00:48:07.340
Yeah, thank you, everyone.


00:48:07.340 --> 00:48:08.480
How about a joke?


00:48:08.480 --> 00:48:09.120
Joke, yes.


00:48:09.120 --> 00:48:13.380
Sorry for almost skipping over your extras here.


00:48:13.380 --> 00:48:14.640
No worries.


00:48:14.640 --> 00:48:16.040
You ready? Yeah.


00:48:16.040 --> 00:48:20.080
So this one we talked I talked about that crazy giant ship thing.


00:48:20.080 --> 00:48:22.120
And we've got Marlene doing rapid.


00:48:22.120 --> 00:48:24.840
So I thought maybe some kind of machine learning joke.


00:48:24.840 --> 00:48:29.440
Here's a bunch of robots in school.


00:48:29.480 --> 00:48:32.720
And they go like little Android looking thing.


00:48:32.720 --> 00:48:35.120
Small ones because they're students, they're kids.


00:48:35.120 --> 00:48:36.920
And they're in machine learning class.


00:48:36.920 --> 00:48:40.120
And there's a big box of dirty data.


00:48:40.120 --> 00:48:42.600
Like a bunch of bits that are like kind of gray and


00:48:42.600 --> 00:48:44.000
they just have dirt on them.


00:48:44.000 --> 00:48:45.880
And the teacher says,


00:48:45.880 --> 00:48:47.760
"Robby, stop misbehaving


00:48:47.760 --> 00:48:49.760
or I will send you back to data cleaning."


00:48:49.760 --> 00:48:51.400
[Laughter]


00:48:51.400 --> 00:48:53.400
>> Oh.


00:48:53.400 --> 00:48:54.200
>> Yeah.


00:48:54.200 --> 00:48:56.400
>> That's where they're spending half the day anyway.


00:48:56.400 --> 00:48:58.200
>> Yeah, they actually spend most of their time there.


00:48:58.200 --> 00:48:59.080
That's right.


00:48:59.080 --> 00:49:00.720
I don't know who is drawing them.


00:49:00.720 --> 00:49:03.000
Like one of the robots is looking the wrong way.


00:49:03.000 --> 00:49:04.720
I was like, why is it drawn like that?


00:49:04.720 --> 00:49:05.720
I don't understand.


00:49:05.720 --> 00:49:11.280
- Hey, a more concrete, really quick closeout question


00:49:11.280 --> 00:49:13.040
I see in the live stream here is,


00:49:13.040 --> 00:49:16.400
Akmal, is there a difference between Kud-F


00:49:16.400 --> 00:49:18.720
and pandas in terms of utilization?


00:49:18.720 --> 00:49:23.280
- Like in terms of how you actually use them?


00:49:23.280 --> 00:49:26.760
Well, I don't think so.


00:49:26.760 --> 00:49:30.440
For the most part, when you're using QDF,


00:49:30.440 --> 00:49:32.760
the way it's built is to mirror Pandas,


00:49:32.760 --> 00:49:35.680
so the APIs are really similar.


00:49:35.680 --> 00:49:39.640
Ideally, the methods that you would use when you're using Pandas


00:49:39.640 --> 00:49:43.600
are exactly the same methods that you would use when you're using QDF.


00:49:43.600 --> 00:49:47.960
The only difference is when you're creating a Pandas DataFrame, for example,


00:49:47.960 --> 00:49:51.040
you would use pd.DataFrame, for example.


00:49:51.040 --> 00:49:54.280
But then with QDF, you would say qdf.DataFrame.


00:49:54.280 --> 00:49:57.620
If you make it into a variable or something like that,


00:49:57.620 --> 00:49:59.920
then the methods that you're gonna pull


00:49:59.920 --> 00:50:02.020
are gonna be probably identical.


00:50:02.020 --> 00:50:03.440
It's really easy to print.


00:50:03.440 --> 00:50:05.460
- Yeah, that's awesome.


00:50:05.460 --> 00:50:07.540
Yeah, and Dask has similar stuff as well, right?


00:50:07.540 --> 00:50:09.940
You create a Dask data frame instead of a Pandas data frame,


00:50:09.940 --> 00:50:11.480
but the API looks quite similar.


00:50:11.480 --> 00:50:13.820
They're not always 100% compatible,


00:50:13.820 --> 00:50:16.740
but most of the mainstream things, right?


00:50:16.740 --> 00:50:19.980
- Definitely, so yeah, it's built definitely


00:50:19.980 --> 00:50:22.700
to make it as easy as possible


00:50:22.700 --> 00:50:23.540
to switch between the two,


00:50:23.540 --> 00:50:24.900
to you. So it's very similar to y'all.


00:50:24.900 --> 00:50:26.900
Thanks a lot, everybody, for showing up.


00:50:26.900 --> 00:50:30.580
Yeah, thanks. Thanks, Marlene. It's really great to have you here.


00:50:30.580 --> 00:50:32.580
No problem. Thanks for having me.


00:50:32.580 --> 00:50:37.580
Thank you for listening to Python Bytes. Follow the show on Twitter via @PythonBytes. That's


00:50:37.580 --> 00:50:44.100
Python Bytes as in B-Y-T-E-S. And get the full show notes at PythonBytes.fm. If you


00:50:44.100 --> 00:50:48.160
have a news item you want featured, just visit PythonBytes.fm and send it our way. We're


00:50:48.160 --> 00:50:53.020
always on the lookout for sharing something cool. On behalf of myself and Brian Aukin,


00:50:53.020 --> 00:50:54.020
This is Michael Kennedy.


00:50:54.020 --> 00:50:57.420
Thank you for listening and sharing this podcast with your friends and colleagues.

