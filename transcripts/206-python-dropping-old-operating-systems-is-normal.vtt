
00:00:00.000 --> 00:00:05.000
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:05.000 --> 00:00:08.000
This is episode 206. Wow.


00:00:08.000 --> 00:00:10.500
Recorded October 28th, 2020.


00:00:10.500 --> 00:00:11.500
I am Brian Okken.


00:00:11.500 --> 00:00:12.500
And I'm Michael Kennedy.


00:00:12.500 --> 00:00:14.500
Yeah, and we have a special guest today, Steve Dower.


00:00:14.500 --> 00:00:15.500
Hi, thanks for having me on.


00:00:15.500 --> 00:00:18.000
Hey Steve. Thanks for coming. It's great to have you here.


00:00:18.000 --> 00:00:21.500
I also want to throw out that this is sponsored by Tech Meme Ride Home podcast.


00:00:21.500 --> 00:00:24.000
Check them out at pythonbytes.fm/ride.


00:00:24.000 --> 00:00:27.500
Steve, I'm sure many listeners know you, but maybe just give us the quick rundown.


00:00:27.500 --> 00:00:32.220
and you do cool stuff at Microsoft, getting Python better on Windows and you're a core developer.


00:00:32.220 --> 00:00:37.580
Yeah, so my main day job is for Microsoft, where I work as basically a Python engineer,


00:00:37.580 --> 00:00:44.860
kind of a wide-ranging resource to the company. So I haven't shipped anything of my own in a while,


00:00:44.860 --> 00:00:49.180
but I've had my fingers in a lot of Python-related things that have gone out recently.


00:00:49.180 --> 00:00:52.140
So it's a lot of fun, a lot of bouncing around between different teams,


00:00:52.140 --> 00:00:56.540
getting to work with a lot of different people. And yeah, as you say, I'm a CPython core developer,


00:00:56.540 --> 00:00:58.940
one of the Windows experts on the team,


00:00:58.940 --> 00:01:01.340
I'm responsible for the builds that go up on python.org,


00:01:01.340 --> 00:01:04.840
and just generally keeping Python running well on Windows.


00:01:04.840 --> 00:01:06.340
Yeah, that's awesome.


00:01:06.340 --> 00:01:08.840
And you've done some interesting talks, like,


00:01:08.840 --> 00:01:10.840
"Python is okay on Windows, actually,"


00:01:10.840 --> 00:01:12.540
and talked about some of the popularity of it,


00:01:12.540 --> 00:01:14.540
and how we as a community shouldn't


00:01:14.540 --> 00:01:16.840
discount it just because we might happen to be on a Mac


00:01:16.840 --> 00:01:18.840
or use Linux or whatever, right?


00:01:18.840 --> 00:01:20.840
A lot of people do Python on Windows.


00:01:20.840 --> 00:01:23.040
Yeah, yeah. The estimates vary,


00:01:23.040 --> 00:01:25.040
and every time I get new numbers,


00:01:25.040 --> 00:01:28.640
they seem to show up slightly different. So it's real hard to get a good fix on how many


00:01:28.640 --> 00:01:33.520
Python developers there even are in the world. I did get some numbers recently that I had a few


00:01:33.520 --> 00:01:37.920
people double check because they were saying there's like 20 million installs of Python


00:01:37.920 --> 00:01:40.800
on Windows in the entire ecosystem. Wow.


00:01:40.800 --> 00:01:44.720
Which sounded like too many to me. So I had them double check. And then I had someone else double


00:01:44.720 --> 00:01:49.200
check. And they all came back saying, yeah, it's about that. So I'm like, okay, there's a lot of


00:01:49.200 --> 00:01:53.600
Python on Windows out there. But yeah, it doesn't show up in conferences, doesn't show up on Twitter


00:01:53.600 --> 00:01:57.440
that much and a lot of people just look at the packages that don't work and go well I guess it


00:01:57.440 --> 00:02:01.840
doesn't exist on windows because otherwise this package would work and so you know chicken and


00:02:01.840 --> 00:02:06.080
egg problem right yeah there's a lot of chicken and egg problems in the python space I mean it's


00:02:06.080 --> 00:02:09.840
a beautiful place but there are some of these weird chicken and egg ones yeah it's weird I've


00:02:09.840 --> 00:02:16.160
been using python on windows since I started python so have I but one thing I haven't been using


00:02:16.160 --> 00:02:22.720
very much is enums so that was an attempt at a transition so why not Brian tell us more


00:02:22.720 --> 00:02:28.720
Actually, I've tried many times I've tried to use enums and I actually just to be honest,


00:02:28.720 --> 00:02:34.960
I don't very much and partly because I'm used to using enums in C and C++ and they're, they


00:02:34.960 --> 00:02:39.720
just act like symbols in C and C++, they work pretty good.


00:02:39.720 --> 00:02:44.360
There is some weirdness with enums in Python and I'm going to highlight an article called


00:02:44.360 --> 00:02:49.440
Making Enums, as always, Arguably More Pythonic by Harry Percival.


00:02:49.440 --> 00:02:52.480
He starts it off by saying, I hate enums.


00:02:52.480 --> 00:02:58.640
So Harry's a funny guy and this is a fairly hilarious look at why enums are frustrating


00:02:58.640 --> 00:02:59.640
sometimes.


00:02:59.640 --> 00:03:04.920
And then he presents a semi-reasonable workaround, I think, to make them more usable.


00:03:04.920 --> 00:03:06.320
So what's wrong with enums?


00:03:06.320 --> 00:03:12.940
Well, he gives an example and just as a simple enum with string values.


00:03:12.940 --> 00:03:18.960
And you can't directly, if you try to compare one of the enum elements to the value, like


00:03:18.960 --> 00:03:22.560
the value gave, like a similar string, it's not equal.


00:03:22.560 --> 00:03:23.760
It doesn't compare.


00:03:23.760 --> 00:03:26.720
But you can use a dot value or an enum value,


00:03:26.720 --> 00:03:28.760
but that's just weird.


00:03:28.760 --> 00:03:31.200
He also said, he kind of thinks it'd be neat


00:03:31.200 --> 00:03:33.560
if you could do a random choice of all the enum values.


00:03:33.560 --> 00:03:34.940
I think that would be neat.


00:03:34.940 --> 00:03:37.480
And you can't directly convert them to a list.


00:03:37.480 --> 00:03:39.920
There's just interacting with the enum type itself


00:03:39.920 --> 00:03:43.700
or the class itself has problems.


00:03:43.700 --> 00:03:45.880
In the documentation, there is a suggestion


00:03:45.880 --> 00:03:48.900
that you can, instead of strings,


00:03:48.900 --> 00:03:52.220
use int and do an int enum and it works a little better.


00:03:52.220 --> 00:03:54.460
And if you like it like that, but want strings,


00:03:54.460 --> 00:03:57.320
you can make your own string enum class.


00:03:57.320 --> 00:03:59.140
I'm not sure why they didn't just build this


00:03:59.140 --> 00:04:01.860
into the default or, you know,


00:04:01.860 --> 00:04:03.200
one of the standard types anyway,


00:04:03.200 --> 00:04:07.460
but string enum is not there, but there's an example.


00:04:07.460 --> 00:04:11.460
And it sort of fixes a lot of stuff, but not everything.


00:04:11.460 --> 00:04:12.900
It doesn't, still doesn't allow


00:04:12.900 --> 00:04:14.800
for those direct comparisons.


00:04:14.800 --> 00:04:17.060
So the solution that Harry came up with


00:04:17.060 --> 00:04:19.140
is just kind of like the solution


00:04:19.140 --> 00:04:20.900
the documentation says,


00:04:20.900 --> 00:04:24.180
derived from both enum type and str


00:04:24.180 --> 00:04:26.520
when you're creating your enum class,


00:04:26.520 --> 00:04:29.780
but then also define this little snippet


00:04:29.780 --> 00:04:32.560
of a dunder str method,


00:04:32.560 --> 00:04:35.560
so that the str method works better.


00:04:35.560 --> 00:04:36.460
And at that point,


00:04:36.460 --> 00:04:38.760
most of the stuff works that he wants to work.


00:04:38.760 --> 00:04:41.180
It still doesn't do random choice,


00:04:41.180 --> 00:04:43.900
but apparently he's gotten over that a little bit.


00:04:43.900 --> 00:04:46.380
So I actually think this is really,


00:04:46.380 --> 00:04:48.380
This is still just a really small snippet,


00:04:48.380 --> 00:04:52.620
it's like two lines of extra code to add to your enum types,


00:04:52.620 --> 00:04:54.260
make them a little bit more usable.


00:04:54.260 --> 00:04:55.540
So I think it's reasonable.


00:04:55.540 --> 00:05:00.020
- If you're judging by like value add per character,


00:05:00.020 --> 00:05:02.120
this is awesome because it makes working


00:05:02.120 --> 00:05:03.620
with the enumeration so much nicer.


00:05:03.620 --> 00:05:06.740
You can do like the natural things that you would expect,


00:05:06.740 --> 00:05:08.500
especially around testing and comparison.


00:05:08.500 --> 00:05:11.060
And it's like also add a drive from str


00:05:11.060 --> 00:05:14.380
and just add a dunder str method and you're good.


00:05:14.380 --> 00:05:15.260
Steve, what do you think about this?


00:05:15.260 --> 00:05:20.400
Yeah, I'd just add that the gotcha that you have by doing this is now you can have two


00:05:20.400 --> 00:05:24.980
values from different enums compare as equal, which as I recall from the original discussions


00:05:24.980 --> 00:05:27.920
was the reason this wasn't put in by default.


00:05:27.920 --> 00:05:33.820
Say you've got a color enumeration and a fruit enumeration, is orange the same between the


00:05:33.820 --> 00:05:34.820
two?


00:05:34.820 --> 00:05:37.980
And I think the decision was made for enums to say no, it's not.


00:05:37.980 --> 00:05:41.640
If it's a fruit orange, it's different from the color orange.


00:05:41.640 --> 00:05:44.180
Making this change or using an int enum is going to make them equal.


00:05:44.180 --> 00:05:46.380
So as long as you're prepared to deal with that, which,


00:05:46.380 --> 00:05:48.880
to be quite honest, every time I've reached for enums,


00:05:48.880 --> 00:05:51.180
I am much happier with string literals


00:05:51.180 --> 00:05:53.980
and quite comfortable with them matching equal.


00:05:53.980 --> 00:05:54.380
Yeah.


00:05:54.380 --> 00:05:55.680
But that is just one thing to watch out for.


00:05:55.680 --> 00:05:58.080
Usually it's about constraining the list of things.


00:05:58.080 --> 00:05:59.280
Like, I know there's five things.


00:05:59.280 --> 00:06:02.180
I want to make sure I don't, like, somehow mix up what those five are.


00:06:02.180 --> 00:06:05.680
I just want to go, you know, class dot, and here's the five.


00:06:05.680 --> 00:06:07.680
Let my editor tell me which one of those it is.


00:06:07.680 --> 00:06:09.480
It seems like it's all there.


00:06:09.480 --> 00:06:11.480
So what do you think about if you overrode,


00:06:11.480 --> 00:06:15.240
like if you added gender eq, gender neq,


00:06:15.240 --> 00:06:18.200
so like the comparison would say it has to be


00:06:18.200 --> 00:06:21.080
this type of enumeration and the str value has to match.


00:06:21.080 --> 00:06:23.080
Yeah, that would certainly deal with that. Gotcha.


00:06:23.080 --> 00:06:24.920
Again, when these were being designed,


00:06:24.920 --> 00:06:27.640
basically anything that gets designed and added to Python


00:06:27.640 --> 00:06:31.000
has a very large group of very smart people work through it.


00:06:31.000 --> 00:06:33.640
And, you know, as a result, things always get missed.


00:06:33.640 --> 00:06:35.240
So it's possible that one was just missed.


00:06:35.240 --> 00:06:38.120
It's also possible that someone did figure out a reason


00:06:38.120 --> 00:06:40.680
why that was also risky.


00:06:40.680 --> 00:06:45.080
And, you know, risky when you're developing one of the most popular languages in the world


00:06:45.080 --> 00:06:47.320
is just anything that might surprise anyone.


00:06:47.320 --> 00:06:50.680
So someone has deliberately designed around using enums everywhere,


00:06:50.680 --> 00:06:52.200
they're probably not going to be surprised.


00:06:52.200 --> 00:06:57.640
Someone who is using code and that developer has swapped out all of their...


00:06:57.640 --> 00:07:00.840
You know, they had a class with static variables and they turned it into an enum,


00:07:00.840 --> 00:07:05.080
and now stuff breaks because of the defaults that were chosen for enum.


00:07:05.080 --> 00:07:09.160
That's the kind of thing that you're trying to avoid in a language that


00:07:09.160 --> 00:07:12.160
has anywhere between 5 and 20 million


00:07:12.160 --> 00:07:14.160
kind of regular users.


00:07:14.160 --> 00:07:17.160
But as a workaround, I mean, if you know where your enum is going to be used,


00:07:17.160 --> 00:07:20.160
there's a reason you can derive from string and it's exactly for stuff like this.


00:07:20.160 --> 00:07:24.520
Yeah, thanks, Harry, for putting out there. That's quite a neat little bit of advice there.


00:07:24.520 --> 00:07:26.760
And I'm so glad that we have Steve here


00:07:26.760 --> 00:07:29.560
because I picked some sort of semi-internal


00:07:29.560 --> 00:07:33.000
type of pieces and I'm going to make some statements about it.


00:07:33.000 --> 00:07:36.000
And then Steve can correct me to make it more accurate.


00:07:36.000 --> 00:07:38.680
And also we get the core developer's perspective.


00:07:38.680 --> 00:07:41.680
Not that you represent all core developers, but at least a slice.


00:07:41.680 --> 00:07:46.840
All right, so this next one I want to cover is that Python 3.10 will be 10% faster.


00:07:46.840 --> 00:07:49.840
And this is 4.5 years in the making.


00:07:49.840 --> 00:07:57.320
So Yuri Stelovanov long ago did some work on optimizing, I think,


00:07:57.320 --> 00:08:02.840
was it load attribute or was it load method, load call method?


00:08:02.840 --> 00:08:08.640
So about some of these load operations down at the CPython CUVal level.


00:08:08.640 --> 00:08:13.940
And then Pablo Galindo, who's also a core developer,


00:08:13.940 --> 00:08:17.140
and the Python 3.10.3.11 release manager,


00:08:17.140 --> 00:08:20.140
picked up this work, and now we have load method,


00:08:20.140 --> 00:08:23.140
call method, and load global going faster.


00:08:23.140 --> 00:08:28.640
So basically, there's some optimizations around those opcodes


00:08:28.640 --> 00:08:30.640
that make this much faster.


00:08:30.640 --> 00:08:35.640
And this idea apparently first originated in PyPy, P-Y, P-Y.


00:08:35.640 --> 00:08:38.640
So I'm pretty excited to see that


00:08:38.640 --> 00:08:42.040
some simple internals that don't seem to change a whole lot of stuff


00:08:42.040 --> 00:08:43.540
might make this a lot faster.


00:08:43.540 --> 00:08:44.340
What do you think, Steve?


00:08:44.340 --> 00:08:46.740
This one is real. I was so excited about this


00:08:46.740 --> 00:08:48.340
when it was first being proposed.


00:08:48.340 --> 00:08:50.640
The basis of the idea is that


00:08:50.640 --> 00:08:52.640
Python keeps everything in dictionaries,


00:08:52.640 --> 00:08:54.840
which means every time you look up


00:08:54.840 --> 00:08:56.640
.name of anything,


00:08:56.640 --> 00:08:58.340
it takes that name, makes it a string,


00:08:58.340 --> 00:08:59.240
turns it into a...


00:08:59.240 --> 00:09:00.540
gets the hash value,


00:09:00.540 --> 00:09:02.840
looks it up in a dictionary, finds the value,


00:09:02.840 --> 00:09:04.940
maybe wraps that up in some extra stuff,


00:09:04.940 --> 00:09:08.620
Like if it's going to be a method, it's not stored as a method, you turn it into a method


00:09:08.620 --> 00:09:11.980
when you know what it's being kind of dotted through to get to,


00:09:11.980 --> 00:09:14.380
and then returns that. That's a whole lot of work.


00:09:14.380 --> 00:09:18.220
And if you're regularly calling the same method over and over again,


00:09:18.220 --> 00:09:19.260
why not cache it?


00:09:19.260 --> 00:09:22.460
That's the heart of this, right? It does that cache around load data, right?


00:09:22.460 --> 00:09:26.140
Yeah, it does that cache. And the insight that Yuri had that he made work,


00:09:26.140 --> 00:09:30.780
and in fact, I think someone else had suggested it earlier and hadn't gotten it to work was


00:09:30.780 --> 00:09:32.780
what happens when things change?


00:09:32.780 --> 00:09:38.300
Because again, as I say, it's we're designing language for many, many people do all sorts of weird things.


00:09:38.300 --> 00:09:43.420
And if you cache a method lookup, and then someone tries to monkey patch it, you know, we've now broken their code


00:09:43.420 --> 00:09:49.100
for the sake of an optimization, which, you know, is a no-no in Pythons, like correctness beats performance.


00:09:49.100 --> 00:09:52.700
In every case, that's just the trade off that the language chooses to make.


00:09:52.700 --> 00:09:54.700
That's almost always what you want, right?


00:09:54.700 --> 00:09:57.820
When would you want to be faster and wrong rather than slower and right?


00:09:57.820 --> 00:10:00.140
I'd be happy with faster and no monkey patching.


00:10:00.140 --> 00:10:08.240
But yes, yes, sure, like faster and fewer restricted capabilities might be a really good trade off, but faster and wrong. It's not a good one. Yeah,


00:10:08.240 --> 00:10:16.340
we did some benchmarking and basically found that there was a way to track all dictionary updates in the entire runtime


00:10:16.340 --> 00:10:22.240
with a version tag that was not going to instantly overflow and not going to break everything.


00:10:22.240 --> 00:10:27.340
So it became really easy to say, has this dictionary changed since I last looked at it


00:10:27.340 --> 00:10:29.220
with one single value comparison.


00:10:29.220 --> 00:10:31.500
And so it looks at that value.


00:10:31.500 --> 00:10:34.300
If it has changed, it's going to do the full lockup again.


00:10:34.300 --> 00:10:40.220
99.999% of the time it hasn't changed, so it can give you the cached value and you saved


00:10:40.220 --> 00:10:43.180
big dictionary lookup, possibly error handling,


00:10:43.180 --> 00:10:46.460
descriptor protocol, all of this extra stuff that


00:10:46.460 --> 00:10:49.060
just adds so much weight to every operation.


00:10:49.060 --> 00:10:51.940
Yeah, and that's everywhere. I mean, that's everywhere in the language.


00:10:51.940 --> 00:10:52.940
Absolutely everywhere.


00:10:52.940 --> 00:10:56.620
Fantastic. One of the things when I was first getting into Python that made me


00:10:56.620 --> 00:10:59.740
sort of have a sad face was realizing that


00:10:59.740 --> 00:11:02.740
having function calls was pretty expensive.


00:11:02.740 --> 00:11:05.620
Right? Like having a big call chain,


00:11:05.620 --> 00:11:09.020
like actually the act of calling a function has a fair amount of overhead.


00:11:09.020 --> 00:11:12.820
When I wanted to break my code into like a bunch of small functions to make it real readable,


00:11:12.820 --> 00:11:14.820
this part needs to go a little faster.


00:11:14.820 --> 00:11:17.380
Maybe that's not what I want.


00:11:17.380 --> 00:11:20.100
You know, and so hopefully this helps with that as well.


00:11:20.100 --> 00:11:25.100
Yeah, that and vector call is another optimization that we got in recently.


00:11:25.100 --> 00:11:37.720
I think that might have been the pet 509 actually was a vector call also designed to make that faster just removing some of the internal steps for doing a function call fantastic and like Brian said this is everywhere so that's


00:11:37.720 --> 00:11:40.020
everyone's gonna benefit this is fantastic.


00:11:40.020 --> 00:11:42.860
Well we would like to thank our sponsor.


00:11:43.120 --> 00:11:54.180
So this episode is brought to you by tech meme ride home podcast is a great podcast for more than two years and nearly seven hundred episodes the tech meme ride home.


00:11:54.180 --> 00:12:07.660
Has been silicon valley's favorite tech news podcast the tech meme ride home is a daily podcast only fifteen to twenty minutes long and even and every day by five p.m. eastern it's all the latest tech news.


00:12:08.020 --> 00:12:11.540
But it's more than just headlines. You could get a robot to read your headlines.


00:12:11.540 --> 00:12:16.180
The Techmeme Ride Home is all the context around the latest news of the day.


00:12:16.180 --> 00:12:20.420
It's all the top stories, the top posts and tweets, and conversations about those stories,


00:12:20.420 --> 00:12:25.940
as well as behind-the-scenes analysis. The Techmeme Ride Home is the TLDR as a service.


00:12:25.940 --> 00:12:31.780
The folks at Techmeme are online all day reading everything so they can catch you up. Search your


00:12:31.780 --> 00:12:38.340
podcast app now for ride home and subscribe to the tech meme ride home podcast or visit


00:12:38.340 --> 00:12:43.220
pythonbytes.fm/ride to subscribe. Yeah thanks for sponsoring the show and Brian,


00:12:43.220 --> 00:12:48.900
every day, like we do this once a week and it's a lot of work. These guys are on it. I could totally


00:12:48.900 --> 00:12:53.540
do this every day. If I didn't have another job I would not have any problem with catching up on


00:12:53.540 --> 00:12:59.460
Python news daily. So actually sounds quite lovely. I wonder how that podcast is doing now that not so


00:12:59.460 --> 00:13:04.000
so many people are having to commute to and from work.


00:13:04.000 --> 00:13:10.280
That sounds like one of the things where you hope that you've given people the excuse to


00:13:10.280 --> 00:13:13.840
tell their employer on my commute between 4 and 5 p.m.


00:13:13.840 --> 00:13:14.840
I can't do it.


00:13:14.840 --> 00:13:18.040
I've logged off and go listen to a podcast during that time.


00:13:18.040 --> 00:13:20.800
I listen to podcasts while I'm, I realized I was missing out.


00:13:20.800 --> 00:13:23.760
So I started listening to podcasts while I'm doing my laundry.


00:13:23.760 --> 00:13:26.760
I do it when I'm doing dishes.


00:13:26.760 --> 00:13:29.640
I listen when I'm doing yard work, stuff like that.


00:13:29.640 --> 00:13:32.160
- Yeah, I recently broke out some other older podcasts


00:13:32.160 --> 00:13:35.000
just to catch up on stuff with a big mess


00:13:35.000 --> 00:13:35.840
I had around the home.


00:13:35.840 --> 00:13:37.400
Like it's a long story with a new puppy


00:13:37.400 --> 00:13:39.120
that's not worth going into.


00:13:39.120 --> 00:13:41.400
(both laughing)


00:13:41.400 --> 00:13:42.520
Maybe I'll tell you guys after the show.


00:13:42.520 --> 00:13:43.920
It's pretty outrageous.


00:13:43.920 --> 00:13:46.360
Anyway, yeah, and it's so enjoyable.


00:13:46.360 --> 00:13:48.720
But what I've actually found is shows like Python Bytes


00:13:48.720 --> 00:13:51.760
and Write Home that have like a bunch of short little things


00:13:51.760 --> 00:13:53.480
that you can just drop in and out of,


00:13:53.480 --> 00:13:55.300
match a lot better now that people


00:13:55.300 --> 00:13:56.320
are not commuting so much.


00:13:56.320 --> 00:13:59.200
you can do that 10 minutes while you're folding laundry


00:13:59.200 --> 00:14:00.680
and get a whole segment.


00:14:00.680 --> 00:14:02.280
So I think it gets varied,


00:14:02.280 --> 00:14:03.760
but actually it's pretty interesting.


00:14:03.760 --> 00:14:06.520
I think that they and us here are well positioned.


00:14:06.520 --> 00:14:09.480
Like Talk Python has more of a dip than Python Bytes.


00:14:09.480 --> 00:14:10.760
- Have you surveyed your listeners


00:14:10.760 --> 00:14:12.520
to find out what they're doing while they listen to you?


00:14:12.520 --> 00:14:13.600
- No, not really.


00:14:13.600 --> 00:14:16.500
- Everyone should tweet at these guys' Twitter.


00:14:16.500 --> 00:14:19.040
What were you doing when you were hearing this podcast?


00:14:19.040 --> 00:14:20.000
- Yeah, that's awesome.


00:14:20.000 --> 00:14:21.780
I've got a few anecdotes,


00:14:21.780 --> 00:14:24.680
but nothing like a survey that would give me a proper answer.


00:14:24.680 --> 00:14:27.640
Steve, I think your next item is super, super interesting.


00:14:27.640 --> 00:14:30.000
And people speaking to Twitter, right?


00:14:30.000 --> 00:14:34.640
Like this whole conversation started as a, "Hey, Twitter message."


00:14:34.640 --> 00:14:35.720
Like, why did this happen?


00:14:35.720 --> 00:14:36.520
Well, let's ask Steve.


00:14:36.520 --> 00:14:39.480
Yeah, as you know, I spend a decent amount of time on Twitter.


00:14:39.480 --> 00:14:42.520
My handle there is Zuba, Z-O-O-B-A,


00:14:42.520 --> 00:14:45.760
which you'll probably never find in search if you're looking for my name,


00:14:45.760 --> 00:14:46.960
but that's where I am.


00:14:46.960 --> 00:14:51.440
I really like actually searching for what people are saying about Python on Windows.


00:14:51.800 --> 00:14:55.000
It's kind of the most honest feedback you get when they think you're not listening


00:14:55.000 --> 00:14:57.880
And so I go and listen and one of these popped up


00:14:57.880 --> 00:15:04.760
Which was oh, I tried to install python 3.9 newest release about a little bit under a month ago


00:15:04.760 --> 00:15:08.280
On my windows 7 machine and I couldn't install it


00:15:08.280 --> 00:15:11.320
And since then i've actually seen a few more posts


00:15:11.320 --> 00:15:17.240
Someone managed to bypass the installer completely and get it all the way onto their windows 7 machine and then found out it wouldn't run


00:15:17.240 --> 00:15:19.320
oh, man, yeah, and


00:15:19.320 --> 00:15:23.640
So the question was asked, like, why would you do this? Windows 7 is still a fairly big platform.


00:15:23.640 --> 00:15:27.080
Why would you take it out? And, you know, the answer was just a bit too long for a tweet.


00:15:27.080 --> 00:15:31.400
But someone, you know, kindly included Python bytes in the reply. And so I said, hey, I'll


00:15:31.400 --> 00:15:38.680
come on and talk about it. So let's do this topic. And the answer is, multiple legal looking


00:15:38.680 --> 00:15:43.160
documents all come together and have to be read in parallel to figure out why we dropped it.


00:15:45.720 --> 00:15:48.360
Yeah, the small business owners know what I'm talking about.


00:15:48.360 --> 00:15:53.960
So one of those documents is PEP 11, one of the lowest number PEPs that we have,


00:15:53.960 --> 00:15:57.160
and it's titled "Removing Support for Little-Used Platforms".


00:15:57.160 --> 00:16:02.760
The title was not originally about Windows, but there is a section in that PEP


00:16:02.760 --> 00:16:06.120
that describes Python's policy for supporting Windows.


00:16:06.120 --> 00:16:12.040
On release day of 3.x.0, all the supported versions of Windows


00:16:12.040 --> 00:16:15.180
covered by Microsoft Support Lifecycle


00:16:15.180 --> 00:16:17.640
will be supported by CPython.


00:16:17.640 --> 00:16:20.680
And that's on the 3.x.0 release date.


00:16:20.680 --> 00:16:24.120
So what that means is then you now have to go and look at


00:16:24.120 --> 00:16:26.120
Microsoft Support Lifecycle website


00:16:26.120 --> 00:16:28.840
and look up all of the different versions of Windows


00:16:28.840 --> 00:16:32.280
to see which ones are still covered by support to that date.


00:16:32.280 --> 00:16:35.800
Windows 7 fell out of extended support in January.


00:16:35.800 --> 00:16:37.800
There was quite a bit of noise about that


00:16:37.800 --> 00:16:40.760
because that means no more security patches


00:16:40.760 --> 00:16:43.320
except Microsoft did do a couple more security patches


00:16:43.320 --> 00:16:47.160
because some really bad stuff was found, but that's largely stopped.


00:16:47.160 --> 00:16:51.040
Essentially, it's the point when the only people who get Windows 7 support


00:16:51.040 --> 00:16:54.920
are paying for it, and I assume they're paying large amounts of money for it.


00:16:54.920 --> 00:16:56.920
I don't actually know how much it costs,


00:16:56.920 --> 00:16:58.920
but that's the point where, you know,


00:16:58.920 --> 00:17:01.280
you bought it, but you don't get the free support anymore.


00:17:01.280 --> 00:17:03.280
So CPython follows that because


00:17:03.280 --> 00:17:05.920
no one is paying the core team to support


00:17:05.920 --> 00:17:07.920
Python on all of these platforms.


00:17:07.920 --> 00:17:09.920
And so it's, it seems like


00:17:09.920 --> 00:17:16.480
The fairest point to draw that line is at some point, we have to say our volunteers can no longer


00:17:16.480 --> 00:17:22.720
keep a Windows 7 machine running. Even I can't keep a Windows 7 machine running safely because


00:17:22.720 --> 00:17:26.640
there's no security updates for it. How am I meant to develop Python on it? How am I meant to test


00:17:26.640 --> 00:17:32.960
Python on it? The burden there is too high for volunteers to handle. So we just say that's the


00:17:32.960 --> 00:17:37.760
point where it goes away. So because those two documents lined up, Windows 8 actually dropped


00:17:37.760 --> 00:17:42.640
off a couple of years ago because the support life cycle ended early for that to force everyone


00:17:42.640 --> 00:17:48.640
onto 8.1. Windows 8.1 has about three more years, so I think Python 3.12 will be the last one to


00:17:48.640 --> 00:17:53.840
support 8.1, and then it's all Windows 10 or whatever comes out in the future. Yeah, yeah,


00:17:53.840 --> 00:17:59.440
Windows 10x or whatever they call it. That's a different one. That's the Xbox. Yeah, so I,


00:17:59.440 --> 00:18:04.960
you know, I think this makes a ton of sense and two thoughts I had as you were laying out the


00:18:04.960 --> 00:18:10.800
the case here. One is if you're running a Windows 7 and you can't upgrade to even


00:18:10.800 --> 00:18:14.520
Windows 8 or more recently Windows 10 or one of the server equivalents, right?


00:18:14.520 --> 00:18:18.760
I'm sure there's like a server equivalent like Windows 2003 server. I don't know


00:18:18.760 --> 00:18:21.280
how long I support it but whenever it goes out it probably falls under that


00:18:21.280 --> 00:18:25.160
banner as well, right? Yeah, Windows server is a bit more interesting. Their life


00:18:25.160 --> 00:18:30.640
cycles tend to last longer. But historically CPython has only kind of


00:18:30.640 --> 00:18:33.360
tied itself to the client operating systems.


00:18:33.360 --> 00:18:35.360
Gotcha. Oh, interesting. Okay.


00:18:35.360 --> 00:18:37.360
So to me, I feel like if you're running


00:18:37.360 --> 00:18:39.360
code, you're running systems


00:18:39.360 --> 00:18:41.360
that old, you must be running it because it's


00:18:41.360 --> 00:18:44.000
like some super legacy thing.


00:18:44.000 --> 00:18:46.000
So do you absolutely


00:18:46.000 --> 00:18:48.000
necessarily need to have the most cutting


00:18:48.000 --> 00:18:50.000
edge Python or


00:18:50.000 --> 00:18:52.000
whatever language? It's


00:18:52.000 --> 00:18:54.000
probably something that's that


00:18:54.000 --> 00:18:56.000
way because it's calcified


00:18:56.000 --> 00:18:58.000
and you probably don't need or


00:18:58.000 --> 00:19:00.000
you probably shouldn't be putting like the newest


00:19:00.000 --> 00:19:03.120
as shiny as things on it, right? That's that one. What do you think?


00:19:03.120 --> 00:19:08.080
Yeah, no, I totally agree with that. If that setup that you're running is so


00:19:08.080 --> 00:19:12.960
critical that you can't upgrade the operating system, how can you upgrade a language runtime?


00:19:12.960 --> 00:19:15.440
Like, how can you upgrade anything on that?


00:19:15.440 --> 00:19:18.720
I feel like it's in the category of, "Please just don't touch it. It's over there.


00:19:18.720 --> 00:19:23.360
Just don't even walk by. Leave it alone. We cannot have it break. Just leave it over there."


00:19:23.360 --> 00:19:26.080
It probably still has a PS/2 keyboard plugged into it.


00:19:26.080 --> 00:19:29.520
Oh, it might with a little blue or pink round thing. Yeah, absolutely.


00:19:29.520 --> 00:19:31.840
The screen has probably got at least 16 colors.


00:19:31.840 --> 00:19:33.840
Yeah, and the monitor is probably really heavy.


00:19:33.840 --> 00:19:35.840
Windows 7 is not that old.


00:19:35.840 --> 00:19:37.840
Some of the...


00:19:37.840 --> 00:19:40.240
Seriously, like this stuff is old and you probably don't want to touch it, right?


00:19:40.240 --> 00:19:42.240
Yeah, that's exactly it.


00:19:42.240 --> 00:19:45.360
It's all the motivation that you would have for updating to Python 3.9


00:19:45.360 --> 00:19:48.560
from 3.8. And again, we're talking about a version that's only one year old.


00:19:48.560 --> 00:19:50.560
Like Python 3.8 is not that old.


00:19:50.560 --> 00:19:53.200
And you desperately need to upgrade to 3.9.


00:19:53.200 --> 00:19:56.480
You even more desperately need to upgrade Windows.


00:19:56.480 --> 00:19:58.480
And there's just really...


00:19:58.480 --> 00:20:06.000
There really is no question about that. The same thing applies to early versions of Ubuntu. People running Ubuntu 14 or even 16 at this point


00:20:06.000 --> 00:20:11.800
need to be facing the same thing. And we have similar discussions around OpenSSL


00:20:11.800 --> 00:20:18.600
where occasionally people will be, "Oh, I need Python 3.9 to run on OpenSSL 0.9."


00:20:18.600 --> 00:20:22.880
To which our answer is basically, "That's pretty hot-bleed."


00:20:22.880 --> 00:20:29.660
I'm gonna play the other side i totally get the reasons but i also get the questions.


00:20:29.660 --> 00:20:43.460
Because the users and the developers or the whoever's wanting to install python they usually don't get to choose what operating system they're using but they do get to choose which version of python.


00:20:43.660 --> 00:20:56.300
So i do get send in some cases and inside the room true i totally understand where the questions coming yeah we joke about how old these machines are and they're really not like people are setting up new machines


00:20:56.300 --> 00:21:00.980
probably with windows seven they certainly were within the last year and there's good legitimate reasons for that.


00:21:00.980 --> 00:21:06.980
And you know when not you're making fun of some of the apparent contradictions but we're definitely not making fun of the people who have


00:21:06.900 --> 00:21:09.160
you know, often being forced into these positions.


00:21:09.160 --> 00:21:12.660
But the reality is we can't afford as a volunteer team


00:21:12.660 --> 00:21:16.620
to maintain Python against unmaintained operating systems.


00:21:16.620 --> 00:21:19.060
And so, you know, the advice is,


00:21:19.060 --> 00:21:21.380
stay on the previous version of Python,


00:21:21.380 --> 00:21:24.420
that the latest version of Python that works for you,


00:21:24.420 --> 00:21:26.900
it's not going to break, we're not changing it.


00:21:26.900 --> 00:21:30.140
Anything new that comes up, security fixes will still come out.


00:21:30.140 --> 00:21:32.860
At some point, there just has to be a line drawn.


00:21:32.860 --> 00:21:35.180
And that's the point where we've chosen to draw it.


00:21:35.180 --> 00:21:37.940
The other thing I want to point out that we changed in this release,


00:21:37.940 --> 00:21:41.140
which people are more excited about, is if you go to python.org


00:21:41.140 --> 00:21:43.140
to download Python for Windows,


00:21:43.140 --> 00:21:45.700
you get this real big obvious button up front


00:21:45.700 --> 00:21:48.460
that just says "Download for Windows" or "Download Now" or something.


00:21:48.460 --> 00:21:52.060
As of Python 3.9, that's now getting the 64-bit version


00:21:52.060 --> 00:21:54.060
rather than the 32-bit version.


00:21:54.060 --> 00:21:55.820
For a long time, it's been 32-bit.


00:21:55.820 --> 00:21:57.620
The reason for that was compatibility.


00:21:57.620 --> 00:22:00.060
We knew a 32-bit one would run anywhere.


00:22:00.060 --> 00:22:03.460
When we put Python in the Windows Store, that was 64-bit only.


00:22:03.460 --> 00:22:06.860
we kind of wanted to test the waters and see, hey, will people notice


00:22:06.860 --> 00:22:08.860
that we haven't put a 32-bit version here?


00:22:08.860 --> 00:22:10.120
Turns out no one did.


00:22:10.120 --> 00:22:13.860
And so when we got to 3.9, had that change,


00:22:13.860 --> 00:22:18.820
we made it 64-bit by default. So that has a flow-on effect to the ecosystem.


00:22:18.820 --> 00:22:24.260
A lot of particularly data science packages would rather just do 64-bit only packages.


00:22:24.260 --> 00:22:28.580
Some of them certainly get theirs done first and not the 32-bit ones.


00:22:28.580 --> 00:22:31.380
So we expect to see some flow-on impact from that.


00:22:31.380 --> 00:22:36.220
just broader use of 64-bit Python throughout the Windows ecosystem.


00:22:36.220 --> 00:22:39.540
Yeah, that's super cool. And just like, the final thought I had was,


00:22:39.540 --> 00:22:42.580
you know, Django dropped Python 2, and they're like,


00:22:42.580 --> 00:22:46.540
we were able to remove so much code, and it is easier for new people to


00:22:46.540 --> 00:22:50.540
contribute because they don't have to write for two ecosystems, they write for one.


00:22:50.540 --> 00:22:53.980
NumPy did the same thing. And I feel like this is sort of the same story.


00:22:53.980 --> 00:22:56.220
Like, you guys can just not worry about


00:22:56.220 --> 00:22:59.580
yet another older, outdated operating system.


00:22:59.580 --> 00:23:02.180
and stay focused on what most people care about.


00:23:02.180 --> 00:23:06.300
One thing that someone did suggest in one discussion was why not dynamically


00:23:06.300 --> 00:23:08.460
light stuff up for the newer operating system.


00:23:08.460 --> 00:23:10.460
And the answer is we do that.


00:23:10.460 --> 00:23:15.300
And when we drop the older operating system, we get to delete about 100 lines of code


00:23:15.300 --> 00:23:17.660
for each point where we do that.


00:23:17.660 --> 00:23:19.580
So it is, we get to do a cleanup.


00:23:19.580 --> 00:23:23.380
We get to say, oh, we don't have to dynamically check for this API, this API,


00:23:23.380 --> 00:23:26.860
load this, cache this, store that, call that, call this, fallback.


00:23:26.860 --> 00:23:31.420
we can just condense that into, oh, we know that this API is there, so we can use it


00:23:31.420 --> 00:23:34.060
and just reduce a lot of


00:23:34.060 --> 00:23:37.900
kind of effectively dead code on newer operating systems.


00:23:37.900 --> 00:23:40.460
Is that a pre-compile like,


00:23:40.460 --> 00:23:42.140
hash if-death sort of thing,


00:23:42.140 --> 00:23:44.860
or is it a runtime thing? Does it make a performance difference?


00:23:44.860 --> 00:23:46.700
It definitely makes a performance difference,


00:23:46.700 --> 00:23:49.020
though we try and minimize it.


00:23:49.020 --> 00:23:51.020
But again, there's always some impact.


00:23:51.020 --> 00:23:55.340
It tends to be in operating system calls anyway, so you expect a bit of overhead.


00:23:55.340 --> 00:23:59.020
and so it's not going to add a significant kind of percentage overhead


00:23:59.020 --> 00:24:01.420
compared to whatever operation you're doing.


00:24:01.420 --> 00:24:05.660
But it does certainly add a lot of cognitive burden


00:24:05.660 --> 00:24:07.260
to someone who's reading the code.


00:24:07.260 --> 00:24:09.660
One example that we got to clean up recently,


00:24:09.660 --> 00:24:11.900
not in a previous version,


00:24:11.900 --> 00:24:15.500
was we had about, I think, 70 or 80 lines of code


00:24:15.500 --> 00:24:17.500
to concatenate two path segments.


00:24:17.500 --> 00:24:20.780
And this is before Python's loaded, so we have to do this with the operating system.


00:24:20.780 --> 00:24:27.260
The API call up until Windows 7, I think, so pre-Windows 7 was not secure.


00:24:27.260 --> 00:24:31.380
And it would, you know, buffer overruns, all sorts of horrible stuff,


00:24:31.380 --> 00:24:35.380
but it was the best available function there for handling certain cases.


00:24:35.380 --> 00:24:40.180
So we'd use it, but first we'd dynamically look for the newer, safer one, and call that.


00:24:40.180 --> 00:24:45.820
As soon as we dropped, I think, Vista, we could delete all of that code and just unconditionally call


00:24:45.820 --> 00:24:48.740
the one safe path combined function.


00:24:48.740 --> 00:24:51.240
And that code got a whole lot simpler.


00:24:51.240 --> 00:24:53.240
Yeah, lovely. That's awesome.


00:24:53.240 --> 00:24:55.240
Brian, would you say it's more robust now?


00:24:55.240 --> 00:24:58.140
Yes. I think it would be more robust.


00:24:58.140 --> 00:25:00.540
Actually, I thought I showed up to the


00:25:00.540 --> 00:25:03.540
Bash podcast. Is this the Python podcast?


00:25:03.540 --> 00:25:05.540
Yeah, this is. No, that's Bash Bytes.


00:25:05.540 --> 00:25:08.340
I love Python, of course. I still use


00:25:08.340 --> 00:25:12.140
Bash regularly. And I know a lot of people that are


00:25:12.140 --> 00:25:14.640
like sysops people and other people are using


00:25:14.640 --> 00:25:17.240
Bash daily as well. So I wanted to highlight this


00:25:17.240 --> 00:25:18.240
Cool article.


00:25:18.240 --> 00:25:20.580
This is an article by David Pashley called


00:25:20.580 --> 00:25:23.080
Writing Robust Bash Cell Scripts.


00:25:23.080 --> 00:25:26.280
And even though I've been writing scripts for decades,


00:25:26.280 --> 00:25:28.040
I learned a whole bunch in this,


00:25:28.040 --> 00:25:31.040
and I'm going to start changing the way I do things right away.


00:25:31.040 --> 00:25:34.340
The first two tips right away are things I'm going to do.


00:25:34.340 --> 00:25:37.540
First tip is to include a set-u.


00:25:37.540 --> 00:25:39.240
And never even heard of this.


00:25:39.240 --> 00:25:41.940
What it does is it makes your bash script exit


00:25:41.940 --> 00:25:45.540
if it encounters an uninitialized variable.


00:25:45.540 --> 00:25:50.140
So the problem without this is like, let's say you're constructing


00:25:50.140 --> 00:25:53.340
a path name or something or a long path,


00:25:53.340 --> 00:25:57.180
and one of the directories or file names you have in a variable,


00:25:57.180 --> 00:26:00.540
if that's never set, a bash normally just


00:26:00.540 --> 00:26:04.340
silently just deletes it, and it's just not there.


00:26:04.340 --> 00:26:09.220
And it'll still keep executing anyway, but it's not going to be what you want it to do.


00:26:09.220 --> 00:26:14.420
So, yeah, I definitely want to turn this on so I don't use uninitialized variables.


00:26:14.420 --> 00:26:19.620
Similarly, if any of your script statements returns a non-true value,


00:26:19.620 --> 00:26:24.660
so that's usually in scripts or shell work,


00:26:24.660 --> 00:26:27.360
non-true value means something bad happened.


00:26:27.360 --> 00:26:31.460
If you use set-e, that will make your script exit


00:26:31.460 --> 00:26:36.400
at any point if one of the sub-statements returns an error value.


00:26:36.400 --> 00:26:39.700
So you don't want to just keep rolling with an error condition.


00:26:39.700 --> 00:26:41.120
So this is good.


00:26:41.120 --> 00:26:44.720
I hopefully, I'll cautiously add this to scripts


00:26:44.720 --> 00:26:46.620
because I want to make sure they keep working.


00:26:46.620 --> 00:26:49.880
And then a tip just to say, expect the unexpected.


00:26:49.880 --> 00:26:52.260
There will be times where you'll have missing files


00:26:52.260 --> 00:26:54.220
or missing directories or directory


00:26:54.220 --> 00:26:55.920
that you're writing into is not created.


00:26:55.920 --> 00:26:57.820
So there's ways to make sure it's there


00:26:57.820 --> 00:26:59.380
before you write to it.


00:26:59.380 --> 00:27:01.680
Especially if you're running on Windows,


00:27:01.680 --> 00:27:03.960
be prepared for spaces and file names.


00:27:03.960 --> 00:27:07.220
And so variable expansion in Bash


00:27:07.220 --> 00:27:10.160
does not really isolate spaces.


00:27:10.220 --> 00:27:12.640
So you have to put quotes around expansion


00:27:12.640 --> 00:27:14.980
to make sure that it's a single thing.


00:27:14.980 --> 00:27:16.260
And one of the things right away,


00:27:16.260 --> 00:27:17.620
the next one is using trap


00:27:17.620 --> 00:27:20.860
and I've never actually knew how to do this before.


00:27:20.860 --> 00:27:23.760
So if you've got a bash script that's running


00:27:23.760 --> 00:27:26.960
and it just something's wrong and it won't exit,


00:27:26.960 --> 00:27:30.420
you can kill it or other ways to get it to stop.


00:27:30.420 --> 00:27:32.480
But if you have the system in a state


00:27:32.480 --> 00:27:34.660
that needs some cleanup,


00:27:34.660 --> 00:27:38.280
so that this there's a way to use a trap command


00:27:38.280 --> 00:27:41.360
to exit gracefully and clean up things.


00:27:41.360 --> 00:27:43.160
The last couple of points were be careful


00:27:43.160 --> 00:27:45.200
of race conditions and be atomic.


00:27:45.200 --> 00:27:46.220
Those are good things to do,


00:27:46.220 --> 00:27:49.060
but at least a handful of these I'll put to use right away.


00:27:49.060 --> 00:27:49.900
So it's good.


00:27:49.900 --> 00:27:50.960
- Yeah, this is neat.


00:27:50.960 --> 00:27:53.360
And a lot of the stuff I didn't really know about.


00:27:53.360 --> 00:27:57.360
So yeah, like continue on if something went wrong,


00:27:57.360 --> 00:27:58.280
just plow on ahead.


00:27:58.280 --> 00:28:00.480
Yeah, that's cool to know that you can make it stop.


00:28:00.480 --> 00:28:01.920
Steve, do you ever do any bash?


00:28:01.920 --> 00:28:04.040
You got a WSL thing going on over there?


00:28:04.040 --> 00:28:05.680
- I've certainly done a lot more bash


00:28:05.680 --> 00:28:08.600
since I started using WSL for a lot of things.


00:28:08.600 --> 00:28:12.280
I was aware that using an uninitialized variable


00:28:12.280 --> 00:28:15.680
would substitute nothing, but I'm very happy to know


00:28:15.680 --> 00:28:17.360
that there's a way to kind of turn that off


00:28:17.360 --> 00:28:19.280
'cause that has certainly caught me out


00:28:19.280 --> 00:28:21.560
in the past many times.


00:28:21.560 --> 00:28:24.040
And this looks like just a good article


00:28:24.040 --> 00:28:25.480
that I'm gonna have to go read myself now


00:28:25.480 --> 00:28:28.600
because it has everything that you learn


00:28:28.600 --> 00:28:31.920
from doing scripts in like Command Prompt or PowerShell


00:28:31.920 --> 00:28:34.080
or even Python to some extent.


00:28:34.080 --> 00:28:37.240
I have not personally mapped those to bash equivalents.


00:28:37.240 --> 00:28:39.200
So it sounds like this would be a good place for me


00:28:39.200 --> 00:28:42.680
to go through that and up my skills a little bit.


00:28:42.680 --> 00:28:44.280
My favorite thing was the find command.


00:28:44.280 --> 00:28:47.040
And once I got that, that felt as powerful as a reg X.


00:28:47.040 --> 00:28:47.880
And I'm kind of like,


00:28:47.880 --> 00:28:49.800
"Oh, I don't need to write a whole script now.


00:28:49.800 --> 00:28:53.360
I can just do one excessively long find command."


00:28:53.360 --> 00:28:54.360
(laughing)


00:28:54.360 --> 00:28:55.640
- Nice.


00:28:55.640 --> 00:28:56.960
- Yeah, you find a lot as well.


00:28:56.960 --> 00:28:58.420
- All right, this next one,


00:28:58.420 --> 00:28:59.600
I don't want to spend too much time on


00:28:59.600 --> 00:29:02.720
because I feel like we could easily just go


00:29:02.720 --> 00:29:03.600
and spend an hour on it.


00:29:03.600 --> 00:29:06.600
but for time's sake, we don't have a whole lot of time left


00:29:06.600 --> 00:29:08.600
for the episode because we have a bit of a hard stop.


00:29:08.600 --> 00:29:12.400
So I'm going to go through this and get your guys' thoughts on it real quick.


00:29:12.400 --> 00:29:17.480
There was a tweet about a GitHub repository


00:29:17.480 --> 00:29:21.800
that was a conversation on the Python mailing list.


00:29:21.800 --> 00:29:25.280
Lots of places. So Anthony Shaw tweeted


00:29:25.280 --> 00:29:28.680
calling attention to a roadmap by Mark Shannon


00:29:28.680 --> 00:29:34.480
called Ideas for Making for 5x Faster CPython.


00:29:34.480 --> 00:29:37.880
So he laid out a roadmap and a funding map


00:29:37.880 --> 00:29:40.080
and some interesting ideas.


00:29:40.080 --> 00:29:43.080
And I'm going to go through them quick and then especially Steve will see what you,


00:29:43.080 --> 00:29:46.280
what your thoughts are here, how reasonable this might be.


00:29:46.280 --> 00:29:49.280
So the idea is like, there's going to be four different stages.


00:29:49.280 --> 00:29:53.280
And each stage thinks you can get 50% speed improvement.


00:29:53.280 --> 00:29:58.080
You do that four times, that's, you know, compounding performance interest, you get five.


00:29:58.080 --> 00:30:03.080
So I think it talks about three nine somewhere,


00:30:03.080 --> 00:30:05.580
but anyway, I think maybe it's got to shift its numbers a little.


00:30:05.580 --> 00:30:07.080
Anyway, so Python 3.10,


00:30:07.080 --> 00:30:09.580
stage one was to try to improve


00:30:09.580 --> 00:30:12.080
what the adaptive specialized interpreter


00:30:12.080 --> 00:30:15.080
that will adapt types and values during execution,


00:30:15.080 --> 00:30:17.080
exploiting type stability


00:30:17.080 --> 00:30:19.080
without the need for runtime code generation.


00:30:19.080 --> 00:30:21.080
That almost sounds a little bit like what you were talking about


00:30:21.080 --> 00:30:24.080
with the 10% increase earlier, Steve.


00:30:24.080 --> 00:30:26.580
And then 3.11, stage two,


00:30:26.580 --> 00:30:28.580
would be improved performance for integers,


00:30:28.580 --> 00:30:30.580
a less than one machine word,


00:30:30.580 --> 00:30:32.580
faster calls and returns through better handling


00:30:32.580 --> 00:30:34.580
of frames and better object memory layout.


00:30:34.580 --> 00:30:36.580
Stage 3, Python 3.12


00:30:36.580 --> 00:30:38.580
requires runtime code generation


00:30:38.580 --> 00:30:40.580
and a simple JIT for small regions.


00:30:40.580 --> 00:30:42.580
Python 13, extending


00:30:42.580 --> 00:30:44.580
the JIT to do a little bit more.


00:30:44.580 --> 00:30:46.580
And I'm linking to a conversation,


00:30:46.580 --> 00:30:48.580
a long


00:30:48.580 --> 00:30:50.580
threaded conversation,


00:30:50.580 --> 00:30:52.580
over on Python Dev.


00:30:52.580 --> 00:30:54.580
There's a whole bunch of stuff going on here,


00:30:54.580 --> 00:30:57.940
to read through it, but there's just like a lot of interesting implications about like,


00:30:57.940 --> 00:31:03.140
how do we pay this if we pay someone to do it? People like Steve work on CPython,


00:31:03.140 --> 00:31:07.300
and they don't get paid. Like, how is it fair to pay someone else to do it when other people are


00:31:07.300 --> 00:31:10.820
volunteering their time? There's a lot going on here. Steve, what do you think about this?


00:31:10.820 --> 00:31:12.020
Have you been following this?


00:31:12.020 --> 00:31:16.580
I read through the original proposal. I haven't had a chance to chat with Mark directly about it.


00:31:16.580 --> 00:31:22.580
I will, I guess, start by saying that Mark is a very smart guy. And he has done all of this


00:31:22.580 --> 00:31:28.100
planning off on his own in secret and kind of come out and share this plan with us, which


00:31:28.100 --> 00:31:33.380
you know is it's not an ideal kind of workflow certainly when you're part of a team, but


00:31:33.380 --> 00:31:37.660
I have certainly found in the past that when you get a very smart guy or very smart girl


00:31:37.660 --> 00:31:42.060
goes off and disappears for a few weeks and comes back and says I've solved it, there's


00:31:42.060 --> 00:31:43.980
a good chance they've solved it.


00:31:43.980 --> 00:31:46.180
So I'm very interested to see where it goes.


00:31:46.180 --> 00:31:50.460
The part of the discussion that you didn't mention is, or that you hinted at, is this


00:31:50.460 --> 00:31:54.780
is kind of a proposal for the Python Software Foundation to fund the work.


00:31:54.780 --> 00:31:58.420
And that part of that funding is conditional on delivery.


00:31:58.420 --> 00:32:03.220
So the way he's proposed this would work and and the implication seems to be that


00:32:03.220 --> 00:32:06.220
the mark will do the work himself and be the one getting paid for it.


00:32:06.220 --> 00:32:09.780
Yeah, that seemed like it wasn't clear from his GitHub repo.


00:32:09.780 --> 00:32:13.100
But if you read the conversation was like, look, I'm pretty sure I can do these things.


00:32:13.100 --> 00:32:18.540
This is how much would make sense for me to spend the next couple years working on it and getting paid.


00:32:18.980 --> 00:32:21.460
how do we do a fundraiser so that I can do this for everyone?


00:32:21.460 --> 00:32:23.940
Yeah, and you know, I think under those conditions,


00:32:23.940 --> 00:32:27.540
if the PSF is able to put the budget towards it,


00:32:27.540 --> 00:32:30.420
they are in a bit of a tight spot since PyCon


00:32:30.420 --> 00:32:32.180
is normally the big fundraiser for the year,


00:32:32.180 --> 00:32:32.980
and that didn't happen.


00:32:32.980 --> 00:32:35.140
On the other hand, it's also the big expense,


00:32:35.140 --> 00:32:39.060
but financially, the PSF is not in their normal place


00:32:39.060 --> 00:32:41.700
where they'd be for the year


00:32:41.700 --> 00:32:43.780
because PyCon didn't happen in the same way.


00:32:43.780 --> 00:32:48.500
But I think if they're prepared to put funding towards this,


00:32:48.500 --> 00:32:54.080
I guess if the community consensus is that this is the most important thing for us to


00:32:54.080 --> 00:32:59.580
do and there's certainly potential downsides to doing it code complexity is the big one.


00:32:59.580 --> 00:33:04.180
And I don't actually think there's a way that you implement this or even achieve these performance


00:33:04.180 --> 00:33:10.820
gains without making the code much more complex and hence less accessible to new contributors


00:33:10.820 --> 00:33:15.740
and you know people in earlier stages of learning to code at least on the C side.


00:33:15.740 --> 00:33:16.740
Yeah.


00:33:16.740 --> 00:33:20.740
So there's trade-offs. I'm very interested to see what would come about.


00:33:20.740 --> 00:33:25.740
I assume that because 3.10 is targeted for the first pass, that it's already done.


00:33:25.740 --> 00:33:26.740
And he's already got the code.


00:33:26.740 --> 00:33:34.740
And he's just trying to get confirmation that he can spend the next few years heavily investing in it.


00:33:34.740 --> 00:33:38.740
Instead of having to go find a full-time job and go back to doing this in the evenings.


00:33:38.740 --> 00:33:40.740
Which I'm fully supportive of.


00:33:40.740 --> 00:33:51.140
Again, it's really just a big open question of, is this the most important thing for Python to be funding right now, for CPython to be getting in particular?


00:33:51.140 --> 00:33:55.900
Someone, I forget who, raised the question of what if we put that money towards PyPy instead?


00:33:55.900 --> 00:33:58.940
What could they do with it in that amount of time?


00:33:58.940 --> 00:34:07.820
And ultimately, it's going to come down to someone, probably a small group, presumably the steering council will have some involvement from the technical side,


00:34:07.820 --> 00:34:11.020
the Python Software Foundation board will no doubt be involved


00:34:11.020 --> 00:34:14.860
in just deciding is this the best use


00:34:14.860 --> 00:34:18.140
of the money that we have or can go out and get


00:34:18.140 --> 00:34:21.220
for what benefits it would produce.


00:34:21.220 --> 00:34:23.220
Yeah, when I look at it with the funding side,


00:34:23.220 --> 00:34:26.220
I see it as very fraught with challenges on the


00:34:26.220 --> 00:34:28.540
sort of community funding and the PSF funding, but


00:34:28.540 --> 00:34:34.580
I know there's so many huge companies out there that spend an insane amount of money on compute and infrastructure


00:34:34.580 --> 00:34:35.980
that make a lot of money.


00:34:35.980 --> 00:34:41.740
and that if they could have a 5x speed up on their code, they could probably save that money


00:34:41.740 --> 00:34:44.380
right away on infrastructure.


00:34:44.380 --> 00:34:49.260
So it seems like that they could also get funded that way. But we should probably move on just because I've got to


00:34:49.260 --> 00:34:52.780
I'm going to make sure we have time for everything else before we end up running out of time.


00:34:52.780 --> 00:34:57.820
I just do want to call out like you should go check out that conversation. There's a very funny excerpt from Larry Hastings.


00:34:57.820 --> 00:35:02.140
It says, speaking as the Gillectomy guy, they were talking about borrowed references being a challenge.


00:35:02.140 --> 00:35:06.380
"Barb references are evil. The definition of a valid lifetime of a barb reference doesn't exist


00:35:06.380 --> 00:35:11.500
because they are a hack baked into the API that we mostly get away with because of the gill.


00:35:11.500 --> 00:35:16.380
If I still had wishes left at my monkey's paw, I'd wish them away. Unfortunately, I used my last wish


00:35:16.380 --> 00:35:19.100
back in February, wishing I could spend more time at home."


00:35:19.100 --> 00:35:26.220
So bad. All right, Siva, let's get a little bit more insight from you on this last one, huh?


00:35:26.220 --> 00:35:30.300
Because you were at the Core Developer's Friends, which recently happened.


00:35:30.300 --> 00:35:35.660
Yeah, so I don't know exactly what day this is going to go out, but last week from recording day,


00:35:35.660 --> 00:35:43.580
we had the CPython Core Developer Sprints. So this is kind of a get-together, generally in-person


00:35:43.580 --> 00:35:49.020
event that the core development team has done for five years now. I think this is the fifth year.


00:35:49.020 --> 00:35:55.580
In the past, we've all gone down to Facebook or Microsoft or last year we hung out at Bloomberg


00:35:55.580 --> 00:36:02.680
in London, and basically spent a week in a room together, coding, discussing, reviewing


00:36:02.680 --> 00:36:08.100
things, designing things, planning things, and otherwise just getting to actually meet


00:36:08.100 --> 00:36:10.760
our other contributors because we all work online.


00:36:10.760 --> 00:36:16.140
We all mostly work over email and kind of bug tracker and GitHub pull requests throughout


00:36:16.140 --> 00:36:17.140
the year.


00:36:17.140 --> 00:36:20.500
And so it's a really good opportunity to get to meet each other, get to see who we're dealing


00:36:20.500 --> 00:36:21.500
with.


00:36:21.500 --> 00:36:24.980
It's a lot harder to be angry at someone over email when you've met them.


00:36:24.980 --> 00:36:28.920
Yes. And so it's been a really good event. This year, because we're obviously not traveling


00:36:28.920 --> 00:36:34.840
for it, we were hosted by Python Discord, which is at pythondiscord.com. There's a server


00:36:34.840 --> 00:36:40.060
that is really well managed. It's really well organized. I was impressed. I have not been


00:36:40.060 --> 00:36:45.340
there before, but it was great. They set up, felt like thousands of channels for us, far


00:36:45.340 --> 00:36:50.900
too many, but it gave us plenty of space to kind of mingle with other core devs while


00:36:50.900 --> 00:36:53.860
we were discussing and working and planning anything.


00:36:53.860 --> 00:36:58.780
We also did a Q&A, so there'll be a link in the notes for that, from YouTube that we live


00:36:58.780 --> 00:37:03.840
streamed, we had people submit questions ahead of time, everything from what situations should


00:37:03.840 --> 00:37:09.820
I use a mangled name in, like a double underscore led name, through to what's your least favorite


00:37:09.820 --> 00:37:14.580
part of Python, what do you most want to replace, did you ever expect Python to get so big,


00:37:14.580 --> 00:37:15.900
and we had a lot more people involved.


00:37:15.900 --> 00:37:19.080
We normally do a panel for the host company.


00:37:19.080 --> 00:37:23.600
So we'll get kind of their employees together and it's like part of the perk for funding


00:37:23.600 --> 00:37:27.380
the venue and typically meals and coffee and everything for the week.


00:37:27.380 --> 00:37:29.500
This time it was public on YouTube.


00:37:29.500 --> 00:37:31.960
It was all kind of over video.


00:37:31.960 --> 00:37:34.100
So everyone got a bit of a turn to jump in.


00:37:34.100 --> 00:37:38.020
So you'll get to see a lot more core developer faces than you've probably ever seen before.


00:37:38.020 --> 00:37:41.400
You'll get to hear from a lot more of us than you have before.


00:37:41.400 --> 00:37:43.480
And a lot of interesting things.


00:37:43.480 --> 00:37:48.580
The big kind of ideas that came out of the week, kind of hard to say.


00:37:48.580 --> 00:37:53.040
A lot of us did come out feeling like we didn't get as much forward momentum on stuff as we


00:37:53.040 --> 00:37:54.880
normally would in person.


00:37:54.880 --> 00:37:57.160
But at the same time, a lot of things did move forward.


00:37:57.160 --> 00:38:02.320
I think there were about seven or eight peps passed up to the steering council during the


00:38:02.320 --> 00:38:03.960
week, various things.


00:38:03.960 --> 00:38:08.600
One of mine was deprecating disutils, which is an entire podcast on its own.


00:38:08.600 --> 00:38:12.840
So I might have to call you guys another time to talk about that one.


00:38:12.840 --> 00:38:18.680
Through to a proposal to change how we represent 3.10.


00:38:18.680 --> 00:38:22.780
Because a lot of places we put the version numbers back to back with no separator.


00:38:22.780 --> 00:38:25.960
And so you have, you know, 3839 with no nothing in between.


00:38:25.960 --> 00:38:26.960
Now we're up to 310.


00:38:26.960 --> 00:38:28.520
Or is it 310?


00:38:28.520 --> 00:38:29.520
Yeah.


00:38:29.520 --> 00:38:30.520
Okay.


00:38:30.520 --> 00:38:31.520
How do we fix that?


00:38:31.520 --> 00:38:33.920
And we had a lot of discussions about that.


00:38:33.920 --> 00:38:37.840
There was obviously a lot of talk about JIT, about the C API,


00:38:37.840 --> 00:38:42.400
all the usual things that we talk about. But again, because it was online, it was really good to have


00:38:42.400 --> 00:38:46.320
such a range of people involved, you know, across different time zones,


00:38:46.320 --> 00:38:48.320
and people who would not normally get to travel.


00:38:48.320 --> 00:38:50.560
Yeah, it makes it more accessible. Yeah, that's awesome.


00:38:50.560 --> 00:38:52.480
Yeah, we have core developers in countries who can't leave.


00:38:52.480 --> 00:38:58.720
Like they literally cannot leave their country, either because the populace is just strictly


00:38:58.720 --> 00:39:02.400
controlled, or they know they would not get back in when they tried to go home.


00:39:02.960 --> 00:39:08.960
And so they were able to participate and that was great to you know, see and meet some of those people


00:39:08.960 --> 00:39:13.520
We had a few mentees come along to interact with the rest of the team


00:39:13.520 --> 00:39:19.040
And just overall a good week. Awesome. Yeah, cool. Yeah, people can check it out the youtube stream


00:39:19.040 --> 00:39:22.160
I definitely want to check that out. Sounds neat. All right, brian. We've got two minutes left


00:39:22.160 --> 00:39:26.000
Do you think we should do a joke? Yeah, let's do the joke. Let's just cut to the joke


00:39:26.000 --> 00:39:29.860
So we we don't miss that right? So you and I spoke about hacktoberfest


00:39:30.880 --> 00:39:34.000
going wrong and like random PRs to like,


00:39:34.000 --> 00:39:37.840
config files and changing the spelling and config file settings.


00:39:37.840 --> 00:39:41.440
So there was a guy who posted on Twitter,


00:39:41.440 --> 00:39:44.080
said, "Hey, let me double check the name."


00:39:44.080 --> 00:39:48.240
It was Stuart McCroden.


00:39:48.240 --> 00:39:51.200
And he posted this cool t-shirt that he got.


00:39:51.200 --> 00:39:54.240
It says, "Hacktoberfest 2020. Any PR is a good R."


00:39:54.240 --> 00:39:56.160
And it's Lua.py.


00:39:56.160 --> 00:39:59.840
And it has import pyenvim.


00:39:59.840 --> 00:40:03.300
Then the pr just adds hash this imports a package


00:40:03.300 --> 00:40:07.600
That's awesome steve, did you suffer from any of these?


00:40:07.600 --> 00:40:11.760
Uh, I did not I might have done my github notifications are a mess


00:40:11.760 --> 00:40:14.640
So yeah, I I don't even know yet


00:40:14.640 --> 00:40:19.760
Yeah, I don't I don't see poor requests until I actually go look at the repo myself for the most part


00:40:19.760 --> 00:40:24.880
Yeah, I got a bunch. I got a whole bunch. Yeah me too. Okay. I wanted to do one


00:40:25.040 --> 00:40:30.400
This should have been a topic, but the five most difficult programming languages in the world.


00:40:30.400 --> 00:40:36.320
This was submitted to us by Troy Caudill, I think. It's not really a full topic,


00:40:36.320 --> 00:40:43.040
but I thought it was hilarious. This is an article where the author, Locate, I guess,


00:40:43.040 --> 00:40:50.560
actually took five programming languages, Malboge, Intercal, Brain, we all know that one,


00:40:51.120 --> 00:40:55.080
cow and whitespace and wrote hello world in that language.


00:40:55.080 --> 00:40:59.760
And these are hilarious. And my favorite is whitespace because the entire


00:40:59.760 --> 00:41:03.640
language depends on space tab and line feed for writing the program.


00:41:03.640 --> 00:41:08.800
And any non whitespace characters considered a comment. So this is great.


00:41:08.800 --> 00:41:13.120
That's crazy. I don't know why the APL wasn't on there.


00:41:13.120 --> 00:41:15.720
APL is just fully insane. Let me,


00:41:15.720 --> 00:41:18.440
I'll put it just in the show notes here at the bottom of this,


00:41:18.960 --> 00:41:25.200
an example of APL. That right there that I put on is I can't try to even speak


00:41:25.200 --> 00:41:28.920
this, but that is an entire thing that finds the all prime numbers from one to


00:41:28.920 --> 00:41:32.680
R in that that line. I hope you guys see at the bottom of the notes. That's


00:41:32.680 --> 00:41:36.600
insane, isn't it? That's not even intentionally bad, is it? I mean, it's


00:41:36.600 --> 00:41:41.400
meant to be a real programming language. It's as if the Egyptians who only wrote


00:41:41.400 --> 00:41:44.960
in hieroglyphics decided to write a programming language. That's how I feel


00:41:44.960 --> 00:41:48.440
Like you it's insane, but it's a legitimate language.


00:41:48.440 --> 00:41:49.520
Like people try to use it.


00:41:49.520 --> 00:41:51.000
They do use it anyway.


00:41:51.000 --> 00:41:52.160
Not, not for very long.


00:41:52.160 --> 00:41:55.200
I expect only as long as they must.


00:41:55.200 --> 00:41:56.520
And then they immediately stop.


00:41:56.520 --> 00:41:58.040
I just liked that.


00:41:58.040 --> 00:42:01.200
This intercal example is so polite.


00:42:01.200 --> 00:42:03.560
It's please, please do please do please.


00:42:03.560 --> 00:42:04.640
Oh, please give up.


00:42:04.640 --> 00:42:07.200
Yeah.


00:42:07.200 --> 00:42:11.840
Apparently you have to sprinkle pleases in it or else it'll like a error because


00:42:11.840 --> 00:42:17.120
you're not polite enough, but if you do too much, it also errors because you're overly polite.


00:42:17.120 --> 00:42:20.640
I like that. We need more passive-aggressive languages like that.


00:42:20.640 --> 00:42:23.520
Lovely.


00:42:23.520 --> 00:42:26.400
Cool. Well, thanks a lot, guys. It was fun.


00:42:26.400 --> 00:42:29.920
Yeah. Thanks, Brian, Michael. Yeah, thanks. And thanks for being here, Steve. It's great


00:42:29.920 --> 00:42:33.360
to have your perspective. Thank you for listening to Python Bytes.


00:42:33.360 --> 00:42:39.520
Follow the show on Twitter @pythonbytes. That's Python Bytes as in B-Y-T-E-S. And get the full


00:42:39.520 --> 00:42:45.760
show notes at pythonbytes.fm. If you have a news item you want featured, just visit pythonbytes.fm


00:42:45.760 --> 00:42:49.920
and send it our way. We're always on the lookout for sharing something cool. This is Brian Okken,


00:42:49.920 --> 00:42:54.240
and on behalf of myself and Michael Kennedy, thank you for listening and sharing this podcast with


00:42:54.240 --> 00:42:55.440
your friends and colleagues.

