
00:00:00.000 --> 00:00:05.000
This is Python Bytes, Python headlines and news delivered directly to your earbuds.


00:00:05.000 --> 00:00:10.000
It's episode 7, recorded Wednesday, January 4th, 2017.


00:00:10.000 --> 00:00:11.000
Hey Brian.


00:00:11.000 --> 00:00:13.000
Hey, happy new year.


00:00:13.000 --> 00:00:14.000
Yeah, happy new year.


00:00:14.000 --> 00:00:16.000
It's great to be back together.


00:00:16.000 --> 00:00:21.000
We've gone three weeks without discussing cool things that came out in the Python community


00:00:21.000 --> 00:00:23.000
and I think it's time to get back together.


00:00:23.000 --> 00:00:25.000
The Python news must flow.


00:00:25.000 --> 00:00:27.000
It must, and plus I missed this.


00:00:27.000 --> 00:00:28.000
This is fun.


00:00:28.000 --> 00:00:29.000
Yeah, it's definitely, definitely fun.


00:00:29.000 --> 00:00:33.000
So like many of our episodes, this one is sponsored by Rollbar.


00:00:33.000 --> 00:00:35.000
They help you take the pain out of errors.


00:00:35.000 --> 00:00:36.000
So thank you to Rollbar.


00:00:36.000 --> 00:00:39.000
We'll have more to say about them throughout the show.


00:00:39.000 --> 00:00:41.000
So, Brian, you had a little warning.


00:00:41.000 --> 00:00:43.000
You wanted to just get it out of the way?


00:00:43.000 --> 00:00:48.000
Yeah, I've got – there's a couple – I want to try to list some of the names of the articles.


00:00:48.000 --> 00:00:52.000
The people that wrote the articles that we are reading and talking about in this episode,


00:00:52.000 --> 00:00:57.000
and some of them have names that I am most definitely going to mispronounce.


00:00:57.000 --> 00:01:04.120
I hope you don't take offense at it. I have a last name that everybody mispronounces. So I


00:01:04.120 --> 00:01:11.240
understand you're used to it. Yeah, I get Oaken and mostly Oaken is what I get. But


00:01:11.240 --> 00:01:18.840
but you're not a tree. So, hey, so before we get to the first episode, the first news item,


00:01:18.840 --> 00:01:22.200
I actually want to do something open up my terminal, I'm going to type types of that. Okay,


00:01:22.200 --> 00:01:28.760
I'm gonna type Python three dash capital V. Do you know what it says? It not Python three five


00:01:28.760 --> 00:01:37.320
two. It says Python 3.6. That's right. Python 360. Yeah, so Python three six was announced on


00:01:37.320 --> 00:01:44.920
December 23. And it's now Python 360 is our official latest release. And this is really


00:01:44.920 --> 00:01:52.760
exciting. I've already started using some of the new features in my writing. I'm definitely


00:01:52.760 --> 00:01:57.560
taking advantage of the f-strings. I don't know how you would call those.


00:01:57.560 --> 00:02:02.200
Yeah, I think the other languages call it string interpolation, but it's the F character that


00:02:02.200 --> 00:02:06.280
indicates it. Swift and C# call it string interpolation.


00:02:06.280 --> 00:02:08.280
Oh, I'm going to call them the F-in strings.


00:02:08.280 --> 00:02:09.480
I love it.


00:02:10.920 --> 00:02:15.720
But in celebration of this, I know we've already talked about 3.6, but I've got links to the


00:02:15.720 --> 00:02:21.240
in our show notes for the announcement and the what's new article from docspython.org.


00:02:21.240 --> 00:02:26.520
But there's also a couple other articles that are cool. There's a Python 3.6 is packed with


00:02:26.520 --> 00:02:34.760
goodness article from Sirdar Yigalap. No, I got that one wrong. That's on InfoWorld. But it's a


00:02:34.760 --> 00:02:41.120
a list of things that he thinks is cool in three six, including a sink await and use


00:02:41.120 --> 00:02:47.520
the use the use of that more the the improvements of memory and speed. And I I'm really excited


00:02:47.520 --> 00:02:53.800
about that. And some something that I didn't know about is some of the improved API support


00:02:53.800 --> 00:02:57.280
so that tracers and debuggers and stuff can hook into Python easier.


00:02:57.280 --> 00:03:01.640
Yeah, it's definitely packed with goodness. I think that's great. Another article


00:03:01.640 --> 00:03:06.600
that you pointed out was adopt Python 3. I really like that one as well and I'll


00:03:06.600 --> 00:03:10.640
let you go to some of the stats and say the name as well, the author. Yeah so


00:03:10.640 --> 00:03:15.840
this is on Medium and I'm gonna try this one because it's a cool name


00:03:15.840 --> 00:03:23.880
Dibya Chakravarti. I don't know, cool name but yeah so there this other adopt


00:03:23.880 --> 00:03:28.680
Python 3 article talked I thought it was interesting so there's a I have heard of


00:03:28.680 --> 00:03:36.000
a couple of sites called the wall of superpowers and Python 3 readiness that


00:03:36.000 --> 00:03:43.800
are two pages that list most popular Python packages and how much of them are


00:03:43.800 --> 00:03:48.880
Python 3 ready and the numbers are higher than I expected actually 187 out


00:03:48.880 --> 00:03:54.880
of 200 on one of them and 341 out of 360 on the other and I think this is


00:03:54.880 --> 00:03:59.680
important because a lot of people tried to switch to Python 3 a long time ago


00:03:59.680 --> 00:04:04.680
and one of their favorite packages wasn't supported but it probably is


00:04:04.680 --> 00:04:11.600
now so check those out and then this person also wrote up an IPython notebook


00:04:11.600 --> 00:04:18.080
and had some statistics to pull out not just the most popular but everything he


00:04:18.080 --> 00:04:24.360
pulled everything on PyPy that was listed as stable and had at least one


00:04:24.360 --> 00:04:31.320
release in 2016. That was 6000 packages of those. So there must be a lot of like packages


00:04:31.320 --> 00:04:38.560
on PyPy that are not our PyPI that are not updated very often. But I really like it when


00:04:38.560 --> 00:04:44.800
the statistics do some basic filtering, like, nobody cares whether that package that almost


00:04:44.800 --> 00:04:49.400
no one's using hasn't been updated for 10 years supports Python two or Python three.


00:04:49.400 --> 00:04:57.400
Yeah, but of the what he calls stable and active, it was interesting, there's 14% of


00:04:57.400 --> 00:05:02.880
those don't even cover Python 2, they're Python 3 only packages.


00:05:02.880 --> 00:05:10.540
And 28%, which is higher than I would hope, but 28% are Python 2 only.


00:05:10.540 --> 00:05:14.920
But the author estimates that a lot of those could easily be switched if they're really


00:05:14.920 --> 00:05:16.560
important to you.


00:05:16.560 --> 00:05:23.040
But he does list out, he has a list of all the ones that he calls sticky, the 25% of


00:05:23.040 --> 00:05:30.360
28, so I don't know, that's not very many, 14, 7% total.


00:05:30.360 --> 00:05:32.200
Yeah math on the fly.


00:05:32.200 --> 00:05:36.480
Anyway, of those sticky packages that may be a problem for you.


00:05:36.480 --> 00:05:41.840
But you know, I was in one of those camps a year ago, I tried to switch our testing


00:05:41.840 --> 00:05:46.840
to Python three, and there was a package that I needed that wasn't switched.


00:05:46.840 --> 00:05:49.520
And it is now so I don't have that excuse anymore.


00:05:49.520 --> 00:05:50.640
Yeah, that's really great.


00:05:50.640 --> 00:05:52.080
I love the wall of superpowers.


00:05:52.080 --> 00:05:53.640
This article is really interesting.


00:05:53.640 --> 00:05:58.760
And I think it makes it's a good argument and it's data driven, which is cool.


00:05:58.760 --> 00:06:02.240
In fact, like you said, you can get the IPython notebook for it.


00:06:02.240 --> 00:06:07.640
My final thought on Python moving from legacy Python, Python three, six, the new Python


00:06:07.640 --> 00:06:12.760
is you get a lot of benefit in this release just by installing and running on it if you


00:06:12.760 --> 00:06:15.720
don't touch your code at all, because there's a lot of memory and performance speed up.


00:06:15.720 --> 00:06:16.960
So that's really cool.


00:06:16.960 --> 00:06:17.960
Yeah.


00:06:17.960 --> 00:06:23.520
And it's the instead of walls of and the wall of superpowers.


00:06:23.520 --> 00:06:25.880
Maybe we could look at maybe roads and bridges.


00:06:25.880 --> 00:06:29.040
Yeah, there's walls, there's roads and there's bridges.


00:06:29.040 --> 00:06:31.760
And, you know, I don't know how it is in the rest of the world.


00:06:31.760 --> 00:06:33.720
I know in Germany, it's not quite this way.


00:06:33.720 --> 00:06:38.640
In the US, we tend to neglect our physical infrastructure.


00:06:38.640 --> 00:06:43.520
I had to swerve the other day because there was a huge pothole in the road and so on.


00:06:43.520 --> 00:06:44.520
It's a problem.


00:06:44.520 --> 00:06:50.080
But I think the real problem for us these days is actual digital infrastructure.


00:06:50.080 --> 00:06:54.320
So there's a really great article, not an article, it's more like a report or even a


00:06:54.320 --> 00:06:59.040
book, it's like 150 pages, called "Roads and Bridges, the Unseen Labor Behind Our Digital


00:06:59.040 --> 00:07:00.040
Infrastructure."


00:07:00.040 --> 00:07:04.080
It's written by Nadia Egbal, and she did a really good job.


00:07:04.080 --> 00:07:07.520
It's a new, relatively new report, it came out in July.


00:07:07.520 --> 00:07:13.640
It basically talks about open source and mostly open source infrastructure, not open source


00:07:13.640 --> 00:07:14.640
projects.


00:07:14.640 --> 00:07:22.880
So not, not necessarily things like Django, but more things like PyPI and pip, right,


00:07:22.880 --> 00:07:28.800
the underlying foundation, things like OpenSSL that everybody builds on top of.


00:07:28.800 --> 00:07:32.640
And it turns out there's actually a really big problem across the board.


00:07:32.640 --> 00:07:36.800
Like if you think physical infrastructure is neglected, you should see the digital infrastructure.


00:07:36.800 --> 00:07:41.840
All right, so I actually did a whole session with this, some of the folks from the Python


00:07:41.840 --> 00:07:47.600
community, Eric Kulsher from Read the Docs, Donald Stuff from PyPI on Talk Python on episode


00:07:47.600 --> 00:07:48.600
84.


00:07:48.600 --> 00:07:50.400
And we talked about this a little bit.


00:07:50.400 --> 00:07:55.960
Basically, this report goes through and outlines all the challenges that they see for supporting


00:07:55.960 --> 00:08:01.960
things like PyPI, supporting things like OpenSSL.


00:08:01.960 --> 00:08:07.420
And they said that until Heartbleed, you know, Heartbleed was that really serious bug that


00:08:07.420 --> 00:08:12.620
you could sort of send a bunch of requests to a server running OpenSSL that was vulnerable


00:08:12.620 --> 00:08:17.260
and you could actually get it to leak information, unencrypted information back out.


00:08:17.260 --> 00:08:21.500
So until then, it was like that thing was just barely coming along.


00:08:21.500 --> 00:08:23.260
Like there's almost nobody that worked on it.


00:08:23.260 --> 00:08:28.660
like one guy or a couple of guys that very very short term were able to work


00:08:28.660 --> 00:08:33.940
on it and two-thirds of all the web servers use that for their communication.


00:08:33.940 --> 00:08:38.220
And think about that. Another example they talked about RubyGems, the website


00:08:38.220 --> 00:08:42.140
done by volunteers. Somebody had found some kind of vulnerability in it and the


00:08:42.140 --> 00:08:45.300
the people who had supported it they're like all right we'll fix this on the


00:08:45.300 --> 00:08:48.660
weekend because we have jobs we can't work on this infrastructure and like I


00:08:48.660 --> 00:08:52.540
mean that's like pip to Ruby right it's really important and it turned out it


00:08:52.540 --> 00:08:56.660
got hacked and taken down before the weekend.


00:08:56.660 --> 00:08:58.940
And so people had to like schedule vacation days


00:08:58.940 --> 00:09:01.780
so they could get it back running.


00:09:01.780 --> 00:09:04.940
One more example is PyPI itself.


00:09:04.940 --> 00:09:07.580
And Donald Stuft works on that.


00:09:07.580 --> 00:09:10.020
He was employed by HP.


00:09:10.020 --> 00:09:11.460
HP went through a bunch of layoffs


00:09:11.460 --> 00:09:15.820
and not even knowingly, I think, took out his position.


00:09:15.820 --> 00:09:17.660
Now there's Donald's doing that in his spare time.


00:09:17.660 --> 00:09:19.500
Who else supports PyPI?


00:09:19.500 --> 00:09:22.860
They do 400 terabytes of traffic a month


00:09:22.860 --> 00:09:26.640
and it costs almost $40,000 to keep pip running.


00:09:26.640 --> 00:09:28.540
So you can say pip install a thing,


00:09:28.540 --> 00:09:31.100
that's like $40,000 worth of infrastructure.


00:09:31.100 --> 00:09:33.220
And there's only a few baskets


00:09:33.220 --> 00:09:34.340
that are supporting that thing.


00:09:34.340 --> 00:09:35.540
It's quite precarious.


00:09:35.540 --> 00:09:37.460
So I wanted to bring up roads and bridges,


00:09:37.460 --> 00:09:40.020
the unseen labor behind our digital infrastructure.


00:09:40.020 --> 00:09:41.680
This report, I think people who care about this


00:09:41.680 --> 00:09:43.260
will find this very well-written,


00:09:43.260 --> 00:09:45.900
very interesting and lots of neat stories.


00:09:45.900 --> 00:09:47.380
Well, even if they're depressing.


00:09:47.380 --> 00:09:48.340
(laughing)


00:09:48.340 --> 00:09:51.860
Yeah, it is interesting. Thanks for bringing that up.


00:09:51.860 --> 00:09:56.660
Yeah, absolutely. I threw a bunch of little excerpts that I got from the article.


00:09:56.660 --> 00:09:59.140
People can flip through and see if they're interested in that.


00:09:59.140 --> 00:10:03.220
Speaking of things that we take for granted, I know that a lot of...


00:10:03.220 --> 00:10:06.100
There's some libraries out there that people use all the time,


00:10:06.100 --> 00:10:11.860
and if a library is used by a lot of people, making changes to it can be a little scary.


00:10:11.860 --> 00:10:20.660
RC2 of Matplotlib 2.0.0 came out in December and Thomas Caswell is, I don't know if he's the only


00:10:20.660 --> 00:10:26.580
person supporting it, but he's one of the main developers and he was telling me that there's,


00:10:26.580 --> 00:10:33.860
it's been, one of the changes in this is some of the changes in the default style. So the default,


00:10:33.860 --> 00:10:39.620
if you just, if you're not styling your plots specifically and you're just going with whatever


00:10:39.620 --> 00:10:45.860
Matt Plotlib comes up with, those are going to change. And that took 10 years in the making,


00:10:45.860 --> 00:10:51.300
apparently, to change that. So this this library has been around for a while. Anyway, so he would


00:10:51.300 --> 00:10:58.260
love to have feedback. So we've got a list of in our show notes, there's a list of changes,


00:10:58.260 --> 00:11:05.060
there's a list of releases, list of changes, and 2.0.0 is coming out soon-ish. He's not sure when,


00:11:05.060 --> 00:11:12.200
But he'd like to have people try it out and see if any of the default styles or what they think of him


00:11:12.200 --> 00:11:17.380
He wants feedback. So well, I have a little feedback for him that one of the posts you link to in the show notes


00:11:17.380 --> 00:11:21.900
It is basically a set of pictures old version new version with default styling


00:11:21.900 --> 00:11:25.580
Almost universally they look better to me. They look more modern


00:11:25.580 --> 00:11:30.700
They don't look like here's a cheap unstyled sort of thing. I'm just gonna drop in


00:11:30.700 --> 00:11:34.240
They actually look like something that you'd be really excited to share, right?


00:11:34.240 --> 00:11:36.000
So thumbs up for me.


00:11:36.000 --> 00:11:37.000
Yeah, I thought so too.


00:11:37.000 --> 00:11:42.640
And I thought I didn't even think about how hard it would be to change something under


00:11:42.640 --> 00:11:46.040
the, you know, change the rug out of a lot of people.


00:11:46.040 --> 00:11:49.920
And you know, a lot of people don't follow him or follow Python.


00:11:49.920 --> 00:11:52.880
So I'm glad we're bringing this up to try to get people to go check it out.


00:11:52.880 --> 00:11:53.880
Yeah, I totally agree.


00:11:53.880 --> 00:11:55.440
So it's easy to look through it.


00:11:55.440 --> 00:11:59.160
If you care about Matplotlib, get out there and give them some feedback while you can.


00:11:59.160 --> 00:12:01.800
Hey, before we move on, let me tell you about Rollbar.


00:12:01.800 --> 00:12:03.320
Oh, please tell me about Rollbar.


00:12:03.320 --> 00:12:08.280
I recently sent out an email, like a newsletter email, to a bunch of people taking some of


00:12:08.280 --> 00:12:13.360
my courses, and it turned out that I had typed in a URL incorrectly.


00:12:13.360 --> 00:12:19.560
So it was like, "Click here to launch this video," and it was like, "Player/Lecture/1234."


00:12:19.560 --> 00:12:23.680
Well some non-numerical number or a letter got in there.


00:12:23.680 --> 00:12:27.440
My web app was trying to parse that as an integer.


00:12:27.440 --> 00:12:32.320
So I hit send on this email to thousands of people, and then all of a sudden my phone


00:12:32.320 --> 00:12:33.960
And my phone starts going beep beep beep beep beep,


00:12:33.960 --> 00:12:36.040
crash crash crash, error in your website.


00:12:36.040 --> 00:12:37.320
And I'm like, what the heck is this?


00:12:37.320 --> 00:12:39.480
I pull it up and like, I immediately see what's going on.


00:12:39.480 --> 00:12:40.300
I see the stack trace.


00:12:40.300 --> 00:12:44.280
I open up my, open up PyCharm, quickly change it,


00:12:44.280 --> 00:12:45.560
do a push to deploy.


00:12:45.560 --> 00:12:48.040
And within five minutes of sending the email,


00:12:48.040 --> 00:12:49.960
nobody ever sent me a message.


00:12:49.960 --> 00:12:51.160
I found the error and fixed it.


00:12:51.160 --> 00:12:52.680
And the rest of the people that opened the email


00:12:52.680 --> 00:12:53.720
didn't crash.


00:12:53.720 --> 00:12:54.760
And that was from Rollbar.


00:12:54.760 --> 00:12:57.440
And if you guys want that same type of behavior,


00:12:57.440 --> 00:12:58.540
that same type of safety net,


00:12:58.540 --> 00:13:01.320
you can get it at rollbar.com/pythonbytes.


00:13:01.320 --> 00:13:02.160
- That's awesome.


00:13:02.160 --> 00:13:06.240
I wonder how long you would have figured out on their own without that.


00:13:06.240 --> 00:13:09.080
I would have never known until somebody complained.


00:13:09.080 --> 00:13:10.960
Like so, it was really good.


00:13:10.960 --> 00:13:14.520
I felt bad about it, but it was good that at least I got it fixed right away.


00:13:14.520 --> 00:13:15.920
Yeah, awesome.


00:13:15.920 --> 00:13:20.000
One of the things I'm a huge fan of is MongoDB and document databases.


00:13:20.000 --> 00:13:24.640
I really think document databases are like this perfect sweet spot between performance,


00:13:24.640 --> 00:13:29.240
maintainability, ease of use, and relational integrity.


00:13:29.240 --> 00:13:33.340
There's a really great article I want to point out if you're interested in MongoDB or document


00:13:33.340 --> 00:13:36.460
databases in general and Python and you want to get started.


00:13:36.460 --> 00:13:42.000
The guys over at RealPython, Michael Herman, wrote an article called "Introduction to MongoDB


00:13:42.000 --> 00:13:43.300
and Python."


00:13:43.300 --> 00:13:45.700
They talk about what's the difference between SQL and NoSQL.


00:13:45.700 --> 00:13:50.540
They talk about the primary way to talk to the database through PyMongo, like inserting


00:13:50.540 --> 00:13:51.540
and querying data.


00:13:51.540 --> 00:13:54.140
And they also talk about this thing called MongoEngine.


00:13:54.140 --> 00:13:55.860
MongoEngine's like the SQLAlchemy.


00:13:55.860 --> 00:14:00.140
You create classes, you put in constraints and defaults, and then you map those classes


00:14:00.140 --> 00:14:02.100
to documents in your database.


00:14:02.100 --> 00:14:04.100
Yeah, I'm really excited about this.


00:14:04.100 --> 00:14:07.860
I'm trying to use PyMongo on one of my projects, so this is good.


00:14:07.860 --> 00:14:09.220
Yeah, it's definitely good.


00:14:09.220 --> 00:14:10.700
PyMongo is pretty sweet.


00:14:10.700 --> 00:14:12.580
MongoDB is easy to set up and use.


00:14:12.580 --> 00:14:14.100
It's open source, so that's all good.


00:14:14.100 --> 00:14:18.060
I actually did a one and a half hour presentation at this conference in London called Software


00:14:18.060 --> 00:14:21.900
Architect, and they recorded it and put it up, and it was basically the same stuff.


00:14:21.900 --> 00:14:26.020
So I put a link in the show notes as well to this thing I called applied NoSQL with


00:14:26.020 --> 00:14:27.360
MongoDB and Python.


00:14:27.360 --> 00:14:31.180
So if people want to like a video version of mostly the same topics, they can check


00:14:31.180 --> 00:14:32.180
that out as well.


00:14:32.180 --> 00:14:36.540
And actually from you, I learned about TinyDB, I think on one of your podcasts.


00:14:36.540 --> 00:14:38.220
Oh, yeah, TinyDB is awesome.


00:14:38.220 --> 00:14:39.660
Yeah, so that was neat too.


00:14:39.660 --> 00:14:42.220
Yeah, also document database.


00:14:42.220 --> 00:14:44.060
You know, I love things that are for humans.


00:14:44.060 --> 00:14:50.420
Yeah, next up, we've got an article introducing Maya date times for humans.


00:14:50.420 --> 00:14:55.060
And most of the For Humans stuff comes from Kenneth Reitz.


00:14:55.060 --> 00:14:56.660
Do you know how to pronounce his name?


00:14:56.660 --> 00:14:58.940
- I've been saying Reitz, I think that's right.


00:14:58.940 --> 00:15:00.140
It felt like a German name,


00:15:00.140 --> 00:15:01.580
but if it's Reitz, I'm sorry, Kenneth.


00:15:01.580 --> 00:15:05.180
- So Kenneth, if you're listening, please let us know.


00:15:05.180 --> 00:15:08.580
Or I could, I guess, look at any talk that he's given


00:15:08.580 --> 00:15:11.540
and try to get that, but anyway.


00:15:11.540 --> 00:15:16.540
But the date times seem like something that's just easy


00:15:17.380 --> 00:15:20.460
until you actually try to do something that's not.


00:15:20.460 --> 00:15:24.200
It quickly goes from easy to deal with


00:15:24.200 --> 00:15:26.100
to hard to deal with very fast.


00:15:26.100 --> 00:15:29.620
And so I'm excited that Kenneth has taken this on


00:15:29.620 --> 00:15:33.340
and tried to come up with his own library


00:15:33.340 --> 00:15:36.260
for dealing with date times and date time math


00:15:36.260 --> 00:15:39.360
and parsing dates and human readable stuff.


00:15:39.360 --> 00:15:42.880
It just sounds exciting and I'm gonna give it a try.


00:15:42.880 --> 00:15:44.860
- Yeah, he has Request,


00:15:44.860 --> 00:15:47.240
which is the most popular Python package ever,


00:15:47.240 --> 00:15:50.340
downloaded 7 million times a month, which is insane.


00:15:50.340 --> 00:15:52.740
He has records, which is like just right SQL


00:15:52.740 --> 00:15:54.940
for human sort of thing, and now dates.


00:15:54.940 --> 00:15:55.920
A very, very cool stuff.


00:15:55.920 --> 00:15:56.760
Nice work, Kenneth.


00:15:56.760 --> 00:15:57.980
- Yeah, definitely.


00:15:57.980 --> 00:16:00.220
And another package that I'm interested in


00:16:00.220 --> 00:16:04.100
that's coming up is an alternative to Flask


00:16:04.100 --> 00:16:06.100
or something Flask-like.


00:16:06.100 --> 00:16:08.300
- There are more and more reasons to move away


00:16:08.300 --> 00:16:10.340
from legacy Python to Python,


00:16:10.340 --> 00:16:11.820
especially Python 3.5 and above


00:16:11.820 --> 00:16:14.180
because of the cool concurrency stuff.


00:16:14.180 --> 00:16:18.380
So what are the things that people talk about when they talk about Node.js, which I'm not


00:16:18.380 --> 00:16:23.540
a huge fan of Node.js, but you know, it does have its benefits is it's sort of asynchronous


00:16:23.540 --> 00:16:25.820
from the start programming model.


00:16:25.820 --> 00:16:26.820
Right?


00:16:26.820 --> 00:16:27.820
Okay.


00:16:27.820 --> 00:16:32.460
Now that's been traditionally hard in Python because the WSGI API doesn't really support


00:16:32.460 --> 00:16:33.980
it super well.


00:16:33.980 --> 00:16:39.580
Frameworks like Flask and Pyramid, they don't, you can't just write async methods that all


00:16:39.580 --> 00:16:41.100
of a sudden become async, right?


00:16:41.100 --> 00:16:44.860
like too much it's too much in the built-in stack that doesn't understand


00:16:44.860 --> 00:16:47.940
async. This guy I don't know what his real name is I can just know him as


00:16:47.940 --> 00:16:52.900
channel cat created this thing called Sanic which is called a Python 3.5 or


00:16:52.900 --> 00:16:57.860
higher web server written to go fast and it's based on the API flask it leverages


00:16:57.860 --> 00:17:02.220
the async and await functionality of Python 3.5 which I think is really really


00:17:02.220 --> 00:17:07.100
cool it also uses the UV loop which is a really fast asynchronous IO loop for


00:17:07.100 --> 00:17:11.260
Python 3. It's really cool. So if I want to create some kind of method like a


00:17:11.260 --> 00:17:15.580
view action method sort of thing, just like Flask, I'll say app.route and give


00:17:15.580 --> 00:17:19.760
it a like a URL so like slash. But instead of saying def some method, you


00:17:19.760 --> 00:17:24.620
say async def some method. And you can await throughout your method and all the


00:17:24.620 --> 00:17:28.640
the cool benefits of letting the threads go on to do other work while you're


00:17:28.640 --> 00:17:33.820
waiting on databases, web services, files, things like that just happen magically.


00:17:33.820 --> 00:17:36.320
So you can get really good performance numbers.


00:17:36.320 --> 00:17:37.320
Wow, neat.


00:17:37.320 --> 00:17:38.820
Yeah, so it's pretty cool.


00:17:38.820 --> 00:17:41.320
And the fact that it's a Flask, more or less like the Flask API,


00:17:41.320 --> 00:17:44.320
means you don't have to like start from scratch and learn a totally new thing.


00:17:44.320 --> 00:17:47.320
They actually have some performance numbers compared to other things.


00:17:47.320 --> 00:17:49.820
And they don't have Pyramid in here, which is too bad,


00:17:49.820 --> 00:17:51.820
because Pyramid flies on Python 3.


00:17:51.820 --> 00:17:55.820
But when you think of asynchronous programming in Python,


00:17:55.820 --> 00:17:56.820
a Python web framework,


00:17:56.820 --> 00:18:00.820
typically you would probably come up first with Tornado.


00:18:00.820 --> 00:18:02.820
And they have some tests they did.


00:18:02.820 --> 00:18:07.900
test they did and they said, okay, Tornado did like 2000 requests per second with a 44


00:18:07.900 --> 00:18:11.380
second millisecond latency response time basically.


00:18:11.380 --> 00:18:13.060
I said, okay, well, what about Flask?


00:18:13.060 --> 00:18:14.260
Well, Flask did twice as good.


00:18:14.260 --> 00:18:19.500
So like 5000 requests a second, 20 millisecond response time, almost double good in both


00:18:19.500 --> 00:18:20.700
directions.


00:18:20.700 --> 00:18:26.780
The Sanic thing using Python three in the UV loop is 33,000 requests per second with


00:18:26.780 --> 00:18:28.780
a three millisecond response time.


00:18:28.780 --> 00:18:30.500
Wow, that's incredible.


00:18:30.500 --> 00:18:31.500
Yeah.


00:18:31.500 --> 00:18:33.500
See, Python's better than legacy Python.


00:18:33.500 --> 00:18:35.500
Yeah, Python definitely.


00:18:35.500 --> 00:18:40.500
That's really cool. So Python 3.5, the async/await is a cool programming model


00:18:40.500 --> 00:18:43.500
and have this nice web framework to plug in there. This thing's going to go places.


00:18:43.500 --> 00:18:45.500
We're going to be talking about it for a while, I bet.


00:18:45.500 --> 00:18:50.500
Yeah, definitely. At some point I need to talk with you about trying to figure out


00:18:50.500 --> 00:18:57.500
if I were going to start up a new application, would I care about asynchronous stuff right away?


00:18:57.500 --> 00:18:59.500
Yeah, that's a good question, right? Like how much do you really care?


00:18:59.500 --> 00:19:03.940
really care because I mean, on like, let's say on the talk by fun website, I think I


00:19:03.940 --> 00:19:07.980
have 10 processes farmed out to handle the request.


00:19:07.980 --> 00:19:12.980
So like, you know, let's just go with flask if I were running flask 5000 requests a second,


00:19:12.980 --> 00:19:16.380
that's 50,000 requests a second, that's like a pretty insane amount that I'm gonna have


00:19:16.380 --> 00:19:18.460
to hit before I care, right.


00:19:18.460 --> 00:19:21.260
But still, there are people who care and having that built in.


00:19:21.260 --> 00:19:22.260
That's pretty cool.


00:19:22.260 --> 00:19:23.260
Yeah, definitely.


00:19:23.260 --> 00:19:24.860
I can't believe we're wrapped it up.


00:19:24.860 --> 00:19:26.380
We've got all these done already.


00:19:26.380 --> 00:19:27.780
I know, I know.


00:19:27.780 --> 00:19:29.820
I think we've got a bunch of cool topics.


00:19:29.820 --> 00:19:30.660
I love Sanic.


00:19:30.660 --> 00:19:34.140
I love that Python 3.6 is out.


00:19:34.140 --> 00:19:36.300
And I'm happy to be back and sharing it with everybody.


00:19:36.300 --> 00:19:38.940
It was a nice break, but it's even nicer to be back.


00:19:38.940 --> 00:19:40.700
- Yeah, do you have any extra news


00:19:40.700 --> 00:19:41.900
you wanna share with us?


00:19:41.900 --> 00:19:44.780
- No, I just stepped away from the computer.


00:19:44.780 --> 00:19:47.620
I went to California, put my toes in the sand,


00:19:47.620 --> 00:19:49.740
and just kind of forgot about things for a while,


00:19:49.740 --> 00:19:52.300
and came back refreshed and excited


00:19:52.300 --> 00:19:54.180
to keep doing what I'm doing.


00:19:54.180 --> 00:19:55.020
How about you?


00:19:55.020 --> 00:19:55.980
You're still working on your book, right?


00:19:55.980 --> 00:20:00.100
Definitely, and I've ramped up the schedule. So I spent the Christmas break at the keyboard and


00:20:00.100 --> 00:20:06.740
I've got I'm I think about halfway done of with the rough draft approximately


00:20:06.740 --> 00:20:10.240
But going through the first level editor


00:20:10.240 --> 00:20:16.700
I'm still I'm still shooting for a beta at least a beta release by Picon


00:20:16.700 --> 00:20:24.420
the the my goal of getting a physical copy by Picon seems actually insane right now, so


00:20:25.460 --> 00:20:28.700
but that's where I'm going to do it. We're all rooting for you Brian, you can do it.


00:20:28.700 --> 00:20:33.180
And a whole bunch of test and code episodes coming up. I've got one


00:20:33.180 --> 00:20:37.400
interview recorded and about four interviews scheduled so these will keep


00:20:37.400 --> 00:20:41.420
going. I have not quit. All right, awesome. Glad to hear those are coming. Yeah, all


00:20:41.420 --> 00:20:44.220
right. Well thanks a lot for talking to me today. Yeah, it's been great. Thanks for


00:20:44.220 --> 00:20:47.020
sharing the news with me and we'll see you later. Thanks.


00:20:47.020 --> 00:20:51.580
Thank you for listening to Python Bytes. Follow the show on Twitter via @PythonBytes


00:20:51.580 --> 00:20:58.780
bytes that's Python bytes as in b y t e s and get the full show notes at Python bytes dot fm. If you


00:20:58.780 --> 00:21:02.860
have a news item you want featured just visit Python bytes dot fm and send it our way. We're


00:21:02.860 --> 00:21:07.660
always on the lookout for sharing something cool. On behalf of myself and Brian Okken,


00:21:07.660 --> 00:21:11.900
this is Michael Kennedy. Thank you for listening and sharing this podcast with your friends and

