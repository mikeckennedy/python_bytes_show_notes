
00:00:00.000 --> 00:00:05.280
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds.


00:00:05.280 --> 00:00:10.960
This is episode 193, recorded July 29th, 2020. I'm Michael Kennedy.


00:00:10.960 --> 00:00:12.160
And I am Brian Okken.


00:00:12.160 --> 00:00:14.800
And we've got a bunch of great stuff to tell you about.


00:00:14.800 --> 00:00:19.920
This episode is brought to you by us. We will share that information with you later.


00:00:19.920 --> 00:00:24.240
But for now, I want to talk about something that I actually saw today.


00:00:24.240 --> 00:00:27.280
And I think you're going to bring this up as well, Brian.


00:00:27.280 --> 00:00:36.040
I'm a let you talk about but something i ran into updating my service with a big warning in red when i pick and saw some stuff saying your things are inconsistent.


00:00:36.040 --> 00:00:54.460
There's no way pep is going to work soon so be ready and of course that just results in frustration for me because you know and depend a bot tells me i need these versions but some things don't require anyway long story you tell us about it okay so i was curious i haven't actually seen this yet so i'm glad that you've seen it so you have some experience.


00:00:54.580 --> 00:00:58.580
This was brought up to us by Matthew Fickart.


00:00:58.580 --> 00:01:04.880
And he says he was running pip and he got this warning and it's all in red. So I'm gonna have to squint to read this.


00:01:04.880 --> 00:01:11.480
It says, "After October 2020, you may experience errors when installing or updating packages.


00:01:11.480 --> 00:01:15.980
This is because pip will change the way it resolves dependency conflicts.


00:01:15.980 --> 00:01:22.080
We recommend that you use use_features=2020 resolver to test your packages."


00:01:22.080 --> 00:01:31.700
It shows up as an error and I think it's just so that people actually read it but I don't know if it's a real error or not. It still works fine but it's going to be an error eventually.


00:01:31.700 --> 00:01:35.840
Okay so this is not a problem do not adjust your sets actually do adjust your sets.


00:01:35.840 --> 00:01:42.740
What you need to be aware of is the changes so we've got a we I think we've covered it before but we've got a link in the show notes to the


00:01:42.740 --> 00:01:54.740
hit the dependency resolver changes and these are good things but one of the things that matthew pointed out which is great and i'm also gonna link to an article where he discusses where


00:01:54.740 --> 00:02:00.420
like how his problem showed up with this and it's around projects that use


00:02:00.420 --> 00:02:07.420
Some people use poetry and other things and i can't remember the other one, pipenv, that does things like lock files and stuff.


00:02:07.420 --> 00:02:12.580
But a lot of people just do that kind of manually and what you often do is you have like a,


00:02:12.580 --> 00:02:15.620
your original set of requirements that are just your,


00:02:15.620 --> 00:02:23.500
like the handful of things that you immediately depend on with no versions or with minimal version rules around it.


00:02:23.500 --> 00:02:25.980
And you say, pip install this stuff.


00:02:25.980 --> 00:02:33.160
Well that actually ends up installing a whole bunch of all of your immediate dependencies all of their dependencies and everything.


00:02:33.160 --> 00:02:38.300
So if you want to lock that down so that you're only installing the same things again and again,


00:02:38.300 --> 00:02:51.260
you say pip freeze and then pipe that to a like a lock file and then you can use that I guess a common pattern it's not the same as pip m's lock file and stuff but it can be similar anyway.


00:02:51.420 --> 00:02:54.340
And then if you use that and pip install from that,


00:02:54.340 --> 00:02:57.020
everything should be fine. You're going to install those dependencies.


00:02:57.020 --> 00:03:02.540
The problem is if you don't use the use2020 resolver feature


00:03:02.540 --> 00:03:05.420
to generate your lock file,


00:03:05.420 --> 00:03:09.940
then if you do use it to install from your lock file,


00:03:09.940 --> 00:03:12.420
there may be incompatibilities with those.


00:03:12.420 --> 00:03:16.500
So the resolvers actually, there's good things going on here,


00:03:16.500 --> 00:03:18.500
having pip do the resolver better.


00:03:18.500 --> 00:03:22.600
but the quick note we want to say is don't panic when you see that red thing,


00:03:22.600 --> 00:03:25.840
you should just try the use features 2020 resolver,


00:03:25.840 --> 00:03:30.700
but if you're using a lock file, use it for the whole process, use the new resolver


00:03:30.700 --> 00:03:34.700
to generate your original lock file from your original stuff,


00:03:34.700 --> 00:03:38.540
and then use it when you're installing the requirements lock file.


00:03:38.540 --> 00:03:41.900
There's also information on the IPA website,


00:03:41.900 --> 00:03:45.040
they want to know if there's issues, this is still in a,


00:03:45.040 --> 00:03:50.960
it's available but we're still there still maybe kinks but i think it's pretty solid not enforced but


00:03:50.960 --> 00:03:58.920
warning is yeah i can actually really like this way of rolling out a new feature and in a behavior changes to have


00:03:58.920 --> 00:04:05.720
have it be available as a flag so that you can test in a in a not a pre release but an actual release.


00:04:05.720 --> 00:04:11.760
And then i'm had change the default behavior later but so the reason why we're bringing this up is.


00:04:11.880 --> 00:04:27.060
October is not that far away and october is the date when that's gonna change to not just a flag behavior but the default behavior so yes go out and make sure these things are happening and if you completely ignore us when things break in october.


00:04:27.060 --> 00:04:37.720
The reason is probably the need to regenerate your lock file so in principle i'm all for this this is a great idea it's going to make sure that things are consistent.


00:04:37.920 --> 00:04:41.040
by looking at the dependencies of your libraries.


00:04:41.040 --> 00:04:45.920
However, two things that are driving me bonkers right now


00:04:45.920 --> 00:04:51.040
are systems like Dependabot or PyUp,


00:04:51.040 --> 00:04:54.400
which are critically important for making sure that


00:04:54.400 --> 00:04:59.200
your web apps get updated with, say, like security patches and stuff, right?


00:04:59.200 --> 00:05:03.120
So you would do this like, you know, pip freeze your dependencies,


00:05:03.120 --> 00:05:05.760
and then it has the version.


00:05:05.760 --> 00:05:07.680
What if say you're using Django


00:05:07.680 --> 00:05:09.920
and there's a security release around something in there,


00:05:09.920 --> 00:05:10.840
right?


00:05:10.840 --> 00:05:12.400
Unless you know to update that,


00:05:12.400 --> 00:05:15.180
it's always just gonna install the one that you started with.


00:05:15.180 --> 00:05:18.440
So you wanna use a system like Dependabot or PyUp


00:05:18.440 --> 00:05:20.320
where it's gonna look at your requirements.


00:05:20.320 --> 00:05:23.920
It's gonna say, these are out of date, let's update them.


00:05:23.920 --> 00:05:25.400
Here's the new one.


00:05:25.400 --> 00:05:28.920
However, those systems don't look at the entirety


00:05:28.920 --> 00:05:30.760
of what it potentially could set them to.


00:05:30.760 --> 00:05:33.060
It says, okay, you're using DocOpt.


00:05:33.060 --> 00:05:35.520
There's 0.16 of DocOpt.


00:05:35.520 --> 00:05:41.800
Oh, except for the thing that is before it actually requires DocOpt 14 or is incompatible.


00:05:41.800 --> 00:05:48.300
And as in incompatible as pip will not install that requirements.txt any longer.


00:05:48.300 --> 00:05:51.560
But those systems still say, great, let's upgrade it.


00:05:51.560 --> 00:05:57.340
And you're like in this, this battle of those, those things are like upgrading it.


00:05:57.340 --> 00:06:01.300
And then like the older libraries are not upgrading or you get two libraries, one requires


00:06:01.300 --> 00:06:06.860
doc op 16 or above one requires doc op 14 or lower, you just can no longer use those


00:06:06.860 --> 00:06:07.860
libraries together.


00:06:07.860 --> 00:06:12.060
Now it probably doesn't actually matter like the feature you're using probably is compatible


00:06:12.060 --> 00:06:14.900
with both, but you won't be able to install it anymore.


00:06:14.900 --> 00:06:21.060
And my hope is what this means is the people that have these weird old dependencies will


00:06:21.060 --> 00:06:26.860
either loosen the requirements on their dependency structure, like we're talking about, right,


00:06:26.860 --> 00:06:32.460
this thing uses this older version or it's got to be a new version or update it or something


00:06:32.460 --> 00:06:36.140
because it's going to be there's going to be packages that are just incompatible that are


00:06:36.140 --> 00:06:41.260
not actually incompatible because of this. Yeah, interesting. Yes, painful. I don't know what to


00:06:41.260 --> 00:06:46.860
do about it. But it's like literally this morning I ran into this and I had to go back and undo what


00:06:46.860 --> 00:06:51.260
dependabot was trying to do for me because certain things were no longer working right or something


00:06:51.260 --> 00:06:52.260
- Interesting. - Yeah.


00:06:52.260 --> 00:06:55.760
- So does Dependabot, Dependabot, Dependabot?


00:06:55.760 --> 00:06:57.760
- Yeah, that's the thing that GitHub acquired


00:06:57.760 --> 00:07:00.760
that basically looks at your various package listings


00:07:00.760 --> 00:07:02.760
and says, "There's a new version of this.


00:07:02.760 --> 00:07:04.760
Let's pin it to a higher version," and it comes as a PR.


00:07:04.760 --> 00:07:06.260
- Okay, that was my question.


00:07:06.260 --> 00:07:08.760
It comes as a PR, so if you had testing


00:07:08.760 --> 00:07:11.760
around in a CI-like environment or something,


00:07:11.760 --> 00:07:14.760
it could catch it before it went through?


00:07:14.760 --> 00:07:16.260
- Yes, you'll still get the PR.


00:07:16.260 --> 00:07:18.260
It'll still be in your GitHub repo,


00:07:18.260 --> 00:07:23.260
repo, but the CI presumably would fail


00:07:23.260 --> 00:07:26.940
because the pip install step would fail,


00:07:26.940 --> 00:07:29.100
and then it would just know that it couldn't


00:07:29.100 --> 00:07:30.860
auto merge it.


00:07:30.860 --> 00:07:31.660
But still, it's like, you're constantly


00:07:31.660 --> 00:07:37.140
trying to push the water, the tide back


00:07:37.140 --> 00:07:39.540
because you're like, "Stop doing this.


00:07:39.540 --> 00:07:41.300
It's driving me crazy."


00:07:41.300 --> 00:07:42.300
And there are certain ways to link it,


00:07:42.300 --> 00:07:44.700
but then you're just forced it to certain boundaries.


00:07:44.700 --> 00:07:47.580
But anyway, it's going to make it a little bit


00:07:45.580 --> 00:07:46.940
more complicated some of these things.


00:07:46.940 --> 00:07:48.620
Hopefully it considers this.


00:07:48.620 --> 00:07:51.060
- Well, maybe Dependapod can update to do this.


00:07:51.060 --> 00:07:52.020
- Wouldn't that be great?


00:07:52.020 --> 00:07:54.020
Yeah, that would be great.


00:07:54.020 --> 00:07:55.620
Well, speaking of packages,


00:07:55.620 --> 00:07:58.500
the way you use packages is you import them


00:07:58.500 --> 00:07:59.540
once you've installed them, right?


00:07:59.540 --> 00:08:00.380
- Yes.


00:08:00.380 --> 00:08:04.580
- So Brandon Branner was talking on Twitter with me


00:08:04.580 --> 00:08:07.180
saying like, "I have some imports that are slow.


00:08:07.180 --> 00:08:09.540
"Like how can I figure out what's going on here?"


00:08:09.540 --> 00:08:12.460
And this led me over to something


00:08:12.460 --> 00:08:14.180
we may have covered a long time ago.


00:08:14.180 --> 00:08:18.900
I don't think so, but possibly, called import-profiler.


00:08:18.900 --> 00:08:19.740
You know this?


00:08:19.740 --> 00:08:20.560
- No, this is cool.


00:08:20.560 --> 00:08:21.880
- Yeah, so one of the things


00:08:21.880 --> 00:08:25.220
that can actually be legitimately slow


00:08:25.220 --> 00:08:29.460
about Python startup code is actually the imports.


00:08:29.460 --> 00:08:32.700
So for example, like if you import requests,


00:08:32.700 --> 00:08:36.040
it might be importing like a ton of different things,


00:08:36.040 --> 00:08:39.260
standard library modules, as well as external packages,


00:08:39.260 --> 00:08:40.740
which are then themselves importing


00:08:40.740 --> 00:08:43.500
standard library modules, et cetera, et cetera, right?


00:08:43.500 --> 00:08:46.220
- So you might wanna know what's slow and what's not.


00:08:46.220 --> 00:08:48.060
- And it's also not just, it's not like,


00:08:48.060 --> 00:08:50.940
just like a C include, it's a,


00:08:50.940 --> 00:08:52.240
imports actually run code.


00:08:52.240 --> 00:08:53.080
- Yes, exactly.


00:08:53.080 --> 00:08:55.400
It's not something happening at compile time.


00:08:55.400 --> 00:08:57.700
It's happening at run time.


00:08:57.700 --> 00:08:59.960
So every time you start your app,


00:08:59.960 --> 00:09:01.060
it goes through and it says, okay,


00:09:01.060 --> 00:09:02.920
what we're gonna do is we're gonna execute the code


00:09:02.920 --> 00:09:05.680
that defines the functions and defines the methods


00:09:05.680 --> 00:09:07.360
and potentially other code as well.


00:09:07.360 --> 00:09:08.440
Who knows what else is going on?


00:09:08.440 --> 00:09:13.360
So there's a non-trivial amount of time to be spent


00:09:13.360 --> 00:09:14.760
doing that kind of stuff.


00:09:14.760 --> 00:09:18.640
For example, I believe it takes like half a second


00:09:18.640 --> 00:09:20.720
to import requests, just requests.


00:09:20.720 --> 00:09:21.560
- Interesting.


00:09:21.560 --> 00:09:23.120
- Obviously that depends on the system, right?


00:09:23.120 --> 00:09:26.440
You do it on MicroPython versus on like a super computer,


00:09:26.440 --> 00:09:27.720
the time's gonna vary.


00:09:27.720 --> 00:09:30.520
But nonetheless, there's a non-trivial amount of time


00:09:30.520 --> 00:09:31.360
because of what's happening.


00:09:31.360 --> 00:09:33.680
So there's this cool thing called import profiler,


00:09:33.680 --> 00:09:36.320
which all you gotta do is say,


00:09:36.320 --> 00:09:41.240
from import profiler, import, profile, import.


00:09:41.240 --> 00:09:43.960
- Woo, say that a bunch of times fast.


00:09:43.960 --> 00:09:45.000
Written, it's fine.


00:09:45.000 --> 00:09:46.780
Spoken, it's funky.


00:09:46.780 --> 00:09:48.760
But then you just create a context manager


00:09:48.760 --> 00:09:49.960
around your import statements.


00:09:49.960 --> 00:09:54.480
You say with profile import as context, all your imports,


00:09:54.480 --> 00:09:56.920
and then you can print out, you say context.printInfo,


00:09:56.920 --> 00:09:59.560
and you get a profile status report.


00:09:59.560 --> 00:10:00.380
- That's cool.


00:10:00.380 --> 00:10:02.600
- Now I included a little tiny example of this


00:10:02.600 --> 00:10:04.920
for requests and what was coming out of it.


00:10:04.920 --> 00:10:06.660
If you look at the documentation,


00:10:06.660 --> 00:10:08.680
it's actually much longer.


00:10:08.680 --> 00:10:10.440
So I'm looking here.


00:10:10.440 --> 00:10:12.480
I would say just eyeballing it,


00:10:12.480 --> 00:10:15.800
there's probably 30 different modules being imported


00:10:15.800 --> 00:10:17.720
when you say import requests.


00:10:17.720 --> 00:10:19.440
That's non-trivial, all right?


00:10:19.440 --> 00:10:20.800
That's a lot of stuff.


00:10:20.800 --> 00:10:23.120
So this will give you that output.


00:10:23.120 --> 00:10:26.700
It'll say, here, this module imported this module,


00:10:26.700 --> 00:10:29.640
and then it has a hierarchy or a tree type of thing.


00:10:29.640 --> 00:10:31.600
So this module imported this module,


00:10:31.600 --> 00:10:32.920
which imported those other two,


00:10:32.920 --> 00:10:35.780
and so you can sort of see the chain or a tree


00:10:35.780 --> 00:10:37.520
of if I'm importing this,


00:10:37.520 --> 00:10:40.200
here's the whole bunch of other stuff it takes with it.


00:10:40.200 --> 00:10:42.480
- Okay. - Yeah, and it gives you


00:10:42.480 --> 00:10:45.840
the overall time, I think maybe the time dedicated


00:10:45.840 --> 00:10:49.680
to just that operation, and then the inclusive time


00:10:49.680 --> 00:10:51.640
or something, actually maybe it looks more like


00:10:51.640 --> 00:10:53.880
83 milliseconds, sorry, I have my units wrong,


00:10:53.880 --> 00:10:55.320
I said a half a second, but nonetheless,


00:10:55.320 --> 00:10:57.800
it's like, you know, you have a bunch of imports


00:10:57.800 --> 00:11:00.160
and you're running code, where is that slow?


00:11:00.160 --> 00:11:03.900
You can run this and it basically takes three lines of code


00:11:03.900 --> 00:11:06.840
to figure out how much time each part


00:11:06.840 --> 00:11:08.960
of that entire import stack, I don't know,


00:11:08.960 --> 00:11:10.840
I want to say call stack of that execution,


00:11:10.840 --> 00:11:13.000
but it's the series of imports that happen.


00:11:13.000 --> 00:11:15.620
Like you time that whole thing and look at it.


00:11:15.620 --> 00:11:17.160
So yeah, it's pretty cool.


00:11:17.160 --> 00:11:18.000
- That's neat.


00:11:18.000 --> 00:11:22.120
And also, I mean, there's times where you really want


00:11:22.120 --> 00:11:24.460
to get startup time for something really


00:11:24.460 --> 00:11:25.680
as fast as possible.


00:11:25.680 --> 00:11:29.160
And this is part of it, is the things you're importing


00:11:29.160 --> 00:11:32.560
at your startup is sometimes non-trivial


00:11:32.560 --> 00:11:35.480
when you have something that you really want to run fast.


00:11:35.480 --> 00:11:37.420
- Right, like let's say you're spending half a second


00:11:37.420 --> 00:11:40.840
on startup time because of the imports.


00:11:40.840 --> 00:11:43.660
You might be able to take the slowest part of those


00:11:43.660 --> 00:11:46.540
and import that in a function that gets called, right?


00:11:46.540 --> 00:11:48.400
So-- - Yeah, import it later.


00:11:48.400 --> 00:11:50.400
- Yes, you only pay for it


00:11:50.400 --> 00:11:51.880
if you're gonna go down that branch


00:11:51.880 --> 00:11:53.860
'cause maybe you're not gonna call that part


00:11:53.860 --> 00:11:56.540
of the operation or like that part of the CLI or whatever.


00:11:56.540 --> 00:11:58.920
- Yeah, and it's definitely one of those fine-tuning things


00:11:58.920 --> 00:12:01.260
that you wanna make sure you don't do this too early.


00:12:01.260 --> 00:12:05.940
But for people packaging and supporting large projects,


00:12:05.940 --> 00:12:08.460
I think it's a good idea to pay attention to this


00:12:08.460 --> 00:12:10.540
and make sure to your import time.


00:12:10.540 --> 00:12:12.220
Like it'd be something that would be kind of fun


00:12:12.220 --> 00:12:14.540
to throw in a test case for CI to make sure


00:12:14.540 --> 00:12:18.180
that your import time doesn't suddenly go slower


00:12:18.180 --> 00:12:20.620
because something you depend on suddenly got slower


00:12:20.620 --> 00:12:21.460
or something like that.


00:12:21.460 --> 00:12:22.280
- Yeah, yeah, absolutely.


00:12:22.280 --> 00:12:23.120
And you don't necessarily know


00:12:23.120 --> 00:12:26.860
'cause the thing it depends upon, that thing changed, right?


00:12:26.860 --> 00:12:29.140
It's not even the thing you actually depend upon, right?


00:12:29.140 --> 00:12:31.660
It's very, it could be very down the line.


00:12:31.660 --> 00:12:32.780
Yeah, and maybe you're like,


00:12:32.780 --> 00:12:34.300
we're gonna use this other library.


00:12:34.300 --> 00:12:37.180
we barely use it, but we already have dependencies,


00:12:37.180 --> 00:12:38.460
why not just throw this one in?


00:12:38.460 --> 00:12:40.540
Oh wait, that's adding a quarter of a second.


00:12:40.540 --> 00:12:43.300
We could just vendor that one file


00:12:43.300 --> 00:12:45.700
that we don't really, and make it much, much faster.


00:12:45.700 --> 00:12:48.100
So there's a lot of interesting use cases here.


00:12:48.100 --> 00:12:48.920
A lot of time you don't care.


00:12:48.920 --> 00:12:50.620
Like for my web apps, I don't care.


00:12:50.620 --> 00:12:52.220
For my CLI apps, I might care.


00:12:52.220 --> 00:12:53.060
- Yeah, definitely.


00:12:53.060 --> 00:12:57.380
- Yeah, so I've been on this bit of exploration lately,


00:12:57.380 --> 00:13:01.460
Brian, and that's because I'm working on a new course.


00:13:01.460 --> 00:13:02.300
- Yeah?


00:13:02.300 --> 00:13:03.300
- Yeah, yeah, we're actually working on a bunch of courses


00:13:03.300 --> 00:13:05.180
over at Talk Python, some data science ones,


00:13:05.180 --> 00:13:06.640
which are really awesome.


00:13:06.640 --> 00:13:08.020
But the one that I'm working on


00:13:08.020 --> 00:13:11.300
is Python memory management and profiling,


00:13:11.300 --> 00:13:14.040
and tips and tricks and data structures


00:13:14.040 --> 00:13:16.020
to make all those things go better.


00:13:16.020 --> 00:13:16.860
- Nice.


00:13:16.860 --> 00:13:18.740
- So I'm kind of on this profiling bent.


00:13:18.740 --> 00:13:21.640
And anyway, so if people are interested in that


00:13:21.640 --> 00:13:23.340
or any of the other courses that we're working on,


00:13:23.340 --> 00:13:27.140
they can check them out over at training.talkpython.fm.


00:13:27.140 --> 00:13:31.220
Helps bring you this podcast and others and books.


00:13:31.220 --> 00:13:32.460
- Thanks for that transition,


00:13:32.460 --> 00:13:35.100
but I'm excited about that because the profiling and stuff


00:13:35.100 --> 00:13:37.420
is one of those things that often is considered


00:13:37.420 --> 00:13:38.580
kind of like a black art,


00:13:38.580 --> 00:13:40.580
something that you just learn on the job.


00:13:40.580 --> 00:13:41.540
And how do you learn it?


00:13:41.540 --> 00:13:43.580
I don't know, you just have to know somebody


00:13:43.580 --> 00:13:45.000
that knows how to do it or something.


00:13:45.000 --> 00:13:47.580
So having some courses around that's a really great idea.


00:13:47.580 --> 00:13:50.700
- Thanks, yeah, and also like when does a GC run?


00:13:50.700 --> 00:13:52.660
What is the cost of reference counting?


00:13:52.660 --> 00:13:53.880
Can you turn off the GC?


00:13:53.880 --> 00:13:56.640
What data structures are more efficient or less efficient


00:13:56.640 --> 00:13:58.180
according to that and all that kind of stuff.


00:13:58.180 --> 00:13:59.020
It'll be a lot of fun.


00:13:59.020 --> 00:14:01.140
- Cool, yeah, so I've got a book.


00:14:01.140 --> 00:14:03.460
I actually want to highlight something.


00:14:03.460 --> 00:14:06.760
I've got a link called, it's pytestbook.com.


00:14:06.760 --> 00:14:11.060
So if you just go to pytestbook.com, it actually goes to a landing page.


00:14:11.060 --> 00:14:12.700
That's on blog.


00:14:12.700 --> 00:14:16.300
That's kind of not really that active, but there is a landing page.


00:14:16.300 --> 00:14:21.020
The reason why I'm pointing this out is because some people are transitioning.


00:14:21.020 --> 00:14:23.840
Some people are finally starting to use three, eight more.


00:14:23.840 --> 00:14:27.120
There's people starting to test three, nine a lot, which is great.


00:14:27.120 --> 00:14:27.700
There's.


00:14:28.020 --> 00:14:30.740
PyTest 6 just got released, not one of our items.


00:14:30.740 --> 00:14:32.580
And I've gotten a lot of questions of,


00:14:32.580 --> 00:14:34.260
is the book still relevant?


00:14:34.260 --> 00:14:37.140
And yes, the PyTest book is still relevant,


00:14:37.140 --> 00:14:39.340
but there's a couple gotchas.


00:14:39.340 --> 00:14:42.260
I will list all of these on that landing page.


00:14:42.260 --> 00:14:43.700
So they're not there yet,


00:14:43.700 --> 00:14:45.700
but they will be by the time this airs.


00:14:45.700 --> 00:14:46.540
- Time travel.


00:14:46.540 --> 00:14:48.980
- Yeah, there's a RADA page on Pragmatic


00:14:48.980 --> 00:14:51.020
that I'll link to, but the main,


00:14:51.020 --> 00:14:51.920
there's a few things.


00:14:51.920 --> 00:14:55.140
Like there's a database that I use in the examples


00:14:55.140 --> 00:14:57.800
as a tiny DB, and the API changed


00:14:57.800 --> 00:14:59.160
since I wrote the book.


00:14:59.160 --> 00:15:02.640
There's a little note to update this setup


00:15:02.640 --> 00:15:04.840
to pin the database version.


00:15:04.840 --> 00:15:08.960
And there's something, markers used to be,


00:15:08.960 --> 00:15:10.160
used to be able to get away with


00:15:10.160 --> 00:15:12.120
just throwing markers in anywhere.


00:15:12.120 --> 00:15:14.760
Now you get a warning if you don't declare them.


00:15:14.760 --> 00:15:17.920
There's a few minor things that are changed


00:15:17.920 --> 00:15:21.680
that make it for new PyTest users might be frustrating


00:15:21.680 --> 00:15:22.560
to walk through the book.


00:15:22.560 --> 00:15:25.380
So I'm gonna lay those out just directly on that page


00:15:25.380 --> 00:15:27.760
to have people get started really quickly.


00:15:27.760 --> 00:15:30.220
So, pytestbook.com is what that is.


00:15:30.220 --> 00:15:31.900
- Awesome, yeah, it's a great book.


00:15:31.900 --> 00:15:34.320
And you might be on a testing event as well,


00:15:34.320 --> 00:15:36.320
if I'm on my profiling one.


00:15:36.320 --> 00:15:40.040
- Yeah, actually, so this is a Django testing toolbox,


00:15:40.040 --> 00:15:41.720
is an article by Matt Lehman,


00:15:41.720 --> 00:15:43.360
and I was actually gonna think about


00:15:43.360 --> 00:15:45.180
having him on the show, and I still might,


00:15:45.180 --> 00:15:47.880
on Testing Code to talk about some of this stuff.


00:15:47.880 --> 00:15:50.200
But he threw together, I just wanted to cover it here,


00:15:50.200 --> 00:15:53.320
'cause it's a really great throw together of information.


00:15:53.320 --> 00:15:56.800
That's a quick walkthrough of how Matt tests


00:15:56.800 --> 00:16:02.160
Django projects and he goes through some of the packages that he uses all the time and


00:16:02.160 --> 00:16:04.140
some interesting techniques.


00:16:04.140 --> 00:16:09.100
The packages that there's a couple of them that I was familiar with, PyTest Django, which


00:16:09.100 --> 00:16:13.200
is like, of course, you're, of course, you should use that.


00:16:13.200 --> 00:16:17.720
Factory Boy is the one there's a lot of, Factory Boy is one project, there's a lot of different


00:16:17.720 --> 00:16:20.200
projects to generate fake data.


00:16:20.200 --> 00:16:21.680
Factory Boy is the one Matt uses.


00:16:21.680 --> 00:16:23.180
So there's a highlight there.


00:16:23.180 --> 00:16:27.460
And then one that I hadn't heard of before, Django test plus, which is a beefed up test


00:16:27.460 --> 00:16:31.680
case and maybe has other stuff too, but it has a whole bunch of helper utilities to make


00:16:31.680 --> 00:16:36.260
it easier to check commonly tested things in Django.


00:16:36.260 --> 00:16:38.120
So that's pretty cool.


00:16:38.120 --> 00:16:41.700
And then some of the techniques, like one of the things that people, some people trying


00:16:41.700 --> 00:16:47.840
to use PyTest for Django get tripped up at is a lot of people think of PyTest as just


00:16:47.840 --> 00:16:51.880
functions only, test functions only and not test classes.


00:16:51.880 --> 00:16:56.440
There are some uses. Matt says he really likes to use test classes.


00:16:56.440 --> 00:17:01.160
I mean, PyTest allows you to use test classes, but you can use


00:17:01.160 --> 00:17:05.560
these derived test cases like the Django test plus test case.


00:17:05.560 --> 00:17:08.760
A couple of things using a Rage Act assert as a structure,


00:17:08.760 --> 00:17:13.080
in-memory SQLite databases, when you can get away with it to speed up


00:17:13.080 --> 00:17:15.720
because in-memory databases are way faster than


00:17:15.720 --> 00:17:17.320
on-file system databases.


00:17:17.320 --> 00:17:21.240
Yeah, and you don't have to worry about dependencies or servers you got to run. It's just


00:17:21.240 --> 00:17:22.600
colon memory


00:17:22.600 --> 00:17:25.240
Boom you connect to it and off it goes. Yeah


00:17:25.240 --> 00:17:30.840
Um, one of the things I didn't get I mean I I kind of get the next one disabling migrations while testing


00:17:30.840 --> 00:17:36.120
I don't know a lot about my database migrations or django migrations or whatever those are


00:17:36.120 --> 00:17:39.400
But apparently disabling them is a good idea. It makes sense


00:17:39.400 --> 00:17:42.040
faster password hasher


00:17:42.040 --> 00:17:44.520
I have no idea what this is talking about, but


00:17:44.520 --> 00:17:49.800
Apparently you can speed up your testing by having a pass faster password hasher


00:17:50.120 --> 00:17:52.360
Yeah, a lot of times they'll, they'll generate them.


00:17:52.360 --> 00:17:56.160
So they're explicitly slow.


00:17:56.160 --> 00:17:56.920
Right.


00:17:56.920 --> 00:18:02.120
So like over at talk Python, I have, I use pass lib, not Django, but pass up is


00:18:02.120 --> 00:18:06.720
awesome, but if you just do say an MD five, it is like super fast, right?


00:18:06.720 --> 00:18:11.520
So if you say, I want to generate this and take this and generate it, it'll


00:18:11.520 --> 00:18:15.800
come up with the hashed output, but because it's fast, people could look at


00:18:15.800 --> 00:18:19.320
that and say, well, let me try like a hundred thousand words I know and see


00:18:19.320 --> 00:18:22.080
If any of them match that, then that's the password, right?


00:18:22.080 --> 00:18:23.520
You can use more complicated ones,


00:18:23.520 --> 00:18:25.360
and MD5 is not one you want.


00:18:25.360 --> 00:18:28.020
Something like B encrypt or something,


00:18:28.020 --> 00:18:32.200
which is slower a little bit, and better, harder to guess.


00:18:32.200 --> 00:18:34.880
But what you should really do is you should like,


00:18:34.880 --> 00:18:37.960
insert little bits of like salt, like extra text around it,


00:18:37.960 --> 00:18:40.480
so even if it matches, it's not exactly the same.


00:18:40.480 --> 00:18:42.280
You can't do those guesses.


00:18:42.280 --> 00:18:43.480
But then you should fold it,


00:18:43.480 --> 00:18:46.120
which means take the output of the first time,


00:18:46.120 --> 00:18:48.520
feed it back through, take the output of the second time,


00:18:48.520 --> 00:18:51.640
feed it back through 100, 200, 300,000 times


00:18:51.640 --> 00:18:52.840
so that if they try to guess,


00:18:52.840 --> 00:18:55.120
it's super computationally slow.


00:18:55.120 --> 00:18:56.280
I'm sure that's what it's talking about.


00:18:56.280 --> 00:18:57.280
So you don't want to do that


00:18:57.280 --> 00:18:58.560
when you want your test to run fast


00:18:58.560 --> 00:19:01.880
'cause you don't care about hash security during tests.


00:19:01.880 --> 00:19:03.400
- Oh yeah, that makes total sense.


00:19:03.400 --> 00:19:04.220
- That's my guess.


00:19:04.220 --> 00:19:05.060
I don't know for sure,


00:19:05.060 --> 00:19:06.160
but that's what I think what that probably means.


00:19:06.160 --> 00:19:08.800
- The last tip, which is always a good tip,


00:19:08.800 --> 00:19:10.760
is figure out your editor


00:19:10.760 --> 00:19:13.240
so that you can run your tests from your editor


00:19:13.240 --> 00:19:17.120
'cause your cycle time of flipping between code and test


00:19:17.120 --> 00:19:20.160
is going to be a lot faster if you can run them from your editor.


00:19:20.160 --> 00:19:21.160
Yep.


00:19:21.160 --> 00:19:22.160
These are good tips.


00:19:22.160 --> 00:19:25.840
And if you're super intense, you have the auto run, which I don't do.


00:19:25.840 --> 00:19:26.840
I don't have auto run on.


00:19:26.840 --> 00:19:28.480
I do it once in a while.


00:19:28.480 --> 00:19:29.480
Yeah, yeah.


00:19:29.480 --> 00:19:30.480
Cool.


00:19:30.480 --> 00:19:31.480
Well, back to my rant.


00:19:31.480 --> 00:19:32.480
Let's talk about profiling.


00:19:32.480 --> 00:19:33.480
Okay.


00:19:33.480 --> 00:19:35.800
Actually, this is not exactly the same type of profiling.


00:19:35.800 --> 00:19:39.520
It's more of a look inside of data than of performance.


00:19:39.520 --> 00:19:43.240
So this was recommended to us by one of our listeners named Oz.


00:19:43.240 --> 00:19:45.040
First name only is what we got.


00:19:45.040 --> 00:19:46.800
So thank you, Oz.


00:19:46.800 --> 00:19:52.480
And he is a data scientist who goes around and spends a lot of time working on Python


00:19:52.480 --> 00:19:54.560
and doing exploratory data analysis.


00:19:54.560 --> 00:19:59.680
And the idea is like going to grab some data, open it up and explore it, right?


00:19:59.680 --> 00:20:00.680
And just start looking around.


00:20:00.680 --> 00:20:03.360
But it might be incomplete, it might be malformed.


00:20:03.360 --> 00:20:06.600
You don't necessarily know exactly what its structure is.


00:20:06.600 --> 00:20:12.220
And he used to do this by hand, but he found this project called Pandas-Profiling, which


00:20:12.220 --> 00:20:13.760
automates all of this.


00:20:13.760 --> 00:20:15.000
So that sounds handy.


00:20:15.000 --> 00:20:21.040
I mentioned before missing no, missing N-O, as in the missing number, missing data explorer,


00:20:21.040 --> 00:20:23.760
which is super cool and I still think that's awesome.


00:20:23.760 --> 00:20:25.960
But this is kind of in the same vein.


00:20:25.960 --> 00:20:31.000
And the idea is given a pandas data frame, you know, pandas has a describe function that


00:20:31.000 --> 00:20:34.000
says a little bit of detail about it.


00:20:34.000 --> 00:20:37.280
But with this thing, it kind of takes that and supercharges it.


00:20:37.280 --> 00:20:41.920
And you can say df.profile report, and it gives you all sorts of stuff.


00:20:41.920 --> 00:20:46.520
does type inference to say things in this column are integers or numbers,


00:20:46.520 --> 00:20:51.200
strings, date, times, whatever. It talks about the unique values, the missing


00:20:51.200 --> 00:20:56.680
values, quartile statistics stuff, descriptives, that's like mean mode,


00:20:56.680 --> 00:21:02.280
standard deviation, a bunch of stuff. Histograms, correlations, missing values,


00:21:02.280 --> 00:21:06.920
there's the missing note thing I spoke about, text analysis of like categories


00:21:06.920 --> 00:21:10.040
and whatnot, file and image analysis,


00:21:10.040 --> 00:21:13.520
like file sizes and creation dates and sizes of images


00:21:13.520 --> 00:21:15.320
and like all sorts of stuff.


00:21:15.320 --> 00:21:17.580
So the best way to see this is to look at an example.


00:21:17.580 --> 00:21:19.760
So in our notes, Brian, do you see where there's like,


00:21:19.760 --> 00:21:22.440
has nice examples and there's like the NASA meteorites one.


00:21:22.440 --> 00:21:25.720
So there's an example for like the US census data,


00:21:25.720 --> 00:21:29.160
a NASA meteorite one, some Dutch healthcare data and so on.


00:21:29.160 --> 00:21:30.240
If you open that up, you get it,


00:21:30.240 --> 00:21:31.360
you see what you get out of it.


00:21:31.360 --> 00:21:35.200
Like it's pages of reports of what was in that data frame.


00:21:35.200 --> 00:21:36.400
- Oh, this is great.


00:21:36.400 --> 00:21:37.720
- Isn't that cool? - This has got like,


00:21:37.720 --> 00:21:39.520
it's tabbed and stuff, so you can--


00:21:39.520 --> 00:21:43.280
- It's tabbed, it's got warnings, it's got pictures,


00:21:43.280 --> 00:21:45.600
it's got all kinds of analysis.


00:21:45.600 --> 00:21:47.280
- Tons of graphs. - It's got histogram graphs


00:21:47.280 --> 00:21:49.460
and you can like hide and show details


00:21:49.460 --> 00:21:52.980
and the details include tabbed, you know,


00:21:52.980 --> 00:21:55.720
I mean this is a massive dive into what the heck


00:21:55.720 --> 00:22:00.520
is going on with this data, correlations, heat maps.


00:22:00.520 --> 00:22:02.640
I mean, this is the business right here.


00:22:02.640 --> 00:22:06.380
So this is like one line of code to get this output.


00:22:06.380 --> 00:22:08.180
- This is great.


00:22:08.180 --> 00:22:10.600
This like replaces a couple interns at least.


00:22:10.600 --> 00:22:13.400
(laughing)


00:22:13.400 --> 00:22:16.140
- Sorry interns, but yeah, this is really cool.


00:22:16.140 --> 00:22:18.780
So I totally recommend if this sounds interesting,


00:22:18.780 --> 00:22:20.020
you do this kind of work,


00:22:20.020 --> 00:22:22.940
just pull up the NASA meteorite data


00:22:22.940 --> 00:22:25.860
and realize that like that all came from


00:22:25.860 --> 00:22:29.980
importing the thing and saying df profile report basically.


00:22:29.980 --> 00:22:31.080
And you get this.


00:22:31.080 --> 00:22:34.480
You can also click and run that in Binder and Google Collabs.


00:22:34.480 --> 00:22:36.480
You can go and interact with it live if you want.


00:22:36.480 --> 00:22:40.520
- Yeah, I love the warnings on some of the things.


00:22:40.520 --> 00:22:43.560
Like saying some of the variables will show up of like,


00:22:43.560 --> 00:22:45.320
there's some of them are skewed,


00:22:45.320 --> 00:22:47.680
like too many values at one value,


00:22:47.680 --> 00:22:51.120
that there's some of them have missing zeros showing.


00:22:51.120 --> 00:22:53.140
It does quite a bit of analysis for you


00:22:53.140 --> 00:22:54.560
about the data right away.


00:22:54.560 --> 00:22:55.480
That's pretty great.


00:22:55.480 --> 00:22:56.320
- Yeah, yeah.


00:22:56.320 --> 00:22:58.160
- Yeah, the types is great because you can just,


00:22:58.160 --> 00:23:01.840
I mean, you'd have like hundreds or thousands of data points.


00:23:01.840 --> 00:23:04.560
It's not trivial to just say,


00:23:04.560 --> 00:23:06.440
oh yeah, all of them are true or false.


00:23:06.440 --> 00:23:08.600
All of them are, I know they're Booleans.


00:23:08.600 --> 00:23:10.920
You'd have to look at everything first.


00:23:10.920 --> 00:23:11.760
- Yeah.


00:23:11.760 --> 00:23:14.300
It's one of those things that's like easy to adopt,


00:23:14.300 --> 00:23:16.740
but looks really useful and it's also beautiful.


00:23:16.740 --> 00:23:18.120
So yeah, check it out.


00:23:18.120 --> 00:23:18.960
It looks great.


00:23:18.960 --> 00:23:19.800
- I want to talk about


00:23:19.800 --> 00:23:21.080
object-oriented programming a little bit.


00:23:21.080 --> 00:23:21.980
- Oh, okay.


00:23:21.980 --> 00:23:23.320
- Actually, it's not something,


00:23:23.320 --> 00:23:25.920
I mean, all of Python really is object-oriented


00:23:25.920 --> 00:23:28.480
because we use everything as an object really.


00:23:28.480 --> 00:23:31.940
- Deep, deep down, everything's a Py object pointer.


00:23:31.940 --> 00:23:35.320
- Yeah, there's an article by Redouane Delaware


00:23:35.320 --> 00:23:38.360
called Interfaces, Mixins, and Building Powerful


00:23:38.360 --> 00:23:40.480
Custom Data Structures in Python.


00:23:40.480 --> 00:23:43.840
And I really liked it because it's a Python focused,


00:23:43.840 --> 00:23:46.400
I mean, there's not a lot, I've actually been disappointed


00:23:46.400 --> 00:23:49.880
with a lot of the object-oriented discussions around Python.


00:23:49.880 --> 00:23:53.000
And a lot of them are, talk about basically,


00:23:53.000 --> 00:23:55.740
I think they're lamenting that the system isn't the same


00:23:55.740 --> 00:24:01.980
other languages, but it's just not. Get over it. This is a Python-centric discussion talking about


00:24:01.980 --> 00:24:09.260
interfaces and abstract base classes, both informal and formal, abstract base classes,


00:24:09.260 --> 00:24:15.580
using mixins, and it starts out with the concept that people, there's like a base amount of


00:24:15.580 --> 00:24:20.540
knowledge that people have to have to discuss this sort of thing, and of understanding why


00:24:20.540 --> 00:24:26.780
they're useful and what are some of the downfalls and upfalls or benefits and whatever.


00:24:26.780 --> 00:24:32.100
And so he actually starts by talking, it's not too deep of a discussion, but it's an


00:24:32.100 --> 00:24:36.780
interesting discussion and I think it's a good background to discuss it.


00:24:36.780 --> 00:24:40.220
Then he talks about, like one of the things you kind of get into a little bit and you


00:24:40.220 --> 00:24:43.980
go, well, what's really different about an abstract base class and an interface, for


00:24:43.980 --> 00:24:45.420
instance.


00:24:45.420 --> 00:24:51.060
And he writes, "Interfaces can be thought of as a special case of an abstract base class.


00:24:51.060 --> 00:24:55.660
It's imperative that all methods of an interface are abstract methods and that classes don't


00:24:55.660 --> 00:24:59.740
store any data or any state or instance variables.


00:24:59.740 --> 00:25:04.460
However, in case of abstract base classes, the methods are generally abstract, but there


00:25:04.460 --> 00:25:10.300
can also be methods that provide implementation, concrete methods, and also these classes can


00:25:10.300 --> 00:25:11.700
have instance variables."


00:25:11.700 --> 00:25:13.540
So that's a nice distinction.


00:25:13.540 --> 00:25:18.740
And mixins are where you have a parent class that provides some functionality of a subclass,


00:25:18.740 --> 00:25:21.500
but it's not intended to be instantiated itself.


00:25:21.500 --> 00:25:25.820
That's why it's sort of similar to abstract base classes and other things.


00:25:25.820 --> 00:25:31.180
So having all this discussion from one person in a good discussion, I think is a really


00:25:31.180 --> 00:25:32.180
great thing.


00:25:32.180 --> 00:25:37.580
And there are definitely times I don't pull into class hierarchies and base classes that


00:25:37.580 --> 00:25:41.580
much, but there's times when you need them and they're very handy.


00:25:41.580 --> 00:25:42.580
So this is cool.


00:25:42.580 --> 00:25:43.740
This is super cool, actually.


00:25:43.740 --> 00:25:45.300
I really like this analysis.


00:25:45.300 --> 00:25:47.420
I love that it's really Python focused


00:25:47.420 --> 00:25:50.860
because a lot of times the mechanics of the language


00:25:50.860 --> 00:25:54.920
just don't support some of the object-oriented


00:25:54.920 --> 00:25:56.980
programming ideas in the same way, right?


00:25:56.980 --> 00:26:00.420
Like the interface keyword doesn't exist, right?


00:26:00.420 --> 00:26:03.460
So this distinction, you have to make it


00:26:03.460 --> 00:26:05.140
in a conventional sense.


00:26:05.140 --> 00:26:07.260
Like we come up with a convention


00:26:07.260 --> 00:26:09.540
that we don't have concrete methods


00:26:09.540 --> 00:26:11.840
or state with interfaces, right?


00:26:11.840 --> 00:26:15.080
but there's nothing, there's not like an interface keyword in Python.


00:26:15.080 --> 00:26:16.240
So I like it.


00:26:16.240 --> 00:26:20.600
I, I'm a big fan of object oriented programming, and I'm very aware that in


00:26:20.600 --> 00:26:25.760
Python, a lot of times what people use for classes is simply unneeded.


00:26:25.760 --> 00:26:29.400
And I, I know where that comes from and I want, I want to make sure


00:26:29.400 --> 00:26:30.560
that people don't overuse it, right?


00:26:30.560 --> 00:26:34.480
If you come from Java or C sharp or one of these OOP only languages,


00:26:34.480 --> 00:26:37.680
everything's a class, and so you're just going to start creating classes.


00:26:37.680 --> 00:26:40.720
But if what you really want is to group functions and a couple of pieces of


00:26:40.720 --> 00:26:43.680
data that's like shared, that's a module, right?


00:26:43.680 --> 00:26:44.820
You don't need a class, right?


00:26:44.820 --> 00:26:47.920
You could still say module name dot and get the list of them.


00:26:47.920 --> 00:26:50.880
And it's like a static class or something like that.


00:26:50.880 --> 00:26:53.280
But sometimes you want to model stuff


00:26:53.280 --> 00:26:54.960
with object-oriented programming


00:26:54.960 --> 00:26:56.840
and understanding the right way to do it in Python


00:26:56.840 --> 00:26:57.680
is really cool.


00:26:57.680 --> 00:26:58.720
This looks like a good one.


00:26:58.720 --> 00:27:03.120
- Yeah, and also there is a built-in library called ABC


00:27:03.120 --> 00:27:05.600
for abstract base class within Python.


00:27:05.600 --> 00:27:08.640
And it seems like a, for a lot of people,


00:27:08.640 --> 00:27:09.800
it seems like a mystery thing


00:27:09.800 --> 00:27:12.800
that only advanced people use, but it's really not that complicated.


00:27:12.800 --> 00:27:16.320
And this article uses that as well and talks about it.


00:27:16.320 --> 00:27:17.280
So it's good.


00:27:17.280 --> 00:27:21.240
You want to my favorite things about abstract based classes and abstract methods


00:27:21.240 --> 00:27:23.160
is in PyCharm.


00:27:23.160 --> 00:27:28.240
If I have a class that derives from an abstract class, all I have to write is class.


00:27:28.240 --> 00:27:37.840
The thing I'm trying to create, parentheses, abstract class name, close parentheses, colon, and then you just hit alt, alt, enter, and it'll pull up all the abstract methods.


00:27:37.840 --> 00:27:39.120
You can highlight them, say implement.


00:27:39.120 --> 00:27:41.120
and it goes boom and it'll just write the whole class for you.


00:27:41.120 --> 00:27:43.120
But if it's not abstract, obviously it won't do that, right?


00:27:43.120 --> 00:27:48.120
So the abstractness will tell the editor to write the subs of all the functions for you.


00:27:48.120 --> 00:27:50.120
That's a cool reason to use them.


00:27:50.120 --> 00:27:53.120
That's almost reason to have them in the first place.


00:27:53.120 --> 00:27:54.120
Almost.


00:27:54.120 --> 00:27:56.120
We've pickled before, haven't we?


00:27:56.120 --> 00:27:58.120
Yeah, we have talked about pickle a few times.


00:27:58.120 --> 00:28:00.120
Yes, have we talked about this article?


00:28:00.120 --> 00:28:01.120
I don't remember.


00:28:01.120 --> 00:28:02.120
I don't think so.


00:28:02.120 --> 00:28:04.120
We have, apologies.


00:28:04.120 --> 00:28:06.120
But it's short and interesting.


00:28:06.120 --> 00:28:10.560
Batchelder wrote this article called Pickles 9 Flaws.


00:28:10.560 --> 00:28:12.160
And so I want to talk about that.


00:28:12.160 --> 00:28:16.400
This comes to us via PyCoders.com, which is very cool.


00:28:16.400 --> 00:28:19.600
And we've talked about the drawbacks, we've talked about the benefits, but what I liked


00:28:19.600 --> 00:28:23.760
about this article is concise, but it shows you all the trade-offs you're making.


00:28:23.760 --> 00:28:24.760
Right?


00:28:24.760 --> 00:28:27.360
So quickly, I'll just go through the nine.


00:28:27.360 --> 00:28:29.240
One, it's insecure.


00:28:29.240 --> 00:28:33.840
And the reason that it's insecure is not because pickles contain code, but because they create


00:28:33.840 --> 00:28:39.580
these objects by calling the constructors named in the pickle. So any callable can be


00:28:39.580 --> 00:28:45.420
used in place of your class name to construct objects. So basically it runs potentially


00:28:45.420 --> 00:28:49.780
arbitrary code depending on where it got it from. Old pickles look like old code number


00:28:49.780 --> 00:28:55.300
two. So if your code changes between the time you pickled it and whatever, you get the old


00:28:55.300 --> 00:29:01.060
one recreated back to life. So if you added fields or other capabilities, those are not


00:29:01.060 --> 00:29:04.540
going to be there. Or you took away fields, they're still going to be there.


00:29:04.540 --> 00:29:07.980
Yeah, it's implicit. So they will serialize whatever your object


00:29:07.980 --> 00:29:11.940
structure is. And they often over serialize, because they'll serialize


00:29:11.940 --> 00:29:15.460
everything. So like if you have cache data, or pre computed data that you


00:29:15.460 --> 00:29:20.460
wouldn't ever normally save, while that's getting saved. Yeah. One of the


00:29:20.460 --> 00:29:23.740
weird ones that this has caught me out before, and it's just, I don't know,


00:29:23.740 --> 00:29:27.860
it's weird, though, there you go, is the dunder in it, the constructor is not


00:29:27.860 --> 00:29:33.540
called. So your objects are recreated, but the dunder in it is not called. They're just the


00:29:33.540 --> 00:29:40.100
values have the value. So that might set it up in some kind of weird state. Like maybe pass the


00:29:40.100 --> 00:29:44.260
fail some validation or something. It's Python only like you can't share with other programs


00:29:44.260 --> 00:29:50.420
because it's like a Python only structure. They're not readable, they're binary, it will seem like it


00:29:50.420 --> 00:29:56.260
will pickle code. So if you have like a function you're hanging on to you pass it along like


00:29:57.220 --> 00:30:01.220
some kind of lambda function or whatever, or a class that's been passed over,


00:30:01.220 --> 00:30:05.220
and you have a list of them or you're holding on to them, and that you think that it's going to save that,


00:30:05.220 --> 00:30:09.220
all it really saves is basically the name of the function.


00:30:09.220 --> 00:30:13.220
So, those are gone. And I think one of the real big


00:30:13.220 --> 00:30:17.220
challenges is it's actually slower than things like JSON and whatnot.


00:30:17.220 --> 00:30:21.220
If you're willing to give up those tradeoffs because it was super fast, that's one thing,


00:30:21.220 --> 00:30:25.220
but it's not. And are you telling me that we covered it before?


00:30:25.220 --> 00:30:27.220
- I was like 89, but I had forgotten.


00:30:27.220 --> 00:30:29.220
So it was like a couple months ago, right?


00:30:29.220 --> 00:30:30.580
- Yeah, that's a while ago.


00:30:30.580 --> 00:30:32.300
Anyway, it's good to go over it again.


00:30:32.300 --> 00:30:33.140
- Definitely.


00:30:33.140 --> 00:30:34.260
- Be careful with your pickling.


00:30:34.260 --> 00:30:35.940
All right, how about anything extra?


00:30:35.940 --> 00:30:38.100
That was our top six items.


00:30:38.100 --> 00:30:39.100
What else we got?


00:30:39.100 --> 00:30:40.180
- I don't have anything extra.


00:30:40.180 --> 00:30:41.020
Do you have anything extra?


00:30:41.020 --> 00:30:42.060
- Pathlib.


00:30:42.060 --> 00:30:43.460
Speaking of stuff we covered before,


00:30:43.460 --> 00:30:45.100
we talked about Pathlib a couple times.


00:30:45.100 --> 00:30:47.180
You talked about Chris May's article


00:30:47.180 --> 00:30:49.420
or whatever it was around Pathlib, which is cool.


00:30:49.420 --> 00:30:52.220
And I said basically, I'm still,


00:30:52.220 --> 00:30:55.260
I just got to get my mind around not using OS.path


00:30:55.260 --> 00:30:57.220
and just get into this, right?


00:30:57.220 --> 00:30:58.340
And people sent me feedback like,


00:30:58.340 --> 00:31:00.180
Michael, you should get your mind into this.


00:31:00.180 --> 00:31:01.420
Of course you should do this, right?


00:31:01.420 --> 00:31:02.960
And I'm like, yeah, yeah, I know.


00:31:02.960 --> 00:31:06.600
However, Brett Abel sent over a one-line tweet


00:31:06.600 --> 00:31:08.740
that may just seal the deal for me.


00:31:08.740 --> 00:31:09.700
Like, this is sweet.


00:31:09.700 --> 00:31:12.100
So he said, how about this?


00:31:12.100 --> 00:31:15.900
Text equals path of file.readText, done.


00:31:15.900 --> 00:31:18.500
No context managers, no open, none of that.


00:31:18.500 --> 00:31:21.300
And I'm like, oh, that's, okay, that's pretty awesome.


00:31:21.300 --> 00:31:23.740
(laughing)


00:31:23.740 --> 00:31:26.260
Anyway, I just wanted to give a little shout out


00:31:26.260 --> 00:31:28.420
to that one-liner, 'cause that's pretty nice.


00:31:28.420 --> 00:31:31.140
And then also, I was just a guest on a podcast


00:31:31.140 --> 00:31:34.340
out of the UK called A Question of Code,


00:31:34.340 --> 00:31:37.120
where the host, Ed and Tom, and I discussed


00:31:37.120 --> 00:31:39.720
why Python is fun, why is it good for beginners


00:31:39.720 --> 00:31:42.760
and for experts, why it might give you results


00:31:42.760 --> 00:31:46.980
faster than tangible code or tangible programs,


00:31:46.980 --> 00:31:49.860
faster than, say, JavaScript, career stuff,


00:31:49.860 --> 00:31:50.700
all kinds of stuff.


00:31:50.700 --> 00:31:52.220
I linked to that if people want to check that out.


00:31:52.220 --> 00:31:53.060
- That's cool.


00:31:53.060 --> 00:31:53.880
- Yeah, it was a lot of fun.


00:31:53.880 --> 00:31:55.100
Those guys are running a good show over there.


00:31:55.100 --> 00:31:57.540
- Yeah, I think I'm talking with them tomorrow.


00:31:57.540 --> 00:31:59.660
- Right on, how cool.


00:31:59.660 --> 00:32:02.220
- One of the things I like about it is the accents.


00:32:02.220 --> 00:32:04.100
Just, you know, 'cause accents are fun.


00:32:04.100 --> 00:32:05.580
So I was gonna ask you,


00:32:05.580 --> 00:32:07.940
would you consider learning how to do a British accent?


00:32:07.940 --> 00:32:09.300
'Cause that would be great for the show.


00:32:09.300 --> 00:32:10.340
- I would love to.


00:32:10.340 --> 00:32:15.720
I fear I would just end up insulting all the British people


00:32:15.720 --> 00:32:17.960
and not coming across really well.


00:32:17.960 --> 00:32:19.700
But I love British accents.


00:32:19.700 --> 00:32:22.760
If we had enough Patreon supporters,


00:32:22.760 --> 00:32:24.820
I would be more than happy to volunteer


00:32:24.820 --> 00:32:28.900
to move to England to develop an accent.


00:32:28.900 --> 00:32:31.340
- Maybe just live in London for a few years.


00:32:31.340 --> 00:32:33.260
If they're gonna fund that for you, that would be awesome.


00:32:33.260 --> 00:32:34.100
- Yeah, that'd be great.


00:32:34.100 --> 00:32:35.100
- London's a great town.


00:32:35.100 --> 00:32:36.580
(laughing)


00:32:36.580 --> 00:32:37.420
- Okay.


00:32:37.420 --> 00:32:38.300
- All right, how about another joke?


00:32:38.300 --> 00:32:39.140
- I'd love another joke.


00:32:39.140 --> 00:32:43.540
- So this one is by Caitlin Hudon,


00:32:43.540 --> 00:32:45.740
but was pointed out to us by Erin Brown.


00:32:45.740 --> 00:32:47.780
So she tweeted this on Twitter,


00:32:47.780 --> 00:32:49.660
and he's like, "Hey, you guys should think about this."


00:32:49.660 --> 00:32:50.500
So you ready?


00:32:50.500 --> 00:32:51.620
- Yeah. - Caitlin says,


00:32:51.620 --> 00:32:52.780
"I have a Python joke,


00:32:52.780 --> 00:32:55.340
"but I don't think this is the right environment."


00:32:55.340 --> 00:32:56.540
(laughing)


00:32:56.540 --> 00:32:59.260
- Yeah, so there's a ton of these type of jokes.


00:32:59.260 --> 00:33:02.980
Like I have a joke, but, so this is a new thing, right?


00:33:02.980 --> 00:33:04.320
I don't know, it's probably gonna be over


00:33:04.320 --> 00:33:05.620
by the time this airs. - Yeah, probably.


00:33:05.620 --> 00:33:08.780
- But I'm really amused by these types of jokes.


00:33:08.780 --> 00:33:09.700
- Yeah, I love it.


00:33:09.700 --> 00:33:11.860
This kind of touches on the whole virtual environment,


00:33:11.860 --> 00:33:14.580
package management, isolation, chaos.


00:33:14.580 --> 00:33:16.500
I mean, there was that XKCD as well about that.


00:33:16.500 --> 00:33:18.900
- Yeah, okay, so while we're here,


00:33:18.900 --> 00:33:21.140
I'm gonna read some from Luciano.


00:33:21.140 --> 00:33:23.580
Luciano Romalo, he's a Python author,


00:33:23.580 --> 00:33:25.060
and he's an awesome guy.


00:33:25.060 --> 00:33:27.060
Here's a couple other related ones.


00:33:27.060 --> 00:33:29.580
I have a Haskell joke, but it's not popular.


00:33:29.580 --> 00:33:33.220
I have a Scala joke, but nobody understands it.


00:33:33.220 --> 00:33:35.920
I have a Ruby joke, but it's funnier in Elixir.


00:33:35.920 --> 00:33:38.700
And I have a Rust joke, but I can't compile it.


00:33:38.700 --> 00:33:39.980
- Yeah, those are all good, nice.


00:33:39.980 --> 00:33:41.100
- Cool. - Nice, nice.


00:33:41.100 --> 00:33:43.260
All right, well, Brian, thanks for being here, as always.


00:33:43.260 --> 00:33:44.900
- Thank you, talk to you later.


00:33:44.900 --> 00:33:45.720
- Bye.


00:33:45.720 --> 00:33:47.600
Thank you for listening to Python Bytes.


00:33:47.600 --> 00:33:50.080
Follow the show on Twitter via @PythonBytes.


00:33:50.080 --> 00:33:53.040
That's Python Bytes as in B-Y-T-E-S.


00:33:53.040 --> 00:33:56.160
And get the full show notes at PythonBytes.fm.


00:33:56.160 --> 00:33:59.880
If you have a news item you want featured, just visit PythonBytes.fm and send it our


00:33:59.880 --> 00:34:00.880
way.


00:34:00.880 --> 00:34:03.080
We're always on the lookout for sharing something cool.


00:34:03.080 --> 00:34:06.360
On behalf of myself and Brian Auken, this is Michael Kennedy.


00:34:06.360 --> 00:34:09.400
Thank you for listening and sharing this podcast with your friends and colleagues.

