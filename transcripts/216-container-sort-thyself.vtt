
00:00:00.000 --> 00:00:05.860
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode


00:00:05.860 --> 00:00:09.680
216 recorded January 13th


00:00:09.680 --> 00:00:16.060
2021 I'm Michael Kennedy. I'm Brian Akin and Brian. We have a special guest Yusef. Welcome


00:00:16.060 --> 00:00:22.160
Hey, great to have you here. You want to just take a quick moment and tell folks about yourself maybe about your podcast real quick


00:00:22.160 --> 00:00:23.500
Yeah, sure


00:00:23.500 --> 00:00:26.180
Thanks for even being able to participate in this podcast


00:00:26.560 --> 00:00:31.260
So my name is Joseph and I might not be well known as you guys are for sure


00:00:31.260 --> 00:00:34.540
I'm a mechanical engineer from Germany and based in Germany as well


00:00:34.540 --> 00:00:41.020
And I'm working for IT company called SimScale who are providing cloud-based simulation technology on the site


00:00:41.020 --> 00:00:45.120
I'm hosting a podcast called engineered mind and I'm working on a bunch of other stuff


00:00:45.120 --> 00:00:51.800
For example my thesis which will extensively cover. Let's see him this podcast. Yeah. Yeah, I used a couple of cool


00:00:52.360 --> 00:00:55.600
libraries and stuff over there, which we'll feature here.


00:00:55.600 --> 00:00:59.240
All right, well, the very first item, Brian,


00:00:59.240 --> 00:01:03.040
Ron, let's talk about maybe doing,


00:01:03.040 --> 00:01:04.960
what, should I do a pip search a lot?


00:01:04.960 --> 00:01:08.760
- Yeah, well, I kind of forgot pip search was a thing,


00:01:08.760 --> 00:01:10.960
'cause when I'm looking for PyPI stuff,


00:01:10.960 --> 00:01:13.120
I go to pypi.org and just--


00:01:13.120 --> 00:01:15.480
- Yeah, so do I, that's, yeah, exactly.


00:01:15.480 --> 00:01:16.600
It's really fast there.


00:01:16.600 --> 00:01:20.520
- Yeah, but there's a feature called pip.


00:01:20.520 --> 00:01:23.520
you can do a pip search, which the documentation says


00:01:23.520 --> 00:01:26.960
it's supposed to search for PiPI packages


00:01:26.960 --> 00:01:30.640
whose name or summary contains whatever query.


00:01:30.640 --> 00:01:33.960
So I can say pip search, Pytest, for instance,


00:01:33.960 --> 00:01:38.960
and it should show me what if Pytest is a package on PiPI.


00:01:38.960 --> 00:01:41.480
But right now, if you do that,


00:01:41.480 --> 00:01:45.240
it comes back with a big trace back and it says,


00:01:45.240 --> 00:01:50.240
fault, what, minus 32500, runtime error,


00:01:50.320 --> 00:01:58.320
the pipe is XML. Anyway, the API is broken. So this is on purpose. The what happened is


00:01:58.320 --> 00:02:03.440
actually I don't know really what's happened, but there's the it's the services getting


00:02:03.440 --> 00:02:09.480
swamped the the search endpoint is getting it extremely hard. So I saw some message or


00:02:09.480 --> 00:02:14.760
some tweet that was to the effect of is somebody out there running an insane number of searches


00:02:14.760 --> 00:02:19.840
against this endpoint? Please don't. Yeah, I don't know what's going on. But so there's


00:02:19.840 --> 00:02:26.640
some guesses, maybe it's a rogue continuous integration server or something weird's going


00:02:26.640 --> 00:02:34.840
on. But in the meantime, right now, we're going to link to a Python infrastructure status


00:02:34.840 --> 00:02:40.920
page which has an update on this. So if anybody wants to follow, you can check that out. It


00:02:40.920 --> 00:02:48.560
says that the search endpoint remains disabled due to ongoing request volume. And I think


00:02:48.560 --> 00:02:51.680
This really started becoming a problem mid-December,


00:02:51.680 --> 00:02:54.300
and so I'm not sure what happened then.


00:02:54.300 --> 00:03:00.520
And then there's a related issue on GitHub for pip.


00:03:00.520 --> 00:03:03.720
So there's an issue open saying,


00:03:03.720 --> 00:03:05.240
"Remove the pip search command."


00:03:05.240 --> 00:03:07.800
So I think the end result is,


00:03:07.800 --> 00:03:10.240
and even the error message says,


00:03:10.240 --> 00:03:13.240
"The search endpoint will be deprecated in the near future."


00:03:13.240 --> 00:03:17.040
So I think that this way to do pip search


00:03:17.040 --> 00:03:18.960
is just going to go away.


00:03:18.960 --> 00:03:20.080
So, and--


00:03:20.080 --> 00:03:21.320
- That's actually a little surprising


00:03:21.320 --> 00:03:23.160
because usually a lot of these things


00:03:23.160 --> 00:03:24.860
are so backwards compatible.


00:03:24.860 --> 00:03:29.860
- Yeah, and there's quite a discussion on the issue thread,


00:03:29.860 --> 00:03:31.400
but there's the gist of it is,


00:03:31.400 --> 00:03:34.040
is the current architecture is not,


00:03:34.040 --> 00:03:35.840
it was never designed to handle the volume


00:03:35.840 --> 00:03:37.360
it's getting right now.


00:03:37.360 --> 00:03:41.040
So there's a comment at the end of the thread


00:03:41.040 --> 00:03:42.600
that says, if you've got an idea


00:03:42.600 --> 00:03:45.360
for how to do this algorithm better,


00:03:45.360 --> 00:03:49.920
or a way to do it scaled, go ahead and discuss it.


00:03:49.920 --> 00:03:51.840
But there's a link to,


00:03:51.840 --> 00:03:53.280
we're not gonna put that link in the show notes,


00:03:53.280 --> 00:03:57.440
but in the IPI thread or the GitHub thread,


00:03:57.440 --> 00:04:00.360
there's a link to, if you wanna comment on that.


00:04:00.360 --> 00:04:02.680
But basically, we're bringing this up.


00:04:02.680 --> 00:04:05.560
You may have figured out it might be a fluke or whatever,


00:04:05.560 --> 00:04:07.380
but it's really going on.


00:04:07.380 --> 00:04:11.840
And a plea to look at your continuous integration scripts.


00:04:11.840 --> 00:04:14.200
And if you're doing a pip search in there, take those out.


00:04:14.200 --> 00:04:15.360
- It ain't gonna work anyway.


00:04:15.360 --> 00:04:17.560
- It's gotta be some kind of bot,


00:04:17.560 --> 00:04:19.200
some automatic thing like this,


00:04:19.200 --> 00:04:21.440
because it's already given the error message.


00:04:21.440 --> 00:04:25.640
Like people would stop, you know, if it wasn't.


00:04:25.640 --> 00:04:27.560
Maybe somebody's trying, like constantly trying


00:04:27.560 --> 00:04:30.920
to scrape all of the PyPI data out, I don't know.


00:04:30.920 --> 00:04:32.200
- Yeah, why do it with search?


00:04:32.200 --> 00:04:33.320
That's just weird.


00:04:33.320 --> 00:04:34.140
- Yeah, exactly.


00:04:34.140 --> 00:04:35.800
I don't know what's going on here,


00:04:35.800 --> 00:04:37.760
but I guess don't do it.


00:04:37.760 --> 00:04:38.600
- Don't do it.


00:04:38.600 --> 00:04:39.420
(laughing)


00:04:39.420 --> 00:04:41.080
- Doctor, it hurts when I do this, stop doing that.


00:04:41.080 --> 00:04:42.880
So the next one that I wanna talk about


00:04:42.880 --> 00:04:47.240
is QPython, not QTPython or Qt or anything like that,


00:04:47.240 --> 00:04:52.240
but QPython, which is a way to do Python on Android.


00:04:52.240 --> 00:04:55.840
So we've talked about a couple of interesting applications.


00:04:55.840 --> 00:04:58.320
We've talked about Carnets or Carnet.


00:04:58.320 --> 00:05:00.760
I think it's French pronunciation, I've been told.


00:05:00.760 --> 00:05:03.800
And that's a really cool way to do like Jupyter on iPad.


00:05:03.800 --> 00:05:05.920
So local, all of these are local,


00:05:05.920 --> 00:05:08.400
obviously not just running in the browser.


00:05:08.400 --> 00:05:11.240
There's Pythonista, which is really interesting.


00:05:11.240 --> 00:05:13.600
And QPython is also an interesting one


00:05:13.600 --> 00:05:14.880
for a couple reasons,


00:05:14.880 --> 00:05:18.920
'cause you get an SDK and a REPL for your Android device,


00:05:18.920 --> 00:05:20.520
which is pretty interesting.


00:05:20.520 --> 00:05:23.680
But the reason I'm covering it, I think it's interesting.


00:05:23.680 --> 00:05:25.560
Somebody, I think somebody sent this over.


00:05:25.560 --> 00:05:27.080
No, I ran across this myself.


00:05:27.080 --> 00:05:30.640
Anyway, it allows you just to integrate


00:05:30.640 --> 00:05:35.640
with the underlying Android APIs and features for automation.


00:05:35.640 --> 00:05:36.760
Yeah, cool, right?


00:05:36.760 --> 00:05:40.340
So you can do things like check the system,


00:05:40.340 --> 00:05:44.200
you can send out toast notifications,


00:05:44.200 --> 00:05:45.820
you can interact with applications,


00:05:45.820 --> 00:05:47.160
you can mess with the clipboard,


00:05:47.160 --> 00:05:50.580
you can do barcode scanning, speech recognition,


00:05:50.580 --> 00:05:53.540
send emails, like all those kinds of things


00:05:53.540 --> 00:05:56.460
around even screen brightness,


00:05:56.460 --> 00:05:58.340
checking your battery or whatever.


00:05:58.340 --> 00:06:00.760
So if you wanna get access


00:06:00.760 --> 00:06:03.920
and automate your Android things, Python,


00:06:03.920 --> 00:06:06.220
well, here's a cool little app to do it.


00:06:06.220 --> 00:06:08.140
- Okay, wait a second.


00:06:08.140 --> 00:06:10.060
So I'm not an Android user that much.


00:06:10.060 --> 00:06:11.940
I've got like one Android tablet,


00:06:11.940 --> 00:06:13.960
but I didn't know it can make toast.


00:06:13.960 --> 00:06:18.500
- Yeah, well, it really prefers sourdough,


00:06:18.500 --> 00:06:22.360
but it will go even as far as rye if you have to.


00:06:22.360 --> 00:06:23.380
- No, what's toast?


00:06:23.380 --> 00:06:24.220
Do you know what toast is?


00:06:24.220 --> 00:06:26.300
- It's like a pop-up notification, I think.


00:06:26.300 --> 00:06:27.140
- Oh, okay.


00:06:27.140 --> 00:06:29.940
(laughing)


00:06:29.940 --> 00:06:33.300
- Josef, are you an Android person or an iPhone person?


00:06:33.300 --> 00:06:35.460
- I have to confess I'm an iPhone person.


00:06:35.460 --> 00:06:37.740
I used to be completely against iPhone,


00:06:37.740 --> 00:06:41.260
but once you're in the ecosystem, you never get out.


00:06:41.260 --> 00:06:42.220
- It's like the godfather,


00:06:42.220 --> 00:06:44.740
they just keep pulling you back in, man.


00:06:44.740 --> 00:06:48.060
Yeah, I just recently got a new iPhone as well,


00:06:48.060 --> 00:06:49.140
and I'm general about it,


00:06:49.140 --> 00:06:51.620
but because we have our mobile apps,


00:06:51.620 --> 00:06:53.780
the training for the courses,


00:06:53.780 --> 00:06:55.100
I've got an Android tablet,


00:06:55.100 --> 00:06:57.860
and I've got an Android phone and so on.


00:06:57.860 --> 00:07:00.420
Oh, also got a comment here on YouTube.


00:07:00.420 --> 00:07:03.100
So is it an own framework,


00:07:03.100 --> 00:07:05.620
can you use it in Android, Kotlin and Java?


00:07:05.620 --> 00:07:08.980
I believe it's more like an app that you run,


00:07:08.980 --> 00:07:11.620
and then within that you can do little jobs and stuff.


00:07:11.620 --> 00:07:15.820
So way to aesthetic, it's not something you can bring in


00:07:15.820 --> 00:07:18.180
that I'm aware of, 'cause you install it from Google Play,


00:07:18.180 --> 00:07:19.540
for example, to get started and so on.


00:07:19.540 --> 00:07:21.500
But maybe you can plug it in.


00:07:21.500 --> 00:07:23.860
They do talk about having SDK, so possibly,


00:07:23.860 --> 00:07:26.860
but I got the sense that's more for writing code outside


00:07:26.860 --> 00:07:27.740
than getting it on your device.


00:07:27.740 --> 00:07:29.300
But yeah, pretty cool.


00:07:29.300 --> 00:07:30.820
So if you're into Android,


00:07:30.820 --> 00:07:33.140
You want to do Python automation on it.


00:07:33.140 --> 00:07:34.140
This is pretty cool.


00:07:34.140 --> 00:07:35.980
It's free, get it on the Android store.


00:07:35.980 --> 00:07:38.380
It apparently has ads, but it's also open source.


00:07:38.380 --> 00:07:39.780
So go with that.


00:07:39.780 --> 00:07:42.300
- Do you know if there's a counterpart for iOS?


00:07:42.300 --> 00:07:44.500
- I don't know about the automation side.


00:07:44.500 --> 00:07:48.700
There's a thing called Carnets, which is really cool.


00:07:48.700 --> 00:07:50.100
Let's see if I can find that.


00:07:50.100 --> 00:07:53.060
Carnets app, I believe that's how you spell it.


00:07:53.060 --> 00:07:55.420
Yes, that's Jupyter on the app store.


00:07:55.420 --> 00:07:58.100
And that thing, I don't really want to open the app store,


00:07:58.100 --> 00:07:59.620
but apparently I have to.


00:07:59.620 --> 00:08:00.620
Well, so much for that.


00:08:00.620 --> 00:08:02.700
But Carnets, it's here.


00:08:02.700 --> 00:08:06.180
Oh, and it's also on Google Play.


00:08:06.180 --> 00:08:07.340
Is that the same thing?


00:08:07.340 --> 00:08:08.660
No, that's a totally different thing.


00:08:08.660 --> 00:08:11.720
But Carnets or Carnet is a very cool app


00:08:11.720 --> 00:08:13.660
that lets you do something similar.


00:08:13.660 --> 00:08:15.100
And there's also Pythonista.


00:08:15.100 --> 00:08:17.060
Those are the two I know for iOS.


00:08:17.060 --> 00:08:19.300
All right, so moving along.


00:08:19.300 --> 00:08:22.740
Yosef, maybe tell us a little bit about your research


00:08:22.740 --> 00:08:24.220
and then some of the,


00:08:24.220 --> 00:08:26.540
one of the libraries you've been working with here.


00:08:26.540 --> 00:08:27.380
- Yeah, sure.


00:08:27.380 --> 00:08:30.180
So Open3D is one of the possibilities to visualize.


00:08:30.180 --> 00:08:31.020
- There you go.


00:08:31.020 --> 00:08:31.840
- 3D point cloud.


00:08:31.840 --> 00:08:32.680
- I had it out of order.


00:08:32.680 --> 00:08:34.380
Yeah, yeah, let's talk about PyTorch first.


00:08:34.380 --> 00:08:35.220
- That's fine.


00:08:35.220 --> 00:08:36.040
That's just fine.


00:08:36.040 --> 00:08:37.420
So PyTorch 3D is basically an option.


00:08:37.420 --> 00:08:39.940
Let's say if you work with meshes,


00:08:39.940 --> 00:08:43.580
let's say a mesh consists of edges and points, for example,


00:08:43.580 --> 00:08:45.480
and these edges connect all the points


00:08:45.480 --> 00:08:47.100
and what you get at the end is a mesh.


00:08:47.100 --> 00:08:51.340
So PyTorch, which is for Facebook, Facebook AI research,


00:08:51.340 --> 00:08:54.140
and they created this framework, so to speak,


00:08:54.140 --> 00:08:57.580
to be able to work efficiently with 3D data.


00:08:57.580 --> 00:08:59.980
So unfortunately I'm using point cloud data,


00:08:59.980 --> 00:09:01.400
But the beautiful thing is that


00:09:01.400 --> 00:09:03.560
if you use PyTorch native application,


00:09:03.560 --> 00:09:06.480
which you produce for your 3D geometry,


00:09:06.480 --> 00:09:09.140
it runs, I wouldn't say significantly,


00:09:09.140 --> 00:09:12.740
but roughly 10 times slower than this PyTorch 3D,


00:09:12.740 --> 00:09:17.420
which is implemented especially for 3D problems.


00:09:17.420 --> 00:09:18.260
- Wow.


00:09:18.260 --> 00:09:20.680
Okay, so what kind of problem do people solve?


00:09:20.680 --> 00:09:23.560
What problem are you solving when you're working with this?


00:09:23.560 --> 00:09:24.520
- Yeah, so in the beginning,


00:09:24.520 --> 00:09:26.700
it was like I was doing some kind of research.


00:09:26.700 --> 00:09:29.500
Unfortunately, they are coming out paper like every day


00:09:29.500 --> 00:09:33.640
And not too many, actually, in the field of deep learning, especially when it comes to


00:09:33.640 --> 00:09:35.680
point cloud or geometric data.


00:09:35.680 --> 00:09:40.600
And the goal, just to inform the audience a bit, is my goal is basically to use deep


00:09:40.600 --> 00:09:45.500
learning and use some kind of or create an assistant system for engineers and designers.


00:09:45.500 --> 00:09:49.840
That means, let's say you're an engineer, and we have this CAD model, so C-A-D, which


00:09:49.840 --> 00:09:51.200
stands for Computer Aided Design.


00:09:51.200 --> 00:09:54.960
So we'd create a model, for example, of a gear, and then you would have that gear.


00:09:54.960 --> 00:09:59.480
But sometimes we have this differentiation between implicit knowledge and explicit knowledge.


00:09:59.480 --> 00:10:03.000
explicit knowledge means this is existing knowledge, which we already know about, let's


00:10:03.000 --> 00:10:06.120
say this knowledge, this knowledge can sit in a database.


00:10:06.120 --> 00:10:08.680
And sometimes we are not making use out of it.


00:10:08.680 --> 00:10:11.260
And then we have this implicit knowledge, let's say an engineer comes into a company


00:10:11.260 --> 00:10:14.480
is completely new, and he brings knowledge with him to the company.


00:10:14.480 --> 00:10:18.560
Now, the problem I want to tackle is because we're having so many data, and we're accumulating


00:10:18.560 --> 00:10:21.680
geometric data in a company, we have to make use of that.


00:10:21.680 --> 00:10:26.120
And my approach is hopefully when I'm at the end of the thesis, which is like in roughly


00:10:26.120 --> 00:10:31.700
two months, is that I have a system or web application as a front end, where the engineer


00:10:31.700 --> 00:10:36.200
or designer picks or starts a design or picks a point cloud or a design.


00:10:36.200 --> 00:10:41.360
And then it would suggest the engineer or designer with a probability of what they want


00:10:41.360 --> 00:10:42.360
to model.


00:10:42.360 --> 00:10:47.120
Let's say he picks a gear, or maybe you want to have like an arrangement of gears, or any


00:10:47.120 --> 00:10:50.320
specific big component, or let's say you take a wheel.


00:10:50.320 --> 00:10:51.320
Okay, for example, what would you...


00:10:51.320 --> 00:10:52.960
Like for a transmission or something?


00:10:52.960 --> 00:10:53.960
Exactly.


00:10:53.960 --> 00:10:54.960
For a transmission.


00:10:54.960 --> 00:10:58.680
pick a wheel and it could be a Tesla or it could be any other car. And then it would


00:10:58.680 --> 00:11:02.260
give you a probability, okay, this wheel is maybe from a Tesla. And then it would give


00:11:02.260 --> 00:11:07.080
suggest you Tesla with a, for example, 89% probability. And then you would click on the


00:11:07.080 --> 00:11:12.360
web application. This is the idea. And then it would pop the geometry into the web browser


00:11:12.360 --> 00:11:13.360
in the front end.


00:11:13.360 --> 00:11:17.920
Oh, that's pretty cool. So it basically it's like image recognition, but instead of for


00:11:17.920 --> 00:11:21.800
pictures, it's image recognition for 3d CAD outlines.


00:11:21.800 --> 00:11:26.280
Exactly. It's so cool that you mentioned it, because there's a big difference between doing


00:11:26.280 --> 00:11:30.320
convolutional neural networks or deep learning for images, because images are 2D. It's like


00:11:30.320 --> 00:11:35.260
a 2D matrix. But if you have a point cloud, then you have a tensor of higher dimensionality.


00:11:35.260 --> 00:11:40.160
And then you are kind of forced to use, for example, NumPy and all these kinds of things.


00:11:40.160 --> 00:11:44.080
And if you're lucky, you could use something like PyTorch, PyTorch 3D, which you can also


00:11:44.080 --> 00:11:46.280
use CUDA on to be way more efficient.


00:11:46.280 --> 00:11:50.480
Yeah, yeah. Wow, that's really cool. So it looks like a neat thing. This is, you know,


00:11:50.480 --> 00:11:53.480
I haven't done any 3D work for a while,


00:11:53.480 --> 00:11:55.480
but yeah, it looks pretty cool.


00:11:55.480 --> 00:11:57.000
I would love to see, I don't know,


00:11:57.000 --> 00:11:58.160
some pictures and stuff.


00:11:58.160 --> 00:11:59.800
It would not be neat, but yeah.


00:11:59.800 --> 00:12:00.640
- They have a very good,


00:12:00.640 --> 00:12:02.400
like if someone is interested in seeing


00:12:02.400 --> 00:12:03.920
what PyTorch 3D can do,


00:12:03.920 --> 00:12:06.040
Facebook AI Research has an own YouTube channel


00:12:06.040 --> 00:12:09.160
and they pitched PyTorch 3D on that channel


00:12:09.160 --> 00:12:10.680
and they really do a nice,


00:12:10.680 --> 00:12:12.000
they show you what you can do with it.


00:12:12.000 --> 00:12:13.280
So it's really interesting.


00:12:13.280 --> 00:12:14.520
- Yeah. Oh, awesome.


00:12:14.520 --> 00:12:16.080
Well, I guess I'd never really thought about


00:12:16.080 --> 00:12:19.920
applying AI, ML stuff to 3D meshes,


00:12:19.920 --> 00:12:21.220
but it makes perfect sense.


00:12:21.220 --> 00:12:23.440
And I can see it's totally different than images.


00:12:23.440 --> 00:12:24.880
- Yeah. - Yeah, very cool.


00:12:24.880 --> 00:12:27.700
Brian, you don't do any CAD stuff with your devices, do you?


00:12:27.700 --> 00:12:29.340
- Well, I mean, yeah, some people do.


00:12:29.340 --> 00:12:30.180
(laughing)


00:12:30.180 --> 00:12:31.180
Not me, though.


00:12:31.180 --> 00:12:32.300
There's a lot of CAD that goes on


00:12:32.300 --> 00:12:34.340
in the ASIC design and stuff.


00:12:34.340 --> 00:12:35.520
- Yeah, I can imagine.


00:12:35.520 --> 00:12:36.600
Yeah, cool.


00:12:36.600 --> 00:12:38.360
All right, now before we get to the next one,


00:12:38.360 --> 00:12:40.380
I wanna get something sorted out, Brian.


00:12:40.380 --> 00:12:41.220
- Okay.


00:12:41.220 --> 00:12:42.380
- I wanna talk about Datadog.


00:12:42.380 --> 00:12:43.740
So they're back to support the show.


00:12:43.740 --> 00:12:44.860
Thank you, Datadog. - Yay!


00:12:44.860 --> 00:12:45.700
- Yay!


00:12:45.700 --> 00:12:49.820
And so they're really about helping you troubleshoot


00:12:49.820 --> 00:12:53.100
latency, CPU, memory bottlenecks in your apps.


00:12:53.100 --> 00:12:54.620
And if you don't know where it's coming from,


00:12:54.620 --> 00:12:57.420
Datadog will seamlessly correlate the logs


00:12:57.420 --> 00:13:00.220
and the traces at the level of individual requests


00:13:00.220 --> 00:13:02.780
cross systems, allowing you to quickly troubleshoot


00:13:02.780 --> 00:13:03.660
your Python app.


00:13:03.660 --> 00:13:06.540
And they have a continuous profiler that allows you to


00:13:06.540 --> 00:13:09.340
find the most resource consuming parts of your app


00:13:09.340 --> 00:13:12.820
in production, just running all the time at any scale.


00:13:12.820 --> 00:13:14.260
And it has very little overhead.


00:13:14.260 --> 00:13:15.100
So that's pretty cool.


00:13:15.100 --> 00:13:17.060
Instead of trying to debug it and then deploy it


00:13:17.060 --> 00:13:19.380
and hope that kind of translates to production,


00:13:19.380 --> 00:13:20.980
just turn it on and watch.


00:13:20.980 --> 00:13:22.420
So yeah, that's cool.


00:13:22.420 --> 00:13:24.980
So be the hero that got that app back on track


00:13:24.980 --> 00:13:27.220
at your company, get started with a free trial


00:13:27.220 --> 00:13:30.820
and support the podcast at pythonbytes.fm/datadog


00:13:30.820 --> 00:13:33.540
or just click the link in your podcast player show notes.


00:13:33.540 --> 00:13:35.780
Now that that's sorted out, Brian.


00:13:35.780 --> 00:13:40.140
- Yeah, yeah, so sorting, sorting's a thing


00:13:40.140 --> 00:13:43.820
and the default Python containers are not sorted


00:13:43.820 --> 00:13:47.660
and there's reasons behind that,


00:13:47.660 --> 00:13:49.580
but sometimes you need to sort stuff.


00:13:49.580 --> 00:13:52.380
So there's a Python library called,


00:13:52.380 --> 00:13:54.660
or a package called sorted containers.


00:13:54.660 --> 00:13:55.780
It's a, I like it.


00:13:55.780 --> 00:13:57.820
It's a very, I mean, I like the name at least.


00:13:57.820 --> 00:14:00.680
It's a very easy to remember sort of thing,


00:14:00.680 --> 00:14:03.060
but it's, this is amazing.


00:14:03.060 --> 00:14:03.980
I looked into this.


00:14:03.980 --> 00:14:08.260
So this was recommended by Fanchin Bao recently


00:14:08.260 --> 00:14:09.520
for us to take a look at.


00:14:09.520 --> 00:14:14.520
And it's a pure Python based sorted collections library.


00:14:14.960 --> 00:14:18.240
And it's as fast as other packages


00:14:18.240 --> 00:14:20.840
that are built using C extensions.


00:14:20.840 --> 00:14:21.680
- Wow.


00:14:21.680 --> 00:14:23.640
- That's the impressive part.


00:14:23.640 --> 00:14:26.920
It's also fairly memory safe,


00:14:26.920 --> 00:14:29.840
but the documentation is pretty cool.


00:14:29.840 --> 00:14:32.600
There's a whole bunch of different benchmarks.


00:14:32.600 --> 00:14:36.640
So you can take a look at how it deals with large things,


00:14:36.640 --> 00:14:38.920
but it's really pretty zippy.


00:14:38.920 --> 00:14:40.640
It was pretty cool.


00:14:40.640 --> 00:14:43.360
Right on the front page, there's an example,


00:14:43.360 --> 00:14:45.520
and we're gonna throw this in the show notes too,


00:14:45.520 --> 00:14:47.440
of just, you've got,


00:14:47.440 --> 00:14:50.520
it handles a handful of different data types.


00:14:50.520 --> 00:14:54.600
It shows sorted list, sorted dictionaries, and sorted set.


00:14:54.600 --> 00:14:57.840
There's also a sorted key list,


00:14:57.840 --> 00:15:00.080
and I had to look that up to figure out what that was.


00:15:00.080 --> 00:15:05.080
So, sorted, the sorted function within Python


00:15:05.080 --> 00:15:06.800
allows you to pass in a key,


00:15:06.800 --> 00:15:10.120
which the key really is a function to use


00:15:10.120 --> 00:15:13.760
to create a key for sorting.


00:15:13.760 --> 00:15:14.600
And--


00:15:14.600 --> 00:15:15.840
- Right, 'cause the things in there


00:15:15.840 --> 00:15:17.840
might not have a natural sort, right?


00:15:17.840 --> 00:15:20.260
Like you put a bunch of order objects in there,


00:15:20.260 --> 00:15:21.280
well, how do you sort those?


00:15:21.280 --> 00:15:22.760
Do you sort them by price?


00:15:22.760 --> 00:15:24.640
Do you sort them by date?


00:15:24.640 --> 00:15:25.620
- Right. - Right, so you select


00:15:25.620 --> 00:15:26.460
out that element, yeah?


00:15:26.460 --> 00:15:27.760
- Yeah, you should have it selected out.


00:15:27.760 --> 00:15:30.400
Or you can do something like,


00:15:30.400 --> 00:15:32.480
they might be sortable by default,


00:15:32.480 --> 00:15:34.600
but you want it to be like a reverse sort


00:15:34.600 --> 00:15:35.760
or something like that.


00:15:35.760 --> 00:15:36.600
- Right. - So,


00:15:36.600 --> 00:15:38.800
and there's some caveats listed


00:15:38.800 --> 00:15:40.560
so that you have to make sure that your,


00:15:40.560 --> 00:15:42.080
the key that you pass in,


00:15:42.080 --> 00:15:45.640
it follows some conventions like two identical items


00:15:45.640 --> 00:15:48.800
should be, should have the same key, stuff like that.


00:15:48.800 --> 00:15:50.180
That's all reasonable things.


00:15:50.180 --> 00:15:55.180
But it's a fairly easy and complete package to just use.


00:15:55.180 --> 00:15:59.600
It looks, it acts just sort of like a normal,


00:15:59.600 --> 00:16:01.960
the normal thing, containers like lists


00:16:01.960 --> 00:16:03.160
and dictionaries and sets.


00:16:03.160 --> 00:16:06.200
It just remains sorted all the time.


00:16:06.200 --> 00:16:07.920
And this is pretty incredible, so.


00:16:07.920 --> 00:16:11.040
- Yeah, I can totally see bugs get into your code


00:16:11.040 --> 00:16:13.080
'cause you're like, well, we put stuff into this list


00:16:13.080 --> 00:16:15.560
and oh, I want the latest one, so it's the last one,


00:16:15.560 --> 00:16:18.480
but maybe you forgot to sort it before you did that


00:16:18.480 --> 00:16:19.920
or the first one's the last


00:16:19.920 --> 00:16:21.600
'cause you reversed it or whatever.


00:16:21.600 --> 00:16:22.960
- So one of the things that confused me


00:16:22.960 --> 00:16:24.480
when I first looked at this,


00:16:24.480 --> 00:16:26.080
I was scratching my head for a second


00:16:26.080 --> 00:16:29.260
'cause it looks like a fairly simple set of examples


00:16:29.260 --> 00:16:32.420
with just like small set of elements in it.


00:16:32.420 --> 00:16:36.000
So like the first one is a list of like A, B,


00:16:36.000 --> 00:16:40.160
E-A-C-D-B, just a few characters.


00:16:40.160 --> 00:16:42.240
And it's a whole bunch of these examples


00:16:42.240 --> 00:16:43.520
with just a little small amounts.


00:16:43.520 --> 00:16:46.560
And it says, underneath it says,


00:16:46.560 --> 00:16:50.640
all of the demo listed above takes a gigabyte of memory.


00:16:50.640 --> 00:16:52.600
And I'm like, what the heck?


00:16:52.600 --> 00:16:54.520
Why is it taking so much memory?


00:16:54.520 --> 00:16:55.360
(laughing)


00:16:55.360 --> 00:16:57.240
- It's only five things, come on.


00:16:57.240 --> 00:16:58.800
- Yeah, I mean, like why?


00:16:58.800 --> 00:16:59.760
- It's cheap, don't worry about it.


00:16:59.760 --> 00:17:01.320
- But there's, hidden in there,


00:17:01.320 --> 00:17:05.720
there's an example of that five character list


00:17:05.720 --> 00:17:11.320
sorted list that gets multiplied by 10 million.


00:17:11.320 --> 00:17:14.880
So it's a 10, like a 50 million element.


00:17:14.880 --> 00:17:17.680
>> 50 million characters in a list that got sorted, right?


00:17:17.680 --> 00:17:22.400
>> Yeah. So and then all the operations like count.


00:17:22.400 --> 00:17:24.920
So you can say, count all the C's in there,


00:17:24.920 --> 00:17:26.560
it'll tell you how many there are.


00:17:26.560 --> 00:17:29.800
Although a lot of these operations like counting stuff with


00:17:29.800 --> 00:17:33.420
a sorted set take less than linear time.


00:17:33.420 --> 00:17:37.020
So yeah, so there's times you need sort


00:17:37.020 --> 00:17:39.020
and this is a cool one to check out.


00:17:39.020 --> 00:17:39.860
- Yeah, it's cool.


00:17:39.860 --> 00:17:41.660
It's nice that it's pure Python,


00:17:41.660 --> 00:17:43.180
super easy to install, right?


00:17:43.180 --> 00:17:45.500
And it's not gonna have any like weirdness around that.


00:17:45.500 --> 00:17:47.740
Like if you say got an M1 computer


00:17:47.740 --> 00:17:49.720
and thing won't compile or whatever.


00:17:49.720 --> 00:17:51.820
No, this looks really cool.


00:17:51.820 --> 00:17:52.860
Yousef, what do you think?


00:17:52.860 --> 00:17:54.380
- Yeah, this looks amazing.


00:17:54.380 --> 00:17:57.740
I'm also, I'm in touch with my brother on the side


00:17:57.740 --> 00:18:00.100
and he's also watching our podcast at the moment.


00:18:00.100 --> 00:18:02.220
And he's also saying because of the one gigabyte memory


00:18:02.220 --> 00:18:04.800
for sorting is incredible, it's crazy.


00:18:04.800 --> 00:18:07.420
- Yeah, that's pretty awesome.


00:18:07.420 --> 00:18:09.580
I guess it's just showing like you can have a ton


00:18:09.580 --> 00:18:10.660
and it's all nice.


00:18:10.660 --> 00:18:12.580
So it's, I mean, it seems really straightforward,


00:18:12.580 --> 00:18:14.180
but having these things sorted,


00:18:14.180 --> 00:18:17.360
we just got dictionaries that would stay put.


00:18:17.360 --> 00:18:20.020
So having sorted dictionaries is also cool.


00:18:20.020 --> 00:18:21.100
(laughing)


00:18:21.100 --> 00:18:22.020
- Yeah.


00:18:22.020 --> 00:18:24.580
- Right, it used to be that they sort of,


00:18:24.580 --> 00:18:25.820
if they had the same keys and stuff,


00:18:25.820 --> 00:18:27.940
or they wouldn't necessarily retain their order


00:18:27.940 --> 00:18:29.900
of the things you added, but now they do.


00:18:29.900 --> 00:18:31.860
- Right, so if people are confused and think,


00:18:31.860 --> 00:18:33.580
- Well, aren't dictionaries already sorted?


00:18:33.580 --> 00:18:37.620
No, they just stay in the order that they were created.


00:18:37.620 --> 00:18:38.460
- Exactly.


00:18:38.460 --> 00:18:39.280
- So.


00:18:39.280 --> 00:18:42.780
- Yeah, similar, but not exactly the same thing.


00:18:42.780 --> 00:18:43.620
- Yeah.


00:18:43.620 --> 00:18:45.620
- All right, so I wanna, this next one,


00:18:45.620 --> 00:18:47.820
I wanna riff a little bit on typing


00:18:47.820 --> 00:18:50.700
and I wanna do that around a tweet,


00:18:50.700 --> 00:18:53.540
which I think I've got to put into a different type of,


00:18:53.540 --> 00:18:57.820
hold on, for some reason, Twitter has stopped showing me


00:18:57.820 --> 00:19:00.500
like the entire conversation of things.


00:19:00.500 --> 00:19:02.940
I don't know why, but I guess it doesn't really matter.


00:19:02.940 --> 00:19:07.180
So Lucas Lenga responded to a tweet that went out there.


00:19:07.180 --> 00:19:09.860
You know, Lucas is obviously his core developer.


00:19:09.860 --> 00:19:11.220
He's been doing really important stuff,


00:19:11.220 --> 00:19:14.020
but one of the main focuses that he's been working on


00:19:14.020 --> 00:19:17.660
is around type hints and typing with things like mypy.


00:19:17.660 --> 00:19:20.980
He was instrumental in bringing typing to Facebook


00:19:20.980 --> 00:19:23.820
and the Instagram code bases and things like that.


00:19:23.820 --> 00:19:25.420
So there's a tweet that says,


00:19:25.420 --> 00:19:28.660
"Controversial take, types in a Python code base


00:19:28.660 --> 00:19:30.420
are a net negative.


00:19:30.420 --> 00:19:31.760
That's not Lucas.


00:19:31.760 --> 00:19:33.820
This is his, he's about to have a whole long conversation


00:19:33.820 --> 00:19:35.620
about this that I'm gonna talk about.


00:19:35.620 --> 00:19:38.220
But Brian, what do you think?


00:19:38.220 --> 00:19:39.060
You retweeted this.


00:19:39.060 --> 00:19:41.300
- Them's fighting words.


00:19:41.300 --> 00:19:42.660
- Them's is fighting words.


00:19:42.660 --> 00:19:46.220
Yeah, so what do you think?


00:19:46.220 --> 00:19:48.620
- I think that they're good.


00:19:48.620 --> 00:19:49.900
- Yeah, I do too.


00:19:49.900 --> 00:19:52.700
I think when I first saw them, I was a little concerned.


00:19:52.700 --> 00:19:55.660
Like, oh my goodness, this is going to potentially,


00:19:55.660 --> 00:19:59.180
you know, turn Python into something like TypeScript.


00:19:59.180 --> 00:20:02.380
And while I appreciate what TypeScript does


00:20:02.380 --> 00:20:04.020
to make JavaScript much better,


00:20:04.020 --> 00:20:06.620
I almost always walk away from working with TypeScript


00:20:06.620 --> 00:20:08.700
with a feeling of like, ah, that kind of hurt


00:20:08.700 --> 00:20:10.580
and was painful, I wonder why it had to go that way,


00:20:10.580 --> 00:20:13.700
you know, because the TypeScript requires,


00:20:13.700 --> 00:20:16.100
it's like, it's like C# or C++,


00:20:16.100 --> 00:20:18.500
the types have to match and they have to be there.


00:20:18.500 --> 00:20:20.100
And if they don't match at all,


00:20:20.100 --> 00:20:21.980
then it just won't work, right?


00:20:21.980 --> 00:20:22.900
It's super frustrating.


00:20:22.900 --> 00:20:24.700
I know this thing is not defined and you know,


00:20:24.700 --> 00:20:27.020
'cause there's libraries that might not have types


00:20:27.020 --> 00:20:28.100
and then how do you work with them?


00:20:28.100 --> 00:20:29.500
It's just, if I find it,


00:20:29.500 --> 00:20:30.860
there's always some little edge case


00:20:30.860 --> 00:20:32.300
that's like, oh, this is frustrating.


00:20:32.300 --> 00:20:34.060
But I never feel that way with Python


00:20:34.060 --> 00:20:37.000
and I really have come to love Python's type hints.


00:20:37.000 --> 00:20:40.980
And obviously, Lucas starts out his conversation


00:20:40.980 --> 00:20:42.540
saying this is easily disproven.


00:20:42.540 --> 00:20:44.740
If you ever use PyCharm or VS Code,


00:20:44.740 --> 00:20:48.580
the code completion in there is based on type annotations.


00:20:48.580 --> 00:20:51.440
If you've ever seen your editor highlight a function


00:20:51.440 --> 00:20:53.900
and squiggly say this expects something else


00:20:53.900 --> 00:20:55.380
then what you're giving it,


00:20:55.380 --> 00:20:56.660
besides the number of variables,


00:20:56.660 --> 00:20:58.860
but like you're giving it a string


00:20:58.860 --> 00:21:00.860
and it wants a number or something like that,


00:21:00.860 --> 00:21:02.880
you're using type annotations


00:21:02.880 --> 00:21:05.540
and you can enhance your code by doing that, right?


00:21:05.540 --> 00:21:08.260
So I was actually talking to Yusuf about this yesterday.


00:21:08.260 --> 00:21:11.240
My philosophy, or maybe my rule of thumb is


00:21:11.240 --> 00:21:12.520
you don't have to always do it this way,


00:21:12.520 --> 00:21:14.860
but if you're working in your editor


00:21:14.860 --> 00:21:18.660
and you have to type more than say three characters


00:21:18.660 --> 00:21:20.660
to get some kind of symbol to come up,


00:21:20.660 --> 00:21:21.680
you're probably doing it wrong.


00:21:21.680 --> 00:21:23.540
So like if you have email service


00:21:23.540 --> 00:21:27.500
and you wanna have email service send account email,


00:21:27.500 --> 00:21:30.260
you should be able to say .sae,


00:21:30.260 --> 00:21:31.980
S-A-E, right, send account email.


00:21:31.980 --> 00:21:34.520
And it should know the type that's been returned,


00:21:34.520 --> 00:21:37.820
what an email service is, that it has this property,


00:21:37.820 --> 00:21:39.420
and just write it for you, right?


00:21:39.420 --> 00:21:41.620
So to me, a lot of the typing stuff,


00:21:41.620 --> 00:21:43.540
I know, I mean, this comment is somewhat about bugs,


00:21:43.540 --> 00:21:45.860
like I never found a good bug because of this.


00:21:45.860 --> 00:21:48.460
To me, that's almost like a side benefit.


00:21:48.460 --> 00:21:50.500
It's about quickly generating code


00:21:50.500 --> 00:21:53.220
without stopping to go look at the code definition,


00:21:53.220 --> 00:21:55.260
without going over to the documentation


00:21:55.260 --> 00:21:57.600
to see what I could have typed over here.


00:21:57.600 --> 00:22:00.360
You know, it's, for example, AWS people,


00:22:00.360 --> 00:22:03.560
this is insanely frustrating to work with AWS


00:22:03.560 --> 00:22:05.400
because you get these like weird,


00:22:05.400 --> 00:22:07.120
create this service and you give it a name


00:22:07.120 --> 00:22:08.600
and then you get an S3 service back,


00:22:08.600 --> 00:22:11.240
but it has no idea that it's an S3 service.


00:22:11.240 --> 00:22:14.460
So you get zero help on what anything,


00:22:14.460 --> 00:22:16.520
even I think go to definition doesn't quite work


00:22:16.520 --> 00:22:18.880
because it's, you know, use some factory method


00:22:18.880 --> 00:22:21.000
to reach down some weird place and get the thing.


00:22:21.000 --> 00:22:24.920
So I think really driving the code generation experience


00:22:24.920 --> 00:22:26.680
without being in documentation,


00:22:26.680 --> 00:22:29.120
without jumping around and reading all the source,


00:22:29.120 --> 00:22:30.160
just go for it.


00:22:30.160 --> 00:22:31.360
I think it's super nice.


00:22:31.360 --> 00:22:34.880
So to me, that is the biggest win of all of this stuff.


00:22:34.880 --> 00:22:36.200
So let me give you--


00:22:36.200 --> 00:22:37.880
- The entire thread is very interesting.


00:22:37.880 --> 00:22:39.120
So-- - Yeah, yeah.


00:22:39.120 --> 00:22:41.080
So let me touch on a couple of the points of the thread


00:22:41.080 --> 00:22:43.680
'cause I can't get it to come up in the screen share,


00:22:43.680 --> 00:22:44.520
but that's fine.


00:22:44.520 --> 00:22:45.840
I took notes, luckily.


00:22:45.840 --> 00:22:48.080
So some of the things he pointed out,


00:22:48.080 --> 00:22:50.120
he's like, here's tweet one of 10.


00:22:50.120 --> 00:22:53.080
So number one, put enough annotations,


00:22:53.080 --> 00:22:55.240
and then the tooling will connect the dots


00:22:55.240 --> 00:22:56.920
and make plenty of errors evident,


00:22:56.920 --> 00:23:00.240
as well as like heighten this code generation,


00:23:00.240 --> 00:23:01.560
auto magic, right?


00:23:01.560 --> 00:23:02.520
That's one.


00:23:02.520 --> 00:23:04.780
The most common types of errors though,


00:23:04.780 --> 00:23:07.760
that'll creep in is if none is being used


00:23:07.760 --> 00:23:09.960
where you expect a concrete type.


00:23:09.960 --> 00:23:11.560
And things like mypy will say,


00:23:11.560 --> 00:23:14.720
you're using a type that is an optional of something,


00:23:14.720 --> 00:23:16.320
but you're not checking to see if it's none


00:23:16.320 --> 00:23:17.840
before you dereference it.


00:23:17.840 --> 00:23:19.560
You're probably gonna end up at some point


00:23:19.560 --> 00:23:23.600
with an attribute, none type does not contain attribute,


00:23:23.600 --> 00:23:26.760
whatever you tried to do, you know, upper or whatever, right?


00:23:26.760 --> 00:23:29.360
- None is not scriptable or something.


00:23:29.360 --> 00:23:32.120
- Yes, yeah, something like that, right?


00:23:32.120 --> 00:23:34.520
Or callable or any of the things.


00:23:34.520 --> 00:23:38.500
Also, another common bug is the return case.


00:23:38.500 --> 00:23:40.120
So if you've got a function,


00:23:40.120 --> 00:23:42.800
you can, you know, maybe check something


00:23:42.800 --> 00:23:45.400
and return one value, check something else,


00:23:45.400 --> 00:23:46.280
return another value.


00:23:46.280 --> 00:23:48.860
But if you forget at the end and you fall through


00:23:48.860 --> 00:23:51.660
and you don't put up some kind of concrete return type,


00:23:51.660 --> 00:23:53.320
Python functions just return none.


00:23:53.320 --> 00:23:56.080
Like this actually blew me away when I learned Python


00:23:56.080 --> 00:23:57.580
and I learned about functions


00:23:57.580 --> 00:23:59.920
that they always, always, always return something.


00:23:59.920 --> 00:24:02.380
There's no such thing as a void function in Python.


00:24:02.380 --> 00:24:03.220
- Yeah.


00:24:03.220 --> 00:24:05.500
- As a C++ person, that probably surprised you too, right?


00:24:05.500 --> 00:24:07.140
Like with your C++ background.


00:24:07.140 --> 00:24:09.520
- I did a bunch of other Perl and stuff like that.


00:24:09.520 --> 00:24:11.100
So it wasn't too bad. - Oh, okay.


00:24:11.100 --> 00:24:14.220
- But the return type is actually


00:24:14.220 --> 00:24:16.380
one of the greatest documentation features as well,


00:24:16.380 --> 00:24:19.900
because sometimes you can kind of figure out


00:24:19.900 --> 00:24:21.980
what the parameters are going to look like.


00:24:21.980 --> 00:24:23.820
Think, you know, you can guess.


00:24:23.820 --> 00:24:25.420
But what's the return type?


00:24:25.420 --> 00:24:26.460
Is it going to be a list?


00:24:26.460 --> 00:24:27.420
Is it going to be a tuple?


00:24:27.420 --> 00:24:28.940
Is it going to be a single element?


00:24:28.940 --> 00:24:30.380
What if there's more than one element?


00:24:30.380 --> 00:24:35.580
Having type hints around the return types is a great feature.


00:24:35.580 --> 00:24:36.940
Yeah, absolutely.


00:24:36.940 --> 00:24:38.300
All right, let me touch on a couple more.


00:24:38.300 --> 00:24:41.180
And I see some listener comments in the stream as well.


00:24:41.180 --> 00:24:43.740
Squiggly lines in your editor, anyone?


00:24:43.740 --> 00:24:45.180
Like I just got this the other day.


00:24:45.180 --> 00:24:48.460
I thought I was supposed to pass an object ID,


00:24:48.460 --> 00:24:51.180
the primary key in Mongo, but we'd overridden it,


00:24:51.180 --> 00:24:52.180
and it's actually a string,


00:24:52.180 --> 00:24:54.260
and it said you're passing object ID


00:24:54.260 --> 00:24:55.100
when you expect a string.


00:24:55.100 --> 00:24:56.500
I'm like, oh, yeah, I guess I am.


00:24:56.500 --> 00:24:58.260
All right, well, change that.


00:24:58.260 --> 00:24:59.340
Right, that's really nice,


00:24:59.340 --> 00:25:01.540
instead of that being a runtime error.


00:25:01.540 --> 00:25:05.420
And he talks about the work with TypeScript


00:25:05.420 --> 00:25:07.980
and Anders Halsberg and what he did to help build that.


00:25:07.980 --> 00:25:09.840
And TypeScript, like I said, is pretty neat.


00:25:09.840 --> 00:25:11.260
But he also points out that, you know,


00:25:11.260 --> 00:25:12.540
the same company, Microsoft,


00:25:12.540 --> 00:25:15.780
is developing powerful type checking and code completion


00:25:15.780 --> 00:25:17.820
for Python with VS Code.


00:25:17.820 --> 00:25:21.340
And they have one of the Python steering council folks


00:25:21.340 --> 00:25:23.600
working on there, hint, maybe that's Brett.


00:25:23.600 --> 00:25:27.140
And also possibly the Python creator himself, Guido.


00:25:27.140 --> 00:25:29.020
So do you think those two people


00:25:29.020 --> 00:25:30.020
would be working on something


00:25:30.020 --> 00:25:32.540
that just provides the illusion of productivity?


00:25:32.540 --> 00:25:33.640
Probably not.


00:25:33.640 --> 00:25:36.580
So let's see, a couple comments.


00:25:36.580 --> 00:25:38.500
Chris May, hey Chris, happy to see you out there.


00:25:38.500 --> 00:25:41.180
He says, "Code completion is such a confidence builder too."


00:25:41.180 --> 00:25:43.180
I think it's so awesome because for me,


00:25:43.180 --> 00:25:44.740
it's both amazing for beginners


00:25:44.740 --> 00:25:46.900
'cause they can type dot and go, "Now what?"


00:25:46.900 --> 00:25:50.460
And for experts, they can just blast out code so quickly


00:25:50.460 --> 00:25:52.220
because you just type dot a few things


00:25:52.220 --> 00:25:53.940
and you know, like you said, with confidence,


00:25:53.940 --> 00:25:54.940
you just keep going.


00:25:54.940 --> 00:25:59.540
- Oh, sorry, a lot of these features,


00:25:59.540 --> 00:26:02.100
you get them if everybody around you


00:26:02.100 --> 00:26:05.380
writing the code that you're using is using type ints.


00:26:05.380 --> 00:26:08.340
You don't necessarily need to use type ints yourself,


00:26:08.340 --> 00:26:10.700
but then you're being a bad citizen


00:26:10.700 --> 00:26:13.500
and not helping the people out that you're sharing code with.


00:26:13.500 --> 00:26:15.000
So if you don't share code at all,


00:26:15.000 --> 00:26:17.020
and you're only working on projects with yourself,


00:26:17.020 --> 00:26:19.420
then, you know, go ahead, don't use type-ins.


00:26:19.420 --> 00:26:20.440
- It's up to you, right?


00:26:20.440 --> 00:26:21.340
Yeah, absolutely.


00:26:21.340 --> 00:26:23.100
Yousef, what do you think?


00:26:23.100 --> 00:26:25.860
Do you guys use type-ins on your project?


00:26:25.860 --> 00:26:26.700
- No, not really.


00:26:26.700 --> 00:26:29.400
Like, it's not something that's in our conscious mind,


00:26:29.400 --> 00:26:30.240
I would say.


00:26:30.240 --> 00:26:31.860
I'm not sure if it's also something related


00:26:31.860 --> 00:26:33.140
because you're an engineer.


00:26:33.140 --> 00:26:34.740
I wouldn't want to generalize,


00:26:34.740 --> 00:26:37.480
but engineers are usually bothered with the problem itself


00:26:37.480 --> 00:26:40.620
rather than digging down on types, for example.


00:26:40.620 --> 00:26:42.860
It depends also on what language we use.


00:26:42.860 --> 00:26:45.700
- Yeah, it's a bit of a computer science-y topic,


00:26:45.700 --> 00:26:48.220
I can see, but yeah, like I said,


00:26:48.220 --> 00:26:52.400
I love how it generates the content so much easier.


00:26:52.400 --> 00:26:56.620
Magnuson also commented, "I love, for example, Pydantic,


00:26:56.620 --> 00:26:58.980
"but I agree with Romalo," Luciano Romalo,


00:26:58.980 --> 00:26:59.820
who was in this thread,


00:26:59.820 --> 00:27:02.000
"Hopefully it won't be required in Python


00:27:02.000 --> 00:27:03.880
"to help people get started."


00:27:03.880 --> 00:27:06.020
Yeah, so I think the typing stuff is really interesting.


00:27:06.020 --> 00:27:07.620
Like Pydantic, we've talked about a bunch.


00:27:07.620 --> 00:27:09.260
It's a super interesting example


00:27:09.260 --> 00:27:11.980
of really using typing to generate


00:27:11.980 --> 00:27:14.940
cool data ingestion and processing.


00:27:14.940 --> 00:27:16.940
Like if you say I've got a Pydantic model


00:27:16.940 --> 00:27:18.940
and one of its fields is a list of integers


00:27:18.940 --> 00:27:20.940
but you give it a list and the things


00:27:20.940 --> 00:27:22.940
in the list happen to be strings that could be


00:27:22.940 --> 00:27:24.940
integers, it'll automatically convert it.


00:27:24.940 --> 00:27:26.940
Stuff like that is really fantastic.


00:27:26.940 --> 00:27:28.940
I think that's always going to be an add-on


00:27:28.940 --> 00:27:29.820
type of thing.


00:27:29.820 --> 00:27:31.820
Yeah, even though I'm a fan of


00:27:31.820 --> 00:27:33.820
type ints, I don't use them all the time


00:27:33.820 --> 00:27:35.820
and I would be very opposed


00:27:35.820 --> 00:27:37.340
to having them be required.


00:27:37.340 --> 00:27:39.340
Yes, I would too. I would too.


00:27:39.340 --> 00:27:41.340
I don't think they need to be on the whole code base.


00:27:41.340 --> 00:27:43.840
I mean, it depends if your goal is to say


00:27:43.840 --> 00:27:46.500
I want to use them for mypy or mypyc


00:27:46.500 --> 00:27:48.100
and like completely generate stuff.


00:27:48.100 --> 00:27:50.100
But if your goal really is to


00:27:50.100 --> 00:27:51.500
get a little bit of help with editors,


00:27:51.500 --> 00:27:52.800
just having it on the boundaries.


00:27:52.800 --> 00:27:54.340
Like here's the data access layer.


00:27:54.340 --> 00:27:56.340
The things that come out of there return


00:27:56.340 --> 00:27:58.680
whatever and they take the, like you don't have to do anything else


00:27:58.680 --> 00:28:00.680
and the editors will pick it up and run.


00:28:00.680 --> 00:28:01.580
Yeah.


00:28:01.580 --> 00:28:02.900
Alright, one quick question.


00:28:02.900 --> 00:28:05.180
What is a function return if there's no return?


00:28:05.180 --> 00:28:07.180
It returns none.


00:28:07.180 --> 00:28:09.420
So that's why you don't have to just say whether there's a return type.


00:28:09.420 --> 00:28:10.580
It always returns none.


00:28:10.580 --> 00:28:11.180
All right.


00:28:11.180 --> 00:28:15.180
Next up, I guess we got the one I tried to open with there.


00:28:15.180 --> 00:28:17.740
Uh, Yusef is, open 3d.


00:28:17.740 --> 00:28:18.460
That looks fun.


00:28:18.460 --> 00:28:21.780
Yeah, this is, basically a library which you could use in


00:28:21.780 --> 00:28:24.900
Jupiter, which I tried to use, but somehow they at the moment


00:28:24.900 --> 00:28:26.900
have problems using open 3d.


00:28:26.900 --> 00:28:29.860
So what you can do is you call open 3d in your Jupyter notebook and then


00:28:29.860 --> 00:28:31.700
have it have the point cloud visualized.


00:28:31.700 --> 00:28:34.780
Um, however, there are some ways around it, but open 3d, I think.


00:28:35.020 --> 00:28:39.020
If I would start all over again, I would probably use Open3D to visualize my point cloud,


00:28:39.020 --> 00:28:41.520
which I'm actually working with in my Jupyter notebook.


00:28:41.520 --> 00:28:45.520
I'm not sure if using a Jupyter notebook is also something you would recommend personally,


00:28:45.520 --> 00:28:48.520
maybe Brian and Michael, if you're a fan of Jupyter notebooks.


00:28:48.520 --> 00:28:50.020
I think it depends on the application, right?


00:28:50.020 --> 00:28:56.020
Yeah, I think it depends as well. And to me, it really depends on what I'm trying to do


00:28:56.020 --> 00:28:59.520
and like the kind of code. Am I trying to explore data?


00:28:59.520 --> 00:29:02.020
And does it have a really strong visualization component?


00:29:02.020 --> 00:29:04.320
Or is it like a utility type thing?


00:29:04.320 --> 00:29:08.520
So for example, one of the things that I wrote recently


00:29:08.520 --> 00:29:10.720
that I would never put into a Jupyter notebook,


00:29:10.720 --> 00:29:14.120
but I find really helpful is we've got literally thousands


00:29:14.120 --> 00:29:19.040
of video files, MP4s and whatnot for the online courses.


00:29:19.040 --> 00:29:20.880
And in order to import them,


00:29:20.880 --> 00:29:22.720
one of the things I have to tell the database


00:29:22.720 --> 00:29:26.080
is how long in seconds is each file


00:29:26.080 --> 00:29:27.560
and where does it live and stuff.


00:29:27.560 --> 00:29:29.080
So I've got a little script and I just say,


00:29:29.080 --> 00:29:32.880
go to this directory and generate a little JSON output


00:29:32.880 --> 00:29:36.040
for all of the files and parse them


00:29:36.040 --> 00:29:37.080
and tell me how long they are.


00:29:37.080 --> 00:29:39.040
Like that kind of app doesn't belong there, right?


00:29:39.040 --> 00:29:41.080
It's just, that's a command line type of utility


00:29:41.080 --> 00:29:42.060
type of thing.


00:29:42.060 --> 00:29:44.040
But if I want to visualize something like this,


00:29:44.040 --> 00:29:46.680
I think it may well be really good for it actually.


00:29:46.680 --> 00:29:48.600
So I think it varies.


00:29:48.600 --> 00:29:52.480
- Yeah, there's a lot of application parts of my work


00:29:52.480 --> 00:29:54.840
that I think using a Jupyter Notebook


00:29:54.840 --> 00:29:56.720
actually might be more beneficial.


00:29:56.720 --> 00:30:00.000
So I'm often taking big, huge trace datas


00:30:00.000 --> 00:30:02.720
and stuff for like spectrum traces.


00:30:02.720 --> 00:30:06.840
And those could easily be driven from a Jupyter notebook


00:30:06.840 --> 00:30:09.880
and with the visualization stuff would be good.


00:30:09.880 --> 00:30:10.800
- Yeah, cool.


00:30:10.800 --> 00:30:15.800
So this thing is a set of both C++ and Python libraries


00:30:15.800 --> 00:30:20.800
for basically working with 3D meshes, right?


00:30:20.800 --> 00:30:21.760
- Mostly 3D data.


00:30:21.760 --> 00:30:23.720
For example, if you use a LIDAR,


00:30:23.720 --> 00:30:26.560
so when you work with a laser and this looks, for example,


00:30:26.560 --> 00:30:27.520
great, I never watched the video,


00:30:27.520 --> 00:30:30.960
but if you scan objects in your surroundings,


00:30:30.960 --> 00:30:32.740
Usually what you get is a point cloud


00:30:32.740 --> 00:30:35.160
and which you can then visualize using Open3D.


00:30:35.160 --> 00:30:37.520
And the big disadvantage with point clouds


00:30:37.520 --> 00:30:39.760
is that they're kind of unstructured.


00:30:39.760 --> 00:30:43.160
So you could have one matrix representing one point cloud


00:30:43.160 --> 00:30:46.000
and you could have the same matrix switching two points


00:30:46.000 --> 00:30:47.640
but the matrix would be different.


00:30:47.640 --> 00:30:49.600
This is also a problem that a lot of papers


00:30:49.600 --> 00:30:51.920
try to tackle and make sure that,


00:30:51.920 --> 00:30:53.840
yeah, get around the spot.


00:30:53.840 --> 00:30:56.400
- Nice, you have the example video here


00:30:56.400 --> 00:31:01.200
using Open3D for 3D object detection,


00:31:01.200 --> 00:31:03.080
which is, that's pretty wild.


00:31:03.080 --> 00:31:03.920
Yeah, nice.


00:31:03.920 --> 00:31:05.280
- The things people do these days.


00:31:05.280 --> 00:31:07.440
- I know, I think it's really interesting,


00:31:07.440 --> 00:31:11.160
all this image processing and analysis stuff, yeah.


00:31:11.160 --> 00:31:12.320
- Good question, Brian, by the way.


00:31:12.320 --> 00:31:14.880
This is what I ask myself when I listen to Python Bytes.


00:31:14.880 --> 00:31:16.640
As an engineer, what are you guys doing?


00:31:16.640 --> 00:31:17.480
It's great.


00:31:17.480 --> 00:31:19.600
(laughing)


00:31:19.600 --> 00:31:20.520
- Absolutely.


00:31:20.520 --> 00:31:24.080
Cool, all right, well, that's it for all of our main items.


00:31:24.080 --> 00:31:25.160
Brian, you got anything extra


00:31:25.160 --> 00:31:26.540
that you want to throw out there?


00:31:26.540 --> 00:31:28.740
- Yeah, I just wanted a couple things.


00:31:28.740 --> 00:31:32.420
One, 2021 has been exhausting so far.


00:31:32.420 --> 00:31:33.260
- Yeah.


00:31:33.260 --> 00:31:34.940
- I don't know if anybody else has got the same experience,


00:31:34.940 --> 00:31:36.340
but wow.


00:31:36.340 --> 00:31:38.940
And also, I've got a lot of extra projects,


00:31:38.940 --> 00:31:40.940
side projects that I'm working on right now.


00:31:40.940 --> 00:31:42.060
Python Bytes is one of them,


00:31:42.060 --> 00:31:43.820
but there's other stuff going on as well,


00:31:43.820 --> 00:31:45.020
trying to do more writing.


00:31:45.020 --> 00:31:46.820
And because of that,


00:31:46.820 --> 00:31:51.500
testing code has shifted to an every other week cadence.


00:31:51.500 --> 00:31:53.860
So it's not going away.


00:31:53.860 --> 00:31:57.060
I know a lot of, oddly enough, I've had a lot of feedback


00:31:57.060 --> 00:31:58.660
in the last couple of months of people saying,


00:31:58.660 --> 00:32:01.380
"Thank you for the podcast, I've learned so much."


00:32:01.380 --> 00:32:03.660
So I do not, I don't wanna shut it down.


00:32:03.660 --> 00:32:04.800
I wanna keep it going,


00:32:04.800 --> 00:32:06.300
and there's no plans on shutting it down.


00:32:06.300 --> 00:32:08.820
It's just slowing down so that I have room in my life


00:32:08.820 --> 00:32:10.500
for other projects as well.


00:32:10.500 --> 00:32:12.300
So just wanted to let people know that.


00:32:12.300 --> 00:32:15.260
- Yeah, well, yeah, I try to, for a Talk Python,


00:32:15.260 --> 00:32:16.740
batch it up and do a whole bunch.


00:32:16.740 --> 00:32:18.700
Just to say, "This week, I'm just gonna get nothing done,


00:32:18.700 --> 00:32:20.060
"but I'll do a ton of recording,"


00:32:20.060 --> 00:32:21.620
and then just roll them out.


00:32:21.620 --> 00:32:24.620
I had three months of stuff done in like a week and a half.


00:32:24.620 --> 00:32:26.380
I was, I really needed a break after that,


00:32:26.380 --> 00:32:27.940
but then I was good.


00:32:27.940 --> 00:32:28.780
- Cool.


00:32:28.780 --> 00:32:29.600
- Yeah, cool.


00:32:29.600 --> 00:32:30.440
Well, thanks for the update.


00:32:30.440 --> 00:32:32.460
Yousef, anything you want to share


00:32:32.460 --> 00:32:34.380
on the way out into the show?


00:32:34.380 --> 00:32:36.760
- I just want to say thank you for letting me


00:32:36.760 --> 00:32:40.260
or being able to participate in this quick and brief podcast


00:32:40.260 --> 00:32:41.620
and keep doing what you do guys.


00:32:41.620 --> 00:32:43.620
I follow you both on Twitter and what you share


00:32:43.620 --> 00:32:45.060
and what you do is really amazing.


00:32:45.060 --> 00:32:46.820
So it's really inspiring for an engineer


00:32:46.820 --> 00:32:48.580
who wants to delve into the field of Python


00:32:48.580 --> 00:32:52.140
and all fancy kind of things to listen to your podcast,


00:32:52.140 --> 00:32:54.500
taking your courses or following you on social media.


00:32:54.500 --> 00:32:55.340
It's really great.


00:32:55.340 --> 00:32:56.160
You learn a lot.


00:32:56.160 --> 00:32:59.900
And I actually have to learn more to be honest to myself.


00:32:59.900 --> 00:33:01.140
- Yeah, I have to learn more.


00:33:01.140 --> 00:33:01.980
- Yeah.


00:33:01.980 --> 00:33:03.100
- It never stops.


00:33:03.100 --> 00:33:03.940
It never stops.


00:33:03.940 --> 00:33:04.760
- Yeah, that's right.


00:33:04.760 --> 00:33:05.600
- Yeah, but that's awesome.


00:33:05.600 --> 00:33:06.440
Thank you so much.


00:33:06.440 --> 00:33:07.260
Really appreciate that.


00:33:07.260 --> 00:33:08.100
- How about you, Michael?


00:33:08.100 --> 00:33:11.180
- I have one quick thing driven by yours,


00:33:11.180 --> 00:33:13.100
a comment you had last time.


00:33:13.100 --> 00:33:15.560
So Francisco Silva pointed out,


00:33:15.560 --> 00:33:19.220
we had talked about some of the numpyc,


00:33:19.220 --> 00:33:22.880
Pythonic, the idiomatic numpy stuff that you might do


00:33:22.880 --> 00:33:25.060
and how instead of looping over stuff,


00:33:25.060 --> 00:33:27.620
you can just add, say, two numpy arrays


00:33:27.620 --> 00:33:29.980
and it'll add them or you can dot product them


00:33:29.980 --> 00:33:30.900
and whatnot, right?


00:33:30.900 --> 00:33:32.700
So one of the things you can do,


00:33:32.700 --> 00:33:34.860
I guess we also talked about ones and zeros


00:33:34.860 --> 00:33:37.580
to generate a pre-built list of those.


00:33:37.580 --> 00:33:39.060
So one of the things he talked about


00:33:39.060 --> 00:33:41.620
is the all-close method.


00:33:41.620 --> 00:33:43.500
So if you've got floating point numbers,


00:33:43.500 --> 00:33:45.180
one of the things that's really frustrating


00:33:45.180 --> 00:33:48.860
like, are these equal? Well, does it mean floating point numbers equal, right?


00:33:48.860 --> 00:33:52.940
Like, they could be so nearly the same, but not the same, right?


00:33:52.940 --> 00:33:56.140
They could be within an insane amount of closeness, right?


00:33:56.140 --> 00:33:58.940
Like, 10 decimal places and then a one, right?


00:33:58.940 --> 00:34:01.980
So, all close is like, well, if they're within, you know,


00:34:01.980 --> 00:34:04.940
one one thousandth of each other, consider them the same.


00:34:04.940 --> 00:34:07.260
Well, all close takes a bunch of parameters that you can,


00:34:07.260 --> 00:34:09.420
you can specify the tolerance though.


00:34:09.420 --> 00:34:11.500
So, yeah. Anyway, I thought that was cool.


00:34:11.500 --> 00:34:14.140
Yeah. Hey, while we're on the topic, I may as well throw out,


00:34:14.940 --> 00:34:18.740
I've got it. So I tried to use this method of using NumPy,


00:34:18.740 --> 00:34:22.700
and I ran into a problem. So I'm hoping some data science people can help me


00:34:22.700 --> 00:34:25.620
figure out how to solve it. So my problem is just


00:34:25.620 --> 00:34:27.780
the simple thing if I've got two arrays,


00:34:27.780 --> 00:34:32.460
I want to see if all of the elements are element-wise less than or equal to the other element


00:34:32.460 --> 00:34:35.780
in the other array. Okay, I can do that with NumPy.


00:34:35.780 --> 00:34:38.860
But what I can't, that assumes that all of the


00:34:38.860 --> 00:34:42.100
elements are the same data type, like comparable.


00:34:42.100 --> 00:34:44.900
If there are strings thrown in there,


00:34:44.900 --> 00:34:45.740
It doesn't work.


00:34:45.740 --> 00:34:48.700
So obviously, I don't know if it's obvious,


00:34:48.700 --> 00:34:51.780
but so I had to do some cleanup at a time,


00:34:51.780 --> 00:34:54.660
but I don't know what the most, the best way is.


00:34:54.660 --> 00:34:56.180
Reach out to me if you've got an answer.


00:34:56.180 --> 00:34:57.020
- Awesome.


00:34:57.020 --> 00:34:58.200
Yeah, I don't have an answer, but I'm sure people do.


00:34:58.200 --> 00:35:00.820
And a quick, quick comment here.


00:35:00.820 --> 00:35:02.300
This is the one I wanna show.


00:35:02.300 --> 00:35:06.860
Magnus Carlsen says, "Tip, I found out about Copier,


00:35:06.860 --> 00:35:10.280
"an alternative to cookie cutter that can be run later


00:35:10.280 --> 00:35:13.220
"as well to update the project to a newer template."


00:35:13.220 --> 00:35:14.060
That's pretty cool.


00:35:14.060 --> 00:35:15.060
I hadn't heard of that.


00:35:15.060 --> 00:35:18.780
And also Toml spec has reached 1.0.


00:35:18.780 --> 00:35:21.540
Parser might be added to the standard lib.


00:35:21.540 --> 00:35:22.960
Also haven't covered that, but that's cool news.


00:35:22.960 --> 00:35:24.140
Thanks for sharing you guys.


00:35:24.140 --> 00:35:24.980
- Yeah.


00:35:24.980 --> 00:35:27.340
- And I guess, thanks for being here.


00:35:27.340 --> 00:35:28.460
Yousef, thanks for joining us.


00:35:28.460 --> 00:35:30.300
And Brian, thank you as always, man.


00:35:30.300 --> 00:35:31.120
- Thank you.


00:35:31.120 --> 00:35:31.960
Thank you so much, guys.


00:35:31.960 --> 00:35:32.780
- Bye everyone.

