WEBVTT

00:00:00.001 --> 00:00:04.560
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to earbuds.

00:00:04.560 --> 00:00:10.220
This is episode 147, recorded September 4th, 2019. I'm Michael Kennedy.

00:00:10.220 --> 00:00:11.320
I am Brian Okken.

00:00:11.320 --> 00:00:16.360
And this episode is brought to you by DigitalOcean. Tell you more about some cool stuff they got coming up later.

00:00:16.360 --> 00:00:19.580
Right now, I want to talk about tables.

00:00:19.580 --> 00:00:25.460
Okay. And really quick, what's 147 in hex? No, just I couldn't do that. I don't expect you.

00:00:25.460 --> 00:00:33.060
Anyway, no, but one of the things I do need to do occasionally, I need to do really fast is generate tables.

00:00:33.060 --> 00:00:44.440
And I know it's not something that everybody needs to do, but if I've got a whole bunch of data, like in this case, some dictionaries list, and I want to be able to just print that stuff out.

00:00:44.440 --> 00:00:48.000
They're all the same type of dictionary. They just hold some data. I want to print them out.

00:00:48.000 --> 00:00:54.580
How do I do that quickly? And for test reports or whatever, I found this called rapid tables.

00:00:54.900 --> 00:00:56.400
And it's really kind of awesome.

00:00:56.400 --> 00:00:59.520
Oh, that is so cool. Wow.

00:00:59.520 --> 00:01:07.240
Yeah. So you just basically, you've got a list of dictionaries, and then you want to print them out, and you want it to look like a good ASCII table.

00:01:07.240 --> 00:01:13.380
It shows you how to do it, and it also shows you how to do it with a thing called term color.colored.

00:01:13.380 --> 00:01:19.040
I didn't know this was around. So you can do colored tables if you want. I probably won't do that.

00:01:19.340 --> 00:01:27.620
It also converts stuff to markdown and restructured text. That's kind of neat. I might use that, but right away, I just need the just really easy tables.

00:01:27.620 --> 00:01:32.460
And it says it's super fast in speed, like speed-wise. It goes fast.

00:01:32.840 --> 00:01:41.560
But what I like is that it's not a lot of extra code gunk in your code. You just kind of say, I want this table, and you can print it out easily.

00:01:41.560 --> 00:01:49.920
Yeah, that's super cool, because a lot of times, like this kind of formatting, it's a lot of Z fill and pad these strings and L pad.

00:01:50.000 --> 00:01:57.040
Like just like trying to get the spacing, or you're putting tabs, but every now and then the tab, like the word is too big, and so the tab will shoot it to the next column.

00:01:57.040 --> 00:02:00.760
It's a lot of work, and this is not you doing that work.

00:02:00.760 --> 00:02:07.800
Right. So for all the columns, you have to go through each of the elements to find the longest one to figure out how wide you need to make the column.

00:02:07.800 --> 00:02:12.440
And yeah, there's other libraries to do this, but this one I think is pretty cool.

00:02:12.440 --> 00:02:17.020
Yeah, it's very cool. I also like the markdown and restructured text output option. Yeah, very cool.

00:02:17.240 --> 00:02:24.460
So if you think about what is like one of the most popular packages, what would you say? Take some guesses.

00:02:24.460 --> 00:02:25.120
Requests.

00:02:25.120 --> 00:02:31.720
It's got to be requests. I don't know if it's the most used one, but it's certainly the one that has people's attention and imagination.

00:02:31.720 --> 00:02:39.140
So what would you think if I told you here is a competitor to requests called HTTPX?

00:02:39.140 --> 00:02:40.380
Ooh, I like the X.

00:02:40.380 --> 00:02:42.060
It's extra cool. Absolutely.

00:02:42.500 --> 00:02:49.080
What's really interesting about HTTPX, though, is it's not a from scratch, like throw away the ideas of requests.

00:02:49.080 --> 00:02:52.300
It's compatible with the request API.

00:02:52.300 --> 00:02:54.380
So what you can do with requests, you can do with this.

00:02:54.380 --> 00:02:55.580
So you can kind of drop it in.

00:02:55.580 --> 00:02:58.140
But it has all these other cool features.

00:02:58.140 --> 00:03:03.380
And in fact, it comes from this project called ENCODE, E-N-C-O-D-E, ENCODE.

00:03:03.880 --> 00:03:12.120
And over there, they have a ton of cool things, including Django, REST Framework, Starlet, UVicorn, HTTPX, and also some other async stuff.

00:03:12.120 --> 00:03:21.800
And a lot of the things happening around here, UVicorn databases, ORM, HTTPX, is all about adding the asynchronous capabilities to these various things.

00:03:22.220 --> 00:03:26.600
And that's one of the shortcomings of requests is it doesn't support an async option.

00:03:26.600 --> 00:03:35.040
But this HTTPX, it does a bunch of cool things around the async space to kind of let you gradually go up the stack of complexity.

00:03:35.040 --> 00:03:39.620
So you can just be straight synchronous stuff doing what request does.

00:03:39.940 --> 00:03:42.720
It has this concept of parallel requests.

00:03:42.720 --> 00:03:51.260
So you can issue a bunch of requests in parallel, but you don't have to think about actually creating the async event loop and stuff.

00:03:51.260 --> 00:03:52.940
You just say, I want to run these things all in parallel.

00:03:52.940 --> 00:03:57.760
And you could even ask it, say, like, I want to process the responses as they come in.

00:03:57.760 --> 00:04:03.860
So I can say, like, while parallel.haspending responses, the response is parallel.nextresponse.

00:04:03.860 --> 00:04:10.140
So I can kick off, like, 20 requests and just process them as they come back in, like, four lines of code or something.

00:04:10.140 --> 00:04:11.000
Oh, that's so cool.

00:04:11.000 --> 00:04:11.660
I like it.

00:04:11.660 --> 00:04:11.860
Yeah.

00:04:11.860 --> 00:04:18.620
Or if you really want, if you're in something like Starlit, where it has actual async support for the method, you do want that to be async.

00:04:18.620 --> 00:04:26.740
So you can actually flip into, like, an async mode where those happen the same way I described, but also on the asyncio event loop.

00:04:26.740 --> 00:04:28.300
So it's really cool.

00:04:28.300 --> 00:04:29.860
Also, some other neat features.

00:04:29.860 --> 00:04:32.480
So, like I said, a request-compatible API.

00:04:32.480 --> 00:04:36.840
It does HTTP2, which, like, I could do a request for a page.

00:04:36.840 --> 00:04:44.680
And as I pull down, like, say, five CS style sheets and a JavaScript and an image, you can go get those all in one request.

00:04:44.680 --> 00:04:46.820
So it has support for that, which is cool.

00:04:46.820 --> 00:04:51.940
It has a standard synchronous interface, but also async and await if you want it.

00:04:51.940 --> 00:04:54.080
And, Brian, you'll like this one.

00:04:54.080 --> 00:05:00.260
It allows you to make direct requests to WSGI or ASGI, the asynchronous variant of that, apps.

00:05:00.260 --> 00:05:01.920
So imagine I'm creating a Flask app.

00:05:01.920 --> 00:05:02.780
I don't want to test it.

00:05:02.780 --> 00:05:08.620
I can actually, inside of my Flask app, provide HTTPX the app, right?

00:05:08.620 --> 00:05:10.060
The Flask app object.

00:05:10.060 --> 00:05:13.480
And then I can issue requests that don't go through the network layer.

00:05:13.480 --> 00:05:16.680
They just go through this test app instance that I've created.

00:05:16.680 --> 00:05:17.400
Oh, that's cool.

00:05:17.400 --> 00:05:18.020
Isn't that cool?

00:05:18.100 --> 00:05:25.340
So if I want to, like, mock out some behavior or, like, interact with it as if I were externally, I don't have to, like, start a server and talk to it.

00:05:25.340 --> 00:05:31.020
I'd literally just, like, use the same API here but, like, directly skipping all the infrastructure.

00:05:31.020 --> 00:05:32.200
Oh, that sounds fun.

00:05:32.200 --> 00:05:32.980
Yeah.

00:05:32.980 --> 00:05:34.740
In, like, you know, a nerdy kind of fun.

00:05:34.800 --> 00:05:36.520
Yeah, that sounds, like, really fun.

00:05:36.520 --> 00:05:37.400
But, yeah.

00:05:37.400 --> 00:05:41.240
It is also fully type annotated.

00:05:41.240 --> 00:05:43.780
So it's very, like, Python 3 friendly.

00:05:43.780 --> 00:05:45.620
Has 100% test coverage.

00:05:45.620 --> 00:05:48.980
And, yeah, it has support for mocking out things.

00:05:48.980 --> 00:05:50.540
A lot of cool, nice features.

00:05:50.540 --> 00:05:57.360
And the fact it's built, all this is built on top of requests means if you're already using requests, it's, like, you can adopt it pretty easily.

00:05:57.360 --> 00:05:59.440
Because you don't have to change anything.

00:05:59.440 --> 00:06:03.460
But if you want to bring in some of these cool new features, it's just, you know, you start using them.

00:06:03.460 --> 00:06:03.760
Nice.

00:06:03.760 --> 00:06:04.900
Now, one caveat.

00:06:04.900 --> 00:06:07.880
I does say that this is in some form of alpha.

00:06:07.880 --> 00:06:10.160
It's, like, pretty early days for this project.

00:06:10.160 --> 00:06:14.100
But, yeah, it says this project should be considered an alpha release.

00:06:14.100 --> 00:06:17.180
It's substantially API complete, but some areas need to work.

00:06:17.180 --> 00:06:19.220
Well, you know, people start using it.

00:06:19.220 --> 00:06:20.380
People start contributing to it.

00:06:20.380 --> 00:06:21.820
All of a sudden, it becomes not alpha.

00:06:21.820 --> 00:06:23.980
So, anyway, it's out there for people to use.

00:06:24.080 --> 00:06:29.320
This is sort of the same umbrella area as Tom Christie in the Django REST framework area.

00:06:29.320 --> 00:06:30.720
So, I think it's a pretty good place.

00:06:30.720 --> 00:06:30.940
Cool.

00:06:30.940 --> 00:06:31.760
Okay.

00:06:31.760 --> 00:06:32.340
Neat.

00:06:32.340 --> 00:06:35.580
Speaking of stuff under the encode GitHub project.

00:06:35.580 --> 00:06:37.640
So, Starlette is part of that also?

00:06:37.640 --> 00:06:38.100
Yeah, yeah.

00:06:38.100 --> 00:06:38.400
Okay.

00:06:38.400 --> 00:06:41.220
So, interesting that we did not plan this.

00:06:41.220 --> 00:06:41.600
No.

00:06:41.600 --> 00:06:44.980
The universe planned it to line it up for us.

00:06:44.980 --> 00:06:45.560
Oh, my gosh.

00:06:45.560 --> 00:06:47.120
We're wearing the same color shirt also.

00:06:47.120 --> 00:06:48.100
Oh, my gosh.

00:06:48.100 --> 00:06:50.600
It's black.

00:06:50.600 --> 00:06:52.400
So, that's not that weird of a coincidence.

00:06:52.800 --> 00:06:58.480
Anyway, so, the article I wanted to highlight was a quick and dirty mock services with Starlet.

00:06:58.480 --> 00:07:00.900
This is by a friend of the show, Matt Lehman.

00:07:00.900 --> 00:07:01.860
Hey, Matt.

00:07:01.860 --> 00:07:03.280
It's kind of a neat thing.

00:07:03.280 --> 00:07:08.260
So, one of the ideas, I don't know if we've talked about this on the show, but the idea of testing.

00:07:08.260 --> 00:07:19.900
So, if you've got something that you're part of your application or the thing you want to test talks to a third-party service, sometimes you might not actually want to call that third-party service.

00:07:19.900 --> 00:07:23.100
You can mock or stub out the calls to the service.

00:07:23.220 --> 00:07:27.120
Or, one of the ideas is to create a fake service to talk to.

00:07:27.120 --> 00:07:33.500
And so, that's what this article is about is how to create a fake service so that you can use it for testing.

00:07:34.140 --> 00:07:38.060
And Matt writes a really quick one using Starlet.

00:07:38.060 --> 00:07:41.300
And I think you could use other frameworks, too.

00:07:41.300 --> 00:07:42.860
But I like how simple this is.

00:07:42.860 --> 00:07:48.100
One of the needs he had was that he didn't want the service to, like, just come back right away.

00:07:48.100 --> 00:07:52.840
He wanted some delay because there were some of the service calls that were taking up to a minute or longer.

00:07:53.200 --> 00:08:02.400
And he wanted to be able to simulate that within his fake service so that you can test the code under test to make sure it is working correct with a big delay.

00:08:02.400 --> 00:08:06.780
Anyway, like, it was a really easy-to-read write-up, easy way to do that.

00:08:06.780 --> 00:08:10.640
And I know that that's a recommended practice for a lot of instances.

00:08:10.640 --> 00:08:14.340
But there aren't any very many write-ups of how to do it.

00:08:14.340 --> 00:08:15.900
And so, congrats, Matt.

00:08:15.900 --> 00:08:16.360
I like it.

00:08:16.360 --> 00:08:17.740
Yeah, that's really cool.

00:08:17.740 --> 00:08:24.440
When you think of dependencies, you think of, well, my database layer or Stripe API or something.

00:08:24.440 --> 00:08:27.620
But time is one of those dependencies that's really tricky.

00:08:27.620 --> 00:08:32.560
Most of the time, one of the reasons why we try to do a Maka service is to eliminate that time.

00:08:32.560 --> 00:08:38.520
You know, you want to make sure that the flow of the data goes quickly, but you don't want to wait for the service during your test.

00:08:38.520 --> 00:08:45.840
But at the same time, you kind of want to make sure that you're – and in most test cases, maybe that's the right thing.

00:08:45.840 --> 00:08:52.160
But you also want to make sure that your application deals with long latencies if that's the normal situation.

00:08:52.160 --> 00:08:53.280
Yeah, for sure.

00:08:53.280 --> 00:08:58.880
You might want to shrink it from five minutes to five seconds or something so the tests don't run super long.

00:08:58.880 --> 00:08:59.240
But yeah.

00:08:59.240 --> 00:09:04.080
Or even like I want to start something and then see in an hour if it's done.

00:09:04.080 --> 00:09:07.880
You could like, you know, have to fake out like, you know, datetime.now.

00:09:07.880 --> 00:09:12.920
So the next time you ask it, it's like two hours from now, but it's one millisecond, you know?

00:09:12.920 --> 00:09:13.240
Yeah.

00:09:13.240 --> 00:09:21.260
Well, and, you know, make sure your parameterization of that test doesn't make it so that you're running 50 different versions of the hour-long wait.

00:09:21.260 --> 00:09:23.140
Yeah, for sure.

00:09:23.140 --> 00:09:24.400
All right.

00:09:24.400 --> 00:09:28.320
Now, before we get to the next item, let me tell you about some new services from DigitalOcean.

00:09:28.320 --> 00:09:33.580
So they've traditionally had recently added Postgres as a service.

00:09:33.580 --> 00:09:35.640
So now hosted database, which is really cool.

00:09:35.640 --> 00:09:37.420
But maybe you don't use Postgres.

00:09:37.420 --> 00:09:38.840
Maybe you want to use Redis.

00:09:38.840 --> 00:09:40.660
We just talked about queuing and stuff.

00:09:41.260 --> 00:09:45.240
So Redis is now a service that you can get over at DigitalOcean.

00:09:45.240 --> 00:09:46.360
Redis as a service.

00:09:46.360 --> 00:09:48.640
And also MySQL as a service.

00:09:48.640 --> 00:09:53.080
So check that out over at pythonbytes.fm/DigitalOcean.

00:09:53.080 --> 00:09:54.480
Get $50 credit for a new user.

00:09:54.480 --> 00:09:57.400
They've got all sorts of good stuff coming your way.

00:09:57.400 --> 00:10:02.060
And, of course, all of our infrastructure runs on it as well, which is fun and very good.

00:10:02.060 --> 00:10:02.980
All right.

00:10:03.060 --> 00:10:08.840
The next thing I want to talk about is that other larger cloud provider.

00:10:08.840 --> 00:10:09.940
Have you heard of something?

00:10:09.940 --> 00:10:11.860
Some people started using this, Brian.

00:10:11.860 --> 00:10:12.720
It's called AWS.

00:10:12.720 --> 00:10:13.640
Have you heard of this?

00:10:13.640 --> 00:10:14.320
I think so, yeah.

00:10:14.320 --> 00:10:14.680
Yeah.

00:10:14.780 --> 00:10:18.140
I think like a quarter of the internet at least runs on it.

00:10:18.140 --> 00:10:30.300
So the Python API, the Python package that used to talk to things like S3 and EC2 and AMI and all the stuff over at AWS is called Bodo.

00:10:30.300 --> 00:10:31.180
Yeah.

00:10:31.340 --> 00:10:35.860
So there's a project brought to our attention by Giuseppe Consolo.

00:10:35.860 --> 00:10:37.120
Thank you for that, Giuseppe.

00:10:37.120 --> 00:10:41.800
Called Mocking Out AWS APIs with Modo.

00:10:41.800 --> 00:10:44.720
So if you're going to mock out Bodo, what would you call it?

00:10:44.720 --> 00:10:45.580
Modo.

00:10:45.580 --> 00:10:46.940
Oh, nice.

00:10:46.940 --> 00:10:48.780
Now, it lets you do all sorts of stuff.

00:10:48.780 --> 00:10:54.280
Like if you, say, want to mock out an S3 bucket, right?

00:10:54.280 --> 00:10:55.900
So S3 is like file blob storage.

00:10:55.900 --> 00:11:00.460
You can mock it out and then like save a file to it and then see if it's there.

00:11:00.600 --> 00:11:02.520
Preload it with data and then interact with it.

00:11:02.520 --> 00:11:04.480
And it's got all sorts of interesting stuff.

00:11:04.480 --> 00:11:13.700
But if you start to dig through this library, it turns out it's got both some really interesting ways to test stuff and it's also super comprehensive.

00:11:13.700 --> 00:11:20.800
So, for example, if I want to test working with S3, I can say from Modo import mock S3.

00:11:20.800 --> 00:11:25.240
And then I just put an at mock S3 on my method, on my test method.

00:11:25.240 --> 00:11:30.320
And now all of my true S3 calls with Bodo actually don't go to Bodo.

00:11:30.500 --> 00:11:32.700
They go to this Modo mock version.

00:11:32.700 --> 00:11:33.400
Oh, that's neat.

00:11:33.400 --> 00:11:33.660
Yeah.

00:11:33.660 --> 00:11:45.620
But apparently it doesn't really end there because if I wanted to work with like EC2, I could import mock EC2 and put that on there and say Bodo dot working with, you know, do all the Bodo client EC2, whatever.

00:11:45.620 --> 00:11:48.020
It's like, I don't know why Bodo is so terribly complicated.

00:11:48.020 --> 00:11:49.920
It's like super overloaded.

00:11:49.960 --> 00:11:52.040
But anyway, that's a different time for a different story.

00:11:52.040 --> 00:11:57.740
You can go and like ask for your reserved instances and it'll use your mocked out ones and things like that.

00:11:57.960 --> 00:12:12.880
So, just like if you were to go flip through all the stuff that it supports, ACM, API gateway, auto scaling, cloud formation, cloud watch, cloud watch events, cognito identity, data pipeline, DynamoDB, et cetera, et cetera.

00:12:12.880 --> 00:12:14.100
And we're only into the Ds, right?

00:12:14.140 --> 00:12:19.000
It just goes on and on and on of all the different AWS things that it mocks out.

00:12:19.000 --> 00:12:21.800
So, if you got to test AWS, this is pretty killer.

00:12:21.800 --> 00:12:26.420
Like you can mock out Glacier, IoT, Kinesis, whatever, you name it.

00:12:26.420 --> 00:12:33.500
One of the notes you added was that it can run as a standalone server mode so that you can even test non-Python code.

00:12:33.500 --> 00:12:34.120
That's right.

00:12:34.120 --> 00:12:34.580
That's right.

00:12:34.580 --> 00:12:43.880
So, apparently I can, yeah, there's a way to run it as a server and then talk to it as if it were some of these services as well, which is pretty wild.

00:12:43.880 --> 00:12:44.820
It is incredible.

00:12:44.820 --> 00:12:52.420
And I guess good that Bodo is all of the interface so that it's one point to mock it.

00:12:53.420 --> 00:12:58.420
Yeah, yeah, Bodo, the reason I don't like it is you say Bodo and you create a client and then you pass it a string.

00:12:58.420 --> 00:13:00.700
The string could be like EC2 or S3.

00:13:00.700 --> 00:13:10.980
And then how you interact with it has to do with what factory that string drove it to to create a different, like it's really hard to discover what can I do with this thing?

00:13:10.980 --> 00:13:15.960
Because it's like a generic blob that can be converted into something more real.

00:13:15.960 --> 00:13:16.380
I don't know.

00:13:16.380 --> 00:13:17.080
It's funky.

00:13:17.080 --> 00:13:19.060
But yes, in this regard, it's definitely very nice.

00:13:19.060 --> 00:13:21.080
Apparently, your life is more complicated than mine.

00:13:21.420 --> 00:13:26.540
I guess I've worked with S3 and Elastic Transcoder and all that stuff too much.

00:13:26.540 --> 00:13:26.900
Yeah.

00:13:26.900 --> 00:13:28.340
Okay, cool.

00:13:28.340 --> 00:13:28.800
What's next?

00:13:28.800 --> 00:13:32.780
I was just thinking that maybe we should have done a testing code episode with all this testing stuff.

00:13:32.780 --> 00:13:33.140
Yeah.

00:13:33.300 --> 00:13:37.680
But one of the things that we have, I think we've talked about Mongo Engine before.

00:13:37.680 --> 00:13:42.160
And I know that you've used Mongo Engine in some of your courses, right?

00:13:42.160 --> 00:13:42.840
Yeah, for sure.

00:13:42.840 --> 00:13:43.780
And on the sites.

00:13:43.780 --> 00:13:44.280
Yeah.

00:13:44.280 --> 00:13:46.980
And it's like a mapper's...

00:13:46.980 --> 00:13:50.800
They don't say ORM because object relational mapping because it's not really the R.

00:13:50.800 --> 00:13:53.120
So they say ODM for object document mapper.

00:13:53.120 --> 00:13:53.940
That's like the...

00:13:53.940 --> 00:13:54.220
Okay.

00:13:54.220 --> 00:13:55.860
The adapted acronym.

00:13:55.860 --> 00:13:57.420
So I didn't know that there were...

00:13:57.420 --> 00:14:00.740
So I knew about Mongo Engine because of you, but I didn't know about others.

00:14:00.740 --> 00:14:04.600
And here's a project called MicroMongo or Mew Mongo.

00:14:04.600 --> 00:14:05.080
Not sure.

00:14:05.080 --> 00:14:05.180
Yeah.

00:14:05.180 --> 00:14:06.760
I think MicroMongo is the way you would say it.

00:14:06.760 --> 00:14:08.260
I think that's the Greek.

00:14:08.260 --> 00:14:08.560
Yeah.

00:14:08.560 --> 00:14:09.020
Mew, yeah.

00:14:09.020 --> 00:14:11.140
It's a Python MongoDB ODM.

00:14:11.140 --> 00:14:15.620
And it comes because the people that made it had two needs.

00:14:15.620 --> 00:14:18.240
They wanted an asynchronous ODM.

00:14:18.240 --> 00:14:26.220
And for some reason, they felt like it was difficult to do serialization and un-serialization of documents

00:14:26.220 --> 00:14:27.500
with existing ODMs.

00:14:27.500 --> 00:14:28.940
And so this one doesn't.

00:14:28.940 --> 00:14:31.620
So it's an asynchronous sort of thing.

00:14:31.620 --> 00:14:38.560
It works directly with some of the popular Mongo drivers like PyMongo, TX Mongo, that's

00:14:38.560 --> 00:14:41.980
for twisted, Motor AsyncIO, and MongoMock.

00:14:41.980 --> 00:14:45.020
And I'm kind of excited about MongoMock.

00:14:45.020 --> 00:14:45.720
Yeah, for sure.

00:14:45.720 --> 00:14:50.240
I got to say, this is probably the most interesting aspect of this because something like Mongo

00:14:50.240 --> 00:14:51.640
Engine, it just works with PyMongo.

00:14:51.640 --> 00:14:52.860
But this one says, you know what?

00:14:52.860 --> 00:14:58.240
We actually can work with all these different foundations, which gives it like fundamentally

00:14:58.240 --> 00:15:00.800
different behaviors and features, right?

00:15:00.820 --> 00:15:04.780
If you pointed at the twisted one, it can now integrate with twisted's async-ers model.

00:15:04.780 --> 00:15:10.220
Motor AsyncIO now lets it plug into true AsyncIO stuff.

00:15:10.220 --> 00:15:14.980
Like you could plug it into Scarlet like you discussed before and those async methods there.

00:15:14.980 --> 00:15:16.660
And then the mocking as well.

00:15:16.660 --> 00:15:19.240
Like we're just going to take the foundation and make it a mock version.

00:15:19.240 --> 00:15:20.720
All those are super cool.

00:15:20.720 --> 00:15:21.160
Yeah.

00:15:21.160 --> 00:15:26.920
And then also because of this, I learned about MongoMock, which is a cool way to mock out

00:15:26.920 --> 00:15:27.900
your Mongo database.

00:15:27.900 --> 00:15:29.460
So kind of neat.

00:15:29.460 --> 00:15:30.760
Definitely want to try this.

00:15:30.760 --> 00:15:31.200
Yeah.

00:15:31.200 --> 00:15:31.360
Sometime.

00:15:31.360 --> 00:15:31.560
Yeah.

00:15:31.560 --> 00:15:32.840
It definitely looks interesting.

00:15:32.840 --> 00:15:36.480
I don't remember exactly when this got created.

00:15:36.480 --> 00:15:37.660
Do you know what GitHub needs?

00:15:37.660 --> 00:15:40.820
Is it needs a, this project was created on this day, right?

00:15:40.820 --> 00:15:42.320
Because you can go back to the commits.

00:15:42.320 --> 00:15:46.740
But if there's thousands of commits, you've got to like infinite scroll your way back to

00:15:46.740 --> 00:15:48.640
the origins.

00:15:48.640 --> 00:15:50.300
But anyway, yeah, it's really cool.

00:15:50.440 --> 00:15:54.580
I think if I had known about this at first, I might've even chosen this over MongoEngine.

00:15:54.580 --> 00:15:55.680
But yeah, it's really nice.

00:15:55.680 --> 00:15:56.840
It's nice.

00:15:56.840 --> 00:15:59.400
It has a 90% plus test coverage.

00:15:59.400 --> 00:16:05.060
I really like the different foundations, which means you learn like one ODM style of programming,

00:16:05.060 --> 00:16:07.180
but then you can use it in these different situations.

00:16:07.180 --> 00:16:08.220
Yeah.

00:16:08.220 --> 00:16:08.840
Super cool.

00:16:08.840 --> 00:16:09.320
I like it.

00:16:09.320 --> 00:16:12.840
And also I didn't know about MongoMock either, but now I'm excited about it.

00:16:12.840 --> 00:16:13.860
That looks cool.

00:16:13.860 --> 00:16:14.540
Nice.

00:16:14.540 --> 00:16:14.940
All right.

00:16:14.940 --> 00:16:22.040
So let me hit you with an opinionated piece here and you can give me some feedback.

00:16:22.040 --> 00:16:23.940
Let me know what you think about it.

00:16:23.940 --> 00:16:25.460
Some parts of it.

00:16:25.580 --> 00:16:26.140
Tomatoes ready.

00:16:26.140 --> 00:16:26.580
Yeah.

00:16:26.580 --> 00:16:26.860
Perfect.

00:16:26.860 --> 00:16:27.820
Get ready to throw them.

00:16:27.820 --> 00:16:28.680
I'll get ready to dodge them.

00:16:28.680 --> 00:16:33.840
So this article was sent over by Tyler Madison.

00:16:33.840 --> 00:16:35.920
Listener, thanks for sending that over.

00:16:35.920 --> 00:16:39.100
Now it's called the single responsibility principle in Python.

00:16:39.100 --> 00:16:46.460
And the single responsibility principle or SRP comes out of this larger group of design principles,

00:16:46.460 --> 00:16:50.240
coding principles, architecture principles, something like that called solid.

00:16:50.240 --> 00:16:53.320
So S is a single responsibility principle.

00:16:53.320 --> 00:16:54.860
O is the open close principle.

00:16:55.760 --> 00:16:57.660
L is Liskov substitution principle.

00:16:57.660 --> 00:17:02.900
And these even come in really interesting demotivator style posters.

00:17:02.900 --> 00:17:05.020
I don't know if you're all familiar with demotivators.

00:17:05.020 --> 00:17:07.080
You're probably familiar with motivators.

00:17:07.080 --> 00:17:12.380
You will see this probably in the entryway, like kind of near the CEO office.

00:17:12.380 --> 00:17:15.760
It's like probably got a giant eagle soaring above clouds.

00:17:15.760 --> 00:17:19.980
Like together we can fly higher than you ever dreamed or something stupid like that.

00:17:20.460 --> 00:17:26.220
Well, the demotivators take pictures like that but put like negative captions and connotations.

00:17:26.220 --> 00:17:28.600
So these are really interesting things.

00:17:28.600 --> 00:17:33.180
For example, the Liskov substitution one has a duck and a rubber duck in the water.

00:17:33.580 --> 00:17:38.760
And it says, if it looks like a duck and quacks like a duck but it needs batteries, you probably have the wrong abstraction.

00:17:38.760 --> 00:17:39.260
Right?

00:17:39.260 --> 00:17:45.520
So there's all these really cool demotivator style posters around the solid principles.

00:17:45.520 --> 00:17:47.680
And I think the solid principles are pretty neat.

00:17:47.680 --> 00:17:49.180
Like you can go overboard with them.

00:17:49.560 --> 00:17:50.760
But they are pretty powerful.

00:17:50.760 --> 00:17:54.920
So this article focuses specifically on the single responsibility principle.

00:17:54.920 --> 00:17:58.760
And I think talking about it is really interesting.

00:17:58.760 --> 00:18:02.180
I think the solution is unexpected.

00:18:02.180 --> 00:18:03.680
And it made me think.

00:18:03.680 --> 00:18:05.140
And at first I'm like, oh, I don't like it.

00:18:05.140 --> 00:18:08.280
But after a while I'm like, but it is pretty creative.

00:18:08.280 --> 00:18:10.580
And things that make me think I like to share with people.

00:18:10.580 --> 00:18:12.120
So I guess that's why I chose it.

00:18:12.640 --> 00:18:17.940
And it starts out by saying this article will guide you through the complex process of writing simple code.

00:18:17.940 --> 00:18:20.880
And it talks about stuff that you would expect.

00:18:20.880 --> 00:18:21.120
Right?

00:18:21.120 --> 00:18:24.060
So there's some kind of super long function.

00:18:24.060 --> 00:18:25.480
So this is terrible.

00:18:25.480 --> 00:18:26.240
You can't test it.

00:18:26.240 --> 00:18:28.520
You can't reason about it because it's doing five things.

00:18:28.520 --> 00:18:31.520
How do you know whether you're doing too much?

00:18:31.520 --> 00:18:39.500
You can look at measures like the cyclometric complexity, the Halstead complexity thing, the number of arguments, the number of statements, body length, all that kind of stuff.

00:18:40.420 --> 00:18:45.780
And that will help you condense down into, say, reasonable classes or functions.

00:18:45.780 --> 00:18:47.900
And this is really mostly focusing on functions.

00:18:47.900 --> 00:18:48.760
So all right.

00:18:48.760 --> 00:18:50.380
So let's think of another simple example.

00:18:50.380 --> 00:18:54.920
I want to calculate the price of a bunch of products given a list of products.

00:18:54.920 --> 00:19:01.760
And it seems all well and good except for that it also happens to use some kind of logger object and log out the price.

00:19:01.760 --> 00:19:04.160
Well, now this thing is doing two things.

00:19:04.160 --> 00:19:06.340
It's one, calculating it and logging it out.

00:19:06.340 --> 00:19:12.440
What if you want to test it or work with it with its computation bits but not the logging bit or something like that?

00:19:12.440 --> 00:19:16.300
So how do you go around dealing with these types of dependencies?

00:19:16.300 --> 00:19:16.960
Right?

00:19:16.960 --> 00:19:19.220
This kind of goes back to the testing side of things, Brian.

00:19:19.220 --> 00:19:19.640
Yeah.

00:19:19.640 --> 00:19:28.760
How do you deal with things like files and database connections and or database connection objects and, you know, loggers and whatnot?

00:19:29.860 --> 00:19:37.520
So this guy takes us through this whole sort of thought process, which is really good, and says, you know what we're going to do?

00:19:37.520 --> 00:19:41.800
We're going to come up with callable classes.

00:19:41.800 --> 00:19:43.060
Oh, dear.

00:19:43.060 --> 00:19:54.380
Well, the callable classes will be given the dependencies, and then you call them like functions, allowing you to pass different dependencies or other dependencies.

00:19:54.380 --> 00:20:06.800
And now that seems like a really bad idea, but they're using a lot of – my first thought was, okay, well, that's, you know, that's like a curvy-shaped weird hammer that I guess you could hit it with.

00:20:07.460 --> 00:20:10.260
But it's using a lot of interesting Python features.

00:20:10.260 --> 00:20:15.420
So if you create a class that has – it's a data class.

00:20:15.420 --> 00:20:18.460
You set frozen equal to true, slots equal to true.

00:20:18.460 --> 00:20:22.560
It means all of its variables become internal and private only.

00:20:22.560 --> 00:20:25.980
You set it to be private or final, rather, so it can't be derived from.

00:20:25.980 --> 00:20:27.560
And you give it a call function.

00:20:27.560 --> 00:20:29.940
It turns out to be pretty interesting.

00:20:29.940 --> 00:20:35.640
And then they talk about some dependency injection frameworks that work with these types of classes.

00:20:36.280 --> 00:20:43.760
In the end, it comes up with a pretty interesting way to, you know, create these things and then call them.

00:20:43.760 --> 00:20:48.120
I'm not sure that I love it, but it definitely made me think, and I was a little bit surprised by it.

00:20:48.120 --> 00:20:49.900
So I thought you all might enjoy it.

00:20:49.900 --> 00:20:50.300
Yeah.

00:20:50.300 --> 00:20:52.380
It's an entertaining read.

00:20:52.380 --> 00:20:53.220
I'll give you that.

00:20:53.220 --> 00:20:53.840
Yeah.

00:20:53.840 --> 00:20:57.020
Look at the very last code fragment in that article, Brian.

00:20:57.620 --> 00:20:58.020
Okay.

00:20:58.020 --> 00:21:06.340
The last code fragment that says, like, send postcards equals container dot resolve.

00:21:06.340 --> 00:21:07.160
Send to these postcards.

00:21:07.160 --> 00:21:07.820
Yes, exactly.

00:21:07.820 --> 00:21:09.080
And a little bit above it, yeah.

00:21:09.080 --> 00:21:10.220
Yeah, yeah.

00:21:10.220 --> 00:21:13.500
So it is powerful in that you can create these objects.

00:21:13.500 --> 00:21:18.200
You can pass in mock objects without actually using mock dot patch and stuff.

00:21:18.200 --> 00:21:19.900
It's interesting.

00:21:20.160 --> 00:21:28.420
I don't think that I would go write software using this today, but I might use some of the concepts of it, maybe.

00:21:28.420 --> 00:21:37.040
My opinion is that it is possible to do this, and it might make sure that you don't get fired because nobody else can edit your code.

00:21:37.040 --> 00:21:37.940
Yeah.

00:21:37.940 --> 00:21:39.160
Okay.

00:21:39.160 --> 00:21:43.180
So I do like the single responsibility part of solid.

00:21:43.180 --> 00:21:54.600
I am not a fan of the Luskov substitution principle or the open closed or dependency injection is something that frightens me.

00:21:55.000 --> 00:22:01.160
These are things that were put in place to work around limitations of other languages like Java and C.

00:22:01.160 --> 00:22:07.560
And I'm going to get tomatoes thrown at me for coming up with saying this, but some problems are complex.

00:22:07.560 --> 00:22:14.120
And you can remove the complexity out of one part of your code, but it moves to somewhere else.

00:22:14.120 --> 00:22:19.820
And maybe it makes your unit tests better, but your system tests are just the same.

00:22:19.820 --> 00:22:25.260
Or it makes writing regular code super hard because you're like, where did this database connection come from?

00:22:25.260 --> 00:22:27.740
I have no idea how I got here.

00:22:27.740 --> 00:22:28.640
Right?

00:22:28.640 --> 00:22:29.280
Yeah.

00:22:29.280 --> 00:22:30.000
It is a thing.

00:22:30.000 --> 00:22:30.980
It's an interesting article.

00:22:30.980 --> 00:22:32.040
I'm not a fan.

00:22:32.040 --> 00:22:32.280
Yeah.

00:22:32.280 --> 00:22:36.720
I submit this to everyone as a thought piece, not necessarily as guidance.

00:22:36.720 --> 00:22:37.280
Yeah.

00:22:37.280 --> 00:22:39.100
But I'm not willing to say that it's wrong.

00:22:39.100 --> 00:22:40.160
It's just my opinion.

00:22:40.160 --> 00:22:40.820
All right.

00:22:40.820 --> 00:22:43.020
Well, I think we should leave it there for our main topics.

00:22:43.020 --> 00:22:45.120
Got anything you want to share with folks this week?

00:22:45.120 --> 00:22:46.300
I've got one quick one.

00:22:46.300 --> 00:22:47.580
Oh, you share it with us then.

00:22:47.580 --> 00:22:51.380
So do you know Bob and Julian over at PyBytes?

00:22:51.380 --> 00:22:52.380
Of course, right?

00:22:52.380 --> 00:23:00.840
Well, they recently have their code challenges platform, which is at codechallenge.is, right?

00:23:00.840 --> 00:23:02.220
The .es extension, right?

00:23:02.220 --> 00:23:05.120
Just code challenges, put the period between G and ES.

00:23:05.940 --> 00:23:08.840
And that's a place where you can go do practice exercises.

00:23:08.840 --> 00:23:10.580
And it's a cool platform they've created.

00:23:10.580 --> 00:23:18.700
And they just came out with Byte220, where they walk people through analyzing the Python Byte's RSS feed.

00:23:18.700 --> 00:23:19.200
Oh, cool.

00:23:19.300 --> 00:23:19.440
Yeah.

00:23:19.440 --> 00:23:24.640
So you can go in there, and it shows you how to use Feed Parser, which is a really cool way to parse RSS feeds.

00:23:24.640 --> 00:23:27.800
Go in there and actually answer questions.

00:23:27.800 --> 00:23:29.940
What were they looking at?

00:23:29.940 --> 00:23:34.140
It was things like, what is the average duration of an episode in seconds?

00:23:34.140 --> 00:23:37.400
What are the number of episodes with special guests?

00:23:37.400 --> 00:23:39.660
Like Trey was on the show last week, for example.

00:23:40.240 --> 00:23:42.540
What are the most common domain names we mentioned?

00:23:42.540 --> 00:23:45.840
Like GitHub probably is right up near the top and things like that.

00:23:45.840 --> 00:23:51.360
So it's pretty cool that there's like this guided challenge to get through our platform, at least our platform's data.

00:23:51.360 --> 00:23:55.900
Yeah, I'll have to come up with ways in our show notes to break their challenge.

00:23:55.900 --> 00:23:56.380
No.

00:23:56.380 --> 00:23:59.280
Yeah, that sounds good.

00:23:59.280 --> 00:24:00.480
So that's all fun.

00:24:00.480 --> 00:24:02.880
People can check that out if they're interested.

00:24:02.880 --> 00:24:04.080
You ready for some jokes?

00:24:04.080 --> 00:24:04.740
Definitely.

00:24:04.740 --> 00:24:08.440
These come from Web Boss's Dad Jokes GitHub repo.

00:24:08.720 --> 00:24:15.880
So they're pretty short and sweet, but they're in the dad joke style, which is kind of bad jokes that are hopefully funny.

00:24:15.880 --> 00:24:19.540
So what do you get when you cross a computer and a lifeguard?

00:24:19.540 --> 00:24:20.080
I don't know.

00:24:20.080 --> 00:24:20.320
What?

00:24:20.320 --> 00:24:21.120
A screensaver.

00:24:21.120 --> 00:24:25.040
What do you get when you cross a computer with an elephant?

00:24:25.040 --> 00:24:27.080
Lots of memory.

00:24:27.080 --> 00:24:28.480
Lots of memory.

00:24:28.480 --> 00:24:29.780
Lots of memory.

00:24:29.780 --> 00:24:31.020
Okay.

00:24:31.020 --> 00:24:31.600
Nice.

00:24:31.600 --> 00:24:36.780
So I'm going to share this because I made it up and I thought it was funny, but it's an anti-joke.

00:24:37.000 --> 00:24:42.540
So a Python developer, a PHP developer, a C# developer, and a Go developer all went to lunch together.

00:24:42.540 --> 00:24:43.420
Oh my gosh, what happened?

00:24:43.420 --> 00:24:45.420
They had a nice lunch and all got along fine.

00:24:45.420 --> 00:24:46.660
Perfect.

00:24:46.660 --> 00:24:47.720
Of course they should.

00:24:47.720 --> 00:24:49.520
They're all developers.

00:24:49.520 --> 00:24:52.100
Anyway, thanks.

00:24:52.100 --> 00:24:52.920
Awesome.

00:24:52.920 --> 00:24:54.580
Yeah, well, thanks as always, Brian.

00:24:54.580 --> 00:24:55.060
See you later.

00:24:55.380 --> 00:24:56.980
Thank you for listening to Python Bytes.

00:24:56.980 --> 00:24:59.520
Follow the show on Twitter via at Python Bytes.

00:24:59.520 --> 00:25:02.380
That's Python Bytes as in B-Y-T-E-S.

00:25:02.380 --> 00:25:05.600
And get the full show notes at pythonbytes.fm.

00:25:05.600 --> 00:25:09.820
If you have a news item you want featured, just visit pythonbytes.fm and send it our way.

00:25:09.820 --> 00:25:12.520
We're always on the lookout for sharing something cool.

00:25:12.520 --> 00:25:15.620
On behalf of myself and Brian Okken, this is Michael Kennedy.

00:25:15.620 --> 00:25:19.060
Thank you for listening and sharing this podcast with your friends and colleagues.

