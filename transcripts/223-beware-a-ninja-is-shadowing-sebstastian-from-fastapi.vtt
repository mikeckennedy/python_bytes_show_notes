WEBVTT

00:00:00.001 --> 00:00:05.400
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:05.400 --> 00:00:10.540
This is episode 223, recorded March 3rd, 2021.

00:00:10.540 --> 00:00:11.660
I'm Brian Okken.

00:00:11.660 --> 00:00:12.640
I'm Michael Kennedy.

00:00:12.640 --> 00:00:14.240
And I'm Sebastian Ramirez.

00:00:14.240 --> 00:00:16.620
Cool, we did that without talking over the top.

00:00:16.620 --> 00:00:18.820
Hey, we're getting good at this.

00:00:18.820 --> 00:00:20.280
Welcome, Sebastian. Great to see you.

00:00:20.280 --> 00:00:23.220
Thank you very much for inviting me. It's a pleasure to be here with you.

00:00:23.220 --> 00:00:26.520
All right. Well, let's start it off.

00:00:26.520 --> 00:00:31.420
Oh, I wanted to mention, we'll talk about them later, but thanks to Datadog for sponsoring this episode.

00:00:31.420 --> 00:00:37.060
Yeah, yeah. And Sebastian, people maybe know you, but they definitely know your API framework, right?

00:00:37.060 --> 00:00:39.740
I hope so. At least some of them.

00:00:39.740 --> 00:00:44.140
Yeah, should I say who I am or not yet?

00:00:44.140 --> 00:00:47.600
Yeah, yeah, sure. Give us a quick little introduction and we'll jump over to the items.

00:00:47.600 --> 00:00:49.700
Awesome. So hello, everyone. I'm Sebastian Ramirez.

00:00:49.700 --> 00:00:56.240
I'm the creator of FastAPI, which is a web API framework for Python.

00:00:56.240 --> 00:01:05.720
Based on type annotations that, yeah, well, it has been used by quite a bunch of interesting organizations and products recently.

00:01:05.720 --> 00:01:10.460
I'm a software developer at Explosion in Berlin, Germany, but I'm actually from Colombia.

00:01:10.460 --> 00:01:11.780
That's why I said it.

00:01:11.780 --> 00:01:12.600
And yeah, that's a lovely.

00:01:12.600 --> 00:01:16.280
Fantastic. Yeah. And you have the best mustache of anyone that's ever been on the show.

00:01:16.280 --> 00:01:18.020
Thank you very much.

00:01:18.020 --> 00:01:20.660
Definitely. Well, let's jump in.

00:01:20.660 --> 00:01:26.300
So I wanted to cover the Python developer survey 2020 results.

00:01:26.300 --> 00:01:28.280
This is pretty exciting.

00:01:28.280 --> 00:01:34.200
We'll get a little bit in a minute to talk about one of the things I wanted to talk about, of course.

00:01:34.200 --> 00:01:35.680
But let's look at it a little bit.

00:01:35.680 --> 00:01:41.960
So the Python developer survey is put on by the PSF, right?

00:01:41.960 --> 00:01:43.700
Isn't it joint PSF and JetBrains?

00:01:43.700 --> 00:01:46.180
Yeah, I think it's put on by the PSF.

00:01:46.180 --> 00:01:51.520
It's like hosted and analyzed by JetBrains, but it's not collected by JetBrains.

00:01:51.520 --> 00:01:58.800
They make a point of not, you know, it's put on python.org and maybe even PyPI, but not on jetbrains.com.

00:01:58.800 --> 00:02:01.020
So they try to not slant it in that regard.

00:02:01.020 --> 00:02:01.540
Yeah.

00:02:01.540 --> 00:02:04.420
So, but yeah, it's hard to, yeah.

00:02:04.420 --> 00:02:06.580
Anyway, there's a whole bunch of cool stuff in here.

00:02:06.660 --> 00:02:13.280
One of the things that takeaways that I was confused by a little bit at first was the use, what do you use Python for?

00:02:13.280 --> 00:02:23.220
And you've got a lot of reductions in percentages, but if you look at what increased, so you kind of see that people are using Python for more stuff and it's spreading out.

00:02:23.220 --> 00:02:27.100
So there's increases in education and in desktop apps.

00:02:27.100 --> 00:02:29.240
Games increased quite a bit.

00:02:29.240 --> 00:02:32.180
Mobile, which was interesting, and other.

00:02:32.460 --> 00:02:36.180
So the long tail has gotten fatter and that's good.

00:02:36.180 --> 00:02:37.920
We're using Python for a lot of stuff.

00:02:37.920 --> 00:02:41.980
Another good sign is Python 3 is increased.

00:02:41.980 --> 00:02:44.700
So last year we had 90% usage of Python 3.

00:02:44.700 --> 00:02:46.560
Now it's up to 94%.

00:02:46.560 --> 00:02:51.180
Not sure why it's not at 100% yet, but I think there's some, probably some legacy stuff.

00:02:51.180 --> 00:02:56.980
There's some projects out there that are in the, please don't touch it, it's working.

00:02:56.980 --> 00:03:00.300
Nobody knows how it works, just leave it alone category.

00:03:00.580 --> 00:03:03.240
And it's probably that last 5% or so.

00:03:03.240 --> 00:03:03.740
Yeah.

00:03:03.740 --> 00:03:07.400
What are people using for environment isolation?

00:03:07.400 --> 00:03:15.380
We've got virtual MV at 54%, but I assume that also includes VENV or the built-in.

00:03:15.380 --> 00:03:16.280
There's like two.

00:03:16.280 --> 00:03:18.960
Yeah, I saw there was no mention of VENV.

00:03:18.960 --> 00:03:21.820
So just virtual ENV probably is that as well.

00:03:21.820 --> 00:03:22.900
I had that same question.

00:03:22.900 --> 00:03:30.120
I'm like, wait, surely somebody uses Python-VenV because I answered that question.

00:03:30.460 --> 00:03:32.080
Yeah, we kind of use those interchangeably.

00:03:32.080 --> 00:03:34.180
So I guess that maybe that's what it is.

00:03:34.180 --> 00:03:39.380
But one of the things that surprised me was that the, I've heard, I know a lot of people

00:03:39.380 --> 00:03:41.260
use Conda for data science stuff.

00:03:41.260 --> 00:03:42.420
That's at 22%.

00:03:42.420 --> 00:03:47.240
But 32% are just using Docker for isolation, which that surprised me.

00:03:47.240 --> 00:03:48.460
That's an interesting thing.

00:03:48.460 --> 00:03:50.100
That's a hardcore isolation.

00:03:50.100 --> 00:03:50.700
Yeah.

00:03:50.700 --> 00:03:51.020
Yeah.

00:03:52.020 --> 00:03:56.360
Although I think more and more people are just using it all the time for a lot of stuff.

00:03:56.360 --> 00:03:57.400
So I guess why not?

00:03:57.400 --> 00:03:58.480
Sebastian, what about you?

00:03:58.480 --> 00:03:59.360
Are you a poetry?

00:03:59.360 --> 00:04:00.940
Are you a Python-MVNV?

00:04:00.940 --> 00:04:02.480
Are you a Docker?

00:04:02.480 --> 00:04:04.100
I'm all over the place.

00:04:04.100 --> 00:04:05.920
Actually, I'm quite a fan of poetry.

00:04:05.920 --> 00:04:13.340
And I think it's a great tool because it puts a lot of functionality in the same place.

00:04:13.340 --> 00:04:18.240
Handling dependencies, handling environments, and handling pinning versions.

00:04:18.240 --> 00:04:23.460
When you add a new package with poetry, it automatically detects what is the latest version and has the

00:04:23.460 --> 00:04:25.540
right ranges of versions.

00:04:25.540 --> 00:04:27.180
So I think that's very, very cool.

00:04:27.500 --> 00:04:32.160
And creating a package with poetry is super straightforward to create a package that can

00:04:32.160 --> 00:04:34.240
be later published directly.

00:04:34.240 --> 00:04:38.240
So it's more similar to NPM in the Node.js world.

00:04:38.240 --> 00:04:39.080
Right.

00:04:39.080 --> 00:04:41.100
Because you can publish from it as well, right?

00:04:41.100 --> 00:04:42.660
You can create the package and then publish.

00:04:42.660 --> 00:04:43.020
Yeah.

00:04:43.020 --> 00:04:44.660
And have all the configurations together.

00:04:44.660 --> 00:04:50.980
But at the same time, I'm using vanilla Python VM in a bunch of projects at work and

00:04:50.980 --> 00:04:52.980
things and a bunch of Docker as well.

00:04:52.980 --> 00:04:55.640
So yeah, it's many different things.

00:04:55.640 --> 00:05:02.240
I would think that for local development, it's always one type of virtual environment, being

00:05:02.240 --> 00:05:03.500
a VM for poetry.

00:05:03.500 --> 00:05:09.180
And then for deployment, sometimes it's just like pure Docker, sometimes poetry inside of

00:05:09.180 --> 00:05:11.560
Docker, but not even using the virtual environment.

00:05:11.560 --> 00:05:16.800
But yeah, I would think Docker for deployment and then locally virtual environments, at least

00:05:16.800 --> 00:05:17.280
for me.

00:05:17.280 --> 00:05:17.640
Yeah.

00:05:17.640 --> 00:05:18.520
And that was the majority.

00:05:18.520 --> 00:05:23.080
I think most people are primarily using VNV for that, but I can't remember exactly.

00:05:23.080 --> 00:05:24.060
Hey, Brian, quick comment.

00:05:24.060 --> 00:05:24.620
Yeah.

00:05:24.620 --> 00:05:25.220
What's that?

00:05:25.520 --> 00:05:29.800
Is VNV versus virtual ENV a Python 2 versus 3 thing?

00:05:29.800 --> 00:05:30.780
Oh, yeah.

00:05:30.780 --> 00:05:31.960
I guess maybe it is.

00:05:31.960 --> 00:05:35.320
I think, you know, VNV was added, I believe, in Python 3.

00:05:35.320 --> 00:05:39.900
But, and I had kind of forgotten about virtual ENV, but there's some interesting stuff.

00:05:39.900 --> 00:05:44.540
I think we covered it a while ago, the release of version 20, because it actually does a lot

00:05:44.540 --> 00:05:45.400
of interesting stuff.

00:05:45.660 --> 00:05:50.040
And then Magnuson has a comment on poetry.

00:05:50.040 --> 00:05:57.040
manually in order to use --prompt, which is, so it's not called VNV when your prompt

00:05:57.040 --> 00:06:02.260
changes, but project name in parentheses when your project changes, which is the question

00:06:02.260 --> 00:06:02.940
Gandalf had.

00:06:02.940 --> 00:06:07.400
And then Dean is a fan of the virtual ENV wrapper as well.

00:06:07.400 --> 00:06:08.140
So awesome.

00:06:08.420 --> 00:06:10.720
Yeah, I haven't either.

00:06:10.720 --> 00:06:14.660
I feel like this is one of the areas where there's just so many different ways people

00:06:14.660 --> 00:06:15.880
are doing this stuff.

00:06:15.880 --> 00:06:20.080
But yeah, with our special guest here, Brian, but how about you touch on this one?

00:06:20.080 --> 00:06:21.260
This is big news here.

00:06:21.260 --> 00:06:21.880
Yeah.

00:06:22.040 --> 00:06:23.420
So this is big news.

00:06:23.420 --> 00:06:29.920
So frameworks and libraries under web frameworks, we've got Flask at 46%, Django at 43%.

00:06:29.920 --> 00:06:33.400
And then, dun, dun, dun, FastAPI at 12%.

00:06:33.400 --> 00:06:37.340
It's the first time it was on the survey, and it's already up at number three.

00:06:37.340 --> 00:06:39.820
So yeah, way to go.

00:06:39.820 --> 00:06:42.320
The growth is super, super interesting there.

00:06:42.320 --> 00:06:43.860
And yeah, congratulations, Sebastian.

00:06:43.860 --> 00:06:47.540
And I actually think that this is going to grow quite a bit more.

00:06:47.540 --> 00:06:53.220
If you look at the first derivative, it's higher for the numbers for FastAPI, like the

00:06:53.220 --> 00:06:55.380
rate of growth or just the growth.

00:06:55.380 --> 00:07:00.520
Also, I feel like a lot of people are not necessarily leveraging.

00:07:00.520 --> 00:07:02.300
I mean, I'd like to hear your thoughts on this, Sebastian.

00:07:02.300 --> 00:07:06.760
Leveraging FastAPI's ability to deliver HTML as well.

00:07:06.760 --> 00:07:08.100
Yeah, absolutely.

00:07:08.100 --> 00:07:15.420
Because if you're rendering HTML in the backend, the benefits of FastAPI are not as obvious.

00:07:15.420 --> 00:07:21.220
So I guess people probably will use it more for APIs.

00:07:21.220 --> 00:07:27.000
But then there's actually a bunch of people using it for very different stuff than what

00:07:27.000 --> 00:07:29.040
I initially thought of.

00:07:29.040 --> 00:07:29.300
Yeah, yeah.

00:07:29.300 --> 00:07:33.760
Yeah, I think, you know, I think you can basically get down to the Starlette type features and stuff.

00:07:33.760 --> 00:07:37.600
And then you can build, you know, an equivalent of Flask or Django.

00:07:37.600 --> 00:07:40.960
And what I think is interesting about that is a lot of people are like, well, I could do this

00:07:40.960 --> 00:07:42.280
really cool API with FastAPI.

00:07:42.280 --> 00:07:44.620
And then do we use Flask or Django for the web part?

00:07:44.700 --> 00:07:48.160
It's like, well, if you've already got the FastAPI part and you've got like 10 pages

00:07:48.160 --> 00:07:51.200
you want to serve, just, you know, don't juggle two apps.

00:07:51.200 --> 00:07:52.340
Just like put them there.

00:07:52.340 --> 00:07:53.320
It's actually not that hard.

00:07:53.320 --> 00:07:55.000
So I think there's some really interesting stuff.

00:07:55.000 --> 00:07:59.080
And I think as people learn those and leverage those, it's only going to grow because they're

00:07:59.080 --> 00:08:02.260
like, oh, I actually don't have to have Flask plus FastAPI.

00:08:02.260 --> 00:08:03.460
I could just have FastAPI.

00:08:03.460 --> 00:08:03.940
Yeah.

00:08:03.940 --> 00:08:05.340
Not the Flask is bad, but yeah.

00:08:05.580 --> 00:08:05.820
Yeah.

00:08:05.820 --> 00:08:06.540
Of course.

00:08:06.540 --> 00:08:13.620
And like FastAPI is actually, FastAPI owes and was inspired a lot by all of these frameworks

00:08:13.620 --> 00:08:14.740
that paved the way.

00:08:14.740 --> 00:08:18.060
Like all of these designs of these ideas came before FastAPI.

00:08:18.060 --> 00:08:23.620
FastAPI is just putting them together with the new type annotations from modern Python.

00:08:23.620 --> 00:08:28.180
But yeah, like it's all the work that has been done by a lot of people.

00:08:28.520 --> 00:08:28.760
Yeah.

00:08:28.760 --> 00:08:28.880
Yeah.

00:08:28.880 --> 00:08:29.080
Yeah.

00:08:29.080 --> 00:08:31.140
Standing on the shoulders of giants type thing.

00:08:31.140 --> 00:08:31.560
Exactly.

00:08:31.560 --> 00:08:32.160
Exactly.

00:08:32.160 --> 00:08:32.520
Yeah.

00:08:32.520 --> 00:08:32.980
Yeah.

00:08:32.980 --> 00:08:33.240
Awesome.

00:08:33.240 --> 00:08:33.860
But yeah.

00:08:33.860 --> 00:08:37.080
I've got some stuff to add to that as well for my next item, by the way.

00:08:37.080 --> 00:08:37.540
Oh, cool.

00:08:37.540 --> 00:08:38.160
Yeah.

00:08:38.160 --> 00:08:43.520
No, before we move on, one of the things in the survey that was interesting to me was the

00:08:43.520 --> 00:08:46.320
use of continuous integration.

00:08:46.320 --> 00:08:52.360
So I use CI or continuous integration all the time, but one of the, see if I can find it.

00:08:53.020 --> 00:08:59.660
CI, the CI systems in use, GitLab was top, which was interesting to me.

00:08:59.660 --> 00:09:05.260
I mean, I use GitLab at work, but I use GitHub or I use, I guess, GitLab CI, but I'm using

00:09:05.260 --> 00:09:08.540
GitHub Actions a lot and I don't see GitHub Actions even here.

00:09:08.540 --> 00:09:11.500
So I wonder if it just wasn't listed or I'm not sure.

00:09:11.500 --> 00:09:12.560
That's quite interesting.

00:09:12.560 --> 00:09:12.900
Yeah.

00:09:12.900 --> 00:09:14.940
I haven't noticed that GitHub Actions is not.

00:09:14.940 --> 00:09:15.760
Yeah.

00:09:15.760 --> 00:09:16.940
I expected to see it as well.

00:09:16.940 --> 00:09:17.140
Yeah.

00:09:17.140 --> 00:09:17.600
Yeah.

00:09:17.600 --> 00:09:20.640
But what I did not see, I just want to throw this out, like, well done on building the

00:09:20.640 --> 00:09:23.840
survey because what I didn't see is what platform are you on?

00:09:23.840 --> 00:09:27.960
Do you use Python or do you use SQL or do you use Vue.js?

00:09:27.960 --> 00:09:32.440
Like, they did a good job of comparing apples to apples in this one.

00:09:32.440 --> 00:09:33.860
And that was nice.

00:09:33.860 --> 00:09:34.320
Yeah.

00:09:34.320 --> 00:09:34.540
Yeah.

00:09:34.540 --> 00:09:35.140
Yeah.

00:09:35.140 --> 00:09:40.380
I guess, but like, I guess what you brought up before on the web frameworks though, the,

00:09:40.380 --> 00:09:44.960
like why, I mean, it depends on what you're using the web for.

00:09:45.260 --> 00:09:49.560
So like you, the early use of FastAPI was just APIs.

00:09:49.560 --> 00:09:51.380
So I don't know.

00:09:51.380 --> 00:09:52.700
That's not apples to apples.

00:09:52.700 --> 00:09:52.940
Right.

00:09:52.940 --> 00:09:54.820
You may be doing Flask plus FastAPI.

00:09:54.820 --> 00:09:55.260
Yeah.

00:09:55.260 --> 00:09:55.660
Yeah.

00:09:55.660 --> 00:10:01.320
And that, the survey allows that you can, if you add these numbers up, they are over a

00:10:01.320 --> 00:10:01.520
hundred.

00:10:01.520 --> 00:10:04.000
So I wanted to bring up one more thing.

00:10:04.000 --> 00:10:07.180
I guess unit testing is at 49% for pytest.

00:10:07.180 --> 00:10:08.520
So pytest is in the lead.

00:10:08.520 --> 00:10:09.200
Yeah.

00:10:09.200 --> 00:10:13.080
I also saw there's a really interesting number two in that list there.

00:10:13.080 --> 00:10:15.900
28% of using unit test.

00:10:15.900 --> 00:10:16.300
Yeah.

00:10:16.300 --> 00:10:17.700
No, that's not the one I was thinking of.

00:10:17.700 --> 00:10:18.480
That's number three.

00:10:18.480 --> 00:10:19.580
Oh, was it number three?

00:10:19.580 --> 00:10:20.760
Number two is none.

00:10:20.760 --> 00:10:20.960
Number two.

00:10:20.960 --> 00:10:26.440
Number two is, so, you know, in Python, when like a lot of languages have null or nil, but

00:10:26.440 --> 00:10:31.240
apparently people just like do stuff with the none type to test here a lot.

00:10:31.240 --> 00:10:31.520
So.

00:10:31.520 --> 00:10:35.100
None testing.

00:10:35.100 --> 00:10:35.700
Yeah.

00:10:35.700 --> 00:10:36.200
Oh yeah.

00:10:36.200 --> 00:10:37.200
That is number two.

00:10:37.200 --> 00:10:37.760
Yeah.

00:10:37.760 --> 00:10:38.460
It's crushing it.

00:10:38.460 --> 00:10:38.620
Yeah.

00:10:38.620 --> 00:10:39.280
None is pretty.

00:10:39.280 --> 00:10:43.400
I mean, you do get a lot of exceptions and it's easy to like fail first and then, yeah.

00:10:43.400 --> 00:10:43.760
Anyway.

00:10:43.760 --> 00:10:44.640
So I got to talk to.

00:10:44.640 --> 00:10:46.480
Nil type has no attributes such and such.

00:10:46.480 --> 00:10:52.760
I got to talk to the PSF and JetBrains about this because I'm not sure why they call it unit

00:10:52.760 --> 00:10:53.620
testing frameworks.

00:10:53.620 --> 00:10:55.760
We got to get, we got to drop the unit off there.

00:10:55.760 --> 00:10:57.100
Just call them testing frameworks.

00:10:57.100 --> 00:10:57.600
Yeah.

00:10:57.600 --> 00:10:58.920
Brian, I hope you don't mind.

00:10:58.920 --> 00:11:01.860
I'm considering writing a book on this new none framework, by the way.

00:11:01.860 --> 00:11:02.680
I just.

00:11:02.680 --> 00:11:04.620
I think you should.

00:11:04.620 --> 00:11:05.460
That would be funny.

00:11:06.300 --> 00:11:10.920
Actually, I actually, yeah, it's really short.

00:11:10.920 --> 00:11:11.960
It's really, really short.

00:11:11.960 --> 00:11:13.880
All right.

00:11:13.880 --> 00:11:15.340
Probably one page book.

00:11:15.340 --> 00:11:15.600
Okay.

00:11:15.600 --> 00:11:16.560
All right.

00:11:16.560 --> 00:11:17.360
Next item.

00:11:17.360 --> 00:11:21.280
I got to keep moving along or we're going to have a two hour show here is I like ninjas.

00:11:21.280 --> 00:11:22.240
Do you like ninjas guys?

00:11:22.240 --> 00:11:23.160
Ninjas are cool.

00:11:23.160 --> 00:11:23.620
Oh yeah.

00:11:23.620 --> 00:11:25.740
Well, I mean, I don't know any, but.

00:11:25.940 --> 00:11:29.580
Well, I mean, if you are a ninja, you can't really speak about it because it's something

00:11:29.580 --> 00:11:30.500
about this secrecy.

00:11:30.500 --> 00:11:35.800
And anyway, Sebastian was just talking about how FastAPI was inspired by many of the frameworks

00:11:35.800 --> 00:11:36.660
that were on there.

00:11:36.780 --> 00:11:41.500
And there's a cool framework called Django ninja, fast Django rest framework.

00:11:41.500 --> 00:11:46.180
And I'm not a super expert in Django, but I think Django rest framework has been primarily

00:11:46.180 --> 00:11:49.680
the way to do APIs in Django these days and to layer that on.

00:11:49.680 --> 00:11:54.060
And if you look at the very bottom of this, there's a little bit here that says this project

00:11:54.060 --> 00:11:58.180
was heavily inspired by FastAPI developed by some guy named Sebastian.

00:11:58.400 --> 00:11:59.100
So that's pretty cool.

00:11:59.100 --> 00:12:00.480
Have you checked this out, Sebastian?

00:12:00.480 --> 00:12:01.480
I have seen it.

00:12:01.480 --> 00:12:05.700
And actually the author was quite active in the FastAPI community.

00:12:05.700 --> 00:12:10.440
And like, yeah, like I haven't been able to play around with the framework itself.

00:12:10.440 --> 00:12:16.080
But yeah, like I think it could be a very nice idea, a very nice middle ground for people

00:12:16.080 --> 00:12:21.160
that is already having a lot of work, already a lot of code with Django rest framework.

00:12:21.160 --> 00:12:22.560
Yeah, exactly.

00:12:22.560 --> 00:12:23.120
Exactly.

00:12:23.120 --> 00:12:29.320
So this was sent over by Marcus Sharp and Adam Parkin, who goes by Codependent Coder independently.

00:12:29.320 --> 00:12:31.100
So thank you both for sending this in.

00:12:31.100 --> 00:12:37.120
And the idea is that it's a framework for building APIs primarily based on type hints, but also

00:12:37.120 --> 00:12:38.400
with async support.

00:12:38.400 --> 00:12:40.260
And it makes use of Pydantic.

00:12:40.260 --> 00:12:44.140
And those are many of the important ingredients that make FastAPI special as well.

00:12:44.140 --> 00:12:47.980
So some of the key features are it's pretty easy to work with.

00:12:47.980 --> 00:12:50.760
It has a similar feel as FastAPI.

00:12:51.100 --> 00:12:56.120
It's high performance, partly because of Pydantic, partly because it has native async support

00:12:56.120 --> 00:12:58.420
and partly just because they did a good job there.

00:12:58.420 --> 00:12:59.740
Also fast to code.

00:12:59.740 --> 00:13:05.260
The type hints let you know what you're working with and automatically get conversions along

00:13:05.260 --> 00:13:09.200
with Pydantic, of course, does massive levels of like validation and conversion.

00:13:09.200 --> 00:13:15.300
And then it also has automatic docs with open API, formerly known as Swagger, similar to

00:13:15.300 --> 00:13:16.280
FastAPI in that regard.

00:13:16.280 --> 00:13:20.700
And the reason this is interesting, I think, is because it's Django friendly.

00:13:20.700 --> 00:13:22.540
So it has integration with Django core.

00:13:22.540 --> 00:13:24.120
It has integration with Django RRM.

00:13:24.120 --> 00:13:29.000
So if you're already got all of your stuff done in Django and you were thinking, well,

00:13:29.000 --> 00:13:33.660
I really want to have these this style of API that FastAPI brings, but I don't want to

00:13:33.660 --> 00:13:34.160
leave Django.

00:13:34.160 --> 00:13:39.140
I don't want to have to rewrite everything in SQLAlchemy and learn the async API over there

00:13:39.140 --> 00:13:39.900
and that kind of stuff.

00:13:40.020 --> 00:13:45.180
Well, here's a way to kind of like layer on APIs to your Django app, but in the zen of

00:13:45.180 --> 00:13:46.000
what Sebastian.

00:13:46.000 --> 00:13:47.240
So, yeah, I think it's pretty cool.

00:13:47.240 --> 00:13:54.500
And if you check out the performance here, you can see it's slightly faster in the single

00:13:54.500 --> 00:13:55.600
threaded version.

00:13:55.600 --> 00:13:58.880
But once you bust out async and await and it starts just crushing it.

00:13:59.060 --> 00:14:02.400
So here you can see like with 50 operations, 50 workers and so on.

00:14:02.400 --> 00:14:06.240
And what's really interesting is you see like this graph at the bottom of as you add more

00:14:06.240 --> 00:14:10.700
workers, things like Django RRM framework or Flask Marshmallow start to catch up.

00:14:10.700 --> 00:14:16.140
And my theory, looking at this graph, my intuition is what this means is the thing that it's talking

00:14:16.140 --> 00:14:22.000
to and the backend, like the database that it was talking to or something like that is starting to

00:14:22.000 --> 00:14:24.240
like not be able to take it anymore.

00:14:24.240 --> 00:14:30.260
Or the overall CPU level is just starting to like to hit a limit where it can't scale.

00:14:30.260 --> 00:14:35.280
Because it's really interesting that it's kind of just like linear number of things for or flat for

00:14:35.280 --> 00:14:35.960
the Django Ninja.

00:14:35.960 --> 00:14:40.360
And as the scale increases, it kind of gets it's normalized on that.

00:14:40.360 --> 00:14:41.000
So it would be flat.

00:14:41.000 --> 00:14:43.120
But anyway, it's a pretty interesting graph, I think there.

00:14:43.620 --> 00:14:49.140
Yeah, and then last thing, just a super quick example of here is all you got to do is create

00:14:49.140 --> 00:14:54.920
a ninja, API ninja, and then you do an API.get, give it a URL, you give it some parameters.

00:14:54.920 --> 00:14:59.480
Those parameters have types like a colon int, b colon int, and then you return a dictionary

00:14:59.480 --> 00:15:00.660
and off you go.

00:15:00.660 --> 00:15:06.820
And then you've got an API and presumably you could make this async def add, although there's

00:15:06.820 --> 00:15:07.820
really no reason to do it.

00:15:07.820 --> 00:15:09.020
You could, right?

00:15:09.020 --> 00:15:09.980
Because it supports async.

00:15:09.980 --> 00:15:13.540
Anyway, I think there's a pretty cool thing for people already doing Django.

00:15:13.540 --> 00:15:17.700
And they're like, we have so much logic in the ORM and in the other parts of our app.

00:15:17.700 --> 00:15:20.540
We just want to add in this style of API.

00:15:20.540 --> 00:15:21.180
I think this is neat.

00:15:21.180 --> 00:15:21.780
Absolutely.

00:15:21.780 --> 00:15:22.540
Yeah.

00:15:22.540 --> 00:15:23.060
Cool, cool.

00:15:23.060 --> 00:15:23.500
All right.

00:15:23.500 --> 00:15:24.620
Well, let's see.

00:15:24.620 --> 00:15:26.960
What's your first item, Sebastian?

00:15:26.960 --> 00:15:31.540
So I have Pydantic 1.8 was released.

00:15:31.540 --> 00:15:33.700
It was released one or two weeks ago.

00:15:33.700 --> 00:15:35.500
It's the latest version.

00:15:35.880 --> 00:15:37.420
And it has a bunch of interesting things.

00:15:37.420 --> 00:15:45.760
It has a hypothesis plugin for doing property-based testing, which I haven't been able to try out

00:15:45.760 --> 00:15:47.100
yet a lot.

00:15:47.100 --> 00:15:53.300
But I have heard a lot of good things about this idea of property-based testing.

00:15:53.560 --> 00:16:00.160
And in fact, there's a package for doing this type of testing, integrating hypotheses with

00:16:00.160 --> 00:16:01.060
OpenAPI.

00:16:01.060 --> 00:16:05.060
So you can test, like it was made to test FastAPI actually with these ideas.

00:16:05.060 --> 00:16:09.800
But then now there's an integrated plugin in Pydantic.

00:16:09.940 --> 00:16:11.980
So I think that can be quite interesting.

00:16:11.980 --> 00:16:18.360
And also there's now support in Pydantic directly for name tuples and for type dicts.

00:16:18.360 --> 00:16:26.820
So type dicts are these new types or type declarations to say what is the shape of a dictionary inside

00:16:26.820 --> 00:16:27.380
of Python.

00:16:27.380 --> 00:16:32.720
If you have played with TypeScript, it will be comparable to an interface or I guess, you

00:16:32.720 --> 00:16:33.740
know, languages too.

00:16:33.940 --> 00:16:41.700
But then these type dicts, the thing is that they are the official or standard way inside

00:16:41.700 --> 00:16:46.400
of Python that are part of Python to define the types of dictionaries.

00:16:46.400 --> 00:16:48.660
Because Pydantic is actually a class.

00:16:48.660 --> 00:16:54.080
So this could be, I think these type dicts will be interesting, for example, for declaring

00:16:54.080 --> 00:17:00.060
the parameters of a function that are actually a dictionary and declaring where the types that

00:17:00.060 --> 00:17:02.380
that dictionary should take, things like that.

00:17:02.380 --> 00:17:06.580
And I will expect editors to be able to have support for that.

00:17:06.580 --> 00:17:11.360
So imagine that you are passing a parameter to a dictionary and the, sorry, a parameter

00:17:11.360 --> 00:17:15.600
to a function and the parameter is a dictionary and then the editor can give you completion

00:17:15.600 --> 00:17:21.100
or the dictionary inside of the parameter that you're passing or the argument that you're

00:17:21.100 --> 00:17:21.760
passing to the function.

00:17:21.760 --> 00:17:22.360
Things like that.

00:17:22.360 --> 00:17:24.260
I think type dicts will help a lot.

00:17:24.260 --> 00:17:27.440
And then now you can use them inside of Pydantic models.

00:17:27.440 --> 00:17:28.360
And I think that's pretty cool.

00:17:28.360 --> 00:17:34.480
And this other one is the Pydantic has support for annotated types, which is another

00:17:34.480 --> 00:17:35.720
of these types.

00:17:35.720 --> 00:17:42.340
So annotated is one of these things that you import from typing the same way that you will

00:17:42.340 --> 00:17:47.600
import a optional or that you will import a union or that you will import the type for

00:17:47.600 --> 00:17:48.180
lists.

00:17:49.180 --> 00:17:49.960
This is cool.

00:17:49.960 --> 00:17:52.260
I was wondering how you would do stuff like this.

00:17:52.260 --> 00:17:58.360
If you could say add a default value to a Pydantic model or to add a simple constraints.

00:17:58.360 --> 00:17:58.920
Yeah.

00:17:58.920 --> 00:18:04.420
So the thing is that with, with, with Pydantic and with FastAPI, you have a way to declare

00:18:04.420 --> 00:18:09.980
like before annotated exist that you have a way to declare those things by setting the default

00:18:09.980 --> 00:18:15.820
value as a call to Pydantic field, which is a special function.

00:18:15.820 --> 00:18:21.420
Or if as API, you could call, for example, a, a, a, a, the function query, which is a special

00:18:21.420 --> 00:18:26.060
function that returns a special object that has all the information, including metadata for

00:18:26.060 --> 00:18:30.960
validation and maybe like the title or the description of their specific parameter, things like that.

00:18:31.200 --> 00:18:38.700
But then the issue with that approach is that we are taking the place in the, in the declaration

00:18:38.700 --> 00:18:40.720
of the parameter inside of the function.

00:18:40.720 --> 00:18:43.640
We are taking the place that will be used by the default value.

00:18:43.640 --> 00:18:51.020
And we are like playing around with that default value inside of the function signature, inside

00:18:51.020 --> 00:18:52.800
of the function declaration of parameters.

00:18:52.800 --> 00:18:56.900
So it's actually not like the most correct way to do it.

00:18:56.900 --> 00:19:00.900
It's, it's, it's, it's kind of intuitive and it works quite well with Pydantic and FastAPI.

00:19:00.900 --> 00:19:01.400
Okay.

00:19:01.400 --> 00:19:05.700
But in terms of types, it's not very, very explicit.

00:19:05.700 --> 00:19:12.240
And now with this new annotated type, you can put the actual type that the parameter has,

00:19:12.240 --> 00:19:14.060
like let's say it's a string.

00:19:14.060 --> 00:19:21.080
And then you can also put the extra metadata that will go for Pydantic or for FastAPI inside

00:19:21.080 --> 00:19:25.800
of the same annotated, a generic type is the name.

00:19:25.800 --> 00:19:31.640
So the same way that you will put, let's say, annotate a type that is additional, that has

00:19:31.640 --> 00:19:35.560
strings as keys, and then as values, it has integers.

00:19:35.560 --> 00:19:41.360
Then instead of that, you will put this annotated thing and declare the type of the parameter

00:19:41.360 --> 00:19:44.960
and this extra metadata that's going to include like validation and a bunch of things.

00:19:44.960 --> 00:19:50.600
And then the default value can be kept for the actual default value of the parameter.

00:19:50.600 --> 00:19:56.140
So that could be very useful, especially if you are calling the same functions, for example,

00:19:56.140 --> 00:20:00.160
for FastAPI dependencies and you're calling the same functions in other places.

00:20:00.160 --> 00:20:06.240
And I think that, that, that can be very powerful and very, very useful for reusing coding even

00:20:06.240 --> 00:20:06.880
more places.

00:20:06.880 --> 00:20:07.420
Yeah.

00:20:07.420 --> 00:20:11.560
When I first looked at this, I thought it was this annotated thing was the value you were

00:20:11.560 --> 00:20:16.600
setting like SQLAlchemy would be, or Django ORM or something where you say like name equals

00:20:16.600 --> 00:20:20.340
an annotated thing, but that's actually the type it's named colon.

00:20:20.340 --> 00:20:25.160
This really interesting annotated thing with lots of constraints equals some potential default

00:20:25.160 --> 00:20:26.500
value or equals nothing.

00:20:26.500 --> 00:20:26.660
Right.

00:20:26.660 --> 00:20:27.940
You just don't even have to set a value.

00:20:27.940 --> 00:20:28.460
Yeah.

00:20:28.460 --> 00:20:28.840
Yeah.

00:20:28.840 --> 00:20:30.440
And like, I don't know.

00:20:30.440 --> 00:20:33.620
I feel the syntax might look a little bit weird.

00:20:33.620 --> 00:20:40.620
It's not necessarily like the most intuitive, but it's like the most correct at the same time.

00:20:40.980 --> 00:20:46.400
So in, in cases where like the strict type correctness is important, I think this is,

00:20:46.400 --> 00:20:48.100
this could be quite useful.

00:20:48.100 --> 00:20:48.600
Yeah.

00:20:48.600 --> 00:20:53.180
So another thing that I, this is not in the new release, but I'd like to hear your thoughts

00:20:53.180 --> 00:20:53.500
on it.

00:20:53.500 --> 00:20:54.460
I, what is it called?

00:20:54.460 --> 00:20:55.460
Validation.

00:20:55.460 --> 00:20:56.480
Is that what it's?

00:20:56.480 --> 00:20:59.660
There's a type with like runtime validation.

00:20:59.720 --> 00:21:03.720
I think this, this thing here is you say at validate arguments.

00:21:03.720 --> 00:21:08.420
Have you seen this for actually going, you know, instead of just suggesting that it's

00:21:08.420 --> 00:21:13.300
a string and an integer, it will actually make sure that it's a string and an integer at runtime.

00:21:13.300 --> 00:21:14.300
Have you played with this?

00:21:14.300 --> 00:21:14.820
What are your thoughts?

00:21:14.820 --> 00:21:16.120
I haven't played with it.

00:21:16.120 --> 00:21:21.600
Like I remember when someone was talking about it and it was super exciting because it's also

00:21:21.600 --> 00:21:28.660
the very, it's the same idea of what, what FastAPI is doing or similarly what type, which

00:21:28.660 --> 00:21:33.320
is like the equivalent of FastAPI for building command line applications, the equivalent of

00:21:33.320 --> 00:21:39.320
what they do, which is take a signature in the, take the parameters from the function and use

00:21:39.320 --> 00:21:41.820
those parameters to do validation.

00:21:42.400 --> 00:21:44.860
I think that's very interesting and very powerful.

00:21:44.860 --> 00:21:51.200
I just haven't used it yet because I use Pydantic most of the time with FastAPI and in fast

00:21:51.200 --> 00:21:56.040
API, there's no need to, to add the specific decorator because FastAPI is already doing

00:21:56.040 --> 00:21:56.440
that.

00:21:56.440 --> 00:22:02.320
But for other use cases where, where it's not really using FastAPI, but just Pydantic standalone

00:22:02.320 --> 00:22:04.140
because Pydantic is awesome by itself.

00:22:04.140 --> 00:22:06.660
I think this will be very, very powerful.

00:22:06.660 --> 00:22:07.180
Yeah.

00:22:07.180 --> 00:22:07.620
Yeah.

00:22:07.620 --> 00:22:08.140
Totally agree.

00:22:08.140 --> 00:22:08.660
Okay, cool.

00:22:08.660 --> 00:22:10.580
Anything else you want to add on this before we move on?

00:22:10.580 --> 00:22:11.520
Kick it back to Brian.

00:22:11.520 --> 00:22:17.240
No, I think that, that, that was the highlight I had because I think it's pretty cool.

00:22:17.240 --> 00:22:21.540
Well, we brushed by this quickly, but I was curious, not about this, but you mentioned

00:22:21.540 --> 00:22:23.500
a FastAPI does validation.

00:22:23.500 --> 00:22:26.460
I just, we went by that quickly, but is that true?

00:22:26.460 --> 00:22:31.840
Can you, for FastAPI, can I say that this, this data or this, you know, data point that's

00:22:31.840 --> 00:22:35.520
coming in has to be in a certain range of integers or something like that?

00:22:35.520 --> 00:22:36.160
Absolutely.

00:22:36.160 --> 00:22:41.080
Like all the validations that you do, that you can do with Pydantic, you can do them with

00:22:41.080 --> 00:22:41.500
FastAPI.

00:22:41.500 --> 00:22:45.800
And it's like actually like quite extensive, the things that you can do.

00:22:45.800 --> 00:22:50.760
You can say that you want to validate against a regular expression or that you want to have

00:22:50.760 --> 00:22:55.320
a minimum number and a maximum number, or that you want to have, like, I don't know, you could

00:22:55.320 --> 00:22:59.840
even write like custom types of validations for the things that you receive.

00:23:00.160 --> 00:23:04.880
And because Pydantic is based on the same standard Python type annotations, you could do these

00:23:04.880 --> 00:23:07.840
validations even for deeply nested data structures.

00:23:07.840 --> 00:23:16.560
So you can say like, my request of this endpoint is going to receive a list that contains dictionaries

00:23:16.560 --> 00:23:22.320
that inside contain this key tag that contains the strings and this other one that has sub-dictionaries

00:23:22.320 --> 00:23:27.520
and sub-lists and, you know, like a very complex, deeply nested tree of data.

00:23:27.520 --> 00:23:28.240
That's awesome.

00:23:28.240 --> 00:23:31.200
And you can declare all that and have all that validated so that--

00:23:31.200 --> 00:23:32.240
That's awesome.

00:23:32.240 --> 00:23:39.200
--when your code executes, when the code that you wrote executes, it's a FastAPI already took care of

00:23:39.200 --> 00:23:42.320
making sure that the data that you declare is the data that you received.

00:23:42.320 --> 00:23:45.680
Your code will never execute with invalid data.

00:23:45.680 --> 00:23:46.800
That's the idea.

00:23:46.800 --> 00:23:46.800
Yeah.

00:23:46.800 --> 00:23:47.280
Yeah.

00:23:47.280 --> 00:23:48.880
It's so nice in that regard.

00:23:48.880 --> 00:23:53.280
You just like, by the time it gets here, I know it's all been converted and validated

00:23:53.280 --> 00:23:55.840
at least as much as the model is going to validate it for me.

00:23:55.840 --> 00:23:57.120
You don't have to worry about that.

00:23:57.120 --> 00:23:59.360
So it's great to push that to somewhere else.

00:23:59.360 --> 00:23:59.920
Yeah.

00:23:59.920 --> 00:24:07.680
And on the other side, which is also a great feature of Pydantic, the validation shows the

00:24:07.680 --> 00:24:10.640
errors exactly in the place where they are.

00:24:10.640 --> 00:24:15.840
And when you get that, it's like, yes, I can see exactly where is my data wrong.

00:24:15.840 --> 00:24:19.280
So you can see which index in the list was incorrect.

00:24:19.280 --> 00:24:21.920
And inside of that index, which key was incorrect.

00:24:21.920 --> 00:24:24.400
And inside of that, what was the exact error?

00:24:24.400 --> 00:24:28.560
And see like, oh, I had to put a string in another object here, not a JSON object.

00:24:28.560 --> 00:24:28.560
Right.

00:24:28.560 --> 00:24:34.320
And what you mean is like, if I have a Pydantic model and it says it has a list of customers

00:24:34.320 --> 00:24:38.240
and there's three customers in the list, but the third customer that was submitted as part

00:24:38.240 --> 00:24:40.240
of the JSON body has an error.

00:24:40.240 --> 00:24:45.520
It'll say in the customers in index three on this field is the problem.

00:24:45.520 --> 00:24:46.880
Not just the name is required.

00:24:46.880 --> 00:24:47.760
Like, oh, great.

00:24:47.760 --> 00:24:48.320
What does this mean?

00:24:48.320 --> 00:24:49.680
Right.

00:24:49.680 --> 00:24:50.400
Exactly.

00:24:50.400 --> 00:24:51.440
I don't know.

00:24:51.440 --> 00:24:57.440
I don't know how you do to make these examples audible and understandable at the same time.

00:24:57.440 --> 00:24:58.400
It's a difficult.

00:24:58.400 --> 00:25:00.560
That's such a skill.

00:25:00.560 --> 00:25:02.000
Yeah.

00:25:02.000 --> 00:25:04.800
We've been doing it for 223 episodes, I guess.

00:25:04.800 --> 00:25:06.480
Nice.

00:25:06.480 --> 00:25:07.120
All right.

00:25:07.120 --> 00:25:08.000
Brian.

00:25:08.000 --> 00:25:08.400
Yeah.

00:25:08.400 --> 00:25:10.960
So something else that's awesome is Datadog.

00:25:10.960 --> 00:25:14.160
So this episode of Python Bytes is brought to you by Datadog.

00:25:14.160 --> 00:25:20.160
Are you having trouble visualizing latency, CPU, and memory bottlenecks in your app and not sure

00:25:20.160 --> 00:25:22.160
where the issue is coming from or how to solve it?

00:25:22.160 --> 00:25:27.840
Well, Datadog seamlessly correlates logs and traces at the level of individual requests,

00:25:27.840 --> 00:25:31.040
allowing you to quickly troubleshoot your Python application.

00:25:31.040 --> 00:25:35.680
Plus, their continuous profiler allows you to find the most resource-consuming parts in your

00:25:35.680 --> 00:25:40.080
production code all the time at scale, at any scale, with minimal overhead.

00:25:40.080 --> 00:25:43.120
Be the hero that got the app back on track at your company.

00:25:43.120 --> 00:25:49.440
Get started today with a free trial at pythonbytes.fm/datadog or just click the link in your podcast

00:25:49.440 --> 00:25:50.640
player show notes.

00:25:50.640 --> 00:25:50.960
Yes.

00:25:50.960 --> 00:25:52.320
Check out our show notes.

00:25:52.320 --> 00:25:53.680
And thank you, Datadog.

00:25:53.680 --> 00:25:54.000
Yeah.

00:25:54.000 --> 00:25:54.640
Thanks, Datadog.

00:25:54.640 --> 00:25:57.280
And get a cool little Datadog t-shirt as well.

00:25:57.280 --> 00:26:00.000
Speaking of cool, let me talk about the next item here.

00:26:00.000 --> 00:26:02.400
I guess I'm next up on the list here.

00:26:02.400 --> 00:26:06.160
So this item comes to us partially from Will Shanks.

00:26:06.160 --> 00:26:10.160
He sent me the Python side, but I wanted to highlight this sort of broader thing because

00:26:10.160 --> 00:26:12.000
I think it's pretty interesting.

00:26:12.000 --> 00:26:15.760
The first part, let me just tell you the title of the article, the piece of news is,

00:26:15.760 --> 00:26:19.840
Google and Microsoft back Python and Rust programming languages.

00:26:19.840 --> 00:26:25.200
And they both, I believe, do stuff with each, but it's primarily Google backs Python, Microsoft

00:26:25.200 --> 00:26:26.160
backs Rust.

00:26:26.160 --> 00:26:30.240
But the overall trend is part of the story that I think is interesting.

00:26:30.240 --> 00:26:36.160
So they both come along to make significant contributions to the various languages.

00:26:36.160 --> 00:26:42.160
And part of the trade off, I believe there is that they'll have some say or some ability

00:26:42.160 --> 00:26:45.840
to influence where the direction of these projects are going.

00:26:45.840 --> 00:26:51.760
Like, Hey, for example, Google donated $350,000 or it's not quite the right way to put it.

00:26:51.760 --> 00:26:52.720
That's what the article says.

00:26:52.720 --> 00:26:59.760
Google sponsored the PSF at the visionary sponsor level, which has a price tag of $350,000.

00:26:59.760 --> 00:27:03.920
And the goal is, this is the first company to do so, by the way.

00:27:03.920 --> 00:27:10.960
And so they're investing in improved PyPI malware detection and better foundational tools and services

00:27:10.960 --> 00:27:13.040
like pip type of things and so on.

00:27:13.040 --> 00:27:17.680
And they're hiring a CPython developer in residence for 2021.

00:27:17.680 --> 00:27:21.760
I don't know if that position is still open or if there's applications, but anyway, I think that's

00:27:21.760 --> 00:27:22.240
pretty awesome.

00:27:22.240 --> 00:27:22.640
Yeah.

00:27:22.640 --> 00:27:25.360
So yeah, I'm really happy for this.

00:27:25.360 --> 00:27:25.840
That's great.

00:27:25.840 --> 00:27:30.080
I do feel like there's a hundred other companies that should be doing the same thing.

00:27:30.080 --> 00:27:31.760
You know, Bank of America.

00:27:31.760 --> 00:27:32.160
Hello.

00:27:32.160 --> 00:27:35.760
5,000 people working on a Python project there.

00:27:35.760 --> 00:27:37.120
5,000 Python developers.

00:27:37.120 --> 00:27:40.240
Surely some of their wellbeing depends on the wellbeing of Python.

00:27:40.240 --> 00:27:44.640
And, and you'll bank some places like that have at least $300,000 to suspend this

00:27:44.640 --> 00:27:45.920
been on it per year.

00:27:45.920 --> 00:27:46.480
I'm pretty sure.

00:27:46.480 --> 00:27:53.120
You know what I find funny about that, that, you know, like these huge companies, these huge

00:27:53.120 --> 00:27:56.240
corporations, they are depending on Python and all this stuff.

00:27:56.240 --> 00:28:02.720
And they, they, for example, they are for sure running Python and CI and pip install a bunch

00:28:02.720 --> 00:28:03.600
of things.

00:28:03.600 --> 00:28:08.480
And they are probably having some issues with the new resolver and pip install and taking

00:28:08.480 --> 00:28:13.920
a bunch of time and like having a lot of time by their developers waiting for the resolver

00:28:13.920 --> 00:28:14.960
to handle things.

00:28:14.960 --> 00:28:21.680
And the resolver is having to download all the packages that, that match some range

00:28:21.680 --> 00:28:26.720
to be able to extract the metadata, to be able to compute and to be able to do all the backtracking,

00:28:26.720 --> 00:28:27.440
all the stuff.

00:28:27.440 --> 00:28:42.080
And if the PSF was better funded, they, they already have the feature request and they already have the idea and the objective to include the metadata of those packages in by PI.

00:28:42.080 --> 00:28:47.120
So that people ask the API, where are the versions instead of downloading all the packages.

00:28:47.120 --> 00:28:47.520
Yeah.

00:28:47.520 --> 00:28:49.040
So it's like things that.

00:28:49.040 --> 00:28:55.520
That seems more efficient, like a, a hundred kilobyte, a hundred byte JSON document instead of megs of packages.

00:28:55.520 --> 00:28:56.320
Exactly.

00:28:56.320 --> 00:29:09.040
And, and it's just like, you know, like it will probably just be like a little funding, just, I don't know, a couple of full-time developers working a lot more on that than, than, than a lot of, volunteering.

00:29:09.040 --> 00:29:11.920
I'm like with, with, yeah.

00:29:11.920 --> 00:29:20.800
Like I feel if, it was better from that they will, they will save a ton of money and time spent by their developers.

00:29:20.800 --> 00:29:24.000
If they, if they, if they, the whole PSF was better from it.

00:29:24.000 --> 00:29:24.560
Absolutely.

00:29:24.560 --> 00:29:27.200
I mean, that's just one small example, right?

00:29:27.200 --> 00:29:27.600
Yeah.

00:29:27.600 --> 00:29:28.000
Yeah.

00:29:28.000 --> 00:29:28.000
Yeah.

00:29:28.000 --> 00:29:30.720
Another one is maybe, maybe we want higher performance.

00:29:30.720 --> 00:29:36.160
Like the survey that Brian covered was one of the top requested features was better performance.

00:29:36.160 --> 00:29:41.840
Well, if we had, you know, 20 companies each donate a million dollars, I bet we could get a pretty awesome jit.

00:29:41.840 --> 00:29:43.760
Build or something like that.

00:29:43.760 --> 00:29:44.080
Right.

00:29:44.080 --> 00:29:48.160
I mean, there's, there's like clear links back, to the wellbeing.

00:29:48.160 --> 00:29:53.360
So anyway, awesome Google and Microsoft as well for the rest side of things.

00:29:53.360 --> 00:29:53.920
Absolutely.

00:29:53.920 --> 00:30:00.560
But it's, it's the, I think part of the story is that this is a story, you know, like that this is big news.

00:30:00.560 --> 00:30:02.640
It's awesome, but it should be like, oh yeah.

00:30:02.640 --> 00:30:05.520
And the other 20 or the other a hundred companies.

00:30:05.520 --> 00:30:05.760
Right.

00:30:05.760 --> 00:30:06.160
Yeah.

00:30:06.160 --> 00:30:11.760
So the people that listen to, I mean, Microsoft and, Google know that they, that they,

00:30:11.760 --> 00:30:12.960
use Python and rust.

00:30:12.960 --> 00:30:19.120
But I think there's a lot of people listening to this podcast that know there's a need there, but they're, they're just engineers.

00:30:19.120 --> 00:30:25.760
And there's the people at the top of the company really might not know how much their company depends on these languages.

00:30:25.760 --> 00:30:26.240
Yeah.

00:30:26.240 --> 00:30:29.120
And so I actually, nice.

00:30:29.120 --> 00:30:35.520
I actually would like to, I'd like to have some sort of, how to start that conversation document.

00:30:35.520 --> 00:30:47.040
Something like if I'm, if I'm at a company, how do I start that conversation with my lead leaders to say, how, you know, how do I talk to that to say, Hey, we use Python a lot.

00:30:47.040 --> 00:30:49.280
Can we contribute to the PSO?

00:30:49.280 --> 00:30:49.600
Yeah.

00:30:49.600 --> 00:30:49.840
Yeah.

00:30:49.840 --> 00:30:53.120
I spoke to, I think it was Peter Yang about this.

00:30:53.120 --> 00:30:54.160
no, sorry.

00:30:54.160 --> 00:30:56.360
Peter wing from, Anaconda.

00:30:56.360 --> 00:31:00.480
And he has such a good insight and ideas on, on this whole topic.

00:31:00.480 --> 00:31:11.840
one of the challenges is I think it was, he, him who said this, like they don't have, there's not a place on a, you know, a profits and loss accounting system for charity.

00:31:11.840 --> 00:31:15.180
There's a place for sponsorship where you get something back.

00:31:15.180 --> 00:31:16.680
There's a place for advertising.

00:31:16.680 --> 00:31:20.660
There's a place for it, but just charity alone doesn't quite work.

00:31:20.660 --> 00:31:21.540
So I don't know.

00:31:21.540 --> 00:31:26.560
I think that's part of the story is like kind of got to fit into that world where like, well, we could support it.

00:31:26.560 --> 00:31:31.460
And in this sense that we've been talking about, yeah, you'll get something back, but we need a tangible, we get something back.

00:31:31.460 --> 00:31:34.740
I don't know what that is, but I think there's a little bit of a mismatch there.

00:31:34.740 --> 00:31:36.940
Anyway, just a couple of shout outs to some more.

00:31:36.940 --> 00:31:37.720
We got Salesforce.

00:31:37.720 --> 00:31:41.680
We got Fastly, Bloomberg, Azure, Microsoft, Capital One.

00:31:41.680 --> 00:31:46.580
You'll even find TalkBite on training down near the bottom of that list, sponsoring the PSF over there.

00:31:46.580 --> 00:31:47.540
So that's cool.

00:31:47.540 --> 00:31:56.540
But also just to round this out, Microsoft is doing interesting stuff with Rust around, using it to basically replace where they're using it.

00:31:56.540 --> 00:31:58.360
C and low level stuff like that.

00:31:58.360 --> 00:32:05.220
So, they've joined, Mozilla, AWS, Huawei, and Google as founding members of the Rust Foundation as well.

00:32:05.220 --> 00:32:06.760
And I think they donated something.

00:32:06.760 --> 00:32:09.040
Yeah, no, I don't know the numbers there, what that means.

00:32:09.040 --> 00:32:11.240
But anyway, thanks, Will Shanks, for sending that over.

00:32:11.240 --> 00:32:17.280
And, thank you, Google and Microsoft and other companies we gave a shout out to for supporting these projects and communities.

00:32:17.280 --> 00:32:18.440
Semantic versions.

00:32:18.440 --> 00:32:19.380
Let's talk about that.

00:32:19.380 --> 00:32:25.660
Yeah, so, yeah, so I actually don't know if FastAPI is using Semver or Calver.

00:32:25.660 --> 00:32:27.400
Sebastian, what do you got?

00:32:27.400 --> 00:32:36.500
I think FastAPI will match in what he describes as the YOLO zone in that article.

00:32:36.500 --> 00:32:38.200
Okay.

00:32:38.200 --> 00:32:39.400
So what version are you on?

00:32:39.620 --> 00:32:41.080
So it's 0.something.

00:32:41.080 --> 00:32:52.040
The thing is that I'm managing it as if it was like very strict, same version where I'm, where I'm handling the bumps in the, in the, in the versions.

00:32:52.040 --> 00:32:55.660
But all, it's all, 0.something still.

00:32:55.660 --> 00:33:04.640
Because I want to add some features and do some, the freedom to do some changes, to the, to the API to have like the best design possible.

00:33:04.640 --> 00:33:11.840
Also because I want to, to release the one version after Ubicor and Starlette have the one version.

00:33:11.840 --> 00:33:12.700
Yeah.

00:33:12.700 --> 00:33:15.380
I think, I think it's what he describes as that.

00:33:15.380 --> 00:33:22.380
So, yeah, so what we're talking about is an article, from, Hinnick saying, semantic versioning will not save you.

00:33:22.380 --> 00:33:28.460
So the idea with semantic with, versions is you've, is you've got like a three digit number.

00:33:28.460 --> 00:33:32.960
and you know, and there's a major, minor, micro.

00:33:32.960 --> 00:33:44.800
And the idea is if, if the, as long as the major number doesn't change and you're using this, this package or this library or this tool, it's, it's not going to break you if it goes up.

00:33:44.800 --> 00:33:48.800
So if you, if you go from 1.9 to 1.10, you can upgrade.

00:33:48.800 --> 00:33:49.460
It's fine.

00:33:49.460 --> 00:33:54.200
and nothing will break, but there's a, there's a whole bunch of problems with that.

00:33:54.200 --> 00:34:01.180
for one, well, it's that, that implication is just, it's not really true all the time.

00:34:01.180 --> 00:34:05.880
I mean, you don't really know it's, it's often, there's no new features, but there'll be something fixes.

00:34:05.880 --> 00:34:07.160
There'll be fixes and things.

00:34:07.160 --> 00:34:09.520
And you might actually depend on the broken behaviors.

00:34:09.520 --> 00:34:14.700
So there's, in practice, you can't really just upgrade willy nilly.

00:34:14.700 --> 00:34:24.440
So in practice, you have to be like, if you're depending on a package and it changes its version, you have to, you have to test and have good coverage for your own code to start with.

00:34:24.440 --> 00:34:25.860
And you should pin your dependencies.

00:34:25.860 --> 00:34:34.180
So you don't just automatically update to the newest one, but you should also try to regularly keep updated to the new changes.

00:34:34.180 --> 00:34:37.880
And you have to, you have to do it in a try and try basis.

00:34:37.880 --> 00:34:43.260
So you, you like update the new version and then try it, and run your tests.

00:34:43.260 --> 00:34:45.400
And if they pass, then repin the new versions.

00:34:45.400 --> 00:34:53.340
And if they don't pass, well, you've got to have to either, you know, in below it or block that version or something.

00:34:53.340 --> 00:34:55.900
there are, there are messy things that happen.

00:34:55.920 --> 00:34:56.620
yeah.

00:34:56.620 --> 00:34:58.580
And it's getting more complicated with the new resolver.

00:34:58.580 --> 00:35:05.960
Like if you say, I must have, you know, pedantic below some version and then FastAPI comes along and says, well, I must have pedantic above a higher version.

00:35:05.960 --> 00:35:08.580
Well, whatever that other thing needed can't be used with fast.

00:35:08.580 --> 00:35:12.620
Like there's these, these intervals that no longer intersect that can become challenging.

00:35:13.040 --> 00:35:13.220
Yeah.

00:35:13.220 --> 00:35:20.940
And like, let's say you've got an application, you're in the application, you're the only user of it or other people are, but you're not, nobody's importing it.

00:35:20.940 --> 00:35:25.360
Then you can pin directly all of your dependencies and you can test it and it's great.

00:35:25.360 --> 00:35:38.400
But if you're, if you're a library and you're, somebody is going to import you, you can't really just actually just pin everything because, somebody might like, let's say I'm, I'm pulling in requests.

00:35:38.400 --> 00:35:41.360
Somebody else might be pulling in me and requests.

00:35:41.540 --> 00:35:50.860
so you pinning it hardcore is you're, like you said, with the, with the dependency manager or the dependency resolver, that'll break.

00:35:50.860 --> 00:35:54.680
So you've got to be a little bit broad so that these overlaps happen.

00:35:54.680 --> 00:35:56.040
but okay.

00:35:56.040 --> 00:36:01.260
So the consequences of this just nightmare is mayhem and, version conflicts.

00:36:01.260 --> 00:36:10.980
Like we described, let's say I, my package says I have to have requests something and somebody else X and somebody else says, oh, well, I need to request version Y in mind.

00:36:10.980 --> 00:36:13.580
and that's, it's just going to be a mess.

00:36:13.580 --> 00:36:20.300
the, so all of these promises, the other, other subheading for, the promises

00:36:20.300 --> 00:36:25.480
for Semver is that if you're on zero at the beginning, you can change it all you want.

00:36:25.480 --> 00:36:27.520
So there's no promises on zero over.

00:36:27.520 --> 00:36:30.200
If it's zero dot something, all bets are off.

00:36:30.200 --> 00:36:31.720
You can change the API.

00:36:31.720 --> 00:36:33.380
You can completely break things.

00:36:33.380 --> 00:36:35.780
you can completely change the API.

00:36:35.780 --> 00:36:37.280
So nothing before work.

00:36:37.280 --> 00:36:48.320
and, in, in practice that doesn't happen, but, there are times where, in the, there's a, it's a lot of people are stuck in the zero over.

00:36:48.480 --> 00:36:53.040
But you, in reality, the first few releases really are up in the air.

00:36:53.040 --> 00:36:55.920
You're not sure what's going to work and what's going to not, not work.

00:36:55.920 --> 00:37:00.300
But after a while, zero over just starts to be just there.

00:37:00.480 --> 00:37:03.800
And you really should have been at one because everybody's using it.

00:37:03.800 --> 00:37:05.720
but anyway, so.

00:37:05.720 --> 00:37:06.140
Yeah.

00:37:06.140 --> 00:37:07.320
And we covered that whole thing.

00:37:07.320 --> 00:37:08.620
I think it was my mother.

00:37:08.620 --> 00:37:13.920
I mean, I can't remember about the whole zero over thing and calling, calling places out.

00:37:13.920 --> 00:37:15.220
yeah.

00:37:15.220 --> 00:37:19.700
I mean, it's fine to have it, but like some of these projects had been out for 15 years and there's still zero dot something.

00:37:19.700 --> 00:37:20.100
Right.

00:37:20.100 --> 00:37:20.400
Yeah.

00:37:20.400 --> 00:37:25.500
Like react was used by everyone before they released the first one beta.

00:37:25.500 --> 00:37:26.240
Exactly.

00:37:26.240 --> 00:37:26.800
Exactly.

00:37:26.800 --> 00:37:27.480
Interesting.

00:37:27.480 --> 00:37:28.080
Yeah.

00:37:28.080 --> 00:37:47.580
You know, it's quite fun that, I don't know, some months ago, I updated a little bit, a little piece in FastAPI of some corner case that I had for some specific workaround for SQLAlchemy that didn't import SQLAlchemy, but excluded so much with some little thing over there.

00:37:47.580 --> 00:37:52.420
And it was like deprecated, not used in the latest versions and not anything.

00:37:52.420 --> 00:37:57.520
And I just removed it because it was there for a long time and helped break loose.

00:37:57.980 --> 00:38:05.100
I had an issue that had like, I don't know, tens of, of thumbs up.

00:38:05.100 --> 00:38:13.120
I tracked the issue, connected to the repository at Netflix that was using FastAPI for the, yeah.

00:38:13.120 --> 00:38:13.680
And I, yeah.

00:38:13.680 --> 00:38:21.240
Anyway, I had to release something quickly to get the book back because people were already depending on that.

00:38:21.500 --> 00:38:22.540
And it's like, yeah.

00:38:22.540 --> 00:38:22.560
Yeah.

00:38:22.560 --> 00:38:22.620
Yeah.

00:38:22.620 --> 00:38:30.540
Well, you have this problem that you have so many consumers of, I mean, 12% of all web frameworks are FastAPI at the moment.

00:38:30.540 --> 00:38:33.320
That's a lot of people using your library touching the corners.

00:38:33.320 --> 00:38:33.880
Yeah.

00:38:33.880 --> 00:38:34.440
Absolutely.

00:38:35.040 --> 00:38:35.160
Yeah.

00:38:35.160 --> 00:38:35.320
Yeah.

00:38:35.320 --> 00:38:42.320
So the last thing I wanted to touch on with this is, I do like, Hennix, instructions on what you should do about this.

00:38:42.320 --> 00:38:53.720
You should have testing, but one of the things that we didn't bring up yet so far is if you test something against a update and it doesn't work, it might not be an intentional break in the API or the behavior.

00:38:54.220 --> 00:39:01.180
look into it and maybe notify the maintainers that there's, there's a, that you are depending on some behavior that it broke.

00:39:01.180 --> 00:39:04.160
Almost all this stuff is on GitHub and you can file an issue.

00:39:04.160 --> 00:39:04.600
Yeah.

00:39:04.600 --> 00:39:06.240
potentially or something like that.

00:39:06.240 --> 00:39:07.500
And don't, don't just get mad.

00:39:07.500 --> 00:39:09.180
People didn't break you on purpose.

00:39:09.180 --> 00:39:10.860
So be nice.

00:39:10.860 --> 00:39:14.700
Start out, start out with a, a generosity in your thought.

00:39:14.700 --> 00:39:16.700
So there's a whole bunch of comments in the live stream.

00:39:16.700 --> 00:39:16.980
Thank you.

00:39:16.980 --> 00:39:19.520
I'm going to just try to like circle back on a few things.

00:39:19.760 --> 00:39:28.320
One Magnus asks, how do you say or talk about, you know, verbally the square brackets and pydentic or even typing just iterable square bracket int bracket.

00:39:28.320 --> 00:39:35.140
I've always said interval of int, just like you would use for generics or, templates and C++ like interval of it.

00:39:35.140 --> 00:39:35.560
I don't know.

00:39:35.560 --> 00:39:36.220
What do you guys say?

00:39:36.220 --> 00:39:37.980
I have no idea.

00:39:37.980 --> 00:39:38.880
I will ask.

00:39:38.880 --> 00:39:44.180
I believe this key or maybe you could say like, what is the actual term?

00:39:44.180 --> 00:39:47.040
I think it's one of those down there that doesn't have a name yet.

00:39:47.040 --> 00:39:47.780
I don't know.

00:39:47.780 --> 00:39:48.180
Yeah.

00:39:48.180 --> 00:39:48.360
Yeah.

00:39:48.360 --> 00:39:55.640
And then, Dean has an interesting comment on, versioning Brian talking, talking about versioning.

00:39:55.640 --> 00:39:56.860
Why is Brian not updated Chrome?

00:39:56.860 --> 00:39:58.260
There's a big update button right there.

00:39:58.260 --> 00:40:04.520
And then, this one for you, Sebastian, although I believe we touched on this RJL a little bit ago.

00:40:04.520 --> 00:40:07.140
any chance to ask a FastAPI question?

00:40:07.140 --> 00:40:10.600
Will it ever become a web server like Django or Flask more than an API engine?

00:40:10.600 --> 00:40:11.780
yeah, absolutely.

00:40:12.140 --> 00:40:19.420
So the FastAPI will, you can use, you can do everything that you can do with Flask or Django with FastAPI.

00:40:19.420 --> 00:40:22.680
You can render Jinja templates in the backend if you want.

00:40:22.680 --> 00:40:32.420
FastAPI will not include an ORM by default because, that will compromise on tying it to a database and to a type of database.

00:40:32.420 --> 00:40:32.920
Right, right, right.

00:40:32.920 --> 00:40:34.980
And well, Flask doesn't as well, right?

00:40:34.980 --> 00:40:37.160
Like Flask says go pick Mongo.

00:40:37.160 --> 00:40:37.920
You're right.

00:40:37.920 --> 00:40:38.300
You're right.

00:40:38.300 --> 00:40:39.940
Go pick SQLAlchemy, something like that.

00:40:39.940 --> 00:40:40.520
You're right.

00:40:40.920 --> 00:40:41.980
Actually, I don't know.

00:40:41.980 --> 00:40:46.640
Comparing to Flask, FastAPI will be pretty much comparable.

00:40:46.640 --> 00:40:48.480
I think it's super comparable.

00:40:48.480 --> 00:41:00.360
And, you know, I also, I created the decorators that you can put on the templates to, on the, of course, you can have endpoints to have like a chameleon template or a flat, sorry, Jinja 2 template.

00:41:00.440 --> 00:41:02.520
And then, yeah, I'm actually working on a course.

00:41:02.520 --> 00:41:12.660
I haven't told you, Sebastian, the course I'm going to release is building, proper web apps with FastAPI plus APIs, like sort of factoring that stuff in and like doing forums and stuff like that.

00:41:12.660 --> 00:41:13.200
Nice.

00:41:13.200 --> 00:41:13.720
That's very cool.

00:41:13.720 --> 00:41:14.780
So yeah, it'd be fun.

00:41:14.780 --> 00:41:15.120
Yeah.

00:41:15.120 --> 00:41:15.480
All right.

00:41:15.480 --> 00:41:16.120
So cool.

00:41:16.120 --> 00:41:18.640
RJL likes the ORM news.

00:41:18.640 --> 00:41:20.060
yeah, you can pick that.

00:41:20.060 --> 00:41:26.560
And then also, Sebastian, you had such a good tweet a while ago and, Robert Robinson wants to just touch on that.

00:41:26.560 --> 00:41:31.940
When will it be possible to have four years of experience with FastAPIs as companies are still yearning for it?

00:41:31.940 --> 00:41:32.880
Tell people about your tweet.

00:41:32.880 --> 00:41:35.080
You know, it's fun.

00:41:35.080 --> 00:41:39.680
I tweeted something for, for those that maybe probably can see it.

00:41:39.680 --> 00:41:42.480
I tweeted something, half a year ago.

00:41:42.480 --> 00:41:48.140
It was saying, I saw a job post, requiring four plus years of experience of FastAPI.

00:41:48.140 --> 00:41:53.620
I couldn't apply because I only have 1.5 years of experience since I created the thing.

00:41:53.840 --> 00:41:59.560
So maybe it's time to reevaluate the experience is equal to, to skillset.

00:41:59.560 --> 00:42:06.340
But like a bunch of people seem to have liked it because they tweeted it like crazy.

00:42:06.340 --> 00:42:08.360
My Twitter app broke.

00:42:08.360 --> 00:42:18.300
And now recently, I don't know why they started with tweeting it again and sharing screenshots of it on LinkedIn and tagging me.

00:42:18.300 --> 00:42:22.280
And by this point, I have two years of experience with FastAPI.

00:42:22.280 --> 00:42:24.020
So that is no longer true.

00:42:24.020 --> 00:42:27.580
So now we, it'll be like 20, what?

00:42:27.580 --> 00:42:28.260
2023?

00:42:28.260 --> 00:42:29.020
Yeah.

00:42:29.020 --> 00:42:29.420
2023.

00:42:29.420 --> 00:42:30.580
These things will be legit.

00:42:30.580 --> 00:42:31.760
Then you could apply for that job.

00:42:31.760 --> 00:42:32.420
That'd be fantastic.

00:42:32.420 --> 00:42:32.820
Yeah.

00:42:32.820 --> 00:42:33.340
That's what you want.

00:42:33.340 --> 00:42:34.260
I will get a job there.

00:42:34.260 --> 00:42:34.740
Hey.

00:42:34.740 --> 00:42:35.920
All right.

00:42:35.920 --> 00:42:38.020
We're getting, long in the show.

00:42:38.020 --> 00:42:41.120
So maybe our next two items should be kind of short, but, Sebastian, next one's yours.

00:42:41.460 --> 00:42:42.400
Yeah, this will be short.

00:42:42.400 --> 00:42:47.540
open API 3.1.0 was released recently.

00:42:47.540 --> 00:42:49.480
FastAPI is based on open API.

00:42:49.480 --> 00:42:51.100
So it's important for FastAPI.

00:42:51.100 --> 00:42:53.500
and for whoever using FastAPI.

00:42:53.500 --> 00:42:57.240
open API 3.1.0 doesn't change much.

00:42:57.240 --> 00:43:00.580
it adds a more compatibility underneath.

00:43:00.580 --> 00:43:07.100
So now it's based on the latest version of a JSON schema, which means that if you do things

00:43:07.100 --> 00:43:12.620
like, for example, automatic react components based on JSON schema, now they will be able

00:43:12.620 --> 00:43:14.480
to share the same schema as open API.

00:43:14.480 --> 00:43:20.820
The previous open API was based on a very old version of JSON schema and the new one is based

00:43:20.820 --> 00:43:21.620
on the latest version.

00:43:21.620 --> 00:43:26.240
So we will have like all the compatibility all around the place in all the, all the different

00:43:26.240 --> 00:43:27.580
tools.

00:43:27.760 --> 00:43:33.480
So that's, that's a great, and it will allow like a lot of interoperability and integration

00:43:33.480 --> 00:43:34.860
with other, with other tools.

00:43:34.860 --> 00:43:35.240
Yeah.

00:43:35.240 --> 00:43:35.660
Yeah.

00:43:35.660 --> 00:43:41.720
For people who don't know, if you run a FastAPI API site and you go to slash docs, it'll

00:43:41.720 --> 00:43:45.600
generate a whole form that gives you information about the Pydantic models that are exchanged,

00:43:45.600 --> 00:43:47.740
the validation that happens, even lets you try it out.

00:43:47.740 --> 00:43:47.900
Right.

00:43:47.900 --> 00:43:48.340
Yeah.

00:43:48.340 --> 00:43:50.300
And it's related to this.

00:43:50.300 --> 00:43:50.460
Yeah.

00:43:50.460 --> 00:43:50.860
Yeah.

00:43:50.860 --> 00:43:56.960
And open API is an open standard that is held by the Linux foundation and it uses JSON schema,

00:43:57.120 --> 00:44:03.160
which is another open standard, which is a, a in progress RFC, an internet standard.

00:44:03.160 --> 00:44:06.960
And open API also uses OAuth 2, which is another standard.

00:44:06.960 --> 00:44:08.560
So it's all based on standards.

00:44:08.560 --> 00:44:12.500
When you, when you build an application with FastAPI, it's all based on standards and you

00:44:12.500 --> 00:44:14.440
get an application built on standards.

00:44:14.440 --> 00:44:20.220
Having this compatibility between these different standards and having all them synchronized now

00:44:20.220 --> 00:44:25.800
will improve a lot of all that interaction between those different things.

00:44:25.800 --> 00:44:26.920
That's really cool.

00:44:26.920 --> 00:44:27.320
That's awesome.

00:44:27.320 --> 00:44:28.700
Very nice.

00:44:28.700 --> 00:44:30.800
So Brian, that's our, our items, right?

00:44:30.800 --> 00:44:31.760
Anything you want to throw out there?

00:44:32.260 --> 00:44:39.160
I am wearing this lovely Noah shirt from, national oceanic and atmospheric administration.

00:44:39.160 --> 00:44:44.940
thanks to, Matthew Casari and Noah for the great shirt that sent it as a thank

00:44:44.940 --> 00:44:46.840
you for speaking to them a couple of weeks ago.

00:44:46.840 --> 00:44:47.820
And that's really cool.

00:44:47.820 --> 00:44:50.280
They also sent a couple of shirts for my daughters and that was nice.

00:44:50.280 --> 00:44:50.720
Thanks.

00:44:50.720 --> 00:44:51.020
Yeah.

00:44:51.020 --> 00:44:51.640
Fantastic.

00:44:51.640 --> 00:44:52.620
That's really cool.

00:44:52.920 --> 00:44:54.520
I'm sure there's neat Python stuff there.

00:44:54.520 --> 00:44:54.920
Yeah.

00:44:54.920 --> 00:45:00.240
So anybody want me to speak at their company and I'll, and send me a shirt, I'll wear

00:45:00.240 --> 00:45:00.980
it online.

00:45:00.980 --> 00:45:02.700
Fantastic.

00:45:02.700 --> 00:45:04.920
Sebastian, we always throw out just little extra items.

00:45:04.920 --> 00:45:08.480
If people, if you got anything extra, you want to let people know about anything you want

00:45:08.480 --> 00:45:08.700
to share?

00:45:08.700 --> 00:45:14.840
I just got curious recently about item, which is a kind of react in Python and you can use

00:45:14.840 --> 00:45:16.260
it through Jupyter.

00:45:16.260 --> 00:45:18.860
That's some, it seemed quite interesting.

00:45:18.860 --> 00:45:20.860
I haven't played much with it.

00:45:20.860 --> 00:45:23.680
I know I just checked the first demo that it works.

00:45:23.680 --> 00:45:28.300
It's, it's a bit mind bending, but it's quite, quite an interesting experiment.

00:45:28.300 --> 00:45:28.920
Yeah.

00:45:28.920 --> 00:45:29.280
Awesome.

00:45:29.280 --> 00:45:29.560
Okay.

00:45:29.560 --> 00:45:29.920
Very cool.

00:45:29.920 --> 00:45:30.840
People should check that out.

00:45:30.840 --> 00:45:32.500
And Brian, it's true.

00:45:32.500 --> 00:45:34.200
Everyone has a price.

00:45:34.200 --> 00:45:34.860
Everyone has a price.

00:45:34.860 --> 00:45:35.960
Some people, it's just a t-shirt.

00:45:35.960 --> 00:45:36.420
That's awesome.

00:45:36.420 --> 00:45:36.960
All right.

00:45:36.960 --> 00:45:39.500
I got a, a four things I want to throw out there in the joke.

00:45:39.500 --> 00:45:41.100
I'll make these all super, super quick.

00:45:41.100 --> 00:45:44.800
So first of all, I wrote, I've been with all of my courses.

00:45:44.800 --> 00:45:46.100
It's always like, Oh, do you need Python?

00:45:46.100 --> 00:45:47.140
Do you have the right version of Python?

00:45:47.140 --> 00:45:48.420
Are you on windows?

00:45:48.420 --> 00:45:50.660
Oh, then here's what you were going to need to do to get your,

00:45:50.800 --> 00:45:51.760
like, here's how you check it.

00:45:51.760 --> 00:45:52.720
You don't type Python three.

00:45:52.720 --> 00:45:53.460
That will never work.

00:45:53.460 --> 00:45:56.060
You type Python, unless you are on a certain version of windows 10,

00:45:56.060 --> 00:45:57.460
then it'll report that it's not there.

00:45:57.460 --> 00:45:59.360
But like, there's just like, Oh my God, what is happening?

00:45:59.360 --> 00:46:00.620
I just couldn't take it anymore.

00:46:00.620 --> 00:46:03.540
So I finally broke down and wrote a, I don't have Python.

00:46:03.540 --> 00:46:04.120
I need Python.

00:46:04.120 --> 00:46:04.720
What do I do?

00:46:04.720 --> 00:46:05.700
Oh, I'm on macOS.

00:46:05.700 --> 00:46:06.000
Okay.

00:46:06.000 --> 00:46:09.120
So then here's how you find out if you have Python and is a good version.

00:46:09.120 --> 00:46:11.620
If not, here's three or four options for each OS,

00:46:11.620 --> 00:46:16.540
the benefits pros and the cons of potentially say using homebrew and then how you install,

00:46:16.540 --> 00:46:17.880
if you want to go down that path.

00:46:17.880 --> 00:46:19.980
And so anyway, I'll put a link into the show notes.

00:46:19.980 --> 00:46:21.320
So people care about that.

00:46:21.320 --> 00:46:22.060
Nice.

00:46:22.060 --> 00:46:23.140
Thanks for doing that.

00:46:23.140 --> 00:46:23.740
Yeah.

00:46:23.740 --> 00:46:24.040
Yeah.

00:46:24.040 --> 00:46:24.980
You're absolutely welcome.

00:46:25.400 --> 00:46:26.740
Last time I was so excited.

00:46:26.740 --> 00:46:29.040
Still, I'm excited about Boto3 type annotations.

00:46:29.040 --> 00:46:32.700
But someone pointed out that this, you noticed the last updated two years ago,

00:46:32.700 --> 00:46:34.780
there's a deprecated, Oh, there's a fork over here.

00:46:34.780 --> 00:46:37.140
And if you go to that, it goes, you go down like, Oh no, no, no.

00:46:37.140 --> 00:46:37.940
This is deprecated.

00:46:37.940 --> 00:46:38.660
It's over here.

00:46:38.660 --> 00:46:44.880
Eventually you end up at this, my pie Boto3 builder that uses my pie to dynamically generate

00:46:44.880 --> 00:46:50.680
the type stubs for that are compatible with VS Code and PyTarm and so on for the Boto library.

00:46:50.680 --> 00:46:54.000
So if you're really super interested in that thing I covered last time, you know,

00:46:54.000 --> 00:46:56.160
check this out, follow the GitHub thing.

00:46:56.160 --> 00:46:58.300
But use it fast before it's deprecated.

00:46:58.300 --> 00:46:59.200
Yes, exactly.

00:46:59.200 --> 00:46:59.700
Exactly.

00:46:59.700 --> 00:47:03.140
And that comes from Dean Langsom, who is also on the live stream.

00:47:03.140 --> 00:47:03.980
So thank you for that, Dean.

00:47:03.980 --> 00:47:04.580
That's awesome.

00:47:04.580 --> 00:47:06.700
We had Brett Cannon on the show.

00:47:06.700 --> 00:47:07.840
Was that last time or time before?

00:47:07.840 --> 00:47:08.940
That was the last time, right?

00:47:08.940 --> 00:47:14.620
Very, very recently we had Brett Cannon come talk about various things, including the pattern

00:47:14.620 --> 00:47:15.240
matching stuff.

00:47:15.240 --> 00:47:21.040
He also talked about Python launcher and we threw out like, Hey, if I'm in a subdirectory of

00:47:21.040 --> 00:47:23.440
some project and somewhere up, there's a virtual environment.

00:47:23.440 --> 00:47:24.620
And I just try to run it.

00:47:24.620 --> 00:47:28.500
It should automatically find the whole project sort of ambient virtual environment.

00:47:28.500 --> 00:47:30.200
So he apparently added that for us.

00:47:30.200 --> 00:47:30.560
Yeah.

00:47:30.560 --> 00:47:31.480
I just tried it this morning.

00:47:31.480 --> 00:47:32.000
Awesome.

00:47:32.000 --> 00:47:32.460
Yeah.

00:47:32.460 --> 00:47:32.920
Fantastic.

00:47:32.920 --> 00:47:33.800
Nice.

00:47:33.800 --> 00:47:38.900
Then last thing I'm thinking of doing an ask me anything talk Python episode where I get

00:47:38.900 --> 00:47:42.640
some people in the audience to interview me and ask the questions of the audience just

00:47:42.640 --> 00:47:43.260
about the show.

00:47:43.260 --> 00:47:44.660
So I'll put a link in the show notes.

00:47:44.660 --> 00:47:48.040
If you have a question you would like to ask on talk Python and make it part of the ask me

00:47:48.040 --> 00:47:49.060
anything, we'll do that.

00:47:49.060 --> 00:47:50.800
And we'll live stream it on YouTube as well.

00:47:51.120 --> 00:47:51.280
All right.

00:47:51.280 --> 00:47:52.720
So that's all my, my extra items.

00:47:52.720 --> 00:47:54.180
We need a joke.

00:47:54.180 --> 00:47:54.940
We need a joke.

00:47:54.940 --> 00:47:55.240
All right.

00:47:55.240 --> 00:47:57.560
Well, last time I really enjoyed this one.

00:47:57.560 --> 00:48:00.680
So I thought the funny code comments.

00:48:00.680 --> 00:48:02.460
So I thought we might come back to this.

00:48:02.580 --> 00:48:06.220
So, so I think I'll kick it off, I guess.

00:48:06.220 --> 00:48:07.220
And then Brian, you next.

00:48:07.220 --> 00:48:09.780
And then Sebastian, you can, you can pick up the third one.

00:48:09.780 --> 00:48:10.220
How's that sound?

00:48:10.220 --> 00:48:10.600
Sure.

00:48:10.600 --> 00:48:11.480
Awesome.

00:48:11.480 --> 00:48:11.900
All right.

00:48:11.900 --> 00:48:17.180
So here's a comment that kind of misunderstands exception handling constructs.

00:48:17.180 --> 00:48:22.120
So try finally comment in the finally block should never happen.

00:48:22.120 --> 00:48:25.820
I'm sure they meant try exception never happen.

00:48:25.820 --> 00:48:27.080
No, no, no.

00:48:27.080 --> 00:48:27.660
Try finally.

00:48:27.760 --> 00:48:29.540
That probably almost always happens.

00:48:29.540 --> 00:48:31.820
Yeah.

00:48:31.820 --> 00:48:33.100
That's a good one.

00:48:33.100 --> 00:48:33.280
Right.

00:48:33.280 --> 00:48:33.540
All right.

00:48:33.540 --> 00:48:34.240
Brian, you're up next.

00:48:34.240 --> 00:48:35.300
Oh, okay.

00:48:35.300 --> 00:48:40.840
So comment that says, looks like C code because of the comment style, but, you may

00:48:40.840 --> 00:48:45.080
think, you know, what's the following code does, but you don't trust me fiddle with it.

00:48:45.080 --> 00:48:50.240
And you'll spend many a sleepless night cursing the moment you thought you'd be clever enough

00:48:50.240 --> 00:48:51.700
to optimize the code below.

00:48:51.700 --> 00:48:54.600
Now close this file and go play with something else.

00:48:54.600 --> 00:48:57.600
All right, Sebastian.

00:48:57.600 --> 00:48:58.520
The next one's yours.

00:48:58.940 --> 00:49:05.940
So there's this, declaration of a constant integer with a name of capitals T E N.

00:49:05.940 --> 00:49:06.780
So 10.

00:49:06.780 --> 00:49:08.820
And the value is the number 10.

00:49:08.820 --> 00:49:12.340
And the comment says, as if the value of 10 will fluctuate.

00:49:12.340 --> 00:49:16.680
You know, you don't want magic numbers in your code.

00:49:16.680 --> 00:49:22.480
Like, like blue might be better than some hexadecimal number or like max limit might be

00:49:22.480 --> 00:49:25.940
10, but just the word 10, there's no reason for that.

00:49:25.940 --> 00:49:26.440
That's awesome.

00:49:26.800 --> 00:49:27.940
All right, I'll do the next one here.

00:49:27.940 --> 00:49:30.060
I am not responsible for this code.

00:49:30.060 --> 00:49:32.000
They made me write it against my will.

00:49:32.000 --> 00:49:38.580
I like the last, it's the next one.

00:49:38.580 --> 00:49:42.160
So, if this code works, it was written by Paul.

00:49:42.160 --> 00:49:44.480
If not, we don't know who wrote it.

00:49:44.480 --> 00:49:49.480
All right.

00:49:49.480 --> 00:49:51.940
and then the last one says option.

00:49:51.940 --> 00:49:56.660
So is the declaration of options dot batch size is equal to 300.

00:49:56.660 --> 00:49:58.800
And then the comment says madness.

00:49:58.800 --> 00:49:59.820
And then screams.

00:49:59.820 --> 00:50:01.140
This is Sparta.

00:50:01.140 --> 00:50:03.160
This is Sparta.

00:50:03.160 --> 00:50:04.800
Then from the movie 300.

00:50:04.800 --> 00:50:05.440
Fantastic.

00:50:05.440 --> 00:50:07.380
Oh my goodness.

00:50:07.380 --> 00:50:08.480
Nice.

00:50:08.480 --> 00:50:09.240
That's great.

00:50:09.240 --> 00:50:09.880
Awesome.

00:50:09.880 --> 00:50:12.400
Well, those are some really good, important comments.

00:50:12.400 --> 00:50:12.980
All of them.

00:50:12.980 --> 00:50:14.980
I think the Sparta one kind of inspires.

00:50:14.980 --> 00:50:16.740
You're like, we're going to go to batch size 300.

00:50:16.740 --> 00:50:17.560
Let's do this.

00:50:17.560 --> 00:50:18.300
The others.

00:50:18.300 --> 00:50:19.580
I don't know about them so much.

00:50:20.440 --> 00:50:24.560
No, I'm going to start doing the, if, if this code works, it was written by me.

00:50:24.560 --> 00:50:26.900
but you know, we have version control.

00:50:26.900 --> 00:50:28.460
You can, you can just look it up.

00:50:28.460 --> 00:50:29.220
Yeah, that's true.

00:50:29.220 --> 00:50:29.780
There is a blame.

00:50:29.780 --> 00:50:31.840
Well, that was fun.

00:50:31.840 --> 00:50:32.560
We're done.

00:50:32.560 --> 00:50:34.280
Thanks everybody for joining us.

00:50:34.280 --> 00:50:37.140
thank you, Sebastian for joining us.

00:50:37.140 --> 00:50:37.820
This was great.

00:50:37.820 --> 00:50:38.980
Thank you for the invitation.

00:50:38.980 --> 00:50:42.180
Thanks everyone for listening to my weird voice.

00:50:42.180 --> 00:50:43.400
Thanks for having us.

00:50:43.400 --> 00:50:44.580
Sebastian, it was great to have you here.

00:50:44.580 --> 00:50:45.260
Thank you.

00:50:45.260 --> 00:50:45.740
It was awesome.

00:50:45.740 --> 00:50:46.160
Thank you.

00:50:46.160 --> 00:50:46.700
Yep.

00:50:46.700 --> 00:50:47.200
Bye everyone.

00:50:47.200 --> 00:50:47.560
Bye Brian.

