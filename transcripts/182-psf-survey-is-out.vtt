
00:00:00.000 --> 00:00:10.400
Hello and welcome to Python Bytes where we deliver Python news and headlines directly to your earbuds. This is episode 182 recorded May 13th, 2020.


00:00:10.400 --> 00:00:16.000
And I am Brian Okken. And I'm Michael Kennedy. And this episode is brought to you by Datadog.


00:00:16.000 --> 00:00:29.460
There's two surveys that I feel really do a good job of keeping their, you know, they have their thumb on the pulse of the community. And I would say one is the PSF JetBrains combination. That one's really good for Python in particular.


00:00:29.460 --> 00:00:31.620
and the other is the Stack Overflow Survey.


00:00:31.620 --> 00:00:34.020
Well, the Stack Overflow Survey recently came out,


00:00:34.020 --> 00:00:35.540
you know, a couple months ago or something like that.


00:00:35.540 --> 00:00:38.820
So now it's the PSF JetBrains Survey.


00:00:38.820 --> 00:00:40.020
And when I first saw this, I thought,


00:00:40.020 --> 00:00:42.040
oh, this is last year's 'cause it was 2019,


00:00:42.040 --> 00:00:44.260
but they do a ton of analysis on it.


00:00:44.260 --> 00:00:48.180
And the survey was done in 2019, but it's released now.


00:00:48.180 --> 00:00:50.780
So anyway, I wanna talk about some of the results in there


00:00:50.780 --> 00:00:53.020
because there's some interesting takes.


00:00:53.020 --> 00:00:55.660
And also I wanna say thank you to Jose Nario


00:00:55.660 --> 00:00:57.660
who sent this in because like I said,


00:00:57.660 --> 00:00:58.660
I thought it was last year's


00:00:58.660 --> 00:01:00.660
I'm still waiting for the 2020 edition.


00:01:00.660 --> 00:01:02.660
All right, so let's talk about some of the results.


00:01:02.660 --> 00:01:05.660
First of all, one of the first questions asked was


00:01:05.660 --> 00:01:08.660
do you primarily use Python as your main language


00:01:08.660 --> 00:01:11.660
or are you interested in Python because it's some other


00:01:11.660 --> 00:01:15.660
like I also happen to use it in addition to JavaScript or something.


00:01:15.660 --> 00:01:17.660
84% of the people who took the survey,


00:01:17.660 --> 00:01:22.660
and that was mostly folks who visited python.org,


00:01:22.660 --> 00:01:25.660
so 84% said it's my primary language


00:01:25.660 --> 00:01:27.660
and that's unchanged from last year.


00:01:27.660 --> 00:01:32.620
year. Okay, interesting. A lot of the analysis here was how has this changed


00:01:32.620 --> 00:01:36.300
over the last year or so. Right, so there's a lot of interesting trends to be


00:01:36.300 --> 00:01:41.420
pulled out from here. They said what other languages do you use? Well, there


00:01:41.420 --> 00:01:45.540
was JavaScript which has gone down in usage. There's bash which has gone down


00:01:45.540 --> 00:01:50.620
in usage. There's HTML which has gone down in usage relative to last year. And


00:01:50.620 --> 00:01:57.220
C++ which has gone down relative to last year. So the people who took the survey,


00:01:57.220 --> 00:01:59.680
The same number of people said they're primarily using Python,


00:01:59.680 --> 00:02:02.100
but the other languages they're employing,


00:02:02.100 --> 00:02:04.980
all the ones which were popular seem to be going down.


00:02:04.980 --> 00:02:08.300
And I would say this means maybe people are starting


00:02:08.300 --> 00:02:10.420
to lean more on Python, those who use it.


00:02:10.420 --> 00:02:12.580
I don't know what conclusions we should draw there.


00:02:12.580 --> 00:02:15.780
There's also some growth in some other languages as well,


00:02:15.780 --> 00:02:16.980
I'm guessing.


00:02:16.980 --> 00:02:18.980
Interesting to see all the other ones down.


00:02:18.980 --> 00:02:19.660
Yeah.


00:02:19.660 --> 00:02:22.500
Well, this is down within the Python community, right?


00:02:22.500 --> 00:02:24.780
This is not necessarily down overall, right?


00:02:24.780 --> 00:02:27.740
So I would say we should look at the Stack Overflow survey


00:02:27.740 --> 00:02:31.100
to like really more like even Stack Overflow trends.


00:02:31.100 --> 00:02:32.140
But if you look at that one,


00:02:32.140 --> 00:02:34.380
it's all the other languages are relatively down as well.


00:02:34.380 --> 00:02:36.220
So interesting.


00:02:36.220 --> 00:02:40.580
Now, a lot of the divide happens around web


00:02:40.580 --> 00:02:42.220
versus data science here.


00:02:42.220 --> 00:02:43.740
And so a lot of the questions said,


00:02:43.740 --> 00:02:45.620
are you a web developer primarily


00:02:45.620 --> 00:02:47.140
or a data scientist primarily?


00:02:47.140 --> 00:02:50.460
And then if you are, what type of tools do you use?


00:02:50.460 --> 00:02:52.820
So for example, if you're a data scientist,


00:02:52.820 --> 00:03:00.420
use Python, of course, but you also make larger use of C++, Java, R, and C# as a data scientist.


00:03:00.420 --> 00:03:05.860
But if you are a web developer, you make more use of SQL, JavaScript, and HTML, which is,


00:03:05.860 --> 00:03:10.340
you know, no surprise because it's hard to write the web without HTML and JavaScript.


00:03:10.340 --> 00:03:12.180
So those are pretty interesting.


00:03:12.180 --> 00:03:18.060
And they said 58% of the people use Python for both work and personal projects.


00:03:18.060 --> 00:03:20.900
And they said, all right, well, what do you use it for?


00:03:20.900 --> 00:03:21.900
Right?


00:03:21.900 --> 00:03:23.620
There is a bunch of answers.


00:03:23.620 --> 00:03:28.100
I'm going to give you the top four because the average person who filled this out chose


00:03:28.100 --> 00:03:31.180
four things that they primarily use Python for.


00:03:31.180 --> 00:03:34.940
I could use it for web and DevOps or something like that.


00:03:34.940 --> 00:03:35.940
It's not exclusive.


00:03:35.940 --> 00:03:42.140
So the top four were data analysis, which is exactly the same as last year.


00:03:42.140 --> 00:03:44.880
59% of the respondents said that.


00:03:44.880 --> 00:03:45.880
Web development.


00:03:45.880 --> 00:03:46.880
This is pretty interesting.


00:03:46.880 --> 00:03:49.580
51% of people said they do web development,


00:03:49.580 --> 00:03:52.500
but this is down 4% year over year.


00:03:52.500 --> 00:03:53.340
- Interesting.


00:03:53.340 --> 00:03:56.120
- That's a big drop, and I feel like web is a big component


00:03:56.120 --> 00:03:57.620
of what the Python space is.


00:03:57.620 --> 00:03:59.500
So I don't really know what to draw from that.


00:03:59.500 --> 00:04:02.580
Like maybe just more people are sort of backfilling


00:04:02.580 --> 00:04:04.780
in the data science side maybe.


00:04:04.780 --> 00:04:07.280
Maybe the tools that they use are better.


00:04:07.280 --> 00:04:08.640
So things like Streamlit and stuff,


00:04:08.640 --> 00:04:10.300
they're like, well, I don't have to do web now.


00:04:10.300 --> 00:04:11.340
I'm not really sure.


00:04:11.340 --> 00:04:13.860
Machine learning, 40%, that's up 1%.


00:04:13.860 --> 00:04:19.300
DevOps, 39%, that's down 4% as well, which is the same number as a web


00:04:19.300 --> 00:04:23.220
development. And these are kind of similar things. So what you use Python


00:04:23.220 --> 00:04:27.540
for is pretty interesting. And then more broadly, it says what do you use it the


00:04:27.540 --> 00:04:33.340
most for web data analysis and machine learning. Web is down 1% as the primary


00:04:33.340 --> 00:04:38.820
thing you use it for data analysis is up 1% machine learning is up 2%. Also, not


00:04:38.820 --> 00:04:45.020
Not surprising, I guess, but good news on the Python versus legacy Python story, 90%


00:04:45.020 --> 00:04:47.860
of people are using Python 3.


00:04:47.860 --> 00:04:51.800
That's a huge change from five years ago when it was like, "Oh yeah, there's that one weird


00:04:51.800 --> 00:04:56.620
guy that uses Python 3, but everyone else, nah."


00:04:56.620 --> 00:05:02.380
More of the data scientists are using Python 3 as a percentage over the web developers.


00:05:02.380 --> 00:05:07.380
I think that's because data science, the libraries and the tools are changing a lot.


00:05:07.380 --> 00:05:12.380
It's not like you have legacy data science.


00:05:12.380 --> 00:05:14.380
Like, "Oh yeah, we're using that machine learning library


00:05:14.380 --> 00:05:17.700
from 10 years ago because we just don't want to change it."


00:05:17.700 --> 00:05:19.980
It's like those are fundamentally changed


00:05:19.980 --> 00:05:21.700
and you just have new tools.


00:05:21.700 --> 00:05:23.540
Whereas web development, I think there's a lot of folks


00:05:23.540 --> 00:05:25.340
that are like, "Yeah, we're still got that


00:05:25.340 --> 00:05:27.620
Django one app going on Python two or something."


00:05:27.620 --> 00:05:30.300
- I'm not surprised there's still some Python two,


00:05:30.300 --> 00:05:32.060
but 10% still seems a little high.


00:05:32.060 --> 00:05:34.220
- I think it's mostly legacy code.


00:05:34.220 --> 00:05:36.380
I'm not entirely sure, but you can use your legacy Python


00:05:33.780 --> 00:05:35.220
for your legacy code.


00:05:35.220 --> 00:05:38.340
All right, and then web frameworks.


00:05:38.340 --> 00:05:42.100
Flask was kind of neck and neck with Django last year.


00:05:42.100 --> 00:05:43.480
Now it's like totally ahead.


00:05:43.480 --> 00:05:47.340
So 48% Flask developers and 44% Django developers


00:05:47.340 --> 00:05:49.020
and everything else is pretty small.


00:05:49.020 --> 00:05:52.260
Data science, 63% of the people are using NumPy,


00:05:52.260 --> 00:05:55.420
55% Pandas, 46% Matplotlib.


00:05:55.420 --> 00:05:58.220
Here's one I threw in for you, Brian, testing.


00:05:58.220 --> 00:06:00.940
49% of the people are using pytest.


00:06:00.940 --> 00:06:01.900
- Yes. - 30%.


00:06:01.900 --> 00:06:05.300
Yeah, 30% of the people are using the built-in unit test.


00:06:05.300 --> 00:06:07.580
And 34% are using this other framework


00:06:07.580 --> 00:06:09.340
I hadn't heard of before.


00:06:09.340 --> 00:06:11.220
It's called the none framework.


00:06:11.220 --> 00:06:13.320
- Yeah, that's unfortunately high,


00:06:13.320 --> 00:06:15.460
but it's funny that it's higher than unit test.


00:06:15.460 --> 00:06:17.980
- Yeah, I know, that's what I thought as well.


00:06:17.980 --> 00:06:18.800
Pretty funny.


00:06:18.800 --> 00:06:20.220
All right, a couple more and we'll be done with this one.


00:06:20.220 --> 00:06:22.860
So cloud, the cloud platforms people are using,


00:06:22.860 --> 00:06:26.660
AWS is in the lead, no surprise there, with 55%.


00:06:26.660 --> 00:06:29.700
What did surprise me is Google Cloud,


00:06:29.700 --> 00:06:34.300
GCP and whatnot is actually number two at 33%.


00:06:34.300 --> 00:06:38.240
DigitalOcean, shout out to them, is at 22%


00:06:38.240 --> 00:06:42.260
and then Heroku is 20% and Azure is 19%.


00:06:42.260 --> 00:06:44.300
So pretty interesting.


00:06:44.300 --> 00:06:47.220
And then how do you run your code in the cloud


00:06:47.220 --> 00:06:48.100
in a production environment?


00:06:48.100 --> 00:06:50.780
Do you run in containers, VMs, platforms as a service


00:06:50.780 --> 00:06:51.820
like Heroku or something?


00:06:51.820 --> 00:06:55.260
So containers, 47%, that's pretty high.


00:06:55.260 --> 00:07:00.260
VMs 46% and then platform as a service is 25%.


00:07:00.260 --> 00:07:02.180
What editor do you use?


00:07:02.180 --> 00:07:06.100
PyCharm 33%, VS Code 24%, Vim 9%.


00:07:06.100 --> 00:07:08.660
Everything else is like a super small margin after that.


00:07:08.660 --> 00:07:10.620
Yeah, and that's pretty much it.


00:07:10.620 --> 00:07:14.380
- Yeah, so I threw in an extra one on there at the end.


00:07:14.380 --> 00:07:15.740
Well, one, the containers,


00:07:15.740 --> 00:07:20.660
I thought containers was number two below VMs last year.


00:07:20.660 --> 00:07:22.860
And now it's jumped to number one.


00:07:22.860 --> 00:07:24.980
- Oh yeah, like that's probably Kubernetes.


00:07:24.980 --> 00:07:28.120
like hosted Kubernetes clusters, right?


00:07:28.120 --> 00:07:30.540
That people are throwing their Docker images into.


00:07:30.540 --> 00:07:31.380
Oh yeah, what's the last one?


00:07:31.380 --> 00:07:32.220
Take us through this one.


00:07:32.220 --> 00:07:33.100
- And then the tool use.


00:07:33.100 --> 00:07:36.220
They also listed a handful of things of people using.


00:07:36.220 --> 00:07:39.180
90% people using version control, that's good.


00:07:39.180 --> 00:07:41.540
80% write their tests, that's good.


00:07:41.540 --> 00:07:43.580
And 80% code linting.


00:07:43.580 --> 00:07:46.380
And 65% people use type hinting,


00:07:46.380 --> 00:07:48.540
which actually is a little higher than I--


00:07:48.540 --> 00:07:49.540
- Oh yeah, way to go.


00:07:49.540 --> 00:07:50.360
- That's nice.


00:07:50.360 --> 00:07:54.540
And about half the people using code coverage tools, 52%.


00:07:54.540 --> 00:07:55.380
Yeah, thanks for adding that.


00:07:55.380 --> 00:08:00.380
I'm very familiar with legacy code and non-legacy code,


00:08:00.380 --> 00:08:01.900
which I guess you call modern,


00:08:01.900 --> 00:08:03.380
but you're going to take it to 11.


00:08:03.380 --> 00:08:04.220
What's up?


00:08:04.220 --> 00:08:06.020
What's up with this level?


00:08:06.020 --> 00:08:07.340
- It's hyper modern.


00:08:07.340 --> 00:08:08.380
- Woo!


00:08:08.380 --> 00:08:09.280
- Yeah.


00:08:09.280 --> 00:08:11.660
This is from Claudio, cool name.


00:08:11.660 --> 00:08:15.580
But anyway, so he wrote a, actually, it's like a book.


00:08:15.580 --> 00:08:18.820
This is an incredible series of blog posts


00:08:18.820 --> 00:08:20.480
and he actually writes them out.


00:08:20.480 --> 00:08:23.500
They're all linked together, called Hyper Modern Python,


00:08:23.500 --> 00:08:26.260
and sets them up in six chapters.


00:08:26.260 --> 00:08:31.020
He's got setup, testing, linting, typing, documentation,


00:08:31.020 --> 00:08:33.060
and then the last chapter is CI/CD,


00:08:33.060 --> 00:08:34.420
and he just wrapped it up.


00:08:34.420 --> 00:08:35.380
I've been watching this,


00:08:35.380 --> 00:08:38.840
and I was gonna announce it when he was done.


00:08:38.840 --> 00:08:41.840
It's a really fun series to learn about.


00:08:41.840 --> 00:08:44.380
You know, you've learned some of the basics of Python,


00:08:44.380 --> 00:08:46.820
but you wanna get some best practices


00:08:46.820 --> 00:08:48.500
and take it up a notch.


00:08:48.500 --> 00:08:50.020
And I think this is good.


00:08:50.020 --> 00:08:52.060
It's opinionated, of course.


00:08:52.060 --> 00:08:53.580
I actually like opinionated things


00:08:53.580 --> 00:08:55.980
and some of the opinions I don't quite follow.


00:08:55.980 --> 00:09:00.500
Like he likes PyENV, I'm not really a fan of PyENV,


00:09:00.500 --> 00:09:02.340
but that's all right.


00:09:02.340 --> 00:09:04.260
Also poetry, he uses poetry.


00:09:04.260 --> 00:09:07.660
I use Flit usually, but anyway,


00:09:07.660 --> 00:09:10.780
he does recommend the source layout, which is good.


00:09:10.780 --> 00:09:13.740
But for setup, there's a whole bunch of neat stuff in here.


00:09:13.740 --> 00:09:16.220
And some tools that, like for linting,


00:09:16.220 --> 00:09:19.260
he talks about Flickate, Black, Import Order,


00:09:19.260 --> 00:09:21.700
Bugbear, which is fun, I don't know if we've covered that,


00:09:21.700 --> 00:09:26.600
But there's a whole bunch of tools that I haven't even heard of like safety and dessert,


00:09:26.600 --> 00:09:29.980
and data validation with dessert and marshmallow.


00:09:29.980 --> 00:09:31.740
So I'll have to look that sort of stuff up.


00:09:31.740 --> 00:09:32.740
That looks neat.


00:09:32.740 --> 00:09:38.780
So just a good run through it in the CI/CD section, he talked about using GitHub actions,


00:09:38.780 --> 00:09:44.520
and reporting your coverage with CodeCov, uploading to PyPI and using test PyPI servers


00:09:44.520 --> 00:09:46.500
and documenting on read the docs.


00:09:46.500 --> 00:09:50.340
I think this is a fairly good representation for modern projects.


00:09:50.340 --> 00:09:55.940
Yeah covers a lot of stuff that people probably should be doing and maybe haven't taken the time to set up.


00:09:55.940 --> 00:10:14.480
Or dig into yeah and one of the things i want to highlight also is incredible use of pictures the imagery that uses on these posts are like the cct section was some nineteen seventies and space station or you know space colony.


00:10:14.720 --> 00:10:18.720
images and they're beautiful so it's worth it just for the pictures.


00:10:18.720 --> 00:10:20.920
It is worth it just for the pictures, they're great.


00:10:20.920 --> 00:10:21.920
Yeah, very nice one.


00:10:21.920 --> 00:10:24.920
Well, another thing that's really nice is Datadog.


00:10:24.920 --> 00:10:25.420
Indeed.


00:10:25.420 --> 00:10:30.020
Yep, this episode of Python Bytes is brought to you by Datadog and


00:10:30.020 --> 00:10:31.520
let me ask you a question.


00:10:31.520 --> 00:10:34.720
Do you have an app in production that is slower than you like?


00:10:34.720 --> 00:10:36.720
It's performance all over the place,


00:10:36.720 --> 00:10:38.720
sometimes fast, sometimes slow.


00:10:38.720 --> 00:10:41.220
Now here's the important question, do you know why?


00:10:41.220 --> 00:10:43.020
Well, with Datadog you will.


00:10:43.020 --> 00:10:47.100
You can troubleshoot your app's performance with Datadog's end-to-end tracing.


00:10:47.100 --> 00:10:50.940
Use the detailed flame graphs to identify bottlenecks and latency


00:10:50.940 --> 00:10:52.940
in that finicky app of yours.


00:10:52.940 --> 00:10:56.860
Be the hero that got the app back on track at your company.


00:10:56.860 --> 00:11:00.780
Get started today with a free trial of Datadog


00:11:00.780 --> 00:11:04.220
by going to pythonbytes.fm/datadog.


00:11:04.220 --> 00:11:06.780
And you even get a free t-shirt.


00:11:06.780 --> 00:11:09.180
So I really like my purple Datadog t-shirt.


00:11:09.180 --> 00:11:10.980
I wear it a little too much, probably.


00:11:10.980 --> 00:11:12.980
That's a cute one. Awesome. Yeah. Thanks, Datadog.


00:11:12.980 --> 00:11:17.780
This next one that I want to cover, Brian, is a little bit just kind of a fun thing.


00:11:17.780 --> 00:11:19.940
This, Dan Bader shared this with me the other day.


00:11:19.940 --> 00:11:21.980
He's like, "Man, you got to check this out. Look at this thing."


00:11:21.980 --> 00:11:22.780
And I'm like, "What is it?"


00:11:22.780 --> 00:11:25.980
It's called the OpenAI Jukebox.


00:11:25.980 --> 00:11:31.780
And so it's this AI that creates music.


00:11:31.780 --> 00:11:35.080
And it doesn't just create music.


00:11:35.080 --> 00:11:40.180
It creates different genres of music in the styles of certain artists


00:11:40.180 --> 00:11:44.260
with lyrics and musical accompaniment.


00:11:44.260 --> 00:11:46.420
So it's wild, right?


00:11:46.420 --> 00:11:48.420
I mean, I had you listen to a couple of the samples.


00:11:48.420 --> 00:11:53.220
And folks out there, you should just go click on the Open AI Jukebox link


00:11:53.220 --> 00:11:57.420
in the show notes, go to the curated samples, and play a couple.


00:11:57.420 --> 00:12:00.140
They're-- how would you classify them, Ryan?


00:12:00.140 --> 00:12:02.820
I'd classify them as you can tell they're music.


00:12:02.820 --> 00:12:05.060
[LAUGHS]


00:12:05.060 --> 00:12:07.780
None of these I would pick up, want to go out, rush out,


00:12:07.780 --> 00:12:09.020
and buy the album right away.


00:12:09.020 --> 00:12:14.700
Yeah, neither would I. I mean, to me, they sound like sort of bad recordings of an artist,


00:12:14.700 --> 00:12:21.100
you know, maybe taking on like a phone at a live concert where you've kind of got like


00:12:21.100 --> 00:12:22.460
not a good audio setup.


00:12:22.460 --> 00:12:27.340
There's like a little bit of a, I think I remember this song, bit to it, even though


00:12:27.340 --> 00:12:28.060
there's no way.


00:12:28.060 --> 00:12:34.540
Yeah, but it was created by an AI, which is insane. So one, they've got a country song


00:12:34.540 --> 00:12:37.980
in the style of Alan Jackson, which is a country singer.


00:12:37.980 --> 00:12:41.260
And you could convince me that that was Alan Jackson singing that song,


00:12:41.260 --> 00:12:42.260
if I didn't know better.


00:12:42.260 --> 00:12:43.580
I'm like, oh, I've never heard that song,


00:12:43.580 --> 00:12:45.620
and I'm not really super familiar with his music,


00:12:45.620 --> 00:12:47.580
but I kind of know what the guy sounds like.


00:12:47.580 --> 00:12:50.420
That's probably one of his songs, because it sounds like he's singing it,


00:12:50.420 --> 00:12:51.060
which is crazy.


00:12:51.060 --> 00:12:52.940
It's got Elvis Presley.


00:12:52.940 --> 00:12:54.780
It's got Katy Perry.


00:12:54.780 --> 00:12:58.740
It's got some heavy metal in the style of Rage.


00:12:58.740 --> 00:13:00.580
I'm not actually familiar with them.


00:13:00.580 --> 00:13:03.060
You got some other crazy stuff, like alternative metal


00:13:03.060 --> 00:13:07.820
in the style of Disturbed or a jazz like Ella Fitzgerald.


00:13:07.820 --> 00:13:13.900
And it's really interesting how accurate these things reproduce


00:13:13.900 --> 00:13:17.780
what those artists' style of singing is, their voice,


00:13:17.780 --> 00:13:20.940
what their voice sounds like, the style of music they write.


00:13:20.940 --> 00:13:23.900
I would definitely not want to go listen to this to relax


00:13:23.900 --> 00:13:24.660
or whatever.


00:13:24.660 --> 00:13:29.380
But as a AI example, it's pretty crazy.


00:13:29.380 --> 00:13:29.880
Yeah.


00:13:29.880 --> 00:13:31.580
And one of the things I really appreciate


00:13:31.580 --> 00:13:34.380
the music while you're listening to it, it kind of,


00:13:34.380 --> 00:13:36.620
it shows you the words, the lyrics while you're


00:13:36.620 --> 00:13:38.620
listening to it. - Yeah, the lyrics highlight,


00:13:38.620 --> 00:13:40.780
'cause some of them it's easy to understand,


00:13:40.780 --> 00:13:42.240
but others, like the disturbed one,


00:13:42.240 --> 00:13:44.380
it's not so much easy to understand.


00:13:44.380 --> 00:13:45.540
- It's like a highlighted thing,


00:13:45.540 --> 00:13:49.100
but my brain wanted to see the little bouncy ball,


00:13:49.100 --> 00:13:52.460
like, I don't know, the kids' music.


00:13:52.460 --> 00:13:54.140
- Yeah, exactly.


00:13:54.140 --> 00:13:57.060
So the code for this is available on GitHub.


00:13:57.060 --> 00:13:59.980
The dataset, they use, they train the model.


00:13:59.980 --> 00:14:06.580
To train it, they crawled the web and curated a data set of 1.2 million songs.


00:14:06.580 --> 00:14:07.080
Oh wow.


00:14:07.080 --> 00:14:09.180
That's got to use some bandwidth to get a hold of those.


00:14:09.180 --> 00:14:11.480
And then 600,000 of those were in English.


00:14:11.480 --> 00:14:15.480
And then it paired those with lyrics and metadata from the Lyric Wiki.


00:14:15.480 --> 00:14:15.980
Okay.


00:14:15.980 --> 00:14:17.080
So it went and found the songs.


00:14:17.080 --> 00:14:21.480
It said, "Okay, we need the written text so we can teach the model what the words are


00:14:21.480 --> 00:14:24.680
so that it can make up its own lyrics, I guess."


00:14:24.680 --> 00:14:25.180
Yeah.


00:14:25.180 --> 00:14:30.980
And then it says the top level transformer is trained on the task of predicting compressed audio tokens.


00:14:30.980 --> 00:14:35.380
And they provide additional information like the artist and genre for each song.


00:14:35.380 --> 00:14:37.280
And it said they get two advantages from that.


00:14:37.280 --> 00:14:40.080
First, it reduces the entropy of the audio prediction.


00:14:40.080 --> 00:14:44.280
So the model's able to get better audio quality for the given style.


00:14:44.280 --> 00:14:48.880
And at generation time, they're able to guide it in the style of their choosing.


00:14:48.880 --> 00:14:52.780
Like, no, no, we want some like hard rock versus Elvis or whatever.


00:14:52.780 --> 00:14:55.340
Anyway, if you're into AI,


00:14:55.340 --> 00:14:57.660
this seems like a pretty wild project to check out.


00:14:57.660 --> 00:14:58.780
Yeah, definitely.


00:14:58.780 --> 00:15:00.500
Yeah, I'd say it's even curious.


00:15:00.500 --> 00:15:01.100
Curious.


00:15:01.100 --> 00:15:02.700
Or if you're curious, you should go check it out.


00:15:02.700 --> 00:15:06.940
You should, and you should also check out this next post


00:15:06.940 --> 00:15:10.700
called "The Curious Case of Python's Context Manager."


00:15:10.700 --> 00:15:13.340
So Redouane Delaware,


00:15:13.340 --> 00:15:16.700
went through this because context managers are really important.


00:15:16.700 --> 00:15:21.100
And when you start really making some elegant, really readable code,


00:15:21.100 --> 00:15:23.820
it's good to make use of context managers.


00:15:23.820 --> 00:15:25.460
If you're not familiar with what they are,


00:15:25.460 --> 00:15:26.780
anytime you see a with,


00:15:26.780 --> 00:15:30.540
like with open file as F or something like that,


00:15:30.540 --> 00:15:33.300
that's a use of a context manager.


00:15:33.300 --> 00:15:35.700
The file one is probably the most notable one.


00:15:35.700 --> 00:15:37.220
So when you leave,


00:15:37.220 --> 00:15:41.620
what it does is it hooks up the keeping track of the data,


00:15:41.620 --> 00:15:43.260
so that when you exit the block,


00:15:43.260 --> 00:15:44.940
it can clean up after itself.


00:15:44.940 --> 00:15:46.820
So really handy things.


00:15:46.820 --> 00:15:50.140
I've seen a lot of different tutorials on how to write them,


00:15:50.140 --> 00:15:53.100
And a lot of them also, they go through the class.


00:15:53.100 --> 00:15:57.500
So in general, the punchline is use the context manager,


00:15:57.500 --> 00:16:00.900
contextlib.contextmanager decorator,


00:16:00.900 --> 00:16:02.900
and use a yield statement in the middle.


00:16:02.900 --> 00:16:04.900
And that will help you out.


00:16:04.900 --> 00:16:07.400
That's really the working way to do it.


00:16:07.400 --> 00:16:10.860
But if you want to write, you write a class based one


00:16:10.860 --> 00:16:14.500
with the dunder init, dunder enter, dunder exit.


00:16:14.500 --> 00:16:16.500
I think those are good examples.


00:16:16.500 --> 00:16:19.600
One of the things I liked about this tutorial is that it went through that.


00:16:19.600 --> 00:16:22.200
and it didn't seem artificial, it seemed it's like,


00:16:22.200 --> 00:16:25.860
this is the one way to do it, but it went through it pretty quickly and went through


00:16:25.860 --> 00:16:28.720
some other stuff and it's a pretty quick tutorial.


00:16:28.720 --> 00:16:31.620
But then, it gets into some really fun stuff


00:16:31.620 --> 00:16:35.720
that I really appreciated, like context managers


00:16:35.720 --> 00:16:39.300
as decorators and writing your own and then


00:16:39.300 --> 00:16:43.760
create so that you're not using a decorator to make a context manager, you're actually


00:16:43.760 --> 00:16:46.660
creating a decorator that is a context manager.


00:16:46.660 --> 00:16:48.460
That's a pretty interesting thing.


00:16:48.460 --> 00:16:54.560
and then wrapping things and nesting context managers with block or with statement.


00:16:54.560 --> 00:16:58.060
Yeah, that's cool to have like three of them instead of just one.


00:16:58.060 --> 00:17:00.860
Rather than like having three with blocks, right?


00:17:00.860 --> 00:17:02.220
Somehow I just missed that.


00:17:02.220 --> 00:17:02.720
Yeah.


00:17:02.720 --> 00:17:03.220
Yeah.


00:17:03.220 --> 00:17:06.740
And I've just nested the with blocks, but you don't have to do that.


00:17:06.740 --> 00:17:09.780
You can have them all on one line, which is cool.


00:17:09.780 --> 00:17:11.420
Yeah, there's a lot of cool little tips here.


00:17:11.420 --> 00:17:12.420
And then combining them.


00:17:12.420 --> 00:17:16.500
So like creating context manager that's really a combination of two other context managers


00:17:16.500 --> 00:17:19.260
or more than one, which is nice.


00:17:19.260 --> 00:17:21.660
Then you get into this and you think,


00:17:21.660 --> 00:17:23.060
well, what am I going to do with this?


00:17:23.060 --> 00:17:24.580
Where would I use it?


00:17:24.580 --> 00:17:28.300
There's three examples that he lists and shows.


00:17:28.300 --> 00:17:33.240
There's context managers with SQL alchemy session,


00:17:33.240 --> 00:17:34.820
which is a really cool idea.


00:17:34.820 --> 00:17:36.300
>> Yeah, I love this one.


00:17:36.300 --> 00:17:40.820
>> How to use rollback and session so that when you're testing and stuff,


00:17:40.820 --> 00:17:44.660
you can just automatically undo the thing that was in the block.


00:17:44.660 --> 00:17:48.340
Sweet idea. Using it for exception handling so that you can,


00:17:48.340 --> 00:17:52.580
and that in combination with using it as a decorator is a neat idea to


00:17:52.580 --> 00:17:58.260
have a policy for how to deal with certain exceptions during parts of your code,


00:17:58.260 --> 00:18:03.140
and then just decorate those functions with exception handling. That's pretty cool.


00:18:03.140 --> 00:18:08.180
And then the last one was talking about persistent parameters across HTTP requests.


00:18:08.180 --> 00:18:13.380
So it goes from very gentle to really deep into using this,


00:18:13.380 --> 00:18:15.780
well, pretty quick, but it's really easy to read.


00:18:15.780 --> 00:18:17.280
Yeah, well, you know, I


00:18:17.280 --> 00:18:21.280
realize reading through this that I've not been using the decorator style nearly enough.


00:18:21.280 --> 00:18:22.980
I'm always like, oh, I'll just add a


00:18:22.980 --> 00:18:26.880
class with an enter/exit type of thing, but yeah, the context managers


00:18:26.880 --> 00:18:27.980
you just get a function


00:18:27.980 --> 00:18:29.780
and do, you know, it's pretty clean.


00:18:29.780 --> 00:18:31.680
Yeah, it reminds me a lot of


00:18:31.680 --> 00:18:33.480
pytest fixtures.


00:18:33.480 --> 00:18:37.480
Yeah, for sure. That's a great article. I like it. I'll definitely have to study that one up.


00:18:37.480 --> 00:18:40.780
So, previously we spoke about


00:18:40.780 --> 00:18:43.280
NBDev, which takes


00:18:43.280 --> 00:18:46.880
Jupyter notebooks and allows you to do a whole bunch of cool things with them, right?


00:18:46.880 --> 00:18:49.920
You can export the stuff into a script,


00:18:49.920 --> 00:18:52.680
you can have it strip out some of the metadata,


00:18:52.680 --> 00:18:55.880
the saved output, which is like the bane of all


00:18:55.880 --> 00:18:59.280
GitHub committed notebooks, because


00:18:59.280 --> 00:19:02.580
every time you rerun it, if it's taking variable input data,


00:19:02.580 --> 00:19:04.580
it's going to have different metadata, so every


00:19:04.580 --> 00:19:08.180
run is a conflict, a merge conflict, which is no fun.


00:19:08.180 --> 00:19:12.380
So that thing solved a bunch of those types of things,


00:19:12.380 --> 00:19:14.880
but Clement Roberts sent over a message and said,


00:19:14.880 --> 00:19:17.080
"Hey, that's really cool and NBDev is great,


00:19:17.080 --> 00:19:20.480
but if you're looking just to do the stripping of the metadata,


00:19:20.480 --> 00:19:24.680
there's a project called NBStripOut, which is pretty clever."


00:19:24.680 --> 00:19:29.780
And yeah, you can just set it up as like a Git pre-commit hook,


00:19:29.780 --> 00:19:32.980
and then every time you commit your stuff to GitHub,


00:19:32.980 --> 00:19:34.780
it automatically just strips it out


00:19:34.780 --> 00:19:37.980
so that you never run into any of those merge conflicts.


00:19:37.980 --> 00:19:40.220
- Oh, hooking up as a pre-commit hook, that's a great idea.


00:19:40.220 --> 00:19:43.580
- Yeah, yeah, so you can either run it from the command line


00:19:43.580 --> 00:19:46.100
or once you're in a GitHub repo


00:19:46.100 --> 00:19:48.320
and you've pip installed nb strip out,


00:19:48.320 --> 00:19:51.500
you just say nb strip out --install, that's it.


00:19:51.500 --> 00:19:53.580
Now it's a Git pre-commit hook


00:19:53.580 --> 00:19:55.520
and it'll take care of doing all the things


00:19:55.520 --> 00:19:56.360
for Jupyter notebooks.


00:19:56.360 --> 00:19:57.200
- Oh, nice.


00:19:57.200 --> 00:19:59.740
- Yeah, so it basically is the same as going to Jupyter


00:19:59.740 --> 00:20:02.300
saying clear all output in the UI,


00:20:02.300 --> 00:20:03.980
but it just does it as you try it,


00:20:03.980 --> 00:20:06.580
only as you save it to GitHub, which is cool.


00:20:06.580 --> 00:20:09.940
And then there's also a YouTube tutorial, right?


00:20:09.940 --> 00:20:13.260
We've said that it's really cool to have screenshots


00:20:13.260 --> 00:20:14.380
of like UIs.


00:20:14.380 --> 00:20:15.780
Well, this is also really nice.


00:20:15.780 --> 00:20:19.260
So if you go actually to the PyPI listing,


00:20:19.260 --> 00:20:21.900
there's like a YouTube video right there


00:20:21.900 --> 00:20:23.940
that shows you like a four minute tutorial


00:20:23.940 --> 00:20:25.740
of like why you should care about this.


00:20:25.740 --> 00:20:27.220
And I've done that, it's super useful.


00:20:27.220 --> 00:20:28.500
I'm like, oh, this is kind of interesting.


00:20:28.500 --> 00:20:29.320
Let me watch it.


00:20:29.320 --> 00:20:30.460
I'm like, yep, that looks useful.


00:20:30.460 --> 00:20:32.060
We should talk about it.


00:20:32.060 --> 00:20:33.180
Really nice. - Yeah, nice.


00:20:33.180 --> 00:20:35.180
- Yeah, anyway, so if people are working with notebooks


00:20:35.180 --> 00:20:38.240
and they're having this merge conflict issue


00:20:38.240 --> 00:20:40.300
is the saved output.


00:20:40.300 --> 00:20:41.660
People forgetting to clear the output


00:20:41.660 --> 00:20:44.140
for they committed, don't make them remember,


00:20:44.140 --> 00:20:47.300
just do mb strip out dash dash install, and you're golden.


00:20:47.300 --> 00:20:49.700
- In episode 179, we had Guido on,


00:20:49.700 --> 00:20:51.620
which was totally a lot of fun.


00:20:51.620 --> 00:20:52.700
One of the things he brought up


00:20:52.700 --> 00:20:56.180
was the 2020 Python Language Summit.


00:20:56.180 --> 00:20:58.620
And it was really interesting to listen about that.


00:20:58.620 --> 00:21:01.700
But if you want to read more about it,


00:21:01.700 --> 00:21:03.380
there's a pretty good write up


00:21:03.380 --> 00:21:04.980
of all the topics I talked about.


00:21:04.980 --> 00:21:09.120
So we're linking to a post that has links to other posts.


00:21:09.120 --> 00:21:11.920
We've got things like, should all strings become f-strings


00:21:11.920 --> 00:21:16.020
and using the peg parser and replacing CPython's parser


00:21:16.020 --> 00:21:18.600
with the peg parser and different things like that.


00:21:18.600 --> 00:21:20.880
And even some of the lightning talks,


00:21:20.880 --> 00:21:24.320
just little snippets of kind of what was talked about


00:21:24.320 --> 00:21:28.640
and kind of like a news article feed of what's going on.


00:21:28.640 --> 00:21:30.600
I found it really interesting and helpful


00:21:30.600 --> 00:21:32.920
to be able to kind of pay attention


00:21:32.920 --> 00:21:34.680
to what's going on at the language summit


00:21:34.680 --> 00:21:37.520
and what's going on with the language going forward


00:21:37.520 --> 00:21:39.200
to keep up with everything.


00:21:39.200 --> 00:21:43.040
I also wanted to bring up that there's been notifications


00:21:43.040 --> 00:21:46.080
recently about there's a voting coming up


00:21:46.080 --> 00:21:47.900
for the board of directors


00:21:47.900 --> 00:21:50.280
for the Python Software Foundation.


00:21:50.280 --> 00:21:53.220
And so the PSF and some of the board of directors


00:21:53.220 --> 00:21:55.120
did a video on what this feels like


00:21:55.120 --> 00:21:56.720
and what does it mean to do that.


00:21:56.720 --> 00:21:58.360
So we're linking to the video


00:21:58.360 --> 00:22:01.640
and a link to the information about nominations


00:22:01.640 --> 00:22:04.400
'cause nominations are open for new board members


00:22:04.400 --> 00:22:06.000
up until the 31st of May.


00:22:06.000 --> 00:22:06.840
- Oh, that's cool.


00:22:06.840 --> 00:22:08.840
Yeah, it is a little bit mysterious to me


00:22:08.840 --> 00:22:12.480
what the PSF board of director folks do.


00:22:12.480 --> 00:22:14.760
I mean, I can imagine, but I don't really know for sure.


00:22:14.760 --> 00:22:16.720
So it's cool that they've got a video


00:22:16.720 --> 00:22:18.240
on talking about that.


00:22:18.240 --> 00:22:19.680
Yeah, if you know people who should be part of it,


00:22:19.680 --> 00:22:20.520
nominate them.


00:22:20.520 --> 00:22:21.360
That's cool.


00:22:21.360 --> 00:22:22.180
- Yeah.


00:22:22.180 --> 00:22:23.020
- Assuming they want to be nominated.


00:22:23.020 --> 00:22:24.760
(laughing)


00:22:24.760 --> 00:22:25.600
Awesome.


00:22:25.600 --> 00:22:27.080
All right, well, I guess that's it for all our items.


00:22:27.080 --> 00:22:28.080
You got anything extra, Brian?


00:22:28.080 --> 00:22:30.200
- I don't, I'm just been working along.


00:22:30.200 --> 00:22:31.040
How about you?


00:22:31.040 --> 00:22:31.960
- Two quick things.


00:22:31.960 --> 00:22:37.160
follow up, we talked about Austin, the profiler, which is awesome.


00:22:37.160 --> 00:22:40.800
It does CPU profiling, also memory profiling.


00:22:40.800 --> 00:22:46.440
Remember, it had the TUI, it had the web GUI, it had all the different user interfaces.


00:22:46.440 --> 00:22:50.360
And one of the ways you could view it, one of the many ways you could view it was through


00:22:50.360 --> 00:22:51.360
Speedscope.


00:22:51.360 --> 00:22:53.200
It's cool.


00:22:53.200 --> 00:23:00.680
So Wendell Bauman sent in a script that he'd created called PySpeedscope, which will let


00:23:00.680 --> 00:23:05.320
you generate one of these SpeedScope files that you can then visualize from Python.


00:23:05.320 --> 00:23:06.320
Nice.


00:23:06.320 --> 00:23:12.440
So, anyway, I'll just link over to his GitHub repo for PySpeedScope, which looks pretty cool.


00:23:12.440 --> 00:23:14.840
Also, I updated our search engine.


00:23:14.840 --> 00:23:19.520
I realized that when you search for stuff over at Python Bytes, it would give you good


00:23:19.520 --> 00:23:24.460
results but it would just present them kind of as if they were all equal.


00:23:24.460 --> 00:23:25.680
So now it ranks things.


00:23:25.680 --> 00:23:28.080
So I added ranking to our little search engine.


00:23:28.080 --> 00:23:32.400
So now if you search for stuff, it's more likely to give you good results.


00:23:32.400 --> 00:23:35.080
Well, that's cool.


00:23:35.080 --> 00:23:37.920
Without ranking, isn't it just pulling up random lists of things?


00:23:37.920 --> 00:23:41.200
Well, I mean, everything fit in there, right?


00:23:41.200 --> 00:23:45.840
If you search for it, everything that came up had, like if you search for, I don't know,


00:23:45.840 --> 00:23:49.840
Jupiter, it would have to have Jupiter in it if it came up as a result.


00:23:49.840 --> 00:23:54.540
But for example, if Jupiter was in the title or just like a random, and here's an example


00:23:54.540 --> 00:23:57.540
Jupyter notebook versus the topic is about Jupyter.


00:23:57.540 --> 00:24:00.060
Like they would show up in whatever order they just came back.


00:24:00.060 --> 00:24:03.540
Now it's like the stuff that's about it more specifically shows up first.


00:24:03.540 --> 00:24:04.540
Oh, very helpful.


00:24:04.540 --> 00:24:05.540
Yeah, indeed.


00:24:05.540 --> 00:24:06.540
So hopefully that's a little bit helpful.


00:24:06.540 --> 00:24:07.540
For me too.


00:24:07.540 --> 00:24:08.540
I use that all the time.


00:24:08.540 --> 00:24:09.540
I know.


00:24:09.540 --> 00:24:11.020
That's why I'm like, there's this thing.


00:24:11.020 --> 00:24:12.020
I know it's in here.


00:24:12.020 --> 00:24:13.460
And why are there so many results?


00:24:13.460 --> 00:24:16.540
It should be right at the top because the title is basically what I searched for.


00:24:16.540 --> 00:24:17.540
Yeah, exactly.


00:24:17.540 --> 00:24:19.980
So this is for us, but people can benefit as well.


00:24:19.980 --> 00:24:20.980
Definitely.


00:24:20.980 --> 00:24:21.980
All right.


00:24:21.980 --> 00:24:22.980
You got some jokes?


00:24:22.980 --> 00:24:27.740
These are definitely groaners, but they're submitted by friends of the show on Twitter,


00:24:27.740 --> 00:24:29.420
so I appreciate this.


00:24:29.420 --> 00:24:30.660
So a couple of them.


00:24:30.660 --> 00:24:36.500
Due to social distancing, I wonder how many projects are migrating to UDP and away from


00:24:36.500 --> 00:24:38.460
TLS to avoid all the handshakes.


00:24:38.460 --> 00:24:40.180
>> Well, we have to, right?


00:24:40.180 --> 00:24:41.180
>> Yeah.


00:24:41.180 --> 00:24:43.660
>> You don't want to get a computer virus.


00:24:43.660 --> 00:24:46.700
>> Next, a chef and a vagrant walk into a bar.


00:24:46.700 --> 00:24:52.020
Within a few seconds, it was identical to the last bar they went into.


00:24:52.020 --> 00:24:59.080
I got it. So Vagrant manages virtual machines and Chefs helps set up, configure those environments.


00:24:59.080 --> 00:25:00.080
Got it.


00:25:00.080 --> 00:25:01.080
Okay.


00:25:01.080 --> 00:25:02.080
Nice.


00:25:02.080 --> 00:25:03.080
Anyway, so.


00:25:03.080 --> 00:25:08.260
Yeah. I like how you're leaving somewhat understanding these as an exercise of the reader and partially


00:25:08.260 --> 00:25:11.500
I'm ruining their joy of solving the problem.


00:25:11.500 --> 00:25:18.660
Yeah. No, it's all good. Both of these took me a little bit of Googling to understand.


00:25:18.660 --> 00:25:21.980
Beautiful. I like them. They're definitely groaners, but they do kind of make you feel


00:25:21.980 --> 00:25:23.980
you think for a second as well, which is great.


00:25:23.980 --> 00:25:24.980
Yeah.


00:25:24.980 --> 00:25:25.980
So thanks a lot.


00:25:25.980 --> 00:25:26.980
Yeah.


00:25:26.980 --> 00:25:27.980
You bet.


00:25:27.980 --> 00:25:28.980
I think we're done.


00:25:28.980 --> 00:25:29.980
Thanks.


00:25:29.980 --> 00:25:30.980
See ya.


00:25:30.980 --> 00:25:31.980
Bye.


00:25:31.980 --> 00:25:32.980
Thank you for listening to Python Bytes.


00:25:32.980 --> 00:25:33.980
Follow the show on Twitter @pythonbytes.


00:25:33.980 --> 00:25:35.420
That's Python Bytes as in B-Y-T-E-S.


00:25:35.420 --> 00:25:38.300
And get the full show notes at pythonbytes.fm.


00:25:38.300 --> 00:25:42.860
If you have a news item you want featured, just visit pythonbytes.fm and send it our


00:25:42.860 --> 00:25:43.860
way.


00:25:43.860 --> 00:25:45.400
We're always on the lookout for sharing something cool.


00:25:45.400 --> 00:25:49.300
This is Brian Okken, and on behalf of myself and Michael Kennedy, thank you for listening


00:25:49.300 --> 00:25:51.700
and sharing this podcast with your friends and colleagues.

