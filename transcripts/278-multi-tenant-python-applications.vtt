WEBVTT

00:00:00.001 --> 00:00:04.760
Hello and welcome to Python Bytes, where we deliver Python news and headlines directly to your earbuds.

00:00:04.760 --> 00:00:10.220
This is episode 278, recorded April 6th, 2022.

00:00:10.220 --> 00:00:11.620
I'm Michael Kennedy.

00:00:11.620 --> 00:00:12.980
And I'm Brian Okken.

00:00:12.980 --> 00:00:14.500
And I'm Vuisile Ngovo.

00:00:14.500 --> 00:00:17.000
Welcome, Vuisile. It's really great to have you here.

00:00:17.000 --> 00:00:20.380
You know, I'm really excited and I feel honored to be here.

00:00:20.380 --> 00:00:21.880
So thanks for the opportunity.

00:00:21.880 --> 00:00:24.780
Yeah, it's going to be great to share some Python news with you.

00:00:24.780 --> 00:00:28.180
Now, before we jump into all those things, tell us a bit about yourself.

00:00:28.620 --> 00:00:30.000
What do you do? What are you into?

00:00:30.000 --> 00:00:34.260
Firstly, I'd like to say I'm still relatively early on in my career.

00:00:34.260 --> 00:00:36.320
And I'm from Zimbabwe.

00:00:36.320 --> 00:00:39.680
And we have a small but growing Python community here.

00:00:39.680 --> 00:00:43.520
And for a long time, I didn't have any community.

00:00:43.520 --> 00:00:49.760
So podcasts like your talk Python podcast was the only way I got to connect with community members.

00:00:49.760 --> 00:00:51.480
So it's really great to be here.

00:00:51.480 --> 00:00:55.720
But on the question about me, I'm a software developer.

00:00:55.720 --> 00:00:57.400
I work in the back end.

00:00:57.640 --> 00:01:00.300
I work for a company called Ideation.ai.

00:01:00.300 --> 00:01:09.300
It's a health tech startup that's building information systems that help clinicians manage patients and hospitals better.

00:01:09.300 --> 00:01:15.620
So I work mostly on APIs and microservices using Python, Django, Postgres mostly.

00:01:15.620 --> 00:01:17.560
That sounds like a really fun project.

00:01:17.560 --> 00:01:22.600
And we know that health care needs help and automation and modernization.

00:01:22.600 --> 00:01:23.640
So thanks.

00:01:23.640 --> 00:01:24.140
That's awesome.

00:01:24.140 --> 00:01:25.360
Yeah, very cool.

00:01:25.360 --> 00:01:25.880
All right.

00:01:25.880 --> 00:01:26.860
Brian, should we kick it off?

00:01:26.860 --> 00:01:28.000
Yeah, sure.

00:01:28.000 --> 00:01:29.900
When you talk about getting drunk or what is this?

00:01:29.900 --> 00:01:31.040
Getting drunk.

00:01:31.040 --> 00:01:31.900
Oh, sorry.

00:01:31.900 --> 00:01:32.840
I must have misread that.

00:01:34.900 --> 00:01:38.540
So this was just announced a few days ago from Darren Burns.

00:01:38.540 --> 00:01:44.000
He's the engineer that's helping William.

00:01:44.000 --> 00:01:44.960
Is it Will?

00:01:44.960 --> 00:01:45.380
Will.

00:01:45.380 --> 00:01:48.500
With Rich and everything.

00:01:48.500 --> 00:01:50.340
The Rich Empire.

00:01:50.340 --> 00:01:51.140
Yeah.

00:01:51.680 --> 00:01:57.300
So this is just really cool because I often wanted to, the dunk, he released dunk.

00:01:57.300 --> 00:02:02.580
So dunk is a prettier get diff tool.

00:02:03.180 --> 00:02:08.780
And it uses Rich and it's just a command line tool and it's beautiful.

00:02:08.780 --> 00:02:14.500
So you just even install it and then you do a get diff on something.

00:02:14.500 --> 00:02:18.280
It could be one file or it could be, it's usually a commit, right?

00:02:18.280 --> 00:02:21.920
So you do a diff of whatever you have now or other stuff.

00:02:21.920 --> 00:02:26.700
And it just, instead of doing the weird, like the hard to read command line.

00:02:26.700 --> 00:02:27.720
The plus, minus, plus.

00:02:27.720 --> 00:02:28.140
Yeah.

00:02:28.140 --> 00:02:29.080
Yeah, that thing.

00:02:29.420 --> 00:02:35.080
It's got these nice, just this nice colors with Rich of like, you know, what was added,

00:02:35.080 --> 00:02:37.700
what was green for added, red for taken out.

00:02:37.700 --> 00:02:40.180
And the line numbers.

00:02:40.180 --> 00:02:41.140
It's beautiful.

00:02:41.140 --> 00:02:44.800
And it's still a work in progress, but I'm using it already.

00:02:44.800 --> 00:02:45.580
It's just great.

00:02:45.580 --> 00:02:46.920
This is fantastic.

00:02:46.920 --> 00:02:51.500
When I first looked at this, I thought it was like a gooey window that was showing, but

00:02:51.500 --> 00:02:52.440
no, that's just the terminal.

00:02:52.440 --> 00:02:53.180
Yeah.

00:02:53.180 --> 00:02:54.040
Yeah.

00:02:54.040 --> 00:02:54.480
Yeah.

00:02:54.480 --> 00:02:55.500
It's pretty cool.

00:02:55.500 --> 00:02:58.460
You know, text editor, right?

00:02:58.460 --> 00:02:59.160
Yeah.

00:02:59.160 --> 00:02:59.800
Definitely.

00:02:59.800 --> 00:03:04.480
Some text editors have, have something that like this nice, but just on the command line,

00:03:04.480 --> 00:03:05.260
it's super cool.

00:03:05.260 --> 00:03:10.080
Um, the, one of my first questions with it was sometimes I have a lot of diff stuff.

00:03:10.080 --> 00:03:11.460
So does this have a pager?

00:03:11.460 --> 00:03:18.900
And the answer from Darren was, it does not have a pager, but, but you can use a less

00:03:18.900 --> 00:03:20.280
dash capital R.

00:03:20.280 --> 00:03:26.140
I don't know what the R does, but anyway, if you pipe, get diff to dunk and then pipe it

00:03:26.140 --> 00:03:29.820
to less dash R, you've got a diff with a pager that works for me.

00:03:29.820 --> 00:03:31.380
I'll just alias that to something.

00:03:31.380 --> 00:03:32.300
So, yeah.

00:03:32.300 --> 00:03:32.860
Yeah.

00:03:32.860 --> 00:03:33.400
That's really cool.

00:03:33.400 --> 00:03:36.620
Anyway, pretty quick, pretty short, topic.

00:03:36.620 --> 00:03:41.640
But, for people that are looking at, get diffs a lot, this is a super handy thing

00:03:41.640 --> 00:03:42.160
to look at.

00:03:42.160 --> 00:03:42.520
Yeah.

00:03:42.520 --> 00:03:42.980
This is neat.

00:03:42.980 --> 00:03:47.520
I usually do a lot of my diffs in PyCharm and it actually looks real similar to that UI.

00:03:47.520 --> 00:03:49.060
We see, what about you?

00:03:49.060 --> 00:03:50.980
How do you see your diffs?

00:03:50.980 --> 00:03:51.580
Yeah.

00:03:51.580 --> 00:03:57.120
I do most of my coding and Visual Studio Code and I use the visual studio diff, viewer

00:03:57.120 --> 00:03:57.940
for that same.

00:03:57.940 --> 00:03:59.220
It's pretty similar to this.

00:03:59.220 --> 00:04:00.380
Nice.

00:04:00.380 --> 00:04:00.700
Yeah.

00:04:00.700 --> 00:04:01.260
This looks great.

00:04:01.260 --> 00:04:02.720
I think very nice.

00:04:02.720 --> 00:04:04.160
Yeah.

00:04:04.400 --> 00:04:05.200
Very nice one.

00:04:05.200 --> 00:04:06.700
How about we start with some memes?

00:04:06.700 --> 00:04:10.640
So we all heard about log4j.

00:04:10.640 --> 00:04:18.260
Uh, and my favorite one was the take on the XKCD about little Bobby tables, the little, little,

00:04:18.260 --> 00:04:21.560
little Jindy we call him or something like that.

00:04:21.560 --> 00:04:26.500
I can't remember, but you know, all the jokes aside, like, you know, here's Homer Simpson,

00:04:26.500 --> 00:04:29.020
zero days without log4j CVE.

00:04:29.020 --> 00:04:34.380
And, maybe the best one was that, that this guy right here, this, this guy,

00:04:34.380 --> 00:04:39.280
he looks like he's probably about 75 or entire and says upgraded log, upgrading log4j three

00:04:39.280 --> 00:04:39.620
times.

00:04:39.620 --> 00:04:40.620
It wasn't that stressful.

00:04:40.620 --> 00:04:42.480
Says Dave, 28 years old.

00:04:42.480 --> 00:04:48.060
But in all seriousness, like, is there a log for pi?

00:04:48.060 --> 00:04:49.820
Like, is this something that we should consider?

00:04:49.820 --> 00:04:52.520
And my first thought was, yeah, no, we're good.

00:04:52.520 --> 00:04:56.880
Like we don't have this stupid, like remote method invocation where you can inject like,

00:04:56.880 --> 00:05:02.400
um, a function call as a string inside of your, your log message.

00:05:02.400 --> 00:05:02.960
Oh no.

00:05:03.360 --> 00:05:08.260
But here's Ari Bovenberg who wrote an article that says, yeah, it's not anywhere near as

00:05:08.260 --> 00:05:10.940
severe as that, but there are some things you should consider.

00:05:10.940 --> 00:05:14.900
And so for your consideration, I present this article and some ideas.

00:05:14.900 --> 00:05:17.180
So it says, look, here's the basics of logging.

00:05:17.180 --> 00:05:19.620
And this is using Python's built in logger.

00:05:19.620 --> 00:05:25.740
I'm, I'm a fan of, log book and log guru and the sort of higher level nicer things, but

00:05:25.740 --> 00:05:27.320
nonetheless, here's the basics, right?

00:05:27.640 --> 00:05:33.100
So you can log like say logger.info or trace or whatever, and then put out a message like

00:05:33.100 --> 00:05:33.620
hello world.

00:05:33.620 --> 00:05:34.880
There's no injection there.

00:05:34.880 --> 00:05:39.760
You can also do this thing, which is really the crux of the problem across the board is

00:05:39.760 --> 00:05:44.280
you can say, here's a formatted string and the data that formats it.

00:05:44.460 --> 00:05:50.240
Uh, so you can put in the problem with log for J was even if the string was fully evaluated

00:05:50.240 --> 00:05:54.820
as user input or something, you take some user input and you fully validate it.

00:05:54.880 --> 00:06:00.240
It still could have, it'll still get like reinterpreted for these remote, like trying to find you

00:06:00.240 --> 00:06:02.620
what machine am I running on or my production or debug?

00:06:02.620 --> 00:06:06.200
Like, let me go call this function and find out or just call it to hack you.

00:06:06.200 --> 00:06:11.740
But so the Python version doesn't have that, but you can do this like format string and pass

00:06:11.740 --> 00:06:17.380
this context variable thing, like pass a data structure in, in, in that case, some bad stuff

00:06:17.380 --> 00:06:19.520
can actually happen here.

00:06:19.520 --> 00:06:20.100
Right?

00:06:20.320 --> 00:06:21.000
So that's fine.

00:06:21.000 --> 00:06:26.480
So as well, what about, what if I wrote my, as my name instead of, or my message instead

00:06:26.480 --> 00:06:34.000
of hello, I wrote hello, quote backslash and info main user, Alice commented something else.

00:06:34.000 --> 00:06:35.740
And you would, you pass that over.

00:06:35.740 --> 00:06:39.640
And what you would end up with is a log message that was supposed to be one line that ends up

00:06:39.640 --> 00:06:40.120
like two.

00:06:40.120 --> 00:06:43.120
So that could cause some confusion, right?

00:06:43.120 --> 00:06:44.700
That might, might be problematic.

00:06:44.700 --> 00:06:49.780
It's not going to result you in being hacked, but there's more like denial of service type of

00:06:49.780 --> 00:06:49.960
thing.

00:06:50.040 --> 00:06:53.380
So like one thing you could say is, well, just don't use backslash N, like take those

00:06:53.380 --> 00:06:53.600
out.

00:06:53.600 --> 00:07:00.460
But there are all sorts of freaky Unicode ways to like restructure similar meanings and stuff.

00:07:00.460 --> 00:07:03.260
So another one has to do with formatting.

00:07:03.260 --> 00:07:08.720
So if you're logging in some information and it's just a regular F string, that's probably

00:07:08.720 --> 00:07:09.460
fine.

00:07:09.460 --> 00:07:15.420
But if what you're logging into the F string, you can later get evaluated again, passing this

00:07:15.420 --> 00:07:20.260
data structure, asking the logger to fill out the format string.

00:07:20.260 --> 00:07:22.320
Then you can pass interesting stuff.

00:07:22.320 --> 00:07:29.760
One of the more interesting ones was you could say percent, parenthesis, variable name, close

00:07:29.760 --> 00:07:33.340
parenthesis, 99999999999s.

00:07:33.340 --> 00:07:38.060
And what that'll do is it'll pad the username with a gigabyte of white space and then try to

00:07:38.060 --> 00:07:39.360
have you write it to the log file.

00:07:40.580 --> 00:07:41.200
Oh, great.

00:07:41.200 --> 00:07:43.940
So that's bad, right?

00:07:43.940 --> 00:07:45.000
Right.

00:07:45.000 --> 00:07:45.320
Yeah.

00:07:45.320 --> 00:07:50.480
You could also do things if you knew the data structure that was being passed in to fill

00:07:50.480 --> 00:07:51.460
out the log string.

00:07:51.920 --> 00:07:57.680
You could sort of try to reach out and get variable names out of it by putting a formatted

00:07:57.680 --> 00:07:58.360
string in there.

00:07:58.360 --> 00:08:04.140
And if you marry that with the huge piece of text, that'll make the login really slow.

00:08:04.140 --> 00:08:07.040
So you could put in like different things.

00:08:07.040 --> 00:08:11.760
And if you see, oh, this message actually makes the request really slow, you could infer that

00:08:11.760 --> 00:08:15.660
maybe that data is actually in the variable being passed over.

00:08:15.660 --> 00:08:19.340
So then you could try to get it to write it to a file if you have, say, file access, but

00:08:19.340 --> 00:08:20.320
not other types of access.

00:08:20.320 --> 00:08:20.720
Anyway.

00:08:21.060 --> 00:08:21.840
So there's a bunch of things.

00:08:21.840 --> 00:08:27.780
So basically the long story short is don't mix like F string formatting along with passing

00:08:27.780 --> 00:08:29.040
more data to the log file.

00:08:29.040 --> 00:08:34.120
One or the other, because the logger knows how to look for some of these things when it

00:08:34.120 --> 00:08:38.360
takes the data and puts it in the format, but it doesn't do that for the original string.

00:08:38.360 --> 00:08:40.060
So careful about mix and match.

00:08:40.060 --> 00:08:40.660
Final thing.

00:08:40.660 --> 00:08:46.320
There's actually, it's been included in a PEP and there's a discussion on discuss.python.org.

00:08:46.320 --> 00:08:49.460
And there's actually a pretty interesting discussion with a bunch of core devs there.

00:08:49.580 --> 00:08:53.540
So you can see that's maybe a better follow up there, but pretty interesting.

00:08:53.920 --> 00:09:00.700
There's no log for PIE, but there doesn't mean you can just completely go crazy with unverified

00:09:00.700 --> 00:09:01.220
user input.

00:09:01.220 --> 00:09:03.160
You should trust your users though.

00:09:03.160 --> 00:09:03.900
I know.

00:09:03.900 --> 00:09:06.180
Why not?

00:09:06.180 --> 00:09:08.120
They're so friendly and consider.

00:09:08.120 --> 00:09:08.320
Yeah.

00:09:08.320 --> 00:09:08.980
Why not?

00:09:08.980 --> 00:09:10.420
The real ones are.

00:09:10.420 --> 00:09:16.900
You know, when this, when this log for J vulnerability came out and I realized that it wasn't really a big

00:09:16.900 --> 00:09:19.020
problem in Python, I didn't pay any attention to it.

00:09:19.020 --> 00:09:23.720
And now I'm, I'm actually shocked that you could do a denial of service attack using that.

00:09:23.720 --> 00:09:24.740
Yeah, exactly.

00:09:24.740 --> 00:09:28.020
I think that's what it basically becomes is there's two aspects.

00:09:28.020 --> 00:09:31.740
One is you can sort of crush the server by having it write so much data.

00:09:31.740 --> 00:09:38.540
The other that they pointed out here was if your goal is to try to obscure regular hacking,

00:09:38.540 --> 00:09:44.840
if you could wreck the log file with so much data that it's really difficult for people to parse the

00:09:44.840 --> 00:09:47.760
log file, you might be able to hide yourself a little bit better for longer.

00:09:47.760 --> 00:09:49.720
So anyway, there's some interesting stuff there.

00:09:49.720 --> 00:09:51.160
All right, we see that over to you.

00:09:51.160 --> 00:09:52.000
Yep.

00:09:52.000 --> 00:09:52.360
Thanks.

00:09:52.360 --> 00:09:59.480
If you're building a software as a service platform in Python and Django, there are a few

00:09:59.480 --> 00:10:03.620
things to think about, you know, like the architecture you're going to use, what type of database

00:10:03.620 --> 00:10:08.480
you're going to use, whether you use a single database or multiple databases and all these

00:10:08.480 --> 00:10:08.740
things.

00:10:08.740 --> 00:10:14.740
So while I was getting ready for this call, I found this book, it's called Building Multi-Tenant

00:10:14.740 --> 00:10:15.940
Applications with Django.

00:10:15.940 --> 00:10:18.940
And it's by an author that you've actually covered on the show.

00:10:18.940 --> 00:10:20.900
It's a company, I think, called the Gin.

00:10:21.580 --> 00:10:23.220
So this book is free.

00:10:23.220 --> 00:10:23.940
It's open source.

00:10:23.940 --> 00:10:26.180
Anyone's free to read it, download it.

00:10:26.180 --> 00:10:30.720
And it goes through the different approaches that you'd have to follow.

00:10:30.720 --> 00:10:35.020
I mean, the different architecture designs that you should consider when building software as a

00:10:35.020 --> 00:10:36.640
service or multi-tenant applications.

00:10:37.220 --> 00:10:42.860
And so one of the things they cover here is email where you're using queries to isolate

00:10:42.860 --> 00:10:43.320
the data.

00:10:43.320 --> 00:10:46.020
Something like Postgres, you must do that.

00:10:46.020 --> 00:10:51.160
This book goes over the different approaches you can use to build multi-tenancy apps, right?

00:10:51.500 --> 00:10:58.940
And then it also covers some third-party packages that you can install that help do a lot of the boilerplate code for you.

00:10:58.940 --> 00:11:00.040
That's really nice.

00:11:00.040 --> 00:11:01.180
Because I've considered this.

00:11:01.180 --> 00:11:10.580
It'd be so great if you're doing some sort of software as a service type thing where people log in and you want that group just to see all their data and all their records and stuff.

00:11:10.640 --> 00:11:15.980
But it's so scary because if you just forget the where clause on just one, on just one.

00:11:15.980 --> 00:11:16.580
Exactly.

00:11:16.580 --> 00:11:19.240
They get everybody's data, which is really bad, right?

00:11:19.240 --> 00:11:21.160
And so this is really cool.

00:11:21.160 --> 00:11:21.760
Yeah.

00:11:21.760 --> 00:11:22.660
Yeah, this is neat.

00:11:22.660 --> 00:11:35.900
So the book covers things like using HTTP headers or subdomains in the request to identify different tenants and how you do that, how you capture that using middleware in Django.

00:11:35.900 --> 00:11:37.200
That's cool.

00:11:37.200 --> 00:11:44.720
So some of the middleware is Django multi-tenant, Django tenant schemas, or Django DB multi-tenant.

00:11:44.720 --> 00:11:49.140
Not a ton of variation in the name in there, but it's still pretty cool, right?

00:11:49.140 --> 00:11:53.240
And some of them use schemas and some of them use isolated databases, right?

00:11:53.240 --> 00:11:53.780
Yeah.

00:11:53.780 --> 00:11:54.300
Yeah.

00:11:54.300 --> 00:11:54.940
Nice.

00:11:54.940 --> 00:12:00.920
So it will depend on what your tolerance for cost is and database management.

00:12:00.920 --> 00:12:04.500
So if you don't mind having a database for each client, you could do that.

00:12:04.500 --> 00:12:09.160
And then you'd have to do migrations on each database, wherever you make updates to the application.

00:12:09.160 --> 00:12:13.200
Or if you just want to have a single shared database, you can do that and isolate using schemas.

00:12:13.200 --> 00:12:13.820
Yeah.

00:12:13.820 --> 00:12:18.980
I hadn't thought about having to migrate every separate database, but yeah, that's a ton of work.

00:12:18.980 --> 00:12:21.420
The deployment all of a sudden looks really rough, doesn't it?

00:12:21.420 --> 00:12:21.940
Yeah.

00:12:21.940 --> 00:12:22.280
Yeah.

00:12:22.280 --> 00:12:23.860
But that's true isolation there.

00:12:23.860 --> 00:12:24.480
Yeah, exactly.

00:12:24.480 --> 00:12:26.360
There's no way you're going to make a mistake there.

00:12:26.360 --> 00:12:30.120
Do you guys do anything like this with your healthcare products?

00:12:30.120 --> 00:12:30.780
Yeah.

00:12:30.780 --> 00:12:31.060
Yeah.

00:12:31.060 --> 00:12:32.200
We use one of these approaches.

00:12:32.200 --> 00:12:38.700
I can't tell you which one, but we use our software as a, what do you call it?

00:12:38.700 --> 00:12:39.940
Software as a service.

00:12:40.120 --> 00:12:41.920
We have a number of clients.

00:12:41.920 --> 00:12:48.140
They need to have a central login, like the single application that you can all log in and view only their data.

00:12:48.140 --> 00:12:51.560
And we can't have information from one client leaking over into another.

00:12:51.560 --> 00:12:52.100
Yeah.

00:12:52.100 --> 00:12:52.600
Cool.

00:12:52.600 --> 00:12:53.060
All right.

00:12:53.060 --> 00:12:53.700
Well, really neat.

00:12:53.700 --> 00:12:55.960
I'm sure that'll be super valuable to people.

00:12:55.960 --> 00:12:56.400
Indeed.

00:12:56.400 --> 00:12:57.020
Yeah.

00:12:57.340 --> 00:13:00.780
Now, Brian, before we move on, how about I tell you about our sponsor?

00:13:00.780 --> 00:13:02.760
Once again, Microsoft is here.

00:13:02.760 --> 00:13:04.680
So let's hear from them before we carry on.

00:13:04.680 --> 00:13:09.720
This episode of Python Bytes is brought to you by Microsoft for Startups Founders Hub.

00:13:09.720 --> 00:13:11.480
Starting a business is hard.

00:13:11.480 --> 00:13:16.420
By some estimates, over 90% of startups will go out of business in just their first year.

00:13:16.420 --> 00:13:21.800
With that in mind, Microsoft for Startups set out to understand what startups need to be successful

00:13:21.800 --> 00:13:25.560
and to create a digital platform to help them overcome those challenges.

00:13:25.560 --> 00:13:28.260
Microsoft for Startups Founders Hub was born.

00:13:28.260 --> 00:13:34.900
Founders Hub provides all founders at any stage with free resources to solve their startup challenges.

00:13:34.900 --> 00:13:40.420
The platform provides technology benefits, access to expert guidance and skilled resources,

00:13:40.420 --> 00:13:43.320
mentorship and networking connections, and much more.

00:13:43.320 --> 00:13:48.540
Unlike others in the industry, Microsoft for Startups Founders Hub doesn't require startups

00:13:48.540 --> 00:13:52.580
to be investor backed or third party validated to participate.

00:13:52.580 --> 00:13:55.080
Founders Hub is truly open to all.

00:13:55.080 --> 00:13:56.580
So what do you get if you join them?

00:13:56.580 --> 00:14:01.360
You speed up your development with free access to GitHub and Microsoft Cloud computing resources

00:14:01.360 --> 00:14:04.820
and the ability to unlock more credits over time.

00:14:04.820 --> 00:14:09.480
To help your startup innovate, Founders Hub is partnering with innovative companies like OpenAI,

00:14:09.480 --> 00:14:14.520
a global leader in AI research and development, to provide exclusive benefits and discounts.

00:14:14.520 --> 00:14:19.620
Through Microsoft for Startups Founders Hub, becoming a founder is no longer about who you know.

00:14:19.620 --> 00:14:23.700
You'll have access to their mentorship network, giving you a pool of hundreds of mentors

00:14:23.700 --> 00:14:29.860
across a range of disciplines and areas like idea validation, fundraising, management and coaching,

00:14:29.860 --> 00:14:33.160
sales and marketing, as well as specific technical stress points.

00:14:33.160 --> 00:14:37.840
You'll be able to book a one-on-one meeting with the mentors, many of whom are former founders

00:14:37.840 --> 00:14:38.300
themselves.

00:14:38.300 --> 00:14:43.360
Make your idea a reality today with the critical support you'll get from Founders Hub.

00:14:43.360 --> 00:14:47.640
To join the program, just visit pythonbytes.fm/foundershub.

00:14:47.760 --> 00:14:49.560
All one word, no links in your show notes.

00:14:49.560 --> 00:14:51.560
Thank you to Microsoft for supporting the show.

00:14:53.140 --> 00:14:58.660
This is a topic that has been very interesting to me, sort of this memory story around Python lists.

00:14:58.660 --> 00:14:59.880
Yeah.

00:14:59.880 --> 00:15:02.300
I'm looking forward to this one you got to share.

00:15:02.300 --> 00:15:03.940
So I was interested.

00:15:03.940 --> 00:15:09.380
This is a, we're going to present an article called Pre-Allocated Lists in Python by Redouan

00:15:09.380 --> 00:15:10.740
Delaware, I think.

00:15:11.800 --> 00:15:16.160
Anyway, I've always, I've thought about this before because one of the things that happens

00:15:16.160 --> 00:15:20.940
with when you allocate a list in Python, if it's empty, it's not really empty.

00:15:20.940 --> 00:15:22.360
There's some data there already.

00:15:22.360 --> 00:15:27.820
And one of the first things the article talks about is this data structure that AC struct that

00:15:27.820 --> 00:15:31.500
Python uses to store basically the info about the list.

00:15:31.580 --> 00:15:35.580
But it's still space, but it's, you know, it's still, it's empty, supposedly.

00:15:35.580 --> 00:15:39.340
And then when you, and normally you kind of just append to it.

00:15:39.340 --> 00:15:45.180
So you, or one way to add things to a list is to just append one thing after another.

00:15:45.180 --> 00:15:51.000
And what Python does, it's kind of a neat algorithm, is it allocates more than it needs.

00:15:51.000 --> 00:15:55.760
So if you add, if it, you, you add like five things or six things or something, and there's

00:15:55.760 --> 00:16:00.780
not enough space, it'll, it'll, and I don't remember the real algorithm, but it chunks a

00:16:00.780 --> 00:16:01.720
bigger portion.

00:16:01.720 --> 00:16:06.220
And then if you run out of space again, you get more space added to it.

00:16:06.220 --> 00:16:06.640
Right.

00:16:06.640 --> 00:16:12.420
Because the last thing you want to do is reallocate for every bite at a time and copy the whole

00:16:12.420 --> 00:16:14.080
list as you're adding a thousand items.

00:16:14.080 --> 00:16:15.160
That would be super bad.

00:16:15.160 --> 00:16:15.760
Right.

00:16:15.760 --> 00:16:18.680
So this, this article talks about three different ways.

00:16:18.680 --> 00:16:22.180
Like, let's say, if you know, you know, you're going to have 10,000 elements in a list.

00:16:22.180 --> 00:16:30.600
Um, and, in this example, it's just counting, you know, a zero through, you know, 9,999,

00:16:30.600 --> 00:16:31.900
and filling it into the list.

00:16:31.900 --> 00:16:36.720
Uh, but, but there's, that's, I think that that's irrelevant.

00:16:36.720 --> 00:16:40.940
It's the same sort of work, for each kind of list, but it takes three kinds.

00:16:40.940 --> 00:16:44.800
Well, the first kind is starting with an empty list and just appending every time.

00:16:44.800 --> 00:16:48.660
And that seems like it would be slow, but, it's not actually not.

00:16:48.660 --> 00:16:50.960
The other two ways are to preallocate.

00:16:50.960 --> 00:16:52.880
And I'm like, how would you preallocate?

00:16:52.880 --> 00:17:02.000
Uh, but, his, his technique was to, to take like none and, assign your list

00:17:02.000 --> 00:17:03.460
none times 10,000.

00:17:03.460 --> 00:17:06.440
So you had a 10,000 element list of nuns.

00:17:06.440 --> 00:17:07.240
That's fine.

00:17:07.240 --> 00:17:08.460
Um, and then.

00:17:08.460 --> 00:17:10.680
Long as that's not a valid value, you're fine.

00:17:11.120 --> 00:17:11.640
Yeah.

00:17:11.640 --> 00:17:20.100
Um, and then the, the other, the third way, was to take, let's see, where is it?

00:17:20.100 --> 00:17:26.860
Is to, to do a list comprehension and do, and just assign your list, the list comprehension,

00:17:26.860 --> 00:17:32.300
um, and then put a for loop, for I in range 10,000 in the middle of it.

00:17:32.540 --> 00:17:37.120
Um, and in, in the case, in this case, if you, if you weren't really just counting to

00:17:37.120 --> 00:17:40.980
a 10,000 and doing something else, it would be a similar sort of thing of you'd have a for

00:17:40.980 --> 00:17:42.400
loop to fill this, this in.

00:17:42.400 --> 00:17:46.540
And I, I actually had no guesses as to what would be fastest.

00:17:46.540 --> 00:17:53.540
So the, the, the, the, the final say when he was doing timing on this was that the append

00:17:53.540 --> 00:17:57.820
method actually was, was the slowest, but not terrible.

00:17:57.820 --> 00:18:02.380
Um, it's pretty efficient and the pre allocate method, it shaved.

00:18:02.380 --> 00:18:05.560
So we had a 499 microseconds on his machine.

00:18:05.560 --> 00:18:10.280
Um, and then 321 on, the pre allocate.

00:18:10.280 --> 00:18:15.320
Um, so that's not even half as, I mean, it's not an order of magnitude, but it is faster.

00:18:15.400 --> 00:18:18.360
And the list comprehension was 225.

00:18:18.360 --> 00:18:19.960
So that was about half.

00:18:19.960 --> 00:18:25.800
It was about, twice as fast as the append was to use the list comprehension and list comprehension

00:18:25.800 --> 00:18:28.620
is actually the most readable of the three, I think.

00:18:28.620 --> 00:18:34.900
So, it's just sort of a, that I guess it's an interesting article to look at like how

00:18:34.900 --> 00:18:42.000
to discuss like how, how this, this allocating and allocating extra memory happens, with

00:18:42.000 --> 00:18:42.420
append.

00:18:42.420 --> 00:18:47.480
But it also, is interesting that the pre allocate, it seems like that would be the

00:18:47.480 --> 00:18:49.020
fast, one of the faster ones.

00:18:49.020 --> 00:18:51.340
And it's not, so interesting.

00:18:51.340 --> 00:18:52.520
Uh, yeah.

00:18:52.520 --> 00:18:56.400
I wonder if, I don't think the list has this.

00:18:56.400 --> 00:19:00.560
I know in other languages it does where you, when you create the list empty, you can say,

00:19:00.620 --> 00:19:02.840
I would like to initialize you with this capacity.

00:19:02.840 --> 00:19:03.600
Yeah.

00:19:03.600 --> 00:19:04.120
Right.

00:19:04.120 --> 00:19:09.620
And if it was like a built-in way to say, when you allocate your inner C level array pointers,

00:19:09.620 --> 00:19:14.120
make it this big to start with, but still sort of fill into it before you start your growing

00:19:14.120 --> 00:19:14.600
algorithm.

00:19:14.600 --> 00:19:15.200
Yeah.

00:19:15.440 --> 00:19:18.980
Maybe that'd be a cool PEP for some of the containers if it's not there, but yeah, this,

00:19:18.980 --> 00:19:21.720
I, I think it's natural that the list comprehension is fastest.

00:19:21.720 --> 00:19:26.220
And also it doesn't, it means you don't end up with a weird programming model where you have a list.

00:19:26.220 --> 00:19:29.280
It's length is one thing, but that's not what you should actually work with.

00:19:29.280 --> 00:19:32.720
I think that's, it's probably not worth it except for extreme cases.

00:19:33.220 --> 00:19:38.860
A couple of things that I was, I found interesting about this that I'd like to pursue a little further is it

00:19:38.860 --> 00:19:40.160
didn't talk about memory space.

00:19:40.160 --> 00:19:44.300
So one of the benefits of pre-allocating is you're not allocating more than you need,

00:19:44.300 --> 00:19:46.380
but I don't know if you're not allocating.

00:19:46.380 --> 00:19:49.260
I don't know what the, the, the Python algorithm is.

00:19:49.260 --> 00:19:55.740
But, but the, so I'd, I'd like to see this with space.

00:19:55.740 --> 00:19:58.380
So how much memory is being used by the three methods.

00:19:58.380 --> 00:20:04.060
The other thing that would be interesting to see is to throw NumPy in the mix because I

00:20:04.060 --> 00:20:08.860
know NumPy has some more efficient, I mean, it's a completely different beast, but still.

00:20:08.860 --> 00:20:12.180
You work with homogeneous data that's numbers or something or strings.

00:20:12.180 --> 00:20:12.400
Yeah.

00:20:12.400 --> 00:20:13.840
What do you think about this?

00:20:13.840 --> 00:20:16.120
Do you have to worry about these little details?

00:20:16.120 --> 00:20:18.500
Are you guys under like heavy performance pressure?

00:20:18.500 --> 00:20:21.200
You know, no, not, not right now, at least.

00:20:21.200 --> 00:20:27.100
I've never had to think about like C level things and I'm actually taken aback that so much

00:20:27.100 --> 00:20:31.600
goes into allocating stuff to a list because in Python, you know, allocating stuff to a

00:20:31.600 --> 00:20:33.680
list is just create the list and put stuff in there, you know?

00:20:33.680 --> 00:20:34.160
Yeah.

00:20:34.160 --> 00:20:36.300
So this is eyeopening to me.

00:20:36.300 --> 00:20:36.780
Yeah.

00:20:36.780 --> 00:20:37.340
It's pretty cool.

00:20:37.340 --> 00:20:41.900
It's not like C where you have to pre-allocate it and then fill it out and or something funky

00:20:41.900 --> 00:20:42.420
like that.

00:20:42.420 --> 00:20:43.060
Mm-hmm.

00:20:43.060 --> 00:20:43.380
Yeah.

00:20:43.380 --> 00:20:43.760
So, yeah.

00:20:43.760 --> 00:20:48.800
So what McCugan is saying, I think the list comprehension will pre-allocate because the range object

00:20:48.800 --> 00:20:52.040
has a dunder length int method that reports its size.

00:20:52.040 --> 00:20:53.080
And yeah.

00:20:53.420 --> 00:20:57.680
So I think maybe the time saving we're getting is that we're not filling it in with

00:20:57.680 --> 00:21:01.440
nones to begin with, but actually filling it in with the data we want.

00:21:01.440 --> 00:21:02.420
Okay.

00:21:02.420 --> 00:21:02.720
Yeah.

00:21:02.720 --> 00:21:03.120
Good to know.

00:21:03.120 --> 00:21:03.680
Thank you, Will.

00:21:04.100 --> 00:21:10.640
I've more than once had a, not argument, but a disagreement where somebody said, but you

00:21:10.640 --> 00:21:16.340
need to show me because, and it's, oh, you have a for loop and you just append to the list.

00:21:16.340 --> 00:21:17.660
That's the same as a list comprehension.

00:21:17.660 --> 00:21:18.820
They're doing the same thing.

00:21:18.820 --> 00:21:24.640
The outcome, the final result is the same, but the information that Python has to work with

00:21:24.640 --> 00:21:26.380
is more much like, well, we'll say it here.

00:21:26.380 --> 00:21:28.420
It can take all the information it has to work with.

00:21:28.420 --> 00:21:30.780
I say, oh, look, it's going to be this long as we loop.

00:21:30.840 --> 00:21:33.860
And you're going to just add stuff to the list, not use it in other interesting ways.

00:21:33.860 --> 00:21:36.160
So just go and, and jam on it.

00:21:36.160 --> 00:21:36.320
Right.

00:21:36.320 --> 00:21:36.840
Yeah.

00:21:36.840 --> 00:21:37.280
Yeah.

00:21:37.280 --> 00:21:38.220
All right.

00:21:38.220 --> 00:21:44.540
Speaking of working with some data, let me tell you about this cool project called Mockaroo.

00:21:44.540 --> 00:21:45.620
You guys familiar with this?

00:21:45.620 --> 00:21:47.200
No, no, no.

00:21:47.200 --> 00:21:48.380
So here's the story.

00:21:48.380 --> 00:21:56.000
Imagine you needed some data and you want this for testing or this could be testing like unit

00:21:56.000 --> 00:21:56.340
testing.

00:21:56.500 --> 00:21:57.940
This could be development.

00:21:57.940 --> 00:22:04.340
Like one of the big problems with UI apps is having something to display just so that

00:22:04.340 --> 00:22:05.440
it, it fills it out.

00:22:05.440 --> 00:22:09.900
If I'm going to like fill out a webpage and I say, I want to work on the CSS of this, this

00:22:09.900 --> 00:22:11.920
table or the CSS of this list.

00:22:11.920 --> 00:22:14.520
If there's nothing in the list, what are you going to do?

00:22:14.520 --> 00:22:14.720
Right.

00:22:14.720 --> 00:22:18.140
So you want to have some realistic data to work with.

00:22:18.140 --> 00:22:22.500
So this Mockaroo is this free thing that has all these different types of data that you can

00:22:22.500 --> 00:22:22.960
work with.

00:22:23.160 --> 00:22:27.980
So I can come over here and just say, I want some data and I want it in a CSV format

00:22:27.980 --> 00:22:35.440
or SQL table or Firebase or Excel or XML or, you know, my favorite probably is JSON.

00:22:35.440 --> 00:22:38.040
And then you can say, all right, well, I'm going to have an ID here.

00:22:38.040 --> 00:22:39.220
We have like a customer table.

00:22:39.220 --> 00:22:42.680
So ID, first name, last name, but it has also things like gender.

00:22:42.680 --> 00:22:45.280
And one of the types you can pick is gender.

00:22:45.380 --> 00:22:47.960
So it has all these well-known data types.

00:22:47.960 --> 00:22:52.020
So if I go and type in, I want a gender, not only will it say male, female or something,

00:22:52.020 --> 00:22:53.320
it gives you like a list.

00:22:53.320 --> 00:22:57.520
So I can have gender written out as female, male or non-binary.

00:22:57.520 --> 00:23:01.500
I could have gender abbreviated as M or F or just binary.

00:23:01.500 --> 00:23:03.280
So you can have like lots of control.

00:23:03.280 --> 00:23:07.500
So if I wanted to like, you say auto or car, what do I got to type in a car?

00:23:07.500 --> 00:23:12.960
You can do like car makes, models, registration numbers, all of these things.

00:23:12.960 --> 00:23:16.780
So you can say this one is a gender abbreviated and like you fill it out.

00:23:16.780 --> 00:23:21.480
Then you can just say, generate me this data exactly like you want.

00:23:21.480 --> 00:23:23.100
And then download it in whatever format.

00:23:23.100 --> 00:23:27.680
Like I said, CSV, SQL, insert statements, JSON, Excel.

00:23:27.680 --> 00:23:28.620
Isn't that cool?

00:23:28.620 --> 00:23:29.620
That is pretty cool.

00:23:29.620 --> 00:23:31.320
So I've used this more than once.

00:23:31.320 --> 00:23:34.260
I can see a use case for this already.

00:23:34.260 --> 00:23:35.060
Awesome.

00:23:35.060 --> 00:23:35.620
Yeah, right?

00:23:35.620 --> 00:23:36.300
Yeah.

00:23:36.300 --> 00:23:36.720
Yeah.

00:23:36.720 --> 00:23:43.340
And I kind of liked the first option when you were selecting the gender type, having it be

00:23:43.340 --> 00:23:44.420
animal names.

00:23:44.420 --> 00:23:45.700
That'd be fun.

00:23:45.700 --> 00:23:46.200
Yeah.

00:23:46.200 --> 00:23:49.540
I mean, there's all like, there's all these, there's all these, that's crazy.

00:23:49.540 --> 00:23:51.400
There's all these different data formats.

00:23:51.400 --> 00:23:54.720
So you've got like cars.

00:23:54.720 --> 00:23:56.060
What else we got here?

00:23:56.060 --> 00:24:02.520
Credit cards, goods, ISBNs for books, numbers on a normal distribution, passwords.

00:24:02.520 --> 00:24:04.660
Even MongoDB object IDs.

00:24:04.660 --> 00:24:05.340
That's cool.

00:24:05.340 --> 00:24:06.140
Oh, that is pretty cool.

00:24:06.140 --> 00:24:06.420
Yeah.

00:24:06.420 --> 00:24:06.780
Yeah.

00:24:06.780 --> 00:24:14.040
So you have e-commerce stuff, money, stock market symbols, locations, healthcare.

00:24:14.040 --> 00:24:15.240
Let's see.

00:24:15.240 --> 00:24:15.880
How about that?

00:24:15.880 --> 00:24:20.620
You got your drug companies, your NHS numbers and all those different things.

00:24:20.720 --> 00:24:22.100
Oh, it's because I'm searching for common.

00:24:22.100 --> 00:24:23.460
Why is car keep showing up?

00:24:23.460 --> 00:24:24.900
Animal common names.

00:24:24.900 --> 00:24:25.180
Yeah.

00:24:25.180 --> 00:24:25.860
Yes.

00:24:25.860 --> 00:24:28.980
You could have a wombat or a jungle kangaroo.

00:24:28.980 --> 00:24:30.660
I mean, these are all some fun, right?

00:24:30.660 --> 00:24:31.160
Yeah.

00:24:31.160 --> 00:24:32.960
So these are all super neat.

00:24:32.960 --> 00:24:34.840
You can get up to like a thousand rows for free.

00:24:34.840 --> 00:24:36.820
And then I think you have to pay if you need more than that.

00:24:36.820 --> 00:24:41.040
And then a follow on, I believe this from the same company, full disclosure, these guys

00:24:41.040 --> 00:24:42.160
sponsored Talk Python.

00:24:42.320 --> 00:24:44.520
But I've wanted to talk about this even before.

00:24:44.520 --> 00:24:51.260
So they have this thing, the service called Tonic that you can then point at your production

00:24:51.260 --> 00:24:56.780
database and it'll do things like generate me something that looks exactly like production

00:24:56.780 --> 00:25:01.920
data, but doesn't have any personally identifiable information so that I can give it to the developers

00:25:01.920 --> 00:25:08.580
to test with real looking data with real variations from our clients, but is sort of safe.

00:25:08.580 --> 00:25:12.620
Like if they lose their laptop or whatever, or they just leave it open, it's not going to

00:25:12.620 --> 00:25:13.240
destroy something.

00:25:13.240 --> 00:25:13.460
Right.

00:25:13.800 --> 00:25:13.940
Yeah.

00:25:13.940 --> 00:25:14.780
That's pretty cool.

00:25:14.780 --> 00:25:15.220
Yeah.

00:25:15.220 --> 00:25:22.600
So you basically connect it to your database and then it will go along and sort of create

00:25:22.600 --> 00:25:27.280
data that looks more like what you actually have instead of just this mockaroo data.

00:25:27.280 --> 00:25:28.260
So pretty neat.

00:25:28.260 --> 00:25:33.040
Anyway, if you need to do some testing, you need to generate fake data, not just for like

00:25:33.040 --> 00:25:37.040
pytest testing, but also UI development and just something to work with.

00:25:37.040 --> 00:25:38.140
These are both good options.

00:25:38.140 --> 00:25:38.900
Very cool.

00:25:38.900 --> 00:25:39.420
Yeah.

00:25:39.420 --> 00:25:39.880
Cool.

00:25:39.880 --> 00:25:40.040
Cool.

00:25:40.040 --> 00:25:42.920
Sam out in the audience says, this is fantastic.

00:25:42.920 --> 00:25:43.540
I agree.

00:25:43.540 --> 00:25:45.500
And Will says, yeah, super useful.

00:25:45.500 --> 00:25:50.360
I could see even using this for testing development of rich and textual out there.

00:25:50.360 --> 00:25:50.920
So very cool.

00:25:50.920 --> 00:25:51.940
All right.

00:25:51.940 --> 00:25:53.180
Vusile, off to you.

00:25:53.180 --> 00:25:53.700
Last one.

00:25:53.700 --> 00:25:54.440
All right.

00:25:54.440 --> 00:25:58.880
So this is a fun project that a good friend of mine, Daniele Procida made.

00:25:58.880 --> 00:26:01.260
He's demoed it at a couple of conferences.

00:26:01.260 --> 00:26:03.460
It's called the Brachio Graph.

00:26:03.460 --> 00:26:09.320
The goal for this project is to make a pin plotter powered by Python and make it as cheap

00:26:09.320 --> 00:26:12.320
as possible using common things you can find in the house.

00:26:12.840 --> 00:26:14.740
So it's a plotter.

00:26:14.740 --> 00:26:20.340
It uses a Raspberry Pi and ice cream stick and a clothespin to draw and a pencil, of course.

00:26:20.340 --> 00:26:21.680
Right.

00:26:22.020 --> 00:26:28.840
So it's got Python code that turns an image into, I think it's called a raster.

00:26:28.840 --> 00:26:34.100
It rasterizes an image into coordinates on a piece of paper.

00:26:34.100 --> 00:26:35.320
I could have used this yesterday.

00:26:35.320 --> 00:26:36.080
Oh my gosh.

00:26:36.080 --> 00:26:36.660
This is great.

00:26:36.660 --> 00:26:38.040
Yeah.

00:26:38.280 --> 00:26:43.220
So I don't know if I can play video here, but it looks pretty cool when it's actually printing

00:26:43.220 --> 00:26:45.020
out or plotting out an image.

00:26:45.020 --> 00:26:46.720
Let me see if I can get it to work here.

00:26:47.060 --> 00:26:54.140
But yeah, it has a motor that then does everything and it can draw very basic images.

00:26:54.140 --> 00:26:55.020
Oh, wow.

00:26:55.020 --> 00:26:57.840
It's a fun project that you can work on.

00:26:58.520 --> 00:27:02.740
And it costs, I mean, the setup for this costs less than 50 US dollars.

00:27:02.740 --> 00:27:05.200
And it's a pretty, pretty fun project.

00:27:05.200 --> 00:27:07.860
Oh, I would have gotten an A in art class if I had this.

00:27:10.080 --> 00:27:10.820
No, I love it.

00:27:10.820 --> 00:27:11.560
This is really neat.

00:27:11.560 --> 00:27:14.320
People should definitely play the video and watch it because it's fascinating.

00:27:14.320 --> 00:27:15.180
Yeah.

00:27:15.180 --> 00:27:15.580
Yeah.

00:27:15.580 --> 00:27:15.900
Yeah.

00:27:15.900 --> 00:27:23.140
The website has like a how-to guides and documentation on how to build this, what things you need,

00:27:23.140 --> 00:27:25.840
what sources to the software and everything.

00:27:25.840 --> 00:27:30.240
And it's also an open source project that anyone can contribute to if you're interested.

00:27:30.240 --> 00:27:31.440
This is really neat.

00:27:31.440 --> 00:27:37.520
This is one of the things I like about simple things like this is they're great projects to

00:27:37.520 --> 00:27:40.460
start kids with because it's very real and physical.

00:27:40.460 --> 00:27:41.020
Yeah.

00:27:41.020 --> 00:27:44.460
I was thinking this would be awesome in a teaching scenario as well.

00:27:44.460 --> 00:27:45.020
Yeah.

00:27:45.020 --> 00:27:45.480
Cool.

00:27:45.480 --> 00:27:46.100
All right.

00:27:46.100 --> 00:27:46.820
This is a great one.

00:27:46.820 --> 00:27:47.600
And I love it.

00:27:47.600 --> 00:27:49.700
Very neat to do with Python and stuff.

00:27:49.700 --> 00:27:50.260
All right.

00:27:50.260 --> 00:27:52.160
Well, I think that's it for our main items.

00:27:52.160 --> 00:27:54.140
Brian, do you got anything you'd like to share?

00:27:54.140 --> 00:28:00.720
Oh, we covered last, I think we covered last week that the Python issues were migrating to

00:28:00.720 --> 00:28:04.600
GitHub and it might be on April Fool's Day and it was not.

00:28:05.260 --> 00:28:08.080
So next plan looks like April 8th.

00:28:08.080 --> 00:28:09.280
Next, one more week.

00:28:09.280 --> 00:28:11.280
If we keep talking about it, it's never going to happen.

00:28:11.280 --> 00:28:11.880
Okay.

00:28:11.880 --> 00:28:14.140
Like a watch pot sort of a thing.

00:28:14.140 --> 00:28:14.780
Exactly.

00:28:14.780 --> 00:28:15.300
Yes.

00:28:15.300 --> 00:28:17.180
Well, I'm waiting for it to happen.

00:28:17.180 --> 00:28:18.260
I want it to happen.

00:28:18.260 --> 00:28:19.020
I know.

00:28:19.020 --> 00:28:21.960
The transformation will be complete at that point, right?

00:28:21.960 --> 00:28:25.480
So next week, we won't cover it at all unless it's already happened.

00:28:25.480 --> 00:28:28.240
But if it's delayed again, we won't cover it again until that.

00:28:28.240 --> 00:28:29.580
Yeah, exactly.

00:28:29.580 --> 00:28:31.260
We're not getting roped into this three times.

00:28:31.260 --> 00:28:33.880
Lucille, anything else you want to give a shout out to?

00:28:34.260 --> 00:28:34.720
Yeah, yeah.

00:28:34.720 --> 00:28:38.180
Just one thing is a project that I found recently.

00:28:38.180 --> 00:28:40.280
It's called Thunder Client.

00:28:40.280 --> 00:28:44.340
It's an alternative video code extension and it's lightweight.

00:28:44.340 --> 00:28:50.160
You download it and install it in less than a second and you can get started sending requests.

00:28:50.160 --> 00:28:52.660
And it has less setup than Postman.

00:28:52.660 --> 00:28:53.180
Right.

00:28:53.180 --> 00:28:56.480
And it doesn't need any, it's like, it's easy to install.

00:28:56.840 --> 00:29:01.500
Yeah, so if you were testing APIs, like construct a JSON thing, put this header in, you want to call it.

00:29:01.500 --> 00:29:03.220
Yeah, Thunder Client for VS Code.

00:29:03.220 --> 00:29:03.900
Very nice.

00:29:03.900 --> 00:29:04.500
Yeah.

00:29:04.500 --> 00:29:05.600
Thunder, Thunder.

00:29:05.600 --> 00:29:06.920
If you're using VS Code.

00:29:06.920 --> 00:29:08.880
Exactly.

00:29:08.880 --> 00:29:09.220
Yeah.

00:29:09.220 --> 00:29:09.540
Yeah.

00:29:09.540 --> 00:29:13.520
You just switch tabs, you know, instead of switching applications.

00:29:13.760 --> 00:29:15.820
So that shaves a few microseconds off your workflow.

00:29:15.820 --> 00:29:16.060
Yeah, exactly.

00:29:16.060 --> 00:29:17.740
That's cool.

00:29:17.740 --> 00:29:18.720
I love it.

00:29:18.720 --> 00:29:19.200
All right.

00:29:19.200 --> 00:29:19.500
Nice.

00:29:19.500 --> 00:29:22.440
I've got just one thing I believe today.

00:29:22.440 --> 00:29:23.100
This is really short.

00:29:23.220 --> 00:29:27.860
I've spoken about ingrok at ingrok.com before about how it's really cool for exposing.

00:29:27.860 --> 00:29:34.160
If you're like wanting to expose an API to the outside world that you're developing or you need to debug it.

00:29:34.160 --> 00:29:35.880
I've used this for like web hooks.

00:29:35.880 --> 00:29:39.420
So this company, I need to integrate with their web hook.

00:29:39.420 --> 00:29:41.540
So I need them to call this, but it's not working.

00:29:41.540 --> 00:29:43.860
So I want like a break point on my machine.

00:29:43.860 --> 00:29:45.680
But how do they get to my machine?

00:29:45.680 --> 00:29:51.060
Just run ingrok and it'll tunnel it right through the firewalls using SSH reverse tunnels.

00:29:51.060 --> 00:29:51.940
That's all good.

00:29:51.940 --> 00:30:01.540
What I discovered working on yet another integration project was that there's actually this super rich inspector that I think people haven't noticed in there.

00:30:01.540 --> 00:30:06.440
If you fire up an ingrok thing and then you go to look host 4040, every request comes through.

00:30:06.440 --> 00:30:14.340
You can see the summary, the HTTP headers, the cookies, the response, the status codes, the duration, all that.

00:30:14.340 --> 00:30:20.660
If you're using ingrok for that sort of use case, be sure to check out this like live web view that lets you dive into.

00:30:20.660 --> 00:30:28.540
It's almost like the dev tools, the network tab of the dev tools, but for just people coming in rather than you consuming stuff.

00:30:28.540 --> 00:30:29.200
So it's pretty cool.

00:30:29.200 --> 00:30:29.880
That's neat.

00:30:30.580 --> 00:30:32.240
Are you guys ready for a joke?

00:30:32.240 --> 00:30:32.960
Yes.

00:30:32.960 --> 00:30:35.680
Shall we finish it out with a joke?

00:30:35.680 --> 00:30:43.880
You may have heard recently that the Microsoft source code for Bing was got by the Lazarus group.

00:30:44.360 --> 00:30:49.560
And people thought this was some folks in like Brazil or somewhere in South America.

00:30:49.560 --> 00:30:52.420
It turns out it was a bunch of British teenagers.

00:30:53.200 --> 00:30:57.140
What about like $14 million in Bitcoin and whatever.

00:30:57.140 --> 00:31:02.340
So they had gotten a hold of some of the windows and Bing source code, I believe it was.

00:31:02.340 --> 00:31:07.760
And there was like, oh my gosh, is this going to reveal a bunch of zero days because people can go through the source code?

00:31:07.760 --> 00:31:11.800
Well, we don't do that much windows, at least on the server and Python.

00:31:11.800 --> 00:31:12.980
There's some, but not as much.

00:31:12.980 --> 00:31:14.480
But we use a lot of Linux, right?

00:31:14.980 --> 00:31:19.340
For all the Talk Python, PythonByte stuff, we've got like a fleet of eight Linux servers.

00:31:19.340 --> 00:31:28.580
Now, Brian, when I saw this headline, I really began to worry that maybe some vulnerabilities would be discovered or some kind of problem would happen here.

00:31:28.580 --> 00:31:37.980
So the headline is, Linus Torvalds confirms the Lapsus breach after hackers publish the Linux kernel source code to the internet.

00:31:37.980 --> 00:31:40.120
Okay.

00:31:41.560 --> 00:31:58.400
In a blog post on Tuesday, published hours after the Lapsus posted a torrent file containing partial source code from the Linux kernel, the geek man himself revealed that his branch was cloned by the hacking group, granting attackers unlimited power to the article stops there.

00:31:58.400 --> 00:32:00.440
Oh, man.

00:32:00.440 --> 00:32:02.080
How many times do you have to read?

00:32:02.080 --> 00:32:04.200
Exactly.

00:32:04.200 --> 00:32:07.960
I think being open source, it's probably okay.

00:32:07.960 --> 00:32:09.940
Yeah.

00:32:09.940 --> 00:32:10.420
Yeah.

00:32:10.420 --> 00:32:10.780
Yeah.

00:32:11.500 --> 00:32:12.460
Oh, no.

00:32:12.460 --> 00:32:14.300
It's published the source.

00:32:14.300 --> 00:32:16.060
They published the source to Linux.

00:32:16.060 --> 00:32:17.200
What are we going to do?

00:32:17.200 --> 00:32:22.280
The programming humor just never stops.

00:32:22.280 --> 00:32:23.040
I love it.

00:32:23.040 --> 00:32:25.940
So they published the Bing source code?

00:32:25.940 --> 00:32:28.060
I think they got some of the Bing source code.

00:32:28.060 --> 00:32:29.880
Maybe Cortana.

00:32:29.880 --> 00:32:32.220
I can't remember exactly what it was, but it was some of these services.

00:32:32.220 --> 00:32:34.460
And I think the Windows source code as well.

00:32:34.460 --> 00:32:35.520
I was surprised.

00:32:35.520 --> 00:32:41.340
So I don't pay too much attention to the blog traffic stuff, but I was looking the other day after I'd put up.

00:32:41.440 --> 00:32:43.780
I was looking at a bunch of the transcripts for testing code.

00:32:43.780 --> 00:32:46.340
I was curious how much we're just getting hit.

00:32:46.340 --> 00:32:52.700
And for Python test.com, I'm getting more traffic from Bing than from Google.

00:32:53.500 --> 00:32:54.400
How interesting.

00:32:54.400 --> 00:32:55.240
It's interesting.

00:32:55.240 --> 00:32:55.260
It's interesting.

00:32:55.260 --> 00:32:57.980
All of a sudden, Bing's pretty awesome, isn't it?

00:32:57.980 --> 00:33:01.000
Well, it's got nice pictures.

00:33:01.000 --> 00:33:02.000
I'll tell you that.

00:33:02.000 --> 00:33:03.940
It's got nice background pictures.

00:33:03.940 --> 00:33:04.260
It does.

00:33:04.260 --> 00:33:07.100
Actually, in terms of beauty, it's really nice.

00:33:07.100 --> 00:33:10.380
And I end up using DuckDuckGo.

00:33:10.920 --> 00:33:14.680
So when I'm using DuckDuckGo, I know they've got a ton of different sources.

00:33:14.680 --> 00:33:17.420
But one of the sources they use for data, I believe, is also Bing.

00:33:17.420 --> 00:33:18.880
It's all right.

00:33:18.880 --> 00:33:20.020
It's all right.

00:33:20.020 --> 00:33:20.780
It's all right.

00:33:20.780 --> 00:33:25.440
Well, Vusili, it was really great to have you here with us.

00:33:25.440 --> 00:33:26.480
And Brian.

00:33:26.480 --> 00:33:27.260
Yep.

00:33:27.260 --> 00:33:27.920
I thought it was mine.

00:33:27.920 --> 00:33:30.520
Yeah, it was great to have a chat with you as always.

00:33:30.520 --> 00:33:31.340
All right.

00:33:31.340 --> 00:33:32.020
Bye, everyone.

00:33:32.020 --> 00:33:32.240
Thank you.

00:33:32.240 --> 00:33:32.600
Next week.

